/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>);
impl <T> __IncompleteArrayField<T> {
    #[inline]
    pub fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ptr(&self) -> *const T { ::core::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut_ptr(&mut self) -> *mut T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl <T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
impl <T> ::core::clone::Clone for __IncompleteArrayField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::core::marker::Copy for __IncompleteArrayField<T> { }
#[repr(C)]
pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
impl <T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self { __BindgenUnionField(::core::marker::PhantomData) }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T { ::core::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T { ::core::mem::transmute(self) }
}
impl <T> ::core::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self { Self::new() }
}
impl <T> ::core::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::core::marker::Copy for __BindgenUnionField<T> { }
impl <T> ::core::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl <T> ::core::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) { }
}
impl <T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool { true }
}
impl <T> ::core::cmp::Eq for __BindgenUnionField<T> { }
pub const __GNUCLIKE_ASM: ::kernel::sys::raw::c_uint = 3;
pub const __GNUCLIKE___TYPEOF: ::kernel::sys::raw::c_uint = 1;
pub const __GNUCLIKE___OFFSETOF: ::kernel::sys::raw::c_uint = 1;
pub const __GNUCLIKE___SECTION: ::kernel::sys::raw::c_uint = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: ::kernel::sys::raw::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: ::kernel::sys::raw::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: ::kernel::sys::raw::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: ::kernel::sys::raw::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: ::kernel::sys::raw::c_uint = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: ::kernel::sys::raw::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: ::kernel::sys::raw::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: ::kernel::sys::raw::c_uint = 1;
pub const __CC_SUPPORTS_INLINE: ::kernel::sys::raw::c_uint = 1;
pub const __CC_SUPPORTS___INLINE: ::kernel::sys::raw::c_uint = 1;
pub const __CC_SUPPORTS___INLINE__: ::kernel::sys::raw::c_uint = 1;
pub const __CC_SUPPORTS___FUNC__: ::kernel::sys::raw::c_uint = 1;
pub const __CC_SUPPORTS_WARNING: ::kernel::sys::raw::c_uint = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: ::kernel::sys::raw::c_uint = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: ::kernel::sys::raw::c_uint = 1;
pub const __POSIX_VISIBLE: ::kernel::sys::raw::c_uint = 200809;
pub const __XSI_VISIBLE: ::kernel::sys::raw::c_uint = 700;
pub const __BSD_VISIBLE: ::kernel::sys::raw::c_uint = 1;
pub const __ISO_C_VISIBLE: ::kernel::sys::raw::c_uint = 2011;
pub const __EXT1_VISIBLE: ::kernel::sys::raw::c_uint = 1;
pub const __CHAR_BIT: ::kernel::sys::raw::c_uint = 8;
pub const __SCHAR_MAX: ::kernel::sys::raw::c_uint = 127;
pub const __SCHAR_MIN: ::kernel::sys::raw::c_int = -128;
pub const __UCHAR_MAX: ::kernel::sys::raw::c_uint = 255;
pub const __USHRT_MAX: ::kernel::sys::raw::c_uint = 65535;
pub const __SHRT_MAX: ::kernel::sys::raw::c_uint = 32767;
pub const __SHRT_MIN: ::kernel::sys::raw::c_int = -32768;
pub const __UINT_MAX: ::kernel::sys::raw::c_uint = 4294967295;
pub const __INT_MAX: ::kernel::sys::raw::c_uint = 2147483647;
pub const __INT_MIN: ::kernel::sys::raw::c_int = -2147483648;
pub const __ULONG_MAX: ::kernel::sys::raw::c_int = -1;
pub const __LONG_MAX: ::kernel::sys::raw::c_ulonglong = 9223372036854775807;
pub const __LONG_MIN: ::kernel::sys::raw::c_longlong = -9223372036854775808;
pub const __ULLONG_MAX: ::kernel::sys::raw::c_int = -1;
pub const __LLONG_MAX: ::kernel::sys::raw::c_ulonglong = 9223372036854775807;
pub const __LLONG_MIN: ::kernel::sys::raw::c_longlong = -9223372036854775808;
pub const __SSIZE_MAX: ::kernel::sys::raw::c_ulonglong = 9223372036854775807;
pub const __SIZE_T_MAX: ::kernel::sys::raw::c_int = -1;
pub const __OFF_MAX: ::kernel::sys::raw::c_ulonglong = 9223372036854775807;
pub const __OFF_MIN: ::kernel::sys::raw::c_longlong = -9223372036854775808;
pub const __UQUAD_MAX: ::kernel::sys::raw::c_int = -1;
pub const __QUAD_MAX: ::kernel::sys::raw::c_ulonglong = 9223372036854775807;
pub const __QUAD_MIN: ::kernel::sys::raw::c_longlong = -9223372036854775808;
pub const __LONG_BIT: ::kernel::sys::raw::c_uint = 64;
pub const __WORD_BIT: ::kernel::sys::raw::c_uint = 32;
pub const __MINSIGSTKSZ: ::kernel::sys::raw::c_uint = 2048;
pub const __WCHAR_MIN: ::kernel::sys::raw::c_int = -2147483648;
pub const __WCHAR_MAX: ::kernel::sys::raw::c_uint = 2147483647;
pub const _QUAD_HIGHWORD: ::kernel::sys::raw::c_uint = 1;
pub const _QUAD_LOWWORD: ::kernel::sys::raw::c_uint = 0;
pub const _LITTLE_ENDIAN: ::kernel::sys::raw::c_uint = 1234;
pub const _BIG_ENDIAN: ::kernel::sys::raw::c_uint = 4321;
pub const _PDP_ENDIAN: ::kernel::sys::raw::c_uint = 3412;
pub const _BYTE_ORDER: ::kernel::sys::raw::c_uint = 1234;
pub const LITTLE_ENDIAN: ::kernel::sys::raw::c_uint = 1234;
pub const BIG_ENDIAN: ::kernel::sys::raw::c_uint = 4321;
pub const PDP_ENDIAN: ::kernel::sys::raw::c_uint = 3412;
pub const BYTE_ORDER: ::kernel::sys::raw::c_uint = 1234;
pub const __bool_true_false_are_defined: ::kernel::sys::raw::c_uint = 1;
pub const false_: ::kernel::sys::raw::c_uint = 0;
pub const true_: ::kernel::sys::raw::c_uint = 1;
pub const _SIG_WORDS: ::kernel::sys::raw::c_uint = 4;
pub const _SIG_MAXSIG: ::kernel::sys::raw::c_uint = 128;
pub const FD_SETSIZE: ::kernel::sys::raw::c_uint = 1024;
pub const SOCK_STREAM: ::kernel::sys::raw::c_uint = 1;
pub const SOCK_DGRAM: ::kernel::sys::raw::c_uint = 2;
pub const SOCK_RAW: ::kernel::sys::raw::c_uint = 3;
pub const SOCK_RDM: ::kernel::sys::raw::c_uint = 4;
pub const SOCK_SEQPACKET: ::kernel::sys::raw::c_uint = 5;
pub const SOCK_CLOEXEC: ::kernel::sys::raw::c_uint = 268435456;
pub const SOCK_NONBLOCK: ::kernel::sys::raw::c_uint = 536870912;
pub const ACCEPT4_INHERIT: ::kernel::sys::raw::c_uint = 1;
pub const ACCEPT4_COMPAT: ::kernel::sys::raw::c_uint = 2;
pub const SO_DEBUG: ::kernel::sys::raw::c_uint = 1;
pub const SO_ACCEPTCONN: ::kernel::sys::raw::c_uint = 2;
pub const SO_REUSEADDR: ::kernel::sys::raw::c_uint = 4;
pub const SO_KEEPALIVE: ::kernel::sys::raw::c_uint = 8;
pub const SO_DONTROUTE: ::kernel::sys::raw::c_uint = 16;
pub const SO_BROADCAST: ::kernel::sys::raw::c_uint = 32;
pub const SO_USELOOPBACK: ::kernel::sys::raw::c_uint = 64;
pub const SO_LINGER: ::kernel::sys::raw::c_uint = 128;
pub const SO_OOBINLINE: ::kernel::sys::raw::c_uint = 256;
pub const SO_REUSEPORT: ::kernel::sys::raw::c_uint = 512;
pub const SO_TIMESTAMP: ::kernel::sys::raw::c_uint = 1024;
pub const SO_NOSIGPIPE: ::kernel::sys::raw::c_uint = 2048;
pub const SO_ACCEPTFILTER: ::kernel::sys::raw::c_uint = 4096;
pub const SO_BINTIME: ::kernel::sys::raw::c_uint = 8192;
pub const SO_NO_OFFLOAD: ::kernel::sys::raw::c_uint = 16384;
pub const SO_NO_DDP: ::kernel::sys::raw::c_uint = 32768;
pub const SO_SNDBUF: ::kernel::sys::raw::c_uint = 4097;
pub const SO_RCVBUF: ::kernel::sys::raw::c_uint = 4098;
pub const SO_SNDLOWAT: ::kernel::sys::raw::c_uint = 4099;
pub const SO_RCVLOWAT: ::kernel::sys::raw::c_uint = 4100;
pub const SO_SNDTIMEO: ::kernel::sys::raw::c_uint = 4101;
pub const SO_RCVTIMEO: ::kernel::sys::raw::c_uint = 4102;
pub const SO_ERROR: ::kernel::sys::raw::c_uint = 4103;
pub const SO_TYPE: ::kernel::sys::raw::c_uint = 4104;
pub const SO_LABEL: ::kernel::sys::raw::c_uint = 4105;
pub const SO_PEERLABEL: ::kernel::sys::raw::c_uint = 4112;
pub const SO_LISTENQLIMIT: ::kernel::sys::raw::c_uint = 4113;
pub const SO_LISTENQLEN: ::kernel::sys::raw::c_uint = 4114;
pub const SO_LISTENINCQLEN: ::kernel::sys::raw::c_uint = 4115;
pub const SO_SETFIB: ::kernel::sys::raw::c_uint = 4116;
pub const SO_USER_COOKIE: ::kernel::sys::raw::c_uint = 4117;
pub const SO_PROTOCOL: ::kernel::sys::raw::c_uint = 4118;
pub const SO_PROTOTYPE: ::kernel::sys::raw::c_uint = 4118;
pub const SO_TS_CLOCK: ::kernel::sys::raw::c_uint = 4119;
pub const SO_MAX_PACING_RATE: ::kernel::sys::raw::c_uint = 4120;
pub const SO_TS_REALTIME_MICRO: ::kernel::sys::raw::c_uint = 0;
pub const SO_TS_BINTIME: ::kernel::sys::raw::c_uint = 1;
pub const SO_TS_REALTIME: ::kernel::sys::raw::c_uint = 2;
pub const SO_TS_MONOTONIC: ::kernel::sys::raw::c_uint = 3;
pub const SO_TS_DEFAULT: ::kernel::sys::raw::c_uint = 0;
pub const SO_TS_CLOCK_MAX: ::kernel::sys::raw::c_uint = 3;
pub const SO_VENDOR: ::kernel::sys::raw::c_uint = 2147483648;
pub const SOL_SOCKET: ::kernel::sys::raw::c_uint = 65535;
pub const AF_UNSPEC: ::kernel::sys::raw::c_uint = 0;
pub const AF_UNIX: ::kernel::sys::raw::c_uint = 1;
pub const AF_INET: ::kernel::sys::raw::c_uint = 2;
pub const AF_IMPLINK: ::kernel::sys::raw::c_uint = 3;
pub const AF_PUP: ::kernel::sys::raw::c_uint = 4;
pub const AF_CHAOS: ::kernel::sys::raw::c_uint = 5;
pub const AF_NETBIOS: ::kernel::sys::raw::c_uint = 6;
pub const AF_ISO: ::kernel::sys::raw::c_uint = 7;
pub const AF_OSI: ::kernel::sys::raw::c_uint = 7;
pub const AF_ECMA: ::kernel::sys::raw::c_uint = 8;
pub const AF_DATAKIT: ::kernel::sys::raw::c_uint = 9;
pub const AF_CCITT: ::kernel::sys::raw::c_uint = 10;
pub const AF_SNA: ::kernel::sys::raw::c_uint = 11;
pub const AF_DECnet: ::kernel::sys::raw::c_uint = 12;
pub const AF_DLI: ::kernel::sys::raw::c_uint = 13;
pub const AF_LAT: ::kernel::sys::raw::c_uint = 14;
pub const AF_HYLINK: ::kernel::sys::raw::c_uint = 15;
pub const AF_APPLETALK: ::kernel::sys::raw::c_uint = 16;
pub const AF_ROUTE: ::kernel::sys::raw::c_uint = 17;
pub const AF_LINK: ::kernel::sys::raw::c_uint = 18;
pub const pseudo_AF_XTP: ::kernel::sys::raw::c_uint = 19;
pub const AF_COIP: ::kernel::sys::raw::c_uint = 20;
pub const AF_CNT: ::kernel::sys::raw::c_uint = 21;
pub const pseudo_AF_RTIP: ::kernel::sys::raw::c_uint = 22;
pub const AF_IPX: ::kernel::sys::raw::c_uint = 23;
pub const AF_SIP: ::kernel::sys::raw::c_uint = 24;
pub const pseudo_AF_PIP: ::kernel::sys::raw::c_uint = 25;
pub const AF_ISDN: ::kernel::sys::raw::c_uint = 26;
pub const AF_E164: ::kernel::sys::raw::c_uint = 26;
pub const pseudo_AF_KEY: ::kernel::sys::raw::c_uint = 27;
pub const AF_INET6: ::kernel::sys::raw::c_uint = 28;
pub const AF_NATM: ::kernel::sys::raw::c_uint = 29;
pub const AF_ATM: ::kernel::sys::raw::c_uint = 30;
pub const pseudo_AF_HDRCMPLT: ::kernel::sys::raw::c_uint = 31;
pub const AF_NETGRAPH: ::kernel::sys::raw::c_uint = 32;
pub const AF_SLOW: ::kernel::sys::raw::c_uint = 33;
pub const AF_SCLUSTER: ::kernel::sys::raw::c_uint = 34;
pub const AF_ARP: ::kernel::sys::raw::c_uint = 35;
pub const AF_BLUETOOTH: ::kernel::sys::raw::c_uint = 36;
pub const AF_IEEE80211: ::kernel::sys::raw::c_uint = 37;
pub const AF_INET_SDP: ::kernel::sys::raw::c_uint = 40;
pub const AF_INET6_SDP: ::kernel::sys::raw::c_uint = 42;
pub const AF_MAX: ::kernel::sys::raw::c_uint = 42;
pub const AF_VENDOR00: ::kernel::sys::raw::c_uint = 39;
pub const AF_VENDOR01: ::kernel::sys::raw::c_uint = 41;
pub const AF_VENDOR02: ::kernel::sys::raw::c_uint = 43;
pub const AF_VENDOR03: ::kernel::sys::raw::c_uint = 45;
pub const AF_VENDOR04: ::kernel::sys::raw::c_uint = 47;
pub const AF_VENDOR05: ::kernel::sys::raw::c_uint = 49;
pub const AF_VENDOR06: ::kernel::sys::raw::c_uint = 51;
pub const AF_VENDOR07: ::kernel::sys::raw::c_uint = 53;
pub const AF_VENDOR08: ::kernel::sys::raw::c_uint = 55;
pub const AF_VENDOR09: ::kernel::sys::raw::c_uint = 57;
pub const AF_VENDOR10: ::kernel::sys::raw::c_uint = 59;
pub const AF_VENDOR11: ::kernel::sys::raw::c_uint = 61;
pub const AF_VENDOR12: ::kernel::sys::raw::c_uint = 63;
pub const AF_VENDOR13: ::kernel::sys::raw::c_uint = 65;
pub const AF_VENDOR14: ::kernel::sys::raw::c_uint = 67;
pub const AF_VENDOR15: ::kernel::sys::raw::c_uint = 69;
pub const AF_VENDOR16: ::kernel::sys::raw::c_uint = 71;
pub const AF_VENDOR17: ::kernel::sys::raw::c_uint = 73;
pub const AF_VENDOR18: ::kernel::sys::raw::c_uint = 75;
pub const AF_VENDOR19: ::kernel::sys::raw::c_uint = 77;
pub const AF_VENDOR20: ::kernel::sys::raw::c_uint = 79;
pub const AF_VENDOR21: ::kernel::sys::raw::c_uint = 81;
pub const AF_VENDOR22: ::kernel::sys::raw::c_uint = 83;
pub const AF_VENDOR23: ::kernel::sys::raw::c_uint = 85;
pub const AF_VENDOR24: ::kernel::sys::raw::c_uint = 87;
pub const AF_VENDOR25: ::kernel::sys::raw::c_uint = 89;
pub const AF_VENDOR26: ::kernel::sys::raw::c_uint = 91;
pub const AF_VENDOR27: ::kernel::sys::raw::c_uint = 93;
pub const AF_VENDOR28: ::kernel::sys::raw::c_uint = 95;
pub const AF_VENDOR29: ::kernel::sys::raw::c_uint = 97;
pub const AF_VENDOR30: ::kernel::sys::raw::c_uint = 99;
pub const AF_VENDOR31: ::kernel::sys::raw::c_uint = 101;
pub const AF_VENDOR32: ::kernel::sys::raw::c_uint = 103;
pub const AF_VENDOR33: ::kernel::sys::raw::c_uint = 105;
pub const AF_VENDOR34: ::kernel::sys::raw::c_uint = 107;
pub const AF_VENDOR35: ::kernel::sys::raw::c_uint = 109;
pub const AF_VENDOR36: ::kernel::sys::raw::c_uint = 111;
pub const AF_VENDOR37: ::kernel::sys::raw::c_uint = 113;
pub const AF_VENDOR38: ::kernel::sys::raw::c_uint = 115;
pub const AF_VENDOR39: ::kernel::sys::raw::c_uint = 117;
pub const AF_VENDOR40: ::kernel::sys::raw::c_uint = 119;
pub const AF_VENDOR41: ::kernel::sys::raw::c_uint = 121;
pub const AF_VENDOR42: ::kernel::sys::raw::c_uint = 123;
pub const AF_VENDOR43: ::kernel::sys::raw::c_uint = 125;
pub const AF_VENDOR44: ::kernel::sys::raw::c_uint = 127;
pub const AF_VENDOR45: ::kernel::sys::raw::c_uint = 129;
pub const AF_VENDOR46: ::kernel::sys::raw::c_uint = 131;
pub const AF_VENDOR47: ::kernel::sys::raw::c_uint = 133;
pub const SOCK_MAXADDRLEN: ::kernel::sys::raw::c_uint = 255;
pub const _SS_MAXSIZE: ::kernel::sys::raw::c_uint = 128;
pub const PF_UNSPEC: ::kernel::sys::raw::c_uint = 0;
pub const PF_INET: ::kernel::sys::raw::c_uint = 2;
pub const PF_IMPLINK: ::kernel::sys::raw::c_uint = 3;
pub const PF_PUP: ::kernel::sys::raw::c_uint = 4;
pub const PF_CHAOS: ::kernel::sys::raw::c_uint = 5;
pub const PF_NETBIOS: ::kernel::sys::raw::c_uint = 6;
pub const PF_ISO: ::kernel::sys::raw::c_uint = 7;
pub const PF_OSI: ::kernel::sys::raw::c_uint = 7;
pub const PF_ECMA: ::kernel::sys::raw::c_uint = 8;
pub const PF_DATAKIT: ::kernel::sys::raw::c_uint = 9;
pub const PF_CCITT: ::kernel::sys::raw::c_uint = 10;
pub const PF_SNA: ::kernel::sys::raw::c_uint = 11;
pub const PF_DECnet: ::kernel::sys::raw::c_uint = 12;
pub const PF_DLI: ::kernel::sys::raw::c_uint = 13;
pub const PF_LAT: ::kernel::sys::raw::c_uint = 14;
pub const PF_HYLINK: ::kernel::sys::raw::c_uint = 15;
pub const PF_APPLETALK: ::kernel::sys::raw::c_uint = 16;
pub const PF_ROUTE: ::kernel::sys::raw::c_uint = 17;
pub const PF_LINK: ::kernel::sys::raw::c_uint = 18;
pub const PF_XTP: ::kernel::sys::raw::c_uint = 19;
pub const PF_COIP: ::kernel::sys::raw::c_uint = 20;
pub const PF_CNT: ::kernel::sys::raw::c_uint = 21;
pub const PF_SIP: ::kernel::sys::raw::c_uint = 24;
pub const PF_IPX: ::kernel::sys::raw::c_uint = 23;
pub const PF_RTIP: ::kernel::sys::raw::c_uint = 22;
pub const PF_PIP: ::kernel::sys::raw::c_uint = 25;
pub const PF_ISDN: ::kernel::sys::raw::c_uint = 26;
pub const PF_KEY: ::kernel::sys::raw::c_uint = 27;
pub const PF_INET6: ::kernel::sys::raw::c_uint = 28;
pub const PF_NATM: ::kernel::sys::raw::c_uint = 29;
pub const PF_ATM: ::kernel::sys::raw::c_uint = 30;
pub const PF_NETGRAPH: ::kernel::sys::raw::c_uint = 32;
pub const PF_SLOW: ::kernel::sys::raw::c_uint = 33;
pub const PF_SCLUSTER: ::kernel::sys::raw::c_uint = 34;
pub const PF_ARP: ::kernel::sys::raw::c_uint = 35;
pub const PF_BLUETOOTH: ::kernel::sys::raw::c_uint = 36;
pub const PF_IEEE80211: ::kernel::sys::raw::c_uint = 37;
pub const PF_INET_SDP: ::kernel::sys::raw::c_uint = 40;
pub const PF_INET6_SDP: ::kernel::sys::raw::c_uint = 42;
pub const PF_MAX: ::kernel::sys::raw::c_uint = 42;
pub const NET_RT_DUMP: ::kernel::sys::raw::c_uint = 1;
pub const NET_RT_FLAGS: ::kernel::sys::raw::c_uint = 2;
pub const NET_RT_IFLIST: ::kernel::sys::raw::c_uint = 3;
pub const NET_RT_IFMALIST: ::kernel::sys::raw::c_uint = 4;
pub const NET_RT_IFLISTL: ::kernel::sys::raw::c_uint = 5;
pub const SOMAXCONN: ::kernel::sys::raw::c_uint = 128;
pub const MSG_OOB: ::kernel::sys::raw::c_uint = 1;
pub const MSG_PEEK: ::kernel::sys::raw::c_uint = 2;
pub const MSG_DONTROUTE: ::kernel::sys::raw::c_uint = 4;
pub const MSG_EOR: ::kernel::sys::raw::c_uint = 8;
pub const MSG_TRUNC: ::kernel::sys::raw::c_uint = 16;
pub const MSG_CTRUNC: ::kernel::sys::raw::c_uint = 32;
pub const MSG_WAITALL: ::kernel::sys::raw::c_uint = 64;
pub const MSG_DONTWAIT: ::kernel::sys::raw::c_uint = 128;
pub const MSG_EOF: ::kernel::sys::raw::c_uint = 256;
pub const MSG_NOTIFICATION: ::kernel::sys::raw::c_uint = 8192;
pub const MSG_NBIO: ::kernel::sys::raw::c_uint = 16384;
pub const MSG_COMPAT: ::kernel::sys::raw::c_uint = 32768;
pub const MSG_SOCALLBCK: ::kernel::sys::raw::c_uint = 65536;
pub const MSG_NOSIGNAL: ::kernel::sys::raw::c_uint = 131072;
pub const MSG_CMSG_CLOEXEC: ::kernel::sys::raw::c_uint = 262144;
pub const MSG_WAITFORONE: ::kernel::sys::raw::c_uint = 524288;
pub const MSG_MORETOCOME: ::kernel::sys::raw::c_uint = 1048576;
pub const CMGROUP_MAX: ::kernel::sys::raw::c_uint = 16;
pub const SCM_RIGHTS: ::kernel::sys::raw::c_uint = 1;
pub const SCM_TIMESTAMP: ::kernel::sys::raw::c_uint = 2;
pub const SCM_CREDS: ::kernel::sys::raw::c_uint = 3;
pub const SCM_BINTIME: ::kernel::sys::raw::c_uint = 4;
pub const SCM_REALTIME: ::kernel::sys::raw::c_uint = 5;
pub const SCM_MONOTONIC: ::kernel::sys::raw::c_uint = 6;
pub const SCM_TIME_INFO: ::kernel::sys::raw::c_uint = 7;
pub const ST_INFO_HW: ::kernel::sys::raw::c_uint = 1;
pub const ST_INFO_HW_HPREC: ::kernel::sys::raw::c_uint = 2;
pub const SHUT_RD: ::kernel::sys::raw::c_uint = 0;
pub const SHUT_WR: ::kernel::sys::raw::c_uint = 1;
pub const SHUT_RDWR: ::kernel::sys::raw::c_uint = 2;
pub const PRU_FLUSH_RD: ::kernel::sys::raw::c_uint = 0;
pub const PRU_FLUSH_WR: ::kernel::sys::raw::c_uint = 1;
pub const PRU_FLUSH_RDWR: ::kernel::sys::raw::c_uint = 2;
pub const SF_NODISKIO: ::kernel::sys::raw::c_uint = 1;
pub const SF_MNOWAIT: ::kernel::sys::raw::c_uint = 2;
pub const SF_SYNC: ::kernel::sys::raw::c_uint = 4;
pub const SF_USER_READAHEAD: ::kernel::sys::raw::c_uint = 8;
pub const SF_NOCACHE: ::kernel::sys::raw::c_uint = 16;
pub const IF_NAMESIZE: ::kernel::sys::raw::c_uint = 16;
pub const IFNAMSIZ: ::kernel::sys::raw::c_uint = 16;
pub const IF_MAXUNIT: ::kernel::sys::raw::c_uint = 32767;
pub const IFF_UP: ::kernel::sys::raw::c_uint = 1;
pub const IFF_BROADCAST: ::kernel::sys::raw::c_uint = 2;
pub const IFF_DEBUG: ::kernel::sys::raw::c_uint = 4;
pub const IFF_LOOPBACK: ::kernel::sys::raw::c_uint = 8;
pub const IFF_POINTOPOINT: ::kernel::sys::raw::c_uint = 16;
pub const IFF_DRV_RUNNING: ::kernel::sys::raw::c_uint = 64;
pub const IFF_NOARP: ::kernel::sys::raw::c_uint = 128;
pub const IFF_PROMISC: ::kernel::sys::raw::c_uint = 256;
pub const IFF_ALLMULTI: ::kernel::sys::raw::c_uint = 512;
pub const IFF_DRV_OACTIVE: ::kernel::sys::raw::c_uint = 1024;
pub const IFF_SIMPLEX: ::kernel::sys::raw::c_uint = 2048;
pub const IFF_LINK0: ::kernel::sys::raw::c_uint = 4096;
pub const IFF_LINK1: ::kernel::sys::raw::c_uint = 8192;
pub const IFF_LINK2: ::kernel::sys::raw::c_uint = 16384;
pub const IFF_ALTPHYS: ::kernel::sys::raw::c_uint = 16384;
pub const IFF_MULTICAST: ::kernel::sys::raw::c_uint = 32768;
pub const IFF_CANTCONFIG: ::kernel::sys::raw::c_uint = 65536;
pub const IFF_PPROMISC: ::kernel::sys::raw::c_uint = 131072;
pub const IFF_MONITOR: ::kernel::sys::raw::c_uint = 262144;
pub const IFF_STATICARP: ::kernel::sys::raw::c_uint = 524288;
pub const IFF_DYING: ::kernel::sys::raw::c_uint = 2097152;
pub const IFF_RENAMING: ::kernel::sys::raw::c_uint = 4194304;
pub const IFF_NOGROUP: ::kernel::sys::raw::c_uint = 8388608;
pub const IFF_CANTCHANGE: ::kernel::sys::raw::c_uint = 2199378;
pub const LINK_STATE_UNKNOWN: ::kernel::sys::raw::c_uint = 0;
pub const LINK_STATE_DOWN: ::kernel::sys::raw::c_uint = 1;
pub const LINK_STATE_UP: ::kernel::sys::raw::c_uint = 2;
pub const IFCAP_RXCSUM: ::kernel::sys::raw::c_uint = 1;
pub const IFCAP_TXCSUM: ::kernel::sys::raw::c_uint = 2;
pub const IFCAP_NETCONS: ::kernel::sys::raw::c_uint = 4;
pub const IFCAP_VLAN_MTU: ::kernel::sys::raw::c_uint = 8;
pub const IFCAP_VLAN_HWTAGGING: ::kernel::sys::raw::c_uint = 16;
pub const IFCAP_JUMBO_MTU: ::kernel::sys::raw::c_uint = 32;
pub const IFCAP_POLLING: ::kernel::sys::raw::c_uint = 64;
pub const IFCAP_VLAN_HWCSUM: ::kernel::sys::raw::c_uint = 128;
pub const IFCAP_TSO4: ::kernel::sys::raw::c_uint = 256;
pub const IFCAP_TSO6: ::kernel::sys::raw::c_uint = 512;
pub const IFCAP_LRO: ::kernel::sys::raw::c_uint = 1024;
pub const IFCAP_WOL_UCAST: ::kernel::sys::raw::c_uint = 2048;
pub const IFCAP_WOL_MCAST: ::kernel::sys::raw::c_uint = 4096;
pub const IFCAP_WOL_MAGIC: ::kernel::sys::raw::c_uint = 8192;
pub const IFCAP_TOE4: ::kernel::sys::raw::c_uint = 16384;
pub const IFCAP_TOE6: ::kernel::sys::raw::c_uint = 32768;
pub const IFCAP_VLAN_HWFILTER: ::kernel::sys::raw::c_uint = 65536;
pub const IFCAP_VLAN_HWTSO: ::kernel::sys::raw::c_uint = 262144;
pub const IFCAP_LINKSTATE: ::kernel::sys::raw::c_uint = 524288;
pub const IFCAP_NETMAP: ::kernel::sys::raw::c_uint = 1048576;
pub const IFCAP_RXCSUM_IPV6: ::kernel::sys::raw::c_uint = 2097152;
pub const IFCAP_TXCSUM_IPV6: ::kernel::sys::raw::c_uint = 4194304;
pub const IFCAP_HWSTATS: ::kernel::sys::raw::c_uint = 8388608;
pub const IFCAP_TXRTLMT: ::kernel::sys::raw::c_uint = 16777216;
pub const IFCAP_HWRXTSTMP: ::kernel::sys::raw::c_uint = 33554432;
pub const IFCAP_HWCSUM_IPV6: ::kernel::sys::raw::c_uint = 6291456;
pub const IFCAP_HWCSUM: ::kernel::sys::raw::c_uint = 3;
pub const IFCAP_TSO: ::kernel::sys::raw::c_uint = 768;
pub const IFCAP_WOL: ::kernel::sys::raw::c_uint = 14336;
pub const IFCAP_TOE: ::kernel::sys::raw::c_uint = 49152;
pub const IFCAP_CANTCHANGE: ::kernel::sys::raw::c_uint = 1048576;
pub const IFQ_MAXLEN: ::kernel::sys::raw::c_uint = 50;
pub const IFNET_SLOWHZ: ::kernel::sys::raw::c_uint = 1;
pub const IFAN_ARRIVAL: ::kernel::sys::raw::c_uint = 0;
pub const IFAN_DEPARTURE: ::kernel::sys::raw::c_uint = 1;
pub const IFSTATMAX: ::kernel::sys::raw::c_uint = 800;
pub const IFG_ALL: &'static [u8; 4usize] = b"all\x00";
pub const IFG_EGRESS: &'static [u8; 7usize] = b"egress\x00";
pub const RSS_FUNC_NONE: ::kernel::sys::raw::c_uint = 0;
pub const RSS_FUNC_PRIVATE: ::kernel::sys::raw::c_uint = 1;
pub const RSS_FUNC_TOEPLITZ: ::kernel::sys::raw::c_uint = 2;
pub const RSS_TYPE_IPV4: ::kernel::sys::raw::c_uint = 1;
pub const RSS_TYPE_TCP_IPV4: ::kernel::sys::raw::c_uint = 2;
pub const RSS_TYPE_IPV6: ::kernel::sys::raw::c_uint = 4;
pub const RSS_TYPE_IPV6_EX: ::kernel::sys::raw::c_uint = 8;
pub const RSS_TYPE_TCP_IPV6: ::kernel::sys::raw::c_uint = 16;
pub const RSS_TYPE_TCP_IPV6_EX: ::kernel::sys::raw::c_uint = 32;
pub const RSS_TYPE_UDP_IPV4: ::kernel::sys::raw::c_uint = 64;
pub const RSS_TYPE_UDP_IPV6: ::kernel::sys::raw::c_uint = 128;
pub const RSS_TYPE_UDP_IPV6_EX: ::kernel::sys::raw::c_uint = 256;
pub const RSS_KEYLEN: ::kernel::sys::raw::c_uint = 128;
pub const IFNET_PCP_NONE: ::kernel::sys::raw::c_uint = 255;
pub const CR4_PGE: ::kernel::sys::raw::c_uint = 128;
pub const INVPCID_ADDR: ::kernel::sys::raw::c_uint = 0;
pub const INVPCID_CTX: ::kernel::sys::raw::c_uint = 1;
pub const INVPCID_CTXGLOB: ::kernel::sys::raw::c_uint = 2;
pub const INVPCID_ALLCTX: ::kernel::sys::raw::c_uint = 3;
pub const MSR_FSBASE: ::kernel::sys::raw::c_uint = 3221225728;
pub const MSR_GSBASE: ::kernel::sys::raw::c_uint = 3221225729;
pub const CALLOUT_LOCAL_ALLOC: ::kernel::sys::raw::c_uint = 1;
pub const CALLOUT_ACTIVE: ::kernel::sys::raw::c_uint = 2;
pub const CALLOUT_PENDING: ::kernel::sys::raw::c_uint = 4;
pub const CALLOUT_MPSAFE: ::kernel::sys::raw::c_uint = 8;
pub const CALLOUT_RETURNUNLOCKED: ::kernel::sys::raw::c_uint = 16;
pub const CALLOUT_SHAREDLOCK: ::kernel::sys::raw::c_uint = 32;
pub const CALLOUT_DFRMIGRATION: ::kernel::sys::raw::c_uint = 64;
pub const CALLOUT_PROCESSED: ::kernel::sys::raw::c_uint = 128;
pub const CALLOUT_DIRECT: ::kernel::sys::raw::c_uint = 256;
pub const C_DIRECT_EXEC: ::kernel::sys::raw::c_uint = 1;
pub const C_PRELBITS: ::kernel::sys::raw::c_uint = 7;
pub const C_PRELRANGE: ::kernel::sys::raw::c_uint = 127;
pub const C_HARDCLOCK: ::kernel::sys::raw::c_uint = 256;
pub const C_ABSOLUTE: ::kernel::sys::raw::c_uint = 512;
pub const C_PRECALC: ::kernel::sys::raw::c_uint = 1024;
pub const C_CATCH: ::kernel::sys::raw::c_uint = 2048;
pub const CS_DRAIN: ::kernel::sys::raw::c_uint = 1;
pub const CS_EXECUTING: ::kernel::sys::raw::c_uint = 2;
pub const INT8_MIN: ::kernel::sys::raw::c_int = -128;
pub const INT16_MIN: ::kernel::sys::raw::c_int = -32768;
pub const INT32_MIN: ::kernel::sys::raw::c_int = -2147483648;
pub const INT8_MAX: ::kernel::sys::raw::c_uint = 127;
pub const INT16_MAX: ::kernel::sys::raw::c_uint = 32767;
pub const INT32_MAX: ::kernel::sys::raw::c_uint = 2147483647;
pub const UINT8_MAX: ::kernel::sys::raw::c_uint = 255;
pub const UINT16_MAX: ::kernel::sys::raw::c_uint = 65535;
pub const UINT32_MAX: ::kernel::sys::raw::c_uint = 4294967295;
pub const INT64_MIN: ::kernel::sys::raw::c_longlong = -9223372036854775808;
pub const INT64_MAX: ::kernel::sys::raw::c_ulonglong = 9223372036854775807;
pub const UINT64_MAX: ::kernel::sys::raw::c_int = -1;
pub const INT_LEAST8_MIN: ::kernel::sys::raw::c_int = -128;
pub const INT_LEAST16_MIN: ::kernel::sys::raw::c_int = -32768;
pub const INT_LEAST32_MIN: ::kernel::sys::raw::c_int = -2147483648;
pub const INT_LEAST64_MIN: ::kernel::sys::raw::c_longlong =
    -9223372036854775808;
pub const INT_LEAST8_MAX: ::kernel::sys::raw::c_uint = 127;
pub const INT_LEAST16_MAX: ::kernel::sys::raw::c_uint = 32767;
pub const INT_LEAST32_MAX: ::kernel::sys::raw::c_uint = 2147483647;
pub const INT_LEAST64_MAX: ::kernel::sys::raw::c_ulonglong =
    9223372036854775807;
pub const UINT_LEAST8_MAX: ::kernel::sys::raw::c_uint = 255;
pub const UINT_LEAST16_MAX: ::kernel::sys::raw::c_uint = 65535;
pub const UINT_LEAST32_MAX: ::kernel::sys::raw::c_uint = 4294967295;
pub const UINT_LEAST64_MAX: ::kernel::sys::raw::c_int = -1;
pub const INT_FAST8_MIN: ::kernel::sys::raw::c_int = -2147483648;
pub const INT_FAST16_MIN: ::kernel::sys::raw::c_int = -2147483648;
pub const INT_FAST32_MIN: ::kernel::sys::raw::c_int = -2147483648;
pub const INT_FAST64_MIN: ::kernel::sys::raw::c_longlong =
    -9223372036854775808;
pub const INT_FAST8_MAX: ::kernel::sys::raw::c_uint = 2147483647;
pub const INT_FAST16_MAX: ::kernel::sys::raw::c_uint = 2147483647;
pub const INT_FAST32_MAX: ::kernel::sys::raw::c_uint = 2147483647;
pub const INT_FAST64_MAX: ::kernel::sys::raw::c_ulonglong =
    9223372036854775807;
pub const UINT_FAST8_MAX: ::kernel::sys::raw::c_uint = 4294967295;
pub const UINT_FAST16_MAX: ::kernel::sys::raw::c_uint = 4294967295;
pub const UINT_FAST32_MAX: ::kernel::sys::raw::c_uint = 4294967295;
pub const UINT_FAST64_MAX: ::kernel::sys::raw::c_int = -1;
pub const INTPTR_MIN: ::kernel::sys::raw::c_longlong = -9223372036854775808;
pub const INTPTR_MAX: ::kernel::sys::raw::c_ulonglong = 9223372036854775807;
pub const UINTPTR_MAX: ::kernel::sys::raw::c_int = -1;
pub const INTMAX_MIN: ::kernel::sys::raw::c_longlong = -9223372036854775808;
pub const INTMAX_MAX: ::kernel::sys::raw::c_ulonglong = 9223372036854775807;
pub const UINTMAX_MAX: ::kernel::sys::raw::c_int = -1;
pub const PTRDIFF_MIN: ::kernel::sys::raw::c_longlong = -9223372036854775808;
pub const PTRDIFF_MAX: ::kernel::sys::raw::c_ulonglong = 9223372036854775807;
pub const SIG_ATOMIC_MIN: ::kernel::sys::raw::c_longlong =
    -9223372036854775808;
pub const SIG_ATOMIC_MAX: ::kernel::sys::raw::c_ulonglong =
    9223372036854775807;
pub const SIZE_MAX: ::kernel::sys::raw::c_int = -1;
pub const WINT_MIN: ::kernel::sys::raw::c_int = -2147483648;
pub const WINT_MAX: ::kernel::sys::raw::c_uint = 2147483647;
pub const __WORDSIZE: ::kernel::sys::raw::c_uint = 64;
pub const WCHAR_MIN: ::kernel::sys::raw::c_int = -2147483648;
pub const WCHAR_MAX: ::kernel::sys::raw::c_uint = 2147483647;
pub const RSIZE_MAX: ::kernel::sys::raw::c_int = -1;
pub const HASH_NOWAIT: ::kernel::sys::raw::c_uint = 1;
pub const HASH_WAITOK: ::kernel::sys::raw::c_uint = 2;
pub const HD_COLUMN_MASK: ::kernel::sys::raw::c_uint = 255;
pub const HD_DELIM_MASK: ::kernel::sys::raw::c_uint = 65280;
pub const HD_OMIT_COUNT: ::kernel::sys::raw::c_uint = 65536;
pub const HD_OMIT_HEX: ::kernel::sys::raw::c_uint = 131072;
pub const HD_OMIT_CHARS: ::kernel::sys::raw::c_uint = 262144;
pub const LIBKERN_LEN_BCD2BIN: ::kernel::sys::raw::c_uint = 154;
pub const LIBKERN_LEN_BIN2BCD: ::kernel::sys::raw::c_uint = 100;
pub const LIBKERN_LEN_HEX2ASCII: ::kernel::sys::raw::c_uint = 36;
pub const ARC4_ENTR_NONE: ::kernel::sys::raw::c_uint = 0;
pub const ARC4_ENTR_HAVE: ::kernel::sys::raw::c_uint = 1;
pub const ARC4_ENTR_SEED: ::kernel::sys::raw::c_uint = 2;
pub const FNM_NOMATCH: ::kernel::sys::raw::c_uint = 1;
pub const FNM_NOESCAPE: ::kernel::sys::raw::c_uint = 1;
pub const FNM_PATHNAME: ::kernel::sys::raw::c_uint = 2;
pub const FNM_PERIOD: ::kernel::sys::raw::c_uint = 4;
pub const FNM_LEADING_DIR: ::kernel::sys::raw::c_uint = 8;
pub const FNM_CASEFOLD: ::kernel::sys::raw::c_uint = 16;
pub const FNM_IGNORECASE: ::kernel::sys::raw::c_uint = 16;
pub const FNM_FILE_NAME: ::kernel::sys::raw::c_uint = 2;
pub const BSD: ::kernel::sys::raw::c_uint = 199506;
pub const BSD4_3: ::kernel::sys::raw::c_uint = 1;
pub const BSD4_4: ::kernel::sys::raw::c_uint = 1;
pub const __FreeBSD_version: ::kernel::sys::raw::c_uint = 1200064;
pub const P_OSREL_SIGWAIT: ::kernel::sys::raw::c_uint = 700000;
pub const P_OSREL_SIGSEGV: ::kernel::sys::raw::c_uint = 700004;
pub const P_OSREL_MAP_ANON: ::kernel::sys::raw::c_uint = 800104;
pub const P_OSREL_MAP_FSTRICT: ::kernel::sys::raw::c_uint = 1100036;
pub const P_OSREL_SHUTDOWN_ENOTCONN: ::kernel::sys::raw::c_uint = 1100077;
pub const P_OSREL_MAP_GUARD: ::kernel::sys::raw::c_uint = 1200035;
pub const P_OSREL_WRFSBASE: ::kernel::sys::raw::c_uint = 1200041;
pub const P_OSREL_CK_CYLGRP: ::kernel::sys::raw::c_uint = 1200046;
pub const P_OSREL_VMTOTAL64: ::kernel::sys::raw::c_uint = 1200054;
pub const ARG_MAX: ::kernel::sys::raw::c_uint = 262144;
pub const CHILD_MAX: ::kernel::sys::raw::c_uint = 40;
pub const MAX_CANON: ::kernel::sys::raw::c_uint = 255;
pub const MAX_INPUT: ::kernel::sys::raw::c_uint = 255;
pub const NAME_MAX: ::kernel::sys::raw::c_uint = 255;
pub const NGROUPS_MAX: ::kernel::sys::raw::c_uint = 1023;
pub const OPEN_MAX: ::kernel::sys::raw::c_uint = 64;
pub const PATH_MAX: ::kernel::sys::raw::c_uint = 1024;
pub const PIPE_BUF: ::kernel::sys::raw::c_uint = 512;
pub const IOV_MAX: ::kernel::sys::raw::c_uint = 1024;
pub const MAXCOMLEN: ::kernel::sys::raw::c_uint = 19;
pub const MAXINTERP: ::kernel::sys::raw::c_uint = 1024;
pub const MAXLOGNAME: ::kernel::sys::raw::c_uint = 33;
pub const MAXUPRC: ::kernel::sys::raw::c_uint = 40;
pub const NCARGS: ::kernel::sys::raw::c_uint = 262144;
pub const NGROUPS: ::kernel::sys::raw::c_uint = 1024;
pub const NOFILE: ::kernel::sys::raw::c_uint = 64;
pub const NOGROUP: ::kernel::sys::raw::c_uint = 65535;
pub const MAXHOSTNAMELEN: ::kernel::sys::raw::c_uint = 256;
pub const SPECNAMELEN: ::kernel::sys::raw::c_uint = 63;
pub const EPERM: ::kernel::sys::raw::c_uint = 1;
pub const ENOENT: ::kernel::sys::raw::c_uint = 2;
pub const ESRCH: ::kernel::sys::raw::c_uint = 3;
pub const EINTR: ::kernel::sys::raw::c_uint = 4;
pub const EIO: ::kernel::sys::raw::c_uint = 5;
pub const ENXIO: ::kernel::sys::raw::c_uint = 6;
pub const E2BIG: ::kernel::sys::raw::c_uint = 7;
pub const ENOEXEC: ::kernel::sys::raw::c_uint = 8;
pub const EBADF: ::kernel::sys::raw::c_uint = 9;
pub const ECHILD: ::kernel::sys::raw::c_uint = 10;
pub const EDEADLK: ::kernel::sys::raw::c_uint = 11;
pub const ENOMEM: ::kernel::sys::raw::c_uint = 12;
pub const EACCES: ::kernel::sys::raw::c_uint = 13;
pub const EFAULT: ::kernel::sys::raw::c_uint = 14;
pub const ENOTBLK: ::kernel::sys::raw::c_uint = 15;
pub const EBUSY: ::kernel::sys::raw::c_uint = 16;
pub const EEXIST: ::kernel::sys::raw::c_uint = 17;
pub const EXDEV: ::kernel::sys::raw::c_uint = 18;
pub const ENODEV: ::kernel::sys::raw::c_uint = 19;
pub const ENOTDIR: ::kernel::sys::raw::c_uint = 20;
pub const EISDIR: ::kernel::sys::raw::c_uint = 21;
pub const EINVAL: ::kernel::sys::raw::c_uint = 22;
pub const ENFILE: ::kernel::sys::raw::c_uint = 23;
pub const EMFILE: ::kernel::sys::raw::c_uint = 24;
pub const ENOTTY: ::kernel::sys::raw::c_uint = 25;
pub const ETXTBSY: ::kernel::sys::raw::c_uint = 26;
pub const EFBIG: ::kernel::sys::raw::c_uint = 27;
pub const ENOSPC: ::kernel::sys::raw::c_uint = 28;
pub const ESPIPE: ::kernel::sys::raw::c_uint = 29;
pub const EROFS: ::kernel::sys::raw::c_uint = 30;
pub const EMLINK: ::kernel::sys::raw::c_uint = 31;
pub const EPIPE: ::kernel::sys::raw::c_uint = 32;
pub const EDOM: ::kernel::sys::raw::c_uint = 33;
pub const ERANGE: ::kernel::sys::raw::c_uint = 34;
pub const EAGAIN: ::kernel::sys::raw::c_uint = 35;
pub const EWOULDBLOCK: ::kernel::sys::raw::c_uint = 35;
pub const EINPROGRESS: ::kernel::sys::raw::c_uint = 36;
pub const EALREADY: ::kernel::sys::raw::c_uint = 37;
pub const ENOTSOCK: ::kernel::sys::raw::c_uint = 38;
pub const EDESTADDRREQ: ::kernel::sys::raw::c_uint = 39;
pub const EMSGSIZE: ::kernel::sys::raw::c_uint = 40;
pub const EPROTOTYPE: ::kernel::sys::raw::c_uint = 41;
pub const ENOPROTOOPT: ::kernel::sys::raw::c_uint = 42;
pub const EPROTONOSUPPORT: ::kernel::sys::raw::c_uint = 43;
pub const ESOCKTNOSUPPORT: ::kernel::sys::raw::c_uint = 44;
pub const EOPNOTSUPP: ::kernel::sys::raw::c_uint = 45;
pub const ENOTSUP: ::kernel::sys::raw::c_uint = 45;
pub const EPFNOSUPPORT: ::kernel::sys::raw::c_uint = 46;
pub const EAFNOSUPPORT: ::kernel::sys::raw::c_uint = 47;
pub const EADDRINUSE: ::kernel::sys::raw::c_uint = 48;
pub const EADDRNOTAVAIL: ::kernel::sys::raw::c_uint = 49;
pub const ENETDOWN: ::kernel::sys::raw::c_uint = 50;
pub const ENETUNREACH: ::kernel::sys::raw::c_uint = 51;
pub const ENETRESET: ::kernel::sys::raw::c_uint = 52;
pub const ECONNABORTED: ::kernel::sys::raw::c_uint = 53;
pub const ECONNRESET: ::kernel::sys::raw::c_uint = 54;
pub const ENOBUFS: ::kernel::sys::raw::c_uint = 55;
pub const EISCONN: ::kernel::sys::raw::c_uint = 56;
pub const ENOTCONN: ::kernel::sys::raw::c_uint = 57;
pub const ESHUTDOWN: ::kernel::sys::raw::c_uint = 58;
pub const ETOOMANYREFS: ::kernel::sys::raw::c_uint = 59;
pub const ETIMEDOUT: ::kernel::sys::raw::c_uint = 60;
pub const ECONNREFUSED: ::kernel::sys::raw::c_uint = 61;
pub const ELOOP: ::kernel::sys::raw::c_uint = 62;
pub const ENAMETOOLONG: ::kernel::sys::raw::c_uint = 63;
pub const EHOSTDOWN: ::kernel::sys::raw::c_uint = 64;
pub const EHOSTUNREACH: ::kernel::sys::raw::c_uint = 65;
pub const ENOTEMPTY: ::kernel::sys::raw::c_uint = 66;
pub const EPROCLIM: ::kernel::sys::raw::c_uint = 67;
pub const EUSERS: ::kernel::sys::raw::c_uint = 68;
pub const EDQUOT: ::kernel::sys::raw::c_uint = 69;
pub const ESTALE: ::kernel::sys::raw::c_uint = 70;
pub const EREMOTE: ::kernel::sys::raw::c_uint = 71;
pub const EBADRPC: ::kernel::sys::raw::c_uint = 72;
pub const ERPCMISMATCH: ::kernel::sys::raw::c_uint = 73;
pub const EPROGUNAVAIL: ::kernel::sys::raw::c_uint = 74;
pub const EPROGMISMATCH: ::kernel::sys::raw::c_uint = 75;
pub const EPROCUNAVAIL: ::kernel::sys::raw::c_uint = 76;
pub const ENOLCK: ::kernel::sys::raw::c_uint = 77;
pub const ENOSYS: ::kernel::sys::raw::c_uint = 78;
pub const EFTYPE: ::kernel::sys::raw::c_uint = 79;
pub const EAUTH: ::kernel::sys::raw::c_uint = 80;
pub const ENEEDAUTH: ::kernel::sys::raw::c_uint = 81;
pub const EIDRM: ::kernel::sys::raw::c_uint = 82;
pub const ENOMSG: ::kernel::sys::raw::c_uint = 83;
pub const EOVERFLOW: ::kernel::sys::raw::c_uint = 84;
pub const ECANCELED: ::kernel::sys::raw::c_uint = 85;
pub const EILSEQ: ::kernel::sys::raw::c_uint = 86;
pub const ENOATTR: ::kernel::sys::raw::c_uint = 87;
pub const EDOOFUS: ::kernel::sys::raw::c_uint = 88;
pub const EBADMSG: ::kernel::sys::raw::c_uint = 89;
pub const EMULTIHOP: ::kernel::sys::raw::c_uint = 90;
pub const ENOLINK: ::kernel::sys::raw::c_uint = 91;
pub const EPROTO: ::kernel::sys::raw::c_uint = 92;
pub const ENOTCAPABLE: ::kernel::sys::raw::c_uint = 93;
pub const ECAPMODE: ::kernel::sys::raw::c_uint = 94;
pub const ENOTRECOVERABLE: ::kernel::sys::raw::c_uint = 95;
pub const EOWNERDEAD: ::kernel::sys::raw::c_uint = 96;
pub const ELAST: ::kernel::sys::raw::c_uint = 96;
pub const ERESTART: ::kernel::sys::raw::c_int = -1;
pub const EJUSTRETURN: ::kernel::sys::raw::c_int = -2;
pub const ENOIOCTL: ::kernel::sys::raw::c_int = -3;
pub const EDIRIOCTL: ::kernel::sys::raw::c_int = -4;
pub const ERELOOKUP: ::kernel::sys::raw::c_int = -5;
pub const DST_NONE: ::kernel::sys::raw::c_uint = 0;
pub const DST_USA: ::kernel::sys::raw::c_uint = 1;
pub const DST_AUST: ::kernel::sys::raw::c_uint = 2;
pub const DST_WET: ::kernel::sys::raw::c_uint = 3;
pub const DST_MET: ::kernel::sys::raw::c_uint = 4;
pub const DST_EET: ::kernel::sys::raw::c_uint = 5;
pub const DST_CAN: ::kernel::sys::raw::c_uint = 6;
pub const SBT_MAX: ::kernel::sys::raw::c_ulonglong = 9223372036854775807;
pub const ITIMER_REAL: ::kernel::sys::raw::c_uint = 0;
pub const ITIMER_VIRTUAL: ::kernel::sys::raw::c_uint = 1;
pub const ITIMER_PROF: ::kernel::sys::raw::c_uint = 2;
pub const CLOCK_REALTIME: ::kernel::sys::raw::c_uint = 0;
pub const CLOCK_VIRTUAL: ::kernel::sys::raw::c_uint = 1;
pub const CLOCK_PROF: ::kernel::sys::raw::c_uint = 2;
pub const CLOCK_MONOTONIC: ::kernel::sys::raw::c_uint = 4;
pub const CLOCK_UPTIME: ::kernel::sys::raw::c_uint = 5;
pub const CLOCK_UPTIME_PRECISE: ::kernel::sys::raw::c_uint = 7;
pub const CLOCK_UPTIME_FAST: ::kernel::sys::raw::c_uint = 8;
pub const CLOCK_REALTIME_PRECISE: ::kernel::sys::raw::c_uint = 9;
pub const CLOCK_REALTIME_FAST: ::kernel::sys::raw::c_uint = 10;
pub const CLOCK_MONOTONIC_PRECISE: ::kernel::sys::raw::c_uint = 11;
pub const CLOCK_MONOTONIC_FAST: ::kernel::sys::raw::c_uint = 12;
pub const CLOCK_SECOND: ::kernel::sys::raw::c_uint = 13;
pub const CLOCK_THREAD_CPUTIME_ID: ::kernel::sys::raw::c_uint = 14;
pub const CLOCK_PROCESS_CPUTIME_ID: ::kernel::sys::raw::c_uint = 15;
pub const TIMER_RELTIME: ::kernel::sys::raw::c_uint = 0;
pub const TIMER_ABSTIME: ::kernel::sys::raw::c_uint = 1;
pub const CPUCLOCK_WHICH_PID: ::kernel::sys::raw::c_uint = 0;
pub const CPUCLOCK_WHICH_TID: ::kernel::sys::raw::c_uint = 1;
pub const TC_DEFAULTPERC: ::kernel::sys::raw::c_uint = 5;
pub const PRI_ITHD: ::kernel::sys::raw::c_uint = 1;
pub const PRI_REALTIME: ::kernel::sys::raw::c_uint = 2;
pub const PRI_TIMESHARE: ::kernel::sys::raw::c_uint = 3;
pub const PRI_IDLE: ::kernel::sys::raw::c_uint = 4;
pub const PRI_FIFO_BIT: ::kernel::sys::raw::c_uint = 8;
pub const PRI_FIFO: ::kernel::sys::raw::c_uint = 10;
pub const PRI_MIN: ::kernel::sys::raw::c_uint = 0;
pub const PRI_MAX: ::kernel::sys::raw::c_uint = 255;
pub const PRI_MIN_ITHD: ::kernel::sys::raw::c_uint = 0;
pub const PI_REALTIME: ::kernel::sys::raw::c_uint = 0;
pub const PI_AV: ::kernel::sys::raw::c_uint = 4;
pub const PI_NET: ::kernel::sys::raw::c_uint = 8;
pub const PI_DISK: ::kernel::sys::raw::c_uint = 12;
pub const PI_TTY: ::kernel::sys::raw::c_uint = 16;
pub const PI_DULL: ::kernel::sys::raw::c_uint = 20;
pub const PI_SOFT: ::kernel::sys::raw::c_uint = 24;
pub const PRI_MIN_REALTIME: ::kernel::sys::raw::c_uint = 48;
pub const PRI_MIN_KERN: ::kernel::sys::raw::c_uint = 80;
pub const PSWP: ::kernel::sys::raw::c_uint = 80;
pub const PVM: ::kernel::sys::raw::c_uint = 84;
pub const PINOD: ::kernel::sys::raw::c_uint = 88;
pub const PRIBIO: ::kernel::sys::raw::c_uint = 92;
pub const PVFS: ::kernel::sys::raw::c_uint = 96;
pub const PZERO: ::kernel::sys::raw::c_uint = 100;
pub const PSOCK: ::kernel::sys::raw::c_uint = 104;
pub const PWAIT: ::kernel::sys::raw::c_uint = 108;
pub const PLOCK: ::kernel::sys::raw::c_uint = 112;
pub const PPAUSE: ::kernel::sys::raw::c_uint = 116;
pub const PRI_MIN_TIMESHARE: ::kernel::sys::raw::c_uint = 120;
pub const PUSER: ::kernel::sys::raw::c_uint = 120;
pub const PRI_MIN_IDLE: ::kernel::sys::raw::c_uint = 224;
pub const PRI_MAX_IDLE: ::kernel::sys::raw::c_uint = 255;
pub const PRI_USER: ::kernel::sys::raw::c_int = -2;
pub const PRI_UNCHANGED: ::kernel::sys::raw::c_int = -1;
pub const FALSE: ::kernel::sys::raw::c_uint = 0;
pub const TRUE: ::kernel::sys::raw::c_uint = 1;
pub const MACHINE: &'static [u8; 6usize] = b"amd64\x00";
pub const MACHINE_ARCH: &'static [u8; 6usize] = b"amd64\x00";
pub const MACHINE_ARCH32: &'static [u8; 5usize] = b"i386\x00";
pub const MAXCPU: ::kernel::sys::raw::c_uint = 256;
pub const MAXMEMDOM: ::kernel::sys::raw::c_uint = 8;
pub const CACHE_LINE_SHIFT: ::kernel::sys::raw::c_uint = 6;
pub const CACHE_LINE_SIZE: ::kernel::sys::raw::c_uint = 64;
pub const NPTEPGSHIFT: ::kernel::sys::raw::c_uint = 9;
pub const PAGE_SHIFT: ::kernel::sys::raw::c_uint = 12;
pub const PAGE_SIZE: ::kernel::sys::raw::c_uint = 4096;
pub const PAGE_MASK: ::kernel::sys::raw::c_uint = 4095;
pub const NPDEPGSHIFT: ::kernel::sys::raw::c_uint = 9;
pub const PDRSHIFT: ::kernel::sys::raw::c_uint = 21;
pub const NBPDR: ::kernel::sys::raw::c_uint = 2097152;
pub const PDRMASK: ::kernel::sys::raw::c_uint = 2097151;
pub const NPDPEPGSHIFT: ::kernel::sys::raw::c_uint = 9;
pub const PDPSHIFT: ::kernel::sys::raw::c_uint = 30;
pub const NBPDP: ::kernel::sys::raw::c_uint = 1073741824;
pub const PDPMASK: ::kernel::sys::raw::c_uint = 1073741823;
pub const NPML4EPGSHIFT: ::kernel::sys::raw::c_uint = 9;
pub const PML4SHIFT: ::kernel::sys::raw::c_uint = 39;
pub const NBPML4: ::kernel::sys::raw::c_ulonglong = 549755813888;
pub const PML4MASK: ::kernel::sys::raw::c_ulonglong = 549755813887;
pub const MAXPAGESIZES: ::kernel::sys::raw::c_uint = 3;
pub const IOPAGES: ::kernel::sys::raw::c_uint = 2;
pub const IOPERM_BITMAP_SIZE: ::kernel::sys::raw::c_uint = 8193;
pub const KSTACK_PAGES: ::kernel::sys::raw::c_uint = 4;
pub const KSTACK_GUARD_PAGES: ::kernel::sys::raw::c_uint = 1;
pub const DEV_BSHIFT: ::kernel::sys::raw::c_uint = 9;
pub const DEV_BSIZE: ::kernel::sys::raw::c_uint = 512;
pub const BLKDEV_IOSIZE: ::kernel::sys::raw::c_uint = 4096;
pub const DFLTPHYS: ::kernel::sys::raw::c_uint = 65536;
pub const MAXPHYS: ::kernel::sys::raw::c_uint = 131072;
pub const MAXDUMPPGS: ::kernel::sys::raw::c_uint = 16;
pub const MSIZE: ::kernel::sys::raw::c_uint = 256;
pub const MCLSHIFT: ::kernel::sys::raw::c_uint = 11;
pub const MCLBYTES: ::kernel::sys::raw::c_uint = 2048;
pub const MJUMPAGESIZE: ::kernel::sys::raw::c_uint = 4096;
pub const MJUM9BYTES: ::kernel::sys::raw::c_uint = 9216;
pub const MJUM16BYTES: ::kernel::sys::raw::c_uint = 16384;
pub const PRIMASK: ::kernel::sys::raw::c_uint = 255;
pub const PCATCH: ::kernel::sys::raw::c_uint = 256;
pub const PDROP: ::kernel::sys::raw::c_uint = 512;
pub const NZERO: ::kernel::sys::raw::c_uint = 0;
pub const NBBY: ::kernel::sys::raw::c_uint = 8;
pub const CMASK: ::kernel::sys::raw::c_uint = 18;
pub const MAXBSIZE: ::kernel::sys::raw::c_uint = 65536;
pub const MAXBCACHEBUF: ::kernel::sys::raw::c_uint = 65536;
pub const BKVASIZE: ::kernel::sys::raw::c_uint = 16384;
pub const BKVAMASK: ::kernel::sys::raw::c_uint = 16383;
pub const MAXPATHLEN: ::kernel::sys::raw::c_uint = 1024;
pub const MAXSYMLINKS: ::kernel::sys::raw::c_uint = 32;
pub const FSHIFT: ::kernel::sys::raw::c_uint = 11;
pub const FSCALE: ::kernel::sys::raw::c_uint = 2048;
pub const M_NOWAIT: ::kernel::sys::raw::c_uint = 1;
pub const M_WAITOK: ::kernel::sys::raw::c_uint = 2;
pub const M_ZERO: ::kernel::sys::raw::c_uint = 256;
pub const M_NOVM: ::kernel::sys::raw::c_uint = 512;
pub const M_USE_RESERVE: ::kernel::sys::raw::c_uint = 1024;
pub const M_NODUMP: ::kernel::sys::raw::c_uint = 2048;
pub const M_FIRSTFIT: ::kernel::sys::raw::c_uint = 4096;
pub const M_BESTFIT: ::kernel::sys::raw::c_uint = 8192;
pub const M_MAGIC: ::kernel::sys::raw::c_uint = 877983977;
pub const M_ZERO_INVARIANTS: ::kernel::sys::raw::c_uint = 0;
pub const DTMALLOC_PROBE_MALLOC: ::kernel::sys::raw::c_uint = 0;
pub const DTMALLOC_PROBE_FREE: ::kernel::sys::raw::c_uint = 1;
pub const DTMALLOC_PROBE_MAX: ::kernel::sys::raw::c_uint = 2;
pub const MALLOC_TYPE_STREAM_VERSION: ::kernel::sys::raw::c_uint = 1;
pub const MALLOC_MAX_NAME: ::kernel::sys::raw::c_uint = 32;
pub const UMA_SMALLEST_UNIT: ::kernel::sys::raw::c_uint = 16;
pub const UMA_ZONE_PAGEABLE: ::kernel::sys::raw::c_uint = 1;
pub const UMA_ZONE_ZINIT: ::kernel::sys::raw::c_uint = 2;
pub const UMA_ZONE_STATIC: ::kernel::sys::raw::c_uint = 4;
pub const UMA_ZONE_OFFPAGE: ::kernel::sys::raw::c_uint = 8;
pub const UMA_ZONE_MALLOC: ::kernel::sys::raw::c_uint = 16;
pub const UMA_ZONE_NOFREE: ::kernel::sys::raw::c_uint = 32;
pub const UMA_ZONE_MTXCLASS: ::kernel::sys::raw::c_uint = 64;
pub const UMA_ZONE_VM: ::kernel::sys::raw::c_uint = 128;
pub const UMA_ZONE_HASH: ::kernel::sys::raw::c_uint = 256;
pub const UMA_ZONE_SECONDARY: ::kernel::sys::raw::c_uint = 512;
pub const UMA_ZONE_NOBUCKET: ::kernel::sys::raw::c_uint = 1024;
pub const UMA_ZONE_MAXBUCKET: ::kernel::sys::raw::c_uint = 2048;
pub const UMA_ZONE_CACHESPREAD: ::kernel::sys::raw::c_uint = 4096;
pub const UMA_ZONE_VTOSLAB: ::kernel::sys::raw::c_uint = 8192;
pub const UMA_ZONE_NODUMP: ::kernel::sys::raw::c_uint = 16384;
pub const UMA_ZONE_PCPU: ::kernel::sys::raw::c_uint = 32768;
pub const UMA_ZONE_NUMA: ::kernel::sys::raw::c_uint = 65536;
pub const UMA_ZONE_NOBUCKETCACHE: ::kernel::sys::raw::c_uint = 131072;
pub const UMA_ZONE_INHERIT: ::kernel::sys::raw::c_uint = 41272;
pub const UMA_ALIGN_CACHE: ::kernel::sys::raw::c_int = -1;
pub const UMA_SLAB_BOOT: ::kernel::sys::raw::c_uint = 1;
pub const UMA_SLAB_KERNEL: ::kernel::sys::raw::c_uint = 4;
pub const UMA_SLAB_PRIV: ::kernel::sys::raw::c_uint = 8;
pub const UMA_SLAB_OFFP: ::kernel::sys::raw::c_uint = 16;
pub const UMA_SLAB_MALLOC: ::kernel::sys::raw::c_uint = 32;
pub const UMA_STREAM_VERSION: ::kernel::sys::raw::c_uint = 1;
pub const UTH_MAX_NAME: ::kernel::sys::raw::c_uint = 32;
pub const UTH_ZONE_SECONDARY: ::kernel::sys::raw::c_uint = 1;
pub const M_EXT: ::kernel::sys::raw::c_uint = 1;
pub const M_PKTHDR: ::kernel::sys::raw::c_uint = 2;
pub const M_EOR: ::kernel::sys::raw::c_uint = 4;
pub const M_RDONLY: ::kernel::sys::raw::c_uint = 8;
pub const M_BCAST: ::kernel::sys::raw::c_uint = 16;
pub const M_MCAST: ::kernel::sys::raw::c_uint = 32;
pub const M_PROMISC: ::kernel::sys::raw::c_uint = 64;
pub const M_VLANTAG: ::kernel::sys::raw::c_uint = 128;
pub const M_UNUSED_8: ::kernel::sys::raw::c_uint = 256;
pub const M_NOFREE: ::kernel::sys::raw::c_uint = 512;
pub const M_TSTMP: ::kernel::sys::raw::c_uint = 1024;
pub const M_TSTMP_HPREC: ::kernel::sys::raw::c_uint = 2048;
pub const M_PROTO1: ::kernel::sys::raw::c_uint = 4096;
pub const M_PROTO2: ::kernel::sys::raw::c_uint = 8192;
pub const M_PROTO3: ::kernel::sys::raw::c_uint = 16384;
pub const M_PROTO4: ::kernel::sys::raw::c_uint = 32768;
pub const M_PROTO5: ::kernel::sys::raw::c_uint = 65536;
pub const M_PROTO6: ::kernel::sys::raw::c_uint = 131072;
pub const M_PROTO7: ::kernel::sys::raw::c_uint = 262144;
pub const M_PROTO8: ::kernel::sys::raw::c_uint = 524288;
pub const M_PROTO9: ::kernel::sys::raw::c_uint = 1048576;
pub const M_PROTO10: ::kernel::sys::raw::c_uint = 2097152;
pub const M_PROTO11: ::kernel::sys::raw::c_uint = 4194304;
pub const M_PROTO12: ::kernel::sys::raw::c_uint = 8388608;
pub const MB_DTOR_SKIP: ::kernel::sys::raw::c_uint = 1;
pub const M_PROTOFLAGS: ::kernel::sys::raw::c_uint = 16773120;
pub const M_COPYFLAGS: ::kernel::sys::raw::c_uint = 16776446;
pub const M_FLAG_BITS: &'static [u8; 101usize] =
    b"\x10\x01M_EXT\\2M_PKTHDR\\3M_EOR\\4M_RDONLY\\5M_BCAST\\6M_MCAST\x07M_PROMISC\\10M_VLANTAG\\13M_TSTMP\\14M_TSTMP_HPREC\x00";
pub const M_FLAG_PROTOBITS: &'static [u8; 130usize] =
    b"\rM_PROTO1\\16M_PROTO2\\17M_PROTO3\\20M_PROTO4\\21M_PROTO5\x12M_PROTO6\\23M_PROTO7\\24M_PROTO8\\25M_PROTO9\\26M_PROTO10\x17M_PROTO11\\30M_PROTO12\x00";
pub const M_FLAG_PRINTF: &'static [u8; 230usize] =
    b"\x10\x01M_EXT\\2M_PKTHDR\\3M_EOR\\4M_RDONLY\\5M_BCAST\\6M_MCAST\x07M_PROMISC\\10M_VLANTAG\\13M_TSTMP\\14M_TSTMP_HPREC\rM_PROTO1\\16M_PROTO2\\17M_PROTO3\\20M_PROTO4\\21M_PROTO5\x12M_PROTO6\\23M_PROTO7\\24M_PROTO8\\25M_PROTO9\\26M_PROTO10\x17M_PROTO11\\30M_PROTO12\x00";
pub const M_HASHTYPE_HASHPROP: ::kernel::sys::raw::c_uint = 128;
pub const M_HASHTYPE_NONE: ::kernel::sys::raw::c_uint = 0;
pub const M_HASHTYPE_OPAQUE: ::kernel::sys::raw::c_uint = 63;
pub const QOS_DSCP_CS0: ::kernel::sys::raw::c_uint = 0;
pub const QOS_DSCP_DEF: ::kernel::sys::raw::c_uint = 0;
pub const QOS_DSCP_CS1: ::kernel::sys::raw::c_uint = 32;
pub const QOS_DSCP_AF11: ::kernel::sys::raw::c_uint = 40;
pub const QOS_DSCP_AF12: ::kernel::sys::raw::c_uint = 48;
pub const QOS_DSCP_AF13: ::kernel::sys::raw::c_uint = 56;
pub const QOS_DSCP_CS2: ::kernel::sys::raw::c_uint = 64;
pub const QOS_DSCP_AF21: ::kernel::sys::raw::c_uint = 72;
pub const QOS_DSCP_AF22: ::kernel::sys::raw::c_uint = 80;
pub const QOS_DSCP_AF23: ::kernel::sys::raw::c_uint = 88;
pub const QOS_DSCP_CS3: ::kernel::sys::raw::c_uint = 96;
pub const QOS_DSCP_AF31: ::kernel::sys::raw::c_uint = 104;
pub const QOS_DSCP_AF32: ::kernel::sys::raw::c_uint = 112;
pub const QOS_DSCP_AF33: ::kernel::sys::raw::c_uint = 120;
pub const QOS_DSCP_CS4: ::kernel::sys::raw::c_uint = 128;
pub const QOS_DSCP_AF41: ::kernel::sys::raw::c_uint = 136;
pub const QOS_DSCP_AF42: ::kernel::sys::raw::c_uint = 144;
pub const QOS_DSCP_AF43: ::kernel::sys::raw::c_uint = 152;
pub const QOS_DSCP_CS5: ::kernel::sys::raw::c_uint = 160;
pub const QOS_DSCP_EF: ::kernel::sys::raw::c_uint = 184;
pub const QOS_DSCP_CS6: ::kernel::sys::raw::c_uint = 192;
pub const QOS_DSCP_CS7: ::kernel::sys::raw::c_uint = 224;
pub const EXT_CLUSTER: ::kernel::sys::raw::c_uint = 1;
pub const EXT_SFBUF: ::kernel::sys::raw::c_uint = 2;
pub const EXT_JUMBOP: ::kernel::sys::raw::c_uint = 3;
pub const EXT_JUMBO9: ::kernel::sys::raw::c_uint = 4;
pub const EXT_JUMBO16: ::kernel::sys::raw::c_uint = 5;
pub const EXT_PACKET: ::kernel::sys::raw::c_uint = 6;
pub const EXT_MBUF: ::kernel::sys::raw::c_uint = 7;
pub const EXT_VENDOR1: ::kernel::sys::raw::c_uint = 224;
pub const EXT_VENDOR2: ::kernel::sys::raw::c_uint = 225;
pub const EXT_VENDOR3: ::kernel::sys::raw::c_uint = 226;
pub const EXT_VENDOR4: ::kernel::sys::raw::c_uint = 227;
pub const EXT_EXP1: ::kernel::sys::raw::c_uint = 244;
pub const EXT_EXP2: ::kernel::sys::raw::c_uint = 245;
pub const EXT_EXP3: ::kernel::sys::raw::c_uint = 246;
pub const EXT_EXP4: ::kernel::sys::raw::c_uint = 247;
pub const EXT_NET_DRV: ::kernel::sys::raw::c_uint = 252;
pub const EXT_MOD_TYPE: ::kernel::sys::raw::c_uint = 253;
pub const EXT_DISPOSABLE: ::kernel::sys::raw::c_uint = 254;
pub const EXT_EXTREF: ::kernel::sys::raw::c_uint = 255;
pub const EXT_FLAG_EMBREF: ::kernel::sys::raw::c_uint = 1;
pub const EXT_FLAG_EXTREF: ::kernel::sys::raw::c_uint = 2;
pub const EXT_FLAG_NOFREE: ::kernel::sys::raw::c_uint = 16;
pub const EXT_FLAG_VENDOR1: ::kernel::sys::raw::c_uint = 65536;
pub const EXT_FLAG_VENDOR2: ::kernel::sys::raw::c_uint = 131072;
pub const EXT_FLAG_VENDOR3: ::kernel::sys::raw::c_uint = 262144;
pub const EXT_FLAG_VENDOR4: ::kernel::sys::raw::c_uint = 524288;
pub const EXT_FLAG_EXP1: ::kernel::sys::raw::c_uint = 1048576;
pub const EXT_FLAG_EXP2: ::kernel::sys::raw::c_uint = 2097152;
pub const EXT_FLAG_EXP3: ::kernel::sys::raw::c_uint = 4194304;
pub const EXT_FLAG_EXP4: ::kernel::sys::raw::c_uint = 8388608;
pub const EXT_FLAG_BITS: &'static [u8; 186usize] =
    b"\x10\x01EXT_FLAG_EMBREF\\2EXT_FLAG_EXTREF\\5EXT_FLAG_NOFREE\x11EXT_FLAG_VENDOR1\\22EXT_FLAG_VENDOR2\\23EXT_FLAG_VENDOR3\x14EXT_FLAG_VENDOR4\\25EXT_FLAG_EXP1\\26EXT_FLAG_EXP2\\27EXT_FLAG_EXP3\x18EXT_FLAG_EXP4\x00";
pub const CSUM_IP: ::kernel::sys::raw::c_uint = 1;
pub const CSUM_IP_UDP: ::kernel::sys::raw::c_uint = 2;
pub const CSUM_IP_TCP: ::kernel::sys::raw::c_uint = 4;
pub const CSUM_IP_SCTP: ::kernel::sys::raw::c_uint = 8;
pub const CSUM_IP_TSO: ::kernel::sys::raw::c_uint = 16;
pub const CSUM_IP_ISCSI: ::kernel::sys::raw::c_uint = 32;
pub const CSUM_IP6_UDP: ::kernel::sys::raw::c_uint = 512;
pub const CSUM_IP6_TCP: ::kernel::sys::raw::c_uint = 1024;
pub const CSUM_IP6_SCTP: ::kernel::sys::raw::c_uint = 2048;
pub const CSUM_IP6_TSO: ::kernel::sys::raw::c_uint = 4096;
pub const CSUM_IP6_ISCSI: ::kernel::sys::raw::c_uint = 8192;
pub const CSUM_L3_CALC: ::kernel::sys::raw::c_uint = 16777216;
pub const CSUM_L3_VALID: ::kernel::sys::raw::c_uint = 33554432;
pub const CSUM_L4_CALC: ::kernel::sys::raw::c_uint = 67108864;
pub const CSUM_L4_VALID: ::kernel::sys::raw::c_uint = 134217728;
pub const CSUM_L5_CALC: ::kernel::sys::raw::c_uint = 268435456;
pub const CSUM_L5_VALID: ::kernel::sys::raw::c_uint = 536870912;
pub const CSUM_COALESCED: ::kernel::sys::raw::c_uint = 1073741824;
pub const CSUM_BITS: &'static [u8; 257usize] =
    b"\x10\x01CSUM_IP\\2CSUM_IP_UDP\\3CSUM_IP_TCP\\4CSUM_IP_SCTP\\5CSUM_IP_TSO\x06CSUM_IP_ISCSI\nCSUM_IP6_UDP\\13CSUM_IP6_TCP\\14CSUM_IP6_SCTP\\15CSUM_IP6_TSO\x0eCSUM_IP6_ISCSI\x19CSUM_L3_CALC\\32CSUM_L3_VALID\\33CSUM_L4_CALC\\34CSUM_L4_VALID\x1dCSUM_L5_CALC\\36CSUM_L5_VALID\\37CSUM_COALESCED\x00";
pub const CSUM_IP_CHECKED: ::kernel::sys::raw::c_uint = 16777216;
pub const CSUM_IP_VALID: ::kernel::sys::raw::c_uint = 33554432;
pub const CSUM_DATA_VALID: ::kernel::sys::raw::c_uint = 134217728;
pub const CSUM_PSEUDO_HDR: ::kernel::sys::raw::c_uint = 67108864;
pub const CSUM_SCTP_VALID: ::kernel::sys::raw::c_uint = 134217728;
pub const CSUM_DELAY_IP: ::kernel::sys::raw::c_uint = 1;
pub const CSUM_DATA_VALID_IPV6: ::kernel::sys::raw::c_uint = 134217728;
pub const CSUM_TCP: ::kernel::sys::raw::c_uint = 4;
pub const CSUM_UDP: ::kernel::sys::raw::c_uint = 2;
pub const CSUM_SCTP: ::kernel::sys::raw::c_uint = 8;
pub const CSUM_TSO: ::kernel::sys::raw::c_uint = 4112;
pub const CSUM_UDP_IPV6: ::kernel::sys::raw::c_uint = 512;
pub const CSUM_TCP_IPV6: ::kernel::sys::raw::c_uint = 1024;
pub const CSUM_SCTP_IPV6: ::kernel::sys::raw::c_uint = 2048;
pub const MT_NOTMBUF: ::kernel::sys::raw::c_uint = 0;
pub const MT_DATA: ::kernel::sys::raw::c_uint = 1;
pub const MT_HEADER: ::kernel::sys::raw::c_uint = 1;
pub const MT_VENDOR1: ::kernel::sys::raw::c_uint = 4;
pub const MT_VENDOR2: ::kernel::sys::raw::c_uint = 5;
pub const MT_VENDOR3: ::kernel::sys::raw::c_uint = 6;
pub const MT_VENDOR4: ::kernel::sys::raw::c_uint = 7;
pub const MT_SONAME: ::kernel::sys::raw::c_uint = 8;
pub const MT_EXP1: ::kernel::sys::raw::c_uint = 9;
pub const MT_EXP2: ::kernel::sys::raw::c_uint = 10;
pub const MT_EXP3: ::kernel::sys::raw::c_uint = 11;
pub const MT_EXP4: ::kernel::sys::raw::c_uint = 12;
pub const MT_CONTROL: ::kernel::sys::raw::c_uint = 14;
pub const MT_OOBDATA: ::kernel::sys::raw::c_uint = 15;
pub const MT_NTYPES: ::kernel::sys::raw::c_uint = 16;
pub const MT_NOINIT: ::kernel::sys::raw::c_uint = 255;
pub const MBUF_MEM_NAME: &'static [u8; 5usize] = b"mbuf\x00";
pub const MBUF_CLUSTER_MEM_NAME: &'static [u8; 13usize] = b"mbuf_cluster\x00";
pub const MBUF_PACKET_MEM_NAME: &'static [u8; 12usize] = b"mbuf_packet\x00";
pub const MBUF_JUMBOP_MEM_NAME: &'static [u8; 16usize] =
    b"mbuf_jumbo_page\x00";
pub const MBUF_JUMBO9_MEM_NAME: &'static [u8; 14usize] = b"mbuf_jumbo_9k\x00";
pub const MBUF_JUMBO16_MEM_NAME: &'static [u8; 15usize] =
    b"mbuf_jumbo_16k\x00";
pub const MBUF_TAG_MEM_NAME: &'static [u8; 9usize] = b"mbuf_tag\x00";
pub const MBUF_EXTREFCNT_MEM_NAME: &'static [u8; 16usize] =
    b"mbuf_ext_refcnt\x00";
pub const M_COPYALL: ::kernel::sys::raw::c_uint = 1000000000;
pub const MTAG_PERSISTENT: ::kernel::sys::raw::c_uint = 2048;
pub const PACKET_TAG_NONE: ::kernel::sys::raw::c_uint = 0;
pub const PACKET_TAG_IPSEC_IN_DONE: ::kernel::sys::raw::c_uint = 1;
pub const PACKET_TAG_IPSEC_OUT_DONE: ::kernel::sys::raw::c_uint = 2;
pub const PACKET_TAG_IPSEC_IN_CRYPTO_DONE: ::kernel::sys::raw::c_uint = 3;
pub const PACKET_TAG_IPSEC_OUT_CRYPTO_NEEDED: ::kernel::sys::raw::c_uint = 4;
pub const PACKET_TAG_IPSEC_IN_COULD_DO_CRYPTO: ::kernel::sys::raw::c_uint = 5;
pub const PACKET_TAG_IPSEC_PENDING_TDB: ::kernel::sys::raw::c_uint = 6;
pub const PACKET_TAG_BRIDGE: ::kernel::sys::raw::c_uint = 7;
pub const PACKET_TAG_GIF: ::kernel::sys::raw::c_uint = 8;
pub const PACKET_TAG_GRE: ::kernel::sys::raw::c_uint = 9;
pub const PACKET_TAG_IN_PACKET_CHECKSUM: ::kernel::sys::raw::c_uint = 10;
pub const PACKET_TAG_ENCAP: ::kernel::sys::raw::c_uint = 11;
pub const PACKET_TAG_IPSEC_SOCKET: ::kernel::sys::raw::c_uint = 12;
pub const PACKET_TAG_IPSEC_HISTORY: ::kernel::sys::raw::c_uint = 13;
pub const PACKET_TAG_IPV6_INPUT: ::kernel::sys::raw::c_uint = 14;
pub const PACKET_TAG_DUMMYNET: ::kernel::sys::raw::c_uint = 15;
pub const PACKET_TAG_DIVERT: ::kernel::sys::raw::c_uint = 17;
pub const PACKET_TAG_IPFORWARD: ::kernel::sys::raw::c_uint = 18;
pub const PACKET_TAG_MACLABEL: ::kernel::sys::raw::c_uint = 2067;
pub const PACKET_TAG_PF: ::kernel::sys::raw::c_uint = 2069;
pub const PACKET_TAG_RTSOCKFAM: ::kernel::sys::raw::c_uint = 25;
pub const PACKET_TAG_IPOPTIONS: ::kernel::sys::raw::c_uint = 27;
pub const PACKET_TAG_CARP: ::kernel::sys::raw::c_uint = 28;
pub const PACKET_TAG_IPSEC_NAT_T_PORTS: ::kernel::sys::raw::c_uint = 29;
pub const PACKET_TAG_ND_OUTGOING: ::kernel::sys::raw::c_uint = 30;
pub const MTAG_ABI_COMPAT: ::kernel::sys::raw::c_uint = 0;
pub const MBUF_HASHFLAG_L2: ::kernel::sys::raw::c_uint = 4;
pub const MBUF_HASHFLAG_L3: ::kernel::sys::raw::c_uint = 8;
pub const MBUF_HASHFLAG_L4: ::kernel::sys::raw::c_uint = 16;
pub const PSL_C: ::kernel::sys::raw::c_uint = 1;
pub const PSL_PF: ::kernel::sys::raw::c_uint = 4;
pub const PSL_AF: ::kernel::sys::raw::c_uint = 16;
pub const PSL_Z: ::kernel::sys::raw::c_uint = 64;
pub const PSL_N: ::kernel::sys::raw::c_uint = 128;
pub const PSL_T: ::kernel::sys::raw::c_uint = 256;
pub const PSL_I: ::kernel::sys::raw::c_uint = 512;
pub const PSL_D: ::kernel::sys::raw::c_uint = 1024;
pub const PSL_V: ::kernel::sys::raw::c_uint = 2048;
pub const PSL_IOPL: ::kernel::sys::raw::c_uint = 12288;
pub const PSL_NT: ::kernel::sys::raw::c_uint = 16384;
pub const PSL_RF: ::kernel::sys::raw::c_uint = 65536;
pub const PSL_VM: ::kernel::sys::raw::c_uint = 131072;
pub const PSL_AC: ::kernel::sys::raw::c_uint = 262144;
pub const PSL_VIF: ::kernel::sys::raw::c_uint = 524288;
pub const PSL_VIP: ::kernel::sys::raw::c_uint = 1048576;
pub const PSL_ID: ::kernel::sys::raw::c_uint = 2097152;
pub const PSL_RESERVED_DEFAULT: ::kernel::sys::raw::c_uint = 2;
pub const PSL_KERNEL: ::kernel::sys::raw::c_uint = 2;
pub const PSL_USER: ::kernel::sys::raw::c_uint = 514;
pub const PSL_USERCHANGE: ::kernel::sys::raw::c_uint = 2444757;
pub const _MACHINE_FRAME_H_: ::kernel::sys::raw::c_uint = 1;
pub const TF_HASSEGS: ::kernel::sys::raw::c_uint = 1;
pub const TF_HASBASES: ::kernel::sys::raw::c_uint = 2;
pub const TF_HASFPXSTATE: ::kernel::sys::raw::c_uint = 4;
pub const SEL_RPL_MASK: ::kernel::sys::raw::c_uint = 3;
pub const SEL_KPL: ::kernel::sys::raw::c_uint = 0;
pub const SEL_UPL: ::kernel::sys::raw::c_uint = 3;
pub const SEL_LDT: ::kernel::sys::raw::c_uint = 4;
pub const SDT_SYSNULL: ::kernel::sys::raw::c_uint = 0;
pub const SDT_SYS286TSS: ::kernel::sys::raw::c_uint = 1;
pub const SDT_SYSLDT: ::kernel::sys::raw::c_uint = 2;
pub const SDT_SYS286BSY: ::kernel::sys::raw::c_uint = 3;
pub const SDT_SYS286CGT: ::kernel::sys::raw::c_uint = 4;
pub const SDT_SYSTASKGT: ::kernel::sys::raw::c_uint = 5;
pub const SDT_SYS286IGT: ::kernel::sys::raw::c_uint = 6;
pub const SDT_SYS286TGT: ::kernel::sys::raw::c_uint = 7;
pub const SDT_SYSNULL2: ::kernel::sys::raw::c_uint = 8;
pub const SDT_SYS386TSS: ::kernel::sys::raw::c_uint = 9;
pub const SDT_SYSTSS: ::kernel::sys::raw::c_uint = 9;
pub const SDT_SYSNULL3: ::kernel::sys::raw::c_uint = 10;
pub const SDT_SYS386BSY: ::kernel::sys::raw::c_uint = 11;
pub const SDT_SYSBSY: ::kernel::sys::raw::c_uint = 11;
pub const SDT_SYS386CGT: ::kernel::sys::raw::c_uint = 12;
pub const SDT_SYSCGT: ::kernel::sys::raw::c_uint = 12;
pub const SDT_SYSNULL4: ::kernel::sys::raw::c_uint = 13;
pub const SDT_SYS386IGT: ::kernel::sys::raw::c_uint = 14;
pub const SDT_SYSIGT: ::kernel::sys::raw::c_uint = 14;
pub const SDT_SYS386TGT: ::kernel::sys::raw::c_uint = 15;
pub const SDT_SYSTGT: ::kernel::sys::raw::c_uint = 15;
pub const SDT_MEMRO: ::kernel::sys::raw::c_uint = 16;
pub const SDT_MEMROA: ::kernel::sys::raw::c_uint = 17;
pub const SDT_MEMRW: ::kernel::sys::raw::c_uint = 18;
pub const SDT_MEMRWA: ::kernel::sys::raw::c_uint = 19;
pub const SDT_MEMROD: ::kernel::sys::raw::c_uint = 20;
pub const SDT_MEMRODA: ::kernel::sys::raw::c_uint = 21;
pub const SDT_MEMRWD: ::kernel::sys::raw::c_uint = 22;
pub const SDT_MEMRWDA: ::kernel::sys::raw::c_uint = 23;
pub const SDT_MEME: ::kernel::sys::raw::c_uint = 24;
pub const SDT_MEMEA: ::kernel::sys::raw::c_uint = 25;
pub const SDT_MEMER: ::kernel::sys::raw::c_uint = 26;
pub const SDT_MEMERA: ::kernel::sys::raw::c_uint = 27;
pub const SDT_MEMEC: ::kernel::sys::raw::c_uint = 28;
pub const SDT_MEMEAC: ::kernel::sys::raw::c_uint = 29;
pub const SDT_MEMERC: ::kernel::sys::raw::c_uint = 30;
pub const SDT_MEMERAC: ::kernel::sys::raw::c_uint = 31;
pub const NIDT: ::kernel::sys::raw::c_uint = 256;
pub const NRSVIDT: ::kernel::sys::raw::c_uint = 32;
pub const IDT_DE: ::kernel::sys::raw::c_uint = 0;
pub const IDT_DB: ::kernel::sys::raw::c_uint = 1;
pub const IDT_NMI: ::kernel::sys::raw::c_uint = 2;
pub const IDT_BP: ::kernel::sys::raw::c_uint = 3;
pub const IDT_OF: ::kernel::sys::raw::c_uint = 4;
pub const IDT_BR: ::kernel::sys::raw::c_uint = 5;
pub const IDT_UD: ::kernel::sys::raw::c_uint = 6;
pub const IDT_NM: ::kernel::sys::raw::c_uint = 7;
pub const IDT_DF: ::kernel::sys::raw::c_uint = 8;
pub const IDT_FPUGP: ::kernel::sys::raw::c_uint = 9;
pub const IDT_TS: ::kernel::sys::raw::c_uint = 10;
pub const IDT_NP: ::kernel::sys::raw::c_uint = 11;
pub const IDT_SS: ::kernel::sys::raw::c_uint = 12;
pub const IDT_GP: ::kernel::sys::raw::c_uint = 13;
pub const IDT_PF: ::kernel::sys::raw::c_uint = 14;
pub const IDT_MF: ::kernel::sys::raw::c_uint = 16;
pub const IDT_AC: ::kernel::sys::raw::c_uint = 17;
pub const IDT_MC: ::kernel::sys::raw::c_uint = 18;
pub const IDT_XF: ::kernel::sys::raw::c_uint = 19;
pub const IDT_IO_INTS: ::kernel::sys::raw::c_uint = 32;
pub const IDT_SYSCALL: ::kernel::sys::raw::c_uint = 128;
pub const IDT_DTRACE_RET: ::kernel::sys::raw::c_uint = 146;
pub const IDT_EVTCHN: ::kernel::sys::raw::c_uint = 147;
pub const GNULL_SEL: ::kernel::sys::raw::c_uint = 0;
pub const GNULL2_SEL: ::kernel::sys::raw::c_uint = 1;
pub const GUFS32_SEL: ::kernel::sys::raw::c_uint = 2;
pub const GUGS32_SEL: ::kernel::sys::raw::c_uint = 3;
pub const GCODE_SEL: ::kernel::sys::raw::c_uint = 4;
pub const GDATA_SEL: ::kernel::sys::raw::c_uint = 5;
pub const GUCODE32_SEL: ::kernel::sys::raw::c_uint = 6;
pub const GUDATA_SEL: ::kernel::sys::raw::c_uint = 7;
pub const GUCODE_SEL: ::kernel::sys::raw::c_uint = 8;
pub const GPROC0_SEL: ::kernel::sys::raw::c_uint = 9;
pub const GUSERLDT_SEL: ::kernel::sys::raw::c_uint = 11;
pub const NGDT: ::kernel::sys::raw::c_uint = 13;
pub const VNET_MAGIC_N: ::kernel::sys::raw::c_uint = 1041076009;
pub const VNET_SETNAME: &'static [u8; 9usize] = b"set_vnet\x00";
pub const VNET_SYMPREFIX: &'static [u8; 12usize] = b"vnet_entry_\x00";
pub const CK_MD_CACHELINE: ::kernel::sys::raw::c_uint = 64;
pub const CK_MD_PAGESIZE: ::kernel::sys::raw::c_uint = 4096;
pub const CK_MD_CC_BUILTIN_DISABLE: ::kernel::sys::raw::c_uint = 1;
pub const CK_VERSION: &'static [u8; 6usize] = b"0.7.0\x00";
pub const CK_GIT_SHA: &'static [u8; 8usize] = b"db5db44\x00";
pub const CK_CC_IMM: &'static [u8; 2usize] = b"i\x00";
pub const CK_CC_IMM_U32: &'static [u8; 2usize] = b"Z\x00";
pub const CK_CC_IMM_S32: &'static [u8; 2usize] = b"e\x00";
pub const CHAR_BIT: ::kernel::sys::raw::c_uint = 8;
pub const SCHAR_MAX: ::kernel::sys::raw::c_uint = 127;
pub const SCHAR_MIN: ::kernel::sys::raw::c_int = -128;
pub const UCHAR_MAX: ::kernel::sys::raw::c_uint = 255;
pub const CHAR_MAX: ::kernel::sys::raw::c_uint = 127;
pub const CHAR_MIN: ::kernel::sys::raw::c_int = -128;
pub const USHRT_MAX: ::kernel::sys::raw::c_uint = 65535;
pub const SHRT_MAX: ::kernel::sys::raw::c_uint = 32767;
pub const SHRT_MIN: ::kernel::sys::raw::c_int = -32768;
pub const UINT_MAX: ::kernel::sys::raw::c_uint = 4294967295;
pub const INT_MAX: ::kernel::sys::raw::c_uint = 2147483647;
pub const INT_MIN: ::kernel::sys::raw::c_int = -2147483648;
pub const ULONG_MAX: ::kernel::sys::raw::c_int = -1;
pub const LONG_MAX: ::kernel::sys::raw::c_ulonglong = 9223372036854775807;
pub const LONG_MIN: ::kernel::sys::raw::c_longlong = -9223372036854775808;
pub const ULLONG_MAX: ::kernel::sys::raw::c_int = -1;
pub const LLONG_MAX: ::kernel::sys::raw::c_ulonglong = 9223372036854775807;
pub const LLONG_MIN: ::kernel::sys::raw::c_longlong = -9223372036854775808;
pub const SSIZE_MAX: ::kernel::sys::raw::c_ulonglong = 9223372036854775807;
pub const SIZE_T_MAX: ::kernel::sys::raw::c_int = -1;
pub const OFF_MAX: ::kernel::sys::raw::c_ulonglong = 9223372036854775807;
pub const OFF_MIN: ::kernel::sys::raw::c_longlong = -9223372036854775808;
pub const GID_MAX: ::kernel::sys::raw::c_uint = 4294967295;
pub const UID_MAX: ::kernel::sys::raw::c_uint = 4294967295;
pub const UQUAD_MAX: ::kernel::sys::raw::c_int = -1;
pub const QUAD_MAX: ::kernel::sys::raw::c_ulonglong = 9223372036854775807;
pub const QUAD_MIN: ::kernel::sys::raw::c_longlong = -9223372036854775808;
pub const LONG_BIT: ::kernel::sys::raw::c_uint = 64;
pub const WORD_BIT: ::kernel::sys::raw::c_uint = 32;
pub const MQ_PRIO_MAX: ::kernel::sys::raw::c_uint = 64;
pub const CK_EPOCH_LENGTH: ::kernel::sys::raw::c_uint = 4;
pub const CK_EPOCH_SENSE: ::kernel::sys::raw::c_uint = 2;
pub const CPU_SETSIZE: ::kernel::sys::raw::c_uint = 256;
pub const CPU_MAXSIZE: ::kernel::sys::raw::c_uint = 256;
pub const PRIO_MIN: ::kernel::sys::raw::c_int = -20;
pub const PRIO_MAX: ::kernel::sys::raw::c_uint = 20;
pub const PRIO_PROCESS: ::kernel::sys::raw::c_uint = 0;
pub const PRIO_PGRP: ::kernel::sys::raw::c_uint = 1;
pub const PRIO_USER: ::kernel::sys::raw::c_uint = 2;
pub const RUSAGE_SELF: ::kernel::sys::raw::c_uint = 0;
pub const RUSAGE_CHILDREN: ::kernel::sys::raw::c_int = -1;
pub const RUSAGE_THREAD: ::kernel::sys::raw::c_uint = 1;
pub const RLIMIT_CPU: ::kernel::sys::raw::c_uint = 0;
pub const RLIMIT_FSIZE: ::kernel::sys::raw::c_uint = 1;
pub const RLIMIT_DATA: ::kernel::sys::raw::c_uint = 2;
pub const RLIMIT_STACK: ::kernel::sys::raw::c_uint = 3;
pub const RLIMIT_CORE: ::kernel::sys::raw::c_uint = 4;
pub const RLIMIT_RSS: ::kernel::sys::raw::c_uint = 5;
pub const RLIMIT_MEMLOCK: ::kernel::sys::raw::c_uint = 6;
pub const RLIMIT_NPROC: ::kernel::sys::raw::c_uint = 7;
pub const RLIMIT_NOFILE: ::kernel::sys::raw::c_uint = 8;
pub const RLIMIT_SBSIZE: ::kernel::sys::raw::c_uint = 9;
pub const RLIMIT_VMEM: ::kernel::sys::raw::c_uint = 10;
pub const RLIMIT_AS: ::kernel::sys::raw::c_uint = 10;
pub const RLIMIT_NPTS: ::kernel::sys::raw::c_uint = 11;
pub const RLIMIT_SWAP: ::kernel::sys::raw::c_uint = 12;
pub const RLIMIT_KQUEUES: ::kernel::sys::raw::c_uint = 13;
pub const RLIMIT_UMTXP: ::kernel::sys::raw::c_uint = 14;
pub const RLIM_NLIMITS: ::kernel::sys::raw::c_uint = 15;
pub const CP_USER: ::kernel::sys::raw::c_uint = 0;
pub const CP_NICE: ::kernel::sys::raw::c_uint = 1;
pub const CP_SYS: ::kernel::sys::raw::c_uint = 2;
pub const CP_INTR: ::kernel::sys::raw::c_uint = 3;
pub const CP_IDLE: ::kernel::sys::raw::c_uint = 4;
pub const CPUSTATES: ::kernel::sys::raw::c_uint = 5;
pub const PC_PTI_STACK_SZ: ::kernel::sys::raw::c_uint = 16;
pub const PC_DBREG_CMD_NONE: ::kernel::sys::raw::c_uint = 0;
pub const PC_DBREG_CMD_LOAD: ::kernel::sys::raw::c_uint = 1;
pub const OFFSETOF_CURTHREAD: ::kernel::sys::raw::c_uint = 0;
pub const OFFSETOF_CURPCB: ::kernel::sys::raw::c_uint = 32;
pub const DPCPU_SETNAME: &'static [u8; 9usize] = b"set_pcpu\x00";
pub const DPCPU_SYMPREFIX: &'static [u8; 12usize] = b"pcpu_entry_\x00";
pub const DPCPU_MODMIN: ::kernel::sys::raw::c_uint = 2048;
pub const KTR_GEN: ::kernel::sys::raw::c_uint = 1;
pub const KTR_NET: ::kernel::sys::raw::c_uint = 2;
pub const KTR_DEV: ::kernel::sys::raw::c_uint = 4;
pub const KTR_LOCK: ::kernel::sys::raw::c_uint = 8;
pub const KTR_SMP: ::kernel::sys::raw::c_uint = 16;
pub const KTR_SUBSYS: ::kernel::sys::raw::c_uint = 32;
pub const KTR_PMAP: ::kernel::sys::raw::c_uint = 64;
pub const KTR_MALLOC: ::kernel::sys::raw::c_uint = 128;
pub const KTR_TRAP: ::kernel::sys::raw::c_uint = 256;
pub const KTR_INTR: ::kernel::sys::raw::c_uint = 512;
pub const KTR_SIG: ::kernel::sys::raw::c_uint = 1024;
pub const KTR_SPARE2: ::kernel::sys::raw::c_uint = 2048;
pub const KTR_PROC: ::kernel::sys::raw::c_uint = 4096;
pub const KTR_SYSC: ::kernel::sys::raw::c_uint = 8192;
pub const KTR_INIT: ::kernel::sys::raw::c_uint = 16384;
pub const KTR_SPARE3: ::kernel::sys::raw::c_uint = 32768;
pub const KTR_SPARE4: ::kernel::sys::raw::c_uint = 65536;
pub const KTR_EVH: ::kernel::sys::raw::c_uint = 131072;
pub const KTR_VFS: ::kernel::sys::raw::c_uint = 262144;
pub const KTR_VOP: ::kernel::sys::raw::c_uint = 524288;
pub const KTR_VM: ::kernel::sys::raw::c_uint = 1048576;
pub const KTR_INET: ::kernel::sys::raw::c_uint = 2097152;
pub const KTR_RUNQ: ::kernel::sys::raw::c_uint = 4194304;
pub const KTR_SPARE5: ::kernel::sys::raw::c_uint = 8388608;
pub const KTR_UMA: ::kernel::sys::raw::c_uint = 16777216;
pub const KTR_CALLOUT: ::kernel::sys::raw::c_uint = 33554432;
pub const KTR_GEOM: ::kernel::sys::raw::c_uint = 67108864;
pub const KTR_BUSDMA: ::kernel::sys::raw::c_uint = 134217728;
pub const KTR_INET6: ::kernel::sys::raw::c_uint = 268435456;
pub const KTR_SCHED: ::kernel::sys::raw::c_uint = 536870912;
pub const KTR_BUF: ::kernel::sys::raw::c_uint = 1073741824;
pub const KTR_PTRACE: ::kernel::sys::raw::c_uint = 2147483648;
pub const KTR_ALL: ::kernel::sys::raw::c_uint = 4294967295;
pub const KTR_COMPILE: ::kernel::sys::raw::c_uint = 0;
pub const LC_SLEEPLOCK: ::kernel::sys::raw::c_uint = 1;
pub const LC_SPINLOCK: ::kernel::sys::raw::c_uint = 2;
pub const LC_SLEEPABLE: ::kernel::sys::raw::c_uint = 4;
pub const LC_RECURSABLE: ::kernel::sys::raw::c_uint = 8;
pub const LC_UPGRADABLE: ::kernel::sys::raw::c_uint = 16;
pub const LO_CLASSFLAGS: ::kernel::sys::raw::c_uint = 65535;
pub const LO_INITIALIZED: ::kernel::sys::raw::c_uint = 65536;
pub const LO_WITNESS: ::kernel::sys::raw::c_uint = 131072;
pub const LO_QUIET: ::kernel::sys::raw::c_uint = 262144;
pub const LO_RECURSABLE: ::kernel::sys::raw::c_uint = 524288;
pub const LO_SLEEPABLE: ::kernel::sys::raw::c_uint = 1048576;
pub const LO_UPGRADABLE: ::kernel::sys::raw::c_uint = 2097152;
pub const LO_DUPOK: ::kernel::sys::raw::c_uint = 4194304;
pub const LO_IS_VNODE: ::kernel::sys::raw::c_uint = 8388608;
pub const LO_CLASSMASK: ::kernel::sys::raw::c_uint = 251658240;
pub const LO_NOPROFILE: ::kernel::sys::raw::c_uint = 268435456;
pub const LO_NEW: ::kernel::sys::raw::c_uint = 536870912;
pub const LO_CLASSSHIFT: ::kernel::sys::raw::c_uint = 24;
pub const LOCK_CLASS_MAX: ::kernel::sys::raw::c_uint = 15;
pub const LOP_NEWORDER: ::kernel::sys::raw::c_uint = 1;
pub const LOP_QUIET: ::kernel::sys::raw::c_uint = 2;
pub const LOP_TRYLOCK: ::kernel::sys::raw::c_uint = 4;
pub const LOP_EXCLUSIVE: ::kernel::sys::raw::c_uint = 8;
pub const LOP_DUPOK: ::kernel::sys::raw::c_uint = 16;
pub const LA_MASKASSERT: ::kernel::sys::raw::c_uint = 255;
pub const LA_UNLOCKED: ::kernel::sys::raw::c_uint = 0;
pub const LA_LOCKED: ::kernel::sys::raw::c_uint = 1;
pub const LA_SLOCKED: ::kernel::sys::raw::c_uint = 2;
pub const LA_XLOCKED: ::kernel::sys::raw::c_uint = 4;
pub const LA_RECURSED: ::kernel::sys::raw::c_uint = 8;
pub const LA_NOTRECURSED: ::kernel::sys::raw::c_uint = 16;
pub const LOCK_DEBUG: ::kernel::sys::raw::c_uint = 1;
pub const EVFILT_READ: ::kernel::sys::raw::c_int = -1;
pub const EVFILT_WRITE: ::kernel::sys::raw::c_int = -2;
pub const EVFILT_AIO: ::kernel::sys::raw::c_int = -3;
pub const EVFILT_VNODE: ::kernel::sys::raw::c_int = -4;
pub const EVFILT_PROC: ::kernel::sys::raw::c_int = -5;
pub const EVFILT_SIGNAL: ::kernel::sys::raw::c_int = -6;
pub const EVFILT_TIMER: ::kernel::sys::raw::c_int = -7;
pub const EVFILT_PROCDESC: ::kernel::sys::raw::c_int = -8;
pub const EVFILT_FS: ::kernel::sys::raw::c_int = -9;
pub const EVFILT_LIO: ::kernel::sys::raw::c_int = -10;
pub const EVFILT_USER: ::kernel::sys::raw::c_int = -11;
pub const EVFILT_SENDFILE: ::kernel::sys::raw::c_int = -12;
pub const EVFILT_EMPTY: ::kernel::sys::raw::c_int = -13;
pub const EVFILT_SYSCOUNT: ::kernel::sys::raw::c_uint = 13;
pub const EV_ADD: ::kernel::sys::raw::c_uint = 1;
pub const EV_DELETE: ::kernel::sys::raw::c_uint = 2;
pub const EV_ENABLE: ::kernel::sys::raw::c_uint = 4;
pub const EV_DISABLE: ::kernel::sys::raw::c_uint = 8;
pub const EV_FORCEONESHOT: ::kernel::sys::raw::c_uint = 256;
pub const EV_ONESHOT: ::kernel::sys::raw::c_uint = 16;
pub const EV_CLEAR: ::kernel::sys::raw::c_uint = 32;
pub const EV_RECEIPT: ::kernel::sys::raw::c_uint = 64;
pub const EV_DISPATCH: ::kernel::sys::raw::c_uint = 128;
pub const EV_SYSFLAGS: ::kernel::sys::raw::c_uint = 61440;
pub const EV_DROP: ::kernel::sys::raw::c_uint = 4096;
pub const EV_FLAG1: ::kernel::sys::raw::c_uint = 8192;
pub const EV_FLAG2: ::kernel::sys::raw::c_uint = 16384;
pub const EV_EOF: ::kernel::sys::raw::c_uint = 32768;
pub const EV_ERROR: ::kernel::sys::raw::c_uint = 16384;
pub const NOTE_FFNOP: ::kernel::sys::raw::c_uint = 0;
pub const NOTE_FFAND: ::kernel::sys::raw::c_uint = 1073741824;
pub const NOTE_FFOR: ::kernel::sys::raw::c_uint = 2147483648;
pub const NOTE_FFCOPY: ::kernel::sys::raw::c_uint = 3221225472;
pub const NOTE_FFCTRLMASK: ::kernel::sys::raw::c_uint = 3221225472;
pub const NOTE_FFLAGSMASK: ::kernel::sys::raw::c_uint = 16777215;
pub const NOTE_TRIGGER: ::kernel::sys::raw::c_uint = 16777216;
pub const NOTE_LOWAT: ::kernel::sys::raw::c_uint = 1;
pub const NOTE_FILE_POLL: ::kernel::sys::raw::c_uint = 2;
pub const NOTE_DELETE: ::kernel::sys::raw::c_uint = 1;
pub const NOTE_WRITE: ::kernel::sys::raw::c_uint = 2;
pub const NOTE_EXTEND: ::kernel::sys::raw::c_uint = 4;
pub const NOTE_ATTRIB: ::kernel::sys::raw::c_uint = 8;
pub const NOTE_LINK: ::kernel::sys::raw::c_uint = 16;
pub const NOTE_RENAME: ::kernel::sys::raw::c_uint = 32;
pub const NOTE_REVOKE: ::kernel::sys::raw::c_uint = 64;
pub const NOTE_OPEN: ::kernel::sys::raw::c_uint = 128;
pub const NOTE_CLOSE: ::kernel::sys::raw::c_uint = 256;
pub const NOTE_CLOSE_WRITE: ::kernel::sys::raw::c_uint = 512;
pub const NOTE_READ: ::kernel::sys::raw::c_uint = 1024;
pub const NOTE_EXIT: ::kernel::sys::raw::c_uint = 2147483648;
pub const NOTE_FORK: ::kernel::sys::raw::c_uint = 1073741824;
pub const NOTE_EXEC: ::kernel::sys::raw::c_uint = 536870912;
pub const NOTE_PCTRLMASK: ::kernel::sys::raw::c_uint = 4026531840;
pub const NOTE_PDATAMASK: ::kernel::sys::raw::c_uint = 1048575;
pub const NOTE_TRACK: ::kernel::sys::raw::c_uint = 1;
pub const NOTE_TRACKERR: ::kernel::sys::raw::c_uint = 2;
pub const NOTE_CHILD: ::kernel::sys::raw::c_uint = 4;
pub const NOTE_SECONDS: ::kernel::sys::raw::c_uint = 1;
pub const NOTE_MSECONDS: ::kernel::sys::raw::c_uint = 2;
pub const NOTE_USECONDS: ::kernel::sys::raw::c_uint = 4;
pub const NOTE_NSECONDS: ::kernel::sys::raw::c_uint = 8;
pub const NOTE_ABSTIME: ::kernel::sys::raw::c_uint = 16;
pub const KNF_LISTLOCKED: ::kernel::sys::raw::c_uint = 1;
pub const KNF_NOKQLOCK: ::kernel::sys::raw::c_uint = 2;
pub const NOTE_SIGNAL: ::kernel::sys::raw::c_uint = 134217728;
pub const EVENT_REGISTER: ::kernel::sys::raw::c_uint = 1;
pub const EVENT_PROCESS: ::kernel::sys::raw::c_uint = 2;
pub const KN_ACTIVE: ::kernel::sys::raw::c_uint = 1;
pub const KN_QUEUED: ::kernel::sys::raw::c_uint = 2;
pub const KN_DISABLED: ::kernel::sys::raw::c_uint = 4;
pub const KN_DETACHED: ::kernel::sys::raw::c_uint = 8;
pub const KN_MARKER: ::kernel::sys::raw::c_uint = 32;
pub const KN_KQUEUE: ::kernel::sys::raw::c_uint = 64;
pub const KN_HASKQLOCK: ::kernel::sys::raw::c_uint = 128;
pub const KN_SCAN: ::kernel::sys::raw::c_uint = 256;
pub const OSD_THREAD: ::kernel::sys::raw::c_uint = 0;
pub const OSD_JAIL: ::kernel::sys::raw::c_uint = 1;
pub const OSD_KHELP: ::kernel::sys::raw::c_uint = 2;
pub const OSD_FIRST: ::kernel::sys::raw::c_uint = 0;
pub const OSD_LAST: ::kernel::sys::raw::c_uint = 2;
pub const RTP_PRIO_REALTIME: ::kernel::sys::raw::c_uint = 2;
pub const RTP_PRIO_NORMAL: ::kernel::sys::raw::c_uint = 3;
pub const RTP_PRIO_IDLE: ::kernel::sys::raw::c_uint = 4;
pub const RTP_PRIO_FIFO_BIT: ::kernel::sys::raw::c_uint = 8;
pub const RTP_PRIO_FIFO: ::kernel::sys::raw::c_uint = 10;
pub const RTP_PRIO_MIN: ::kernel::sys::raw::c_uint = 0;
pub const RTP_PRIO_MAX: ::kernel::sys::raw::c_uint = 31;
pub const RTP_LOOKUP: ::kernel::sys::raw::c_uint = 0;
pub const RTP_SET: ::kernel::sys::raw::c_uint = 1;
pub const RQB_LEN: ::kernel::sys::raw::c_uint = 1;
pub const RQB_L2BPW: ::kernel::sys::raw::c_uint = 6;
pub const RQB_BPW: ::kernel::sys::raw::c_uint = 64;
pub const RQ_NQS: ::kernel::sys::raw::c_uint = 64;
pub const RQ_PPQ: ::kernel::sys::raw::c_uint = 4;
pub const _X86_SIGNAL_H: ::kernel::sys::raw::c_uint = 1;
pub const SIGHUP: ::kernel::sys::raw::c_uint = 1;
pub const SIGINT: ::kernel::sys::raw::c_uint = 2;
pub const SIGQUIT: ::kernel::sys::raw::c_uint = 3;
pub const SIGILL: ::kernel::sys::raw::c_uint = 4;
pub const SIGTRAP: ::kernel::sys::raw::c_uint = 5;
pub const SIGABRT: ::kernel::sys::raw::c_uint = 6;
pub const SIGIOT: ::kernel::sys::raw::c_uint = 6;
pub const SIGEMT: ::kernel::sys::raw::c_uint = 7;
pub const SIGFPE: ::kernel::sys::raw::c_uint = 8;
pub const SIGKILL: ::kernel::sys::raw::c_uint = 9;
pub const SIGBUS: ::kernel::sys::raw::c_uint = 10;
pub const SIGSEGV: ::kernel::sys::raw::c_uint = 11;
pub const SIGSYS: ::kernel::sys::raw::c_uint = 12;
pub const SIGPIPE: ::kernel::sys::raw::c_uint = 13;
pub const SIGALRM: ::kernel::sys::raw::c_uint = 14;
pub const SIGTERM: ::kernel::sys::raw::c_uint = 15;
pub const SIGURG: ::kernel::sys::raw::c_uint = 16;
pub const SIGSTOP: ::kernel::sys::raw::c_uint = 17;
pub const SIGTSTP: ::kernel::sys::raw::c_uint = 18;
pub const SIGCONT: ::kernel::sys::raw::c_uint = 19;
pub const SIGCHLD: ::kernel::sys::raw::c_uint = 20;
pub const SIGTTIN: ::kernel::sys::raw::c_uint = 21;
pub const SIGTTOU: ::kernel::sys::raw::c_uint = 22;
pub const SIGIO: ::kernel::sys::raw::c_uint = 23;
pub const SIGXCPU: ::kernel::sys::raw::c_uint = 24;
pub const SIGXFSZ: ::kernel::sys::raw::c_uint = 25;
pub const SIGVTALRM: ::kernel::sys::raw::c_uint = 26;
pub const SIGPROF: ::kernel::sys::raw::c_uint = 27;
pub const SIGWINCH: ::kernel::sys::raw::c_uint = 28;
pub const SIGINFO: ::kernel::sys::raw::c_uint = 29;
pub const SIGUSR1: ::kernel::sys::raw::c_uint = 30;
pub const SIGUSR2: ::kernel::sys::raw::c_uint = 31;
pub const SIGTHR: ::kernel::sys::raw::c_uint = 32;
pub const SIGLWP: ::kernel::sys::raw::c_uint = 32;
pub const SIGLIBRT: ::kernel::sys::raw::c_uint = 33;
pub const SIGRTMIN: ::kernel::sys::raw::c_uint = 65;
pub const SIGRTMAX: ::kernel::sys::raw::c_uint = 126;
pub const SIGEV_NONE: ::kernel::sys::raw::c_uint = 0;
pub const SIGEV_SIGNAL: ::kernel::sys::raw::c_uint = 1;
pub const SIGEV_THREAD: ::kernel::sys::raw::c_uint = 2;
pub const SIGEV_KEVENT: ::kernel::sys::raw::c_uint = 3;
pub const SIGEV_THREAD_ID: ::kernel::sys::raw::c_uint = 4;
pub const ILL_ILLOPC: ::kernel::sys::raw::c_uint = 1;
pub const ILL_ILLOPN: ::kernel::sys::raw::c_uint = 2;
pub const ILL_ILLADR: ::kernel::sys::raw::c_uint = 3;
pub const ILL_ILLTRP: ::kernel::sys::raw::c_uint = 4;
pub const ILL_PRVOPC: ::kernel::sys::raw::c_uint = 5;
pub const ILL_PRVREG: ::kernel::sys::raw::c_uint = 6;
pub const ILL_COPROC: ::kernel::sys::raw::c_uint = 7;
pub const ILL_BADSTK: ::kernel::sys::raw::c_uint = 8;
pub const BUS_ADRALN: ::kernel::sys::raw::c_uint = 1;
pub const BUS_ADRERR: ::kernel::sys::raw::c_uint = 2;
pub const BUS_OBJERR: ::kernel::sys::raw::c_uint = 3;
pub const SEGV_MAPERR: ::kernel::sys::raw::c_uint = 1;
pub const SEGV_ACCERR: ::kernel::sys::raw::c_uint = 2;
pub const FPE_INTOVF: ::kernel::sys::raw::c_uint = 1;
pub const FPE_INTDIV: ::kernel::sys::raw::c_uint = 2;
pub const FPE_FLTDIV: ::kernel::sys::raw::c_uint = 3;
pub const FPE_FLTOVF: ::kernel::sys::raw::c_uint = 4;
pub const FPE_FLTUND: ::kernel::sys::raw::c_uint = 5;
pub const FPE_FLTRES: ::kernel::sys::raw::c_uint = 6;
pub const FPE_FLTINV: ::kernel::sys::raw::c_uint = 7;
pub const FPE_FLTSUB: ::kernel::sys::raw::c_uint = 8;
pub const TRAP_BRKPT: ::kernel::sys::raw::c_uint = 1;
pub const TRAP_TRACE: ::kernel::sys::raw::c_uint = 2;
pub const TRAP_DTRACE: ::kernel::sys::raw::c_uint = 3;
pub const TRAP_CAP: ::kernel::sys::raw::c_uint = 4;
pub const CLD_EXITED: ::kernel::sys::raw::c_uint = 1;
pub const CLD_KILLED: ::kernel::sys::raw::c_uint = 2;
pub const CLD_DUMPED: ::kernel::sys::raw::c_uint = 3;
pub const CLD_TRAPPED: ::kernel::sys::raw::c_uint = 4;
pub const CLD_STOPPED: ::kernel::sys::raw::c_uint = 5;
pub const CLD_CONTINUED: ::kernel::sys::raw::c_uint = 6;
pub const POLL_IN: ::kernel::sys::raw::c_uint = 1;
pub const POLL_OUT: ::kernel::sys::raw::c_uint = 2;
pub const POLL_MSG: ::kernel::sys::raw::c_uint = 3;
pub const POLL_ERR: ::kernel::sys::raw::c_uint = 4;
pub const POLL_PRI: ::kernel::sys::raw::c_uint = 5;
pub const POLL_HUP: ::kernel::sys::raw::c_uint = 6;
pub const SA_NOCLDSTOP: ::kernel::sys::raw::c_uint = 8;
pub const SA_ONSTACK: ::kernel::sys::raw::c_uint = 1;
pub const SA_RESTART: ::kernel::sys::raw::c_uint = 2;
pub const SA_RESETHAND: ::kernel::sys::raw::c_uint = 4;
pub const SA_NODEFER: ::kernel::sys::raw::c_uint = 16;
pub const SA_NOCLDWAIT: ::kernel::sys::raw::c_uint = 32;
pub const SA_SIGINFO: ::kernel::sys::raw::c_uint = 64;
pub const NSIG: ::kernel::sys::raw::c_uint = 32;
pub const SI_NOINFO: ::kernel::sys::raw::c_uint = 0;
pub const SI_USER: ::kernel::sys::raw::c_uint = 65537;
pub const SI_QUEUE: ::kernel::sys::raw::c_uint = 65538;
pub const SI_TIMER: ::kernel::sys::raw::c_uint = 65539;
pub const SI_ASYNCIO: ::kernel::sys::raw::c_uint = 65540;
pub const SI_MESGQ: ::kernel::sys::raw::c_uint = 65541;
pub const SI_KERNEL: ::kernel::sys::raw::c_uint = 65542;
pub const SI_LWP: ::kernel::sys::raw::c_uint = 65543;
pub const SI_UNDEFINED: ::kernel::sys::raw::c_uint = 0;
pub const SS_ONSTACK: ::kernel::sys::raw::c_uint = 1;
pub const SS_DISABLE: ::kernel::sys::raw::c_uint = 4;
pub const MINSIGSTKSZ: ::kernel::sys::raw::c_uint = 2048;
pub const SIGSTKSZ: ::kernel::sys::raw::c_uint = 34816;
pub const SV_ONSTACK: ::kernel::sys::raw::c_uint = 1;
pub const SV_INTERRUPT: ::kernel::sys::raw::c_uint = 2;
pub const SV_RESETHAND: ::kernel::sys::raw::c_uint = 4;
pub const SV_NODEFER: ::kernel::sys::raw::c_uint = 16;
pub const SV_NOCLDSTOP: ::kernel::sys::raw::c_uint = 8;
pub const SV_SIGINFO: ::kernel::sys::raw::c_uint = 64;
pub const SIG_BLOCK: ::kernel::sys::raw::c_uint = 1;
pub const SIG_UNBLOCK: ::kernel::sys::raw::c_uint = 2;
pub const SIG_SETMASK: ::kernel::sys::raw::c_uint = 3;
pub const PS_NOCLDWAIT: ::kernel::sys::raw::c_uint = 1;
pub const PS_NOCLDSTOP: ::kernel::sys::raw::c_uint = 2;
pub const PS_CLDSIGIGN: ::kernel::sys::raw::c_uint = 4;
pub const KSI_TRAP: ::kernel::sys::raw::c_uint = 1;
pub const KSI_EXT: ::kernel::sys::raw::c_uint = 2;
pub const KSI_INS: ::kernel::sys::raw::c_uint = 4;
pub const KSI_SIGQ: ::kernel::sys::raw::c_uint = 8;
pub const KSI_HEAD: ::kernel::sys::raw::c_uint = 16;
pub const KSI_PTRACE: ::kernel::sys::raw::c_uint = 32;
pub const KSI_COPYMASK: ::kernel::sys::raw::c_uint = 41;
pub const SQ_INIT: ::kernel::sys::raw::c_uint = 1;
pub const SIGPROCMASK_OLD: ::kernel::sys::raw::c_uint = 1;
pub const SIGPROCMASK_PROC_LOCKED: ::kernel::sys::raw::c_uint = 2;
pub const SIGPROCMASK_PS_LOCKED: ::kernel::sys::raw::c_uint = 4;
pub const SIGDEFERSTOP_NOP: ::kernel::sys::raw::c_uint = 0;
pub const SIGDEFERSTOP_OFF: ::kernel::sys::raw::c_uint = 1;
pub const SIGDEFERSTOP_SILENT: ::kernel::sys::raw::c_uint = 2;
pub const SIGDEFERSTOP_EINTR: ::kernel::sys::raw::c_uint = 3;
pub const SIGDEFERSTOP_ERESTART: ::kernel::sys::raw::c_uint = 4;
pub const SIGDEFERSTOP_VAL_NCHG: ::kernel::sys::raw::c_int = -1;
pub const _MC_HASSEGS: ::kernel::sys::raw::c_uint = 1;
pub const _MC_HASBASES: ::kernel::sys::raw::c_uint = 2;
pub const _MC_HASFPXSTATE: ::kernel::sys::raw::c_uint = 4;
pub const _MC_FLAG_MASK: ::kernel::sys::raw::c_uint = 7;
pub const _MC_FPFMT_NODEV: ::kernel::sys::raw::c_uint = 65536;
pub const _MC_FPFMT_XMM: ::kernel::sys::raw::c_uint = 65538;
pub const _MC_FPOWNED_NONE: ::kernel::sys::raw::c_uint = 131072;
pub const _MC_FPOWNED_FPU: ::kernel::sys::raw::c_uint = 131073;
pub const _MC_FPOWNED_PCB: ::kernel::sys::raw::c_uint = 131074;
pub const UCF_SWAPPED: ::kernel::sys::raw::c_uint = 1;
pub const GET_MC_CLEAR_RET: ::kernel::sys::raw::c_uint = 1;
pub const AUDIT_RECORD_MAGIC: ::kernel::sys::raw::c_uint = 2190085915;
pub const MAX_AUDIT_RECORDS: ::kernel::sys::raw::c_uint = 20;
pub const MAXAUDITDATA: ::kernel::sys::raw::c_uint = 32767;
pub const MAX_AUDIT_RECORD_SIZE: ::kernel::sys::raw::c_uint = 32767;
pub const MIN_AUDIT_FILE_SIZE: ::kernel::sys::raw::c_uint = 524288;
pub const AUDIT_HARD_LIMIT_FREE_BLOCKS: ::kernel::sys::raw::c_uint = 4;
pub const AUDIT_TRIGGER_MIN: ::kernel::sys::raw::c_uint = 1;
pub const AUDIT_TRIGGER_LOW_SPACE: ::kernel::sys::raw::c_uint = 1;
pub const AUDIT_TRIGGER_ROTATE_KERNEL: ::kernel::sys::raw::c_uint = 2;
pub const AUDIT_TRIGGER_READ_FILE: ::kernel::sys::raw::c_uint = 3;
pub const AUDIT_TRIGGER_CLOSE_AND_DIE: ::kernel::sys::raw::c_uint = 4;
pub const AUDIT_TRIGGER_NO_SPACE: ::kernel::sys::raw::c_uint = 5;
pub const AUDIT_TRIGGER_ROTATE_USER: ::kernel::sys::raw::c_uint = 6;
pub const AUDIT_TRIGGER_INITIALIZE: ::kernel::sys::raw::c_uint = 7;
pub const AUDIT_TRIGGER_EXPIRE_TRAILS: ::kernel::sys::raw::c_uint = 8;
pub const AUDIT_TRIGGER_MAX: ::kernel::sys::raw::c_uint = 8;
pub const AUDITDEV_FILENAME: &'static [u8; 6usize] = b"audit\x00";
pub const AUDIT_TRIGGER_FILE: &'static [u8; 11usize] = b"/dev/audit\x00";
pub const AU_DEFAUDITSID: ::kernel::sys::raw::c_uint = 0;
pub const AU_ASSIGN_ASID: ::kernel::sys::raw::c_int = -1;
pub const AUC_UNSET: ::kernel::sys::raw::c_uint = 0;
pub const AUC_AUDITING: ::kernel::sys::raw::c_uint = 1;
pub const AUC_NOAUDIT: ::kernel::sys::raw::c_uint = 2;
pub const AUC_DISABLED: ::kernel::sys::raw::c_int = -1;
pub const A_OLDGETPOLICY: ::kernel::sys::raw::c_uint = 2;
pub const A_OLDSETPOLICY: ::kernel::sys::raw::c_uint = 3;
pub const A_GETKMASK: ::kernel::sys::raw::c_uint = 4;
pub const A_SETKMASK: ::kernel::sys::raw::c_uint = 5;
pub const A_OLDGETQCTRL: ::kernel::sys::raw::c_uint = 6;
pub const A_OLDSETQCTRL: ::kernel::sys::raw::c_uint = 7;
pub const A_GETCWD: ::kernel::sys::raw::c_uint = 8;
pub const A_GETCAR: ::kernel::sys::raw::c_uint = 9;
pub const A_GETSTAT: ::kernel::sys::raw::c_uint = 12;
pub const A_SETSTAT: ::kernel::sys::raw::c_uint = 13;
pub const A_SETUMASK: ::kernel::sys::raw::c_uint = 14;
pub const A_SETSMASK: ::kernel::sys::raw::c_uint = 15;
pub const A_OLDGETCOND: ::kernel::sys::raw::c_uint = 20;
pub const A_OLDSETCOND: ::kernel::sys::raw::c_uint = 21;
pub const A_GETCLASS: ::kernel::sys::raw::c_uint = 22;
pub const A_SETCLASS: ::kernel::sys::raw::c_uint = 23;
pub const A_GETPINFO: ::kernel::sys::raw::c_uint = 24;
pub const A_SETPMASK: ::kernel::sys::raw::c_uint = 25;
pub const A_SETFSIZE: ::kernel::sys::raw::c_uint = 26;
pub const A_GETFSIZE: ::kernel::sys::raw::c_uint = 27;
pub const A_GETPINFO_ADDR: ::kernel::sys::raw::c_uint = 28;
pub const A_GETKAUDIT: ::kernel::sys::raw::c_uint = 29;
pub const A_SETKAUDIT: ::kernel::sys::raw::c_uint = 30;
pub const A_SENDTRIGGER: ::kernel::sys::raw::c_uint = 31;
pub const A_GETSINFO_ADDR: ::kernel::sys::raw::c_uint = 32;
pub const A_GETPOLICY: ::kernel::sys::raw::c_uint = 33;
pub const A_SETPOLICY: ::kernel::sys::raw::c_uint = 34;
pub const A_GETQCTRL: ::kernel::sys::raw::c_uint = 35;
pub const A_SETQCTRL: ::kernel::sys::raw::c_uint = 36;
pub const A_GETCOND: ::kernel::sys::raw::c_uint = 37;
pub const A_SETCOND: ::kernel::sys::raw::c_uint = 38;
pub const A_GETEVENT: ::kernel::sys::raw::c_uint = 39;
pub const A_SETEVENT: ::kernel::sys::raw::c_uint = 40;
pub const AUDIT_CNT: ::kernel::sys::raw::c_uint = 1;
pub const AUDIT_AHLT: ::kernel::sys::raw::c_uint = 2;
pub const AUDIT_ARGV: ::kernel::sys::raw::c_uint = 4;
pub const AUDIT_ARGE: ::kernel::sys::raw::c_uint = 8;
pub const AUDIT_SEQ: ::kernel::sys::raw::c_uint = 16;
pub const AUDIT_WINDATA: ::kernel::sys::raw::c_uint = 32;
pub const AUDIT_USER: ::kernel::sys::raw::c_uint = 64;
pub const AUDIT_GROUP: ::kernel::sys::raw::c_uint = 128;
pub const AUDIT_TRAIL: ::kernel::sys::raw::c_uint = 256;
pub const AUDIT_PATH: ::kernel::sys::raw::c_uint = 512;
pub const AUDIT_SCNT: ::kernel::sys::raw::c_uint = 1024;
pub const AUDIT_PUBLIC: ::kernel::sys::raw::c_uint = 2048;
pub const AUDIT_ZONENAME: ::kernel::sys::raw::c_uint = 4096;
pub const AUDIT_PERZONE: ::kernel::sys::raw::c_uint = 8192;
pub const AQ_HIWATER: ::kernel::sys::raw::c_uint = 100;
pub const AQ_MAXHIGH: ::kernel::sys::raw::c_uint = 10000;
pub const AQ_LOWATER: ::kernel::sys::raw::c_uint = 10;
pub const AQ_BUFSZ: ::kernel::sys::raw::c_uint = 32767;
pub const AQ_MAXBUFSZ: ::kernel::sys::raw::c_uint = 1048576;
pub const AU_FS_MINFREE: ::kernel::sys::raw::c_uint = 20;
pub const AU_IPv4: ::kernel::sys::raw::c_uint = 4;
pub const AU_IPv6: ::kernel::sys::raw::c_uint = 16;
pub const EVNAMEMAP_NAME_SIZE: ::kernel::sys::raw::c_uint = 64;
pub const XU_NGROUPS: ::kernel::sys::raw::c_uint = 16;
pub const CRED_FLAG_CAPMODE: ::kernel::sys::raw::c_uint = 1;
pub const XUCRED_VERSION: ::kernel::sys::raw::c_uint = 0;
pub const DOMAINSET_SETSIZE: ::kernel::sys::raw::c_uint = 8;
pub const DOMAINSET_MAXSIZE: ::kernel::sys::raw::c_uint = 256;
pub const KINFO_PROC_SIZE: ::kernel::sys::raw::c_uint = 1088;
pub const KINFO_PROC32_SIZE: ::kernel::sys::raw::c_uint = 768;
pub const TDF_BORROWING: ::kernel::sys::raw::c_uint = 1;
pub const TDF_INPANIC: ::kernel::sys::raw::c_uint = 2;
pub const TDF_INMEM: ::kernel::sys::raw::c_uint = 4;
pub const TDF_SINTR: ::kernel::sys::raw::c_uint = 8;
pub const TDF_TIMEOUT: ::kernel::sys::raw::c_uint = 16;
pub const TDF_IDLETD: ::kernel::sys::raw::c_uint = 32;
pub const TDF_CANSWAP: ::kernel::sys::raw::c_uint = 64;
pub const TDF_SLEEPABORT: ::kernel::sys::raw::c_uint = 128;
pub const TDF_KTH_SUSP: ::kernel::sys::raw::c_uint = 256;
pub const TDF_ALLPROCSUSP: ::kernel::sys::raw::c_uint = 512;
pub const TDF_BOUNDARY: ::kernel::sys::raw::c_uint = 1024;
pub const TDF_ASTPENDING: ::kernel::sys::raw::c_uint = 2048;
pub const TDF_UNUSED12: ::kernel::sys::raw::c_uint = 4096;
pub const TDF_SBDRY: ::kernel::sys::raw::c_uint = 8192;
pub const TDF_UPIBLOCKED: ::kernel::sys::raw::c_uint = 16384;
pub const TDF_NEEDSUSPCHK: ::kernel::sys::raw::c_uint = 32768;
pub const TDF_NEEDRESCHED: ::kernel::sys::raw::c_uint = 65536;
pub const TDF_NEEDSIGCHK: ::kernel::sys::raw::c_uint = 131072;
pub const TDF_NOLOAD: ::kernel::sys::raw::c_uint = 262144;
pub const TDF_SERESTART: ::kernel::sys::raw::c_uint = 524288;
pub const TDF_THRWAKEUP: ::kernel::sys::raw::c_uint = 1048576;
pub const TDF_SEINTR: ::kernel::sys::raw::c_uint = 2097152;
pub const TDF_SWAPINREQ: ::kernel::sys::raw::c_uint = 4194304;
pub const TDF_UNUSED23: ::kernel::sys::raw::c_uint = 8388608;
pub const TDF_SCHED0: ::kernel::sys::raw::c_uint = 16777216;
pub const TDF_SCHED1: ::kernel::sys::raw::c_uint = 33554432;
pub const TDF_SCHED2: ::kernel::sys::raw::c_uint = 67108864;
pub const TDF_SCHED3: ::kernel::sys::raw::c_uint = 134217728;
pub const TDF_ALRMPEND: ::kernel::sys::raw::c_uint = 268435456;
pub const TDF_PROFPEND: ::kernel::sys::raw::c_uint = 536870912;
pub const TDF_MACPEND: ::kernel::sys::raw::c_uint = 1073741824;
pub const TDB_SUSPEND: ::kernel::sys::raw::c_uint = 1;
pub const TDB_XSIG: ::kernel::sys::raw::c_uint = 2;
pub const TDB_USERWR: ::kernel::sys::raw::c_uint = 4;
pub const TDB_SCE: ::kernel::sys::raw::c_uint = 8;
pub const TDB_SCX: ::kernel::sys::raw::c_uint = 16;
pub const TDB_EXEC: ::kernel::sys::raw::c_uint = 32;
pub const TDB_FORK: ::kernel::sys::raw::c_uint = 64;
pub const TDB_STOPATFORK: ::kernel::sys::raw::c_uint = 128;
pub const TDB_CHILD: ::kernel::sys::raw::c_uint = 256;
pub const TDB_BORN: ::kernel::sys::raw::c_uint = 512;
pub const TDB_EXIT: ::kernel::sys::raw::c_uint = 1024;
pub const TDB_VFORK: ::kernel::sys::raw::c_uint = 2048;
pub const TDB_FSTP: ::kernel::sys::raw::c_uint = 4096;
pub const TDB_STEP: ::kernel::sys::raw::c_uint = 8192;
pub const TDP_OLDMASK: ::kernel::sys::raw::c_uint = 1;
pub const TDP_INKTR: ::kernel::sys::raw::c_uint = 2;
pub const TDP_INKTRACE: ::kernel::sys::raw::c_uint = 4;
pub const TDP_BUFNEED: ::kernel::sys::raw::c_uint = 8;
pub const TDP_COWINPROGRESS: ::kernel::sys::raw::c_uint = 16;
pub const TDP_ALTSTACK: ::kernel::sys::raw::c_uint = 32;
pub const TDP_DEADLKTREAT: ::kernel::sys::raw::c_uint = 64;
pub const TDP_NOFAULTING: ::kernel::sys::raw::c_uint = 128;
pub const TDP_UNUSED9: ::kernel::sys::raw::c_uint = 256;
pub const TDP_OWEUPC: ::kernel::sys::raw::c_uint = 512;
pub const TDP_ITHREAD: ::kernel::sys::raw::c_uint = 1024;
pub const TDP_SYNCIO: ::kernel::sys::raw::c_uint = 2048;
pub const TDP_SCHED1: ::kernel::sys::raw::c_uint = 4096;
pub const TDP_SCHED2: ::kernel::sys::raw::c_uint = 8192;
pub const TDP_SCHED3: ::kernel::sys::raw::c_uint = 16384;
pub const TDP_SCHED4: ::kernel::sys::raw::c_uint = 32768;
pub const TDP_GEOM: ::kernel::sys::raw::c_uint = 65536;
pub const TDP_SOFTDEP: ::kernel::sys::raw::c_uint = 131072;
pub const TDP_NORUNNINGBUF: ::kernel::sys::raw::c_uint = 262144;
pub const TDP_WAKEUP: ::kernel::sys::raw::c_uint = 524288;
pub const TDP_INBDFLUSH: ::kernel::sys::raw::c_uint = 1048576;
pub const TDP_KTHREAD: ::kernel::sys::raw::c_uint = 2097152;
pub const TDP_CALLCHAIN: ::kernel::sys::raw::c_uint = 4194304;
pub const TDP_IGNSUSP: ::kernel::sys::raw::c_uint = 8388608;
pub const TDP_AUDITREC: ::kernel::sys::raw::c_uint = 16777216;
pub const TDP_RFPPWAIT: ::kernel::sys::raw::c_uint = 33554432;
pub const TDP_RESETSPUR: ::kernel::sys::raw::c_uint = 67108864;
pub const TDP_NERRNO: ::kernel::sys::raw::c_uint = 134217728;
pub const TDP_UIOHELD: ::kernel::sys::raw::c_uint = 268435456;
pub const TDP_FORKING: ::kernel::sys::raw::c_uint = 536870912;
pub const TDP_EXECVMSPC: ::kernel::sys::raw::c_uint = 1073741824;
pub const TDI_SUSPENDED: ::kernel::sys::raw::c_uint = 1;
pub const TDI_SLEEPING: ::kernel::sys::raw::c_uint = 2;
pub const TDI_SWAPPED: ::kernel::sys::raw::c_uint = 4;
pub const TDI_LOCK: ::kernel::sys::raw::c_uint = 8;
pub const TDI_IWAIT: ::kernel::sys::raw::c_uint = 16;
pub const NOCPU: ::kernel::sys::raw::c_int = -1;
pub const NOCPU_OLD: ::kernel::sys::raw::c_uint = 255;
pub const MAXCPU_OLD: ::kernel::sys::raw::c_uint = 254;
pub const P_ADVLOCK: ::kernel::sys::raw::c_uint = 1;
pub const P_CONTROLT: ::kernel::sys::raw::c_uint = 2;
pub const P_KPROC: ::kernel::sys::raw::c_uint = 4;
pub const P_UNUSED3: ::kernel::sys::raw::c_uint = 8;
pub const P_PPWAIT: ::kernel::sys::raw::c_uint = 16;
pub const P_PROFIL: ::kernel::sys::raw::c_uint = 32;
pub const P_STOPPROF: ::kernel::sys::raw::c_uint = 64;
pub const P_HADTHREADS: ::kernel::sys::raw::c_uint = 128;
pub const P_SUGID: ::kernel::sys::raw::c_uint = 256;
pub const P_SYSTEM: ::kernel::sys::raw::c_uint = 512;
pub const P_SINGLE_EXIT: ::kernel::sys::raw::c_uint = 1024;
pub const P_TRACED: ::kernel::sys::raw::c_uint = 2048;
pub const P_WAITED: ::kernel::sys::raw::c_uint = 4096;
pub const P_WEXIT: ::kernel::sys::raw::c_uint = 8192;
pub const P_EXEC: ::kernel::sys::raw::c_uint = 16384;
pub const P_WKILLED: ::kernel::sys::raw::c_uint = 32768;
pub const P_CONTINUED: ::kernel::sys::raw::c_uint = 65536;
pub const P_STOPPED_SIG: ::kernel::sys::raw::c_uint = 131072;
pub const P_STOPPED_TRACE: ::kernel::sys::raw::c_uint = 262144;
pub const P_STOPPED_SINGLE: ::kernel::sys::raw::c_uint = 524288;
pub const P_PROTECTED: ::kernel::sys::raw::c_uint = 1048576;
pub const P_SIGEVENT: ::kernel::sys::raw::c_uint = 2097152;
pub const P_SINGLE_BOUNDARY: ::kernel::sys::raw::c_uint = 4194304;
pub const P_HWPMC: ::kernel::sys::raw::c_uint = 8388608;
pub const P_JAILED: ::kernel::sys::raw::c_uint = 16777216;
pub const P_TOTAL_STOP: ::kernel::sys::raw::c_uint = 33554432;
pub const P_INEXEC: ::kernel::sys::raw::c_uint = 67108864;
pub const P_STATCHILD: ::kernel::sys::raw::c_uint = 134217728;
pub const P_INMEM: ::kernel::sys::raw::c_uint = 268435456;
pub const P_SWAPPINGOUT: ::kernel::sys::raw::c_uint = 536870912;
pub const P_SWAPPINGIN: ::kernel::sys::raw::c_uint = 1073741824;
pub const P_PPTRACE: ::kernel::sys::raw::c_uint = 2147483648;
pub const P_STOPPED: ::kernel::sys::raw::c_uint = 917504;
pub const P2_INHERIT_PROTECTED: ::kernel::sys::raw::c_uint = 1;
pub const P2_NOTRACE: ::kernel::sys::raw::c_uint = 2;
pub const P2_NOTRACE_EXEC: ::kernel::sys::raw::c_uint = 4;
pub const P2_AST_SU: ::kernel::sys::raw::c_uint = 8;
pub const P2_PTRACE_FSTP: ::kernel::sys::raw::c_uint = 16;
pub const P2_TRAPCAP: ::kernel::sys::raw::c_uint = 32;
pub const P_TREE_ORPHANED: ::kernel::sys::raw::c_uint = 1;
pub const P_TREE_FIRST_ORPHAN: ::kernel::sys::raw::c_uint = 2;
pub const P_TREE_REAPER: ::kernel::sys::raw::c_uint = 4;
pub const SIDL: ::kernel::sys::raw::c_uint = 1;
pub const SRUN: ::kernel::sys::raw::c_uint = 2;
pub const SSLEEP: ::kernel::sys::raw::c_uint = 3;
pub const SSTOP: ::kernel::sys::raw::c_uint = 4;
pub const SZOMB: ::kernel::sys::raw::c_uint = 5;
pub const SWAIT: ::kernel::sys::raw::c_uint = 6;
pub const SLOCK: ::kernel::sys::raw::c_uint = 7;
pub const P_MAGIC: ::kernel::sys::raw::c_uint = 3203398350;
pub const SW_TYPE_MASK: ::kernel::sys::raw::c_uint = 255;
pub const SWT_NONE: ::kernel::sys::raw::c_uint = 0;
pub const SWT_PREEMPT: ::kernel::sys::raw::c_uint = 1;
pub const SWT_OWEPREEMPT: ::kernel::sys::raw::c_uint = 2;
pub const SWT_TURNSTILE: ::kernel::sys::raw::c_uint = 3;
pub const SWT_SLEEPQ: ::kernel::sys::raw::c_uint = 4;
pub const SWT_SLEEPQTIMO: ::kernel::sys::raw::c_uint = 5;
pub const SWT_RELINQUISH: ::kernel::sys::raw::c_uint = 6;
pub const SWT_NEEDRESCHED: ::kernel::sys::raw::c_uint = 7;
pub const SWT_IDLE: ::kernel::sys::raw::c_uint = 8;
pub const SWT_IWAIT: ::kernel::sys::raw::c_uint = 9;
pub const SWT_SUSPEND: ::kernel::sys::raw::c_uint = 10;
pub const SWT_REMOTEPREEMPT: ::kernel::sys::raw::c_uint = 11;
pub const SWT_REMOTEWAKEIDLE: ::kernel::sys::raw::c_uint = 12;
pub const SWT_COUNT: ::kernel::sys::raw::c_uint = 13;
pub const SW_VOL: ::kernel::sys::raw::c_uint = 256;
pub const SW_INVOL: ::kernel::sys::raw::c_uint = 512;
pub const SW_PREEMPT: ::kernel::sys::raw::c_uint = 1024;
pub const SINGLE_NO_EXIT: ::kernel::sys::raw::c_uint = 0;
pub const SINGLE_EXIT: ::kernel::sys::raw::c_uint = 1;
pub const SINGLE_BOUNDARY: ::kernel::sys::raw::c_uint = 2;
pub const SINGLE_ALLPROC: ::kernel::sys::raw::c_uint = 3;
pub const PID_MAX: ::kernel::sys::raw::c_uint = 99999;
pub const NO_PID: ::kernel::sys::raw::c_uint = 100000;
pub const PGET_HOLD: ::kernel::sys::raw::c_uint = 1;
pub const PGET_CANSEE: ::kernel::sys::raw::c_uint = 2;
pub const PGET_CANDEBUG: ::kernel::sys::raw::c_uint = 4;
pub const PGET_ISCURRENT: ::kernel::sys::raw::c_uint = 8;
pub const PGET_NOTWEXIT: ::kernel::sys::raw::c_uint = 16;
pub const PGET_NOTINEXEC: ::kernel::sys::raw::c_uint = 32;
pub const PGET_NOTID: ::kernel::sys::raw::c_uint = 64;
pub const PGET_WANTREAD: ::kernel::sys::raw::c_uint = 21;
pub const EPOCH_PREEMPT: ::kernel::sys::raw::c_uint = 1;
pub const LOCKSTAT_WRITER: ::kernel::sys::raw::c_uint = 0;
pub const LOCKSTAT_READER: ::kernel::sys::raw::c_uint = 1;
pub const MTX_DEF: ::kernel::sys::raw::c_uint = 0;
pub const MTX_SPIN: ::kernel::sys::raw::c_uint = 1;
pub const MTX_RECURSE: ::kernel::sys::raw::c_uint = 4;
pub const MTX_NOWITNESS: ::kernel::sys::raw::c_uint = 8;
pub const MTX_NOPROFILE: ::kernel::sys::raw::c_uint = 32;
pub const MTX_NEW: ::kernel::sys::raw::c_uint = 64;
pub const MTX_QUIET: ::kernel::sys::raw::c_uint = 2;
pub const MTX_DUPOK: ::kernel::sys::raw::c_uint = 16;
pub const MTX_UNOWNED: ::kernel::sys::raw::c_uint = 0;
pub const MTX_RECURSED: ::kernel::sys::raw::c_uint = 1;
pub const MTX_CONTESTED: ::kernel::sys::raw::c_uint = 2;
pub const MTX_DESTROYED: ::kernel::sys::raw::c_uint = 4;
pub const MTX_FLAGMASK: ::kernel::sys::raw::c_uint = 7;
pub const MTX_NETWORK_LOCK: &'static [u8; 15usize] = b"network driver\x00";
pub const RW_LOCK_READ: ::kernel::sys::raw::c_uint = 1;
pub const RW_LOCK_READ_WAITERS: ::kernel::sys::raw::c_uint = 2;
pub const RW_LOCK_WRITE_WAITERS: ::kernel::sys::raw::c_uint = 4;
pub const RW_LOCK_WRITE_SPINNER: ::kernel::sys::raw::c_uint = 8;
pub const RW_LOCK_WRITER_RECURSED: ::kernel::sys::raw::c_uint = 16;
pub const RW_LOCK_FLAGMASK: ::kernel::sys::raw::c_uint = 31;
pub const RW_LOCK_WAITERS: ::kernel::sys::raw::c_uint = 6;
pub const RW_READERS_SHIFT: ::kernel::sys::raw::c_uint = 5;
pub const RW_ONE_READER: ::kernel::sys::raw::c_uint = 32;
pub const RW_DESTROYED: ::kernel::sys::raw::c_uint = 6;
pub const RW_DUPOK: ::kernel::sys::raw::c_uint = 1;
pub const RW_NOPROFILE: ::kernel::sys::raw::c_uint = 2;
pub const RW_NOWITNESS: ::kernel::sys::raw::c_uint = 4;
pub const RW_QUIET: ::kernel::sys::raw::c_uint = 8;
pub const RW_RECURSE: ::kernel::sys::raw::c_uint = 16;
pub const RW_NEW: ::kernel::sys::raw::c_uint = 32;
pub const SX_LOCK_SHARED: ::kernel::sys::raw::c_uint = 1;
pub const SX_LOCK_SHARED_WAITERS: ::kernel::sys::raw::c_uint = 2;
pub const SX_LOCK_EXCLUSIVE_WAITERS: ::kernel::sys::raw::c_uint = 4;
pub const SX_LOCK_RECURSED: ::kernel::sys::raw::c_uint = 8;
pub const SX_LOCK_WRITE_SPINNER: ::kernel::sys::raw::c_uint = 16;
pub const SX_LOCK_FLAGMASK: ::kernel::sys::raw::c_uint = 31;
pub const SX_LOCK_WAITERS: ::kernel::sys::raw::c_uint = 6;
pub const SX_SHARERS_SHIFT: ::kernel::sys::raw::c_uint = 5;
pub const SX_ONE_SHARER: ::kernel::sys::raw::c_uint = 32;
pub const SX_LOCK_DESTROYED: ::kernel::sys::raw::c_uint = 6;
pub const SX_DUPOK: ::kernel::sys::raw::c_uint = 1;
pub const SX_NOPROFILE: ::kernel::sys::raw::c_uint = 2;
pub const SX_NOWITNESS: ::kernel::sys::raw::c_uint = 4;
pub const SX_QUIET: ::kernel::sys::raw::c_uint = 8;
pub const SX_NOADAPTIVE: ::kernel::sys::raw::c_uint = 16;
pub const SX_RECURSE: ::kernel::sys::raw::c_uint = 32;
pub const SX_NEW: ::kernel::sys::raw::c_uint = 64;
pub const SX_INTERRUPTIBLE: ::kernel::sys::raw::c_uint = 64;
pub const GROUPTASK_NAMELEN: ::kernel::sys::raw::c_uint = 32;
pub const IF_DUNIT_NONE: ::kernel::sys::raw::c_int = -1;
pub const ALTQF_READY: ::kernel::sys::raw::c_uint = 1;
pub const ALTQF_ENABLED: ::kernel::sys::raw::c_uint = 2;
pub const ALTQF_CLASSIFY: ::kernel::sys::raw::c_uint = 4;
pub const ALTQF_CNDTNING: ::kernel::sys::raw::c_uint = 8;
pub const ALTQF_DRIVER1: ::kernel::sys::raw::c_uint = 64;
pub const ALTQF_CANTCHANGE: ::kernel::sys::raw::c_uint = 1;
pub const ALTDQ_REMOVE: ::kernel::sys::raw::c_uint = 1;
pub const ALTDQ_POLL: ::kernel::sys::raw::c_uint = 2;
pub const ALTRQ_PURGE: ::kernel::sys::raw::c_uint = 1;
pub const HHOOK_IPSEC_INET: ::kernel::sys::raw::c_uint = 0;
pub const HHOOK_IPSEC_INET6: ::kernel::sys::raw::c_uint = 1;
pub const HHOOK_IPSEC_COUNT: ::kernel::sys::raw::c_uint = 2;
pub const IFENCAP_FLAG_BROADCAST: ::kernel::sys::raw::c_uint = 2;
pub const IF_SND_TAG_TYPE_RATE_LIMIT: ::kernel::sys::raw::c_uint = 0;
pub const IF_SND_TAG_TYPE_UNLIMITED: ::kernel::sys::raw::c_uint = 1;
pub const IF_SND_TAG_TYPE_MAX: ::kernel::sys::raw::c_uint = 2;
pub const IF_SND_QUEUE_LEVEL_MIN: ::kernel::sys::raw::c_uint = 0;
pub const IF_SND_QUEUE_LEVEL_MAX: ::kernel::sys::raw::c_uint = 65535;
pub const IF_MINMTU: ::kernel::sys::raw::c_uint = 72;
pub const IF_MAXMTU: ::kernel::sys::raw::c_uint = 65535;
pub const IFM_ETHER: ::kernel::sys::raw::c_uint = 32;
pub const IFM_10_T: ::kernel::sys::raw::c_uint = 3;
pub const IFM_10_2: ::kernel::sys::raw::c_uint = 4;
pub const IFM_10_5: ::kernel::sys::raw::c_uint = 5;
pub const IFM_100_TX: ::kernel::sys::raw::c_uint = 6;
pub const IFM_100_FX: ::kernel::sys::raw::c_uint = 7;
pub const IFM_100_T4: ::kernel::sys::raw::c_uint = 8;
pub const IFM_100_VG: ::kernel::sys::raw::c_uint = 9;
pub const IFM_100_T2: ::kernel::sys::raw::c_uint = 10;
pub const IFM_1000_SX: ::kernel::sys::raw::c_uint = 11;
pub const IFM_10_STP: ::kernel::sys::raw::c_uint = 12;
pub const IFM_10_FL: ::kernel::sys::raw::c_uint = 13;
pub const IFM_1000_LX: ::kernel::sys::raw::c_uint = 14;
pub const IFM_1000_CX: ::kernel::sys::raw::c_uint = 15;
pub const IFM_1000_T: ::kernel::sys::raw::c_uint = 16;
pub const IFM_HPNA_1: ::kernel::sys::raw::c_uint = 17;
pub const IFM_10G_LR: ::kernel::sys::raw::c_uint = 18;
pub const IFM_10G_SR: ::kernel::sys::raw::c_uint = 19;
pub const IFM_10G_CX4: ::kernel::sys::raw::c_uint = 20;
pub const IFM_2500_SX: ::kernel::sys::raw::c_uint = 21;
pub const IFM_10G_TWINAX: ::kernel::sys::raw::c_uint = 22;
pub const IFM_10G_TWINAX_LONG: ::kernel::sys::raw::c_uint = 23;
pub const IFM_10G_LRM: ::kernel::sys::raw::c_uint = 24;
pub const IFM_UNKNOWN: ::kernel::sys::raw::c_uint = 25;
pub const IFM_10G_T: ::kernel::sys::raw::c_uint = 26;
pub const IFM_40G_CR4: ::kernel::sys::raw::c_uint = 27;
pub const IFM_40G_SR4: ::kernel::sys::raw::c_uint = 28;
pub const IFM_40G_LR4: ::kernel::sys::raw::c_uint = 29;
pub const IFM_1000_KX: ::kernel::sys::raw::c_uint = 30;
pub const IFM_OTHER: ::kernel::sys::raw::c_uint = 31;
pub const IFM_ETH_MASTER: ::kernel::sys::raw::c_uint = 256;
pub const IFM_ETH_RXPAUSE: ::kernel::sys::raw::c_uint = 512;
pub const IFM_ETH_TXPAUSE: ::kernel::sys::raw::c_uint = 1024;
pub const IFM_ETH_XTYPE: ::kernel::sys::raw::c_uint = 30720;
pub const IFM_ETH_XSHIFT: ::kernel::sys::raw::c_uint = 6;
pub const IFM_IEEE80211: ::kernel::sys::raw::c_uint = 128;
pub const IFM_IEEE80211_FH1: ::kernel::sys::raw::c_uint = 3;
pub const IFM_IEEE80211_FH2: ::kernel::sys::raw::c_uint = 4;
pub const IFM_IEEE80211_DS1: ::kernel::sys::raw::c_uint = 5;
pub const IFM_IEEE80211_DS2: ::kernel::sys::raw::c_uint = 6;
pub const IFM_IEEE80211_DS5: ::kernel::sys::raw::c_uint = 7;
pub const IFM_IEEE80211_DS11: ::kernel::sys::raw::c_uint = 8;
pub const IFM_IEEE80211_DS22: ::kernel::sys::raw::c_uint = 9;
pub const IFM_IEEE80211_OFDM6: ::kernel::sys::raw::c_uint = 10;
pub const IFM_IEEE80211_OFDM9: ::kernel::sys::raw::c_uint = 11;
pub const IFM_IEEE80211_OFDM12: ::kernel::sys::raw::c_uint = 12;
pub const IFM_IEEE80211_OFDM18: ::kernel::sys::raw::c_uint = 13;
pub const IFM_IEEE80211_OFDM24: ::kernel::sys::raw::c_uint = 14;
pub const IFM_IEEE80211_OFDM36: ::kernel::sys::raw::c_uint = 15;
pub const IFM_IEEE80211_OFDM48: ::kernel::sys::raw::c_uint = 16;
pub const IFM_IEEE80211_OFDM54: ::kernel::sys::raw::c_uint = 17;
pub const IFM_IEEE80211_OFDM72: ::kernel::sys::raw::c_uint = 18;
pub const IFM_IEEE80211_DS354k: ::kernel::sys::raw::c_uint = 19;
pub const IFM_IEEE80211_DS512k: ::kernel::sys::raw::c_uint = 20;
pub const IFM_IEEE80211_OFDM3: ::kernel::sys::raw::c_uint = 21;
pub const IFM_IEEE80211_OFDM4: ::kernel::sys::raw::c_uint = 22;
pub const IFM_IEEE80211_OFDM27: ::kernel::sys::raw::c_uint = 23;
pub const IFM_IEEE80211_MCS: ::kernel::sys::raw::c_uint = 24;
pub const IFM_IEEE80211_VHT: ::kernel::sys::raw::c_uint = 25;
pub const IFM_IEEE80211_ADHOC: ::kernel::sys::raw::c_uint = 256;
pub const IFM_IEEE80211_HOSTAP: ::kernel::sys::raw::c_uint = 512;
pub const IFM_IEEE80211_IBSS: ::kernel::sys::raw::c_uint = 1024;
pub const IFM_IEEE80211_WDS: ::kernel::sys::raw::c_uint = 2048;
pub const IFM_IEEE80211_TURBO: ::kernel::sys::raw::c_uint = 4096;
pub const IFM_IEEE80211_MONITOR: ::kernel::sys::raw::c_uint = 8192;
pub const IFM_IEEE80211_MBSS: ::kernel::sys::raw::c_uint = 16384;
pub const IFM_IEEE80211_11A: ::kernel::sys::raw::c_uint = 65536;
pub const IFM_IEEE80211_11B: ::kernel::sys::raw::c_uint = 131072;
pub const IFM_IEEE80211_11G: ::kernel::sys::raw::c_uint = 196608;
pub const IFM_IEEE80211_FH: ::kernel::sys::raw::c_uint = 262144;
pub const IFM_IEEE80211_11NA: ::kernel::sys::raw::c_uint = 327680;
pub const IFM_IEEE80211_11NG: ::kernel::sys::raw::c_uint = 393216;
pub const IFM_IEEE80211_VHT5G: ::kernel::sys::raw::c_uint = 458752;
pub const IFM_IEEE80211_VHT2G: ::kernel::sys::raw::c_uint = 524288;
pub const IFM_ATM: ::kernel::sys::raw::c_uint = 160;
pub const IFM_ATM_UNKNOWN: ::kernel::sys::raw::c_uint = 3;
pub const IFM_ATM_UTP_25: ::kernel::sys::raw::c_uint = 4;
pub const IFM_ATM_TAXI_100: ::kernel::sys::raw::c_uint = 5;
pub const IFM_ATM_TAXI_140: ::kernel::sys::raw::c_uint = 6;
pub const IFM_ATM_MM_155: ::kernel::sys::raw::c_uint = 7;
pub const IFM_ATM_SM_155: ::kernel::sys::raw::c_uint = 8;
pub const IFM_ATM_UTP_155: ::kernel::sys::raw::c_uint = 9;
pub const IFM_ATM_MM_622: ::kernel::sys::raw::c_uint = 10;
pub const IFM_ATM_SM_622: ::kernel::sys::raw::c_uint = 11;
pub const IFM_ATM_VIRTUAL: ::kernel::sys::raw::c_uint = 12;
pub const IFM_ATM_SDH: ::kernel::sys::raw::c_uint = 256;
pub const IFM_ATM_NOSCRAMB: ::kernel::sys::raw::c_uint = 512;
pub const IFM_ATM_UNASSIGNED: ::kernel::sys::raw::c_uint = 1024;
pub const IFM_AUTO: ::kernel::sys::raw::c_uint = 0;
pub const IFM_MANUAL: ::kernel::sys::raw::c_uint = 1;
pub const IFM_NONE: ::kernel::sys::raw::c_uint = 2;
pub const IFM_FDX: ::kernel::sys::raw::c_uint = 1048576;
pub const IFM_HDX: ::kernel::sys::raw::c_uint = 2097152;
pub const IFM_FLOW: ::kernel::sys::raw::c_uint = 4194304;
pub const IFM_FLAG0: ::kernel::sys::raw::c_uint = 16777216;
pub const IFM_FLAG1: ::kernel::sys::raw::c_uint = 33554432;
pub const IFM_FLAG2: ::kernel::sys::raw::c_uint = 67108864;
pub const IFM_LOOP: ::kernel::sys::raw::c_uint = 134217728;
pub const IFM_NMASK: ::kernel::sys::raw::c_uint = 224;
pub const IFM_TMASK: ::kernel::sys::raw::c_uint = 31;
pub const IFM_IMASK: ::kernel::sys::raw::c_uint = 4026531840;
pub const IFM_ISHIFT: ::kernel::sys::raw::c_uint = 28;
pub const IFM_OMASK: ::kernel::sys::raw::c_uint = 65280;
pub const IFM_MMASK: ::kernel::sys::raw::c_uint = 458752;
pub const IFM_MSHIFT: ::kernel::sys::raw::c_uint = 16;
pub const IFM_GMASK: ::kernel::sys::raw::c_uint = 267386880;
pub const IFM_ETH_FMASK: ::kernel::sys::raw::c_uint = 4195840;
pub const IFM_AVALID: ::kernel::sys::raw::c_uint = 1;
pub const IFM_ACTIVE: ::kernel::sys::raw::c_uint = 2;
pub const IFM_STATUS_VALID: ::kernel::sys::raw::c_uint = 1;
pub const ETHER_ADDR_LEN: ::kernel::sys::raw::c_uint = 6;
pub const ETHER_TYPE_LEN: ::kernel::sys::raw::c_uint = 2;
pub const ETHER_CRC_LEN: ::kernel::sys::raw::c_uint = 4;
pub const ETHER_HDR_LEN: ::kernel::sys::raw::c_uint = 14;
pub const ETHER_MIN_LEN: ::kernel::sys::raw::c_uint = 64;
pub const ETHER_MAX_LEN: ::kernel::sys::raw::c_uint = 1518;
pub const ETHER_MAX_LEN_JUMBO: ::kernel::sys::raw::c_uint = 9018;
pub const ETHER_VLAN_ENCAP_LEN: ::kernel::sys::raw::c_uint = 4;
pub const ETHER_ALIGN: ::kernel::sys::raw::c_uint = 2;
pub const M_HASFCS: ::kernel::sys::raw::c_uint = 65536;
pub const ETHER_CRC_POLY_LE: ::kernel::sys::raw::c_uint = 3988292384;
pub const ETHER_CRC_POLY_BE: ::kernel::sys::raw::c_uint = 79764918;
pub const EVL_VLID_MASK: ::kernel::sys::raw::c_uint = 4095;
pub const EVL_PRI_MASK: ::kernel::sys::raw::c_uint = 57344;
pub const ETHERTYPE_8023: ::kernel::sys::raw::c_uint = 4;
pub const ETHERTYPE_PUP: ::kernel::sys::raw::c_uint = 512;
pub const ETHERTYPE_PUPAT: ::kernel::sys::raw::c_uint = 512;
pub const ETHERTYPE_SPRITE: ::kernel::sys::raw::c_uint = 1280;
pub const ETHERTYPE_NS: ::kernel::sys::raw::c_uint = 1536;
pub const ETHERTYPE_NSAT: ::kernel::sys::raw::c_uint = 1537;
pub const ETHERTYPE_DLOG1: ::kernel::sys::raw::c_uint = 1632;
pub const ETHERTYPE_DLOG2: ::kernel::sys::raw::c_uint = 1633;
pub const ETHERTYPE_IP: ::kernel::sys::raw::c_uint = 2048;
pub const ETHERTYPE_X75: ::kernel::sys::raw::c_uint = 2049;
pub const ETHERTYPE_NBS: ::kernel::sys::raw::c_uint = 2050;
pub const ETHERTYPE_ECMA: ::kernel::sys::raw::c_uint = 2051;
pub const ETHERTYPE_CHAOS: ::kernel::sys::raw::c_uint = 2052;
pub const ETHERTYPE_X25: ::kernel::sys::raw::c_uint = 2053;
pub const ETHERTYPE_ARP: ::kernel::sys::raw::c_uint = 2054;
pub const ETHERTYPE_NSCOMPAT: ::kernel::sys::raw::c_uint = 2055;
pub const ETHERTYPE_FRARP: ::kernel::sys::raw::c_uint = 2056;
pub const ETHERTYPE_UBDEBUG: ::kernel::sys::raw::c_uint = 2304;
pub const ETHERTYPE_IEEEPUP: ::kernel::sys::raw::c_uint = 2560;
pub const ETHERTYPE_IEEEPUPAT: ::kernel::sys::raw::c_uint = 2561;
pub const ETHERTYPE_VINES: ::kernel::sys::raw::c_uint = 2989;
pub const ETHERTYPE_VINESLOOP: ::kernel::sys::raw::c_uint = 2990;
pub const ETHERTYPE_VINESECHO: ::kernel::sys::raw::c_uint = 2991;
pub const ETHERTYPE_TRAIL: ::kernel::sys::raw::c_uint = 4096;
pub const ETHERTYPE_NTRAILER: ::kernel::sys::raw::c_uint = 16;
pub const ETHERTYPE_DCA: ::kernel::sys::raw::c_uint = 4660;
pub const ETHERTYPE_VALID: ::kernel::sys::raw::c_uint = 5632;
pub const ETHERTYPE_DOGFIGHT: ::kernel::sys::raw::c_uint = 6537;
pub const ETHERTYPE_RCL: ::kernel::sys::raw::c_uint = 6549;
pub const ETHERTYPE_NBPVCD: ::kernel::sys::raw::c_uint = 15360;
pub const ETHERTYPE_NBPSCD: ::kernel::sys::raw::c_uint = 15361;
pub const ETHERTYPE_NBPCREQ: ::kernel::sys::raw::c_uint = 15362;
pub const ETHERTYPE_NBPCRSP: ::kernel::sys::raw::c_uint = 15363;
pub const ETHERTYPE_NBPCC: ::kernel::sys::raw::c_uint = 15364;
pub const ETHERTYPE_NBPCLREQ: ::kernel::sys::raw::c_uint = 15365;
pub const ETHERTYPE_NBPCLRSP: ::kernel::sys::raw::c_uint = 15366;
pub const ETHERTYPE_NBPDG: ::kernel::sys::raw::c_uint = 15367;
pub const ETHERTYPE_NBPDGB: ::kernel::sys::raw::c_uint = 15368;
pub const ETHERTYPE_NBPCLAIM: ::kernel::sys::raw::c_uint = 15369;
pub const ETHERTYPE_NBPDLTE: ::kernel::sys::raw::c_uint = 15370;
pub const ETHERTYPE_NBPRAS: ::kernel::sys::raw::c_uint = 15371;
pub const ETHERTYPE_NBPRAR: ::kernel::sys::raw::c_uint = 15372;
pub const ETHERTYPE_NBPRST: ::kernel::sys::raw::c_uint = 15373;
pub const ETHERTYPE_PCS: ::kernel::sys::raw::c_uint = 16962;
pub const ETHERTYPE_IMLBLDIAG: ::kernel::sys::raw::c_uint = 16972;
pub const ETHERTYPE_DIDDLE: ::kernel::sys::raw::c_uint = 17185;
pub const ETHERTYPE_IMLBL: ::kernel::sys::raw::c_uint = 19522;
pub const ETHERTYPE_SIMNET: ::kernel::sys::raw::c_uint = 21000;
pub const ETHERTYPE_DECEXPER: ::kernel::sys::raw::c_uint = 24576;
pub const ETHERTYPE_MOPDL: ::kernel::sys::raw::c_uint = 24577;
pub const ETHERTYPE_MOPRC: ::kernel::sys::raw::c_uint = 24578;
pub const ETHERTYPE_DECnet: ::kernel::sys::raw::c_uint = 24579;
pub const ETHERTYPE_DN: ::kernel::sys::raw::c_uint = 24579;
pub const ETHERTYPE_LAT: ::kernel::sys::raw::c_uint = 24580;
pub const ETHERTYPE_DECDIAG: ::kernel::sys::raw::c_uint = 24581;
pub const ETHERTYPE_DECCUST: ::kernel::sys::raw::c_uint = 24582;
pub const ETHERTYPE_SCA: ::kernel::sys::raw::c_uint = 24583;
pub const ETHERTYPE_AMBER: ::kernel::sys::raw::c_uint = 24584;
pub const ETHERTYPE_DECMUMPS: ::kernel::sys::raw::c_uint = 24585;
pub const ETHERTYPE_TRANSETHER: ::kernel::sys::raw::c_uint = 25944;
pub const ETHERTYPE_RAWFR: ::kernel::sys::raw::c_uint = 25945;
pub const ETHERTYPE_UBDL: ::kernel::sys::raw::c_uint = 28672;
pub const ETHERTYPE_UBNIU: ::kernel::sys::raw::c_uint = 28673;
pub const ETHERTYPE_UBDIAGLOOP: ::kernel::sys::raw::c_uint = 28674;
pub const ETHERTYPE_UBNMC: ::kernel::sys::raw::c_uint = 28675;
pub const ETHERTYPE_UBBST: ::kernel::sys::raw::c_uint = 28677;
pub const ETHERTYPE_OS9: ::kernel::sys::raw::c_uint = 28679;
pub const ETHERTYPE_OS9NET: ::kernel::sys::raw::c_uint = 28681;
pub const ETHERTYPE_RACAL: ::kernel::sys::raw::c_uint = 28720;
pub const ETHERTYPE_PRIMENTS: ::kernel::sys::raw::c_uint = 28721;
pub const ETHERTYPE_CABLETRON: ::kernel::sys::raw::c_uint = 28724;
pub const ETHERTYPE_CRONUSVLN: ::kernel::sys::raw::c_uint = 32771;
pub const ETHERTYPE_CRONUS: ::kernel::sys::raw::c_uint = 32772;
pub const ETHERTYPE_HP: ::kernel::sys::raw::c_uint = 32773;
pub const ETHERTYPE_NESTAR: ::kernel::sys::raw::c_uint = 32774;
pub const ETHERTYPE_ATTSTANFORD: ::kernel::sys::raw::c_uint = 32776;
pub const ETHERTYPE_EXCELAN: ::kernel::sys::raw::c_uint = 32784;
pub const ETHERTYPE_SG_DIAG: ::kernel::sys::raw::c_uint = 32787;
pub const ETHERTYPE_SG_NETGAMES: ::kernel::sys::raw::c_uint = 32788;
pub const ETHERTYPE_SG_RESV: ::kernel::sys::raw::c_uint = 32789;
pub const ETHERTYPE_SG_BOUNCE: ::kernel::sys::raw::c_uint = 32790;
pub const ETHERTYPE_APOLLODOMAIN: ::kernel::sys::raw::c_uint = 32793;
pub const ETHERTYPE_TYMSHARE: ::kernel::sys::raw::c_uint = 32814;
pub const ETHERTYPE_TIGAN: ::kernel::sys::raw::c_uint = 32815;
pub const ETHERTYPE_REVARP: ::kernel::sys::raw::c_uint = 32821;
pub const ETHERTYPE_AEONIC: ::kernel::sys::raw::c_uint = 32822;
pub const ETHERTYPE_IPXNEW: ::kernel::sys::raw::c_uint = 32823;
pub const ETHERTYPE_LANBRIDGE: ::kernel::sys::raw::c_uint = 32824;
pub const ETHERTYPE_DSMD: ::kernel::sys::raw::c_uint = 32825;
pub const ETHERTYPE_ARGONAUT: ::kernel::sys::raw::c_uint = 32826;
pub const ETHERTYPE_VAXELN: ::kernel::sys::raw::c_uint = 32827;
pub const ETHERTYPE_DECDNS: ::kernel::sys::raw::c_uint = 32828;
pub const ETHERTYPE_ENCRYPT: ::kernel::sys::raw::c_uint = 32829;
pub const ETHERTYPE_DECDTS: ::kernel::sys::raw::c_uint = 32830;
pub const ETHERTYPE_DECLTM: ::kernel::sys::raw::c_uint = 32831;
pub const ETHERTYPE_DECNETBIOS: ::kernel::sys::raw::c_uint = 32832;
pub const ETHERTYPE_DECLAST: ::kernel::sys::raw::c_uint = 32833;
pub const ETHERTYPE_PLANNING: ::kernel::sys::raw::c_uint = 32836;
pub const ETHERTYPE_DECAM: ::kernel::sys::raw::c_uint = 32840;
pub const ETHERTYPE_EXPERDATA: ::kernel::sys::raw::c_uint = 32841;
pub const ETHERTYPE_VEXP: ::kernel::sys::raw::c_uint = 32859;
pub const ETHERTYPE_VPROD: ::kernel::sys::raw::c_uint = 32860;
pub const ETHERTYPE_ES: ::kernel::sys::raw::c_uint = 32861;
pub const ETHERTYPE_LITTLE: ::kernel::sys::raw::c_uint = 32864;
pub const ETHERTYPE_COUNTERPOINT: ::kernel::sys::raw::c_uint = 32866;
pub const ETHERTYPE_VEECO: ::kernel::sys::raw::c_uint = 32871;
pub const ETHERTYPE_GENDYN: ::kernel::sys::raw::c_uint = 32872;
pub const ETHERTYPE_ATT: ::kernel::sys::raw::c_uint = 32873;
pub const ETHERTYPE_AUTOPHON: ::kernel::sys::raw::c_uint = 32874;
pub const ETHERTYPE_COMDESIGN: ::kernel::sys::raw::c_uint = 32876;
pub const ETHERTYPE_COMPUGRAPHIC: ::kernel::sys::raw::c_uint = 32877;
pub const ETHERTYPE_MATRA: ::kernel::sys::raw::c_uint = 32890;
pub const ETHERTYPE_DDE: ::kernel::sys::raw::c_uint = 32891;
pub const ETHERTYPE_MERIT: ::kernel::sys::raw::c_uint = 32892;
pub const ETHERTYPE_VLTLMAN: ::kernel::sys::raw::c_uint = 32896;
pub const ETHERTYPE_ATALK: ::kernel::sys::raw::c_uint = 32923;
pub const ETHERTYPE_AT: ::kernel::sys::raw::c_uint = 32923;
pub const ETHERTYPE_APPLETALK: ::kernel::sys::raw::c_uint = 32923;
pub const ETHERTYPE_SPIDER: ::kernel::sys::raw::c_uint = 32927;
pub const ETHERTYPE_PACER: ::kernel::sys::raw::c_uint = 32966;
pub const ETHERTYPE_APPLITEK: ::kernel::sys::raw::c_uint = 32967;
pub const ETHERTYPE_SNA: ::kernel::sys::raw::c_uint = 32981;
pub const ETHERTYPE_VARIAN: ::kernel::sys::raw::c_uint = 32989;
pub const ETHERTYPE_RETIX: ::kernel::sys::raw::c_uint = 33010;
pub const ETHERTYPE_AARP: ::kernel::sys::raw::c_uint = 33011;
pub const ETHERTYPE_APOLLO: ::kernel::sys::raw::c_uint = 33015;
pub const ETHERTYPE_VLAN: ::kernel::sys::raw::c_uint = 33024;
pub const ETHERTYPE_BOFL: ::kernel::sys::raw::c_uint = 33026;
pub const ETHERTYPE_WELLFLEET: ::kernel::sys::raw::c_uint = 33027;
pub const ETHERTYPE_TALARIS: ::kernel::sys::raw::c_uint = 33067;
pub const ETHERTYPE_WATERLOO: ::kernel::sys::raw::c_uint = 33072;
pub const ETHERTYPE_HAYES: ::kernel::sys::raw::c_uint = 33072;
pub const ETHERTYPE_VGLAB: ::kernel::sys::raw::c_uint = 33073;
pub const ETHERTYPE_IPX: ::kernel::sys::raw::c_uint = 33079;
pub const ETHERTYPE_NOVELL: ::kernel::sys::raw::c_uint = 33080;
pub const ETHERTYPE_MUMPS: ::kernel::sys::raw::c_uint = 33087;
pub const ETHERTYPE_AMOEBA: ::kernel::sys::raw::c_uint = 33093;
pub const ETHERTYPE_FLIP: ::kernel::sys::raw::c_uint = 33094;
pub const ETHERTYPE_VURESERVED: ::kernel::sys::raw::c_uint = 33095;
pub const ETHERTYPE_LOGICRAFT: ::kernel::sys::raw::c_uint = 33096;
pub const ETHERTYPE_NCD: ::kernel::sys::raw::c_uint = 33097;
pub const ETHERTYPE_ALPHA: ::kernel::sys::raw::c_uint = 33098;
pub const ETHERTYPE_SNMP: ::kernel::sys::raw::c_uint = 33100;
pub const ETHERTYPE_TEC: ::kernel::sys::raw::c_uint = 33103;
pub const ETHERTYPE_RATIONAL: ::kernel::sys::raw::c_uint = 33104;
pub const ETHERTYPE_XTP: ::kernel::sys::raw::c_uint = 33149;
pub const ETHERTYPE_SGITW: ::kernel::sys::raw::c_uint = 33150;
pub const ETHERTYPE_HIPPI_FP: ::kernel::sys::raw::c_uint = 33152;
pub const ETHERTYPE_STP: ::kernel::sys::raw::c_uint = 33153;
pub const ETHERTYPE_MOTOROLA: ::kernel::sys::raw::c_uint = 33165;
pub const ETHERTYPE_NETBEUI: ::kernel::sys::raw::c_uint = 33169;
pub const ETHERTYPE_ACCTON: ::kernel::sys::raw::c_uint = 33680;
pub const ETHERTYPE_TALARISMC: ::kernel::sys::raw::c_uint = 34091;
pub const ETHERTYPE_KALPANA: ::kernel::sys::raw::c_uint = 34178;
pub const ETHERTYPE_SECTRA: ::kernel::sys::raw::c_uint = 34523;
pub const ETHERTYPE_IPV6: ::kernel::sys::raw::c_uint = 34525;
pub const ETHERTYPE_DELTACON: ::kernel::sys::raw::c_uint = 34526;
pub const ETHERTYPE_ATOMIC: ::kernel::sys::raw::c_uint = 34527;
pub const ETHERTYPE_RDP: ::kernel::sys::raw::c_uint = 34617;
pub const ETHERTYPE_MICP: ::kernel::sys::raw::c_uint = 34618;
pub const ETHERTYPE_TCPCOMP: ::kernel::sys::raw::c_uint = 34667;
pub const ETHERTYPE_IPAS: ::kernel::sys::raw::c_uint = 34668;
pub const ETHERTYPE_SECUREDATA: ::kernel::sys::raw::c_uint = 34669;
pub const ETHERTYPE_FLOWCONTROL: ::kernel::sys::raw::c_uint = 34824;
pub const ETHERTYPE_SLOW: ::kernel::sys::raw::c_uint = 34825;
pub const ETHERTYPE_PPP: ::kernel::sys::raw::c_uint = 34827;
pub const ETHERTYPE_HITACHI: ::kernel::sys::raw::c_uint = 34848;
pub const ETHERTYPE_TEST: ::kernel::sys::raw::c_uint = 34850;
pub const ETHERTYPE_MPLS: ::kernel::sys::raw::c_uint = 34887;
pub const ETHERTYPE_MPLS_MCAST: ::kernel::sys::raw::c_uint = 34888;
pub const ETHERTYPE_AXIS: ::kernel::sys::raw::c_uint = 34902;
pub const ETHERTYPE_PPPOEDISC: ::kernel::sys::raw::c_uint = 34915;
pub const ETHERTYPE_PPPOE: ::kernel::sys::raw::c_uint = 34916;
pub const ETHERTYPE_LANPROBE: ::kernel::sys::raw::c_uint = 34952;
pub const ETHERTYPE_PAE: ::kernel::sys::raw::c_uint = 34958;
pub const ETHERTYPE_QINQ: ::kernel::sys::raw::c_uint = 34984;
pub const ETHERTYPE_LOOPBACK: ::kernel::sys::raw::c_uint = 36864;
pub const ETHERTYPE_LBACK: ::kernel::sys::raw::c_uint = 36864;
pub const ETHERTYPE_XNSSM: ::kernel::sys::raw::c_uint = 36865;
pub const ETHERTYPE_TCPSM: ::kernel::sys::raw::c_uint = 36866;
pub const ETHERTYPE_BCLOOP: ::kernel::sys::raw::c_uint = 36867;
pub const ETHERTYPE_DEBNI: ::kernel::sys::raw::c_uint = 43690;
pub const ETHERTYPE_SONIX: ::kernel::sys::raw::c_uint = 64245;
pub const ETHERTYPE_VITAL: ::kernel::sys::raw::c_uint = 65280;
pub const ETHERTYPE_MAX: ::kernel::sys::raw::c_uint = 65535;
pub const ETHERMTU: ::kernel::sys::raw::c_uint = 1500;
pub const ETHERMIN: ::kernel::sys::raw::c_uint = 46;
pub const ETHERMTU_JUMBO: ::kernel::sys::raw::c_uint = 9000;
pub const IEEE8021Q_PCP_BK: ::kernel::sys::raw::c_uint = 1;
pub const IEEE8021Q_PCP_BE: ::kernel::sys::raw::c_uint = 0;
pub const IEEE8021Q_PCP_EE: ::kernel::sys::raw::c_uint = 2;
pub const IEEE8021Q_PCP_CA: ::kernel::sys::raw::c_uint = 3;
pub const IEEE8021Q_PCP_VI: ::kernel::sys::raw::c_uint = 4;
pub const IEEE8021Q_PCP_VO: ::kernel::sys::raw::c_uint = 5;
pub const IEEE8021Q_PCP_IC: ::kernel::sys::raw::c_uint = 6;
pub const IEEE8021Q_PCP_NC: ::kernel::sys::raw::c_uint = 7;
pub const KOBJ_CACHE_SIZE: ::kernel::sys::raw::c_uint = 256;
pub const IOCPARM_SHIFT: ::kernel::sys::raw::c_uint = 13;
pub const IOCPARM_MASK: ::kernel::sys::raw::c_uint = 8191;
pub const IOCPARM_MAX: ::kernel::sys::raw::c_uint = 8192;
pub const IOC_VOID: ::kernel::sys::raw::c_uint = 536870912;
pub const IOC_OUT: ::kernel::sys::raw::c_uint = 1073741824;
pub const IOC_IN: ::kernel::sys::raw::c_uint = 2147483648;
pub const IOC_INOUT: ::kernel::sys::raw::c_uint = 3221225472;
pub const IOC_DIRMASK: ::kernel::sys::raw::c_uint = 3758096384;
pub const BUS_USER_VERSION: ::kernel::sys::raw::c_uint = 1;
pub const DF_ENABLED: ::kernel::sys::raw::c_uint = 1;
pub const DF_FIXEDCLASS: ::kernel::sys::raw::c_uint = 2;
pub const DF_WILDCARD: ::kernel::sys::raw::c_uint = 4;
pub const DF_DESCMALLOCED: ::kernel::sys::raw::c_uint = 8;
pub const DF_QUIET: ::kernel::sys::raw::c_uint = 16;
pub const DF_DONENOMATCH: ::kernel::sys::raw::c_uint = 32;
pub const DF_EXTERNALSOFTC: ::kernel::sys::raw::c_uint = 64;
pub const DF_REBID: ::kernel::sys::raw::c_uint = 128;
pub const DF_SUSPENDED: ::kernel::sys::raw::c_uint = 256;
pub const DF_QUIET_CHILDREN: ::kernel::sys::raw::c_uint = 512;
pub const DEVF_FORCE_DETACH: ::kernel::sys::raw::c_uint = 1;
pub const DEVF_SET_DRIVER_DETACH: ::kernel::sys::raw::c_uint = 1;
pub const DEVF_CLEAR_DRIVER_DETACH: ::kernel::sys::raw::c_uint = 1;
pub const DEVF_FORCE_DELETE: ::kernel::sys::raw::c_uint = 1;
pub const KTR_VERSION: ::kernel::sys::raw::c_uint = 2;
pub const KTR_PARMS: ::kernel::sys::raw::c_uint = 6;
pub const EHE_DEAD_PRIORITY: ::kernel::sys::raw::c_int = -1;
pub const EVENTHANDLER_PRI_FIRST: ::kernel::sys::raw::c_uint = 0;
pub const EVENTHANDLER_PRI_ANY: ::kernel::sys::raw::c_uint = 10000;
pub const EVENTHANDLER_PRI_LAST: ::kernel::sys::raw::c_uint = 20000;
pub const SHUTDOWN_PRI_FIRST: ::kernel::sys::raw::c_uint = 0;
pub const SHUTDOWN_PRI_DEFAULT: ::kernel::sys::raw::c_uint = 10000;
pub const SHUTDOWN_PRI_LAST: ::kernel::sys::raw::c_uint = 20000;
pub const LOWMEM_PRI_DEFAULT: ::kernel::sys::raw::c_uint = 0;
pub const FILTER_STRAY: ::kernel::sys::raw::c_uint = 1;
pub const FILTER_HANDLED: ::kernel::sys::raw::c_uint = 2;
pub const FILTER_SCHEDULE_THREAD: ::kernel::sys::raw::c_uint = 4;
pub const RLE_RESERVED: ::kernel::sys::raw::c_uint = 1;
pub const RLE_ALLOCATED: ::kernel::sys::raw::c_uint = 2;
pub const RLE_PREFETCH: ::kernel::sys::raw::c_uint = 4;
pub const BUS_PROBE_SPECIFIC: ::kernel::sys::raw::c_uint = 0;
pub const BUS_PROBE_VENDOR: ::kernel::sys::raw::c_int = -10;
pub const BUS_PROBE_DEFAULT: ::kernel::sys::raw::c_int = -20;
pub const BUS_PROBE_LOW_PRIORITY: ::kernel::sys::raw::c_int = -40;
pub const BUS_PROBE_GENERIC: ::kernel::sys::raw::c_int = -100;
pub const BUS_PROBE_HOOVER: ::kernel::sys::raw::c_int = -1000000;
pub const BUS_PROBE_NOWILDCARD: ::kernel::sys::raw::c_int = -2000000000;
pub const BUS_PASS_ROOT: ::kernel::sys::raw::c_uint = 0;
pub const BUS_PASS_BUS: ::kernel::sys::raw::c_uint = 10;
pub const BUS_PASS_CPU: ::kernel::sys::raw::c_uint = 20;
pub const BUS_PASS_RESOURCE: ::kernel::sys::raw::c_uint = 30;
pub const BUS_PASS_INTERRUPT: ::kernel::sys::raw::c_uint = 40;
pub const BUS_PASS_TIMER: ::kernel::sys::raw::c_uint = 50;
pub const BUS_PASS_SCHEDULER: ::kernel::sys::raw::c_uint = 60;
pub const BUS_PASS_SUPPORTDEV: ::kernel::sys::raw::c_uint = 100000;
pub const BUS_PASS_DEFAULT: ::kernel::sys::raw::c_uint = 2147483647;
pub const BUS_PASS_ORDER_FIRST: ::kernel::sys::raw::c_uint = 0;
pub const BUS_PASS_ORDER_EARLY: ::kernel::sys::raw::c_uint = 2;
pub const BUS_PASS_ORDER_MIDDLE: ::kernel::sys::raw::c_uint = 5;
pub const BUS_PASS_ORDER_LATE: ::kernel::sys::raw::c_uint = 7;
pub const BUS_PASS_ORDER_LAST: ::kernel::sys::raw::c_uint = 9;
pub const TS_ENTER: ::kernel::sys::raw::c_uint = 0;
pub const TS_EXIT: ::kernel::sys::raw::c_uint = 1;
pub const TS_THREAD: ::kernel::sys::raw::c_uint = 2;
pub const TS_EVENT: ::kernel::sys::raw::c_uint = 3;
pub const CPU_LEVEL_ROOT: ::kernel::sys::raw::c_uint = 1;
pub const CPU_LEVEL_CPUSET: ::kernel::sys::raw::c_uint = 2;
pub const CPU_LEVEL_WHICH: ::kernel::sys::raw::c_uint = 3;
pub const CPU_WHICH_TID: ::kernel::sys::raw::c_uint = 1;
pub const CPU_WHICH_PID: ::kernel::sys::raw::c_uint = 2;
pub const CPU_WHICH_CPUSET: ::kernel::sys::raw::c_uint = 3;
pub const CPU_WHICH_IRQ: ::kernel::sys::raw::c_uint = 4;
pub const CPU_WHICH_JAIL: ::kernel::sys::raw::c_uint = 5;
pub const CPU_WHICH_DOMAIN: ::kernel::sys::raw::c_uint = 6;
pub const CPU_WHICH_INTRHANDLER: ::kernel::sys::raw::c_uint = 7;
pub const CPU_WHICH_ITHREAD: ::kernel::sys::raw::c_uint = 8;
pub const CPUSET_INVALID: ::kernel::sys::raw::c_int = -1;
pub const CPUSET_DEFAULT: ::kernel::sys::raw::c_uint = 0;
pub const CPU_SET_ROOT: ::kernel::sys::raw::c_uint = 1;
pub const CPU_SET_RDONLY: ::kernel::sys::raw::c_uint = 2;
pub const X86_BUS_SPACE_IO: ::kernel::sys::raw::c_uint = 0;
pub const X86_BUS_SPACE_MEM: ::kernel::sys::raw::c_uint = 1;
pub const BUS_SPACE_MAXSIZE_24BIT: ::kernel::sys::raw::c_uint = 16777215;
pub const BUS_SPACE_MAXSIZE_32BIT: ::kernel::sys::raw::c_uint = 4294967295;
pub const BUS_SPACE_MAXSIZE: ::kernel::sys::raw::c_uint = 4294967295;
pub const BUS_SPACE_MAXADDR_24BIT: ::kernel::sys::raw::c_uint = 16777215;
pub const BUS_SPACE_MAXADDR_32BIT: ::kernel::sys::raw::c_uint = 4294967295;
pub const BUS_SPACE_MAXADDR_48BIT: ::kernel::sys::raw::c_ulonglong =
    281474976710655;
pub const BUS_SPACE_MAXADDR: ::kernel::sys::raw::c_int = -1;
pub const BUS_SPACE_INVALID_DATA: ::kernel::sys::raw::c_int = -1;
pub const BUS_SPACE_UNRESTRICTED: ::kernel::sys::raw::c_int = -1;
pub const BUS_SPACE_BARRIER_READ: ::kernel::sys::raw::c_uint = 1;
pub const BUS_SPACE_BARRIER_WRITE: ::kernel::sys::raw::c_uint = 2;
pub const BUS_DMA_WAITOK: ::kernel::sys::raw::c_uint = 0;
pub const BUS_DMA_NOWAIT: ::kernel::sys::raw::c_uint = 1;
pub const BUS_DMA_ALLOCNOW: ::kernel::sys::raw::c_uint = 2;
pub const BUS_DMA_COHERENT: ::kernel::sys::raw::c_uint = 4;
pub const BUS_DMA_ZERO: ::kernel::sys::raw::c_uint = 8;
pub const BUS_DMA_BUS1: ::kernel::sys::raw::c_uint = 16;
pub const BUS_DMA_BUS2: ::kernel::sys::raw::c_uint = 32;
pub const BUS_DMA_BUS3: ::kernel::sys::raw::c_uint = 64;
pub const BUS_DMA_BUS4: ::kernel::sys::raw::c_uint = 128;
pub const BUS_DMA_NOWRITE: ::kernel::sys::raw::c_uint = 256;
pub const BUS_DMA_NOCACHE: ::kernel::sys::raw::c_uint = 512;
pub const BUS_DMA_KEEP_PG_OFFSET: ::kernel::sys::raw::c_uint = 1024;
pub const BUS_DMA_LOAD_MBUF: ::kernel::sys::raw::c_uint = 2048;
pub const BUS_DMASYNC_PREREAD: ::kernel::sys::raw::c_uint = 1;
pub const BUS_DMASYNC_POSTREAD: ::kernel::sys::raw::c_uint = 2;
pub const BUS_DMASYNC_PREWRITE: ::kernel::sys::raw::c_uint = 4;
pub const BUS_DMASYNC_POSTWRITE: ::kernel::sys::raw::c_uint = 8;
pub const NV_NAME_MAX: ::kernel::sys::raw::c_uint = 2048;
pub const NV_TYPE_NONE: ::kernel::sys::raw::c_uint = 0;
pub const NV_TYPE_NULL: ::kernel::sys::raw::c_uint = 1;
pub const NV_TYPE_BOOL: ::kernel::sys::raw::c_uint = 2;
pub const NV_TYPE_NUMBER: ::kernel::sys::raw::c_uint = 3;
pub const NV_TYPE_STRING: ::kernel::sys::raw::c_uint = 4;
pub const NV_TYPE_NVLIST: ::kernel::sys::raw::c_uint = 5;
pub const NV_TYPE_DESCRIPTOR: ::kernel::sys::raw::c_uint = 6;
pub const NV_TYPE_BINARY: ::kernel::sys::raw::c_uint = 7;
pub const NV_TYPE_BOOL_ARRAY: ::kernel::sys::raw::c_uint = 8;
pub const NV_TYPE_NUMBER_ARRAY: ::kernel::sys::raw::c_uint = 9;
pub const NV_TYPE_STRING_ARRAY: ::kernel::sys::raw::c_uint = 10;
pub const NV_TYPE_NVLIST_ARRAY: ::kernel::sys::raw::c_uint = 11;
pub const NV_TYPE_DESCRIPTOR_ARRAY: ::kernel::sys::raw::c_uint = 12;
pub const NV_FLAG_IGNORE_CASE: ::kernel::sys::raw::c_uint = 1;
pub const NV_FLAG_NO_UNIQUE: ::kernel::sys::raw::c_uint = 2;
pub const TASKQUEUE_NAMELEN: ::kernel::sys::raw::c_uint = 32;
pub const TASK_ENQUEUED: ::kernel::sys::raw::c_uint = 1;
pub const TASK_SKIP_WAKEUP: ::kernel::sys::raw::c_uint = 2;
pub const QIDX_INVALID: ::kernel::sys::raw::c_uint = 65535;
pub const FREEBSD_TSO_SIZE_MAX: ::kernel::sys::raw::c_uint = 65518;
pub const IPI_TX_INTR: ::kernel::sys::raw::c_uint = 1;
pub const IPI_TX_IPV4: ::kernel::sys::raw::c_uint = 2;
pub const IPI_TX_IPV6: ::kernel::sys::raw::c_uint = 4;
pub const IFLIB_PNP_DESCR: &'static [u8; 77usize] =
    b"U32:vendor;U32:device;U32:subvendor;U32:subdevice;U32:revision;U32:class;D:#\x00";
pub const IFLIB_MAGIC: ::kernel::sys::raw::c_uint = 3405705229;
pub const ETH_ADDR_LEN: ::kernel::sys::raw::c_uint = 6;
pub const IFLIB_HAS_RXCQ: ::kernel::sys::raw::c_uint = 1;
pub const IFLIB_SKIP_MSIX: ::kernel::sys::raw::c_uint = 2;
pub const IFLIB_IS_VF: ::kernel::sys::raw::c_uint = 4;
pub const IFLIB_HAS_TXCQ: ::kernel::sys::raw::c_uint = 8;
pub const IFLIB_NEED_SCRATCH: ::kernel::sys::raw::c_uint = 16;
pub const IFLIB_TSO_INIT_IP: ::kernel::sys::raw::c_uint = 32;
pub const IFLIB_DO_RX_FIXUP: ::kernel::sys::raw::c_uint = 64;
pub const IFLIB_NEED_ZERO_CSUM: ::kernel::sys::raw::c_uint = 128;
pub const IFLIB_NEED_ETHER_PAD: ::kernel::sys::raw::c_uint = 256;
pub const IFLIB_TXD_ENCAP_PIO: ::kernel::sys::raw::c_uint = 512;
pub const IFLIB_RX_COMPLETION: ::kernel::sys::raw::c_uint = 1024;
pub const IFLIB_SKIP_CLREFILL: ::kernel::sys::raw::c_uint = 2048;
pub const IFLIB_NO_HANG_RESET: ::kernel::sys::raw::c_uint = 4096;
pub const IFLIB_PSEUDO: ::kernel::sys::raw::c_uint = 8192;
pub const IFLIB_VIRTUAL: ::kernel::sys::raw::c_uint = 16384;
pub const IFLIB_GEN_MAC: ::kernel::sys::raw::c_uint = 32768;
pub const IFLIB_ADMIN_ALWAYS_RUN: ::kernel::sys::raw::c_uint = 65536;
pub type __int8_t = ::kernel::sys::raw::c_schar;
pub type __uint8_t = ::kernel::sys::raw::c_uchar;
pub type __int16_t = ::kernel::sys::raw::c_short;
pub type __uint16_t = ::kernel::sys::raw::c_ushort;
pub type __int32_t = ::kernel::sys::raw::c_int;
pub type __uint32_t = ::kernel::sys::raw::c_uint;
pub type __int64_t = ::kernel::sys::raw::c_long;
pub type __uint64_t = ::kernel::sys::raw::c_ulong;
pub type __clock_t = __int32_t;
pub type __critical_t = __int64_t;
pub type __double_t = f64;
pub type __float_t = f32;
pub type __intfptr_t = __int64_t;
pub type __intptr_t = __int64_t;
pub type __intmax_t = __int64_t;
pub type __int_fast8_t = __int32_t;
pub type __int_fast16_t = __int32_t;
pub type __int_fast32_t = __int32_t;
pub type __int_fast64_t = __int64_t;
pub type __int_least8_t = __int8_t;
pub type __int_least16_t = __int16_t;
pub type __int_least32_t = __int32_t;
pub type __int_least64_t = __int64_t;
pub type __ptrdiff_t = __int64_t;
pub type __register_t = __int64_t;
pub type __segsz_t = __int64_t;
pub type __size_t = __uint64_t;
pub type __ssize_t = __int64_t;
pub type __time_t = __int64_t;
pub type __uintfptr_t = __uint64_t;
pub type __uintptr_t = __uint64_t;
pub type __uintmax_t = __uint64_t;
pub type __uint_fast8_t = __uint32_t;
pub type __uint_fast16_t = __uint32_t;
pub type __uint_fast32_t = __uint32_t;
pub type __uint_fast64_t = __uint64_t;
pub type __uint_least8_t = __uint8_t;
pub type __uint_least16_t = __uint16_t;
pub type __uint_least32_t = __uint32_t;
pub type __uint_least64_t = __uint64_t;
pub type __u_register_t = __uint64_t;
pub type __vm_offset_t = __uint64_t;
pub type __vm_paddr_t = __uint64_t;
pub type __vm_size_t = __uint64_t;
pub type ___wchar_t = ::kernel::sys::raw::c_int;
pub type __blksize_t = __int32_t;
pub type __blkcnt_t = __int64_t;
pub type __clockid_t = __int32_t;
pub type __fflags_t = __uint32_t;
pub type __fsblkcnt_t = __uint64_t;
pub type __fsfilcnt_t = __uint64_t;
pub type __gid_t = __uint32_t;
pub type __id_t = __int64_t;
pub type __ino_t = __uint64_t;
pub type __key_t = ::kernel::sys::raw::c_long;
pub type __lwpid_t = __int32_t;
pub type __mode_t = __uint16_t;
pub type __accmode_t = ::kernel::sys::raw::c_int;
pub type __nl_item = ::kernel::sys::raw::c_int;
pub type __nlink_t = __uint64_t;
pub type __off_t = __int64_t;
pub type __off64_t = __int64_t;
pub type __pid_t = __int32_t;
pub type __rlim_t = __int64_t;
pub type __sa_family_t = __uint8_t;
pub type __socklen_t = __uint32_t;
pub type __suseconds_t = ::kernel::sys::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __timer {
    _unused: [u8; 0],
}
pub type __timer_t = *mut __timer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __mq {
    _unused: [u8; 0],
}
pub type __mqd_t = *mut __mq;
pub type __uid_t = __uint32_t;
pub type __useconds_t = ::kernel::sys::raw::c_uint;
pub type __cpuwhich_t = ::kernel::sys::raw::c_int;
pub type __cpulevel_t = ::kernel::sys::raw::c_int;
pub type __cpusetid_t = ::kernel::sys::raw::c_int;
pub type __ct_rune_t = ::kernel::sys::raw::c_int;
pub type __rune_t = __ct_rune_t;
pub type __wint_t = __ct_rune_t;
pub type __char16_t = __uint_least16_t;
pub type __char32_t = __uint_least32_t;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct __max_align_t {
    pub __max_align1: ::kernel::sys::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __max_align2: f64,
}
#[test]
fn bindgen_test_layout___max_align_t() {
    assert_eq!(::core::mem::size_of::<__max_align_t>() , 32usize , concat ! (
               "Size of: " , stringify ! ( __max_align_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __max_align_t ) ) . __max_align1 as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __max_align_t ) , "::"
                , stringify ! ( __max_align1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __max_align_t ) ) . __max_align2 as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __max_align_t ) , "::"
                , stringify ! ( __max_align2 ) ));
}
impl Clone for __max_align_t {
    fn clone(&self) -> Self { *self }
}
pub type __dev_t = __uint64_t;
pub type __fixpt_t = __uint32_t;
#[repr(C)]
#[derive(Copy)]
pub union __mbstate_t {
    pub __mbstate8: [::kernel::sys::raw::c_char; 128usize],
    pub _mbstateL: __int64_t,
    _bindgen_union_align: [u64; 16usize],
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(::core::mem::size_of::<__mbstate_t>() , 128usize , concat ! (
               "Size of: " , stringify ! ( __mbstate_t ) ));
    assert_eq! (::core::mem::align_of::<__mbstate_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __mbstate_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . __mbstate8 as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( __mbstate8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . _mbstateL as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( _mbstateL ) ));
}
impl Clone for __mbstate_t {
    fn clone(&self) -> Self { *self }
}
impl Default for __mbstate_t {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for __mbstate_t {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "__mbstate_t {{ union }}")
    }
}
pub type __rman_res_t = __uintmax_t;
pub type __va_list = __builtin_va_list;
pub type __gnuc_va_list = __va_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_cond {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_cond_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutex {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutex_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_once {
    pub state: ::kernel::sys::raw::c_int,
    pub mutex: pthread_mutex_t,
}
#[test]
fn bindgen_test_layout_pthread_once() {
    assert_eq!(::core::mem::size_of::<pthread_once>() , 16usize , concat ! (
               "Size of: " , stringify ! ( pthread_once ) ));
    assert_eq! (::core::mem::align_of::<pthread_once>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_once ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_once ) ) . state as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_once ) , "::" ,
                stringify ! ( state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_once ) ) . mutex as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_once ) , "::" ,
                stringify ! ( mutex ) ));
}
impl Clone for pthread_once {
    fn clone(&self) -> Self { *self }
}
impl Default for pthread_once {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_rwlock {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_rwlockattr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_barrier {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_barrier_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_spinlock {
    _unused: [u8; 0],
}
pub type pthread_t = *mut pthread;
pub type pthread_attr_t = *mut pthread_attr;
pub type pthread_mutex_t = *mut pthread_mutex;
pub type pthread_mutexattr_t = *mut pthread_mutex_attr;
pub type pthread_cond_t = *mut pthread_cond;
pub type pthread_condattr_t = *mut pthread_cond_attr;
pub type pthread_key_t = ::kernel::sys::raw::c_int;
pub type pthread_once_t = pthread_once;
pub type pthread_rwlock_t = *mut pthread_rwlock;
pub type pthread_rwlockattr_t = *mut pthread_rwlockattr;
pub type pthread_barrier_t = *mut pthread_barrier;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_barrierattr {
    _unused: [u8; 0],
}
pub type pthread_barrierattr_t = *mut pthread_barrierattr;
pub type pthread_spinlock_t = *mut pthread_spinlock;
pub type pthread_addr_t = *mut ::kernel::sys::raw::c_void;
pub type pthread_startroutine_t =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void)
                               -> *mut ::kernel::sys::raw::c_void>;
pub type u_char = ::kernel::sys::raw::c_uchar;
pub type u_short = ::kernel::sys::raw::c_ushort;
pub type u_int = ::kernel::sys::raw::c_uint;
pub type u_long = ::kernel::sys::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type u_quad_t = __uint64_t;
pub type quad_t = __int64_t;
pub type qaddr_t = *mut quad_t;
pub type caddr_t = *mut ::kernel::sys::raw::c_char;
pub type c_caddr_t = *const ::kernel::sys::raw::c_char;
pub type blksize_t = __blksize_t;
pub type cpuwhich_t = __cpuwhich_t;
pub type cpulevel_t = __cpulevel_t;
pub type cpusetid_t = __cpusetid_t;
pub type blkcnt_t = __blkcnt_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type critical_t = __critical_t;
pub type daddr_t = __int64_t;
pub type dev_t = __dev_t;
pub type fflags_t = __fflags_t;
pub type fixpt_t = __fixpt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type gid_t = __gid_t;
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type id_t = __id_t;
pub type ino_t = __ino_t;
pub type key_t = __key_t;
pub type lwpid_t = __lwpid_t;
pub type mode_t = __mode_t;
pub type accmode_t = __accmode_t;
pub type nlink_t = __nlink_t;
pub type off_t = __off_t;
pub type off64_t = __off64_t;
pub type pid_t = __pid_t;
pub type register_t = __register_t;
pub type rlim_t = __rlim_t;
pub type sbintime_t = __int64_t;
pub type segsz_t = __segsz_t;
pub type suseconds_t = __suseconds_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type mqd_t = __mqd_t;
pub type u_register_t = __u_register_t;
pub type uid_t = __uid_t;
pub type useconds_t = __useconds_t;
pub type cap_ioctl_t = ::kernel::sys::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cap_rights {
    _unused: [u8; 0],
}
pub type cap_rights_t = cap_rights;
pub type vm_offset_t = __vm_offset_t;
pub type vm_ooffset_t = __int64_t;
pub type vm_paddr_t = __vm_paddr_t;
pub type vm_pindex_t = __uint64_t;
pub type vm_size_t = __vm_size_t;
pub type rman_res_t = __rman_res_t;
pub type boolean_t = ::kernel::sys::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct device {
    _unused: [u8; 0],
}
pub type device_t = *mut device;
pub type intfptr_t = __intfptr_t;
pub type intrmask_t = __uint32_t;
pub type uintfptr_t = __uintfptr_t;
pub type uoff_t = __uint64_t;
pub type vm_memattr_t = ::kernel::sys::raw::c_char;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_page {
    _unused: [u8; 0],
}
pub type vm_page_t = *mut vm_page;
pub type bool_ = bool;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct __sigset {
    pub __bits: [__uint32_t; 4usize],
}
#[test]
fn bindgen_test_layout___sigset() {
    assert_eq!(::core::mem::size_of::<__sigset>() , 16usize , concat ! (
               "Size of: " , stringify ! ( __sigset ) ));
    assert_eq! (::core::mem::align_of::<__sigset>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( __sigset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sigset ) ) . __bits as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sigset ) , "::" ,
                stringify ! ( __bits ) ));
}
impl Clone for __sigset {
    fn clone(&self) -> Self { *self }
}
pub type __sigset_t = __sigset;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct timeval {
    pub tv_sec: time_t,
    pub tv_usec: suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(::core::mem::size_of::<timeval>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timeval ) ));
    assert_eq! (::core::mem::align_of::<timeval>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timeval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_usec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_usec ) ));
}
impl Clone for timeval {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: ::kernel::sys::raw::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(::core::mem::size_of::<timespec>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timespec ) ));
    assert_eq! (::core::mem::align_of::<timespec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timespec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_nsec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_nsec ) ));
}
impl Clone for timespec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(::core::mem::size_of::<itimerspec>() , 32usize , concat ! (
               "Size of: " , stringify ! ( itimerspec ) ));
    assert_eq! (::core::mem::align_of::<itimerspec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( itimerspec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerspec ) ) . it_interval as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerspec ) , "::" ,
                stringify ! ( it_interval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerspec ) ) . it_value as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerspec ) , "::" ,
                stringify ! ( it_value ) ));
}
impl Clone for itimerspec {
    fn clone(&self) -> Self { *self }
}
pub type __fd_mask = ::kernel::sys::raw::c_ulong;
pub type fd_mask = __fd_mask;
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(::core::mem::size_of::<fd_set>() , 128usize , concat ! (
               "Size of: " , stringify ! ( fd_set ) ));
    assert_eq! (::core::mem::align_of::<fd_set>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( fd_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fd_set ) ) . __fds_bits as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( fd_set ) , "::" ,
                stringify ! ( __fds_bits ) ));
}
impl Clone for fd_set {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct iovec {
    pub iov_base: *mut ::kernel::sys::raw::c_void,
    pub iov_len: usize,
}
#[test]
fn bindgen_test_layout_iovec() {
    assert_eq!(::core::mem::size_of::<iovec>() , 16usize , concat ! (
               "Size of: " , stringify ! ( iovec ) ));
    assert_eq! (::core::mem::align_of::<iovec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( iovec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const iovec ) ) . iov_base as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( iovec ) , "::" ,
                stringify ! ( iov_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const iovec ) ) . iov_len as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( iovec ) , "::" ,
                stringify ! ( iov_len ) ));
}
impl Clone for iovec {
    fn clone(&self) -> Self { *self }
}
impl Default for iovec {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type sa_family_t = __sa_family_t;
pub type socklen_t = __socklen_t;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct linger {
    pub l_onoff: ::kernel::sys::raw::c_int,
    pub l_linger: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_linger() {
    assert_eq!(::core::mem::size_of::<linger>() , 8usize , concat ! (
               "Size of: " , stringify ! ( linger ) ));
    assert_eq! (::core::mem::align_of::<linger>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( linger ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const linger ) ) . l_onoff as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( linger ) , "::" ,
                stringify ! ( l_onoff ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const linger ) ) . l_linger as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( linger ) , "::" ,
                stringify ! ( l_linger ) ));
}
impl Clone for linger {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct accept_filter_arg {
    pub af_name: [::kernel::sys::raw::c_char; 16usize],
    pub af_arg: [::kernel::sys::raw::c_char; 240usize],
}
#[test]
fn bindgen_test_layout_accept_filter_arg() {
    assert_eq!(::core::mem::size_of::<accept_filter_arg>() , 256usize , concat
               ! ( "Size of: " , stringify ! ( accept_filter_arg ) ));
    assert_eq! (::core::mem::align_of::<accept_filter_arg>() , 1usize , concat
                ! ( "Alignment of " , stringify ! ( accept_filter_arg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const accept_filter_arg ) ) . af_name as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( accept_filter_arg ) ,
                "::" , stringify ! ( af_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const accept_filter_arg ) ) . af_arg as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( accept_filter_arg ) ,
                "::" , stringify ! ( af_arg ) ));
}
impl Clone for accept_filter_arg {
    fn clone(&self) -> Self { *self }
}
impl Default for accept_filter_arg {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for accept_filter_arg {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "accept_filter_arg {{ af_name: {:?}, af_arg: [{}] }}" ,
               self . af_name , self . af_arg . iter (  ) . enumerate (  ) .
               map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ))
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct sockaddr {
    pub sa_len: ::kernel::sys::raw::c_uchar,
    pub sa_family: sa_family_t,
    pub sa_data: [::kernel::sys::raw::c_char; 14usize],
}
#[test]
fn bindgen_test_layout_sockaddr() {
    assert_eq!(::core::mem::size_of::<sockaddr>() , 16usize , concat ! (
               "Size of: " , stringify ! ( sockaddr ) ));
    assert_eq! (::core::mem::align_of::<sockaddr>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( sockaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr ) ) . sa_len as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr ) , "::" ,
                stringify ! ( sa_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr ) ) . sa_family as * const _ as
                usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr ) , "::" ,
                stringify ! ( sa_family ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr ) ) . sa_data as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr ) , "::" ,
                stringify ! ( sa_data ) ));
}
impl Clone for sockaddr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct sockproto {
    pub sp_family: ::kernel::sys::raw::c_ushort,
    pub sp_protocol: ::kernel::sys::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_sockproto() {
    assert_eq!(::core::mem::size_of::<sockproto>() , 4usize , concat ! (
               "Size of: " , stringify ! ( sockproto ) ));
    assert_eq! (::core::mem::align_of::<sockproto>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( sockproto ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockproto ) ) . sp_family as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sockproto ) , "::" ,
                stringify ! ( sp_family ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockproto ) ) . sp_protocol as * const _
                as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( sockproto ) , "::" ,
                stringify ! ( sp_protocol ) ));
}
impl Clone for sockproto {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct sockaddr_storage {
    pub ss_len: ::kernel::sys::raw::c_uchar,
    pub ss_family: sa_family_t,
    pub __ss_pad1: [::kernel::sys::raw::c_char; 6usize],
    pub __ss_align: __int64_t,
    pub __ss_pad2: [::kernel::sys::raw::c_char; 112usize],
}
#[test]
fn bindgen_test_layout_sockaddr_storage() {
    assert_eq!(::core::mem::size_of::<sockaddr_storage>() , 128usize , concat
               ! ( "Size of: " , stringify ! ( sockaddr_storage ) ));
    assert_eq! (::core::mem::align_of::<sockaddr_storage>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( sockaddr_storage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_storage ) ) . ss_len as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_storage ) ,
                "::" , stringify ! ( ss_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_storage ) ) . ss_family as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_storage ) ,
                "::" , stringify ! ( ss_family ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_storage ) ) . __ss_pad1 as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_storage ) ,
                "::" , stringify ! ( __ss_pad1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_storage ) ) . __ss_align as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_storage ) ,
                "::" , stringify ! ( __ss_align ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_storage ) ) . __ss_pad2 as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_storage ) ,
                "::" , stringify ! ( __ss_pad2 ) ));
}
impl Clone for sockaddr_storage {
    fn clone(&self) -> Self { *self }
}
impl Default for sockaddr_storage {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for sockaddr_storage {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "sockaddr_storage {{ ss_len: {:?}, ss_family: {:?}, __ss_pad1: {:?}, __ss_align: {:?}, __ss_pad2: [{}] }}"
               , self . ss_len , self . ss_family , self . __ss_pad1 , self .
               __ss_align , self . __ss_pad2 . iter (  ) . enumerate (  ) .
               map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ))
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct msghdr {
    pub msg_name: *mut ::kernel::sys::raw::c_void,
    pub msg_namelen: socklen_t,
    pub msg_iov: *mut iovec,
    pub msg_iovlen: ::kernel::sys::raw::c_int,
    pub msg_control: *mut ::kernel::sys::raw::c_void,
    pub msg_controllen: socklen_t,
    pub msg_flags: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_msghdr() {
    assert_eq!(::core::mem::size_of::<msghdr>() , 48usize , concat ! (
               "Size of: " , stringify ! ( msghdr ) ));
    assert_eq! (::core::mem::align_of::<msghdr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( msghdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msghdr ) ) . msg_name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( msghdr ) , "::" ,
                stringify ! ( msg_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msghdr ) ) . msg_namelen as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( msghdr ) , "::" ,
                stringify ! ( msg_namelen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msghdr ) ) . msg_iov as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( msghdr ) , "::" ,
                stringify ! ( msg_iov ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msghdr ) ) . msg_iovlen as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( msghdr ) , "::" ,
                stringify ! ( msg_iovlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msghdr ) ) . msg_control as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( msghdr ) , "::" ,
                stringify ! ( msg_control ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msghdr ) ) . msg_controllen as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( msghdr ) , "::" ,
                stringify ! ( msg_controllen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msghdr ) ) . msg_flags as * const _ as
                usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( msghdr ) , "::" ,
                stringify ! ( msg_flags ) ));
}
impl Clone for msghdr {
    fn clone(&self) -> Self { *self }
}
impl Default for msghdr {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct cmsghdr {
    pub cmsg_len: socklen_t,
    pub cmsg_level: ::kernel::sys::raw::c_int,
    pub cmsg_type: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_cmsghdr() {
    assert_eq!(::core::mem::size_of::<cmsghdr>() , 12usize , concat ! (
               "Size of: " , stringify ! ( cmsghdr ) ));
    assert_eq! (::core::mem::align_of::<cmsghdr>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( cmsghdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmsghdr ) ) . cmsg_len as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( cmsghdr ) , "::" ,
                stringify ! ( cmsg_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmsghdr ) ) . cmsg_level as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( cmsghdr ) , "::" ,
                stringify ! ( cmsg_level ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmsghdr ) ) . cmsg_type as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( cmsghdr ) , "::" ,
                stringify ! ( cmsg_type ) ));
}
impl Clone for cmsghdr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct cmsgcred {
    pub cmcred_pid: pid_t,
    pub cmcred_uid: uid_t,
    pub cmcred_euid: uid_t,
    pub cmcred_gid: gid_t,
    pub cmcred_ngroups: ::kernel::sys::raw::c_short,
    pub cmcred_groups: [gid_t; 16usize],
}
#[test]
fn bindgen_test_layout_cmsgcred() {
    assert_eq!(::core::mem::size_of::<cmsgcred>() , 84usize , concat ! (
               "Size of: " , stringify ! ( cmsgcred ) ));
    assert_eq! (::core::mem::align_of::<cmsgcred>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( cmsgcred ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmsgcred ) ) . cmcred_pid as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( cmsgcred ) , "::" ,
                stringify ! ( cmcred_pid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmsgcred ) ) . cmcred_uid as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( cmsgcred ) , "::" ,
                stringify ! ( cmcred_uid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmsgcred ) ) . cmcred_euid as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( cmsgcred ) , "::" ,
                stringify ! ( cmcred_euid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmsgcred ) ) . cmcred_gid as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( cmsgcred ) , "::" ,
                stringify ! ( cmcred_gid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmsgcred ) ) . cmcred_ngroups as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( cmsgcred ) , "::" ,
                stringify ! ( cmcred_ngroups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmsgcred ) ) . cmcred_groups as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( cmsgcred ) , "::" ,
                stringify ! ( cmcred_groups ) ));
}
impl Clone for cmsgcred {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct sockcred {
    pub sc_uid: uid_t,
    pub sc_euid: uid_t,
    pub sc_gid: gid_t,
    pub sc_egid: gid_t,
    pub sc_ngroups: ::kernel::sys::raw::c_int,
    pub sc_groups: [gid_t; 1usize],
}
#[test]
fn bindgen_test_layout_sockcred() {
    assert_eq!(::core::mem::size_of::<sockcred>() , 24usize , concat ! (
               "Size of: " , stringify ! ( sockcred ) ));
    assert_eq! (::core::mem::align_of::<sockcred>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( sockcred ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockcred ) ) . sc_uid as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sockcred ) , "::" ,
                stringify ! ( sc_uid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockcred ) ) . sc_euid as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( sockcred ) , "::" ,
                stringify ! ( sc_euid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockcred ) ) . sc_gid as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sockcred ) , "::" ,
                stringify ! ( sc_gid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockcred ) ) . sc_egid as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( sockcred ) , "::" ,
                stringify ! ( sc_egid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockcred ) ) . sc_ngroups as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( sockcred ) , "::" ,
                stringify ! ( sc_ngroups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockcred ) ) . sc_groups as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( sockcred ) , "::" ,
                stringify ! ( sc_groups ) ));
}
impl Clone for sockcred {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct sock_timestamp_info {
    pub st_info_flags: __uint32_t,
    pub st_info_pad0: __uint32_t,
    pub st_info_rsv: [__uint64_t; 7usize],
}
#[test]
fn bindgen_test_layout_sock_timestamp_info() {
    assert_eq!(::core::mem::size_of::<sock_timestamp_info>() , 64usize ,
               concat ! ( "Size of: " , stringify ! ( sock_timestamp_info )
               ));
    assert_eq! (::core::mem::align_of::<sock_timestamp_info>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( sock_timestamp_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sock_timestamp_info ) ) . st_info_flags
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sock_timestamp_info ) ,
                "::" , stringify ! ( st_info_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sock_timestamp_info ) ) . st_info_pad0 as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( sock_timestamp_info ) ,
                "::" , stringify ! ( st_info_pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sock_timestamp_info ) ) . st_info_rsv as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sock_timestamp_info ) ,
                "::" , stringify ! ( st_info_rsv ) ));
}
impl Clone for sock_timestamp_info {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct osockaddr {
    pub sa_family: ::kernel::sys::raw::c_ushort,
    pub sa_data: [::kernel::sys::raw::c_char; 14usize],
}
#[test]
fn bindgen_test_layout_osockaddr() {
    assert_eq!(::core::mem::size_of::<osockaddr>() , 16usize , concat ! (
               "Size of: " , stringify ! ( osockaddr ) ));
    assert_eq! (::core::mem::align_of::<osockaddr>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( osockaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const osockaddr ) ) . sa_family as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( osockaddr ) , "::" ,
                stringify ! ( sa_family ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const osockaddr ) ) . sa_data as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( osockaddr ) , "::" ,
                stringify ! ( sa_data ) ));
}
impl Clone for osockaddr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct omsghdr {
    pub msg_name: *mut ::kernel::sys::raw::c_char,
    pub msg_namelen: ::kernel::sys::raw::c_int,
    pub msg_iov: *mut iovec,
    pub msg_iovlen: ::kernel::sys::raw::c_int,
    pub msg_accrights: *mut ::kernel::sys::raw::c_char,
    pub msg_accrightslen: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_omsghdr() {
    assert_eq!(::core::mem::size_of::<omsghdr>() , 48usize , concat ! (
               "Size of: " , stringify ! ( omsghdr ) ));
    assert_eq! (::core::mem::align_of::<omsghdr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( omsghdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const omsghdr ) ) . msg_name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( omsghdr ) , "::" ,
                stringify ! ( msg_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const omsghdr ) ) . msg_namelen as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( omsghdr ) , "::" ,
                stringify ! ( msg_namelen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const omsghdr ) ) . msg_iov as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( omsghdr ) , "::" ,
                stringify ! ( msg_iov ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const omsghdr ) ) . msg_iovlen as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( omsghdr ) , "::" ,
                stringify ! ( msg_iovlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const omsghdr ) ) . msg_accrights as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( omsghdr ) , "::" ,
                stringify ! ( msg_accrights ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const omsghdr ) ) . msg_accrightslen as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( omsghdr ) , "::" ,
                stringify ! ( msg_accrightslen ) ));
}
impl Clone for omsghdr {
    fn clone(&self) -> Self { *self }
}
impl Default for omsghdr {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sf_hdtr {
    pub headers: *mut iovec,
    pub hdr_cnt: ::kernel::sys::raw::c_int,
    pub trailers: *mut iovec,
    pub trl_cnt: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_sf_hdtr() {
    assert_eq!(::core::mem::size_of::<sf_hdtr>() , 32usize , concat ! (
               "Size of: " , stringify ! ( sf_hdtr ) ));
    assert_eq! (::core::mem::align_of::<sf_hdtr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sf_hdtr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sf_hdtr ) ) . headers as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sf_hdtr ) , "::" ,
                stringify ! ( headers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sf_hdtr ) ) . hdr_cnt as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sf_hdtr ) , "::" ,
                stringify ! ( hdr_cnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sf_hdtr ) ) . trailers as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( sf_hdtr ) , "::" ,
                stringify ! ( trailers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sf_hdtr ) ) . trl_cnt as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( sf_hdtr ) , "::" ,
                stringify ! ( trl_cnt ) ));
}
impl Clone for sf_hdtr {
    fn clone(&self) -> Self { *self }
}
impl Default for sf_hdtr {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mmsghdr {
    pub msg_hdr: msghdr,
    pub msg_len: isize,
}
#[test]
fn bindgen_test_layout_mmsghdr() {
    assert_eq!(::core::mem::size_of::<mmsghdr>() , 56usize , concat ! (
               "Size of: " , stringify ! ( mmsghdr ) ));
    assert_eq! (::core::mem::align_of::<mmsghdr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( mmsghdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mmsghdr ) ) . msg_hdr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mmsghdr ) , "::" ,
                stringify ! ( msg_hdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mmsghdr ) ) . msg_len as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( mmsghdr ) , "::" ,
                stringify ! ( msg_len ) ));
}
impl Clone for mmsghdr {
    fn clone(&self) -> Self { *self }
}
impl Default for mmsghdr {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct socket {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcpcb {
    _unused: [u8; 0],
}
extern "C" {
    pub fn so_sototcpcb(so: *mut socket) -> *mut tcpcb;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct inpcb {
    _unused: [u8; 0],
}
extern "C" {
    pub fn so_sotoinpcb(so: *mut socket) -> *mut inpcb;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockbuf {
    _unused: [u8; 0],
}
extern "C" {
    pub fn so_sockbuf_snd(arg1: *mut socket) -> *mut sockbuf;
}
extern "C" {
    pub fn so_sockbuf_rcv(arg1: *mut socket) -> *mut sockbuf;
}
extern "C" {
    pub fn so_state_get(arg1: *const socket) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn so_state_set(arg1: *mut socket, arg2: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn so_options_get(arg1: *const socket) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn so_options_set(arg1: *mut socket, arg2: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn so_error_get(arg1: *const socket) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn so_error_set(arg1: *mut socket, arg2: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn so_linger_get(arg1: *const socket) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn so_linger_set(arg1: *mut socket, arg2: ::kernel::sys::raw::c_int);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct protosw {
    _unused: [u8; 0],
}
extern "C" {
    pub fn so_protosw_get(arg1: *const socket) -> *mut protosw;
}
extern "C" {
    pub fn so_protosw_set(arg1: *mut socket, arg2: *mut protosw);
}
extern "C" {
    pub fn so_sorwakeup_locked(so: *mut socket);
}
extern "C" {
    pub fn so_sowwakeup_locked(so: *mut socket);
}
extern "C" {
    pub fn so_sorwakeup(so: *mut socket);
}
extern "C" {
    pub fn so_sowwakeup(so: *mut socket);
}
extern "C" {
    pub fn so_lock(so: *mut socket);
}
extern "C" {
    pub fn so_unlock(so: *mut socket);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct if_clonereq {
    pub ifcr_total: ::kernel::sys::raw::c_int,
    pub ifcr_count: ::kernel::sys::raw::c_int,
    pub ifcr_buffer: *mut ::kernel::sys::raw::c_char,
}
#[test]
fn bindgen_test_layout_if_clonereq() {
    assert_eq!(::core::mem::size_of::<if_clonereq>() , 16usize , concat ! (
               "Size of: " , stringify ! ( if_clonereq ) ));
    assert_eq! (::core::mem::align_of::<if_clonereq>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( if_clonereq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_clonereq ) ) . ifcr_total as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_clonereq ) , "::" ,
                stringify ! ( ifcr_total ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_clonereq ) ) . ifcr_count as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( if_clonereq ) , "::" ,
                stringify ! ( ifcr_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_clonereq ) ) . ifcr_buffer as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( if_clonereq ) , "::" ,
                stringify ! ( ifcr_buffer ) ));
}
impl Clone for if_clonereq {
    fn clone(&self) -> Self { *self }
}
impl Default for if_clonereq {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct if_data {
    pub ifi_type: u8,
    pub ifi_physical: u8,
    pub ifi_addrlen: u8,
    pub ifi_hdrlen: u8,
    pub ifi_link_state: u8,
    pub ifi_vhid: u8,
    pub ifi_datalen: u16,
    pub ifi_mtu: u32,
    pub ifi_metric: u32,
    pub ifi_baudrate: u64,
    pub ifi_ipackets: u64,
    pub ifi_ierrors: u64,
    pub ifi_opackets: u64,
    pub ifi_oerrors: u64,
    pub ifi_collisions: u64,
    pub ifi_ibytes: u64,
    pub ifi_obytes: u64,
    pub ifi_imcasts: u64,
    pub ifi_omcasts: u64,
    pub ifi_iqdrops: u64,
    pub ifi_oqdrops: u64,
    pub ifi_noproto: u64,
    pub ifi_hwassist: u64,
    pub __ifi_epoch: if_data__bindgen_ty_1,
    pub __ifi_lastchange: if_data__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy)]
pub union if_data__bindgen_ty_1 {
    pub tt: time_t,
    pub ph: u64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_if_data__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<if_data__bindgen_ty_1>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( if_data__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<if_data__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( if_data__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data__bindgen_ty_1 ) ) . tt as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data__bindgen_ty_1 )
                , "::" , stringify ! ( tt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data__bindgen_ty_1 ) ) . ph as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data__bindgen_ty_1 )
                , "::" , stringify ! ( ph ) ));
}
impl Clone for if_data__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for if_data__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for if_data__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "if_data__bindgen_ty_1 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy)]
pub union if_data__bindgen_ty_2 {
    pub tv: timeval,
    pub ph: if_data__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct if_data__bindgen_ty_2__bindgen_ty_1 {
    pub ph1: u64,
    pub ph2: u64,
}
#[test]
fn bindgen_test_layout_if_data__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<if_data__bindgen_ty_2__bindgen_ty_1>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( if_data__bindgen_ty_2__bindgen_ty_1
               ) ));
    assert_eq! (::core::mem::align_of::<if_data__bindgen_ty_2__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                if_data__bindgen_ty_2__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data__bindgen_ty_2__bindgen_ty_1 ) ) .
                ph1 as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                if_data__bindgen_ty_2__bindgen_ty_1 ) , "::" , stringify ! (
                ph1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data__bindgen_ty_2__bindgen_ty_1 ) ) .
                ph2 as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                if_data__bindgen_ty_2__bindgen_ty_1 ) , "::" , stringify ! (
                ph2 ) ));
}
impl Clone for if_data__bindgen_ty_2__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_if_data__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<if_data__bindgen_ty_2>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( if_data__bindgen_ty_2 )
               ));
    assert_eq! (::core::mem::align_of::<if_data__bindgen_ty_2>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( if_data__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data__bindgen_ty_2 ) ) . tv as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data__bindgen_ty_2 )
                , "::" , stringify ! ( tv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data__bindgen_ty_2 ) ) . ph as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data__bindgen_ty_2 )
                , "::" , stringify ! ( ph ) ));
}
impl Clone for if_data__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for if_data__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for if_data__bindgen_ty_2 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "if_data__bindgen_ty_2 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_if_data() {
    assert_eq!(::core::mem::size_of::<if_data>() , 152usize , concat ! (
               "Size of: " , stringify ! ( if_data ) ));
    assert_eq! (::core::mem::align_of::<if_data>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( if_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_type as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_physical as * const _
                as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_physical ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_addrlen as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_addrlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_hdrlen as * const _ as
                usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_hdrlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_link_state as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_link_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_vhid as * const _ as
                usize } , 5usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_vhid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_datalen as * const _ as
                usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_datalen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_mtu as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_mtu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_metric as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_metric ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_baudrate as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_baudrate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_ipackets as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_ipackets ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_ierrors as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_ierrors ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_opackets as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_opackets ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_oerrors as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_oerrors ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_collisions as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_collisions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_ibytes as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_ibytes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_obytes as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_obytes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_imcasts as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_imcasts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_omcasts as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_omcasts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_iqdrops as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_iqdrops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_oqdrops as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_oqdrops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_noproto as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_noproto ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_hwassist as * const _
                as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_hwassist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . __ifi_epoch as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( __ifi_epoch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . __ifi_lastchange as * const
                _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( __ifi_lastchange ) ));
}
impl Clone for if_data {
    fn clone(&self) -> Self { *self }
}
impl Default for if_data {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for if_data {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "if_data {{ ifi_type: {:?}, ifi_physical: {:?}, ifi_addrlen: {:?}, ifi_hdrlen: {:?}, ifi_link_state: {:?}, ifi_vhid: {:?}, ifi_datalen: {:?}, ifi_mtu: {:?}, ifi_metric: {:?}, ifi_baudrate: {:?}, ifi_ipackets: {:?}, ifi_ierrors: {:?}, ifi_opackets: {:?}, ifi_oerrors: {:?}, ifi_collisions: {:?}, ifi_ibytes: {:?}, ifi_obytes: {:?}, ifi_imcasts: {:?}, ifi_omcasts: {:?}, ifi_iqdrops: {:?}, ifi_oqdrops: {:?}, ifi_noproto: {:?}, ifi_hwassist: {:?}, __ifi_epoch: {:?}, __ifi_lastchange: {:?} }}"
               , self . ifi_type , self . ifi_physical , self . ifi_addrlen ,
               self . ifi_hdrlen , self . ifi_link_state , self . ifi_vhid ,
               self . ifi_datalen , self . ifi_mtu , self . ifi_metric , self
               . ifi_baudrate , self . ifi_ipackets , self . ifi_ierrors ,
               self . ifi_opackets , self . ifi_oerrors , self .
               ifi_collisions , self . ifi_ibytes , self . ifi_obytes , self .
               ifi_imcasts , self . ifi_omcasts , self . ifi_iqdrops , self .
               ifi_oqdrops , self . ifi_noproto , self . ifi_hwassist , self .
               __ifi_epoch , self . __ifi_lastchange)
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct if_msghdr {
    pub ifm_msglen: u_short,
    pub ifm_version: u_char,
    pub ifm_type: u_char,
    pub ifm_addrs: ::kernel::sys::raw::c_int,
    pub ifm_flags: ::kernel::sys::raw::c_int,
    pub ifm_index: u_short,
    pub ifm_data: if_data,
}
#[test]
fn bindgen_test_layout_if_msghdr() {
    assert_eq!(::core::mem::size_of::<if_msghdr>() , 168usize , concat ! (
               "Size of: " , stringify ! ( if_msghdr ) ));
    assert_eq! (::core::mem::align_of::<if_msghdr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( if_msghdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_msghdr ) ) . ifm_msglen as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_msghdr ) , "::" ,
                stringify ! ( ifm_msglen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_msghdr ) ) . ifm_version as * const _
                as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( if_msghdr ) , "::" ,
                stringify ! ( ifm_version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_msghdr ) ) . ifm_type as * const _ as
                usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( if_msghdr ) , "::" ,
                stringify ! ( ifm_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_msghdr ) ) . ifm_addrs as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( if_msghdr ) , "::" ,
                stringify ! ( ifm_addrs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_msghdr ) ) . ifm_flags as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( if_msghdr ) , "::" ,
                stringify ! ( ifm_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_msghdr ) ) . ifm_index as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( if_msghdr ) , "::" ,
                stringify ! ( ifm_index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_msghdr ) ) . ifm_data as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( if_msghdr ) , "::" ,
                stringify ! ( ifm_data ) ));
}
impl Clone for if_msghdr {
    fn clone(&self) -> Self { *self }
}
impl Default for if_msghdr {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for if_msghdr {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "if_msghdr {{ ifm_msglen: {:?}, ifm_version: {:?}, ifm_type: {:?}, ifm_addrs: {:?}, ifm_flags: {:?}, ifm_index: {:?}, ifm_data: {:?} }}"
               , self . ifm_msglen , self . ifm_version , self . ifm_type ,
               self . ifm_addrs , self . ifm_flags , self . ifm_index , self .
               ifm_data)
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct if_msghdrl {
    pub ifm_msglen: u_short,
    pub ifm_version: u_char,
    pub ifm_type: u_char,
    pub ifm_addrs: ::kernel::sys::raw::c_int,
    pub ifm_flags: ::kernel::sys::raw::c_int,
    pub ifm_index: u_short,
    pub _ifm_spare1: u_short,
    pub ifm_len: u_short,
    pub ifm_data_off: u_short,
    pub ifm_data: if_data,
}
#[test]
fn bindgen_test_layout_if_msghdrl() {
    assert_eq!(::core::mem::size_of::<if_msghdrl>() , 176usize , concat ! (
               "Size of: " , stringify ! ( if_msghdrl ) ));
    assert_eq! (::core::mem::align_of::<if_msghdrl>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( if_msghdrl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_msghdrl ) ) . ifm_msglen as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_msghdrl ) , "::" ,
                stringify ! ( ifm_msglen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_msghdrl ) ) . ifm_version as * const _
                as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( if_msghdrl ) , "::" ,
                stringify ! ( ifm_version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_msghdrl ) ) . ifm_type as * const _ as
                usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( if_msghdrl ) , "::" ,
                stringify ! ( ifm_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_msghdrl ) ) . ifm_addrs as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( if_msghdrl ) , "::" ,
                stringify ! ( ifm_addrs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_msghdrl ) ) . ifm_flags as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( if_msghdrl ) , "::" ,
                stringify ! ( ifm_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_msghdrl ) ) . ifm_index as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( if_msghdrl ) , "::" ,
                stringify ! ( ifm_index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_msghdrl ) ) . _ifm_spare1 as * const _
                as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( if_msghdrl ) , "::" ,
                stringify ! ( _ifm_spare1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_msghdrl ) ) . ifm_len as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( if_msghdrl ) , "::" ,
                stringify ! ( ifm_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_msghdrl ) ) . ifm_data_off as * const
                _ as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( if_msghdrl ) , "::" ,
                stringify ! ( ifm_data_off ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_msghdrl ) ) . ifm_data as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( if_msghdrl ) , "::" ,
                stringify ! ( ifm_data ) ));
}
impl Clone for if_msghdrl {
    fn clone(&self) -> Self { *self }
}
impl Default for if_msghdrl {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for if_msghdrl {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "if_msghdrl {{ ifm_msglen: {:?}, ifm_version: {:?}, ifm_type: {:?}, ifm_addrs: {:?}, ifm_flags: {:?}, ifm_index: {:?}, _ifm_spare1: {:?}, ifm_len: {:?}, ifm_data_off: {:?}, ifm_data: {:?} }}"
               , self . ifm_msglen , self . ifm_version , self . ifm_type ,
               self . ifm_addrs , self . ifm_flags , self . ifm_index , self .
               _ifm_spare1 , self . ifm_len , self . ifm_data_off , self .
               ifm_data)
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct ifa_msghdr {
    pub ifam_msglen: u_short,
    pub ifam_version: u_char,
    pub ifam_type: u_char,
    pub ifam_addrs: ::kernel::sys::raw::c_int,
    pub ifam_flags: ::kernel::sys::raw::c_int,
    pub ifam_index: u_short,
    pub ifam_metric: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_ifa_msghdr() {
    assert_eq!(::core::mem::size_of::<ifa_msghdr>() , 20usize , concat ! (
               "Size of: " , stringify ! ( ifa_msghdr ) ));
    assert_eq! (::core::mem::align_of::<ifa_msghdr>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( ifa_msghdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifa_msghdr ) ) . ifam_msglen as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifa_msghdr ) , "::" ,
                stringify ! ( ifam_msglen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifa_msghdr ) ) . ifam_version as * const
                _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( ifa_msghdr ) , "::" ,
                stringify ! ( ifam_version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifa_msghdr ) ) . ifam_type as * const _
                as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( ifa_msghdr ) , "::" ,
                stringify ! ( ifam_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifa_msghdr ) ) . ifam_addrs as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ifa_msghdr ) , "::" ,
                stringify ! ( ifam_addrs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifa_msghdr ) ) . ifam_flags as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifa_msghdr ) , "::" ,
                stringify ! ( ifam_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifa_msghdr ) ) . ifam_index as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( ifa_msghdr ) , "::" ,
                stringify ! ( ifam_index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifa_msghdr ) ) . ifam_metric as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ifa_msghdr ) , "::" ,
                stringify ! ( ifam_metric ) ));
}
impl Clone for ifa_msghdr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ifa_msghdrl {
    pub ifam_msglen: u_short,
    pub ifam_version: u_char,
    pub ifam_type: u_char,
    pub ifam_addrs: ::kernel::sys::raw::c_int,
    pub ifam_flags: ::kernel::sys::raw::c_int,
    pub ifam_index: u_short,
    pub _ifam_spare1: u_short,
    pub ifam_len: u_short,
    pub ifam_data_off: u_short,
    pub ifam_metric: ::kernel::sys::raw::c_int,
    pub ifam_data: if_data,
}
#[test]
fn bindgen_test_layout_ifa_msghdrl() {
    assert_eq!(::core::mem::size_of::<ifa_msghdrl>() , 176usize , concat ! (
               "Size of: " , stringify ! ( ifa_msghdrl ) ));
    assert_eq! (::core::mem::align_of::<ifa_msghdrl>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ifa_msghdrl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifa_msghdrl ) ) . ifam_msglen as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifa_msghdrl ) , "::" ,
                stringify ! ( ifam_msglen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifa_msghdrl ) ) . ifam_version as * const
                _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( ifa_msghdrl ) , "::" ,
                stringify ! ( ifam_version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifa_msghdrl ) ) . ifam_type as * const _
                as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( ifa_msghdrl ) , "::" ,
                stringify ! ( ifam_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifa_msghdrl ) ) . ifam_addrs as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ifa_msghdrl ) , "::" ,
                stringify ! ( ifam_addrs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifa_msghdrl ) ) . ifam_flags as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifa_msghdrl ) , "::" ,
                stringify ! ( ifam_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifa_msghdrl ) ) . ifam_index as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( ifa_msghdrl ) , "::" ,
                stringify ! ( ifam_index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifa_msghdrl ) ) . _ifam_spare1 as * const
                _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( ifa_msghdrl ) , "::" ,
                stringify ! ( _ifam_spare1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifa_msghdrl ) ) . ifam_len as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ifa_msghdrl ) , "::" ,
                stringify ! ( ifam_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifa_msghdrl ) ) . ifam_data_off as *
                const _ as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( ifa_msghdrl ) , "::" ,
                stringify ! ( ifam_data_off ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifa_msghdrl ) ) . ifam_metric as * const
                _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( ifa_msghdrl ) , "::" ,
                stringify ! ( ifam_metric ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifa_msghdrl ) ) . ifam_data as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ifa_msghdrl ) , "::" ,
                stringify ! ( ifam_data ) ));
}
impl Clone for ifa_msghdrl {
    fn clone(&self) -> Self { *self }
}
impl Default for ifa_msghdrl {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for ifa_msghdrl {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "ifa_msghdrl {{ ifam_msglen: {:?}, ifam_version: {:?}, ifam_type: {:?}, ifam_addrs: {:?}, ifam_flags: {:?}, ifam_index: {:?}, _ifam_spare1: {:?}, ifam_len: {:?}, ifam_data_off: {:?}, ifam_metric: {:?}, ifam_data: {:?} }}"
               , self . ifam_msglen , self . ifam_version , self . ifam_type ,
               self . ifam_addrs , self . ifam_flags , self . ifam_index ,
               self . _ifam_spare1 , self . ifam_len , self . ifam_data_off ,
               self . ifam_metric , self . ifam_data)
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct ifma_msghdr {
    pub ifmam_msglen: u_short,
    pub ifmam_version: u_char,
    pub ifmam_type: u_char,
    pub ifmam_addrs: ::kernel::sys::raw::c_int,
    pub ifmam_flags: ::kernel::sys::raw::c_int,
    pub ifmam_index: u_short,
}
#[test]
fn bindgen_test_layout_ifma_msghdr() {
    assert_eq!(::core::mem::size_of::<ifma_msghdr>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ifma_msghdr ) ));
    assert_eq! (::core::mem::align_of::<ifma_msghdr>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( ifma_msghdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifma_msghdr ) ) . ifmam_msglen as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifma_msghdr ) , "::" ,
                stringify ! ( ifmam_msglen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifma_msghdr ) ) . ifmam_version as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( ifma_msghdr ) , "::" ,
                stringify ! ( ifmam_version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifma_msghdr ) ) . ifmam_type as * const _
                as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( ifma_msghdr ) , "::" ,
                stringify ! ( ifmam_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifma_msghdr ) ) . ifmam_addrs as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ifma_msghdr ) , "::" ,
                stringify ! ( ifmam_addrs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifma_msghdr ) ) . ifmam_flags as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifma_msghdr ) , "::" ,
                stringify ! ( ifmam_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifma_msghdr ) ) . ifmam_index as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( ifma_msghdr ) , "::" ,
                stringify ! ( ifmam_index ) ));
}
impl Clone for ifma_msghdr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct if_announcemsghdr {
    pub ifan_msglen: u_short,
    pub ifan_version: u_char,
    pub ifan_type: u_char,
    pub ifan_index: u_short,
    pub ifan_name: [::kernel::sys::raw::c_char; 16usize],
    pub ifan_what: u_short,
}
#[test]
fn bindgen_test_layout_if_announcemsghdr() {
    assert_eq!(::core::mem::size_of::<if_announcemsghdr>() , 24usize , concat
               ! ( "Size of: " , stringify ! ( if_announcemsghdr ) ));
    assert_eq! (::core::mem::align_of::<if_announcemsghdr>() , 2usize , concat
                ! ( "Alignment of " , stringify ! ( if_announcemsghdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_announcemsghdr ) ) . ifan_msglen as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_announcemsghdr ) ,
                "::" , stringify ! ( ifan_msglen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_announcemsghdr ) ) . ifan_version as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( if_announcemsghdr ) ,
                "::" , stringify ! ( ifan_version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_announcemsghdr ) ) . ifan_type as *
                const _ as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( if_announcemsghdr ) ,
                "::" , stringify ! ( ifan_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_announcemsghdr ) ) . ifan_index as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( if_announcemsghdr ) ,
                "::" , stringify ! ( ifan_index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_announcemsghdr ) ) . ifan_name as *
                const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( if_announcemsghdr ) ,
                "::" , stringify ! ( ifan_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_announcemsghdr ) ) . ifan_what as *
                const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! ( if_announcemsghdr ) ,
                "::" , stringify ! ( ifan_what ) ));
}
impl Clone for if_announcemsghdr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifreq_buffer {
    pub length: usize,
    pub buffer: *mut ::kernel::sys::raw::c_void,
}
#[test]
fn bindgen_test_layout_ifreq_buffer() {
    assert_eq!(::core::mem::size_of::<ifreq_buffer>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ifreq_buffer ) ));
    assert_eq! (::core::mem::align_of::<ifreq_buffer>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ifreq_buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifreq_buffer ) ) . length as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifreq_buffer ) , "::" ,
                stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifreq_buffer ) ) . buffer as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifreq_buffer ) , "::" ,
                stringify ! ( buffer ) ));
}
impl Clone for ifreq_buffer {
    fn clone(&self) -> Self { *self }
}
impl Default for ifreq_buffer {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct ifreq {
    pub ifr_name: [::kernel::sys::raw::c_char; 16usize],
    pub ifr_ifru: ifreq__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub union ifreq__bindgen_ty_1 {
    pub ifru_addr: sockaddr,
    pub ifru_dstaddr: sockaddr,
    pub ifru_broadaddr: sockaddr,
    pub ifru_buffer: ifreq_buffer,
    pub ifru_flags: [::kernel::sys::raw::c_short; 2usize],
    pub ifru_index: ::kernel::sys::raw::c_short,
    pub ifru_jid: ::kernel::sys::raw::c_int,
    pub ifru_metric: ::kernel::sys::raw::c_int,
    pub ifru_mtu: ::kernel::sys::raw::c_int,
    pub ifru_phys: ::kernel::sys::raw::c_int,
    pub ifru_media: ::kernel::sys::raw::c_int,
    pub ifru_data: caddr_t,
    pub ifru_cap: [::kernel::sys::raw::c_int; 2usize],
    pub ifru_fib: u_int,
    pub ifru_vlan_pcp: u_char,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_ifreq__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<ifreq__bindgen_ty_1>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( ifreq__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<ifreq__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( ifreq__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifreq__bindgen_ty_1 ) ) . ifru_addr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifreq__bindgen_ty_1 ) ,
                "::" , stringify ! ( ifru_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifreq__bindgen_ty_1 ) ) . ifru_dstaddr as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifreq__bindgen_ty_1 ) ,
                "::" , stringify ! ( ifru_dstaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifreq__bindgen_ty_1 ) ) . ifru_broadaddr
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifreq__bindgen_ty_1 ) ,
                "::" , stringify ! ( ifru_broadaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifreq__bindgen_ty_1 ) ) . ifru_buffer as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifreq__bindgen_ty_1 ) ,
                "::" , stringify ! ( ifru_buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifreq__bindgen_ty_1 ) ) . ifru_flags as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifreq__bindgen_ty_1 ) ,
                "::" , stringify ! ( ifru_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifreq__bindgen_ty_1 ) ) . ifru_index as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifreq__bindgen_ty_1 ) ,
                "::" , stringify ! ( ifru_index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifreq__bindgen_ty_1 ) ) . ifru_jid as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifreq__bindgen_ty_1 ) ,
                "::" , stringify ! ( ifru_jid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifreq__bindgen_ty_1 ) ) . ifru_metric as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifreq__bindgen_ty_1 ) ,
                "::" , stringify ! ( ifru_metric ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifreq__bindgen_ty_1 ) ) . ifru_mtu as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifreq__bindgen_ty_1 ) ,
                "::" , stringify ! ( ifru_mtu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifreq__bindgen_ty_1 ) ) . ifru_phys as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifreq__bindgen_ty_1 ) ,
                "::" , stringify ! ( ifru_phys ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifreq__bindgen_ty_1 ) ) . ifru_media as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifreq__bindgen_ty_1 ) ,
                "::" , stringify ! ( ifru_media ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifreq__bindgen_ty_1 ) ) . ifru_data as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifreq__bindgen_ty_1 ) ,
                "::" , stringify ! ( ifru_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifreq__bindgen_ty_1 ) ) . ifru_cap as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifreq__bindgen_ty_1 ) ,
                "::" , stringify ! ( ifru_cap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifreq__bindgen_ty_1 ) ) . ifru_fib as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifreq__bindgen_ty_1 ) ,
                "::" , stringify ! ( ifru_fib ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifreq__bindgen_ty_1 ) ) . ifru_vlan_pcp
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifreq__bindgen_ty_1 ) ,
                "::" , stringify ! ( ifru_vlan_pcp ) ));
}
impl Clone for ifreq__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for ifreq__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for ifreq__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "ifreq__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_ifreq() {
    assert_eq!(::core::mem::size_of::<ifreq>() , 32usize , concat ! (
               "Size of: " , stringify ! ( ifreq ) ));
    assert_eq! (::core::mem::align_of::<ifreq>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ifreq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifreq ) ) . ifr_name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifreq ) , "::" ,
                stringify ! ( ifr_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifreq ) ) . ifr_ifru as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ifreq ) , "::" ,
                stringify ! ( ifr_ifru ) ));
}
impl Clone for ifreq {
    fn clone(&self) -> Self { *self }
}
impl Default for ifreq {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for ifreq {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "ifreq {{ ifr_name: {:?}, ifr_ifru: {:?} }}" , self .
               ifr_name , self . ifr_ifru)
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct ifaliasreq {
    pub ifra_name: [::kernel::sys::raw::c_char; 16usize],
    pub ifra_addr: sockaddr,
    pub ifra_broadaddr: sockaddr,
    pub ifra_mask: sockaddr,
    pub ifra_vhid: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_ifaliasreq() {
    assert_eq!(::core::mem::size_of::<ifaliasreq>() , 68usize , concat ! (
               "Size of: " , stringify ! ( ifaliasreq ) ));
    assert_eq! (::core::mem::align_of::<ifaliasreq>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( ifaliasreq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaliasreq ) ) . ifra_name as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaliasreq ) , "::" ,
                stringify ! ( ifra_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaliasreq ) ) . ifra_addr as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaliasreq ) , "::" ,
                stringify ! ( ifra_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaliasreq ) ) . ifra_broadaddr as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaliasreq ) , "::" ,
                stringify ! ( ifra_broadaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaliasreq ) ) . ifra_mask as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaliasreq ) , "::" ,
                stringify ! ( ifra_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaliasreq ) ) . ifra_vhid as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaliasreq ) , "::" ,
                stringify ! ( ifra_vhid ) ));
}
impl Clone for ifaliasreq {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct oifaliasreq {
    pub ifra_name: [::kernel::sys::raw::c_char; 16usize],
    pub ifra_addr: sockaddr,
    pub ifra_broadaddr: sockaddr,
    pub ifra_mask: sockaddr,
}
#[test]
fn bindgen_test_layout_oifaliasreq() {
    assert_eq!(::core::mem::size_of::<oifaliasreq>() , 64usize , concat ! (
               "Size of: " , stringify ! ( oifaliasreq ) ));
    assert_eq! (::core::mem::align_of::<oifaliasreq>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( oifaliasreq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const oifaliasreq ) ) . ifra_name as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( oifaliasreq ) , "::" ,
                stringify ! ( ifra_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const oifaliasreq ) ) . ifra_addr as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( oifaliasreq ) , "::" ,
                stringify ! ( ifra_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const oifaliasreq ) ) . ifra_broadaddr as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( oifaliasreq ) , "::" ,
                stringify ! ( ifra_broadaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const oifaliasreq ) ) . ifra_mask as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( oifaliasreq ) , "::" ,
                stringify ! ( ifra_mask ) ));
}
impl Clone for oifaliasreq {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifmediareq {
    pub ifm_name: [::kernel::sys::raw::c_char; 16usize],
    pub ifm_current: ::kernel::sys::raw::c_int,
    pub ifm_mask: ::kernel::sys::raw::c_int,
    pub ifm_status: ::kernel::sys::raw::c_int,
    pub ifm_active: ::kernel::sys::raw::c_int,
    pub ifm_count: ::kernel::sys::raw::c_int,
    pub ifm_ulist: *mut ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_ifmediareq() {
    assert_eq!(::core::mem::size_of::<ifmediareq>() , 48usize , concat ! (
               "Size of: " , stringify ! ( ifmediareq ) ));
    assert_eq! (::core::mem::align_of::<ifmediareq>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ifmediareq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmediareq ) ) . ifm_name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmediareq ) , "::" ,
                stringify ! ( ifm_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmediareq ) ) . ifm_current as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmediareq ) , "::" ,
                stringify ! ( ifm_current ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmediareq ) ) . ifm_mask as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmediareq ) , "::" ,
                stringify ! ( ifm_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmediareq ) ) . ifm_status as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmediareq ) , "::" ,
                stringify ! ( ifm_status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmediareq ) ) . ifm_active as * const _
                as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmediareq ) , "::" ,
                stringify ! ( ifm_active ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmediareq ) ) . ifm_count as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmediareq ) , "::" ,
                stringify ! ( ifm_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmediareq ) ) . ifm_ulist as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmediareq ) , "::" ,
                stringify ! ( ifm_ulist ) ));
}
impl Clone for ifmediareq {
    fn clone(&self) -> Self { *self }
}
impl Default for ifmediareq {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifdrv {
    pub ifd_name: [::kernel::sys::raw::c_char; 16usize],
    pub ifd_cmd: ::kernel::sys::raw::c_ulong,
    pub ifd_len: usize,
    pub ifd_data: *mut ::kernel::sys::raw::c_void,
}
#[test]
fn bindgen_test_layout_ifdrv() {
    assert_eq!(::core::mem::size_of::<ifdrv>() , 40usize , concat ! (
               "Size of: " , stringify ! ( ifdrv ) ));
    assert_eq! (::core::mem::align_of::<ifdrv>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ifdrv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifdrv ) ) . ifd_name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifdrv ) , "::" ,
                stringify ! ( ifd_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifdrv ) ) . ifd_cmd as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ifdrv ) , "::" ,
                stringify ! ( ifd_cmd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifdrv ) ) . ifd_len as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ifdrv ) , "::" ,
                stringify ! ( ifd_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifdrv ) ) . ifd_data as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( ifdrv ) , "::" ,
                stringify ! ( ifd_data ) ));
}
impl Clone for ifdrv {
    fn clone(&self) -> Self { *self }
}
impl Default for ifdrv {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct ifstat {
    pub ifs_name: [::kernel::sys::raw::c_char; 16usize],
    pub ascii: [::kernel::sys::raw::c_char; 801usize],
}
#[test]
fn bindgen_test_layout_ifstat() {
    assert_eq!(::core::mem::size_of::<ifstat>() , 817usize , concat ! (
               "Size of: " , stringify ! ( ifstat ) ));
    assert_eq! (::core::mem::align_of::<ifstat>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( ifstat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifstat ) ) . ifs_name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifstat ) , "::" ,
                stringify ! ( ifs_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifstat ) ) . ascii as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ifstat ) , "::" ,
                stringify ! ( ascii ) ));
}
impl Clone for ifstat {
    fn clone(&self) -> Self { *self }
}
impl Default for ifstat {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for ifstat {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "ifstat {{ ifs_name: {:?}, ascii: [{}] }}" , self .
               ifs_name , self . ascii . iter (  ) . enumerate (  ) . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ))
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct ifconf {
    pub ifc_len: ::kernel::sys::raw::c_int,
    pub ifc_ifcu: ifconf__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub union ifconf__bindgen_ty_1 {
    pub ifcu_buf: caddr_t,
    pub ifcu_req: *mut ifreq,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_ifconf__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<ifconf__bindgen_ty_1>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( ifconf__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<ifconf__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( ifconf__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifconf__bindgen_ty_1 ) ) . ifcu_buf as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifconf__bindgen_ty_1 )
                , "::" , stringify ! ( ifcu_buf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifconf__bindgen_ty_1 ) ) . ifcu_req as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifconf__bindgen_ty_1 )
                , "::" , stringify ! ( ifcu_req ) ));
}
impl Clone for ifconf__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for ifconf__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for ifconf__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "ifconf__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_ifconf() {
    assert_eq!(::core::mem::size_of::<ifconf>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ifconf ) ));
    assert_eq! (::core::mem::align_of::<ifconf>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ifconf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifconf ) ) . ifc_len as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifconf ) , "::" ,
                stringify ! ( ifc_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifconf ) ) . ifc_ifcu as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifconf ) , "::" ,
                stringify ! ( ifc_ifcu ) ));
}
impl Clone for ifconf {
    fn clone(&self) -> Self { *self }
}
impl Default for ifconf {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for ifconf {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "ifconf {{ ifc_len: {:?}, ifc_ifcu: {:?} }}" , self .
               ifc_len , self . ifc_ifcu)
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct ifg_req {
    pub ifgrq_ifgrqu: ifg_req__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub union ifg_req__bindgen_ty_1 {
    pub ifgrqu_group: [::kernel::sys::raw::c_char; 16usize],
    pub ifgrqu_member: [::kernel::sys::raw::c_char; 16usize],
    _bindgen_union_align: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_ifg_req__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<ifg_req__bindgen_ty_1>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( ifg_req__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<ifg_req__bindgen_ty_1>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( ifg_req__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifg_req__bindgen_ty_1 ) ) . ifgrqu_group
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifg_req__bindgen_ty_1 )
                , "::" , stringify ! ( ifgrqu_group ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifg_req__bindgen_ty_1 ) ) . ifgrqu_member
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifg_req__bindgen_ty_1 )
                , "::" , stringify ! ( ifgrqu_member ) ));
}
impl Clone for ifg_req__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for ifg_req__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for ifg_req__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "ifg_req__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_ifg_req() {
    assert_eq!(::core::mem::size_of::<ifg_req>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ifg_req ) ));
    assert_eq! (::core::mem::align_of::<ifg_req>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( ifg_req ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifg_req ) ) . ifgrq_ifgrqu as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifg_req ) , "::" ,
                stringify ! ( ifgrq_ifgrqu ) ));
}
impl Clone for ifg_req {
    fn clone(&self) -> Self { *self }
}
impl Default for ifg_req {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for ifg_req {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "ifg_req {{ ifgrq_ifgrqu: {:?} }}" , self . ifgrq_ifgrqu)
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct ifgroupreq {
    pub ifgr_name: [::kernel::sys::raw::c_char; 16usize],
    pub ifgr_len: u_int,
    pub ifgr_ifgru: ifgroupreq__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub union ifgroupreq__bindgen_ty_1 {
    pub ifgru_group: [::kernel::sys::raw::c_char; 16usize],
    pub ifgru_groups: *mut ifg_req,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_ifgroupreq__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<ifgroupreq__bindgen_ty_1>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( ifgroupreq__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<ifgroupreq__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( ifgroupreq__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifgroupreq__bindgen_ty_1 ) ) .
                ifgru_group as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                ifgroupreq__bindgen_ty_1 ) , "::" , stringify ! ( ifgru_group
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifgroupreq__bindgen_ty_1 ) ) .
                ifgru_groups as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                ifgroupreq__bindgen_ty_1 ) , "::" , stringify ! ( ifgru_groups
                ) ));
}
impl Clone for ifgroupreq__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for ifgroupreq__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for ifgroupreq__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "ifgroupreq__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_ifgroupreq() {
    assert_eq!(::core::mem::size_of::<ifgroupreq>() , 40usize , concat ! (
               "Size of: " , stringify ! ( ifgroupreq ) ));
    assert_eq! (::core::mem::align_of::<ifgroupreq>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ifgroupreq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifgroupreq ) ) . ifgr_name as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifgroupreq ) , "::" ,
                stringify ! ( ifgr_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifgroupreq ) ) . ifgr_len as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ifgroupreq ) , "::" ,
                stringify ! ( ifgr_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifgroupreq ) ) . ifgr_ifgru as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ifgroupreq ) , "::" ,
                stringify ! ( ifgr_ifgru ) ));
}
impl Clone for ifgroupreq {
    fn clone(&self) -> Self { *self }
}
impl Default for ifgroupreq {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for ifgroupreq {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "ifgroupreq {{ ifgr_name: {:?}, ifgr_len: {:?}, ifgr_ifgru: {:?} }}"
               , self . ifgr_name , self . ifgr_len , self . ifgr_ifgru)
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct ifi2creq {
    pub dev_addr: u8,
    pub offset: u8,
    pub len: u8,
    pub spare0: u8,
    pub spare1: u32,
    pub data: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_ifi2creq() {
    assert_eq!(::core::mem::size_of::<ifi2creq>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ifi2creq ) ));
    assert_eq! (::core::mem::align_of::<ifi2creq>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( ifi2creq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifi2creq ) ) . dev_addr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifi2creq ) , "::" ,
                stringify ! ( dev_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifi2creq ) ) . offset as * const _ as
                usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( ifi2creq ) , "::" ,
                stringify ! ( offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifi2creq ) ) . len as * const _ as usize
                } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( ifi2creq ) , "::" ,
                stringify ! ( len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifi2creq ) ) . spare0 as * const _ as
                usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( ifi2creq ) , "::" ,
                stringify ! ( spare0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifi2creq ) ) . spare1 as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ifi2creq ) , "::" ,
                stringify ! ( spare1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifi2creq ) ) . data as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifi2creq ) , "::" ,
                stringify ! ( data ) ));
}
impl Clone for ifi2creq {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ifrsskey {
    pub ifrk_name: [::kernel::sys::raw::c_char; 16usize],
    pub ifrk_func: u8,
    pub ifrk_spare0: u8,
    pub ifrk_keylen: u16,
    pub ifrk_key: [u8; 128usize],
}
#[test]
fn bindgen_test_layout_ifrsskey() {
    assert_eq!(::core::mem::size_of::<ifrsskey>() , 148usize , concat ! (
               "Size of: " , stringify ! ( ifrsskey ) ));
    assert_eq! (::core::mem::align_of::<ifrsskey>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( ifrsskey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifrsskey ) ) . ifrk_name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifrsskey ) , "::" ,
                stringify ! ( ifrk_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifrsskey ) ) . ifrk_func as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ifrsskey ) , "::" ,
                stringify ! ( ifrk_func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifrsskey ) ) . ifrk_spare0 as * const _
                as usize } , 17usize , concat ! (
                "Alignment of field: " , stringify ! ( ifrsskey ) , "::" ,
                stringify ! ( ifrk_spare0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifrsskey ) ) . ifrk_keylen as * const _
                as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( ifrsskey ) , "::" ,
                stringify ! ( ifrk_keylen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifrsskey ) ) . ifrk_key as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( ifrsskey ) , "::" ,
                stringify ! ( ifrk_key ) ));
}
impl Clone for ifrsskey {
    fn clone(&self) -> Self { *self }
}
impl Default for ifrsskey {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for ifrsskey {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "ifrsskey {{ ifrk_name: {:?}, ifrk_func: {:?}, ifrk_spare0: {:?}, ifrk_keylen: {:?}, ifrk_key: [{}] }}"
               , self . ifrk_name , self . ifrk_func , self . ifrk_spare0 ,
               self . ifrk_keylen , self . ifrk_key . iter (  ) . enumerate (
               ) . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ))
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct ifrsshash {
    pub ifrh_name: [::kernel::sys::raw::c_char; 16usize],
    pub ifrh_func: u8,
    pub ifrh_spare0: u8,
    pub ifrh_spare1: u16,
    pub ifrh_types: u32,
}
#[test]
fn bindgen_test_layout_ifrsshash() {
    assert_eq!(::core::mem::size_of::<ifrsshash>() , 24usize , concat ! (
               "Size of: " , stringify ! ( ifrsshash ) ));
    assert_eq! (::core::mem::align_of::<ifrsshash>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( ifrsshash ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifrsshash ) ) . ifrh_name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifrsshash ) , "::" ,
                stringify ! ( ifrh_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifrsshash ) ) . ifrh_func as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ifrsshash ) , "::" ,
                stringify ! ( ifrh_func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifrsshash ) ) . ifrh_spare0 as * const _
                as usize } , 17usize , concat ! (
                "Alignment of field: " , stringify ! ( ifrsshash ) , "::" ,
                stringify ! ( ifrh_spare0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifrsshash ) ) . ifrh_spare1 as * const _
                as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( ifrsshash ) , "::" ,
                stringify ! ( ifrh_spare1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifrsshash ) ) . ifrh_types as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( ifrsshash ) , "::" ,
                stringify ! ( ifrh_types ) ));
}
impl Clone for ifrsshash {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rtentry {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_addrinfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct carp_if {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct carp_softc {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ifvlantrunk {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct route {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct vnet {
    pub vnet_le: vnet__bindgen_ty_1,
    pub vnet_magic_n: u_int,
    pub vnet_ifcnt: u_int,
    pub vnet_sockcnt: u_int,
    pub vnet_state: u_int,
    pub vnet_data_mem: *mut ::kernel::sys::raw::c_void,
    pub vnet_data_base: usize,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct vnet__bindgen_ty_1 {
    pub le_next: *mut vnet,
    pub le_prev: *mut *mut vnet,
}
#[test]
fn bindgen_test_layout_vnet__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<vnet__bindgen_ty_1>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( vnet__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<vnet__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( vnet__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vnet__bindgen_ty_1 ) ) . le_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( vnet__bindgen_ty_1 ) ,
                "::" , stringify ! ( le_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vnet__bindgen_ty_1 ) ) . le_prev as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( vnet__bindgen_ty_1 ) ,
                "::" , stringify ! ( le_prev ) ));
}
impl Clone for vnet__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for vnet__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_vnet() {
    assert_eq!(::core::mem::size_of::<vnet>() , 48usize , concat ! (
               "Size of: " , stringify ! ( vnet ) ));
    assert_eq! (::core::mem::align_of::<vnet>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( vnet ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vnet ) ) . vnet_le as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( vnet ) , "::" ,
                stringify ! ( vnet_le ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vnet ) ) . vnet_magic_n as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( vnet ) , "::" ,
                stringify ! ( vnet_magic_n ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vnet ) ) . vnet_ifcnt as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( vnet ) , "::" ,
                stringify ! ( vnet_ifcnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vnet ) ) . vnet_sockcnt as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( vnet ) , "::" ,
                stringify ! ( vnet_sockcnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vnet ) ) . vnet_state as * const _ as
                usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( vnet ) , "::" ,
                stringify ! ( vnet_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vnet ) ) . vnet_data_mem as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( vnet ) , "::" ,
                stringify ! ( vnet_data_mem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vnet ) ) . vnet_data_base as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( vnet ) , "::" ,
                stringify ! ( vnet_data_base ) ));
}
impl Clone for vnet {
    fn clone(&self) -> Self { *self }
}
impl Default for vnet {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifmedia {
    pub ifm_mask: ::kernel::sys::raw::c_int,
    pub ifm_media: ::kernel::sys::raw::c_int,
    pub ifm_cur: *mut ifmedia_entry,
    pub ifm_list: ifmedia__bindgen_ty_1,
    pub ifm_change: ifm_change_cb_t,
    pub ifm_status: ifm_stat_cb_t,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifmedia__bindgen_ty_1 {
    pub lh_first: *mut ifmedia_entry,
}
#[test]
fn bindgen_test_layout_ifmedia__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<ifmedia__bindgen_ty_1>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( ifmedia__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<ifmedia__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( ifmedia__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmedia__bindgen_ty_1 ) ) . lh_first as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmedia__bindgen_ty_1 )
                , "::" , stringify ! ( lh_first ) ));
}
impl Clone for ifmedia__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for ifmedia__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_ifmedia() {
    assert_eq!(::core::mem::size_of::<ifmedia>() , 40usize , concat ! (
               "Size of: " , stringify ! ( ifmedia ) ));
    assert_eq! (::core::mem::align_of::<ifmedia>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ifmedia ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmedia ) ) . ifm_mask as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmedia ) , "::" ,
                stringify ! ( ifm_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmedia ) ) . ifm_media as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmedia ) , "::" ,
                stringify ! ( ifm_media ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmedia ) ) . ifm_cur as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmedia ) , "::" ,
                stringify ! ( ifm_cur ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmedia ) ) . ifm_list as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmedia ) , "::" ,
                stringify ! ( ifm_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmedia ) ) . ifm_change as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmedia ) , "::" ,
                stringify ! ( ifm_change ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmedia ) ) . ifm_status as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmedia ) , "::" ,
                stringify ! ( ifm_status ) ));
}
impl Clone for ifmedia {
    fn clone(&self) -> Self { *self }
}
impl Default for ifmedia {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netmap_adapter {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netdump_methods {
    _unused: [u8; 0],
}
extern "C" {
    pub fn atomic_cmpset_char(dst: *mut u_char, expect: u_char, src: u_char)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn atomic_cmpset_short(dst: *mut u_short, expect: u_short,
                               src: u_short) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn atomic_cmpset_int(dst: *mut u_int, expect: u_int, src: u_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn atomic_cmpset_long(dst: *mut u_long, expect: u_long, src: u_long)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn atomic_fcmpset_char(dst: *mut u_char, expect: *mut u_char,
                               src: u_char) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn atomic_fcmpset_short(dst: *mut u_short, expect: *mut u_short,
                                src: u_short) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn atomic_fcmpset_int(dst: *mut u_int, expect: *mut u_int, src: u_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn atomic_fcmpset_long(dst: *mut u_long, expect: *mut u_long,
                               src: u_long) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn atomic_fetchadd_int(p: *mut u_int, v: u_int) -> u_int;
}
extern "C" {
    pub fn atomic_fetchadd_long(p: *mut u_long, v: u_long) -> u_long;
}
extern "C" {
    pub fn atomic_testandset_int(p: *mut u_int, v: u_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn atomic_testandset_long(p: *mut u_long, v: u_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn atomic_testandclear_int(p: *mut u_int, v: u_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn atomic_testandclear_long(p: *mut u_long, v: u_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn atomic_thread_fence_acq();
}
extern "C" {
    pub fn atomic_thread_fence_acq_rel();
}
extern "C" {
    pub fn atomic_thread_fence_rel();
}
extern "C" {
    pub fn atomic_thread_fence_seq_cst();
}
extern "C" {
    pub fn atomic_set_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_set_barr_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_clear_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_clear_barr_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_add_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_add_barr_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_subtract_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_subtract_barr_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_set_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_set_barr_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_clear_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_clear_barr_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_add_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_add_barr_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_subtract_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_subtract_barr_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_set_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_set_barr_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_clear_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_clear_barr_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_add_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_add_barr_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_subtract_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_subtract_barr_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_set_long(p: *mut u_long, v: u_long);
}
extern "C" {
    pub fn atomic_set_barr_long(p: *mut u_long, v: u_long);
}
extern "C" {
    pub fn atomic_clear_long(p: *mut u_long, v: u_long);
}
extern "C" {
    pub fn atomic_clear_barr_long(p: *mut u_long, v: u_long);
}
extern "C" {
    pub fn atomic_add_long(p: *mut u_long, v: u_long);
}
extern "C" {
    pub fn atomic_add_barr_long(p: *mut u_long, v: u_long);
}
extern "C" {
    pub fn atomic_subtract_long(p: *mut u_long, v: u_long);
}
extern "C" {
    pub fn atomic_subtract_barr_long(p: *mut u_long, v: u_long);
}
extern "C" {
    pub fn atomic_load_acq_char(p: *mut u_char) -> u_char;
}
extern "C" {
    pub fn atomic_store_rel_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_load_acq_short(p: *mut u_short) -> u_short;
}
extern "C" {
    pub fn atomic_store_rel_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_load_acq_int(p: *mut u_int) -> u_int;
}
extern "C" {
    pub fn atomic_store_rel_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_load_acq_long(p: *mut u_long) -> u_long;
}
extern "C" {
    pub fn atomic_store_rel_long(p: *mut u_long, v: u_long);
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy)]
pub struct region_descriptor {
    pub _bitfield_1: [u64; 2usize],
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_region_descriptor() {
    assert_eq!(::core::mem::size_of::<region_descriptor>() , 10usize , concat
               ! ( "Size of: " , stringify ! ( region_descriptor ) ));
    assert_eq! (::core::mem::align_of::<region_descriptor>() , 1usize , concat
                ! ( "Alignment of " , stringify ! ( region_descriptor ) ));
}
impl Clone for region_descriptor {
    fn clone(&self) -> Self { *self }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy)]
pub struct invpcid_descr {
    pub _bitfield_1: u64,
    pub addr: u64,
}
#[test]
fn bindgen_test_layout_invpcid_descr() {
    assert_eq!(::core::mem::size_of::<invpcid_descr>() , 16usize , concat ! (
               "Size of: " , stringify ! ( invpcid_descr ) ));
    assert_eq! (::core::mem::align_of::<invpcid_descr>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( invpcid_descr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const invpcid_descr ) ) . addr as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( invpcid_descr ) , "::"
                , stringify ! ( addr ) ));
}
impl Clone for invpcid_descr {
    fn clone(&self) -> Self { *self }
}
impl invpcid_descr {
    #[inline]
    pub fn pcid(&self) -> u64 {
        let mut unit_field_val: u64 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u64
                                                 as *mut u8,
                                             ::core::mem::size_of::<u64>())
        };
        let mask = 4095u64 as u64;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::core::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_pcid(&mut self, val: u64) {
        let mask = 4095u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u64
                                                 as *mut u8,
                                             ::core::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn pad(&self) -> u64 {
        let mut unit_field_val: u64 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u64
                                                 as *mut u8,
                                             ::core::mem::size_of::<u64>())
        };
        let mask = 18446744073709547520u64 as u64;
        let val = (unit_field_val & mask) >> 12usize;
        unsafe { ::core::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_pad(&mut self, val: u64) {
        let mask = 18446744073709547520u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u64
                                                 as *mut u8,
                                             ::core::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 12usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(pcid: u64, pad: u64) -> u64 {
        ({ ({ 0 } | ((pcid as u64 as u64) << 0usize) & (4095u64 as u64)) } |
             ((pad as u64 as u64) << 12usize) &
                 (18446744073709547520u64 as u64))
    }
}
pub const SGX_ECREATE: _bindgen_ty_1 = _bindgen_ty_1::SGX_ECREATE;
pub const SGX_EADD: _bindgen_ty_1 = _bindgen_ty_1::SGX_EADD;
pub const SGX_EINIT: _bindgen_ty_1 = _bindgen_ty_1::SGX_EINIT;
pub const SGX_EREMOVE: _bindgen_ty_1 = _bindgen_ty_1::SGX_EREMOVE;
pub const SGX_EDGBRD: _bindgen_ty_1 = _bindgen_ty_1::SGX_EDGBRD;
pub const SGX_EDGBWR: _bindgen_ty_1 = _bindgen_ty_1::SGX_EDGBWR;
pub const SGX_EEXTEND: _bindgen_ty_1 = _bindgen_ty_1::SGX_EEXTEND;
pub const SGX_ELDU: _bindgen_ty_1 = _bindgen_ty_1::SGX_ELDU;
pub const SGX_EBLOCK: _bindgen_ty_1 = _bindgen_ty_1::SGX_EBLOCK;
pub const SGX_EPA: _bindgen_ty_1 = _bindgen_ty_1::SGX_EPA;
pub const SGX_EWB: _bindgen_ty_1 = _bindgen_ty_1::SGX_EWB;
pub const SGX_ETRACK: _bindgen_ty_1 = _bindgen_ty_1::SGX_ETRACK;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_1 {
    SGX_ECREATE = 0,
    SGX_EADD = 1,
    SGX_EINIT = 2,
    SGX_EREMOVE = 3,
    SGX_EDGBRD = 4,
    SGX_EDGBWR = 5,
    SGX_EEXTEND = 6,
    SGX_ELDU = 8,
    SGX_EBLOCK = 9,
    SGX_EPA = 10,
    SGX_EWB = 11,
    SGX_ETRACK = 12,
}
pub const SGX_PT_SECS: _bindgen_ty_2 = _bindgen_ty_2::SGX_PT_SECS;
pub const SGX_PT_TCS: _bindgen_ty_2 = _bindgen_ty_2::SGX_PT_TCS;
pub const SGX_PT_REG: _bindgen_ty_2 = _bindgen_ty_2::SGX_PT_REG;
pub const SGX_PT_VA: _bindgen_ty_2 = _bindgen_ty_2::SGX_PT_VA;
pub const SGX_PT_TRIM: _bindgen_ty_2 = _bindgen_ty_2::SGX_PT_TRIM;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_2 {
    SGX_PT_SECS = 0,
    SGX_PT_TCS = 1,
    SGX_PT_REG = 2,
    SGX_PT_VA = 3,
    SGX_PT_TRIM = 4,
}
extern "C" {
    pub fn sgx_encls(eax: u32, rbx: u64, rcx: u64, rdx: u64)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn reset_dbregs();
}
extern "C" {
    pub fn rdmsr_safe(msr: u_int, val: *mut u64) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn wrmsr_safe(msr: u_int, newval: u64) -> ::kernel::sys::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lock_object {
    pub lo_name: *const ::kernel::sys::raw::c_char,
    pub lo_flags: u_int,
    pub lo_data: u_int,
    pub lo_witness: *mut witness,
}
#[test]
fn bindgen_test_layout_lock_object() {
    assert_eq!(::core::mem::size_of::<lock_object>() , 24usize , concat ! (
               "Size of: " , stringify ! ( lock_object ) ));
    assert_eq! (::core::mem::align_of::<lock_object>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lock_object ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_object ) ) . lo_name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_object ) , "::" ,
                stringify ! ( lo_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_object ) ) . lo_flags as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_object ) , "::" ,
                stringify ! ( lo_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_object ) ) . lo_data as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_object ) , "::" ,
                stringify ! ( lo_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_object ) ) . lo_witness as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_object ) , "::" ,
                stringify ! ( lo_witness ) ));
}
impl Clone for lock_object {
    fn clone(&self) -> Self { *self }
}
impl Default for lock_object {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct callout_list {
    pub lh_first: *mut callout,
}
#[test]
fn bindgen_test_layout_callout_list() {
    assert_eq!(::core::mem::size_of::<callout_list>() , 8usize , concat ! (
               "Size of: " , stringify ! ( callout_list ) ));
    assert_eq! (::core::mem::align_of::<callout_list>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( callout_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout_list ) ) . lh_first as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( callout_list ) , "::" ,
                stringify ! ( lh_first ) ));
}
impl Clone for callout_list {
    fn clone(&self) -> Self { *self }
}
impl Default for callout_list {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct callout_slist {
    pub slh_first: *mut callout,
}
#[test]
fn bindgen_test_layout_callout_slist() {
    assert_eq!(::core::mem::size_of::<callout_slist>() , 8usize , concat ! (
               "Size of: " , stringify ! ( callout_slist ) ));
    assert_eq! (::core::mem::align_of::<callout_slist>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( callout_slist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout_slist ) ) . slh_first as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( callout_slist ) , "::"
                , stringify ! ( slh_first ) ));
}
impl Clone for callout_slist {
    fn clone(&self) -> Self { *self }
}
impl Default for callout_slist {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct callout_tailq {
    pub tqh_first: *mut callout,
    pub tqh_last: *mut *mut callout,
}
#[test]
fn bindgen_test_layout_callout_tailq() {
    assert_eq!(::core::mem::size_of::<callout_tailq>() , 16usize , concat ! (
               "Size of: " , stringify ! ( callout_tailq ) ));
    assert_eq! (::core::mem::align_of::<callout_tailq>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( callout_tailq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout_tailq ) ) . tqh_first as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( callout_tailq ) , "::"
                , stringify ! ( tqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout_tailq ) ) . tqh_last as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( callout_tailq ) , "::"
                , stringify ! ( tqh_last ) ));
}
impl Clone for callout_tailq {
    fn clone(&self) -> Self { *self }
}
impl Default for callout_tailq {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct callout {
    pub c_links: callout__bindgen_ty_1,
    pub c_time: sbintime_t,
    pub c_precision: sbintime_t,
    pub c_arg: *mut ::kernel::sys::raw::c_void,
    pub c_func: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                *mut ::kernel::sys::raw::c_void)>,
    pub c_lock: *mut lock_object,
    pub c_flags: ::kernel::sys::raw::c_short,
    pub c_iflags: ::kernel::sys::raw::c_short,
    pub c_cpu: ::kernel::sys::raw::c_int,
}
#[repr(C)]
#[derive(Copy)]
pub union callout__bindgen_ty_1 {
    pub le: callout__bindgen_ty_1__bindgen_ty_1,
    pub sle: callout__bindgen_ty_1__bindgen_ty_2,
    pub tqe: callout__bindgen_ty_1__bindgen_ty_3,
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct callout__bindgen_ty_1__bindgen_ty_1 {
    pub le_next: *mut callout,
    pub le_prev: *mut *mut callout,
}
#[test]
fn bindgen_test_layout_callout__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<callout__bindgen_ty_1__bindgen_ty_1>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( callout__bindgen_ty_1__bindgen_ty_1
               ) ));
    assert_eq! (::core::mem::align_of::<callout__bindgen_ty_1__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                callout__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout__bindgen_ty_1__bindgen_ty_1 ) ) .
                le_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                callout__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! (
                le_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout__bindgen_ty_1__bindgen_ty_1 ) ) .
                le_prev as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                callout__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! (
                le_prev ) ));
}
impl Clone for callout__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for callout__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct callout__bindgen_ty_1__bindgen_ty_2 {
    pub sle_next: *mut callout,
}
#[test]
fn bindgen_test_layout_callout__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<callout__bindgen_ty_1__bindgen_ty_2>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( callout__bindgen_ty_1__bindgen_ty_2
               ) ));
    assert_eq! (::core::mem::align_of::<callout__bindgen_ty_1__bindgen_ty_2>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                callout__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout__bindgen_ty_1__bindgen_ty_2 ) ) .
                sle_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                callout__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify ! (
                sle_next ) ));
}
impl Clone for callout__bindgen_ty_1__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for callout__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct callout__bindgen_ty_1__bindgen_ty_3 {
    pub tqe_next: *mut callout,
    pub tqe_prev: *mut *mut callout,
}
#[test]
fn bindgen_test_layout_callout__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(::core::mem::size_of::<callout__bindgen_ty_1__bindgen_ty_3>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( callout__bindgen_ty_1__bindgen_ty_3
               ) ));
    assert_eq! (::core::mem::align_of::<callout__bindgen_ty_1__bindgen_ty_3>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                callout__bindgen_ty_1__bindgen_ty_3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout__bindgen_ty_1__bindgen_ty_3 ) ) .
                tqe_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                callout__bindgen_ty_1__bindgen_ty_3 ) , "::" , stringify ! (
                tqe_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout__bindgen_ty_1__bindgen_ty_3 ) ) .
                tqe_prev as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                callout__bindgen_ty_1__bindgen_ty_3 ) , "::" , stringify ! (
                tqe_prev ) ));
}
impl Clone for callout__bindgen_ty_1__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
impl Default for callout__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_callout__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<callout__bindgen_ty_1>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( callout__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<callout__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( callout__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout__bindgen_ty_1 ) ) . le as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( callout__bindgen_ty_1 )
                , "::" , stringify ! ( le ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout__bindgen_ty_1 ) ) . sle as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( callout__bindgen_ty_1 )
                , "::" , stringify ! ( sle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout__bindgen_ty_1 ) ) . tqe as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( callout__bindgen_ty_1 )
                , "::" , stringify ! ( tqe ) ));
}
impl Clone for callout__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for callout__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for callout__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "callout__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_callout() {
    assert_eq!(::core::mem::size_of::<callout>() , 64usize , concat ! (
               "Size of: " , stringify ! ( callout ) ));
    assert_eq! (::core::mem::align_of::<callout>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( callout ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout ) ) . c_links as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( callout ) , "::" ,
                stringify ! ( c_links ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout ) ) . c_time as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( callout ) , "::" ,
                stringify ! ( c_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout ) ) . c_precision as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( callout ) , "::" ,
                stringify ! ( c_precision ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout ) ) . c_arg as * const _ as usize
                } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( callout ) , "::" ,
                stringify ! ( c_arg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout ) ) . c_func as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( callout ) , "::" ,
                stringify ! ( c_func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout ) ) . c_lock as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( callout ) , "::" ,
                stringify ! ( c_lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout ) ) . c_flags as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( callout ) , "::" ,
                stringify ! ( c_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout ) ) . c_iflags as * const _ as
                usize } , 58usize , concat ! (
                "Alignment of field: " , stringify ! ( callout ) , "::" ,
                stringify ! ( c_iflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout ) ) . c_cpu as * const _ as usize
                } , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( callout ) , "::" ,
                stringify ! ( c_cpu ) ));
}
impl Clone for callout {
    fn clone(&self) -> Self { *self }
}
impl Default for callout {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for callout {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "callout {{ c_links: {:?}, c_time: {:?}, c_precision: {:?}, c_arg: {:?}, c_func: {:?}, c_lock: {:?}, c_flags: {:?}, c_iflags: {:?}, c_cpu: {:?} }}"
               , self . c_links , self . c_time , self . c_precision , self .
               c_arg , self . c_func , self . c_lock , self . c_flags , self .
               c_iflags , self . c_cpu)
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct callout_handle {
    pub callout: *mut callout,
}
#[test]
fn bindgen_test_layout_callout_handle() {
    assert_eq!(::core::mem::size_of::<callout_handle>() , 8usize , concat ! (
               "Size of: " , stringify ! ( callout_handle ) ));
    assert_eq! (::core::mem::align_of::<callout_handle>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( callout_handle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout_handle ) ) . callout as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( callout_handle ) , "::"
                , stringify ! ( callout ) ));
}
impl Clone for callout_handle {
    fn clone(&self) -> Self { *self }
}
impl Default for callout_handle {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    pub fn callout_init(arg1: *mut callout, arg2: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn _callout_init_lock(arg1: *mut callout, arg2: *mut lock_object,
                              arg3: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn callout_reset_sbt_on(arg1: *mut callout, arg2: sbintime_t,
                                arg3: sbintime_t,
                                arg4:
                                    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                                    *mut ::kernel::sys::raw::c_void)>,
                                arg5: *mut ::kernel::sys::raw::c_void,
                                arg6: ::kernel::sys::raw::c_int,
                                arg7: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn callout_schedule(arg1: *mut callout,
                            arg2: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn callout_schedule_on(arg1: *mut callout,
                               arg2: ::kernel::sys::raw::c_int,
                               arg3: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn _callout_stop_safe(arg1: *mut callout,
                              arg2: ::kernel::sys::raw::c_int,
                              arg3:
                                  ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                                  *mut ::kernel::sys::raw::c_void)>)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn callout_process(now: sbintime_t);
}
extern "C" {
    pub fn callout_when(sbt: sbintime_t, precision: sbintime_t,
                        flags: ::kernel::sys::raw::c_int,
                        sbt_res: *mut sbintime_t, prec_res: *mut sbintime_t);
}
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = __int_fast8_t;
pub type int_fast16_t = __int_fast16_t;
pub type int_fast32_t = __int_fast32_t;
pub type int_fast64_t = __int_fast64_t;
pub type uint_fast8_t = __uint_fast8_t;
pub type uint_fast16_t = __uint_fast16_t;
pub type uint_fast32_t = __uint_fast32_t;
pub type uint_fast64_t = __uint_fast64_t;
extern "C" {
    #[link_name = "cold"]
    pub static mut cold: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "suspend_blocked"]
    pub static mut suspend_blocked: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "rebooting"]
    pub static mut rebooting: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "panicstr"]
    pub static mut panicstr: *const ::kernel::sys::raw::c_char;
}
extern "C" {
    #[link_name = "version"]
    pub static mut version: [::kernel::sys::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "compiler_version"]
    pub static mut compiler_version: [::kernel::sys::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "copyright"]
    pub static mut copyright: [::kernel::sys::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "kstack_pages"]
    pub static mut kstack_pages: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "pagesizes"]
    pub static mut pagesizes: [u_long; 0usize];
}
extern "C" {
    #[link_name = "physmem"]
    pub static mut physmem: ::kernel::sys::raw::c_long;
}
extern "C" {
    #[link_name = "realmem"]
    pub static mut realmem: ::kernel::sys::raw::c_long;
}
extern "C" {
    #[link_name = "rootdevnames"]
    pub static mut rootdevnames: [*mut ::kernel::sys::raw::c_char; 2usize];
}
extern "C" {
    #[link_name = "boothowto"]
    pub static mut boothowto: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "bootverbose"]
    pub static mut bootverbose: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "maxusers"]
    pub static mut maxusers: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "ngroups_max"]
    pub static mut ngroups_max: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "vm_guest"]
    pub static mut vm_guest: ::kernel::sys::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VM_GUEST {
    VM_GUEST_NO = 0,
    VM_GUEST_VM = 1,
    VM_GUEST_XEN = 2,
    VM_GUEST_HV = 3,
    VM_GUEST_VMWARE = 4,
    VM_GUEST_KVM = 5,
    VM_GUEST_BHYVE = 6,
    VM_LAST = 7,
}
extern "C" {
    #[link_name = "osreldate"]
    pub static mut osreldate: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "envmode"]
    pub static mut envmode: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "hintmode"]
    pub static mut hintmode: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "dynamic_kenv"]
    pub static mut dynamic_kenv: ::kernel::sys::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mtx {
    pub lock_object: lock_object,
    pub mtx_lock: usize,
}
#[test]
fn bindgen_test_layout_mtx() {
    assert_eq!(::core::mem::size_of::<mtx>() , 32usize , concat ! (
               "Size of: " , stringify ! ( mtx ) ));
    assert_eq! (::core::mem::align_of::<mtx>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( mtx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mtx ) ) . lock_object as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mtx ) , "::" ,
                stringify ! ( lock_object ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mtx ) ) . mtx_lock as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( mtx ) , "::" ,
                stringify ! ( mtx_lock ) ));
}
impl Clone for mtx {
    fn clone(&self) -> Self { *self }
}
impl Default for mtx {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    #[link_name = "kenv_lock"]
    pub static mut kenv_lock: mtx;
}
extern "C" {
    #[link_name = "kern_envp"]
    pub static mut kern_envp: *mut ::kernel::sys::raw::c_char;
}
extern "C" {
    #[link_name = "static_env"]
    pub static mut static_env: [::kernel::sys::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "static_hints"]
    pub static mut static_hints: [::kernel::sys::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "kenvp"]
    pub static mut kenvp: *mut *mut ::kernel::sys::raw::c_char;
}
extern "C" {
    #[link_name = "zero_region"]
    pub static mut zero_region: *const ::kernel::sys::raw::c_void;
}
extern "C" {
    #[link_name = "unmapped_buf_allowed"]
    pub static mut unmapped_buf_allowed: ::kernel::sys::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct malloc_type {
    pub ks_next: *mut malloc_type,
    pub ks_magic: u_long,
    pub ks_shortdesc: *const ::kernel::sys::raw::c_char,
    pub ks_handle: *mut ::kernel::sys::raw::c_void,
}
#[test]
fn bindgen_test_layout_malloc_type() {
    assert_eq!(::core::mem::size_of::<malloc_type>() , 32usize , concat ! (
               "Size of: " , stringify ! ( malloc_type ) ));
    assert_eq! (::core::mem::align_of::<malloc_type>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( malloc_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type ) ) . ks_next as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_type ) , "::" ,
                stringify ! ( ks_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type ) ) . ks_magic as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_type ) , "::" ,
                stringify ! ( ks_magic ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type ) ) . ks_shortdesc as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_type ) , "::" ,
                stringify ! ( ks_shortdesc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type ) ) . ks_handle as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_type ) , "::" ,
                stringify ! ( ks_handle ) ));
}
impl Clone for malloc_type {
    fn clone(&self) -> Self { *self }
}
impl Default for malloc_type {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct proc_ {
    pub p_list: proc__bindgen_ty_1,
    pub p_threads: proc__bindgen_ty_2,
    pub p_slock: mtx,
    pub p_ucred: *mut ucred,
    pub p_fd: *mut filedesc,
    pub p_fdtol: *mut filedesc_to_leader,
    pub p_stats: *mut pstats,
    pub p_limit: *mut plimit,
    pub p_limco: callout,
    pub p_sigacts: *mut sigacts,
    pub p_flag: ::kernel::sys::raw::c_int,
    pub p_flag2: ::kernel::sys::raw::c_int,
    pub p_state: proc__bindgen_ty_3,
    pub p_pid: pid_t,
    pub p_hash: proc__bindgen_ty_4,
    pub p_pglist: proc__bindgen_ty_5,
    pub p_pptr: *mut proc_,
    pub p_sibling: proc__bindgen_ty_6,
    pub p_children: proc__bindgen_ty_7,
    pub p_reaper: *mut proc_,
    pub p_reaplist: proc__bindgen_ty_8,
    pub p_reapsibling: proc__bindgen_ty_9,
    pub p_mtx: mtx,
    pub p_statmtx: mtx,
    pub p_itimmtx: mtx,
    pub p_profmtx: mtx,
    pub p_ksi: *mut ksiginfo,
    pub p_sigqueue: sigqueue_t,
    pub p_oppid: pid_t,
    pub p_vmspace: *mut vmspace,
    pub p_swtick: u_int,
    pub p_cowgen: u_int,
    pub p_realtimer: itimerval,
    pub p_ru: rusage,
    pub p_rux: rusage_ext,
    pub p_crux: rusage_ext,
    pub p_profthreads: ::kernel::sys::raw::c_int,
    pub p_exitthreads: ::kernel::sys::raw::c_int,
    pub p_traceflag: ::kernel::sys::raw::c_int,
    pub p_tracevp: *mut vnode,
    pub p_tracecred: *mut ucred,
    pub p_textvp: *mut vnode,
    pub p_lock: u_int,
    pub p_sigiolst: sigiolst,
    pub p_sigparent: ::kernel::sys::raw::c_int,
    pub p_sig: ::kernel::sys::raw::c_int,
    pub p_code: u_long,
    pub p_stops: u_int,
    pub p_stype: u_int,
    pub p_step: ::kernel::sys::raw::c_char,
    pub p_pfsflags: u_char,
    pub p_ptevents: u_int,
    pub p_nlminfo: *mut nlminfo,
    pub p_aioinfo: *mut kaioinfo,
    pub p_singlethread: *mut thread,
    pub p_suspcount: ::kernel::sys::raw::c_int,
    pub p_xthread: *mut thread,
    pub p_boundary_count: ::kernel::sys::raw::c_int,
    pub p_pendingcnt: ::kernel::sys::raw::c_int,
    pub p_itimers: *mut itimers,
    pub p_procdesc: *mut procdesc,
    pub p_treeflag: u_int,
    pub p_pendingexits: ::kernel::sys::raw::c_int,
    pub p_filemon: *mut filemon,
    pub p_pdeathsig: ::kernel::sys::raw::c_int,
    pub p_magic: u_int,
    pub p_osrel: ::kernel::sys::raw::c_int,
    pub p_comm: [::kernel::sys::raw::c_char; 20usize],
    pub p_sysent: *mut sysentvec,
    pub p_args: *mut pargs,
    pub p_cpulimit: rlim_t,
    pub p_nice: ::kernel::sys::raw::c_schar,
    pub p_fibnum: ::kernel::sys::raw::c_int,
    pub p_reapsubtree: pid_t,
    pub p_elf_machine: u16,
    pub p_elf_flags: u64,
    pub p_xexit: u_int,
    pub p_xsig: u_int,
    pub p_pgrp: *mut pgrp,
    pub p_klist: *mut knlist,
    pub p_numthreads: ::kernel::sys::raw::c_int,
    pub p_md: mdproc,
    pub p_itcallout: callout,
    pub p_acflag: u_short,
    pub p_peers: *mut proc_,
    pub p_leader: *mut proc_,
    pub p_emuldata: *mut ::kernel::sys::raw::c_void,
    pub p_label: *mut label,
    pub p_ktr: proc__bindgen_ty_10,
    pub p_mqnotifier: proc__bindgen_ty_11,
    pub p_dtrace: *mut kdtrace_proc,
    pub p_pwait: cv,
    pub p_dbgwait: cv,
    pub p_prev_runtime: u64,
    pub p_racct: *mut racct,
    pub p_throttled: ::kernel::sys::raw::c_int,
    pub p_orphan: proc__bindgen_ty_12,
    pub p_orphans: proc__bindgen_ty_13,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct proc__bindgen_ty_1 {
    pub le_next: *mut proc_,
    pub le_prev: *mut *mut proc_,
}
#[test]
fn bindgen_test_layout_proc__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<proc__bindgen_ty_1>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( proc__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<proc__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( proc__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc__bindgen_ty_1 ) ) . le_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( proc__bindgen_ty_1 ) ,
                "::" , stringify ! ( le_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc__bindgen_ty_1 ) ) . le_prev as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( proc__bindgen_ty_1 ) ,
                "::" , stringify ! ( le_prev ) ));
}
impl Clone for proc__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for proc__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct proc__bindgen_ty_2 {
    pub tqh_first: *mut thread,
    pub tqh_last: *mut *mut thread,
}
#[test]
fn bindgen_test_layout_proc__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<proc__bindgen_ty_2>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( proc__bindgen_ty_2 ) ));
    assert_eq! (::core::mem::align_of::<proc__bindgen_ty_2>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( proc__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc__bindgen_ty_2 ) ) . tqh_first as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( proc__bindgen_ty_2 ) ,
                "::" , stringify ! ( tqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc__bindgen_ty_2 ) ) . tqh_last as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( proc__bindgen_ty_2 ) ,
                "::" , stringify ! ( tqh_last ) ));
}
impl Clone for proc__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for proc__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub const proc__PRS_NEW: proc__bindgen_ty_3 = proc__bindgen_ty_3::PRS_NEW;
pub const proc__PRS_NORMAL: proc__bindgen_ty_3 =
    proc__bindgen_ty_3::PRS_NORMAL;
pub const proc__PRS_ZOMBIE: proc__bindgen_ty_3 =
    proc__bindgen_ty_3::PRS_ZOMBIE;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum proc__bindgen_ty_3 { PRS_NEW = 0, PRS_NORMAL = 1, PRS_ZOMBIE = 2, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct proc__bindgen_ty_4 {
    pub le_next: *mut proc_,
    pub le_prev: *mut *mut proc_,
}
#[test]
fn bindgen_test_layout_proc__bindgen_ty_4() {
    assert_eq!(::core::mem::size_of::<proc__bindgen_ty_4>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( proc__bindgen_ty_4 ) ));
    assert_eq! (::core::mem::align_of::<proc__bindgen_ty_4>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( proc__bindgen_ty_4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc__bindgen_ty_4 ) ) . le_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( proc__bindgen_ty_4 ) ,
                "::" , stringify ! ( le_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc__bindgen_ty_4 ) ) . le_prev as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( proc__bindgen_ty_4 ) ,
                "::" , stringify ! ( le_prev ) ));
}
impl Clone for proc__bindgen_ty_4 {
    fn clone(&self) -> Self { *self }
}
impl Default for proc__bindgen_ty_4 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct proc__bindgen_ty_5 {
    pub le_next: *mut proc_,
    pub le_prev: *mut *mut proc_,
}
#[test]
fn bindgen_test_layout_proc__bindgen_ty_5() {
    assert_eq!(::core::mem::size_of::<proc__bindgen_ty_5>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( proc__bindgen_ty_5 ) ));
    assert_eq! (::core::mem::align_of::<proc__bindgen_ty_5>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( proc__bindgen_ty_5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc__bindgen_ty_5 ) ) . le_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( proc__bindgen_ty_5 ) ,
                "::" , stringify ! ( le_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc__bindgen_ty_5 ) ) . le_prev as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( proc__bindgen_ty_5 ) ,
                "::" , stringify ! ( le_prev ) ));
}
impl Clone for proc__bindgen_ty_5 {
    fn clone(&self) -> Self { *self }
}
impl Default for proc__bindgen_ty_5 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct proc__bindgen_ty_6 {
    pub le_next: *mut proc_,
    pub le_prev: *mut *mut proc_,
}
#[test]
fn bindgen_test_layout_proc__bindgen_ty_6() {
    assert_eq!(::core::mem::size_of::<proc__bindgen_ty_6>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( proc__bindgen_ty_6 ) ));
    assert_eq! (::core::mem::align_of::<proc__bindgen_ty_6>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( proc__bindgen_ty_6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc__bindgen_ty_6 ) ) . le_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( proc__bindgen_ty_6 ) ,
                "::" , stringify ! ( le_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc__bindgen_ty_6 ) ) . le_prev as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( proc__bindgen_ty_6 ) ,
                "::" , stringify ! ( le_prev ) ));
}
impl Clone for proc__bindgen_ty_6 {
    fn clone(&self) -> Self { *self }
}
impl Default for proc__bindgen_ty_6 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct proc__bindgen_ty_7 {
    pub lh_first: *mut proc_,
}
#[test]
fn bindgen_test_layout_proc__bindgen_ty_7() {
    assert_eq!(::core::mem::size_of::<proc__bindgen_ty_7>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( proc__bindgen_ty_7 ) ));
    assert_eq! (::core::mem::align_of::<proc__bindgen_ty_7>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( proc__bindgen_ty_7 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc__bindgen_ty_7 ) ) . lh_first as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( proc__bindgen_ty_7 ) ,
                "::" , stringify ! ( lh_first ) ));
}
impl Clone for proc__bindgen_ty_7 {
    fn clone(&self) -> Self { *self }
}
impl Default for proc__bindgen_ty_7 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct proc__bindgen_ty_8 {
    pub lh_first: *mut proc_,
}
#[test]
fn bindgen_test_layout_proc__bindgen_ty_8() {
    assert_eq!(::core::mem::size_of::<proc__bindgen_ty_8>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( proc__bindgen_ty_8 ) ));
    assert_eq! (::core::mem::align_of::<proc__bindgen_ty_8>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( proc__bindgen_ty_8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc__bindgen_ty_8 ) ) . lh_first as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( proc__bindgen_ty_8 ) ,
                "::" , stringify ! ( lh_first ) ));
}
impl Clone for proc__bindgen_ty_8 {
    fn clone(&self) -> Self { *self }
}
impl Default for proc__bindgen_ty_8 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct proc__bindgen_ty_9 {
    pub le_next: *mut proc_,
    pub le_prev: *mut *mut proc_,
}
#[test]
fn bindgen_test_layout_proc__bindgen_ty_9() {
    assert_eq!(::core::mem::size_of::<proc__bindgen_ty_9>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( proc__bindgen_ty_9 ) ));
    assert_eq! (::core::mem::align_of::<proc__bindgen_ty_9>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( proc__bindgen_ty_9 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc__bindgen_ty_9 ) ) . le_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( proc__bindgen_ty_9 ) ,
                "::" , stringify ! ( le_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc__bindgen_ty_9 ) ) . le_prev as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( proc__bindgen_ty_9 ) ,
                "::" , stringify ! ( le_prev ) ));
}
impl Clone for proc__bindgen_ty_9 {
    fn clone(&self) -> Self { *self }
}
impl Default for proc__bindgen_ty_9 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct proc__bindgen_ty_10 {
    pub stqh_first: *mut ktr_request,
    pub stqh_last: *mut *mut ktr_request,
}
#[test]
fn bindgen_test_layout_proc__bindgen_ty_10() {
    assert_eq!(::core::mem::size_of::<proc__bindgen_ty_10>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( proc__bindgen_ty_10 )
               ));
    assert_eq! (::core::mem::align_of::<proc__bindgen_ty_10>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( proc__bindgen_ty_10 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc__bindgen_ty_10 ) ) . stqh_first as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( proc__bindgen_ty_10 ) ,
                "::" , stringify ! ( stqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc__bindgen_ty_10 ) ) . stqh_last as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( proc__bindgen_ty_10 ) ,
                "::" , stringify ! ( stqh_last ) ));
}
impl Clone for proc__bindgen_ty_10 {
    fn clone(&self) -> Self { *self }
}
impl Default for proc__bindgen_ty_10 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct proc__bindgen_ty_11 {
    pub lh_first: *mut mqueue_notifier,
}
#[test]
fn bindgen_test_layout_proc__bindgen_ty_11() {
    assert_eq!(::core::mem::size_of::<proc__bindgen_ty_11>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( proc__bindgen_ty_11 ) ));
    assert_eq! (::core::mem::align_of::<proc__bindgen_ty_11>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( proc__bindgen_ty_11 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc__bindgen_ty_11 ) ) . lh_first as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( proc__bindgen_ty_11 ) ,
                "::" , stringify ! ( lh_first ) ));
}
impl Clone for proc__bindgen_ty_11 {
    fn clone(&self) -> Self { *self }
}
impl Default for proc__bindgen_ty_11 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct proc__bindgen_ty_12 {
    pub le_next: *mut proc_,
    pub le_prev: *mut *mut proc_,
}
#[test]
fn bindgen_test_layout_proc__bindgen_ty_12() {
    assert_eq!(::core::mem::size_of::<proc__bindgen_ty_12>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( proc__bindgen_ty_12 )
               ));
    assert_eq! (::core::mem::align_of::<proc__bindgen_ty_12>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( proc__bindgen_ty_12 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc__bindgen_ty_12 ) ) . le_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( proc__bindgen_ty_12 ) ,
                "::" , stringify ! ( le_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc__bindgen_ty_12 ) ) . le_prev as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( proc__bindgen_ty_12 ) ,
                "::" , stringify ! ( le_prev ) ));
}
impl Clone for proc__bindgen_ty_12 {
    fn clone(&self) -> Self { *self }
}
impl Default for proc__bindgen_ty_12 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct proc__bindgen_ty_13 {
    pub lh_first: *mut proc_,
}
#[test]
fn bindgen_test_layout_proc__bindgen_ty_13() {
    assert_eq!(::core::mem::size_of::<proc__bindgen_ty_13>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( proc__bindgen_ty_13 ) ));
    assert_eq! (::core::mem::align_of::<proc__bindgen_ty_13>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( proc__bindgen_ty_13 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc__bindgen_ty_13 ) ) . lh_first as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( proc__bindgen_ty_13 ) ,
                "::" , stringify ! ( lh_first ) ));
}
impl Clone for proc__bindgen_ty_13 {
    fn clone(&self) -> Self { *self }
}
impl Default for proc__bindgen_ty_13 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_proc_() {
    assert_eq!(::core::mem::size_of::<proc_>() , 1336usize , concat ! (
               "Size of: " , stringify ! ( proc_ ) ));
    assert_eq! (::core::mem::align_of::<proc_>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( proc_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_list as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_threads as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_threads ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_slock as * const _ as usize
                } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_slock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_ucred as * const _ as usize
                } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_ucred ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_fd as * const _ as usize }
                , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_fd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_fdtol as * const _ as usize
                } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_fdtol ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_stats as * const _ as usize
                } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_stats ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_limit as * const _ as usize
                } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_limit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_limco as * const _ as usize
                } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_limco ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_sigacts as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_sigacts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_flag as * const _ as usize
                } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_flag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_flag2 as * const _ as usize
                } , 180usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_flag2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_state as * const _ as usize
                } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_pid as * const _ as usize }
                , 188usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_pid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_hash as * const _ as usize
                } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_hash ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_pglist as * const _ as
                usize } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_pglist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_pptr as * const _ as usize
                } , 224usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_pptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_sibling as * const _ as
                usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_sibling ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_children as * const _ as
                usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_children ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_reaper as * const _ as
                usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_reaper ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_reaplist as * const _ as
                usize } , 264usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_reaplist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_reapsibling as * const _ as
                usize } , 272usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_reapsibling ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_mtx as * const _ as usize }
                , 288usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_mtx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_statmtx as * const _ as
                usize } , 320usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_statmtx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_itimmtx as * const _ as
                usize } , 352usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_itimmtx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_profmtx as * const _ as
                usize } , 384usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_profmtx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_ksi as * const _ as usize }
                , 416usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_ksi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_sigqueue as * const _ as
                usize } , 424usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_sigqueue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_oppid as * const _ as usize
                } , 504usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_oppid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_vmspace as * const _ as
                usize } , 512usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_vmspace ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_swtick as * const _ as
                usize } , 520usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_swtick ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_cowgen as * const _ as
                usize } , 524usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_cowgen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_realtimer as * const _ as
                usize } , 528usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_realtimer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_ru as * const _ as usize }
                , 560usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_ru ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_rux as * const _ as usize }
                , 704usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_rux ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_crux as * const _ as usize
                } , 760usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_crux ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_profthreads as * const _ as
                usize } , 816usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_profthreads ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_exitthreads as * const _ as
                usize } , 820usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_exitthreads ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_traceflag as * const _ as
                usize } , 824usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_traceflag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_tracevp as * const _ as
                usize } , 832usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_tracevp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_tracecred as * const _ as
                usize } , 840usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_tracecred ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_textvp as * const _ as
                usize } , 848usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_textvp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_lock as * const _ as usize
                } , 856usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_sigiolst as * const _ as
                usize } , 864usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_sigiolst ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_sigparent as * const _ as
                usize } , 872usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_sigparent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_sig as * const _ as usize }
                , 876usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_code as * const _ as usize
                } , 880usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_code ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_stops as * const _ as usize
                } , 888usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_stops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_stype as * const _ as usize
                } , 892usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_stype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_step as * const _ as usize
                } , 896usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_step ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_pfsflags as * const _ as
                usize } , 897usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_pfsflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_ptevents as * const _ as
                usize } , 900usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_ptevents ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_nlminfo as * const _ as
                usize } , 904usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_nlminfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_aioinfo as * const _ as
                usize } , 912usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_aioinfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_singlethread as * const _
                as usize } , 920usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_singlethread ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_suspcount as * const _ as
                usize } , 928usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_suspcount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_xthread as * const _ as
                usize } , 936usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_xthread ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_boundary_count as * const _
                as usize } , 944usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_boundary_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_pendingcnt as * const _ as
                usize } , 948usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_pendingcnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_itimers as * const _ as
                usize } , 952usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_itimers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_procdesc as * const _ as
                usize } , 960usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_procdesc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_treeflag as * const _ as
                usize } , 968usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_treeflag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_pendingexits as * const _
                as usize } , 972usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_pendingexits ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_filemon as * const _ as
                usize } , 976usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_filemon ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_pdeathsig as * const _ as
                usize } , 984usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_pdeathsig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_magic as * const _ as usize
                } , 988usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_magic ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_osrel as * const _ as usize
                } , 992usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_osrel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_comm as * const _ as usize
                } , 996usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_comm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_sysent as * const _ as
                usize } , 1016usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_sysent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_args as * const _ as usize
                } , 1024usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_args ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_cpulimit as * const _ as
                usize } , 1032usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_cpulimit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_nice as * const _ as usize
                } , 1040usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_nice ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_fibnum as * const _ as
                usize } , 1044usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_fibnum ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_reapsubtree as * const _ as
                usize } , 1048usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_reapsubtree ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_elf_machine as * const _ as
                usize } , 1052usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_elf_machine ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_elf_flags as * const _ as
                usize } , 1056usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_elf_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_xexit as * const _ as usize
                } , 1064usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_xexit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_xsig as * const _ as usize
                } , 1068usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_xsig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_pgrp as * const _ as usize
                } , 1072usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_pgrp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_klist as * const _ as usize
                } , 1080usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_klist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_numthreads as * const _ as
                usize } , 1088usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_numthreads ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_md as * const _ as usize }
                , 1096usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_md ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_itcallout as * const _ as
                usize } , 1120usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_itcallout ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_acflag as * const _ as
                usize } , 1184usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_acflag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_peers as * const _ as usize
                } , 1192usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_peers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_leader as * const _ as
                usize } , 1200usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_leader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_emuldata as * const _ as
                usize } , 1208usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_emuldata ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_label as * const _ as usize
                } , 1216usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_label ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_ktr as * const _ as usize }
                , 1224usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_ktr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_mqnotifier as * const _ as
                usize } , 1240usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_mqnotifier ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_dtrace as * const _ as
                usize } , 1248usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_dtrace ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_pwait as * const _ as usize
                } , 1256usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_pwait ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_dbgwait as * const _ as
                usize } , 1272usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_dbgwait ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_prev_runtime as * const _
                as usize } , 1288usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_prev_runtime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_racct as * const _ as usize
                } , 1296usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_racct ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_throttled as * const _ as
                usize } , 1304usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_throttled ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_orphan as * const _ as
                usize } , 1312usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_orphan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_orphans as * const _ as
                usize } , 1328usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_orphans ) ));
}
impl Clone for proc_ {
    fn clone(&self) -> Self { *self }
}
impl Default for proc_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for proc_ {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "proc_ {{ p_list: {:?}, p_threads: {:?}, p_slock: {:?}, p_ucred: {:?}, p_fd: {:?}, p_fdtol: {:?}, p_stats: {:?}, p_limit: {:?}, p_limco: {:?}, p_sigacts: {:?}, p_flag: {:?}, p_flag2: {:?}, p_state: {:?}, p_pid: {:?}, p_hash: {:?}, p_pglist: {:?}, p_pptr: {:?}, p_sibling: {:?}, p_children: {:?}, p_reaper: {:?}, p_reaplist: {:?}, p_reapsibling: {:?}, p_mtx: {:?}, p_statmtx: {:?}, p_itimmtx: {:?}, p_profmtx: {:?}, p_ksi: {:?}, p_sigqueue: {:?}, p_oppid: {:?}, p_vmspace: {:?}, p_swtick: {:?}, p_cowgen: {:?}, p_realtimer: {:?}, p_ru: {:?}, p_rux: {:?}, p_crux: {:?}, p_profthreads: {:?}, p_exitthreads: {:?}, p_traceflag: {:?}, p_tracevp: {:?}, p_tracecred: {:?}, p_textvp: {:?}, p_lock: {:?}, p_sigiolst: {:?}, p_sigparent: {:?}, p_sig: {:?}, p_code: {:?}, p_stops: {:?}, p_stype: {:?}, p_step: {:?}, p_pfsflags: {:?}, p_ptevents: {:?}, p_nlminfo: {:?}, p_aioinfo: {:?}, p_singlethread: {:?}, p_suspcount: {:?}, p_xthread: {:?}, p_boundary_count: {:?}, p_pendingcnt: {:?}, p_itimers: {:?}, p_procdesc: {:?}, p_treeflag: {:?}, p_pendingexits: {:?}, p_filemon: {:?}, p_pdeathsig: {:?}, p_magic: {:?}, p_osrel: {:?}, p_comm: {:?}, p_sysent: {:?}, p_args: {:?}, p_cpulimit: {:?}, p_nice: {:?}, p_fibnum: {:?}, p_reapsubtree: {:?}, p_elf_machine: {:?}, p_elf_flags: {:?}, p_xexit: {:?}, p_xsig: {:?}, p_pgrp: {:?}, p_klist: {:?}, p_numthreads: {:?}, p_md: {:?}, p_itcallout: {:?}, p_acflag: {:?}, p_peers: {:?}, p_leader: {:?}, p_emuldata: {:?}, p_label: {:?}, p_ktr: {:?}, p_mqnotifier: {:?}, p_dtrace: {:?}, p_pwait: {:?}, p_dbgwait: {:?}, p_prev_runtime: {:?}, p_racct: {:?}, p_throttled: {:?}, p_orphan: {:?}, p_orphans: {:?} }}"
               , self . p_list , self . p_threads , self . p_slock , self .
               p_ucred , self . p_fd , self . p_fdtol , self . p_stats , self
               . p_limit , self . p_limco , self . p_sigacts , self . p_flag ,
               self . p_flag2 , self . p_state , self . p_pid , self . p_hash
               , self . p_pglist , self . p_pptr , self . p_sibling , self .
               p_children , self . p_reaper , self . p_reaplist , self .
               p_reapsibling , self . p_mtx , self . p_statmtx , self .
               p_itimmtx , self . p_profmtx , self . p_ksi , self . p_sigqueue
               , self . p_oppid , self . p_vmspace , self . p_swtick , self .
               p_cowgen , self . p_realtimer , self . p_ru , self . p_rux ,
               self . p_crux , self . p_profthreads , self . p_exitthreads ,
               self . p_traceflag , self . p_tracevp , self . p_tracecred ,
               self . p_textvp , self . p_lock , self . p_sigiolst , self .
               p_sigparent , self . p_sig , self . p_code , self . p_stops ,
               self . p_stype , self . p_step , self . p_pfsflags , self .
               p_ptevents , self . p_nlminfo , self . p_aioinfo , self .
               p_singlethread , self . p_suspcount , self . p_xthread , self .
               p_boundary_count , self . p_pendingcnt , self . p_itimers ,
               self . p_procdesc , self . p_treeflag , self . p_pendingexits ,
               self . p_filemon , self . p_pdeathsig , self . p_magic , self .
               p_osrel , self . p_comm , self . p_sysent , self . p_args ,
               self . p_cpulimit , self . p_nice , self . p_fibnum , self .
               p_reapsubtree , self . p_elf_machine , self . p_elf_flags ,
               self . p_xexit , self . p_xsig , self . p_pgrp , self . p_klist
               , self . p_numthreads , self . p_md , self . p_itcallout , self
               . p_acflag , self . p_peers , self . p_leader , self .
               p_emuldata , self . p_label , self . p_ktr , self .
               p_mqnotifier , self . p_dtrace , self . p_pwait , self .
               p_dbgwait , self . p_prev_runtime , self . p_racct , self .
               p_throttled , self . p_orphan , self . p_orphans)
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct thread {
    pub td_lock: *mut mtx,
    pub td_proc: *mut proc_,
    pub td_plist: thread__bindgen_ty_1,
    pub td_runq: thread__bindgen_ty_2,
    pub td_slpq: thread__bindgen_ty_3,
    pub td_lockq: thread__bindgen_ty_4,
    pub td_hash: thread__bindgen_ty_5,
    pub td_cpuset: *mut cpuset,
    pub td_domain: domainset_ref,
    pub td_sel: *mut seltd,
    pub td_sleepqueue: *mut sleepqueue,
    pub td_turnstile: *mut turnstile,
    pub td_rlqe: *mut rl_q_entry,
    pub td_umtxq: *mut umtx_q,
    pub td_tid: lwpid_t,
    pub td_sigqueue: sigqueue_t,
    pub td_lend_user_pri: u_char,
    pub td_epochnest: u_char,
    pub td_flags: ::kernel::sys::raw::c_int,
    pub td_inhibitors: ::kernel::sys::raw::c_int,
    pub td_pflags: ::kernel::sys::raw::c_int,
    pub td_dupfd: ::kernel::sys::raw::c_int,
    pub td_sqqueue: ::kernel::sys::raw::c_int,
    pub td_wchan: *mut ::kernel::sys::raw::c_void,
    pub td_wmesg: *const ::kernel::sys::raw::c_char,
    pub td_owepreempt: u_char,
    pub td_tsqueue: u_char,
    pub td_locks: ::kernel::sys::raw::c_short,
    pub td_rw_rlocks: ::kernel::sys::raw::c_short,
    pub td_sx_slocks: ::kernel::sys::raw::c_short,
    pub td_lk_slocks: ::kernel::sys::raw::c_short,
    pub td_stopsched: ::kernel::sys::raw::c_short,
    pub td_blocked: *mut turnstile,
    pub td_lockname: *const ::kernel::sys::raw::c_char,
    pub td_contested: thread__bindgen_ty_6,
    pub td_sleeplocks: *mut lock_list_entry,
    pub td_intr_nesting_level: ::kernel::sys::raw::c_int,
    pub td_pinned: ::kernel::sys::raw::c_int,
    pub td_ucred: *mut ucred,
    pub td_limit: *mut plimit,
    pub td_slptick: ::kernel::sys::raw::c_int,
    pub td_blktick: ::kernel::sys::raw::c_int,
    pub td_swvoltick: ::kernel::sys::raw::c_int,
    pub td_swinvoltick: ::kernel::sys::raw::c_int,
    pub td_cow: u_int,
    pub td_ru: rusage,
    pub td_rux: rusage_ext,
    pub td_incruntime: u64,
    pub td_runtime: u64,
    pub td_pticks: u_int,
    pub td_sticks: u_int,
    pub td_iticks: u_int,
    pub td_uticks: u_int,
    pub td_intrval: ::kernel::sys::raw::c_int,
    pub td_oldsigmask: sigset_t,
    pub td_generation: u_int,
    pub td_sigstk: stack_t,
    pub td_xsig: ::kernel::sys::raw::c_int,
    pub td_profil_addr: u_long,
    pub td_profil_ticks: u_int,
    pub td_name: [::kernel::sys::raw::c_char; 20usize],
    pub td_fpop: *mut file,
    pub td_dbgflags: ::kernel::sys::raw::c_int,
    pub td_si: siginfo_t,
    pub td_ng_outbound: ::kernel::sys::raw::c_int,
    pub td_osd: osd,
    pub td_map_def_user: *mut vm_map_entry,
    pub td_dbg_forked: pid_t,
    pub td_vp_reserv: u_int,
    pub td_no_sleeping: ::kernel::sys::raw::c_int,
    pub td_su: *mut ::kernel::sys::raw::c_void,
    pub td_sleeptimo: sbintime_t,
    pub td_rtcgen: ::kernel::sys::raw::c_int,
    pub td_vslock_sz: usize,
    pub td_sigmask: sigset_t,
    pub td_rqindex: u_char,
    pub td_base_pri: u_char,
    pub td_priority: u_char,
    pub td_pri_class: u_char,
    pub td_user_pri: u_char,
    pub td_base_user_pri: u_char,
    pub td_pre_epoch_prio: u_char,
    pub td_rb_list: usize,
    pub td_rbp_list: usize,
    pub td_rb_inact: usize,
    pub td_sa: syscall_args,
    pub td_pcb: *mut pcb,
    pub td_state: thread__bindgen_ty_7,
    pub td_uretoff: thread__bindgen_ty_8,
    pub td_cowgen: u_int,
    pub td_slpcallout: callout,
    pub td_frame: *mut trapframe,
    pub td_kstack_obj: *mut vm_object,
    pub td_kstack: vm_offset_t,
    pub td_kstack_pages: ::kernel::sys::raw::c_int,
    pub td_critnest: u_int,
    pub td_md: mdthread,
    pub td_ar: *mut kaudit_record,
    pub td_lprof: [lpohead; 2usize],
    pub td_dtrace: *mut kdtrace_thread,
    pub td_errno: ::kernel::sys::raw::c_int,
    pub td_vnet: *mut vnet,
    pub td_vnet_lpush: *const ::kernel::sys::raw::c_char,
    pub td_intr_frame: *mut trapframe,
    pub td_rfppwait_p: *mut proc_,
    pub td_ma: *mut *mut vm_page,
    pub td_ma_cnt: ::kernel::sys::raw::c_int,
    pub td_emuldata: *mut ::kernel::sys::raw::c_void,
    pub td_lastcpu: ::kernel::sys::raw::c_int,
    pub td_oncpu: ::kernel::sys::raw::c_int,
    pub td_lkpi_task: *mut ::kernel::sys::raw::c_void,
    pub td_epochq: thread__bindgen_ty_9,
    pub td_epoch_section: epoch_section_t,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct thread__bindgen_ty_1 {
    pub tqe_next: *mut thread,
    pub tqe_prev: *mut *mut thread,
}
#[test]
fn bindgen_test_layout_thread__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<thread__bindgen_ty_1>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( thread__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<thread__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( thread__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread__bindgen_ty_1 ) ) . tqe_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( thread__bindgen_ty_1 )
                , "::" , stringify ! ( tqe_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread__bindgen_ty_1 ) ) . tqe_prev as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( thread__bindgen_ty_1 )
                , "::" , stringify ! ( tqe_prev ) ));
}
impl Clone for thread__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for thread__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct thread__bindgen_ty_2 {
    pub tqe_next: *mut thread,
    pub tqe_prev: *mut *mut thread,
}
#[test]
fn bindgen_test_layout_thread__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<thread__bindgen_ty_2>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( thread__bindgen_ty_2 )
               ));
    assert_eq! (::core::mem::align_of::<thread__bindgen_ty_2>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( thread__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread__bindgen_ty_2 ) ) . tqe_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( thread__bindgen_ty_2 )
                , "::" , stringify ! ( tqe_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread__bindgen_ty_2 ) ) . tqe_prev as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( thread__bindgen_ty_2 )
                , "::" , stringify ! ( tqe_prev ) ));
}
impl Clone for thread__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for thread__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct thread__bindgen_ty_3 {
    pub tqe_next: *mut thread,
    pub tqe_prev: *mut *mut thread,
}
#[test]
fn bindgen_test_layout_thread__bindgen_ty_3() {
    assert_eq!(::core::mem::size_of::<thread__bindgen_ty_3>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( thread__bindgen_ty_3 )
               ));
    assert_eq! (::core::mem::align_of::<thread__bindgen_ty_3>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( thread__bindgen_ty_3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread__bindgen_ty_3 ) ) . tqe_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( thread__bindgen_ty_3 )
                , "::" , stringify ! ( tqe_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread__bindgen_ty_3 ) ) . tqe_prev as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( thread__bindgen_ty_3 )
                , "::" , stringify ! ( tqe_prev ) ));
}
impl Clone for thread__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
impl Default for thread__bindgen_ty_3 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct thread__bindgen_ty_4 {
    pub tqe_next: *mut thread,
    pub tqe_prev: *mut *mut thread,
}
#[test]
fn bindgen_test_layout_thread__bindgen_ty_4() {
    assert_eq!(::core::mem::size_of::<thread__bindgen_ty_4>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( thread__bindgen_ty_4 )
               ));
    assert_eq! (::core::mem::align_of::<thread__bindgen_ty_4>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( thread__bindgen_ty_4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread__bindgen_ty_4 ) ) . tqe_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( thread__bindgen_ty_4 )
                , "::" , stringify ! ( tqe_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread__bindgen_ty_4 ) ) . tqe_prev as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( thread__bindgen_ty_4 )
                , "::" , stringify ! ( tqe_prev ) ));
}
impl Clone for thread__bindgen_ty_4 {
    fn clone(&self) -> Self { *self }
}
impl Default for thread__bindgen_ty_4 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct thread__bindgen_ty_5 {
    pub le_next: *mut thread,
    pub le_prev: *mut *mut thread,
}
#[test]
fn bindgen_test_layout_thread__bindgen_ty_5() {
    assert_eq!(::core::mem::size_of::<thread__bindgen_ty_5>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( thread__bindgen_ty_5 )
               ));
    assert_eq! (::core::mem::align_of::<thread__bindgen_ty_5>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( thread__bindgen_ty_5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread__bindgen_ty_5 ) ) . le_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( thread__bindgen_ty_5 )
                , "::" , stringify ! ( le_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread__bindgen_ty_5 ) ) . le_prev as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( thread__bindgen_ty_5 )
                , "::" , stringify ! ( le_prev ) ));
}
impl Clone for thread__bindgen_ty_5 {
    fn clone(&self) -> Self { *self }
}
impl Default for thread__bindgen_ty_5 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct thread__bindgen_ty_6 {
    pub lh_first: *mut turnstile,
}
#[test]
fn bindgen_test_layout_thread__bindgen_ty_6() {
    assert_eq!(::core::mem::size_of::<thread__bindgen_ty_6>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( thread__bindgen_ty_6 )
               ));
    assert_eq! (::core::mem::align_of::<thread__bindgen_ty_6>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( thread__bindgen_ty_6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread__bindgen_ty_6 ) ) . lh_first as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( thread__bindgen_ty_6 )
                , "::" , stringify ! ( lh_first ) ));
}
impl Clone for thread__bindgen_ty_6 {
    fn clone(&self) -> Self { *self }
}
impl Default for thread__bindgen_ty_6 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub const thread_TDS_INACTIVE: thread__bindgen_ty_7 =
    thread__bindgen_ty_7::TDS_INACTIVE;
pub const thread_TDS_INHIBITED: thread__bindgen_ty_7 =
    thread__bindgen_ty_7::TDS_INHIBITED;
pub const thread_TDS_CAN_RUN: thread__bindgen_ty_7 =
    thread__bindgen_ty_7::TDS_CAN_RUN;
pub const thread_TDS_RUNQ: thread__bindgen_ty_7 =
    thread__bindgen_ty_7::TDS_RUNQ;
pub const thread_TDS_RUNNING: thread__bindgen_ty_7 =
    thread__bindgen_ty_7::TDS_RUNNING;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum thread__bindgen_ty_7 {
    TDS_INACTIVE = 0,
    TDS_INHIBITED = 1,
    TDS_CAN_RUN = 2,
    TDS_RUNQ = 3,
    TDS_RUNNING = 4,
}
#[repr(C)]
#[derive(Copy)]
pub union thread__bindgen_ty_8 {
    pub tdu_retval: [register_t; 2usize],
    pub tdu_off: off_t,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_thread__bindgen_ty_8() {
    assert_eq!(::core::mem::size_of::<thread__bindgen_ty_8>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( thread__bindgen_ty_8 )
               ));
    assert_eq! (::core::mem::align_of::<thread__bindgen_ty_8>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( thread__bindgen_ty_8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread__bindgen_ty_8 ) ) . tdu_retval as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( thread__bindgen_ty_8 )
                , "::" , stringify ! ( tdu_retval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread__bindgen_ty_8 ) ) . tdu_off as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( thread__bindgen_ty_8 )
                , "::" , stringify ! ( tdu_off ) ));
}
impl Clone for thread__bindgen_ty_8 {
    fn clone(&self) -> Self { *self }
}
impl Default for thread__bindgen_ty_8 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for thread__bindgen_ty_8 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "thread__bindgen_ty_8 {{ union }}")
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct thread__bindgen_ty_9 {
    pub tqe_next: *mut thread,
    pub tqe_prev: *mut *mut thread,
}
#[test]
fn bindgen_test_layout_thread__bindgen_ty_9() {
    assert_eq!(::core::mem::size_of::<thread__bindgen_ty_9>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( thread__bindgen_ty_9 )
               ));
    assert_eq! (::core::mem::align_of::<thread__bindgen_ty_9>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( thread__bindgen_ty_9 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread__bindgen_ty_9 ) ) . tqe_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( thread__bindgen_ty_9 )
                , "::" , stringify ! ( tqe_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread__bindgen_ty_9 ) ) . tqe_prev as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( thread__bindgen_ty_9 )
                , "::" , stringify ! ( tqe_prev ) ));
}
impl Clone for thread__bindgen_ty_9 {
    fn clone(&self) -> Self { *self }
}
impl Default for thread__bindgen_ty_9 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_thread() {
    assert_eq!(::core::mem::size_of::<thread>() , 1352usize , concat ! (
               "Size of: " , stringify ! ( thread ) ));
    assert_eq! (::core::mem::align_of::<thread>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( thread ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_lock as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_proc as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_proc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_plist as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_plist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_runq as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_runq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_slpq as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_slpq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_lockq as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_lockq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_hash as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_hash ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_cpuset as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_cpuset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_domain as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_domain ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_sel as * const _ as usize
                } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_sel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_sleepqueue as * const _
                as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_sleepqueue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_turnstile as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_turnstile ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_rlqe as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_rlqe ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_umtxq as * const _ as
                usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_umtxq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_tid as * const _ as usize
                } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_tid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_sigqueue as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_sigqueue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_lend_user_pri as * const
                _ as usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_lend_user_pri ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_epochnest as * const _ as
                usize } , 249usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_epochnest ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_flags as * const _ as
                usize } , 252usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_inhibitors as * const _
                as usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_inhibitors ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_pflags as * const _ as
                usize } , 260usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_pflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_dupfd as * const _ as
                usize } , 264usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_dupfd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_sqqueue as * const _ as
                usize } , 268usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_sqqueue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_wchan as * const _ as
                usize } , 272usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_wchan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_wmesg as * const _ as
                usize } , 280usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_wmesg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_owepreempt as * const _
                as usize } , 288usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_owepreempt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_tsqueue as * const _ as
                usize } , 289usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_tsqueue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_locks as * const _ as
                usize } , 290usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_locks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_rw_rlocks as * const _ as
                usize } , 292usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_rw_rlocks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_sx_slocks as * const _ as
                usize } , 294usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_sx_slocks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_lk_slocks as * const _ as
                usize } , 296usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_lk_slocks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_stopsched as * const _ as
                usize } , 298usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_stopsched ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_blocked as * const _ as
                usize } , 304usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_blocked ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_lockname as * const _ as
                usize } , 312usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_lockname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_contested as * const _ as
                usize } , 320usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_contested ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_sleeplocks as * const _
                as usize } , 328usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_sleeplocks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_intr_nesting_level as *
                const _ as usize } , 336usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_intr_nesting_level ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_pinned as * const _ as
                usize } , 340usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_pinned ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_ucred as * const _ as
                usize } , 344usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_ucred ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_limit as * const _ as
                usize } , 352usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_limit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_slptick as * const _ as
                usize } , 360usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_slptick ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_blktick as * const _ as
                usize } , 364usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_blktick ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_swvoltick as * const _ as
                usize } , 368usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_swvoltick ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_swinvoltick as * const _
                as usize } , 372usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_swinvoltick ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_cow as * const _ as usize
                } , 376usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_cow ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_ru as * const _ as usize
                } , 384usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_ru ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_rux as * const _ as usize
                } , 528usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_rux ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_incruntime as * const _
                as usize } , 584usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_incruntime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_runtime as * const _ as
                usize } , 592usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_runtime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_pticks as * const _ as
                usize } , 600usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_pticks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_sticks as * const _ as
                usize } , 604usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_sticks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_iticks as * const _ as
                usize } , 608usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_iticks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_uticks as * const _ as
                usize } , 612usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_uticks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_intrval as * const _ as
                usize } , 616usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_intrval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_oldsigmask as * const _
                as usize } , 620usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_oldsigmask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_generation as * const _
                as usize } , 636usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_generation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_sigstk as * const _ as
                usize } , 640usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_sigstk ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_xsig as * const _ as
                usize } , 664usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_xsig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_profil_addr as * const _
                as usize } , 672usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_profil_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_profil_ticks as * const _
                as usize } , 680usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_profil_ticks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_name as * const _ as
                usize } , 684usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_fpop as * const _ as
                usize } , 704usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_fpop ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_dbgflags as * const _ as
                usize } , 712usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_dbgflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_si as * const _ as usize
                } , 720usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_si ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_ng_outbound as * const _
                as usize } , 800usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_ng_outbound ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_osd as * const _ as usize
                } , 808usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_osd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_map_def_user as * const _
                as usize } , 840usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_map_def_user ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_dbg_forked as * const _
                as usize } , 848usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_dbg_forked ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_vp_reserv as * const _ as
                usize } , 852usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_vp_reserv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_no_sleeping as * const _
                as usize } , 856usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_no_sleeping ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_su as * const _ as usize
                } , 864usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_su ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_sleeptimo as * const _ as
                usize } , 872usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_sleeptimo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_rtcgen as * const _ as
                usize } , 880usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_rtcgen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_vslock_sz as * const _ as
                usize } , 888usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_vslock_sz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_sigmask as * const _ as
                usize } , 896usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_sigmask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_rqindex as * const _ as
                usize } , 912usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_rqindex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_base_pri as * const _ as
                usize } , 913usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_base_pri ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_priority as * const _ as
                usize } , 914usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_priority ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_pri_class as * const _ as
                usize } , 915usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_pri_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_user_pri as * const _ as
                usize } , 916usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_user_pri ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_base_user_pri as * const
                _ as usize } , 917usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_base_user_pri ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_pre_epoch_prio as * const
                _ as usize } , 918usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_pre_epoch_prio ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_rb_list as * const _ as
                usize } , 920usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_rb_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_rbp_list as * const _ as
                usize } , 928usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_rbp_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_rb_inact as * const _ as
                usize } , 936usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_rb_inact ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_sa as * const _ as usize
                } , 944usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_sa ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_pcb as * const _ as usize
                } , 1032usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_pcb ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_state as * const _ as
                usize } , 1040usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_uretoff as * const _ as
                usize } , 1048usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_uretoff ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_cowgen as * const _ as
                usize } , 1064usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_cowgen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_slpcallout as * const _
                as usize } , 1072usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_slpcallout ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_frame as * const _ as
                usize } , 1136usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_frame ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_kstack_obj as * const _
                as usize } , 1144usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_kstack_obj ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_kstack as * const _ as
                usize } , 1152usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_kstack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_kstack_pages as * const _
                as usize } , 1160usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_kstack_pages ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_critnest as * const _ as
                usize } , 1164usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_critnest ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_md as * const _ as usize
                } , 1168usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_md ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_ar as * const _ as usize
                } , 1216usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_ar ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_lprof as * const _ as
                usize } , 1224usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_lprof ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_dtrace as * const _ as
                usize } , 1240usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_dtrace ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_errno as * const _ as
                usize } , 1248usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_errno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_vnet as * const _ as
                usize } , 1256usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_vnet ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_vnet_lpush as * const _
                as usize } , 1264usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_vnet_lpush ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_intr_frame as * const _
                as usize } , 1272usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_intr_frame ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_rfppwait_p as * const _
                as usize } , 1280usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_rfppwait_p ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_ma as * const _ as usize
                } , 1288usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_ma ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_ma_cnt as * const _ as
                usize } , 1296usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_ma_cnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_emuldata as * const _ as
                usize } , 1304usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_emuldata ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_lastcpu as * const _ as
                usize } , 1312usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_lastcpu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_oncpu as * const _ as
                usize } , 1316usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_oncpu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_lkpi_task as * const _ as
                usize } , 1320usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_lkpi_task ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_epochq as * const _ as
                usize } , 1328usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_epochq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_epoch_section as * const
                _ as usize } , 1344usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_epoch_section ) ));
}
impl Clone for thread {
    fn clone(&self) -> Self { *self }
}
impl Default for thread {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for thread {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "thread {{ td_lock: {:?}, td_proc: {:?}, td_plist: {:?}, td_runq: {:?}, td_slpq: {:?}, td_lockq: {:?}, td_hash: {:?}, td_cpuset: {:?}, td_domain: {:?}, td_sel: {:?}, td_sleepqueue: {:?}, td_turnstile: {:?}, td_rlqe: {:?}, td_umtxq: {:?}, td_tid: {:?}, td_sigqueue: {:?}, td_lend_user_pri: {:?}, td_epochnest: {:?}, td_flags: {:?}, td_inhibitors: {:?}, td_pflags: {:?}, td_dupfd: {:?}, td_sqqueue: {:?}, td_wchan: {:?}, td_wmesg: {:?}, td_owepreempt: {:?}, td_tsqueue: {:?}, td_locks: {:?}, td_rw_rlocks: {:?}, td_sx_slocks: {:?}, td_lk_slocks: {:?}, td_stopsched: {:?}, td_blocked: {:?}, td_lockname: {:?}, td_contested: {:?}, td_sleeplocks: {:?}, td_intr_nesting_level: {:?}, td_pinned: {:?}, td_ucred: {:?}, td_limit: {:?}, td_slptick: {:?}, td_blktick: {:?}, td_swvoltick: {:?}, td_swinvoltick: {:?}, td_cow: {:?}, td_ru: {:?}, td_rux: {:?}, td_incruntime: {:?}, td_runtime: {:?}, td_pticks: {:?}, td_sticks: {:?}, td_iticks: {:?}, td_uticks: {:?}, td_intrval: {:?}, td_oldsigmask: {:?}, td_generation: {:?}, td_sigstk: {:?}, td_xsig: {:?}, td_profil_addr: {:?}, td_profil_ticks: {:?}, td_name: {:?}, td_fpop: {:?}, td_dbgflags: {:?}, td_si: {:?}, td_ng_outbound: {:?}, td_osd: {:?}, td_map_def_user: {:?}, td_dbg_forked: {:?}, td_vp_reserv: {:?}, td_no_sleeping: {:?}, td_su: {:?}, td_sleeptimo: {:?}, td_rtcgen: {:?}, td_vslock_sz: {:?}, td_sigmask: {:?}, td_rqindex: {:?}, td_base_pri: {:?}, td_priority: {:?}, td_pri_class: {:?}, td_user_pri: {:?}, td_base_user_pri: {:?}, td_pre_epoch_prio: {:?}, td_rb_list: {:?}, td_rbp_list: {:?}, td_rb_inact: {:?}, td_sa: {:?}, td_pcb: {:?}, td_state: {:?}, td_uretoff: {:?}, td_cowgen: {:?}, td_slpcallout: {:?}, td_frame: {:?}, td_kstack_obj: {:?}, td_kstack: {:?}, td_kstack_pages: {:?}, td_critnest: {:?}, td_md: {:?}, td_ar: {:?}, td_lprof: {:?}, td_dtrace: {:?}, td_errno: {:?}, td_vnet: {:?}, td_vnet_lpush: {:?}, td_intr_frame: {:?}, td_rfppwait_p: {:?}, td_ma: {:?}, td_ma_cnt: {:?}, td_emuldata: {:?}, td_lastcpu: {:?}, td_oncpu: {:?}, td_lkpi_task: {:?}, td_epochq: {:?}, td_epoch_section: {:?} }}"
               , self . td_lock , self . td_proc , self . td_plist , self .
               td_runq , self . td_slpq , self . td_lockq , self . td_hash ,
               self . td_cpuset , self . td_domain , self . td_sel , self .
               td_sleepqueue , self . td_turnstile , self . td_rlqe , self .
               td_umtxq , self . td_tid , self . td_sigqueue , self .
               td_lend_user_pri , self . td_epochnest , self . td_flags , self
               . td_inhibitors , self . td_pflags , self . td_dupfd , self .
               td_sqqueue , self . td_wchan , self . td_wmesg , self .
               td_owepreempt , self . td_tsqueue , self . td_locks , self .
               td_rw_rlocks , self . td_sx_slocks , self . td_lk_slocks , self
               . td_stopsched , self . td_blocked , self . td_lockname , self
               . td_contested , self . td_sleeplocks , self .
               td_intr_nesting_level , self . td_pinned , self . td_ucred ,
               self . td_limit , self . td_slptick , self . td_blktick , self
               . td_swvoltick , self . td_swinvoltick , self . td_cow , self .
               td_ru , self . td_rux , self . td_incruntime , self .
               td_runtime , self . td_pticks , self . td_sticks , self .
               td_iticks , self . td_uticks , self . td_intrval , self .
               td_oldsigmask , self . td_generation , self . td_sigstk , self
               . td_xsig , self . td_profil_addr , self . td_profil_ticks ,
               self . td_name , self . td_fpop , self . td_dbgflags , self .
               td_si , self . td_ng_outbound , self . td_osd , self .
               td_map_def_user , self . td_dbg_forked , self . td_vp_reserv ,
               self . td_no_sleeping , self . td_su , self . td_sleeptimo ,
               self . td_rtcgen , self . td_vslock_sz , self . td_sigmask ,
               self . td_rqindex , self . td_base_pri , self . td_priority ,
               self . td_pri_class , self . td_user_pri , self .
               td_base_user_pri , self . td_pre_epoch_prio , self . td_rb_list
               , self . td_rbp_list , self . td_rb_inact , self . td_sa , self
               . td_pcb , self . td_state , self . td_uretoff , self .
               td_cowgen , self . td_slpcallout , self . td_frame , self .
               td_kstack_obj , self . td_kstack , self . td_kstack_pages ,
               self . td_critnest , self . td_md , self . td_ar , self .
               td_lprof , self . td_dtrace , self . td_errno , self . td_vnet
               , self . td_vnet_lpush , self . td_intr_frame , self .
               td_rfppwait_p , self . td_ma , self . td_ma_cnt , self .
               td_emuldata , self . td_lastcpu , self . td_oncpu , self .
               td_lkpi_task , self . td_epochq , self . td_epoch_section)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tty {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ucred {
    pub cr_ref: u_int,
    pub cr_uid: uid_t,
    pub cr_ruid: uid_t,
    pub cr_svuid: uid_t,
    pub cr_ngroups: ::kernel::sys::raw::c_int,
    pub cr_rgid: gid_t,
    pub cr_svgid: gid_t,
    pub cr_uidinfo: *mut uidinfo,
    pub cr_ruidinfo: *mut uidinfo,
    pub cr_prison: *mut prison,
    pub cr_loginclass: *mut loginclass,
    pub cr_flags: u_int,
    pub cr_pspare2: [*mut ::kernel::sys::raw::c_void; 2usize],
    pub cr_label: *mut label,
    pub cr_audit: auditinfo_addr,
    pub cr_groups: *mut gid_t,
    pub cr_agroups: ::kernel::sys::raw::c_int,
    pub cr_smallgroups: [gid_t; 16usize],
}
#[test]
fn bindgen_test_layout_ucred() {
    assert_eq!(::core::mem::size_of::<ucred>() , 224usize , concat ! (
               "Size of: " , stringify ! ( ucred ) ));
    assert_eq! (::core::mem::align_of::<ucred>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ucred ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ucred ) ) . cr_ref as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ucred ) , "::" ,
                stringify ! ( cr_ref ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ucred ) ) . cr_uid as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ucred ) , "::" ,
                stringify ! ( cr_uid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ucred ) ) . cr_ruid as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ucred ) , "::" ,
                stringify ! ( cr_ruid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ucred ) ) . cr_svuid as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( ucred ) , "::" ,
                stringify ! ( cr_svuid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ucred ) ) . cr_ngroups as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ucred ) , "::" ,
                stringify ! ( cr_ngroups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ucred ) ) . cr_rgid as * const _ as usize
                } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( ucred ) , "::" ,
                stringify ! ( cr_rgid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ucred ) ) . cr_svgid as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ucred ) , "::" ,
                stringify ! ( cr_svgid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ucred ) ) . cr_uidinfo as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( ucred ) , "::" ,
                stringify ! ( cr_uidinfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ucred ) ) . cr_ruidinfo as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( ucred ) , "::" ,
                stringify ! ( cr_ruidinfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ucred ) ) . cr_prison as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( ucred ) , "::" ,
                stringify ! ( cr_prison ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ucred ) ) . cr_loginclass as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( ucred ) , "::" ,
                stringify ! ( cr_loginclass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ucred ) ) . cr_flags as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( ucred ) , "::" ,
                stringify ! ( cr_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ucred ) ) . cr_pspare2 as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( ucred ) , "::" ,
                stringify ! ( cr_pspare2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ucred ) ) . cr_label as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( ucred ) , "::" ,
                stringify ! ( cr_label ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ucred ) ) . cr_audit as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( ucred ) , "::" ,
                stringify ! ( cr_audit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ucred ) ) . cr_groups as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( ucred ) , "::" ,
                stringify ! ( cr_groups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ucred ) ) . cr_agroups as * const _ as
                usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( ucred ) , "::" ,
                stringify ! ( cr_agroups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ucred ) ) . cr_smallgroups as * const _
                as usize } , 156usize , concat ! (
                "Alignment of field: " , stringify ! ( ucred ) , "::" ,
                stringify ! ( cr_smallgroups ) ));
}
impl Clone for ucred {
    fn clone(&self) -> Self { *self }
}
impl Default for ucred {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uio {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _jmp_buf {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct trapframe {
    pub tf_rdi: register_t,
    pub tf_rsi: register_t,
    pub tf_rdx: register_t,
    pub tf_rcx: register_t,
    pub tf_r8: register_t,
    pub tf_r9: register_t,
    pub tf_rax: register_t,
    pub tf_rbx: register_t,
    pub tf_rbp: register_t,
    pub tf_r10: register_t,
    pub tf_r11: register_t,
    pub tf_r12: register_t,
    pub tf_r13: register_t,
    pub tf_r14: register_t,
    pub tf_r15: register_t,
    pub tf_trapno: u32,
    pub tf_fs: u16,
    pub tf_gs: u16,
    pub tf_addr: register_t,
    pub tf_flags: u32,
    pub tf_es: u16,
    pub tf_ds: u16,
    pub tf_err: register_t,
    pub tf_rip: register_t,
    pub tf_cs: register_t,
    pub tf_rflags: register_t,
    pub tf_rsp: register_t,
    pub tf_ss: register_t,
}
#[test]
fn bindgen_test_layout_trapframe() {
    assert_eq!(::core::mem::size_of::<trapframe>() , 192usize , concat ! (
               "Size of: " , stringify ! ( trapframe ) ));
    assert_eq! (::core::mem::align_of::<trapframe>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( trapframe ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_rdi as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_rdi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_rsi as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_rsi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_rdx as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_rdx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_rcx as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_rcx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_r8 as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_r8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_r9 as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_r9 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_rax as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_rax ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_rbx as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_rbx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_rbp as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_rbp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_r10 as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_r10 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_r11 as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_r11 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_r12 as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_r12 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_r13 as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_r13 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_r14 as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_r14 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_r15 as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_r15 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_trapno as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_trapno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_fs as * const _ as
                usize } , 124usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_fs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_gs as * const _ as
                usize } , 126usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_gs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_addr as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_flags as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_es as * const _ as
                usize } , 140usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_es ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_ds as * const _ as
                usize } , 142usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_ds ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_err as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_err ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_rip as * const _ as
                usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_rip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_cs as * const _ as
                usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_cs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_rflags as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_rflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_rsp as * const _ as
                usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_rsp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_ss as * const _ as
                usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_ss ) ));
}
impl Clone for trapframe {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eventtimer {
    _unused: [u8; 0],
}
extern "C" {
    pub fn setjmp(arg1: *mut _jmp_buf) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn longjmp(arg1: *mut _jmp_buf, arg2: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn dumpstatus(addr: vm_offset_t, count: off_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn nullop() -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn eopnotsupp() -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn ureadc(arg1: ::kernel::sys::raw::c_int, arg2: *mut uio)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn hashdestroy(arg1: *mut ::kernel::sys::raw::c_void,
                       arg2: *mut malloc_type, arg3: u_long);
}
extern "C" {
    pub fn hashinit(count: ::kernel::sys::raw::c_int, type_: *mut malloc_type,
                    hashmask: *mut u_long) -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn hashinit_flags(count: ::kernel::sys::raw::c_int,
                          type_: *mut malloc_type, hashmask: *mut u_long,
                          flags: ::kernel::sys::raw::c_int)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn phashinit(count: ::kernel::sys::raw::c_int,
                     type_: *mut malloc_type, nentries: *mut u_long)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn phashinit_flags(count: ::kernel::sys::raw::c_int,
                           type_: *mut malloc_type, nentries: *mut u_long,
                           flags: ::kernel::sys::raw::c_int)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn g_waitidle();
}
extern "C" {
    pub fn panic(arg1: *const ::kernel::sys::raw::c_char, ...);
}
extern "C" {
    pub fn vpanic(arg1: *const ::kernel::sys::raw::c_char,
                  arg2: *mut __va_list_tag);
}
extern "C" {
    pub fn cpu_boot(arg1: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn cpu_flush_dcache(arg1: *mut ::kernel::sys::raw::c_void,
                            arg2: usize);
}
extern "C" {
    pub fn cpu_rootconf();
}
extern "C" {
    pub fn critical_enter();
}
extern "C" {
    pub fn critical_exit();
}
extern "C" {
    pub fn init_param1();
}
extern "C" {
    pub fn init_param2(physpages: ::kernel::sys::raw::c_long);
}
extern "C" {
    pub fn init_static_kenv(arg1: *mut ::kernel::sys::raw::c_char,
                            arg2: usize);
}
extern "C" {
    pub fn tablefull(arg1: *const ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn kvprintf(arg1: *const ::kernel::sys::raw::c_char,
                    arg2:
                        ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                        ::kernel::sys::raw::c_int,
                                                                    arg2:
                                                                        *mut ::kernel::sys::raw::c_void)>,
                    arg3: *mut ::kernel::sys::raw::c_void,
                    arg4: ::kernel::sys::raw::c_int, arg5: *mut __va_list_tag)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn log(arg1: ::kernel::sys::raw::c_int,
               arg2: *const ::kernel::sys::raw::c_char, ...);
}
extern "C" {
    pub fn log_console(arg1: *mut uio);
}
extern "C" {
    pub fn vlog(arg1: ::kernel::sys::raw::c_int,
                arg2: *const ::kernel::sys::raw::c_char,
                arg3: *mut __va_list_tag);
}
extern "C" {
    pub fn asprintf(ret: *mut *mut ::kernel::sys::raw::c_char,
                    mtp: *mut malloc_type,
                    format: *const ::kernel::sys::raw::c_char, ...)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn printf(arg1: *const ::kernel::sys::raw::c_char, ...)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn snprintf(arg1: *mut ::kernel::sys::raw::c_char, arg2: usize,
                    arg3: *const ::kernel::sys::raw::c_char, ...)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sprintf(buf: *mut ::kernel::sys::raw::c_char,
                   arg1: *const ::kernel::sys::raw::c_char, ...)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn uprintf(arg1: *const ::kernel::sys::raw::c_char, ...)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn vprintf(arg1: *const ::kernel::sys::raw::c_char,
                   arg2: *mut __va_list_tag) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn vasprintf(ret: *mut *mut ::kernel::sys::raw::c_char,
                     mtp: *mut malloc_type,
                     format: *const ::kernel::sys::raw::c_char,
                     ap: *mut __va_list_tag) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(arg1: *mut ::kernel::sys::raw::c_char, arg2: usize,
                     arg3: *const ::kernel::sys::raw::c_char,
                     arg4: *mut __va_list_tag) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn vsnrprintf(arg1: *mut ::kernel::sys::raw::c_char, arg2: usize,
                      arg3: ::kernel::sys::raw::c_int,
                      arg4: *const ::kernel::sys::raw::c_char,
                      arg5: *mut __va_list_tag) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn vsprintf(buf: *mut ::kernel::sys::raw::c_char,
                    arg1: *const ::kernel::sys::raw::c_char,
                    arg2: *mut __va_list_tag) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn ttyprintf(arg1: *mut tty,
                     arg2: *const ::kernel::sys::raw::c_char, ...)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sscanf(arg1: *const ::kernel::sys::raw::c_char,
                  arg2: *const ::kernel::sys::raw::c_char, ...)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn vsscanf(arg1: *const ::kernel::sys::raw::c_char,
                   arg2: *const ::kernel::sys::raw::c_char,
                   arg3: *mut __va_list_tag) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn strtol(arg1: *const ::kernel::sys::raw::c_char,
                  arg2: *mut *mut ::kernel::sys::raw::c_char,
                  arg3: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_long;
}
extern "C" {
    pub fn strtoul(arg1: *const ::kernel::sys::raw::c_char,
                   arg2: *mut *mut ::kernel::sys::raw::c_char,
                   arg3: ::kernel::sys::raw::c_int) -> u_long;
}
extern "C" {
    pub fn strtoq(arg1: *const ::kernel::sys::raw::c_char,
                  arg2: *mut *mut ::kernel::sys::raw::c_char,
                  arg3: ::kernel::sys::raw::c_int) -> quad_t;
}
extern "C" {
    pub fn strtouq(arg1: *const ::kernel::sys::raw::c_char,
                   arg2: *mut *mut ::kernel::sys::raw::c_char,
                   arg3: ::kernel::sys::raw::c_int) -> u_quad_t;
}
extern "C" {
    pub fn tprintf(p: *mut proc_, pri: ::kernel::sys::raw::c_int,
                   arg1: *const ::kernel::sys::raw::c_char, ...);
}
extern "C" {
    pub fn vtprintf(arg1: *mut proc_, arg2: ::kernel::sys::raw::c_int,
                    arg3: *const ::kernel::sys::raw::c_char,
                    arg4: *mut __va_list_tag);
}
extern "C" {
    pub fn hexdump(ptr: *const ::kernel::sys::raw::c_void,
                   length: ::kernel::sys::raw::c_int,
                   hdr: *const ::kernel::sys::raw::c_char,
                   flags: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn bcopy(from: *const ::kernel::sys::raw::c_void,
                 to: *mut ::kernel::sys::raw::c_void, len: usize);
}
extern "C" {
    pub fn bzero(buf: *mut ::kernel::sys::raw::c_void, len: usize);
}
extern "C" {
    pub fn explicit_bzero(arg1: *mut ::kernel::sys::raw::c_void, arg2: usize);
}
extern "C" {
    pub fn memcpy(to: *mut ::kernel::sys::raw::c_void,
                  from: *const ::kernel::sys::raw::c_void, len: usize)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn memmove(dest: *mut ::kernel::sys::raw::c_void,
                   src: *const ::kernel::sys::raw::c_void, n: usize)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn copystr(kfaddr: *const ::kernel::sys::raw::c_void,
                   kdaddr: *mut ::kernel::sys::raw::c_void, len: usize,
                   lencopied: *mut usize) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn copyinstr(udaddr: *const ::kernel::sys::raw::c_void,
                     kaddr: *mut ::kernel::sys::raw::c_void, len: usize,
                     lencopied: *mut usize) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn copyin(udaddr: *const ::kernel::sys::raw::c_void,
                  kaddr: *mut ::kernel::sys::raw::c_void, len: usize)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn copyin_nofault(udaddr: *const ::kernel::sys::raw::c_void,
                          kaddr: *mut ::kernel::sys::raw::c_void, len: usize)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn copyout(kaddr: *const ::kernel::sys::raw::c_void,
                   udaddr: *mut ::kernel::sys::raw::c_void, len: usize)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn copyout_nofault(kaddr: *const ::kernel::sys::raw::c_void,
                           udaddr: *mut ::kernel::sys::raw::c_void,
                           len: usize) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn fubyte(base: *const ::kernel::sys::raw::c_void)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn fuword(base: *const ::kernel::sys::raw::c_void)
     -> ::kernel::sys::raw::c_long;
}
extern "C" {
    pub fn fuword16(base: *const ::kernel::sys::raw::c_void)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn fuword32(base: *const ::kernel::sys::raw::c_void) -> i32;
}
extern "C" {
    pub fn fuword64(base: *const ::kernel::sys::raw::c_void) -> i64;
}
extern "C" {
    pub fn fueword(base: *const ::kernel::sys::raw::c_void,
                   val: *mut ::kernel::sys::raw::c_long)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn fueword32(base: *const ::kernel::sys::raw::c_void, val: *mut i32)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn fueword64(base: *const ::kernel::sys::raw::c_void, val: *mut i64)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn subyte(base: *mut ::kernel::sys::raw::c_void,
                  byte: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn suword(base: *mut ::kernel::sys::raw::c_void,
                  word: ::kernel::sys::raw::c_long)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn suword16(base: *mut ::kernel::sys::raw::c_void,
                    word: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn suword32(base: *mut ::kernel::sys::raw::c_void, word: i32)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn suword64(base: *mut ::kernel::sys::raw::c_void, word: i64)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn casuword32(base: *mut u32, oldval: u32, newval: u32) -> u32;
}
extern "C" {
    pub fn casuword(p: *mut u_long, oldval: u_long, newval: u_long) -> u_long;
}
extern "C" {
    pub fn casueword32(base: *mut u32, oldval: u32, oldvalp: *mut u32,
                       newval: u32) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn casueword(p: *mut u_long, oldval: u_long, oldvalp: *mut u_long,
                     newval: u_long) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn realitexpire(arg1: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn sysbeep(hertz: ::kernel::sys::raw::c_int,
                   period: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn hardclock(usermode: ::kernel::sys::raw::c_int, pc: uintfptr_t);
}
extern "C" {
    pub fn hardclock_cnt(cnt: ::kernel::sys::raw::c_int,
                         usermode: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn hardclock_cpu(usermode: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn hardclock_sync(cpu: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn softclock(arg1: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn statclock(usermode: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn statclock_cnt(cnt: ::kernel::sys::raw::c_int,
                         usermode: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn profclock(usermode: ::kernel::sys::raw::c_int, pc: uintfptr_t);
}
extern "C" {
    pub fn profclock_cnt(cnt: ::kernel::sys::raw::c_int,
                         usermode: ::kernel::sys::raw::c_int, pc: uintfptr_t);
}
extern "C" {
    pub fn hardclockintr() -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn startprofclock(arg1: *mut proc_);
}
extern "C" {
    pub fn stopprofclock(arg1: *mut proc_);
}
extern "C" {
    pub fn cpu_startprofclock();
}
extern "C" {
    pub fn cpu_stopprofclock();
}
extern "C" {
    pub fn suspendclock();
}
extern "C" {
    pub fn resumeclock();
}
extern "C" {
    pub fn cpu_idleclock() -> sbintime_t;
}
extern "C" {
    pub fn cpu_activeclock();
}
extern "C" {
    pub fn cpu_new_callout(cpu: ::kernel::sys::raw::c_int, bt: sbintime_t,
                           bt_opt: sbintime_t);
}
extern "C" {
    pub fn cpu_et_frequency(et: *mut eventtimer, newfreq: u64);
}
extern "C" {
    #[link_name = "cpu_disable_c2_sleep"]
    pub static mut cpu_disable_c2_sleep: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "cpu_disable_c3_sleep"]
    pub static mut cpu_disable_c3_sleep: ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn kern_getenv(name: *const ::kernel::sys::raw::c_char)
     -> *mut ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn freeenv(env: *mut ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn getenv_int(name: *const ::kernel::sys::raw::c_char,
                      data: *mut ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn getenv_uint(name: *const ::kernel::sys::raw::c_char,
                       data: *mut ::kernel::sys::raw::c_uint)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn getenv_long(name: *const ::kernel::sys::raw::c_char,
                       data: *mut ::kernel::sys::raw::c_long)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn getenv_ulong(name: *const ::kernel::sys::raw::c_char,
                        data: *mut ::kernel::sys::raw::c_ulong)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn getenv_string(name: *const ::kernel::sys::raw::c_char,
                         data: *mut ::kernel::sys::raw::c_char,
                         size: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn getenv_int64(name: *const ::kernel::sys::raw::c_char,
                        data: *mut i64) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn getenv_uint64(name: *const ::kernel::sys::raw::c_char,
                         data: *mut u64) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn getenv_quad(name: *const ::kernel::sys::raw::c_char,
                       data: *mut quad_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn kern_setenv(name: *const ::kernel::sys::raw::c_char,
                       value: *const ::kernel::sys::raw::c_char)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn kern_unsetenv(name: *const ::kernel::sys::raw::c_char)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn testenv(name: *const ::kernel::sys::raw::c_char)
     -> ::kernel::sys::raw::c_int;
}
pub type cpu_tick_f = ::core::option::Option<unsafe extern "C" fn() -> u64>;
extern "C" {
    pub fn set_cputicker(func: cpu_tick_f, freq: u64,
                         var: ::kernel::sys::raw::c_uint);
}
extern "C" {
    #[link_name = "cpu_ticks"]
    pub static mut cpu_ticks: cpu_tick_f;
}
extern "C" {
    pub fn cpu_tickrate() -> u64;
}
extern "C" {
    pub fn cputick2usec(tick: u64) -> u64;
}
extern "C" {
    #[link_name = "bcd2bin_data"]
    pub static mut bcd2bin_data: [u_char; 0usize];
}
extern "C" {
    #[link_name = "bin2bcd_data"]
    pub static mut bin2bcd_data: [u_char; 0usize];
}
extern "C" {
    #[link_name = "hex2ascii_data"]
    pub static mut hex2ascii_data: [::kernel::sys::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "arc4rand_iniseed_state"]
    pub static mut arc4rand_iniseed_state: ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn arc4random() -> u32;
}
extern "C" {
    pub fn arc4random_buf(arg1: *mut ::kernel::sys::raw::c_void, arg2: usize);
}
extern "C" {
    pub fn arc4rand(arg1: *mut ::kernel::sys::raw::c_void, arg2: u_int,
                    arg3: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn bcmp(arg1: *const ::kernel::sys::raw::c_void,
                arg2: *const ::kernel::sys::raw::c_void, arg3: usize)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn timingsafe_bcmp(arg1: *const ::kernel::sys::raw::c_void,
                           arg2: *const ::kernel::sys::raw::c_void,
                           arg3: usize) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bsearch(arg1: *const ::kernel::sys::raw::c_void,
                   arg2: *const ::kernel::sys::raw::c_void, arg3: usize,
                   arg4: usize,
                   arg5:
                       ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                       *const ::kernel::sys::raw::c_void,
                                                                   arg2:
                                                                       *const ::kernel::sys::raw::c_void)
                                                  ->
                                                      ::kernel::sys::raw::c_int>)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn fnmatch(arg1: *const ::kernel::sys::raw::c_char,
                   arg2: *const ::kernel::sys::raw::c_char,
                   arg3: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn locc(arg1: ::kernel::sys::raw::c_int,
                arg2: *mut ::kernel::sys::raw::c_char, arg3: u_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn memchr(s: *const ::kernel::sys::raw::c_void,
                  c: ::kernel::sys::raw::c_int, n: usize)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn memcchr(s: *const ::kernel::sys::raw::c_void,
                   c: ::kernel::sys::raw::c_int, n: usize)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn memcmp(b1: *const ::kernel::sys::raw::c_void,
                  b2: *const ::kernel::sys::raw::c_void, len: usize)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn memmem(l: *const ::kernel::sys::raw::c_void, l_len: usize,
                  s: *const ::kernel::sys::raw::c_void, s_len: usize)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn qsort(base: *mut ::kernel::sys::raw::c_void, nmemb: usize,
                 size: usize,
                 compar:
                     ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                     *const ::kernel::sys::raw::c_void,
                                                                 arg2:
                                                                     *const ::kernel::sys::raw::c_void)
                                                ->
                                                    ::kernel::sys::raw::c_int>);
}
extern "C" {
    pub fn qsort_r(base: *mut ::kernel::sys::raw::c_void, nmemb: usize,
                   size: usize, thunk: *mut ::kernel::sys::raw::c_void,
                   compar:
                       ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                       *mut ::kernel::sys::raw::c_void,
                                                                   arg2:
                                                                       *const ::kernel::sys::raw::c_void,
                                                                   arg3:
                                                                       *const ::kernel::sys::raw::c_void)
                                                  ->
                                                      ::kernel::sys::raw::c_int>);
}
extern "C" {
    pub fn random() -> u_long;
}
extern "C" {
    pub fn scanc(arg1: u_int, arg2: *const u_char, arg3: *const u_char,
                 arg4: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn srandom(arg1: u_long);
}
extern "C" {
    pub fn strcasecmp(arg1: *const ::kernel::sys::raw::c_char,
                      arg2: *const ::kernel::sys::raw::c_char)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn strcat(arg1: *mut ::kernel::sys::raw::c_char,
                  arg2: *const ::kernel::sys::raw::c_char)
     -> *mut ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn strchr(arg1: *const ::kernel::sys::raw::c_char,
                  arg2: ::kernel::sys::raw::c_int)
     -> *mut ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn strcmp(arg1: *const ::kernel::sys::raw::c_char,
                  arg2: *const ::kernel::sys::raw::c_char)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn strcpy(arg1: *mut ::kernel::sys::raw::c_char,
                  arg2: *const ::kernel::sys::raw::c_char)
     -> *mut ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn strcspn(arg1: *const ::kernel::sys::raw::c_char,
                   arg2: *const ::kernel::sys::raw::c_char) -> usize;
}
extern "C" {
    pub fn strdup(arg1: *const ::kernel::sys::raw::c_char,
                  arg2: *mut malloc_type) -> *mut ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn strncat(arg1: *mut ::kernel::sys::raw::c_char,
                   arg2: *const ::kernel::sys::raw::c_char, arg3: usize)
     -> *mut ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn strndup(arg1: *const ::kernel::sys::raw::c_char, arg2: usize,
                   arg3: *mut malloc_type) -> *mut ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn strlcat(arg1: *mut ::kernel::sys::raw::c_char,
                   arg2: *const ::kernel::sys::raw::c_char, arg3: usize)
     -> usize;
}
extern "C" {
    pub fn strlcpy(arg1: *mut ::kernel::sys::raw::c_char,
                   arg2: *const ::kernel::sys::raw::c_char, arg3: usize)
     -> usize;
}
extern "C" {
    pub fn strlen(arg1: *const ::kernel::sys::raw::c_char) -> usize;
}
extern "C" {
    pub fn strncasecmp(arg1: *const ::kernel::sys::raw::c_char,
                       arg2: *const ::kernel::sys::raw::c_char, arg3: usize)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn strncmp(arg1: *const ::kernel::sys::raw::c_char,
                   arg2: *const ::kernel::sys::raw::c_char, arg3: usize)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn strncpy(arg1: *mut ::kernel::sys::raw::c_char,
                   arg2: *const ::kernel::sys::raw::c_char, arg3: usize)
     -> *mut ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn strnlen(arg1: *const ::kernel::sys::raw::c_char, arg2: usize)
     -> usize;
}
extern "C" {
    pub fn strrchr(arg1: *const ::kernel::sys::raw::c_char,
                   arg2: ::kernel::sys::raw::c_int)
     -> *mut ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn strsep(arg1: *mut *mut ::kernel::sys::raw::c_char,
                  delim: *const ::kernel::sys::raw::c_char)
     -> *mut ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn strspn(arg1: *const ::kernel::sys::raw::c_char,
                  arg2: *const ::kernel::sys::raw::c_char) -> usize;
}
extern "C" {
    pub fn strstr(arg1: *const ::kernel::sys::raw::c_char,
                  arg2: *const ::kernel::sys::raw::c_char)
     -> *mut ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn strvalid(arg1: *const ::kernel::sys::raw::c_char, arg2: usize)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "crc32_tab"]
    pub static mut crc32_tab: [u32; 0usize];
}
extern "C" {
    pub fn calculate_crc32c(crc32c: u32,
                            buffer: *const ::kernel::sys::raw::c_uchar,
                            length: ::kernel::sys::raw::c_uint) -> u32;
}
extern "C" {
    pub fn sse42_crc32c(arg1: u32, arg2: *const ::kernel::sys::raw::c_uchar,
                        arg3: ::kernel::sys::raw::c_uint) -> u32;
}
extern "C" {
    pub fn consinit();
}
extern "C" {
    pub fn cpu_initclocks();
}
extern "C" {
    pub fn cpu_initclocks_bsp();
}
extern "C" {
    pub fn cpu_initclocks_ap();
}
extern "C" {
    pub fn usrinfoinit();
}
extern "C" {
    pub fn kern_reboot(arg1: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn shutdown_nice(arg1: ::kernel::sys::raw::c_int);
}
pub type timeout_t =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void)>;
extern "C" {
    pub fn callout_handle_init(arg1: *mut callout_handle);
}
extern "C" {
    pub fn timeout(arg1: timeout_t, arg2: *mut ::kernel::sys::raw::c_void,
                   arg3: ::kernel::sys::raw::c_int) -> callout_handle;
}
extern "C" {
    pub fn untimeout(arg1: timeout_t, arg2: *mut ::kernel::sys::raw::c_void,
                     arg3: callout_handle);
}
extern "C" {
    pub fn _sleep(chan: *mut ::kernel::sys::raw::c_void,
                  lock: *mut lock_object, pri: ::kernel::sys::raw::c_int,
                  wmesg: *const ::kernel::sys::raw::c_char, sbt: sbintime_t,
                  pr: sbintime_t, flags: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn msleep_spin_sbt(chan: *mut ::kernel::sys::raw::c_void,
                           mtx: *mut mtx,
                           wmesg: *const ::kernel::sys::raw::c_char,
                           sbt: sbintime_t, pr: sbintime_t,
                           flags: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn pause_sbt(wmesg: *const ::kernel::sys::raw::c_char,
                     sbt: sbintime_t, pr: sbintime_t,
                     flags: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn wakeup(chan: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn wakeup_one(chan: *mut ::kernel::sys::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cdev {
    _unused: [u8; 0],
}
extern "C" {
    pub fn dev2udev(x: *mut cdev) -> dev_t;
}
extern "C" {
    pub fn devtoname(cdev: *mut cdev) -> *const ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn devfs_iosize_max() -> usize;
}
extern "C" {
    pub fn iosize_max() -> usize;
}
extern "C" {
    pub fn poll_no_poll(events: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn DELAY(usec: ::kernel::sys::raw::c_int);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct root_hold_token {
    _unused: [u8; 0],
}
extern "C" {
    pub fn root_mount_hold(identifier: *const ::kernel::sys::raw::c_char)
     -> *mut root_hold_token;
}
extern "C" {
    pub fn root_mount_rel(h: *mut root_hold_token);
}
extern "C" {
    pub fn root_mounted() -> ::kernel::sys::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct unrhdr {
    _unused: [u8; 0],
}
extern "C" {
    pub fn new_unrhdr(low: ::kernel::sys::raw::c_int,
                      high: ::kernel::sys::raw::c_int, mutex: *mut mtx)
     -> *mut unrhdr;
}
extern "C" {
    pub fn init_unrhdr(uh: *mut unrhdr, low: ::kernel::sys::raw::c_int,
                       high: ::kernel::sys::raw::c_int, mutex: *mut mtx);
}
extern "C" {
    pub fn delete_unrhdr(uh: *mut unrhdr);
}
extern "C" {
    pub fn clear_unrhdr(uh: *mut unrhdr);
}
extern "C" {
    pub fn clean_unrhdr(uh: *mut unrhdr);
}
extern "C" {
    pub fn clean_unrhdrl(uh: *mut unrhdr);
}
extern "C" {
    pub fn alloc_unr(uh: *mut unrhdr) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn alloc_unr_specific(uh: *mut unrhdr, item: u_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn alloc_unrl(uh: *mut unrhdr) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn free_unr(uh: *mut unrhdr, item: u_int);
}
extern "C" {
    pub fn intr_prof_stack_use(td: *mut thread, frame: *mut trapframe);
}
extern "C" {
    pub fn counted_warning(counter: *mut ::kernel::sys::raw::c_uint,
                           msg: *const ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn _gone_in(major: ::kernel::sys::raw::c_int,
                    msg: *const ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn _gone_in_dev(dev: *mut device, major: ::kernel::sys::raw::c_int,
                        msg: *const ::kernel::sys::raw::c_char);
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct timezone {
    pub tz_minuteswest: ::kernel::sys::raw::c_int,
    pub tz_dsttime: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_timezone() {
    assert_eq!(::core::mem::size_of::<timezone>() , 8usize , concat ! (
               "Size of: " , stringify ! ( timezone ) ));
    assert_eq! (::core::mem::align_of::<timezone>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( timezone ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timezone ) ) . tz_minuteswest as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timezone ) , "::" ,
                stringify ! ( tz_minuteswest ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timezone ) ) . tz_dsttime as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( timezone ) , "::" ,
                stringify ! ( tz_dsttime ) ));
}
impl Clone for timezone {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct bintime {
    pub sec: time_t,
    pub frac: u64,
}
#[test]
fn bindgen_test_layout_bintime() {
    assert_eq!(::core::mem::size_of::<bintime>() , 16usize , concat ! (
               "Size of: " , stringify ! ( bintime ) ));
    assert_eq! (::core::mem::align_of::<bintime>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( bintime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bintime ) ) . sec as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( bintime ) , "::" ,
                stringify ! ( sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bintime ) ) . frac as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( bintime ) , "::" ,
                stringify ! ( frac ) ));
}
impl Clone for bintime {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
#[test]
fn bindgen_test_layout_itimerval() {
    assert_eq!(::core::mem::size_of::<itimerval>() , 32usize , concat ! (
               "Size of: " , stringify ! ( itimerval ) ));
    assert_eq! (::core::mem::align_of::<itimerval>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( itimerval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerval ) ) . it_interval as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerval ) , "::" ,
                stringify ! ( it_interval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerval ) ) . it_value as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerval ) , "::" ,
                stringify ! ( it_value ) ));
}
impl Clone for itimerval {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct clockinfo {
    pub hz: ::kernel::sys::raw::c_int,
    pub tick: ::kernel::sys::raw::c_int,
    pub spare: ::kernel::sys::raw::c_int,
    pub stathz: ::kernel::sys::raw::c_int,
    pub profhz: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_clockinfo() {
    assert_eq!(::core::mem::size_of::<clockinfo>() , 20usize , concat ! (
               "Size of: " , stringify ! ( clockinfo ) ));
    assert_eq! (::core::mem::align_of::<clockinfo>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( clockinfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clockinfo ) ) . hz as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( clockinfo ) , "::" ,
                stringify ! ( hz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clockinfo ) ) . tick as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( clockinfo ) , "::" ,
                stringify ! ( tick ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clockinfo ) ) . spare as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( clockinfo ) , "::" ,
                stringify ! ( spare ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clockinfo ) ) . stathz as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( clockinfo ) , "::" ,
                stringify ! ( stathz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clockinfo ) ) . profhz as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( clockinfo ) , "::" ,
                stringify ! ( profhz ) ));
}
impl Clone for clockinfo {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn inittodr(base: time_t);
}
extern "C" {
    pub fn resettodr();
}
extern "C" {
    #[link_name = "time_second"]
    pub static mut time_second: time_t;
}
extern "C" {
    #[link_name = "time_uptime"]
    pub static mut time_uptime: time_t;
}
extern "C" {
    #[link_name = "tc_tick_bt"]
    pub static mut tc_tick_bt: bintime;
}
extern "C" {
    #[link_name = "tc_tick_sbt"]
    pub static mut tc_tick_sbt: sbintime_t;
}
extern "C" {
    #[link_name = "tick_bt"]
    pub static mut tick_bt: bintime;
}
extern "C" {
    #[link_name = "tick_sbt"]
    pub static mut tick_sbt: sbintime_t;
}
extern "C" {
    #[link_name = "tc_precexp"]
    pub static mut tc_precexp: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "tc_timepercentage"]
    pub static mut tc_timepercentage: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "bt_timethreshold"]
    pub static mut bt_timethreshold: bintime;
}
extern "C" {
    #[link_name = "bt_tickthreshold"]
    pub static mut bt_tickthreshold: bintime;
}
extern "C" {
    #[link_name = "sbt_timethreshold"]
    pub static mut sbt_timethreshold: sbintime_t;
}
extern "C" {
    #[link_name = "sbt_tickthreshold"]
    pub static mut sbt_tickthreshold: sbintime_t;
}
extern "C" {
    #[link_name = "rtc_generation"]
    pub static mut rtc_generation: ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn binuptime(bt: *mut bintime);
}
extern "C" {
    pub fn nanouptime(tsp: *mut timespec);
}
extern "C" {
    pub fn microuptime(tvp: *mut timeval);
}
extern "C" {
    pub fn bintime(bt: *mut bintime);
}
extern "C" {
    pub fn nanotime(tsp: *mut timespec);
}
extern "C" {
    pub fn microtime(tvp: *mut timeval);
}
extern "C" {
    pub fn getbinuptime(bt: *mut bintime);
}
extern "C" {
    pub fn getnanouptime(tsp: *mut timespec);
}
extern "C" {
    pub fn getmicrouptime(tvp: *mut timeval);
}
extern "C" {
    pub fn getbintime(bt: *mut bintime);
}
extern "C" {
    pub fn getnanotime(tsp: *mut timespec);
}
extern "C" {
    pub fn getmicrotime(tvp: *mut timeval);
}
extern "C" {
    pub fn getboottime(boottime: *mut timeval);
}
extern "C" {
    pub fn getboottimebin(boottimebin: *mut bintime);
}
extern "C" {
    pub fn itimerdecr(itp: *mut itimerval, usec: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn itimerfix(tv: *mut timeval) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn ppsratecheck(arg1: *mut timeval,
                        arg2: *mut ::kernel::sys::raw::c_int,
                        arg3: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn ratecheck(arg1: *mut timeval, arg2: *const timeval)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn timevaladd(t1: *mut timeval, t2: *const timeval);
}
extern "C" {
    pub fn timevalsub(t1: *mut timeval, t2: *const timeval);
}
extern "C" {
    pub fn tvtohz(tv: *mut timeval) -> ::kernel::sys::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct priority {
    pub pri_class: u_char,
    pub pri_level: u_char,
    pub pri_native: u_char,
    pub pri_user: u_char,
}
#[test]
fn bindgen_test_layout_priority() {
    assert_eq!(::core::mem::size_of::<priority>() , 4usize , concat ! (
               "Size of: " , stringify ! ( priority ) ));
    assert_eq! (::core::mem::align_of::<priority>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( priority ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const priority ) ) . pri_class as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( priority ) , "::" ,
                stringify ! ( pri_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const priority ) ) . pri_level as * const _ as
                usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( priority ) , "::" ,
                stringify ! ( pri_level ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const priority ) ) . pri_native as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( priority ) , "::" ,
                stringify ! ( pri_native ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const priority ) ) . pri_user as * const _ as
                usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( priority ) , "::" ,
                stringify ! ( pri_user ) ));
}
impl Clone for priority {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn htonl(arg1: __uint32_t) -> __uint32_t;
}
extern "C" {
    pub fn htons(arg1: __uint16_t) -> __uint16_t;
}
extern "C" {
    pub fn ntohl(arg1: __uint32_t) -> __uint32_t;
}
extern "C" {
    pub fn ntohs(arg1: __uint16_t) -> __uint16_t;
}
#[repr(C)]
#[derive(Copy)]
pub struct mtx_padalign {
    pub lock_object: lock_object,
    pub mtx_lock: usize,
    pub __bindgen_padding_0: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_mtx_padalign() {
    assert_eq!(::core::mem::size_of::<mtx_padalign>() , 64usize , concat ! (
               "Size of: " , stringify ! ( mtx_padalign ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mtx_padalign ) ) . lock_object as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mtx_padalign ) , "::" ,
                stringify ! ( lock_object ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mtx_padalign ) ) . mtx_lock as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( mtx_padalign ) , "::" ,
                stringify ! ( mtx_lock ) ));
}
impl Clone for mtx_padalign {
    fn clone(&self) -> Self { *self }
}
impl Default for mtx_padalign {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for mtx_padalign {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "mtx_padalign {{ lock_object: {:?}, mtx_lock: {:?} }}" ,
               self . lock_object , self . mtx_lock)
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct malloc_type_stats {
    pub mts_memalloced: u64,
    pub mts_memfreed: u64,
    pub mts_numallocs: u64,
    pub mts_numfrees: u64,
    pub mts_size: u64,
    pub _mts_reserved1: u64,
    pub _mts_reserved2: u64,
    pub _mts_reserved3: u64,
}
#[test]
fn bindgen_test_layout_malloc_type_stats() {
    assert_eq!(::core::mem::size_of::<malloc_type_stats>() , 64usize , concat
               ! ( "Size of: " , stringify ! ( malloc_type_stats ) ));
    assert_eq! (::core::mem::align_of::<malloc_type_stats>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( malloc_type_stats ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type_stats ) ) . mts_memalloced as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_type_stats ) ,
                "::" , stringify ! ( mts_memalloced ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type_stats ) ) . mts_memfreed as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_type_stats ) ,
                "::" , stringify ! ( mts_memfreed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type_stats ) ) . mts_numallocs as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_type_stats ) ,
                "::" , stringify ! ( mts_numallocs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type_stats ) ) . mts_numfrees as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_type_stats ) ,
                "::" , stringify ! ( mts_numfrees ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type_stats ) ) . mts_size as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_type_stats ) ,
                "::" , stringify ! ( mts_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type_stats ) ) . _mts_reserved1 as
                * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_type_stats ) ,
                "::" , stringify ! ( _mts_reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type_stats ) ) . _mts_reserved2 as
                * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_type_stats ) ,
                "::" , stringify ! ( _mts_reserved2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type_stats ) ) . _mts_reserved3 as
                * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_type_stats ) ,
                "::" , stringify ! ( _mts_reserved3 ) ));
}
impl Clone for malloc_type_stats {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct malloc_type_internal {
    pub mti_probes: [u32; 2usize],
    pub mti_zone: u_char,
    pub mti_stats: [malloc_type_stats; 256usize],
}
#[test]
fn bindgen_test_layout_malloc_type_internal() {
    assert_eq!(::core::mem::size_of::<malloc_type_internal>() , 16400usize ,
               concat ! ( "Size of: " , stringify ! ( malloc_type_internal )
               ));
    assert_eq! (::core::mem::align_of::<malloc_type_internal>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( malloc_type_internal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type_internal ) ) . mti_probes as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_type_internal )
                , "::" , stringify ! ( mti_probes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type_internal ) ) . mti_zone as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_type_internal )
                , "::" , stringify ! ( mti_zone ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type_internal ) ) . mti_stats as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_type_internal )
                , "::" , stringify ! ( mti_stats ) ));
}
impl Clone for malloc_type_internal {
    fn clone(&self) -> Self { *self }
}
impl Default for malloc_type_internal {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for malloc_type_internal {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "malloc_type_internal {{ mti_probes: {:?}, mti_zone: {:?}, mti_stats: [{}] }}"
               , self . mti_probes , self . mti_zone , self . mti_stats . iter
               (  ) . enumerate (  ) . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ))
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct malloc_type_stream_header {
    pub mtsh_version: u32,
    pub mtsh_maxcpus: u32,
    pub mtsh_count: u32,
    pub _mtsh_pad: u32,
}
#[test]
fn bindgen_test_layout_malloc_type_stream_header() {
    assert_eq!(::core::mem::size_of::<malloc_type_stream_header>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( malloc_type_stream_header ) ));
    assert_eq! (::core::mem::align_of::<malloc_type_stream_header>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( malloc_type_stream_header )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type_stream_header ) ) .
                mtsh_version as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                malloc_type_stream_header ) , "::" , stringify ! (
                mtsh_version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type_stream_header ) ) .
                mtsh_maxcpus as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                malloc_type_stream_header ) , "::" , stringify ! (
                mtsh_maxcpus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type_stream_header ) ) .
                mtsh_count as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                malloc_type_stream_header ) , "::" , stringify ! ( mtsh_count
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type_stream_header ) ) . _mtsh_pad
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                malloc_type_stream_header ) , "::" , stringify ! ( _mtsh_pad )
                ));
}
impl Clone for malloc_type_stream_header {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct malloc_type_header {
    pub mth_name: [::kernel::sys::raw::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_malloc_type_header() {
    assert_eq!(::core::mem::size_of::<malloc_type_header>() , 32usize , concat
               ! ( "Size of: " , stringify ! ( malloc_type_header ) ));
    assert_eq! (::core::mem::align_of::<malloc_type_header>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( malloc_type_header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type_header ) ) . mth_name as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_type_header ) ,
                "::" , stringify ! ( mth_name ) ));
}
impl Clone for malloc_type_header {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "M_CACHE"]
    pub static mut M_CACHE: [malloc_type; 1usize];
}
extern "C" {
    #[link_name = "M_DEVBUF"]
    pub static mut M_DEVBUF: [malloc_type; 1usize];
}
extern "C" {
    #[link_name = "M_TEMP"]
    pub static mut M_TEMP: [malloc_type; 1usize];
}
extern "C" {
    #[link_name = "M_IOV"]
    pub static mut M_IOV: [malloc_type; 1usize];
}
extern "C" {
    #[link_name = "malloc_mtx"]
    pub static mut malloc_mtx: mtx;
}
pub type malloc_type_list_func_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut malloc_type,
                                                arg2:
                                                    *mut ::kernel::sys::raw::c_void)>;
extern "C" {
    pub fn contigfree(addr: *mut ::kernel::sys::raw::c_void,
                      size: ::kernel::sys::raw::c_ulong,
                      type_: *mut malloc_type);
}
extern "C" {
    pub fn contigmalloc(size: ::kernel::sys::raw::c_ulong,
                        type_: *mut malloc_type,
                        flags: ::kernel::sys::raw::c_int, low: vm_paddr_t,
                        high: vm_paddr_t,
                        alignment: ::kernel::sys::raw::c_ulong,
                        boundary: vm_paddr_t)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn contigmalloc_domain(size: ::kernel::sys::raw::c_ulong,
                               type_: *mut malloc_type,
                               domain: ::kernel::sys::raw::c_int,
                               flags: ::kernel::sys::raw::c_int,
                               low: vm_paddr_t, high: vm_paddr_t,
                               alignment: ::kernel::sys::raw::c_ulong,
                               boundary: vm_paddr_t)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn free(addr: *mut ::kernel::sys::raw::c_void,
                type_: *mut malloc_type);
}
extern "C" {
    pub fn free_domain(addr: *mut ::kernel::sys::raw::c_void,
                       type_: *mut malloc_type);
}
extern "C" {
    pub fn malloc(size: usize, type_: *mut malloc_type,
                  flags: ::kernel::sys::raw::c_int)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn malloc_domain(size: usize, type_: *mut malloc_type,
                         domain: ::kernel::sys::raw::c_int,
                         flags: ::kernel::sys::raw::c_int)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn mallocarray(nmemb: usize, size: usize, type_: *mut malloc_type,
                       flags: ::kernel::sys::raw::c_int)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn malloc_init(arg1: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn malloc_last_fail() -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn malloc_type_allocated(type_: *mut malloc_type,
                                 size: ::kernel::sys::raw::c_ulong);
}
extern "C" {
    pub fn malloc_type_freed(type_: *mut malloc_type,
                             size: ::kernel::sys::raw::c_ulong);
}
extern "C" {
    pub fn malloc_type_list(arg1: malloc_type_list_func_t,
                            arg2: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn malloc_uninit(arg1: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn realloc(addr: *mut ::kernel::sys::raw::c_void, size: usize,
                   type_: *mut malloc_type, flags: ::kernel::sys::raw::c_int)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn reallocf(addr: *mut ::kernel::sys::raw::c_void, size: usize,
                    type_: *mut malloc_type, flags: ::kernel::sys::raw::c_int)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn malloc_desc2type(desc: *const ::kernel::sys::raw::c_char)
     -> *mut malloc_type;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uma_zone {
    _unused: [u8; 0],
}
pub type uma_zone_t = *mut uma_zone;
extern "C" {
    pub fn zone_drain(arg1: uma_zone_t);
}
pub type uma_ctor =
    ::core::option::Option<unsafe extern "C" fn(mem:
                                                    *mut ::kernel::sys::raw::c_void,
                                                size:
                                                    ::kernel::sys::raw::c_int,
                                                arg:
                                                    *mut ::kernel::sys::raw::c_void,
                                                flags:
                                                    ::kernel::sys::raw::c_int)
                               -> ::kernel::sys::raw::c_int>;
pub type uma_dtor =
    ::core::option::Option<unsafe extern "C" fn(mem:
                                                    *mut ::kernel::sys::raw::c_void,
                                                size:
                                                    ::kernel::sys::raw::c_int,
                                                arg:
                                                    *mut ::kernel::sys::raw::c_void)>;
pub type uma_init =
    ::core::option::Option<unsafe extern "C" fn(mem:
                                                    *mut ::kernel::sys::raw::c_void,
                                                size:
                                                    ::kernel::sys::raw::c_int,
                                                flags:
                                                    ::kernel::sys::raw::c_int)
                               -> ::kernel::sys::raw::c_int>;
pub type uma_fini =
    ::core::option::Option<unsafe extern "C" fn(mem:
                                                    *mut ::kernel::sys::raw::c_void,
                                                size:
                                                    ::kernel::sys::raw::c_int)>;
pub type uma_import =
    ::core::option::Option<unsafe extern "C" fn(arg:
                                                    *mut ::kernel::sys::raw::c_void,
                                                store:
                                                    *mut *mut ::kernel::sys::raw::c_void,
                                                count:
                                                    ::kernel::sys::raw::c_int,
                                                domain:
                                                    ::kernel::sys::raw::c_int,
                                                flags:
                                                    ::kernel::sys::raw::c_int)
                               -> ::kernel::sys::raw::c_int>;
pub type uma_release =
    ::core::option::Option<unsafe extern "C" fn(arg:
                                                    *mut ::kernel::sys::raw::c_void,
                                                store:
                                                    *mut *mut ::kernel::sys::raw::c_void,
                                                count:
                                                    ::kernel::sys::raw::c_int)>;
extern "C" {
    pub fn uma_zcreate(name: *const ::kernel::sys::raw::c_char, size: usize,
                       ctor: uma_ctor, dtor: uma_dtor, uminit: uma_init,
                       fini: uma_fini, align: ::kernel::sys::raw::c_int,
                       flags: u32) -> uma_zone_t;
}
extern "C" {
    pub fn uma_zsecond_create(name: *mut ::kernel::sys::raw::c_char,
                              ctor: uma_ctor, dtor: uma_dtor, zinit: uma_init,
                              zfini: uma_fini, master: uma_zone_t)
     -> uma_zone_t;
}
extern "C" {
    pub fn uma_zsecond_add(zone: uma_zone_t, master: uma_zone_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn uma_zcache_create(name: *mut ::kernel::sys::raw::c_char,
                             size: ::kernel::sys::raw::c_int, ctor: uma_ctor,
                             dtor: uma_dtor, zinit: uma_init, zfini: uma_fini,
                             zimport: uma_import, zrelease: uma_release,
                             arg: *mut ::kernel::sys::raw::c_void,
                             flags: ::kernel::sys::raw::c_int) -> uma_zone_t;
}
extern "C" {
    pub fn uma_zdestroy(zone: uma_zone_t);
}
extern "C" {
    pub fn uma_zalloc_arg(zone: uma_zone_t,
                          arg: *mut ::kernel::sys::raw::c_void,
                          flags: ::kernel::sys::raw::c_int)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn uma_zalloc_domain(zone: uma_zone_t,
                             arg: *mut ::kernel::sys::raw::c_void,
                             domain: ::kernel::sys::raw::c_int,
                             flags: ::kernel::sys::raw::c_int)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn uma_zfree_arg(zone: uma_zone_t,
                         item: *mut ::kernel::sys::raw::c_void,
                         arg: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn uma_zfree_domain(zone: uma_zone_t,
                            item: *mut ::kernel::sys::raw::c_void,
                            arg: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn uma_zwait(zone: uma_zone_t);
}
pub type uma_alloc =
    ::core::option::Option<unsafe extern "C" fn(zone: uma_zone_t,
                                                size: vm_size_t,
                                                domain:
                                                    ::kernel::sys::raw::c_int,
                                                pflag: *mut u8,
                                                wait:
                                                    ::kernel::sys::raw::c_int)
                               -> *mut ::kernel::sys::raw::c_void>;
pub type uma_free =
    ::core::option::Option<unsafe extern "C" fn(item:
                                                    *mut ::kernel::sys::raw::c_void,
                                                size: vm_size_t, pflag: u8)>;
extern "C" {
    pub fn uma_reclaim();
}
extern "C" {
    pub fn uma_set_align(align: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn uma_zone_reserve(zone: uma_zone_t,
                            nitems: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn uma_zone_reserve_kva(zone: uma_zone_t,
                                nitems: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn uma_zone_set_max(zone: uma_zone_t,
                            nitems: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn uma_zone_get_max(zone: uma_zone_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn uma_zone_set_warning(zone: uma_zone_t,
                                warning: *const ::kernel::sys::raw::c_char);
}
pub type uma_maxaction_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: uma_zone_t,
                                                arg2:
                                                    ::kernel::sys::raw::c_int)>;
extern "C" {
    pub fn uma_zone_set_maxaction(zone: uma_zone_t, arg1: uma_maxaction_t);
}
extern "C" {
    pub fn uma_zone_get_cur(zone: uma_zone_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn uma_zone_set_init(zone: uma_zone_t, uminit: uma_init);
}
extern "C" {
    pub fn uma_zone_set_fini(zone: uma_zone_t, fini: uma_fini);
}
extern "C" {
    pub fn uma_zone_set_zinit(zone: uma_zone_t, zinit: uma_init);
}
extern "C" {
    pub fn uma_zone_set_zfini(zone: uma_zone_t, zfini: uma_fini);
}
extern "C" {
    pub fn uma_zone_set_allocf(zone: uma_zone_t, allocf: uma_alloc);
}
extern "C" {
    pub fn uma_zone_set_freef(zone: uma_zone_t, freef: uma_free);
}
extern "C" {
    pub fn uma_prealloc(zone: uma_zone_t, itemcnt: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn uma_zone_exhausted(zone: uma_zone_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn uma_zone_exhausted_nolock(zone: uma_zone_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "pcpu_zone_64"]
    pub static mut pcpu_zone_64: uma_zone_t;
}
extern "C" {
    #[link_name = "pcpu_zone_ptr"]
    pub static mut pcpu_zone_ptr: uma_zone_t;
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct uma_stream_header {
    pub ush_version: u32,
    pub ush_maxcpus: u32,
    pub ush_count: u32,
    pub _ush_pad: u32,
}
#[test]
fn bindgen_test_layout_uma_stream_header() {
    assert_eq!(::core::mem::size_of::<uma_stream_header>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( uma_stream_header ) ));
    assert_eq! (::core::mem::align_of::<uma_stream_header>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( uma_stream_header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_stream_header ) ) . ush_version as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_stream_header ) ,
                "::" , stringify ! ( ush_version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_stream_header ) ) . ush_maxcpus as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_stream_header ) ,
                "::" , stringify ! ( ush_maxcpus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_stream_header ) ) . ush_count as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_stream_header ) ,
                "::" , stringify ! ( ush_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_stream_header ) ) . _ush_pad as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_stream_header ) ,
                "::" , stringify ! ( _ush_pad ) ));
}
impl Clone for uma_stream_header {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct uma_type_header {
    pub uth_name: [::kernel::sys::raw::c_char; 32usize],
    pub uth_align: u32,
    pub uth_size: u32,
    pub uth_rsize: u32,
    pub uth_maxpages: u32,
    pub uth_limit: u32,
    pub uth_pages: u32,
    pub uth_keg_free: u32,
    pub uth_zone_free: u32,
    pub uth_bucketsize: u32,
    pub uth_zone_flags: u32,
    pub uth_allocs: u64,
    pub uth_frees: u64,
    pub uth_fails: u64,
    pub uth_sleeps: u64,
    pub _uth_reserved1: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_uma_type_header() {
    assert_eq!(::core::mem::size_of::<uma_type_header>() , 120usize , concat !
               ( "Size of: " , stringify ! ( uma_type_header ) ));
    assert_eq! (::core::mem::align_of::<uma_type_header>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( uma_type_header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_type_header ) ) . uth_name as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_type_header ) ,
                "::" , stringify ! ( uth_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_type_header ) ) . uth_align as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_type_header ) ,
                "::" , stringify ! ( uth_align ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_type_header ) ) . uth_size as * const
                _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_type_header ) ,
                "::" , stringify ! ( uth_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_type_header ) ) . uth_rsize as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_type_header ) ,
                "::" , stringify ! ( uth_rsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_type_header ) ) . uth_maxpages as *
                const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_type_header ) ,
                "::" , stringify ! ( uth_maxpages ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_type_header ) ) . uth_limit as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_type_header ) ,
                "::" , stringify ! ( uth_limit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_type_header ) ) . uth_pages as *
                const _ as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_type_header ) ,
                "::" , stringify ! ( uth_pages ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_type_header ) ) . uth_keg_free as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_type_header ) ,
                "::" , stringify ! ( uth_keg_free ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_type_header ) ) . uth_zone_free as *
                const _ as usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_type_header ) ,
                "::" , stringify ! ( uth_zone_free ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_type_header ) ) . uth_bucketsize as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_type_header ) ,
                "::" , stringify ! ( uth_bucketsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_type_header ) ) . uth_zone_flags as *
                const _ as usize } , 68usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_type_header ) ,
                "::" , stringify ! ( uth_zone_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_type_header ) ) . uth_allocs as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_type_header ) ,
                "::" , stringify ! ( uth_allocs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_type_header ) ) . uth_frees as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_type_header ) ,
                "::" , stringify ! ( uth_frees ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_type_header ) ) . uth_fails as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_type_header ) ,
                "::" , stringify ! ( uth_fails ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_type_header ) ) . uth_sleeps as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_type_header ) ,
                "::" , stringify ! ( uth_sleeps ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_type_header ) ) . _uth_reserved1 as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_type_header ) ,
                "::" , stringify ! ( _uth_reserved1 ) ));
}
impl Clone for uma_type_header {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct uma_percpu_stat {
    pub ups_allocs: u64,
    pub ups_frees: u64,
    pub ups_cache_free: u64,
    pub _ups_reserved: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_uma_percpu_stat() {
    assert_eq!(::core::mem::size_of::<uma_percpu_stat>() , 64usize , concat !
               ( "Size of: " , stringify ! ( uma_percpu_stat ) ));
    assert_eq! (::core::mem::align_of::<uma_percpu_stat>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( uma_percpu_stat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_percpu_stat ) ) . ups_allocs as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_percpu_stat ) ,
                "::" , stringify ! ( ups_allocs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_percpu_stat ) ) . ups_frees as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_percpu_stat ) ,
                "::" , stringify ! ( ups_frees ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_percpu_stat ) ) . ups_cache_free as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_percpu_stat ) ,
                "::" , stringify ! ( ups_cache_free ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_percpu_stat ) ) . _ups_reserved as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_percpu_stat ) ,
                "::" , stringify ! ( _ups_reserved ) ));
}
impl Clone for uma_percpu_stat {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn uma_reclaim_wakeup();
}
extern "C" {
    pub fn uma_reclaim_worker(arg1: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn uma_limit() -> ::kernel::sys::raw::c_ulong;
}
extern "C" {
    pub fn uma_size() -> ::kernel::sys::raw::c_ulong;
}
extern "C" {
    pub fn uma_avail() -> ::kernel::sys::raw::c_long;
}
extern "C" {
    #[link_name = "sdt_probes_enabled"]
    pub static mut sdt_probes_enabled: bool_;
}
pub type sdt_probe_func_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: u32, arg0: usize,
                                                arg1: usize, arg2: usize,
                                                arg3: usize, arg4: usize)>;
extern "C" {
    #[link_name = "sdt_probe_func"]
    pub static mut sdt_probe_func: sdt_probe_func_t;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sdt_probe {
    pub version: ::kernel::sys::raw::c_int,
    pub prov: *mut sdt_provider,
    pub probe_entry: sdt_probe__bindgen_ty_1,
    pub argtype_list: sdt_probe__bindgen_ty_2,
    pub mod_: *const ::kernel::sys::raw::c_char,
    pub func: *const ::kernel::sys::raw::c_char,
    pub name: *const ::kernel::sys::raw::c_char,
    pub id: id_t,
    pub n_args: ::kernel::sys::raw::c_int,
    pub sdtp_lf: *mut linker_file,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sdt_probe__bindgen_ty_1 {
    pub tqe_next: *mut sdt_probe,
    pub tqe_prev: *mut *mut sdt_probe,
}
#[test]
fn bindgen_test_layout_sdt_probe__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<sdt_probe__bindgen_ty_1>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( sdt_probe__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<sdt_probe__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( sdt_probe__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe__bindgen_ty_1 ) ) . tqe_next as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe__bindgen_ty_1
                ) , "::" , stringify ! ( tqe_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe__bindgen_ty_1 ) ) . tqe_prev as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe__bindgen_ty_1
                ) , "::" , stringify ! ( tqe_prev ) ));
}
impl Clone for sdt_probe__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for sdt_probe__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sdt_probe__bindgen_ty_2 {
    pub tqh_first: *mut sdt_argtype,
    pub tqh_last: *mut *mut sdt_argtype,
}
#[test]
fn bindgen_test_layout_sdt_probe__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<sdt_probe__bindgen_ty_2>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( sdt_probe__bindgen_ty_2 ) ));
    assert_eq! (::core::mem::align_of::<sdt_probe__bindgen_ty_2>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( sdt_probe__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe__bindgen_ty_2 ) ) . tqh_first
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe__bindgen_ty_2
                ) , "::" , stringify ! ( tqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe__bindgen_ty_2 ) ) . tqh_last as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe__bindgen_ty_2
                ) , "::" , stringify ! ( tqh_last ) ));
}
impl Clone for sdt_probe__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for sdt_probe__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_sdt_probe() {
    assert_eq!(::core::mem::size_of::<sdt_probe>() , 96usize , concat ! (
               "Size of: " , stringify ! ( sdt_probe ) ));
    assert_eq! (::core::mem::align_of::<sdt_probe>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sdt_probe ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . version as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . prov as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( prov ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . probe_entry as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( probe_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . argtype_list as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( argtype_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . mod_ as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( mod_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . func as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . name as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . id as * const _ as usize
                } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . n_args as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( n_args ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . sdtp_lf as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( sdtp_lf ) ));
}
impl Clone for sdt_probe {
    fn clone(&self) -> Self { *self }
}
impl Default for sdt_probe {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sdt_provider {
    pub name: *mut ::kernel::sys::raw::c_char,
    pub prov_entry: sdt_provider__bindgen_ty_1,
    pub id: usize,
    pub sdt_refs: ::kernel::sys::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sdt_provider__bindgen_ty_1 {
    pub tqe_next: *mut sdt_provider,
    pub tqe_prev: *mut *mut sdt_provider,
}
#[test]
fn bindgen_test_layout_sdt_provider__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<sdt_provider__bindgen_ty_1>() , 16usize
               , concat ! (
               "Size of: " , stringify ! ( sdt_provider__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<sdt_provider__bindgen_ty_1>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( sdt_provider__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_provider__bindgen_ty_1 ) ) . tqe_next
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                sdt_provider__bindgen_ty_1 ) , "::" , stringify ! ( tqe_next )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_provider__bindgen_ty_1 ) ) . tqe_prev
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                sdt_provider__bindgen_ty_1 ) , "::" , stringify ! ( tqe_prev )
                ));
}
impl Clone for sdt_provider__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for sdt_provider__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_sdt_provider() {
    assert_eq!(::core::mem::size_of::<sdt_provider>() , 40usize , concat ! (
               "Size of: " , stringify ! ( sdt_provider ) ));
    assert_eq! (::core::mem::align_of::<sdt_provider>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sdt_provider ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_provider ) ) . name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_provider ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_provider ) ) . prov_entry as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_provider ) , "::" ,
                stringify ! ( prov_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_provider ) ) . id as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_provider ) , "::" ,
                stringify ! ( id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_provider ) ) . sdt_refs as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_provider ) , "::" ,
                stringify ! ( sdt_refs ) ));
}
impl Clone for sdt_provider {
    fn clone(&self) -> Self { *self }
}
impl Default for sdt_provider {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct linker_file {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sdt_argtype {
    pub ndx: ::kernel::sys::raw::c_int,
    pub type_: *const ::kernel::sys::raw::c_char,
    pub xtype: *const ::kernel::sys::raw::c_char,
    pub argtype_entry: sdt_argtype__bindgen_ty_1,
    pub probe: *mut sdt_probe,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sdt_argtype__bindgen_ty_1 {
    pub tqe_next: *mut sdt_argtype,
    pub tqe_prev: *mut *mut sdt_argtype,
}
#[test]
fn bindgen_test_layout_sdt_argtype__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<sdt_argtype__bindgen_ty_1>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( sdt_argtype__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<sdt_argtype__bindgen_ty_1>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( sdt_argtype__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_argtype__bindgen_ty_1 ) ) . tqe_next
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                sdt_argtype__bindgen_ty_1 ) , "::" , stringify ! ( tqe_next )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_argtype__bindgen_ty_1 ) ) . tqe_prev
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                sdt_argtype__bindgen_ty_1 ) , "::" , stringify ! ( tqe_prev )
                ));
}
impl Clone for sdt_argtype__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for sdt_argtype__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_sdt_argtype() {
    assert_eq!(::core::mem::size_of::<sdt_argtype>() , 48usize , concat ! (
               "Size of: " , stringify ! ( sdt_argtype ) ));
    assert_eq! (::core::mem::align_of::<sdt_argtype>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sdt_argtype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_argtype ) ) . ndx as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_argtype ) , "::" ,
                stringify ! ( ndx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_argtype ) ) . type_ as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_argtype ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_argtype ) ) . xtype as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_argtype ) , "::" ,
                stringify ! ( xtype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_argtype ) ) . argtype_entry as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_argtype ) , "::" ,
                stringify ! ( argtype_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_argtype ) ) . probe as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_argtype ) , "::" ,
                stringify ! ( probe ) ));
}
impl Clone for sdt_argtype {
    fn clone(&self) -> Self { *self }
}
impl Default for sdt_argtype {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    pub fn sdt_probe_stub(arg1: u32, arg2: usize, arg3: usize, arg4: usize,
                          arg5: usize, arg6: usize);
}
#[repr(C)]
pub struct mbuf {
    pub __bindgen_anon_1: mbuf__bindgen_ty_1,
    pub __bindgen_anon_2: mbuf__bindgen_ty_2,
    pub m_data: caddr_t,
    pub m_len: i32,
    pub _bitfield_1: u32,
    pub __bindgen_anon_3: mbuf__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy)]
pub union mbuf__bindgen_ty_1 {
    pub m_next: *mut mbuf,
    pub m_slist: mbuf__bindgen_ty_1__bindgen_ty_1,
    pub m_stailq: mbuf__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mbuf__bindgen_ty_1__bindgen_ty_1 {
    pub sle_next: *mut mbuf,
}
#[test]
fn bindgen_test_layout_mbuf__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<mbuf__bindgen_ty_1__bindgen_ty_1>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( mbuf__bindgen_ty_1__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<mbuf__bindgen_ty_1__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                mbuf__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbuf__bindgen_ty_1__bindgen_ty_1 ) ) .
                sle_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                mbuf__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! (
                sle_next ) ));
}
impl Clone for mbuf__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for mbuf__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mbuf__bindgen_ty_1__bindgen_ty_2 {
    pub stqe_next: *mut mbuf,
}
#[test]
fn bindgen_test_layout_mbuf__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<mbuf__bindgen_ty_1__bindgen_ty_2>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( mbuf__bindgen_ty_1__bindgen_ty_2 )
               ));
    assert_eq! (::core::mem::align_of::<mbuf__bindgen_ty_1__bindgen_ty_2>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                mbuf__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbuf__bindgen_ty_1__bindgen_ty_2 ) ) .
                stqe_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                mbuf__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify ! (
                stqe_next ) ));
}
impl Clone for mbuf__bindgen_ty_1__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for mbuf__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_mbuf__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<mbuf__bindgen_ty_1>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( mbuf__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<mbuf__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( mbuf__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbuf__bindgen_ty_1 ) ) . m_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mbuf__bindgen_ty_1 ) ,
                "::" , stringify ! ( m_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbuf__bindgen_ty_1 ) ) . m_slist as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mbuf__bindgen_ty_1 ) ,
                "::" , stringify ! ( m_slist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbuf__bindgen_ty_1 ) ) . m_stailq as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mbuf__bindgen_ty_1 ) ,
                "::" , stringify ! ( m_stailq ) ));
}
impl Clone for mbuf__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for mbuf__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for mbuf__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "mbuf__bindgen_ty_1 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy)]
pub union mbuf__bindgen_ty_2 {
    pub m_nextpkt: *mut mbuf,
    pub m_slistpkt: mbuf__bindgen_ty_2__bindgen_ty_1,
    pub m_stailqpkt: mbuf__bindgen_ty_2__bindgen_ty_2,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mbuf__bindgen_ty_2__bindgen_ty_1 {
    pub sle_next: *mut mbuf,
}
#[test]
fn bindgen_test_layout_mbuf__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<mbuf__bindgen_ty_2__bindgen_ty_1>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( mbuf__bindgen_ty_2__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<mbuf__bindgen_ty_2__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                mbuf__bindgen_ty_2__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbuf__bindgen_ty_2__bindgen_ty_1 ) ) .
                sle_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                mbuf__bindgen_ty_2__bindgen_ty_1 ) , "::" , stringify ! (
                sle_next ) ));
}
impl Clone for mbuf__bindgen_ty_2__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for mbuf__bindgen_ty_2__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mbuf__bindgen_ty_2__bindgen_ty_2 {
    pub stqe_next: *mut mbuf,
}
#[test]
fn bindgen_test_layout_mbuf__bindgen_ty_2__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<mbuf__bindgen_ty_2__bindgen_ty_2>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( mbuf__bindgen_ty_2__bindgen_ty_2 )
               ));
    assert_eq! (::core::mem::align_of::<mbuf__bindgen_ty_2__bindgen_ty_2>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                mbuf__bindgen_ty_2__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbuf__bindgen_ty_2__bindgen_ty_2 ) ) .
                stqe_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                mbuf__bindgen_ty_2__bindgen_ty_2 ) , "::" , stringify ! (
                stqe_next ) ));
}
impl Clone for mbuf__bindgen_ty_2__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for mbuf__bindgen_ty_2__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_mbuf__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<mbuf__bindgen_ty_2>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( mbuf__bindgen_ty_2 ) ));
    assert_eq! (::core::mem::align_of::<mbuf__bindgen_ty_2>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( mbuf__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbuf__bindgen_ty_2 ) ) . m_nextpkt as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mbuf__bindgen_ty_2 ) ,
                "::" , stringify ! ( m_nextpkt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbuf__bindgen_ty_2 ) ) . m_slistpkt as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mbuf__bindgen_ty_2 ) ,
                "::" , stringify ! ( m_slistpkt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbuf__bindgen_ty_2 ) ) . m_stailqpkt as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mbuf__bindgen_ty_2 ) ,
                "::" , stringify ! ( m_stailqpkt ) ));
}
impl Clone for mbuf__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for mbuf__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for mbuf__bindgen_ty_2 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "mbuf__bindgen_ty_2 {{ union }}")
    }
}
#[repr(C)]
pub struct mbuf__bindgen_ty_3 {
    pub __bindgen_anon_1: __BindgenUnionField<mbuf__bindgen_ty_3__bindgen_ty_1>,
    pub m_dat: __BindgenUnionField<[::kernel::sys::raw::c_char; 0usize]>,
    pub bindgen_union_field: [u64; 13usize],
}
#[repr(C)]
pub struct mbuf__bindgen_ty_3__bindgen_ty_1 {
    pub m_pkthdr: pkthdr,
    pub __bindgen_anon_1: mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
pub struct mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {
    pub m_ext: __BindgenUnionField<m_ext>,
    pub m_pktdat: __BindgenUnionField<[::kernel::sys::raw::c_char; 0usize]>,
    pub bindgen_union_field: [u64; 6usize],
}
#[test]
fn bindgen_test_layout_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1>()
               , 48usize , concat ! (
               "Size of: " , stringify ! (
               mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 )
                ) . m_ext as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( m_ext ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 )
                ) . m_pktdat as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( m_pktdat ) ));
}
impl Default for mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_mbuf__bindgen_ty_3__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<mbuf__bindgen_ty_3__bindgen_ty_1>() ,
               104usize , concat ! (
               "Size of: " , stringify ! ( mbuf__bindgen_ty_3__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<mbuf__bindgen_ty_3__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                mbuf__bindgen_ty_3__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbuf__bindgen_ty_3__bindgen_ty_1 ) ) .
                m_pkthdr as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                mbuf__bindgen_ty_3__bindgen_ty_1 ) , "::" , stringify ! (
                m_pkthdr ) ));
}
impl Default for mbuf__bindgen_ty_3__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for mbuf__bindgen_ty_3__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "mbuf__bindgen_ty_3__bindgen_ty_1 {{ m_pkthdr: {:?} }}" ,
               self . m_pkthdr)
    }
}
#[test]
fn bindgen_test_layout_mbuf__bindgen_ty_3() {
    assert_eq!(::core::mem::size_of::<mbuf__bindgen_ty_3>() , 104usize ,
               concat ! ( "Size of: " , stringify ! ( mbuf__bindgen_ty_3 ) ));
    assert_eq! (::core::mem::align_of::<mbuf__bindgen_ty_3>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( mbuf__bindgen_ty_3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbuf__bindgen_ty_3 ) ) . m_dat as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mbuf__bindgen_ty_3 ) ,
                "::" , stringify ! ( m_dat ) ));
}
impl Default for mbuf__bindgen_ty_3 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for mbuf__bindgen_ty_3 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "mbuf__bindgen_ty_3 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_mbuf() {
    assert_eq!(::core::mem::size_of::<mbuf>() , 136usize , concat ! (
               "Size of: " , stringify ! ( mbuf ) ));
    assert_eq! (::core::mem::align_of::<mbuf>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( mbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbuf ) ) . m_data as * const _ as usize }
                , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mbuf ) , "::" ,
                stringify ! ( m_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbuf ) ) . m_len as * const _ as usize }
                , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( mbuf ) , "::" ,
                stringify ! ( m_len ) ));
}
impl Default for mbuf {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for mbuf {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "mbuf {{ m_data: {:?}, m_len: {:?}, m_type : {:?}, m_flags : {:?} }}"
               , self . m_data , self . m_len , self . m_type (  ) , self .
               m_flags (  ))
    }
}
impl mbuf {
    #[inline]
    pub fn m_type(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u32
                                                 as *mut u8,
                                             ::core::mem::size_of::<u32>())
        };
        let mask = 255u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::core::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_m_type(&mut self, val: u32) {
        let mask = 255u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u32
                                                 as *mut u8,
                                             ::core::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn m_flags(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u32
                                                 as *mut u8,
                                             ::core::mem::size_of::<u32>())
        };
        let mask = 4294967040u64 as u32;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::core::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_m_flags(&mut self, val: u32) {
        let mask = 4294967040u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u32
                                                 as *mut u8,
                                             ::core::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(m_type: u32, m_flags: u32) -> u32 {
        ({ ({ 0 } | ((m_type as u32 as u32) << 0usize) & (255u64 as u32)) } |
             ((m_flags as u32 as u32) << 8usize) & (4294967040u64 as u32))
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct mb_args {
    pub flags: ::kernel::sys::raw::c_int,
    pub type_: ::kernel::sys::raw::c_short,
}
#[test]
fn bindgen_test_layout_mb_args() {
    assert_eq!(::core::mem::size_of::<mb_args>() , 8usize , concat ! (
               "Size of: " , stringify ! ( mb_args ) ));
    assert_eq! (::core::mem::align_of::<mb_args>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( mb_args ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mb_args ) ) . flags as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mb_args ) , "::" ,
                stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mb_args ) ) . type_ as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( mb_args ) , "::" ,
                stringify ! ( type_ ) ));
}
impl Clone for mb_args {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct m_tag {
    pub m_tag_link: m_tag__bindgen_ty_1,
    pub m_tag_id: u_int16_t,
    pub m_tag_len: u_int16_t,
    pub m_tag_cookie: u_int32_t,
    pub m_tag_free: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                    *mut m_tag)>,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct m_tag__bindgen_ty_1 {
    pub sle_next: *mut m_tag,
}
#[test]
fn bindgen_test_layout_m_tag__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<m_tag__bindgen_ty_1>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( m_tag__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<m_tag__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( m_tag__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const m_tag__bindgen_ty_1 ) ) . sle_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( m_tag__bindgen_ty_1 ) ,
                "::" , stringify ! ( sle_next ) ));
}
impl Clone for m_tag__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for m_tag__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_m_tag() {
    assert_eq!(::core::mem::size_of::<m_tag>() , 24usize , concat ! (
               "Size of: " , stringify ! ( m_tag ) ));
    assert_eq! (::core::mem::align_of::<m_tag>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( m_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const m_tag ) ) . m_tag_link as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( m_tag ) , "::" ,
                stringify ! ( m_tag_link ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const m_tag ) ) . m_tag_id as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( m_tag ) , "::" ,
                stringify ! ( m_tag_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const m_tag ) ) . m_tag_len as * const _ as
                usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( m_tag ) , "::" ,
                stringify ! ( m_tag_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const m_tag ) ) . m_tag_cookie as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( m_tag ) , "::" ,
                stringify ! ( m_tag_cookie ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const m_tag ) ) . m_tag_free as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( m_tag ) , "::" ,
                stringify ! ( m_tag_free ) ));
}
impl Clone for m_tag {
    fn clone(&self) -> Self { *self }
}
impl Default for m_tag {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct m_snd_tag {
    pub ifp: *mut ifnet,
}
#[test]
fn bindgen_test_layout_m_snd_tag() {
    assert_eq!(::core::mem::size_of::<m_snd_tag>() , 8usize , concat ! (
               "Size of: " , stringify ! ( m_snd_tag ) ));
    assert_eq! (::core::mem::align_of::<m_snd_tag>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( m_snd_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const m_snd_tag ) ) . ifp as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( m_snd_tag ) , "::" ,
                stringify ! ( ifp ) ));
}
impl Clone for m_snd_tag {
    fn clone(&self) -> Self { *self }
}
impl Default for m_snd_tag {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct pkthdr {
    pub __bindgen_anon_1: pkthdr__bindgen_ty_1,
    pub tags: pkthdr_packet_tags,
    pub len: i32,
    pub flowid: u32,
    pub csum_flags: u32,
    pub fibnum: u16,
    pub cosqos: u8,
    pub rsstype: u8,
    pub __bindgen_anon_2: pkthdr__bindgen_ty_2,
    pub PH_per: pkthdr__bindgen_ty_3,
    pub PH_loc: pkthdr__bindgen_ty_4,
}
#[repr(C)]
#[derive(Copy)]
pub union pkthdr__bindgen_ty_1 {
    pub snd_tag: *mut m_snd_tag,
    pub rcvif: *mut ifnet,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_pkthdr__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<pkthdr__bindgen_ty_1>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( pkthdr__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<pkthdr__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( pkthdr__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_1 ) ) . snd_tag as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr__bindgen_ty_1 )
                , "::" , stringify ! ( snd_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_1 ) ) . rcvif as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr__bindgen_ty_1 )
                , "::" , stringify ! ( rcvif ) ));
}
impl Clone for pkthdr__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for pkthdr__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for pkthdr__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "pkthdr__bindgen_ty_1 {{ union }}")
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pkthdr_packet_tags {
    pub slh_first: *mut m_tag,
}
#[test]
fn bindgen_test_layout_pkthdr_packet_tags() {
    assert_eq!(::core::mem::size_of::<pkthdr_packet_tags>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( pkthdr_packet_tags ) ));
    assert_eq! (::core::mem::align_of::<pkthdr_packet_tags>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( pkthdr_packet_tags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr_packet_tags ) ) . slh_first as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr_packet_tags ) ,
                "::" , stringify ! ( slh_first ) ));
}
impl Clone for pkthdr_packet_tags {
    fn clone(&self) -> Self { *self }
}
impl Default for pkthdr_packet_tags {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub union pkthdr__bindgen_ty_2 {
    pub rcv_tstmp: u64,
    pub __bindgen_anon_1: pkthdr__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct pkthdr__bindgen_ty_2__bindgen_ty_1 {
    pub l2hlen: u8,
    pub l3hlen: u8,
    pub l4hlen: u8,
    pub l5hlen: u8,
    pub spare: u32,
}
#[test]
fn bindgen_test_layout_pkthdr__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<pkthdr__bindgen_ty_2__bindgen_ty_1>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( pkthdr__bindgen_ty_2__bindgen_ty_1
               ) ));
    assert_eq! (::core::mem::align_of::<pkthdr__bindgen_ty_2__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                pkthdr__bindgen_ty_2__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_2__bindgen_ty_1 ) ) .
                l2hlen as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pkthdr__bindgen_ty_2__bindgen_ty_1 ) , "::" , stringify ! (
                l2hlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_2__bindgen_ty_1 ) ) .
                l3hlen as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                pkthdr__bindgen_ty_2__bindgen_ty_1 ) , "::" , stringify ! (
                l3hlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_2__bindgen_ty_1 ) ) .
                l4hlen as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                pkthdr__bindgen_ty_2__bindgen_ty_1 ) , "::" , stringify ! (
                l4hlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_2__bindgen_ty_1 ) ) .
                l5hlen as * const _ as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! (
                pkthdr__bindgen_ty_2__bindgen_ty_1 ) , "::" , stringify ! (
                l5hlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_2__bindgen_ty_1 ) ) .
                spare as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                pkthdr__bindgen_ty_2__bindgen_ty_1 ) , "::" , stringify ! (
                spare ) ));
}
impl Clone for pkthdr__bindgen_ty_2__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_pkthdr__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<pkthdr__bindgen_ty_2>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( pkthdr__bindgen_ty_2 )
               ));
    assert_eq! (::core::mem::align_of::<pkthdr__bindgen_ty_2>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( pkthdr__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_2 ) ) . rcv_tstmp as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr__bindgen_ty_2 )
                , "::" , stringify ! ( rcv_tstmp ) ));
}
impl Clone for pkthdr__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for pkthdr__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for pkthdr__bindgen_ty_2 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "pkthdr__bindgen_ty_2 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy)]
pub union pkthdr__bindgen_ty_3 {
    pub eight: [u8; 8usize],
    pub sixteen: [u16; 4usize],
    pub thirtytwo: [u32; 2usize],
    pub sixtyfour: [u64; 1usize],
    pub unintptr: [usize; 1usize],
    pub ptr: *mut ::kernel::sys::raw::c_void,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_pkthdr__bindgen_ty_3() {
    assert_eq!(::core::mem::size_of::<pkthdr__bindgen_ty_3>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( pkthdr__bindgen_ty_3 )
               ));
    assert_eq! (::core::mem::align_of::<pkthdr__bindgen_ty_3>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( pkthdr__bindgen_ty_3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_3 ) ) . eight as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr__bindgen_ty_3 )
                , "::" , stringify ! ( eight ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_3 ) ) . sixteen as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr__bindgen_ty_3 )
                , "::" , stringify ! ( sixteen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_3 ) ) . thirtytwo as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr__bindgen_ty_3 )
                , "::" , stringify ! ( thirtytwo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_3 ) ) . sixtyfour as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr__bindgen_ty_3 )
                , "::" , stringify ! ( sixtyfour ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_3 ) ) . unintptr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr__bindgen_ty_3 )
                , "::" , stringify ! ( unintptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_3 ) ) . ptr as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr__bindgen_ty_3 )
                , "::" , stringify ! ( ptr ) ));
}
impl Clone for pkthdr__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
impl Default for pkthdr__bindgen_ty_3 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for pkthdr__bindgen_ty_3 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "pkthdr__bindgen_ty_3 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy)]
pub union pkthdr__bindgen_ty_4 {
    pub eight: [u8; 8usize],
    pub sixteen: [u16; 4usize],
    pub thirtytwo: [u32; 2usize],
    pub sixtyfour: [u64; 1usize],
    pub unintptr: [usize; 1usize],
    pub ptr: *mut ::kernel::sys::raw::c_void,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_pkthdr__bindgen_ty_4() {
    assert_eq!(::core::mem::size_of::<pkthdr__bindgen_ty_4>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( pkthdr__bindgen_ty_4 )
               ));
    assert_eq! (::core::mem::align_of::<pkthdr__bindgen_ty_4>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( pkthdr__bindgen_ty_4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_4 ) ) . eight as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr__bindgen_ty_4 )
                , "::" , stringify ! ( eight ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_4 ) ) . sixteen as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr__bindgen_ty_4 )
                , "::" , stringify ! ( sixteen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_4 ) ) . thirtytwo as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr__bindgen_ty_4 )
                , "::" , stringify ! ( thirtytwo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_4 ) ) . sixtyfour as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr__bindgen_ty_4 )
                , "::" , stringify ! ( sixtyfour ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_4 ) ) . unintptr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr__bindgen_ty_4 )
                , "::" , stringify ! ( unintptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_4 ) ) . ptr as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr__bindgen_ty_4 )
                , "::" , stringify ! ( ptr ) ));
}
impl Clone for pkthdr__bindgen_ty_4 {
    fn clone(&self) -> Self { *self }
}
impl Default for pkthdr__bindgen_ty_4 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for pkthdr__bindgen_ty_4 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "pkthdr__bindgen_ty_4 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_pkthdr() {
    assert_eq!(::core::mem::size_of::<pkthdr>() , 56usize , concat ! (
               "Size of: " , stringify ! ( pkthdr ) ));
    assert_eq! (::core::mem::align_of::<pkthdr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pkthdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr ) ) . tags as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr ) , "::" ,
                stringify ! ( tags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr ) ) . len as * const _ as usize }
                , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr ) , "::" ,
                stringify ! ( len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr ) ) . flowid as * const _ as usize
                } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr ) , "::" ,
                stringify ! ( flowid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr ) ) . csum_flags as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr ) , "::" ,
                stringify ! ( csum_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr ) ) . fibnum as * const _ as usize
                } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr ) , "::" ,
                stringify ! ( fibnum ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr ) ) . cosqos as * const _ as usize
                } , 30usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr ) , "::" ,
                stringify ! ( cosqos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr ) ) . rsstype as * const _ as
                usize } , 31usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr ) , "::" ,
                stringify ! ( rsstype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr ) ) . PH_per as * const _ as usize
                } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr ) , "::" ,
                stringify ! ( PH_per ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr ) ) . PH_loc as * const _ as usize
                } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr ) , "::" ,
                stringify ! ( PH_loc ) ));
}
impl Clone for pkthdr {
    fn clone(&self) -> Self { *self }
}
impl Default for pkthdr {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for pkthdr {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "pkthdr {{ tags: {:?}, len: {:?}, flowid: {:?}, csum_flags: {:?}, fibnum: {:?}, cosqos: {:?}, rsstype: {:?}, PH_per: {:?}, PH_loc: {:?} }}"
               , self . tags , self . len , self . flowid , self . csum_flags
               , self . fibnum , self . cosqos , self . rsstype , self .
               PH_per , self . PH_loc)
    }
}
pub type m_ext_free_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut mbuf)>;
#[repr(C)]
#[derive(Copy)]
pub struct m_ext {
    pub __bindgen_anon_1: m_ext__bindgen_ty_1,
    pub ext_buf: *mut ::kernel::sys::raw::c_char,
    pub ext_size: u32,
    pub _bitfield_1: u32,
    pub ext_free: m_ext_free_t,
    pub ext_arg1: *mut ::kernel::sys::raw::c_void,
    pub ext_arg2: *mut ::kernel::sys::raw::c_void,
}
#[repr(C)]
#[derive(Copy)]
pub union m_ext__bindgen_ty_1 {
    pub ext_count: u_int,
    pub ext_cnt: *mut u_int,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_m_ext__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<m_ext__bindgen_ty_1>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( m_ext__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<m_ext__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( m_ext__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const m_ext__bindgen_ty_1 ) ) . ext_count as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( m_ext__bindgen_ty_1 ) ,
                "::" , stringify ! ( ext_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const m_ext__bindgen_ty_1 ) ) . ext_cnt as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( m_ext__bindgen_ty_1 ) ,
                "::" , stringify ! ( ext_cnt ) ));
}
impl Clone for m_ext__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for m_ext__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for m_ext__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "m_ext__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_m_ext() {
    assert_eq!(::core::mem::size_of::<m_ext>() , 48usize , concat ! (
               "Size of: " , stringify ! ( m_ext ) ));
    assert_eq! (::core::mem::align_of::<m_ext>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( m_ext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const m_ext ) ) . ext_buf as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( m_ext ) , "::" ,
                stringify ! ( ext_buf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const m_ext ) ) . ext_size as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( m_ext ) , "::" ,
                stringify ! ( ext_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const m_ext ) ) . ext_free as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( m_ext ) , "::" ,
                stringify ! ( ext_free ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const m_ext ) ) . ext_arg1 as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( m_ext ) , "::" ,
                stringify ! ( ext_arg1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const m_ext ) ) . ext_arg2 as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( m_ext ) , "::" ,
                stringify ! ( ext_arg2 ) ));
}
impl Clone for m_ext {
    fn clone(&self) -> Self { *self }
}
impl Default for m_ext {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for m_ext {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "m_ext {{ ext_buf: {:?}, ext_size: {:?}, ext_type : {:?}, ext_flags : {:?}, ext_free: {:?}, ext_arg1: {:?}, ext_arg2: {:?} }}"
               , self . ext_buf , self . ext_size , self . ext_type (  ) ,
               self . ext_flags (  ) , self . ext_free , self . ext_arg1 ,
               self . ext_arg2)
    }
}
impl m_ext {
    #[inline]
    pub fn ext_type(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u32
                                                 as *mut u8,
                                             ::core::mem::size_of::<u32>())
        };
        let mask = 255u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::core::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_ext_type(&mut self, val: u32) {
        let mask = 255u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u32
                                                 as *mut u8,
                                             ::core::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn ext_flags(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u32
                                                 as *mut u8,
                                             ::core::mem::size_of::<u32>())
        };
        let mask = 4294967040u64 as u32;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::core::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_ext_flags(&mut self, val: u32) {
        let mask = 4294967040u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u32
                                                 as *mut u8,
                                             ::core::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(ext_type: u32, ext_flags: u32) -> u32 {
        ({ ({ 0 } | ((ext_type as u32 as u32) << 0usize) & (255u64 as u32)) }
             | ((ext_flags as u32 as u32) << 8usize) & (4294967040u64 as u32))
    }
}
extern "C" {
    #[link_name = "zone_mbuf"]
    pub static mut zone_mbuf: uma_zone_t;
}
extern "C" {
    #[link_name = "zone_clust"]
    pub static mut zone_clust: uma_zone_t;
}
extern "C" {
    #[link_name = "zone_pack"]
    pub static mut zone_pack: uma_zone_t;
}
extern "C" {
    #[link_name = "zone_jumbop"]
    pub static mut zone_jumbop: uma_zone_t;
}
extern "C" {
    #[link_name = "zone_jumbo9"]
    pub static mut zone_jumbo9: uma_zone_t;
}
extern "C" {
    #[link_name = "zone_jumbo16"]
    pub static mut zone_jumbo16: uma_zone_t;
}
extern "C" {
    pub fn mb_dupcl(arg1: *mut mbuf, arg2: *mut mbuf);
}
extern "C" {
    pub fn mb_free_ext(arg1: *mut mbuf);
}
extern "C" {
    pub fn m_adj(arg1: *mut mbuf, arg2: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn m_apply(arg1: *mut mbuf, arg2: ::kernel::sys::raw::c_int,
                   arg3: ::kernel::sys::raw::c_int,
                   arg4:
                       ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                       *mut ::kernel::sys::raw::c_void,
                                                                   arg2:
                                                                       *mut ::kernel::sys::raw::c_void,
                                                                   arg3:
                                                                       u_int)
                                                  ->
                                                      ::kernel::sys::raw::c_int>,
                   arg5: *mut ::kernel::sys::raw::c_void)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn m_append(arg1: *mut mbuf, arg2: ::kernel::sys::raw::c_int,
                    arg3: c_caddr_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn m_cat(arg1: *mut mbuf, arg2: *mut mbuf);
}
extern "C" {
    pub fn m_catpkt(arg1: *mut mbuf, arg2: *mut mbuf);
}
extern "C" {
    pub fn m_clget(m: *mut mbuf, how: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn m_cljget(m: *mut mbuf, how: ::kernel::sys::raw::c_int,
                    size: ::kernel::sys::raw::c_int)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn m_collapse(arg1: *mut mbuf, arg2: ::kernel::sys::raw::c_int,
                      arg3: ::kernel::sys::raw::c_int) -> *mut mbuf;
}
extern "C" {
    pub fn m_copyback(arg1: *mut mbuf, arg2: ::kernel::sys::raw::c_int,
                      arg3: ::kernel::sys::raw::c_int, arg4: c_caddr_t);
}
extern "C" {
    pub fn m_copydata(arg1: *const mbuf, arg2: ::kernel::sys::raw::c_int,
                      arg3: ::kernel::sys::raw::c_int, arg4: caddr_t);
}
extern "C" {
    pub fn m_copym(arg1: *mut mbuf, arg2: ::kernel::sys::raw::c_int,
                   arg3: ::kernel::sys::raw::c_int,
                   arg4: ::kernel::sys::raw::c_int) -> *mut mbuf;
}
extern "C" {
    pub fn m_copypacket(arg1: *mut mbuf, arg2: ::kernel::sys::raw::c_int)
     -> *mut mbuf;
}
extern "C" {
    pub fn m_copy_pkthdr(arg1: *mut mbuf, arg2: *mut mbuf);
}
extern "C" {
    pub fn m_copyup(arg1: *mut mbuf, arg2: ::kernel::sys::raw::c_int,
                    arg3: ::kernel::sys::raw::c_int) -> *mut mbuf;
}
extern "C" {
    pub fn m_defrag(arg1: *mut mbuf, arg2: ::kernel::sys::raw::c_int)
     -> *mut mbuf;
}
extern "C" {
    pub fn m_demote_pkthdr(arg1: *mut mbuf);
}
extern "C" {
    pub fn m_demote(arg1: *mut mbuf, arg2: ::kernel::sys::raw::c_int,
                    arg3: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn m_devget(arg1: *mut ::kernel::sys::raw::c_char,
                    arg2: ::kernel::sys::raw::c_int,
                    arg3: ::kernel::sys::raw::c_int, arg4: *mut ifnet,
                    arg5:
                        ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                        *mut ::kernel::sys::raw::c_char,
                                                                    arg2:
                                                                        caddr_t,
                                                                    arg3:
                                                                        u_int)>)
     -> *mut mbuf;
}
extern "C" {
    pub fn m_dup(arg1: *const mbuf, arg2: ::kernel::sys::raw::c_int)
     -> *mut mbuf;
}
extern "C" {
    pub fn m_dup_pkthdr(arg1: *mut mbuf, arg2: *const mbuf,
                        arg3: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn m_extadd(arg1: *mut mbuf, arg2: *mut ::kernel::sys::raw::c_char,
                    arg3: u_int, arg4: m_ext_free_t,
                    arg5: *mut ::kernel::sys::raw::c_void,
                    arg6: *mut ::kernel::sys::raw::c_void,
                    arg7: ::kernel::sys::raw::c_int,
                    arg8: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn m_fixhdr(arg1: *mut mbuf) -> u_int;
}
extern "C" {
    pub fn m_fragment(arg1: *mut mbuf, arg2: ::kernel::sys::raw::c_int,
                      arg3: ::kernel::sys::raw::c_int) -> *mut mbuf;
}
extern "C" {
    pub fn m_freem(arg1: *mut mbuf);
}
extern "C" {
    pub fn m_get2(arg1: ::kernel::sys::raw::c_int,
                  arg2: ::kernel::sys::raw::c_int,
                  arg3: ::kernel::sys::raw::c_short,
                  arg4: ::kernel::sys::raw::c_int) -> *mut mbuf;
}
extern "C" {
    pub fn m_getjcl(arg1: ::kernel::sys::raw::c_int,
                    arg2: ::kernel::sys::raw::c_short,
                    arg3: ::kernel::sys::raw::c_int,
                    arg4: ::kernel::sys::raw::c_int) -> *mut mbuf;
}
extern "C" {
    pub fn m_getm2(arg1: *mut mbuf, arg2: ::kernel::sys::raw::c_int,
                   arg3: ::kernel::sys::raw::c_int,
                   arg4: ::kernel::sys::raw::c_short,
                   arg5: ::kernel::sys::raw::c_int) -> *mut mbuf;
}
extern "C" {
    pub fn m_getptr(arg1: *mut mbuf, arg2: ::kernel::sys::raw::c_int,
                    arg3: *mut ::kernel::sys::raw::c_int) -> *mut mbuf;
}
extern "C" {
    pub fn m_length(arg1: *mut mbuf, arg2: *mut *mut mbuf) -> u_int;
}
extern "C" {
    pub fn m_mbuftouio(arg1: *mut uio, arg2: *const mbuf,
                       arg3: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn m_move_pkthdr(arg1: *mut mbuf, arg2: *mut mbuf);
}
extern "C" {
    pub fn m_pkthdr_init(arg1: *mut mbuf, arg2: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn m_prepend(arg1: *mut mbuf, arg2: ::kernel::sys::raw::c_int,
                     arg3: ::kernel::sys::raw::c_int) -> *mut mbuf;
}
extern "C" {
    pub fn m_print(arg1: *const mbuf, arg2: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn m_pulldown(arg1: *mut mbuf, arg2: ::kernel::sys::raw::c_int,
                      arg3: ::kernel::sys::raw::c_int,
                      arg4: *mut ::kernel::sys::raw::c_int) -> *mut mbuf;
}
extern "C" {
    pub fn m_pullup(arg1: *mut mbuf, arg2: ::kernel::sys::raw::c_int)
     -> *mut mbuf;
}
extern "C" {
    pub fn m_sanity(arg1: *mut mbuf, arg2: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn m_split(arg1: *mut mbuf, arg2: ::kernel::sys::raw::c_int,
                   arg3: ::kernel::sys::raw::c_int) -> *mut mbuf;
}
extern "C" {
    pub fn m_uiotombuf(arg1: *mut uio, arg2: ::kernel::sys::raw::c_int,
                       arg3: ::kernel::sys::raw::c_int,
                       arg4: ::kernel::sys::raw::c_int,
                       arg5: ::kernel::sys::raw::c_int) -> *mut mbuf;
}
extern "C" {
    pub fn m_unshare(arg1: *mut mbuf, arg2: ::kernel::sys::raw::c_int)
     -> *mut mbuf;
}
extern "C" {
    #[link_name = "max_datalen"]
    pub static mut max_datalen: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "max_hdr"]
    pub static mut max_hdr: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "max_linkhdr"]
    pub static mut max_linkhdr: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "max_protohdr"]
    pub static mut max_protohdr: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "nmbclusters"]
    pub static mut nmbclusters: ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn m_tag_alloc(arg1: u_int32_t, arg2: ::kernel::sys::raw::c_int,
                       arg3: ::kernel::sys::raw::c_int,
                       arg4: ::kernel::sys::raw::c_int) -> *mut m_tag;
}
extern "C" {
    pub fn m_tag_delete(arg1: *mut mbuf, arg2: *mut m_tag);
}
extern "C" {
    pub fn m_tag_delete_chain(arg1: *mut mbuf, arg2: *mut m_tag);
}
extern "C" {
    pub fn m_tag_free_default(arg1: *mut m_tag);
}
extern "C" {
    pub fn m_tag_locate(arg1: *mut mbuf, arg2: u_int32_t,
                        arg3: ::kernel::sys::raw::c_int, arg4: *mut m_tag)
     -> *mut m_tag;
}
extern "C" {
    pub fn m_tag_copy(arg1: *mut m_tag, arg2: ::kernel::sys::raw::c_int)
     -> *mut m_tag;
}
extern "C" {
    pub fn m_tag_copy_chain(arg1: *mut mbuf, arg2: *const mbuf,
                            arg3: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn m_tag_delete_nonpersistent(arg1: *mut mbuf);
}
extern "C" {
    pub fn m_ether_tcpip_hash_init() -> u32;
}
extern "C" {
    pub fn m_ether_tcpip_hash(arg1: u32, arg2: *const mbuf, arg3: u32) -> u32;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mbufq {
    pub mq_head: mbufq__bindgen_ty_1,
    pub mq_len: ::kernel::sys::raw::c_int,
    pub mq_maxlen: ::kernel::sys::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mbufq__bindgen_ty_1 {
    pub stqh_first: *mut mbuf,
    pub stqh_last: *mut *mut mbuf,
}
#[test]
fn bindgen_test_layout_mbufq__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<mbufq__bindgen_ty_1>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( mbufq__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<mbufq__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( mbufq__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbufq__bindgen_ty_1 ) ) . stqh_first as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mbufq__bindgen_ty_1 ) ,
                "::" , stringify ! ( stqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbufq__bindgen_ty_1 ) ) . stqh_last as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mbufq__bindgen_ty_1 ) ,
                "::" , stringify ! ( stqh_last ) ));
}
impl Clone for mbufq__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for mbufq__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_mbufq() {
    assert_eq!(::core::mem::size_of::<mbufq>() , 24usize , concat ! (
               "Size of: " , stringify ! ( mbufq ) ));
    assert_eq! (::core::mem::align_of::<mbufq>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( mbufq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbufq ) ) . mq_head as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mbufq ) , "::" ,
                stringify ! ( mq_head ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbufq ) ) . mq_len as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mbufq ) , "::" ,
                stringify ! ( mq_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbufq ) ) . mq_maxlen as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( mbufq ) , "::" ,
                stringify ! ( mq_maxlen ) ));
}
impl Clone for mbufq {
    fn clone(&self) -> Self { *self }
}
impl Default for mbufq {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct pti_frame {
    pub pti_rdx: register_t,
    pub pti_rax: register_t,
    pub pti_err: register_t,
    pub pti_rip: register_t,
    pub pti_cs: register_t,
    pub pti_rflags: register_t,
    pub pti_rsp: register_t,
    pub pti_ss: register_t,
}
#[test]
fn bindgen_test_layout_pti_frame() {
    assert_eq!(::core::mem::size_of::<pti_frame>() , 64usize , concat ! (
               "Size of: " , stringify ! ( pti_frame ) ));
    assert_eq! (::core::mem::align_of::<pti_frame>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pti_frame ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pti_frame ) ) . pti_rdx as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pti_frame ) , "::" ,
                stringify ! ( pti_rdx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pti_frame ) ) . pti_rax as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pti_frame ) , "::" ,
                stringify ! ( pti_rax ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pti_frame ) ) . pti_err as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( pti_frame ) , "::" ,
                stringify ! ( pti_err ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pti_frame ) ) . pti_rip as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( pti_frame ) , "::" ,
                stringify ! ( pti_rip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pti_frame ) ) . pti_cs as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( pti_frame ) , "::" ,
                stringify ! ( pti_cs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pti_frame ) ) . pti_rflags as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( pti_frame ) , "::" ,
                stringify ! ( pti_rflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pti_frame ) ) . pti_rsp as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( pti_frame ) , "::" ,
                stringify ! ( pti_rsp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pti_frame ) ) . pti_ss as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( pti_frame ) , "::" ,
                stringify ! ( pti_ss ) ));
}
impl Clone for pti_frame {
    fn clone(&self) -> Self { *self }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy)]
pub struct segment_descriptor {
    pub _bitfield_1: [u32; 3usize],
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_segment_descriptor() {
    assert_eq!(::core::mem::size_of::<segment_descriptor>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( segment_descriptor ) ));
    assert_eq! (::core::mem::align_of::<segment_descriptor>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( segment_descriptor ) ));
}
impl Clone for segment_descriptor {
    fn clone(&self) -> Self { *self }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy)]
pub struct user_segment_descriptor {
    pub _bitfield_1: [u32; 3usize],
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_user_segment_descriptor() {
    assert_eq!(::core::mem::size_of::<user_segment_descriptor>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( user_segment_descriptor ) ));
    assert_eq! (::core::mem::align_of::<user_segment_descriptor>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( user_segment_descriptor ) ));
}
impl Clone for user_segment_descriptor {
    fn clone(&self) -> Self { *self }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy)]
pub struct gate_descriptor {
    pub _bitfield_1: [u64; 3usize],
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_gate_descriptor() {
    assert_eq!(::core::mem::size_of::<gate_descriptor>() , 16usize , concat !
               ( "Size of: " , stringify ! ( gate_descriptor ) ));
    assert_eq! (::core::mem::align_of::<gate_descriptor>() , 1usize , concat !
                ( "Alignment of " , stringify ! ( gate_descriptor ) ));
}
impl Clone for gate_descriptor {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union descriptor {
    pub sd: user_segment_descriptor,
    pub gd: gate_descriptor,
    _bindgen_union_align: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_descriptor() {
    assert_eq!(::core::mem::size_of::<descriptor>() , 16usize , concat ! (
               "Size of: " , stringify ! ( descriptor ) ));
    assert_eq! (::core::mem::align_of::<descriptor>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( descriptor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const descriptor ) ) . sd as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( descriptor ) , "::" ,
                stringify ! ( sd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const descriptor ) ) . gd as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( descriptor ) , "::" ,
                stringify ! ( gd ) ));
}
impl Clone for descriptor {
    fn clone(&self) -> Self { *self }
}
impl Default for descriptor {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for descriptor {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "descriptor {{ union }}")
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy)]
pub struct system_segment_descriptor {
    pub _bitfield_1: [u64; 3usize],
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_system_segment_descriptor() {
    assert_eq!(::core::mem::size_of::<system_segment_descriptor>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( system_segment_descriptor ) ));
    assert_eq! (::core::mem::align_of::<system_segment_descriptor>() , 1usize
                , concat ! (
                "Alignment of " , stringify ! ( system_segment_descriptor )
                ));
}
impl Clone for system_segment_descriptor {
    fn clone(&self) -> Self { *self }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy)]
pub struct soft_segment_descriptor {
    pub ssd_base: ::kernel::sys::raw::c_ulong,
    pub ssd_limit: ::kernel::sys::raw::c_ulong,
    pub _bitfield_1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_soft_segment_descriptor() {
    assert_eq!(::core::mem::size_of::<soft_segment_descriptor>() , 18usize ,
               concat ! (
               "Size of: " , stringify ! ( soft_segment_descriptor ) ));
    assert_eq! (::core::mem::align_of::<soft_segment_descriptor>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( soft_segment_descriptor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const soft_segment_descriptor ) ) . ssd_base as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( soft_segment_descriptor
                ) , "::" , stringify ! ( ssd_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const soft_segment_descriptor ) ) . ssd_limit
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( soft_segment_descriptor
                ) , "::" , stringify ! ( ssd_limit ) ));
}
impl Clone for soft_segment_descriptor {
    fn clone(&self) -> Self { *self }
}
impl soft_segment_descriptor {
    #[inline]
    pub fn ssd_type(&self) -> ::kernel::sys::raw::c_ulong {
        let mut unit_field_val: u16 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u16
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>())
        };
        let mask = 31u64 as u16;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::core::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_ssd_type(&mut self, val: ::kernel::sys::raw::c_ulong) {
        let mask = 31u64 as u16;
        let val = val as u64 as u16;
        let mut unit_field_val: u16 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u16
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn ssd_dpl(&self) -> ::kernel::sys::raw::c_ulong {
        let mut unit_field_val: u16 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u16
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>())
        };
        let mask = 96u64 as u16;
        let val = (unit_field_val & mask) >> 5usize;
        unsafe { ::core::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_ssd_dpl(&mut self, val: ::kernel::sys::raw::c_ulong) {
        let mask = 96u64 as u16;
        let val = val as u64 as u16;
        let mut unit_field_val: u16 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u16
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 5usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn ssd_p(&self) -> ::kernel::sys::raw::c_ulong {
        let mut unit_field_val: u16 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u16
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>())
        };
        let mask = 128u64 as u16;
        let val = (unit_field_val & mask) >> 7usize;
        unsafe { ::core::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_ssd_p(&mut self, val: ::kernel::sys::raw::c_ulong) {
        let mask = 128u64 as u16;
        let val = val as u64 as u16;
        let mut unit_field_val: u16 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u16
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 7usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn ssd_long(&self) -> ::kernel::sys::raw::c_ulong {
        let mut unit_field_val: u16 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u16
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>())
        };
        let mask = 256u64 as u16;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::core::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_ssd_long(&mut self, val: ::kernel::sys::raw::c_ulong) {
        let mask = 256u64 as u16;
        let val = val as u64 as u16;
        let mut unit_field_val: u16 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u16
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn ssd_def32(&self) -> ::kernel::sys::raw::c_ulong {
        let mut unit_field_val: u16 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u16
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>())
        };
        let mask = 512u64 as u16;
        let val = (unit_field_val & mask) >> 9usize;
        unsafe { ::core::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_ssd_def32(&mut self, val: ::kernel::sys::raw::c_ulong) {
        let mask = 512u64 as u16;
        let val = val as u64 as u16;
        let mut unit_field_val: u16 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u16
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 9usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn ssd_gran(&self) -> ::kernel::sys::raw::c_ulong {
        let mut unit_field_val: u16 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u16
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>())
        };
        let mask = 1024u64 as u16;
        let val = (unit_field_val & mask) >> 10usize;
        unsafe { ::core::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_ssd_gran(&mut self, val: ::kernel::sys::raw::c_ulong) {
        let mask = 1024u64 as u16;
        let val = val as u64 as u16;
        let mut unit_field_val: u16 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u16
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 10usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(ssd_type: ::kernel::sys::raw::c_ulong,
                          ssd_dpl: ::kernel::sys::raw::c_ulong,
                          ssd_p: ::kernel::sys::raw::c_ulong,
                          ssd_long: ::kernel::sys::raw::c_ulong,
                          ssd_def32: ::kernel::sys::raw::c_ulong,
                          ssd_gran: ::kernel::sys::raw::c_ulong) -> u16 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({ 0 } |
                                      ((ssd_type as u64 as u16) << 0usize) &
                                          (31u64 as u16))
                             } |
                                 ((ssd_dpl as u64 as u16) << 5usize) &
                                     (96u64 as u16))
                        } |
                            ((ssd_p as u64 as u16) << 7usize) &
                                (128u64 as u16))
                   } | ((ssd_long as u64 as u16) << 8usize) & (256u64 as u16))
              } | ((ssd_def32 as u64 as u16) << 9usize) & (512u64 as u16))
         } | ((ssd_gran as u64 as u16) << 10usize) & (1024u64 as u16))
    }
}
extern "C" {
    #[link_name = "gdt"]
    pub static mut gdt: [user_segment_descriptor; 0usize];
}
extern "C" {
    #[link_name = "gdt_segs"]
    pub static mut gdt_segs: [soft_segment_descriptor; 0usize];
}
extern "C" {
    #[link_name = "idt"]
    pub static mut idt: *mut gate_descriptor;
}
extern "C" {
    #[link_name = "r_gdt"]
    pub static mut r_gdt: region_descriptor;
}
extern "C" {
    #[link_name = "r_idt"]
    pub static mut r_idt: region_descriptor;
}
extern "C" {
    pub fn lgdt(rdp: *mut region_descriptor);
}
extern "C" {
    pub fn sdtossd(sdp: *mut user_segment_descriptor,
                   ssdp: *mut soft_segment_descriptor);
}
extern "C" {
    pub fn ssdtosd(ssdp: *mut soft_segment_descriptor,
                   sdp: *mut user_segment_descriptor);
}
extern "C" {
    pub fn ssdtosyssd(ssdp: *mut soft_segment_descriptor,
                      sdp: *mut system_segment_descriptor);
}
extern "C" {
    pub fn update_gdt_gsbase(td: *mut thread, base: u32);
}
extern "C" {
    pub fn update_gdt_fsbase(td: *mut thread, base: u32);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cpu_ops {
    pub cpu_init: ::core::option::Option<unsafe extern "C" fn()>,
    pub cpu_resume: ::core::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout_cpu_ops() {
    assert_eq!(::core::mem::size_of::<cpu_ops>() , 16usize , concat ! (
               "Size of: " , stringify ! ( cpu_ops ) ));
    assert_eq! (::core::mem::align_of::<cpu_ops>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( cpu_ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_ops ) ) . cpu_init as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( cpu_ops ) , "::" ,
                stringify ! ( cpu_init ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_ops ) ) . cpu_resume as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( cpu_ops ) , "::" ,
                stringify ! ( cpu_resume ) ));
}
impl Clone for cpu_ops {
    fn clone(&self) -> Self { *self }
}
impl Default for cpu_ops {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    #[link_name = "cpu_ops"]
    pub static mut cpu_ops: cpu_ops;
}
extern "C" {
    #[link_name = "brwsection"]
    pub static mut brwsection: [::kernel::sys::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "btext"]
    pub static mut btext: [::kernel::sys::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "_end"]
    pub static mut _end: [::kernel::sys::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "etext"]
    pub static mut etext: [::kernel::sys::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "vmm_resume_p"]
    pub static mut vmm_resume_p:
               ::core::option::Option<unsafe extern "C" fn()>;
}
extern "C" {
    pub fn cpu_halt();
}
extern "C" {
    pub fn cpu_reset();
}
extern "C" {
    pub fn fork_trampoline();
}
extern "C" {
    pub fn swi_vm(arg1: *mut ::kernel::sys::raw::c_void);
}
#[repr(C)]
pub struct buf_ring {
    pub br_prod_head: u32,
    pub br_prod_tail: u32,
    pub br_prod_size: ::kernel::sys::raw::c_int,
    pub br_prod_mask: ::kernel::sys::raw::c_int,
    pub br_drops: u64,
    pub __bindgen_padding_0: [u32; 10usize],
    pub br_cons_head: u32,
    pub br_cons_tail: u32,
    pub br_cons_size: ::kernel::sys::raw::c_int,
    pub br_cons_mask: ::kernel::sys::raw::c_int,
    pub __bindgen_padding_1: [u64; 6usize],
    pub br_ring: __IncompleteArrayField<*mut ::kernel::sys::raw::c_void>,
}
#[test]
fn bindgen_test_layout_buf_ring() {
    assert_eq!(::core::mem::size_of::<buf_ring>() , 128usize , concat ! (
               "Size of: " , stringify ! ( buf_ring ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const buf_ring ) ) . br_prod_head as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( buf_ring ) , "::" ,
                stringify ! ( br_prod_head ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const buf_ring ) ) . br_prod_tail as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( buf_ring ) , "::" ,
                stringify ! ( br_prod_tail ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const buf_ring ) ) . br_prod_size as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( buf_ring ) , "::" ,
                stringify ! ( br_prod_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const buf_ring ) ) . br_prod_mask as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( buf_ring ) , "::" ,
                stringify ! ( br_prod_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const buf_ring ) ) . br_drops as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( buf_ring ) , "::" ,
                stringify ! ( br_drops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const buf_ring ) ) . br_cons_head as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( buf_ring ) , "::" ,
                stringify ! ( br_cons_head ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const buf_ring ) ) . br_cons_tail as * const _
                as usize } , 68usize , concat ! (
                "Alignment of field: " , stringify ! ( buf_ring ) , "::" ,
                stringify ! ( br_cons_tail ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const buf_ring ) ) . br_cons_size as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( buf_ring ) , "::" ,
                stringify ! ( br_cons_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const buf_ring ) ) . br_cons_mask as * const _
                as usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( buf_ring ) , "::" ,
                stringify ! ( br_cons_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const buf_ring ) ) . br_ring as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( buf_ring ) , "::" ,
                stringify ! ( br_ring ) ));
}
impl Default for buf_ring {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for buf_ring {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "buf_ring {{ br_prod_head: {:?}, br_prod_tail: {:?}, br_prod_size: {:?}, br_prod_mask: {:?}, br_drops: {:?}, br_cons_head: {:?}, br_cons_tail: {:?}, br_cons_size: {:?}, br_cons_mask: {:?}, br_ring: {:?} }}"
               , self . br_prod_head , self . br_prod_tail , self .
               br_prod_size , self . br_prod_mask , self . br_drops , self .
               br_cons_head , self . br_cons_tail , self . br_cons_size , self
               . br_cons_mask , self . br_ring)
    }
}
extern "C" {
    pub fn buf_ring_alloc(count: ::kernel::sys::raw::c_int,
                          type_: *mut malloc_type,
                          flags: ::kernel::sys::raw::c_int, arg1: *mut mtx)
     -> *mut buf_ring;
}
extern "C" {
    pub fn buf_ring_free(br: *mut buf_ring, type_: *mut malloc_type);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ck_stack_entry {
    pub next: *mut ck_stack_entry,
}
#[test]
fn bindgen_test_layout_ck_stack_entry() {
    assert_eq!(::core::mem::size_of::<ck_stack_entry>() , 8usize , concat ! (
               "Size of: " , stringify ! ( ck_stack_entry ) ));
    assert_eq! (::core::mem::align_of::<ck_stack_entry>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( ck_stack_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ck_stack_entry ) ) . next as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ck_stack_entry ) , "::"
                , stringify ! ( next ) ));
}
impl Clone for ck_stack_entry {
    fn clone(&self) -> Self { *self }
}
impl Default for ck_stack_entry {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type ck_stack_entry_t = ck_stack_entry;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ck_stack {
    pub head: *mut ck_stack_entry,
    pub generation: *mut ::kernel::sys::raw::c_char,
}
#[test]
fn bindgen_test_layout_ck_stack() {
    assert_eq!(::core::mem::size_of::<ck_stack>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ck_stack ) ));
    assert_eq! (::core::mem::align_of::<ck_stack>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ck_stack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ck_stack ) ) . head as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ck_stack ) , "::" ,
                stringify ! ( head ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ck_stack ) ) . generation as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ck_stack ) , "::" ,
                stringify ! ( generation ) ));
}
impl Clone for ck_stack {
    fn clone(&self) -> Self { *self }
}
impl Default for ck_stack {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type ck_stack_t = ck_stack;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ck_epoch_entry {
    pub function: ck_epoch_cb_t,
    pub stack_entry: ck_stack_entry_t,
}
#[test]
fn bindgen_test_layout_ck_epoch_entry() {
    assert_eq!(::core::mem::size_of::<ck_epoch_entry>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ck_epoch_entry ) ));
    assert_eq! (::core::mem::align_of::<ck_epoch_entry>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( ck_epoch_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ck_epoch_entry ) ) . function as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ck_epoch_entry ) , "::"
                , stringify ! ( function ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ck_epoch_entry ) ) . stack_entry as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ck_epoch_entry ) , "::"
                , stringify ! ( stack_entry ) ));
}
impl Clone for ck_epoch_entry {
    fn clone(&self) -> Self { *self }
}
impl Default for ck_epoch_entry {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type ck_epoch_entry_t = ck_epoch_entry;
pub type ck_epoch_cb_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ck_epoch_entry_t)>;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct ck_epoch_section {
    pub bucket: ::kernel::sys::raw::c_uint,
}
#[test]
fn bindgen_test_layout_ck_epoch_section() {
    assert_eq!(::core::mem::size_of::<ck_epoch_section>() , 4usize , concat !
               ( "Size of: " , stringify ! ( ck_epoch_section ) ));
    assert_eq! (::core::mem::align_of::<ck_epoch_section>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( ck_epoch_section ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ck_epoch_section ) ) . bucket as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ck_epoch_section ) ,
                "::" , stringify ! ( bucket ) ));
}
impl Clone for ck_epoch_section {
    fn clone(&self) -> Self { *self }
}
pub type ck_epoch_section_t = ck_epoch_section;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct ck_epoch_ref {
    pub epoch: ::kernel::sys::raw::c_uint,
    pub count: ::kernel::sys::raw::c_uint,
}
#[test]
fn bindgen_test_layout_ck_epoch_ref() {
    assert_eq!(::core::mem::size_of::<ck_epoch_ref>() , 8usize , concat ! (
               "Size of: " , stringify ! ( ck_epoch_ref ) ));
    assert_eq! (::core::mem::align_of::<ck_epoch_ref>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( ck_epoch_ref ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ck_epoch_ref ) ) . epoch as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ck_epoch_ref ) , "::" ,
                stringify ! ( epoch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ck_epoch_ref ) ) . count as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ck_epoch_ref ) , "::" ,
                stringify ! ( count ) ));
}
impl Clone for ck_epoch_ref {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ck_epoch_record {
    pub record_next: ck_stack_entry_t,
    pub global: *mut ck_epoch,
    pub state: ::kernel::sys::raw::c_uint,
    pub epoch: ::kernel::sys::raw::c_uint,
    pub active: ::kernel::sys::raw::c_uint,
    pub __bindgen_padding_0: [u32; 9usize],
    pub local: ck_epoch_record__bindgen_ty_1,
    pub n_pending: ::kernel::sys::raw::c_uint,
    pub n_peak: ::kernel::sys::raw::c_uint,
    pub n_dispatch: ::kernel::sys::raw::c_uint,
    pub ct: *mut ::kernel::sys::raw::c_void,
    pub pending: [ck_stack_t; 4usize],
    pub __bindgen_padding_1: [u64; 3usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct ck_epoch_record__bindgen_ty_1 {
    pub bucket: [ck_epoch_ref; 2usize],
}
#[test]
fn bindgen_test_layout_ck_epoch_record__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<ck_epoch_record__bindgen_ty_1>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( ck_epoch_record__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<ck_epoch_record__bindgen_ty_1>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( ck_epoch_record__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ck_epoch_record__bindgen_ty_1 ) ) .
                bucket as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                ck_epoch_record__bindgen_ty_1 ) , "::" , stringify ! ( bucket
                ) ));
}
impl Clone for ck_epoch_record__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_ck_epoch_record() {
    assert_eq!(::core::mem::size_of::<ck_epoch_record>() , 192usize , concat !
               ( "Size of: " , stringify ! ( ck_epoch_record ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ck_epoch_record ) ) . record_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ck_epoch_record ) ,
                "::" , stringify ! ( record_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ck_epoch_record ) ) . global as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ck_epoch_record ) ,
                "::" , stringify ! ( global ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ck_epoch_record ) ) . state as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ck_epoch_record ) ,
                "::" , stringify ! ( state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ck_epoch_record ) ) . epoch as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( ck_epoch_record ) ,
                "::" , stringify ! ( epoch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ck_epoch_record ) ) . active as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ck_epoch_record ) ,
                "::" , stringify ! ( active ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ck_epoch_record ) ) . local as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( ck_epoch_record ) ,
                "::" , stringify ! ( local ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ck_epoch_record ) ) . n_pending as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( ck_epoch_record ) ,
                "::" , stringify ! ( n_pending ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ck_epoch_record ) ) . n_peak as * const _
                as usize } , 84usize , concat ! (
                "Alignment of field: " , stringify ! ( ck_epoch_record ) ,
                "::" , stringify ! ( n_peak ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ck_epoch_record ) ) . n_dispatch as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( ck_epoch_record ) ,
                "::" , stringify ! ( n_dispatch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ck_epoch_record ) ) . ct as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( ck_epoch_record ) ,
                "::" , stringify ! ( ct ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ck_epoch_record ) ) . pending as * const
                _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( ck_epoch_record ) ,
                "::" , stringify ! ( pending ) ));
}
impl Clone for ck_epoch_record {
    fn clone(&self) -> Self { *self }
}
impl Default for ck_epoch_record {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for ck_epoch_record {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "ck_epoch_record {{ record_next: {:?}, global: {:?}, state: {:?}, epoch: {:?}, active: {:?}, local: {:?}, n_pending: {:?}, n_peak: {:?}, n_dispatch: {:?}, ct: {:?}, pending: {:?} }}"
               , self . record_next , self . global , self . state , self .
               epoch , self . active , self . local , self . n_pending , self
               . n_peak , self . n_dispatch , self . ct , self . pending)
    }
}
pub type ck_epoch_record_t = ck_epoch_record;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ck_epoch {
    pub epoch: ::kernel::sys::raw::c_uint,
    pub n_free: ::kernel::sys::raw::c_uint,
    pub records: ck_stack_t,
}
#[test]
fn bindgen_test_layout_ck_epoch() {
    assert_eq!(::core::mem::size_of::<ck_epoch>() , 24usize , concat ! (
               "Size of: " , stringify ! ( ck_epoch ) ));
    assert_eq! (::core::mem::align_of::<ck_epoch>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ck_epoch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ck_epoch ) ) . epoch as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ck_epoch ) , "::" ,
                stringify ! ( epoch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ck_epoch ) ) . n_free as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ck_epoch ) , "::" ,
                stringify ! ( n_free ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ck_epoch ) ) . records as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ck_epoch ) , "::" ,
                stringify ! ( records ) ));
}
impl Clone for ck_epoch {
    fn clone(&self) -> Self { *self }
}
impl Default for ck_epoch {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type ck_epoch_t = ck_epoch;
extern "C" {
    pub fn _ck_epoch_addref(arg1: *mut ck_epoch_record_t,
                            arg2: *mut ck_epoch_section_t);
}
extern "C" {
    pub fn _ck_epoch_delref(arg1: *mut ck_epoch_record_t,
                            arg2: *mut ck_epoch_section_t) -> bool_;
}
pub type ck_epoch_wait_cb_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ck_epoch_t,
                                                arg2: *mut ck_epoch_record_t,
                                                arg3:
                                                    *mut ::kernel::sys::raw::c_void)>;
extern "C" {
    pub fn ck_epoch_init(arg1: *mut ck_epoch_t);
}
extern "C" {
    pub fn ck_epoch_recycle(arg1: *mut ck_epoch_t,
                            arg2: *mut ::kernel::sys::raw::c_void)
     -> *mut ck_epoch_record_t;
}
extern "C" {
    pub fn ck_epoch_register(arg1: *mut ck_epoch_t,
                             arg2: *mut ck_epoch_record_t,
                             arg3: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn ck_epoch_unregister(arg1: *mut ck_epoch_record_t);
}
extern "C" {
    pub fn ck_epoch_poll(arg1: *mut ck_epoch_record_t) -> bool_;
}
extern "C" {
    pub fn ck_epoch_poll_deferred(record: *mut ck_epoch_record,
                                  deferred: *mut ck_stack_t) -> bool_;
}
extern "C" {
    pub fn ck_epoch_synchronize(arg1: *mut ck_epoch_record_t);
}
extern "C" {
    pub fn ck_epoch_synchronize_wait(arg1: *mut ck_epoch_t,
                                     arg2: ck_epoch_wait_cb_t,
                                     arg3: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn ck_epoch_barrier(arg1: *mut ck_epoch_record_t);
}
extern "C" {
    pub fn ck_epoch_barrier_wait(arg1: *mut ck_epoch_record_t,
                                 arg2: ck_epoch_wait_cb_t,
                                 arg3: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn ck_epoch_reclaim(arg1: *mut ck_epoch_record_t);
}
pub type counter_u64_t = *mut u64;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct bitset {
    pub __bits: [::kernel::sys::raw::c_long; 1usize],
}
#[test]
fn bindgen_test_layout_bitset() {
    assert_eq!(::core::mem::size_of::<bitset>() , 8usize , concat ! (
               "Size of: " , stringify ! ( bitset ) ));
    assert_eq! (::core::mem::align_of::<bitset>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( bitset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bitset ) ) . __bits as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( bitset ) , "::" ,
                stringify ! ( __bits ) ));
}
impl Clone for bitset {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct _cpuset {
    pub __bits: [::kernel::sys::raw::c_long; 4usize],
}
#[test]
fn bindgen_test_layout__cpuset() {
    assert_eq!(::core::mem::size_of::<_cpuset>() , 32usize , concat ! (
               "Size of: " , stringify ! ( _cpuset ) ));
    assert_eq! (::core::mem::align_of::<_cpuset>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _cpuset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _cpuset ) ) . __bits as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _cpuset ) , "::" ,
                stringify ! ( __bits ) ));
}
impl Clone for _cpuset {
    fn clone(&self) -> Self { *self }
}
pub type cpuset_t = _cpuset;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sx {
    pub lock_object: lock_object,
    pub sx_lock: usize,
}
#[test]
fn bindgen_test_layout_sx() {
    assert_eq!(::core::mem::size_of::<sx>() , 32usize , concat ! (
               "Size of: " , stringify ! ( sx ) ));
    assert_eq! (::core::mem::align_of::<sx>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sx ) ) . lock_object as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sx ) , "::" , stringify
                ! ( lock_object ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sx ) ) . sx_lock as * const _ as usize }
                , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( sx ) , "::" , stringify
                ! ( sx_lock ) ));
}
impl Clone for sx {
    fn clone(&self) -> Self { *self }
}
impl Default for sx {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rmpriolist {
    pub lh_first: *mut rm_priotracker,
}
#[test]
fn bindgen_test_layout_rmpriolist() {
    assert_eq!(::core::mem::size_of::<rmpriolist>() , 8usize , concat ! (
               "Size of: " , stringify ! ( rmpriolist ) ));
    assert_eq! (::core::mem::align_of::<rmpriolist>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rmpriolist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmpriolist ) ) . lh_first as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rmpriolist ) , "::" ,
                stringify ! ( lh_first ) ));
}
impl Clone for rmpriolist {
    fn clone(&self) -> Self { *self }
}
impl Default for rmpriolist {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rm_queue {
    pub rmq_next: *mut rm_queue,
    pub rmq_prev: *mut rm_queue,
}
#[test]
fn bindgen_test_layout_rm_queue() {
    assert_eq!(::core::mem::size_of::<rm_queue>() , 16usize , concat ! (
               "Size of: " , stringify ! ( rm_queue ) ));
    assert_eq! (::core::mem::align_of::<rm_queue>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rm_queue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rm_queue ) ) . rmq_next as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rm_queue ) , "::" ,
                stringify ! ( rmq_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rm_queue ) ) . rmq_prev as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rm_queue ) , "::" ,
                stringify ! ( rmq_prev ) ));
}
impl Clone for rm_queue {
    fn clone(&self) -> Self { *self }
}
impl Default for rm_queue {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct rmlock {
    pub lock_object: lock_object,
    pub rm_writecpus: cpuset_t,
    pub rm_activeReaders: rmlock__bindgen_ty_1,
    pub _rm_lock: rmlock__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rmlock__bindgen_ty_1 {
    pub lh_first: *mut rm_priotracker,
}
#[test]
fn bindgen_test_layout_rmlock__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<rmlock__bindgen_ty_1>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( rmlock__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<rmlock__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rmlock__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmlock__bindgen_ty_1 ) ) . lh_first as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rmlock__bindgen_ty_1 )
                , "::" , stringify ! ( lh_first ) ));
}
impl Clone for rmlock__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for rmlock__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub union rmlock__bindgen_ty_2 {
    pub _rm_wlock_object: lock_object,
    pub _rm_lock_mtx: mtx,
    pub _rm_lock_sx: sx,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_rmlock__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<rmlock__bindgen_ty_2>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( rmlock__bindgen_ty_2 )
               ));
    assert_eq! (::core::mem::align_of::<rmlock__bindgen_ty_2>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rmlock__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmlock__bindgen_ty_2 ) ) .
                _rm_wlock_object as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rmlock__bindgen_ty_2 )
                , "::" , stringify ! ( _rm_wlock_object ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmlock__bindgen_ty_2 ) ) . _rm_lock_mtx
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rmlock__bindgen_ty_2 )
                , "::" , stringify ! ( _rm_lock_mtx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmlock__bindgen_ty_2 ) ) . _rm_lock_sx as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rmlock__bindgen_ty_2 )
                , "::" , stringify ! ( _rm_lock_sx ) ));
}
impl Clone for rmlock__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for rmlock__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for rmlock__bindgen_ty_2 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "rmlock__bindgen_ty_2 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_rmlock() {
    assert_eq!(::core::mem::size_of::<rmlock>() , 96usize , concat ! (
               "Size of: " , stringify ! ( rmlock ) ));
    assert_eq! (::core::mem::align_of::<rmlock>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rmlock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmlock ) ) . lock_object as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rmlock ) , "::" ,
                stringify ! ( lock_object ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmlock ) ) . rm_writecpus as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rmlock ) , "::" ,
                stringify ! ( rm_writecpus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmlock ) ) . rm_activeReaders as * const
                _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( rmlock ) , "::" ,
                stringify ! ( rm_activeReaders ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmlock ) ) . _rm_lock as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( rmlock ) , "::" ,
                stringify ! ( _rm_lock ) ));
}
impl Clone for rmlock {
    fn clone(&self) -> Self { *self }
}
impl Default for rmlock {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for rmlock {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "rmlock {{ lock_object: {:?}, rm_writecpus: {:?}, rm_activeReaders: {:?}, _rm_lock: {:?} }}"
               , self . lock_object , self . rm_writecpus , self .
               rm_activeReaders , self . _rm_lock)
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rm_priotracker {
    pub rmp_cpuQueue: rm_queue,
    pub rmp_rmlock: *mut rmlock,
    pub rmp_thread: *mut thread,
    pub rmp_flags: ::kernel::sys::raw::c_int,
    pub rmp_qentry: rm_priotracker__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rm_priotracker__bindgen_ty_1 {
    pub le_next: *mut rm_priotracker,
    pub le_prev: *mut *mut rm_priotracker,
}
#[test]
fn bindgen_test_layout_rm_priotracker__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<rm_priotracker__bindgen_ty_1>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( rm_priotracker__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<rm_priotracker__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( rm_priotracker__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rm_priotracker__bindgen_ty_1 ) ) .
                le_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rm_priotracker__bindgen_ty_1 ) , "::" , stringify ! ( le_next
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rm_priotracker__bindgen_ty_1 ) ) .
                le_prev as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                rm_priotracker__bindgen_ty_1 ) , "::" , stringify ! ( le_prev
                ) ));
}
impl Clone for rm_priotracker__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for rm_priotracker__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_rm_priotracker() {
    assert_eq!(::core::mem::size_of::<rm_priotracker>() , 56usize , concat ! (
               "Size of: " , stringify ! ( rm_priotracker ) ));
    assert_eq! (::core::mem::align_of::<rm_priotracker>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( rm_priotracker ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rm_priotracker ) ) . rmp_cpuQueue as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rm_priotracker ) , "::"
                , stringify ! ( rmp_cpuQueue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rm_priotracker ) ) . rmp_rmlock as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rm_priotracker ) , "::"
                , stringify ! ( rmp_rmlock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rm_priotracker ) ) . rmp_thread as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rm_priotracker ) , "::"
                , stringify ! ( rmp_thread ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rm_priotracker ) ) . rmp_flags as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rm_priotracker ) , "::"
                , stringify ! ( rmp_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rm_priotracker ) ) . rmp_qentry as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rm_priotracker ) , "::"
                , stringify ! ( rmp_qentry ) ));
}
impl Clone for rm_priotracker {
    fn clone(&self) -> Self { *self }
}
impl Default for rm_priotracker {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct rusage {
    pub ru_utime: timeval,
    pub ru_stime: timeval,
    pub ru_maxrss: ::kernel::sys::raw::c_long,
    pub ru_ixrss: ::kernel::sys::raw::c_long,
    pub ru_idrss: ::kernel::sys::raw::c_long,
    pub ru_isrss: ::kernel::sys::raw::c_long,
    pub ru_minflt: ::kernel::sys::raw::c_long,
    pub ru_majflt: ::kernel::sys::raw::c_long,
    pub ru_nswap: ::kernel::sys::raw::c_long,
    pub ru_inblock: ::kernel::sys::raw::c_long,
    pub ru_oublock: ::kernel::sys::raw::c_long,
    pub ru_msgsnd: ::kernel::sys::raw::c_long,
    pub ru_msgrcv: ::kernel::sys::raw::c_long,
    pub ru_nsignals: ::kernel::sys::raw::c_long,
    pub ru_nvcsw: ::kernel::sys::raw::c_long,
    pub ru_nivcsw: ::kernel::sys::raw::c_long,
}
#[test]
fn bindgen_test_layout_rusage() {
    assert_eq!(::core::mem::size_of::<rusage>() , 144usize , concat ! (
               "Size of: " , stringify ! ( rusage ) ));
    assert_eq! (::core::mem::align_of::<rusage>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rusage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_utime as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_utime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_stime as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_stime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_maxrss as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_maxrss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_ixrss as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_ixrss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_idrss as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_idrss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_isrss as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_isrss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_minflt as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_minflt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_majflt as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_majflt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_nswap as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_nswap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_inblock as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_inblock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_oublock as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_oublock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_msgsnd as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_msgsnd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_msgrcv as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_msgrcv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_nsignals as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_nsignals ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_nvcsw as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_nvcsw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_nivcsw as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_nivcsw ) ));
}
impl Clone for rusage {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct __wrusage {
    pub wru_self: rusage,
    pub wru_children: rusage,
}
#[test]
fn bindgen_test_layout___wrusage() {
    assert_eq!(::core::mem::size_of::<__wrusage>() , 288usize , concat ! (
               "Size of: " , stringify ! ( __wrusage ) ));
    assert_eq! (::core::mem::align_of::<__wrusage>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __wrusage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __wrusage ) ) . wru_self as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __wrusage ) , "::" ,
                stringify ! ( wru_self ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __wrusage ) ) . wru_children as * const _
                as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( __wrusage ) , "::" ,
                stringify ! ( wru_children ) ));
}
impl Clone for __wrusage {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct rlimit {
    pub rlim_cur: rlim_t,
    pub rlim_max: rlim_t,
}
#[test]
fn bindgen_test_layout_rlimit() {
    assert_eq!(::core::mem::size_of::<rlimit>() , 16usize , concat ! (
               "Size of: " , stringify ! ( rlimit ) ));
    assert_eq! (::core::mem::align_of::<rlimit>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rlimit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rlimit ) ) . rlim_cur as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rlimit ) , "::" ,
                stringify ! ( rlim_cur ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rlimit ) ) . rlim_max as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rlimit ) , "::" ,
                stringify ! ( rlim_max ) ));
}
impl Clone for rlimit {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct orlimit {
    pub rlim_cur: __int32_t,
    pub rlim_max: __int32_t,
}
#[test]
fn bindgen_test_layout_orlimit() {
    assert_eq!(::core::mem::size_of::<orlimit>() , 8usize , concat ! (
               "Size of: " , stringify ! ( orlimit ) ));
    assert_eq! (::core::mem::align_of::<orlimit>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( orlimit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const orlimit ) ) . rlim_cur as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( orlimit ) , "::" ,
                stringify ! ( rlim_cur ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const orlimit ) ) . rlim_max as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( orlimit ) , "::" ,
                stringify ! ( rlim_max ) ));
}
impl Clone for orlimit {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct loadavg {
    pub ldavg: [__fixpt_t; 3usize],
    pub fscale: ::kernel::sys::raw::c_long,
}
#[test]
fn bindgen_test_layout_loadavg() {
    assert_eq!(::core::mem::size_of::<loadavg>() , 24usize , concat ! (
               "Size of: " , stringify ! ( loadavg ) ));
    assert_eq! (::core::mem::align_of::<loadavg>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( loadavg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const loadavg ) ) . ldavg as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( loadavg ) , "::" ,
                stringify ! ( ldavg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const loadavg ) ) . fscale as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( loadavg ) , "::" ,
                stringify ! ( fscale ) ));
}
impl Clone for loadavg {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "averunnable"]
    pub static mut averunnable: loadavg;
}
extern "C" {
    pub fn read_cpu_time(cp_time: *mut ::kernel::sys::raw::c_long);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcb {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "__start_set_pcpu"]
    pub static mut __start_set_pcpu: *mut usize;
}
extern "C" {
    #[link_name = "__stop_set_pcpu"]
    pub static mut __stop_set_pcpu: *mut usize;
}
extern "C" {
    #[link_name = "dpcpu_off"]
    pub static mut dpcpu_off: [usize; 0usize];
}
#[repr(C)]
#[derive(Copy)]
pub struct pcpu {
    pub pc_curthread: *mut thread,
    pub pc_idlethread: *mut thread,
    pub pc_fpcurthread: *mut thread,
    pub pc_deadthread: *mut thread,
    pub pc_curpcb: *mut pcb,
    pub pc_switchtime: u64,
    pub pc_switchticks: ::kernel::sys::raw::c_int,
    pub pc_cpuid: u_int,
    pub pc_allcpu: pcpu__bindgen_ty_1,
    pub pc_spinlocks: *mut lock_list_entry,
    pub pc_cp_time: [::kernel::sys::raw::c_long; 5usize],
    pub pc_device: *mut device,
    pub pc_netisr: *mut ::kernel::sys::raw::c_void,
    pub pc_unused1: ::kernel::sys::raw::c_int,
    pub pc_domain: ::kernel::sys::raw::c_int,
    pub pc_rm_queue: rm_queue,
    pub pc_dynamic: usize,
    pub pc_early_dummy_counter: u64,
    pub __bindgen_padding_0: [u8; 88usize],
    pub pc_monitorbuf: [::kernel::sys::raw::c_char; 128usize],
    pub pc_prvspace: *mut pcpu,
    pub pc_curpmap: *mut pmap,
    pub pc_tssp: *mut amd64tss,
    pub pc_commontssp: *mut amd64tss,
    pub pc_kcr3: u64,
    pub pc_ucr3: u64,
    pub pc_saved_ucr3: u64,
    pub pc_rsp0: register_t,
    pub pc_scratch_rsp: register_t,
    pub pc_scratch_rax: register_t,
    pub pc_apic_id: u_int,
    pub pc_acpi_id: u_int,
    pub pc_fs32p: *mut user_segment_descriptor,
    pub pc_gs32p: *mut user_segment_descriptor,
    pub pc_ldt: *mut system_segment_descriptor,
    pub pc_tss: *mut system_segment_descriptor,
    pub pc_pm_save_cnt: u64,
    pub pc_cmci_mask: u_int,
    pub pc_dbreg: [u64; 16usize],
    pub pc_pti_stack: [u64; 16usize],
    pub pc_pti_rsp0: register_t,
    pub pc_dbreg_cmd: ::kernel::sys::raw::c_int,
    pub pc_vcpu_id: u_int,
    pub pc_pcid_next: u32,
    pub pc_pcid_gen: u32,
    pub pc_smp_tlb_done: u32,
    pub pc_ibpb_set: u32,
    pub __pad: [::kernel::sys::raw::c_char; 216usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pcpu__bindgen_ty_1 {
    pub stqe_next: *mut pcpu,
}
#[test]
fn bindgen_test_layout_pcpu__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<pcpu__bindgen_ty_1>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( pcpu__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<pcpu__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( pcpu__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu__bindgen_ty_1 ) ) . stqe_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu__bindgen_ty_1 ) ,
                "::" , stringify ! ( stqe_next ) ));
}
impl Clone for pcpu__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for pcpu__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_pcpu() {
    assert_eq!(::core::mem::size_of::<pcpu>() , 1024usize , concat ! (
               "Size of: " , stringify ! ( pcpu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_curthread as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_curthread ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_idlethread as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_idlethread ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_fpcurthread as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_fpcurthread ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_deadthread as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_deadthread ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_curpcb as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_curpcb ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_switchtime as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_switchtime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_switchticks as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_switchticks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_cpuid as * const _ as usize
                } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_cpuid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_allcpu as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_allcpu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_spinlocks as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_spinlocks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_cp_time as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_cp_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_device as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_device ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_netisr as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_netisr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_unused1 as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_unused1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_domain as * const _ as
                usize } , 132usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_domain ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_rm_queue as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_rm_queue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_dynamic as * const _ as
                usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_dynamic ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_early_dummy_counter as *
                const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_early_dummy_counter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_monitorbuf as * const _ as
                usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_monitorbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_prvspace as * const _ as
                usize } , 384usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_prvspace ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_curpmap as * const _ as
                usize } , 392usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_curpmap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_tssp as * const _ as usize
                } , 400usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_tssp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_commontssp as * const _ as
                usize } , 408usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_commontssp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_kcr3 as * const _ as usize
                } , 416usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_kcr3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_ucr3 as * const _ as usize
                } , 424usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_ucr3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_saved_ucr3 as * const _ as
                usize } , 432usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_saved_ucr3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_rsp0 as * const _ as usize
                } , 440usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_rsp0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_scratch_rsp as * const _ as
                usize } , 448usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_scratch_rsp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_scratch_rax as * const _ as
                usize } , 456usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_scratch_rax ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_apic_id as * const _ as
                usize } , 464usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_apic_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_acpi_id as * const _ as
                usize } , 468usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_acpi_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_fs32p as * const _ as usize
                } , 472usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_fs32p ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_gs32p as * const _ as usize
                } , 480usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_gs32p ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_ldt as * const _ as usize }
                , 488usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_ldt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_tss as * const _ as usize }
                , 496usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_tss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_pm_save_cnt as * const _ as
                usize } , 504usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_pm_save_cnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_cmci_mask as * const _ as
                usize } , 512usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_cmci_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_dbreg as * const _ as usize
                } , 520usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_dbreg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_pti_stack as * const _ as
                usize } , 648usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_pti_stack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_pti_rsp0 as * const _ as
                usize } , 776usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_pti_rsp0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_dbreg_cmd as * const _ as
                usize } , 784usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_dbreg_cmd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_vcpu_id as * const _ as
                usize } , 788usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_vcpu_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_pcid_next as * const _ as
                usize } , 792usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_pcid_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_pcid_gen as * const _ as
                usize } , 796usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_pcid_gen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_smp_tlb_done as * const _
                as usize } , 800usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_smp_tlb_done ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_ibpb_set as * const _ as
                usize } , 804usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_ibpb_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . __pad as * const _ as usize }
                , 808usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( __pad ) ));
}
impl Clone for pcpu {
    fn clone(&self) -> Self { *self }
}
impl Default for pcpu {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for pcpu {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "pcpu {{ pc_curthread: {:?}, pc_idlethread: {:?}, pc_fpcurthread: {:?}, pc_deadthread: {:?}, pc_curpcb: {:?}, pc_switchtime: {:?}, pc_switchticks: {:?}, pc_cpuid: {:?}, pc_allcpu: {:?}, pc_spinlocks: {:?}, pc_cp_time: {:?}, pc_device: {:?}, pc_netisr: {:?}, pc_unused1: {:?}, pc_domain: {:?}, pc_rm_queue: {:?}, pc_dynamic: {:?}, pc_early_dummy_counter: {:?}, pc_monitorbuf: [{}], pc_prvspace: {:?}, pc_curpmap: {:?}, pc_tssp: {:?}, pc_commontssp: {:?}, pc_kcr3: {:?}, pc_ucr3: {:?}, pc_saved_ucr3: {:?}, pc_rsp0: {:?}, pc_scratch_rsp: {:?}, pc_scratch_rax: {:?}, pc_apic_id: {:?}, pc_acpi_id: {:?}, pc_fs32p: {:?}, pc_gs32p: {:?}, pc_ldt: {:?}, pc_tss: {:?}, pc_pm_save_cnt: {:?}, pc_cmci_mask: {:?}, pc_dbreg: {:?}, pc_pti_stack: {:?}, pc_pti_rsp0: {:?}, pc_dbreg_cmd: {:?}, pc_vcpu_id: {:?}, pc_pcid_next: {:?}, pc_pcid_gen: {:?}, pc_smp_tlb_done: {:?}, pc_ibpb_set: {:?}, __pad: [{}] }}"
               , self . pc_curthread , self . pc_idlethread , self .
               pc_fpcurthread , self . pc_deadthread , self . pc_curpcb , self
               . pc_switchtime , self . pc_switchticks , self . pc_cpuid ,
               self . pc_allcpu , self . pc_spinlocks , self . pc_cp_time ,
               self . pc_device , self . pc_netisr , self . pc_unused1 , self
               . pc_domain , self . pc_rm_queue , self . pc_dynamic , self .
               pc_early_dummy_counter , self . pc_monitorbuf . iter (  ) .
               enumerate (  ) . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ) , self . pc_prvspace , self . pc_curpmap , self .
               pc_tssp , self . pc_commontssp , self . pc_kcr3 , self .
               pc_ucr3 , self . pc_saved_ucr3 , self . pc_rsp0 , self .
               pc_scratch_rsp , self . pc_scratch_rax , self . pc_apic_id ,
               self . pc_acpi_id , self . pc_fs32p , self . pc_gs32p , self .
               pc_ldt , self . pc_tss , self . pc_pm_save_cnt , self .
               pc_cmci_mask , self . pc_dbreg , self . pc_pti_stack , self .
               pc_pti_rsp0 , self . pc_dbreg_cmd , self . pc_vcpu_id , self .
               pc_pcid_next , self . pc_pcid_gen , self . pc_smp_tlb_done ,
               self . pc_ibpb_set , self . __pad . iter (  ) . enumerate (  )
               . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ))
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cpuhead {
    pub stqh_first: *mut pcpu,
    pub stqh_last: *mut *mut pcpu,
}
#[test]
fn bindgen_test_layout_cpuhead() {
    assert_eq!(::core::mem::size_of::<cpuhead>() , 16usize , concat ! (
               "Size of: " , stringify ! ( cpuhead ) ));
    assert_eq! (::core::mem::align_of::<cpuhead>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( cpuhead ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuhead ) ) . stqh_first as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuhead ) , "::" ,
                stringify ! ( stqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuhead ) ) . stqh_last as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuhead ) , "::" ,
                stringify ! ( stqh_last ) ));
}
impl Clone for cpuhead {
    fn clone(&self) -> Self { *self }
}
impl Default for cpuhead {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    #[link_name = "cpuhead"]
    pub static mut cpuhead: cpuhead;
}
extern "C" {
    #[link_name = "cpuid_to_pcpu"]
    pub static mut cpuid_to_pcpu: [*mut pcpu; 0usize];
}
extern "C" {
    pub fn cpu_pcpu_init(pcpu: *mut pcpu, cpuid: ::kernel::sys::raw::c_int,
                         size: usize);
}
extern "C" {
    pub fn db_show_mdpcpu(pcpu: *mut pcpu);
}
extern "C" {
    pub fn dpcpu_alloc(size: ::kernel::sys::raw::c_int)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn dpcpu_copy(s: *mut ::kernel::sys::raw::c_void,
                      size: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn dpcpu_free(s: *mut ::kernel::sys::raw::c_void,
                      size: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn dpcpu_init(dpcpu: *mut ::kernel::sys::raw::c_void,
                      cpuid: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn pcpu_destroy(pcpu: *mut pcpu);
}
extern "C" {
    pub fn pcpu_find(cpuid: u_int) -> *mut pcpu;
}
extern "C" {
    pub fn pcpu_init(pcpu: *mut pcpu, cpuid: ::kernel::sys::raw::c_int,
                     size: usize);
}
extern "C" {
    #[link_name = "__pcpu"]
    pub static mut __pcpu: [pcpu; 0usize];
}
extern "C" {
    pub fn counter_u64_alloc(arg1: ::kernel::sys::raw::c_int)
     -> counter_u64_t;
}
extern "C" {
    pub fn counter_u64_free(arg1: counter_u64_t);
}
extern "C" {
    pub fn counter_u64_zero(arg1: counter_u64_t);
}
extern "C" {
    pub fn counter_u64_fetch(arg1: counter_u64_t) -> u64;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct counter_rate {
    pub cr_rate: counter_u64_t,
    pub cr_lock: ::kernel::sys::raw::c_int,
    pub cr_ticks: ::kernel::sys::raw::c_int,
    pub cr_over: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_counter_rate() {
    assert_eq!(::core::mem::size_of::<counter_rate>() , 24usize , concat ! (
               "Size of: " , stringify ! ( counter_rate ) ));
    assert_eq! (::core::mem::align_of::<counter_rate>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( counter_rate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const counter_rate ) ) . cr_rate as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( counter_rate ) , "::" ,
                stringify ! ( cr_rate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const counter_rate ) ) . cr_lock as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( counter_rate ) , "::" ,
                stringify ! ( cr_lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const counter_rate ) ) . cr_ticks as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( counter_rate ) , "::" ,
                stringify ! ( cr_ticks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const counter_rate ) ) . cr_over as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( counter_rate ) , "::" ,
                stringify ! ( cr_over ) ));
}
impl Clone for counter_rate {
    fn clone(&self) -> Self { *self }
}
impl Default for counter_rate {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    pub fn counter_ratecheck(arg1: *mut counter_rate, arg2: i64) -> i64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lock_list_entry {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lock_class {
    pub lc_name: *const ::kernel::sys::raw::c_char,
    pub lc_flags: u_int,
    pub lc_assert: ::core::option::Option<unsafe extern "C" fn(lock:
                                                                   *const lock_object,
                                                               what:
                                                                   ::kernel::sys::raw::c_int)>,
    pub lc_ddb_show: ::core::option::Option<unsafe extern "C" fn(lock:
                                                                     *const lock_object)>,
    pub lc_lock: ::core::option::Option<unsafe extern "C" fn(lock:
                                                                 *mut lock_object,
                                                             how: usize)>,
    pub lc_owner: ::core::option::Option<unsafe extern "C" fn(lock:
                                                                  *const lock_object,
                                                              owner:
                                                                  *mut *mut thread)
                                             -> ::kernel::sys::raw::c_int>,
    pub lc_unlock: ::core::option::Option<unsafe extern "C" fn(lock:
                                                                   *mut lock_object)
                                              -> usize>,
}
#[test]
fn bindgen_test_layout_lock_class() {
    assert_eq!(::core::mem::size_of::<lock_class>() , 56usize , concat ! (
               "Size of: " , stringify ! ( lock_class ) ));
    assert_eq! (::core::mem::align_of::<lock_class>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lock_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_class ) ) . lc_name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_class ) , "::" ,
                stringify ! ( lc_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_class ) ) . lc_flags as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_class ) , "::" ,
                stringify ! ( lc_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_class ) ) . lc_assert as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_class ) , "::" ,
                stringify ! ( lc_assert ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_class ) ) . lc_ddb_show as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_class ) , "::" ,
                stringify ! ( lc_ddb_show ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_class ) ) . lc_lock as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_class ) , "::" ,
                stringify ! ( lc_lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_class ) ) . lc_owner as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_class ) , "::" ,
                stringify ! ( lc_owner ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_class ) ) . lc_unlock as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_class ) , "::" ,
                stringify ! ( lc_unlock ) ));
}
impl Clone for lock_class {
    fn clone(&self) -> Self { *self }
}
impl Default for lock_class {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    #[link_name = "lock_class_mtx_sleep"]
    pub static mut lock_class_mtx_sleep: lock_class;
}
extern "C" {
    #[link_name = "lock_class_mtx_spin"]
    pub static mut lock_class_mtx_spin: lock_class;
}
extern "C" {
    #[link_name = "lock_class_sx"]
    pub static mut lock_class_sx: lock_class;
}
extern "C" {
    #[link_name = "lock_class_rw"]
    pub static mut lock_class_rw: lock_class;
}
extern "C" {
    #[link_name = "lock_class_rm"]
    pub static mut lock_class_rm: lock_class;
}
extern "C" {
    #[link_name = "lock_class_rm_sleepable"]
    pub static mut lock_class_rm_sleepable: lock_class;
}
extern "C" {
    #[link_name = "lock_class_lockmgr"]
    pub static mut lock_class_lockmgr: lock_class;
}
extern "C" {
    #[link_name = "lock_classes"]
    pub static mut lock_classes: [*mut lock_class; 0usize];
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct lock_delay_config {
    pub base: u_int,
    pub max: u_int,
}
#[test]
fn bindgen_test_layout_lock_delay_config() {
    assert_eq!(::core::mem::size_of::<lock_delay_config>() , 8usize , concat !
               ( "Size of: " , stringify ! ( lock_delay_config ) ));
    assert_eq! (::core::mem::align_of::<lock_delay_config>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( lock_delay_config ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_delay_config ) ) . base as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_delay_config ) ,
                "::" , stringify ! ( base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_delay_config ) ) . max as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_delay_config ) ,
                "::" , stringify ! ( max ) ));
}
impl Clone for lock_delay_config {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lock_delay_arg {
    pub config: *mut lock_delay_config,
    pub delay: u_int,
    pub spin_cnt: u_int,
}
#[test]
fn bindgen_test_layout_lock_delay_arg() {
    assert_eq!(::core::mem::size_of::<lock_delay_arg>() , 16usize , concat ! (
               "Size of: " , stringify ! ( lock_delay_arg ) ));
    assert_eq! (::core::mem::align_of::<lock_delay_arg>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( lock_delay_arg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_delay_arg ) ) . config as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_delay_arg ) , "::"
                , stringify ! ( config ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_delay_arg ) ) . delay as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_delay_arg ) , "::"
                , stringify ! ( delay ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_delay_arg ) ) . spin_cnt as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_delay_arg ) , "::"
                , stringify ! ( spin_cnt ) ));
}
impl Clone for lock_delay_arg {
    fn clone(&self) -> Self { *self }
}
impl Default for lock_delay_arg {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    pub fn lock_init(arg1: *mut lock_object, arg2: *mut lock_class,
                     arg3: *const ::kernel::sys::raw::c_char,
                     arg4: *const ::kernel::sys::raw::c_char,
                     arg5: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn lock_destroy(arg1: *mut lock_object);
}
extern "C" {
    pub fn lock_delay(arg1: *mut lock_delay_arg);
}
extern "C" {
    pub fn lock_delay_default_init(arg1: *mut lock_delay_config);
}
extern "C" {
    pub fn spinlock_enter();
}
extern "C" {
    pub fn spinlock_exit();
}
extern "C" {
    pub fn witness_init(arg1: *mut lock_object,
                        arg2: *const ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn witness_destroy(arg1: *mut lock_object);
}
extern "C" {
    pub fn witness_defineorder(arg1: *mut lock_object, arg2: *mut lock_object)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn witness_checkorder(arg1: *mut lock_object,
                              arg2: ::kernel::sys::raw::c_int,
                              arg3: *const ::kernel::sys::raw::c_char,
                              arg4: ::kernel::sys::raw::c_int,
                              arg5: *mut lock_object);
}
extern "C" {
    pub fn witness_lock(arg1: *mut lock_object,
                        arg2: ::kernel::sys::raw::c_int,
                        arg3: *const ::kernel::sys::raw::c_char,
                        arg4: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn witness_upgrade(arg1: *mut lock_object,
                           arg2: ::kernel::sys::raw::c_int,
                           arg3: *const ::kernel::sys::raw::c_char,
                           arg4: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn witness_downgrade(arg1: *mut lock_object,
                             arg2: ::kernel::sys::raw::c_int,
                             arg3: *const ::kernel::sys::raw::c_char,
                             arg4: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn witness_unlock(arg1: *mut lock_object,
                          arg2: ::kernel::sys::raw::c_int,
                          arg3: *const ::kernel::sys::raw::c_char,
                          arg4: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn witness_save(arg1: *mut lock_object,
                        arg2: *mut *const ::kernel::sys::raw::c_char,
                        arg3: *mut ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn witness_restore(arg1: *mut lock_object,
                           arg2: *const ::kernel::sys::raw::c_char,
                           arg3: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn witness_list_locks(arg1: *mut *mut lock_list_entry,
                              arg2:
                                  ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                                  *const ::kernel::sys::raw::c_char, ...)
                                                             ->
                                                                 ::kernel::sys::raw::c_int>)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn witness_warn(arg1: ::kernel::sys::raw::c_int,
                        arg2: *mut lock_object,
                        arg3: *const ::kernel::sys::raw::c_char, ...)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn witness_assert(arg1: *const lock_object,
                          arg2: ::kernel::sys::raw::c_int,
                          arg3: *const ::kernel::sys::raw::c_char,
                          arg4: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn witness_display_spinlock(arg1: *mut lock_object, arg2: *mut thread,
                                    arg3:
                                        ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                                        *const ::kernel::sys::raw::c_char, ...)
                                                                   ->
                                                                       ::kernel::sys::raw::c_int>);
}
extern "C" {
    pub fn witness_line(arg1: *mut lock_object) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn witness_norelease(arg1: *mut lock_object);
}
extern "C" {
    pub fn witness_releaseok(arg1: *mut lock_object);
}
extern "C" {
    pub fn witness_file(arg1: *mut lock_object)
     -> *const ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn witness_thread_exit(arg1: *mut thread);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct kevent {
    pub ident: __uintptr_t,
    pub filter: ::kernel::sys::raw::c_short,
    pub flags: ::kernel::sys::raw::c_ushort,
    pub fflags: ::kernel::sys::raw::c_uint,
    pub data: __int64_t,
    pub udata: *mut ::kernel::sys::raw::c_void,
    pub ext: [__uint64_t; 4usize],
}
#[test]
fn bindgen_test_layout_kevent() {
    assert_eq!(::core::mem::size_of::<kevent>() , 64usize , concat ! (
               "Size of: " , stringify ! ( kevent ) ));
    assert_eq! (::core::mem::align_of::<kevent>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kevent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kevent ) ) . ident as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kevent ) , "::" ,
                stringify ! ( ident ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kevent ) ) . filter as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kevent ) , "::" ,
                stringify ! ( filter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kevent ) ) . flags as * const _ as usize
                } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( kevent ) , "::" ,
                stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kevent ) ) . fflags as * const _ as usize
                } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( kevent ) , "::" ,
                stringify ! ( fflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kevent ) ) . data as * const _ as usize }
                , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( kevent ) , "::" ,
                stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kevent ) ) . udata as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( kevent ) , "::" ,
                stringify ! ( udata ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kevent ) ) . ext as * const _ as usize }
                , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( kevent ) , "::" ,
                stringify ! ( ext ) ));
}
impl Clone for kevent {
    fn clone(&self) -> Self { *self }
}
impl Default for kevent {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kevent32 {
    pub ident: u32,
    pub filter: ::kernel::sys::raw::c_short,
    pub flags: u_short,
    pub fflags: u_int,
    pub data1: i32,
    pub data2: i32,
    pub udata: u32,
    pub ext64: [u32; 8usize],
}
#[test]
fn bindgen_test_layout_kevent32() {
    assert_eq!(::core::mem::size_of::<kevent32>() , 56usize , concat ! (
               "Size of: " , stringify ! ( kevent32 ) ));
    assert_eq! (::core::mem::align_of::<kevent32>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( kevent32 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kevent32 ) ) . ident as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kevent32 ) , "::" ,
                stringify ! ( ident ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kevent32 ) ) . filter as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kevent32 ) , "::" ,
                stringify ! ( filter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kevent32 ) ) . flags as * const _ as
                usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( kevent32 ) , "::" ,
                stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kevent32 ) ) . fflags as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kevent32 ) , "::" ,
                stringify ! ( fflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kevent32 ) ) . data1 as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( kevent32 ) , "::" ,
                stringify ! ( data1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kevent32 ) ) . data2 as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( kevent32 ) , "::" ,
                stringify ! ( data2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kevent32 ) ) . udata as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( kevent32 ) , "::" ,
                stringify ! ( udata ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kevent32 ) ) . ext64 as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( kevent32 ) , "::" ,
                stringify ! ( ext64 ) ));
}
impl Clone for kevent32 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct knote {
    pub kn_link: knote__bindgen_ty_1,
    pub kn_selnext: knote__bindgen_ty_2,
    pub kn_knlist: *mut knlist,
    pub kn_tqe: knote__bindgen_ty_3,
    pub kn_kq: *mut kqueue,
    pub kn_kevent: kevent,
    pub kn_hook: *mut ::kernel::sys::raw::c_void,
    pub kn_hookid: ::kernel::sys::raw::c_int,
    pub kn_status: ::kernel::sys::raw::c_int,
    pub kn_influx: ::kernel::sys::raw::c_int,
    pub kn_sfflags: ::kernel::sys::raw::c_int,
    pub kn_sdata: i64,
    pub kn_ptr: knote__bindgen_ty_4,
    pub kn_fop: *mut filterops,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct knote__bindgen_ty_1 {
    pub sle_next: *mut knote,
}
#[test]
fn bindgen_test_layout_knote__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<knote__bindgen_ty_1>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( knote__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<knote__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( knote__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote__bindgen_ty_1 ) ) . sle_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( knote__bindgen_ty_1 ) ,
                "::" , stringify ! ( sle_next ) ));
}
impl Clone for knote__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for knote__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct knote__bindgen_ty_2 {
    pub sle_next: *mut knote,
}
#[test]
fn bindgen_test_layout_knote__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<knote__bindgen_ty_2>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( knote__bindgen_ty_2 ) ));
    assert_eq! (::core::mem::align_of::<knote__bindgen_ty_2>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( knote__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote__bindgen_ty_2 ) ) . sle_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( knote__bindgen_ty_2 ) ,
                "::" , stringify ! ( sle_next ) ));
}
impl Clone for knote__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for knote__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct knote__bindgen_ty_3 {
    pub tqe_next: *mut knote,
    pub tqe_prev: *mut *mut knote,
}
#[test]
fn bindgen_test_layout_knote__bindgen_ty_3() {
    assert_eq!(::core::mem::size_of::<knote__bindgen_ty_3>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( knote__bindgen_ty_3 )
               ));
    assert_eq! (::core::mem::align_of::<knote__bindgen_ty_3>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( knote__bindgen_ty_3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote__bindgen_ty_3 ) ) . tqe_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( knote__bindgen_ty_3 ) ,
                "::" , stringify ! ( tqe_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote__bindgen_ty_3 ) ) . tqe_prev as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( knote__bindgen_ty_3 ) ,
                "::" , stringify ! ( tqe_prev ) ));
}
impl Clone for knote__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
impl Default for knote__bindgen_ty_3 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub union knote__bindgen_ty_4 {
    pub p_fp: *mut file,
    pub p_proc: *mut proc_,
    pub p_aio: *mut kaiocb,
    pub p_lio: *mut aioliojob,
    pub p_v: *mut ::kernel::sys::raw::c_void,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_knote__bindgen_ty_4() {
    assert_eq!(::core::mem::size_of::<knote__bindgen_ty_4>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( knote__bindgen_ty_4 ) ));
    assert_eq! (::core::mem::align_of::<knote__bindgen_ty_4>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( knote__bindgen_ty_4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote__bindgen_ty_4 ) ) . p_fp as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( knote__bindgen_ty_4 ) ,
                "::" , stringify ! ( p_fp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote__bindgen_ty_4 ) ) . p_proc as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( knote__bindgen_ty_4 ) ,
                "::" , stringify ! ( p_proc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote__bindgen_ty_4 ) ) . p_aio as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( knote__bindgen_ty_4 ) ,
                "::" , stringify ! ( p_aio ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote__bindgen_ty_4 ) ) . p_lio as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( knote__bindgen_ty_4 ) ,
                "::" , stringify ! ( p_lio ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote__bindgen_ty_4 ) ) . p_v as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( knote__bindgen_ty_4 ) ,
                "::" , stringify ! ( p_v ) ));
}
impl Clone for knote__bindgen_ty_4 {
    fn clone(&self) -> Self { *self }
}
impl Default for knote__bindgen_ty_4 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for knote__bindgen_ty_4 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "knote__bindgen_ty_4 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_knote() {
    assert_eq!(::core::mem::size_of::<knote>() , 160usize , concat ! (
               "Size of: " , stringify ! ( knote ) ));
    assert_eq! (::core::mem::align_of::<knote>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( knote ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote ) ) . kn_link as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( knote ) , "::" ,
                stringify ! ( kn_link ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote ) ) . kn_selnext as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( knote ) , "::" ,
                stringify ! ( kn_selnext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote ) ) . kn_knlist as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( knote ) , "::" ,
                stringify ! ( kn_knlist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote ) ) . kn_tqe as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( knote ) , "::" ,
                stringify ! ( kn_tqe ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote ) ) . kn_kq as * const _ as usize }
                , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( knote ) , "::" ,
                stringify ! ( kn_kq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote ) ) . kn_kevent as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( knote ) , "::" ,
                stringify ! ( kn_kevent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote ) ) . kn_hook as * const _ as usize
                } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( knote ) , "::" ,
                stringify ! ( kn_hook ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote ) ) . kn_hookid as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( knote ) , "::" ,
                stringify ! ( kn_hookid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote ) ) . kn_status as * const _ as
                usize } , 124usize , concat ! (
                "Alignment of field: " , stringify ! ( knote ) , "::" ,
                stringify ! ( kn_status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote ) ) . kn_influx as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( knote ) , "::" ,
                stringify ! ( kn_influx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote ) ) . kn_sfflags as * const _ as
                usize } , 132usize , concat ! (
                "Alignment of field: " , stringify ! ( knote ) , "::" ,
                stringify ! ( kn_sfflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote ) ) . kn_sdata as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( knote ) , "::" ,
                stringify ! ( kn_sdata ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote ) ) . kn_ptr as * const _ as usize
                } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( knote ) , "::" ,
                stringify ! ( kn_ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote ) ) . kn_fop as * const _ as usize
                } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( knote ) , "::" ,
                stringify ! ( kn_fop ) ));
}
impl Clone for knote {
    fn clone(&self) -> Self { *self }
}
impl Default for knote {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for knote {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "knote {{ kn_link: {:?}, kn_selnext: {:?}, kn_knlist: {:?}, kn_tqe: {:?}, kn_kq: {:?}, kn_kevent: {:?}, kn_hook: {:?}, kn_hookid: {:?}, kn_status: {:?}, kn_influx: {:?}, kn_sfflags: {:?}, kn_sdata: {:?}, kn_ptr: {:?}, kn_fop: {:?} }}"
               , self . kn_link , self . kn_selnext , self . kn_knlist , self
               . kn_tqe , self . kn_kq , self . kn_kevent , self . kn_hook ,
               self . kn_hookid , self . kn_status , self . kn_influx , self .
               kn_sfflags , self . kn_sdata , self . kn_ptr , self . kn_fop)
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct klist {
    pub slh_first: *mut knote,
}
#[test]
fn bindgen_test_layout_klist() {
    assert_eq!(::core::mem::size_of::<klist>() , 8usize , concat ! (
               "Size of: " , stringify ! ( klist ) ));
    assert_eq! (::core::mem::align_of::<klist>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( klist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const klist ) ) . slh_first as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( klist ) , "::" ,
                stringify ! ( slh_first ) ));
}
impl Clone for klist {
    fn clone(&self) -> Self { *self }
}
impl Default for klist {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kqueue {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct kqlist {
    pub tqh_first: *mut kqueue,
    pub tqh_last: *mut *mut kqueue,
}
#[test]
fn bindgen_test_layout_kqlist() {
    assert_eq!(::core::mem::size_of::<kqlist>() , 16usize , concat ! (
               "Size of: " , stringify ! ( kqlist ) ));
    assert_eq! (::core::mem::align_of::<kqlist>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kqlist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kqlist ) ) . tqh_first as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kqlist ) , "::" ,
                stringify ! ( tqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kqlist ) ) . tqh_last as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kqlist ) , "::" ,
                stringify ! ( tqh_last ) ));
}
impl Clone for kqlist {
    fn clone(&self) -> Self { *self }
}
impl Default for kqlist {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct knlist {
    pub kl_list: klist,
    pub kl_lock: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                 *mut ::kernel::sys::raw::c_void)>,
    pub kl_unlock: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                   *mut ::kernel::sys::raw::c_void)>,
    pub kl_assert_locked: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                          *mut ::kernel::sys::raw::c_void)>,
    pub kl_assert_unlocked: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                            *mut ::kernel::sys::raw::c_void)>,
    pub kl_lockarg: *mut ::kernel::sys::raw::c_void,
    pub kl_autodestroy: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_knlist() {
    assert_eq!(::core::mem::size_of::<knlist>() , 56usize , concat ! (
               "Size of: " , stringify ! ( knlist ) ));
    assert_eq! (::core::mem::align_of::<knlist>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( knlist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knlist ) ) . kl_list as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( knlist ) , "::" ,
                stringify ! ( kl_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knlist ) ) . kl_lock as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( knlist ) , "::" ,
                stringify ! ( kl_lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knlist ) ) . kl_unlock as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( knlist ) , "::" ,
                stringify ! ( kl_unlock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knlist ) ) . kl_assert_locked as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( knlist ) , "::" ,
                stringify ! ( kl_assert_locked ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knlist ) ) . kl_assert_unlocked as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( knlist ) , "::" ,
                stringify ! ( kl_assert_unlocked ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knlist ) ) . kl_lockarg as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( knlist ) , "::" ,
                stringify ! ( kl_lockarg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knlist ) ) . kl_autodestroy as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( knlist ) , "::" ,
                stringify ! ( kl_autodestroy ) ));
}
impl Clone for knlist {
    fn clone(&self) -> Self { *self }
}
impl Default for knlist {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct filterops {
    pub f_isfd: ::kernel::sys::raw::c_int,
    pub f_attach: ::core::option::Option<unsafe extern "C" fn(kn: *mut knote)
                                             -> ::kernel::sys::raw::c_int>,
    pub f_detach: ::core::option::Option<unsafe extern "C" fn(kn:
                                                                  *mut knote)>,
    pub f_event: ::core::option::Option<unsafe extern "C" fn(kn: *mut knote,
                                                             hint:
                                                                 ::kernel::sys::raw::c_long)
                                            -> ::kernel::sys::raw::c_int>,
    pub f_touch: ::core::option::Option<unsafe extern "C" fn(kn: *mut knote,
                                                             kev: *mut kevent,
                                                             type_: u_long)>,
}
#[test]
fn bindgen_test_layout_filterops() {
    assert_eq!(::core::mem::size_of::<filterops>() , 40usize , concat ! (
               "Size of: " , stringify ! ( filterops ) ));
    assert_eq! (::core::mem::align_of::<filterops>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( filterops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const filterops ) ) . f_isfd as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( filterops ) , "::" ,
                stringify ! ( f_isfd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const filterops ) ) . f_attach as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( filterops ) , "::" ,
                stringify ! ( f_attach ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const filterops ) ) . f_detach as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( filterops ) , "::" ,
                stringify ! ( f_detach ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const filterops ) ) . f_event as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( filterops ) , "::" ,
                stringify ! ( f_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const filterops ) ) . f_touch as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( filterops ) , "::" ,
                stringify ! ( f_touch ) ));
}
impl Clone for filterops {
    fn clone(&self) -> Self { *self }
}
impl Default for filterops {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct kevent_copyops {
    pub arg: *mut ::kernel::sys::raw::c_void,
    pub k_copyout: ::core::option::Option<unsafe extern "C" fn(arg:
                                                                   *mut ::kernel::sys::raw::c_void,
                                                               kevp:
                                                                   *mut kevent,
                                                               count:
                                                                   ::kernel::sys::raw::c_int)
                                              -> ::kernel::sys::raw::c_int>,
    pub k_copyin: ::core::option::Option<unsafe extern "C" fn(arg:
                                                                  *mut ::kernel::sys::raw::c_void,
                                                              kevp:
                                                                  *mut kevent,
                                                              count:
                                                                  ::kernel::sys::raw::c_int)
                                             -> ::kernel::sys::raw::c_int>,
    pub kevent_size: usize,
}
#[test]
fn bindgen_test_layout_kevent_copyops() {
    assert_eq!(::core::mem::size_of::<kevent_copyops>() , 32usize , concat ! (
               "Size of: " , stringify ! ( kevent_copyops ) ));
    assert_eq! (::core::mem::align_of::<kevent_copyops>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( kevent_copyops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kevent_copyops ) ) . arg as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kevent_copyops ) , "::"
                , stringify ! ( arg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kevent_copyops ) ) . k_copyout as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kevent_copyops ) , "::"
                , stringify ! ( k_copyout ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kevent_copyops ) ) . k_copyin as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( kevent_copyops ) , "::"
                , stringify ! ( k_copyin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kevent_copyops ) ) . kevent_size as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( kevent_copyops ) , "::"
                , stringify ! ( kevent_size ) ));
}
impl Clone for kevent_copyops {
    fn clone(&self) -> Self { *self }
}
impl Default for kevent_copyops {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rwlock {
    pub lock_object: lock_object,
    pub rw_lock: usize,
}
#[test]
fn bindgen_test_layout_rwlock() {
    assert_eq!(::core::mem::size_of::<rwlock>() , 32usize , concat ! (
               "Size of: " , stringify ! ( rwlock ) ));
    assert_eq! (::core::mem::align_of::<rwlock>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rwlock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rwlock ) ) . lock_object as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rwlock ) , "::" ,
                stringify ! ( lock_object ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rwlock ) ) . rw_lock as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rwlock ) , "::" ,
                stringify ! ( rw_lock ) ));
}
impl Clone for rwlock {
    fn clone(&self) -> Self { *self }
}
impl Default for rwlock {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    pub fn knote(list: *mut knlist, hint: ::kernel::sys::raw::c_long,
                 lockflags: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn knote_fork(list: *mut knlist, pid: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn knlist_alloc(lock: *mut mtx) -> *mut knlist;
}
extern "C" {
    pub fn knlist_detach(knl: *mut knlist);
}
extern "C" {
    pub fn knlist_add(knl: *mut knlist, kn: *mut knote,
                      islocked: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn knlist_remove(knl: *mut knlist, kn: *mut knote,
                         islocked: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn knlist_empty(knl: *mut knlist) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn knlist_init(knl: *mut knlist,
                       lock: *mut ::kernel::sys::raw::c_void,
                       kl_lock:
                           ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                           *mut ::kernel::sys::raw::c_void)>,
                       kl_unlock:
                           ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                           *mut ::kernel::sys::raw::c_void)>,
                       kl_assert_locked:
                           ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                           *mut ::kernel::sys::raw::c_void)>,
                       kl_assert_unlocked:
                           ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                           *mut ::kernel::sys::raw::c_void)>);
}
extern "C" {
    pub fn knlist_init_mtx(knl: *mut knlist, lock: *mut mtx);
}
extern "C" {
    pub fn knlist_init_rw_reader(knl: *mut knlist, lock: *mut rwlock);
}
extern "C" {
    pub fn knlist_destroy(knl: *mut knlist);
}
extern "C" {
    pub fn knlist_cleardel(knl: *mut knlist, td: *mut thread,
                           islocked: ::kernel::sys::raw::c_int,
                           killkn: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn knote_fdclose(p: *mut thread, fd: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn kqfd_register(fd: ::kernel::sys::raw::c_int, kev: *mut kevent,
                         p: *mut thread, waitok: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn kqueue_add_filteropts(filt: ::kernel::sys::raw::c_int,
                                 filtops: *mut filterops)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn kqueue_del_filteropts(filt: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cv_waitq {
    pub tqh_first: *mut thread,
    pub tqh_last: *mut *mut thread,
}
#[test]
fn bindgen_test_layout_cv_waitq() {
    assert_eq!(::core::mem::size_of::<cv_waitq>() , 16usize , concat ! (
               "Size of: " , stringify ! ( cv_waitq ) ));
    assert_eq! (::core::mem::align_of::<cv_waitq>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( cv_waitq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cv_waitq ) ) . tqh_first as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( cv_waitq ) , "::" ,
                stringify ! ( tqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cv_waitq ) ) . tqh_last as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( cv_waitq ) , "::" ,
                stringify ! ( tqh_last ) ));
}
impl Clone for cv_waitq {
    fn clone(&self) -> Self { *self }
}
impl Default for cv_waitq {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cv {
    pub cv_description: *const ::kernel::sys::raw::c_char,
    pub cv_waiters: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_cv() {
    assert_eq!(::core::mem::size_of::<cv>() , 16usize , concat ! (
               "Size of: " , stringify ! ( cv ) ));
    assert_eq! (::core::mem::align_of::<cv>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( cv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cv ) ) . cv_description as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( cv ) , "::" , stringify
                ! ( cv_description ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cv ) ) . cv_waiters as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( cv ) , "::" , stringify
                ! ( cv_waiters ) ));
}
impl Clone for cv {
    fn clone(&self) -> Self { *self }
}
impl Default for cv {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    pub fn cv_init(cvp: *mut cv, desc: *const ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn cv_destroy(cvp: *mut cv);
}
extern "C" {
    pub fn _cv_wait(cvp: *mut cv, lock: *mut lock_object);
}
extern "C" {
    pub fn _cv_wait_unlock(cvp: *mut cv, lock: *mut lock_object);
}
extern "C" {
    pub fn _cv_wait_sig(cvp: *mut cv, lock: *mut lock_object)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn _cv_timedwait_sbt(cvp: *mut cv, lock: *mut lock_object,
                             sbt: sbintime_t, pr: sbintime_t,
                             flags: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn _cv_timedwait_sig_sbt(cvp: *mut cv, lock: *mut lock_object,
                                 sbt: sbintime_t, pr: sbintime_t,
                                 flags: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn cv_signal(cvp: *mut cv);
}
extern "C" {
    pub fn cv_broadcastpri(cvp: *mut cv, pri: ::kernel::sys::raw::c_int);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lock_profile_object {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lpohead {
    pub lh_first: *mut lock_profile_object,
}
#[test]
fn bindgen_test_layout_lpohead() {
    assert_eq!(::core::mem::size_of::<lpohead>() , 8usize , concat ! (
               "Size of: " , stringify ! ( lpohead ) ));
    assert_eq! (::core::mem::align_of::<lpohead>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lpohead ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lpohead ) ) . lh_first as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lpohead ) , "::" ,
                stringify ! ( lh_first ) ));
}
impl Clone for lpohead {
    fn clone(&self) -> Self { *self }
}
impl Default for lpohead {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct osd {
    pub osd_nslots: u_int,
    pub osd_slots: *mut *mut ::kernel::sys::raw::c_void,
    pub osd_next: osd__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct osd__bindgen_ty_1 {
    pub le_next: *mut osd,
    pub le_prev: *mut *mut osd,
}
#[test]
fn bindgen_test_layout_osd__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<osd__bindgen_ty_1>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( osd__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<osd__bindgen_ty_1>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( osd__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const osd__bindgen_ty_1 ) ) . le_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( osd__bindgen_ty_1 ) ,
                "::" , stringify ! ( le_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const osd__bindgen_ty_1 ) ) . le_prev as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( osd__bindgen_ty_1 ) ,
                "::" , stringify ! ( le_prev ) ));
}
impl Clone for osd__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for osd__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_osd() {
    assert_eq!(::core::mem::size_of::<osd>() , 32usize , concat ! (
               "Size of: " , stringify ! ( osd ) ));
    assert_eq! (::core::mem::align_of::<osd>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( osd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const osd ) ) . osd_nslots as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( osd ) , "::" ,
                stringify ! ( osd_nslots ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const osd ) ) . osd_slots as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( osd ) , "::" ,
                stringify ! ( osd_slots ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const osd ) ) . osd_next as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( osd ) , "::" ,
                stringify ! ( osd_next ) ));
}
impl Clone for osd {
    fn clone(&self) -> Self { *self }
}
impl Default for osd {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type osd_destructor_t =
    ::core::option::Option<unsafe extern "C" fn(value:
                                                    *mut ::kernel::sys::raw::c_void)>;
pub type osd_method_t =
    ::core::option::Option<unsafe extern "C" fn(obj:
                                                    *mut ::kernel::sys::raw::c_void,
                                                data:
                                                    *mut ::kernel::sys::raw::c_void)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    pub fn osd_register(type_: u_int, destructor: osd_destructor_t,
                        methods: *mut osd_method_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn osd_deregister(type_: u_int, slot: u_int);
}
extern "C" {
    pub fn osd_set(type_: u_int, osd: *mut osd, slot: u_int,
                   value: *mut ::kernel::sys::raw::c_void)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn osd_reserve(slot: u_int) -> *mut *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn osd_set_reserved(type_: u_int, osd: *mut osd, slot: u_int,
                            rsv: *mut *mut ::kernel::sys::raw::c_void,
                            value: *mut ::kernel::sys::raw::c_void)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn osd_free_reserved(rsv: *mut *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn osd_get(type_: u_int, osd: *mut osd, slot: u_int)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn osd_del(type_: u_int, osd: *mut osd, slot: u_int);
}
extern "C" {
    pub fn osd_call(type_: u_int, method: u_int,
                    obj: *mut ::kernel::sys::raw::c_void,
                    data: *mut ::kernel::sys::raw::c_void)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn osd_exit(type_: u_int, osd: *mut osd);
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct rtprio {
    pub type_: u_short,
    pub prio: u_short,
}
#[test]
fn bindgen_test_layout_rtprio() {
    assert_eq!(::core::mem::size_of::<rtprio>() , 4usize , concat ! (
               "Size of: " , stringify ! ( rtprio ) ));
    assert_eq! (::core::mem::align_of::<rtprio>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( rtprio ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rtprio ) ) . type_ as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rtprio ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rtprio ) ) . prio as * const _ as usize }
                , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( rtprio ) , "::" ,
                stringify ! ( prio ) ));
}
impl Clone for rtprio {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn rtp_to_pri(arg1: *mut rtprio, arg2: *mut thread)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn pri_to_rtp(arg1: *mut thread, arg2: *mut rtprio);
}
pub type rqb_word_t = u_int64_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rqhead {
    pub tqh_first: *mut thread,
    pub tqh_last: *mut *mut thread,
}
#[test]
fn bindgen_test_layout_rqhead() {
    assert_eq!(::core::mem::size_of::<rqhead>() , 16usize , concat ! (
               "Size of: " , stringify ! ( rqhead ) ));
    assert_eq! (::core::mem::align_of::<rqhead>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rqhead ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rqhead ) ) . tqh_first as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rqhead ) , "::" ,
                stringify ! ( tqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rqhead ) ) . tqh_last as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rqhead ) , "::" ,
                stringify ! ( tqh_last ) ));
}
impl Clone for rqhead {
    fn clone(&self) -> Self { *self }
}
impl Default for rqhead {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct rqbits {
    pub rqb_bits: [rqb_word_t; 1usize],
}
#[test]
fn bindgen_test_layout_rqbits() {
    assert_eq!(::core::mem::size_of::<rqbits>() , 8usize , concat ! (
               "Size of: " , stringify ! ( rqbits ) ));
    assert_eq! (::core::mem::align_of::<rqbits>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rqbits ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rqbits ) ) . rqb_bits as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rqbits ) , "::" ,
                stringify ! ( rqb_bits ) ));
}
impl Clone for rqbits {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct runq {
    pub rq_status: rqbits,
    pub rq_queues: [rqhead; 64usize],
}
#[test]
fn bindgen_test_layout_runq() {
    assert_eq!(::core::mem::size_of::<runq>() , 1032usize , concat ! (
               "Size of: " , stringify ! ( runq ) ));
    assert_eq! (::core::mem::align_of::<runq>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( runq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const runq ) ) . rq_status as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( runq ) , "::" ,
                stringify ! ( rq_status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const runq ) ) . rq_queues as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( runq ) , "::" ,
                stringify ! ( rq_queues ) ));
}
impl Clone for runq {
    fn clone(&self) -> Self { *self }
}
impl Default for runq {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for runq {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "runq {{ rq_status: {:?}, rq_queues: [{}] }}" , self .
               rq_status , self . rq_queues . iter (  ) . enumerate (  ) . map
               (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ))
    }
}
extern "C" {
    pub fn runq_add(arg1: *mut runq, arg2: *mut thread,
                    arg3: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn runq_add_pri(arg1: *mut runq, arg2: *mut thread, arg3: u_char,
                        arg4: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn runq_check(arg1: *mut runq) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn runq_choose(arg1: *mut runq) -> *mut thread;
}
extern "C" {
    pub fn runq_choose_from(arg1: *mut runq, arg2: u_char) -> *mut thread;
}
extern "C" {
    pub fn runq_choose_fuzz(arg1: *mut runq, arg2: ::kernel::sys::raw::c_int)
     -> *mut thread;
}
extern "C" {
    pub fn runq_init(arg1: *mut runq);
}
extern "C" {
    pub fn runq_remove(arg1: *mut runq, arg2: *mut thread);
}
extern "C" {
    pub fn runq_remove_idx(arg1: *mut runq, arg2: *mut thread,
                           arg3: *mut u_char);
}
#[repr(C)]
#[derive(Copy)]
pub struct sigio {
    pub sio_u: sigio__bindgen_ty_1,
    pub sio_pgsigio: sigio__bindgen_ty_2,
    pub sio_myref: *mut *mut sigio,
    pub sio_ucred: *mut ucred,
    pub sio_pgid: pid_t,
}
#[repr(C)]
#[derive(Copy)]
pub union sigio__bindgen_ty_1 {
    pub siu_proc: *mut proc_,
    pub siu_pgrp: *mut pgrp,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_sigio__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<sigio__bindgen_ty_1>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( sigio__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<sigio__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( sigio__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigio__bindgen_ty_1 ) ) . siu_proc as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigio__bindgen_ty_1 ) ,
                "::" , stringify ! ( siu_proc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigio__bindgen_ty_1 ) ) . siu_pgrp as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigio__bindgen_ty_1 ) ,
                "::" , stringify ! ( siu_pgrp ) ));
}
impl Clone for sigio__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for sigio__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for sigio__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "sigio__bindgen_ty_1 {{ union }}")
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sigio__bindgen_ty_2 {
    pub sle_next: *mut sigio,
}
#[test]
fn bindgen_test_layout_sigio__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<sigio__bindgen_ty_2>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( sigio__bindgen_ty_2 ) ));
    assert_eq! (::core::mem::align_of::<sigio__bindgen_ty_2>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( sigio__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigio__bindgen_ty_2 ) ) . sle_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigio__bindgen_ty_2 ) ,
                "::" , stringify ! ( sle_next ) ));
}
impl Clone for sigio__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for sigio__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_sigio() {
    assert_eq!(::core::mem::size_of::<sigio>() , 40usize , concat ! (
               "Size of: " , stringify ! ( sigio ) ));
    assert_eq! (::core::mem::align_of::<sigio>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sigio ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigio ) ) . sio_u as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigio ) , "::" ,
                stringify ! ( sio_u ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigio ) ) . sio_pgsigio as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sigio ) , "::" ,
                stringify ! ( sio_pgsigio ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigio ) ) . sio_myref as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( sigio ) , "::" ,
                stringify ! ( sio_myref ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigio ) ) . sio_ucred as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( sigio ) , "::" ,
                stringify ! ( sio_ucred ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigio ) ) . sio_pgid as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( sigio ) , "::" ,
                stringify ! ( sio_pgid ) ));
}
impl Clone for sigio {
    fn clone(&self) -> Self { *self }
}
impl Default for sigio {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for sigio {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "sigio {{ sio_u: {:?}, sio_pgsigio: {:?}, sio_myref: {:?}, sio_ucred: {:?}, sio_pgid: {:?} }}"
               , self . sio_u , self . sio_pgsigio , self . sio_myref , self .
               sio_ucred , self . sio_pgid)
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sigiolst {
    pub slh_first: *mut sigio,
}
#[test]
fn bindgen_test_layout_sigiolst() {
    assert_eq!(::core::mem::size_of::<sigiolst>() , 8usize , concat ! (
               "Size of: " , stringify ! ( sigiolst ) ));
    assert_eq! (::core::mem::align_of::<sigiolst>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sigiolst ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigiolst ) ) . slh_first as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigiolst ) , "::" ,
                stringify ! ( slh_first ) ));
}
impl Clone for sigiolst {
    fn clone(&self) -> Self { *self }
}
impl Default for sigiolst {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    pub fn fgetown(sigiop: *mut *mut sigio) -> pid_t;
}
extern "C" {
    pub fn fsetown(pgid: pid_t, sigiop: *mut *mut sigio)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn funsetown(sigiop: *mut *mut sigio);
}
extern "C" {
    pub fn funsetownlst(sigiolst: *mut sigiolst);
}
pub type sig_atomic_t = ::kernel::sys::raw::c_long;
#[repr(C)]
#[derive(Copy)]
pub struct sigcontext {
    pub sc_mask: __sigset,
    pub sc_onstack: ::kernel::sys::raw::c_long,
    pub sc_rdi: ::kernel::sys::raw::c_long,
    pub sc_rsi: ::kernel::sys::raw::c_long,
    pub sc_rdx: ::kernel::sys::raw::c_long,
    pub sc_rcx: ::kernel::sys::raw::c_long,
    pub sc_r8: ::kernel::sys::raw::c_long,
    pub sc_r9: ::kernel::sys::raw::c_long,
    pub sc_rax: ::kernel::sys::raw::c_long,
    pub sc_rbx: ::kernel::sys::raw::c_long,
    pub sc_rbp: ::kernel::sys::raw::c_long,
    pub sc_r10: ::kernel::sys::raw::c_long,
    pub sc_r11: ::kernel::sys::raw::c_long,
    pub sc_r12: ::kernel::sys::raw::c_long,
    pub sc_r13: ::kernel::sys::raw::c_long,
    pub sc_r14: ::kernel::sys::raw::c_long,
    pub sc_r15: ::kernel::sys::raw::c_long,
    pub sc_trapno: ::kernel::sys::raw::c_int,
    pub sc_fs: ::kernel::sys::raw::c_short,
    pub sc_gs: ::kernel::sys::raw::c_short,
    pub sc_addr: ::kernel::sys::raw::c_long,
    pub sc_flags: ::kernel::sys::raw::c_int,
    pub sc_es: ::kernel::sys::raw::c_short,
    pub sc_ds: ::kernel::sys::raw::c_short,
    pub sc_err: ::kernel::sys::raw::c_long,
    pub sc_rip: ::kernel::sys::raw::c_long,
    pub sc_cs: ::kernel::sys::raw::c_long,
    pub sc_rflags: ::kernel::sys::raw::c_long,
    pub sc_rsp: ::kernel::sys::raw::c_long,
    pub sc_ss: ::kernel::sys::raw::c_long,
    pub sc_len: ::kernel::sys::raw::c_long,
    pub sc_fpformat: ::kernel::sys::raw::c_long,
    pub sc_ownedfp: ::kernel::sys::raw::c_long,
    pub sc_fpstate: [::kernel::sys::raw::c_long; 64usize],
    pub sc_fsbase: ::kernel::sys::raw::c_long,
    pub sc_gsbase: ::kernel::sys::raw::c_long,
    pub sc_xfpustate: ::kernel::sys::raw::c_long,
    pub sc_xfpustate_len: ::kernel::sys::raw::c_long,
    pub sc_spare: [::kernel::sys::raw::c_long; 4usize],
}
#[test]
fn bindgen_test_layout_sigcontext() {
    assert_eq!(::core::mem::size_of::<sigcontext>() , 816usize , concat ! (
               "Size of: " , stringify ! ( sigcontext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_mask as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_onstack as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_onstack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_rdi as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_rdi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_rsi as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_rsi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_rdx as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_rdx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_rcx as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_rcx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_r8 as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_r8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_r9 as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_r9 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_rax as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_rax ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_rbx as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_rbx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_rbp as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_rbp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_r10 as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_r10 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_r11 as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_r11 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_r12 as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_r12 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_r13 as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_r13 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_r14 as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_r14 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_r15 as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_r15 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_trapno as * const _
                as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_trapno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_fs as * const _ as
                usize } , 148usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_fs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_gs as * const _ as
                usize } , 150usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_gs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_addr as * const _ as
                usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_flags as * const _ as
                usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_es as * const _ as
                usize } , 164usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_es ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_ds as * const _ as
                usize } , 166usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_ds ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_err as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_err ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_rip as * const _ as
                usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_rip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_cs as * const _ as
                usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_cs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_rflags as * const _
                as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_rflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_rsp as * const _ as
                usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_rsp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_ss as * const _ as
                usize } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_ss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_len as * const _ as
                usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_fpformat as * const _
                as usize } , 224usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_fpformat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_ownedfp as * const _
                as usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_ownedfp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_fpstate as * const _
                as usize } , 240usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_fpstate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_fsbase as * const _
                as usize } , 752usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_fsbase ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_gsbase as * const _
                as usize } , 760usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_gsbase ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_xfpustate as * const
                _ as usize } , 768usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_xfpustate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_xfpustate_len as *
                const _ as usize } , 776usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_xfpustate_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_spare as * const _ as
                usize } , 784usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_spare ) ));
}
impl Clone for sigcontext {
    fn clone(&self) -> Self { *self }
}
impl Default for sigcontext {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for sigcontext {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "sigcontext {{ sc_mask: {:?}, sc_onstack: {:?}, sc_rdi: {:?}, sc_rsi: {:?}, sc_rdx: {:?}, sc_rcx: {:?}, sc_r8: {:?}, sc_r9: {:?}, sc_rax: {:?}, sc_rbx: {:?}, sc_rbp: {:?}, sc_r10: {:?}, sc_r11: {:?}, sc_r12: {:?}, sc_r13: {:?}, sc_r14: {:?}, sc_r15: {:?}, sc_trapno: {:?}, sc_fs: {:?}, sc_gs: {:?}, sc_addr: {:?}, sc_flags: {:?}, sc_es: {:?}, sc_ds: {:?}, sc_err: {:?}, sc_rip: {:?}, sc_cs: {:?}, sc_rflags: {:?}, sc_rsp: {:?}, sc_ss: {:?}, sc_len: {:?}, sc_fpformat: {:?}, sc_ownedfp: {:?}, sc_fpstate: [{}], sc_fsbase: {:?}, sc_gsbase: {:?}, sc_xfpustate: {:?}, sc_xfpustate_len: {:?}, sc_spare: {:?} }}"
               , self . sc_mask , self . sc_onstack , self . sc_rdi , self .
               sc_rsi , self . sc_rdx , self . sc_rcx , self . sc_r8 , self .
               sc_r9 , self . sc_rax , self . sc_rbx , self . sc_rbp , self .
               sc_r10 , self . sc_r11 , self . sc_r12 , self . sc_r13 , self .
               sc_r14 , self . sc_r15 , self . sc_trapno , self . sc_fs , self
               . sc_gs , self . sc_addr , self . sc_flags , self . sc_es ,
               self . sc_ds , self . sc_err , self . sc_rip , self . sc_cs ,
               self . sc_rflags , self . sc_rsp , self . sc_ss , self . sc_len
               , self . sc_fpformat , self . sc_ownedfp , self . sc_fpstate .
               iter (  ) . enumerate (  ) . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ) , self . sc_fsbase , self . sc_gsbase , self .
               sc_xfpustate , self . sc_xfpustate_len , self . sc_spare)
    }
}
pub type __sighandler_t =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    ::kernel::sys::raw::c_int)>;
#[repr(C)]
#[derive(Copy)]
pub union sigval {
    pub sival_int: ::kernel::sys::raw::c_int,
    pub sival_ptr: *mut ::kernel::sys::raw::c_void,
    pub sigval_int: ::kernel::sys::raw::c_int,
    pub sigval_ptr: *mut ::kernel::sys::raw::c_void,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_sigval() {
    assert_eq!(::core::mem::size_of::<sigval>() , 8usize , concat ! (
               "Size of: " , stringify ! ( sigval ) ));
    assert_eq! (::core::mem::align_of::<sigval>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sigval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigval ) ) . sival_int as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigval ) , "::" ,
                stringify ! ( sival_int ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigval ) ) . sival_ptr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigval ) , "::" ,
                stringify ! ( sival_ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigval ) ) . sigval_int as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigval ) , "::" ,
                stringify ! ( sigval_int ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigval ) ) . sigval_ptr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigval ) , "::" ,
                stringify ! ( sigval_ptr ) ));
}
impl Clone for sigval {
    fn clone(&self) -> Self { *self }
}
impl Default for sigval {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for sigval {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "sigval {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy)]
pub union sigval32 {
    pub sival_int: ::kernel::sys::raw::c_int,
    pub sival_ptr: u32,
    pub sigval_int: ::kernel::sys::raw::c_int,
    pub sigval_ptr: u32,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_sigval32() {
    assert_eq!(::core::mem::size_of::<sigval32>() , 4usize , concat ! (
               "Size of: " , stringify ! ( sigval32 ) ));
    assert_eq! (::core::mem::align_of::<sigval32>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( sigval32 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigval32 ) ) . sival_int as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigval32 ) , "::" ,
                stringify ! ( sival_int ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigval32 ) ) . sival_ptr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigval32 ) , "::" ,
                stringify ! ( sival_ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigval32 ) ) . sigval_int as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigval32 ) , "::" ,
                stringify ! ( sigval_int ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigval32 ) ) . sigval_ptr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigval32 ) , "::" ,
                stringify ! ( sigval_ptr ) ));
}
impl Clone for sigval32 {
    fn clone(&self) -> Self { *self }
}
impl Default for sigval32 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for sigval32 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "sigval32 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct sigevent {
    pub sigev_notify: ::kernel::sys::raw::c_int,
    pub sigev_signo: ::kernel::sys::raw::c_int,
    pub sigev_value: sigval,
    pub _sigev_un: sigevent__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub union sigevent__bindgen_ty_1 {
    pub _threadid: __lwpid_t,
    pub _sigev_thread: sigevent__bindgen_ty_1__bindgen_ty_1,
    pub _kevent_flags: ::kernel::sys::raw::c_ushort,
    pub __spare__: [::kernel::sys::raw::c_long; 8usize],
    _bindgen_union_align: [u64; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sigevent__bindgen_ty_1__bindgen_ty_1 {
    pub _function: ::core::option::Option<unsafe extern "C" fn(arg1: sigval)>,
    pub _attribute: *mut *mut pthread_attr,
}
#[test]
fn bindgen_test_layout_sigevent__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<sigevent__bindgen_ty_1__bindgen_ty_1>()
               , 16usize , concat ! (
               "Size of: " , stringify ! (
               sigevent__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<sigevent__bindgen_ty_1__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                sigevent__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent__bindgen_ty_1__bindgen_ty_1 ) )
                . _function as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                sigevent__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! (
                _function ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent__bindgen_ty_1__bindgen_ty_1 ) )
                . _attribute as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                sigevent__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! (
                _attribute ) ));
}
impl Clone for sigevent__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for sigevent__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_sigevent__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<sigevent__bindgen_ty_1>() , 64usize ,
               concat ! ( "Size of: " , stringify ! ( sigevent__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<sigevent__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( sigevent__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent__bindgen_ty_1 ) ) . _threadid as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigevent__bindgen_ty_1
                ) , "::" , stringify ! ( _threadid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent__bindgen_ty_1 ) ) .
                _sigev_thread as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigevent__bindgen_ty_1
                ) , "::" , stringify ! ( _sigev_thread ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent__bindgen_ty_1 ) ) .
                _kevent_flags as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigevent__bindgen_ty_1
                ) , "::" , stringify ! ( _kevent_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent__bindgen_ty_1 ) ) . __spare__ as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigevent__bindgen_ty_1
                ) , "::" , stringify ! ( __spare__ ) ));
}
impl Clone for sigevent__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for sigevent__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for sigevent__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "sigevent__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_sigevent() {
    assert_eq!(::core::mem::size_of::<sigevent>() , 80usize , concat ! (
               "Size of: " , stringify ! ( sigevent ) ));
    assert_eq! (::core::mem::align_of::<sigevent>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sigevent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent ) ) . sigev_notify as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigevent ) , "::" ,
                stringify ! ( sigev_notify ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent ) ) . sigev_signo as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( sigevent ) , "::" ,
                stringify ! ( sigev_signo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent ) ) . sigev_value as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sigevent ) , "::" ,
                stringify ! ( sigev_value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent ) ) . _sigev_un as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( sigevent ) , "::" ,
                stringify ! ( _sigev_un ) ));
}
impl Clone for sigevent {
    fn clone(&self) -> Self { *self }
}
impl Default for sigevent {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for sigevent {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "sigevent {{ sigev_notify: {:?}, sigev_signo: {:?}, sigev_value: {:?}, _sigev_un: {:?} }}"
               , self . sigev_notify , self . sigev_signo , self . sigev_value
               , self . _sigev_un)
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct __siginfo {
    pub si_signo: ::kernel::sys::raw::c_int,
    pub si_errno: ::kernel::sys::raw::c_int,
    pub si_code: ::kernel::sys::raw::c_int,
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_status: ::kernel::sys::raw::c_int,
    pub si_addr: *mut ::kernel::sys::raw::c_void,
    pub si_value: sigval,
    pub _reason: __siginfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub union __siginfo__bindgen_ty_1 {
    pub _fault: __siginfo__bindgen_ty_1__bindgen_ty_1,
    pub _timer: __siginfo__bindgen_ty_1__bindgen_ty_2,
    pub _mesgq: __siginfo__bindgen_ty_1__bindgen_ty_3,
    pub _poll: __siginfo__bindgen_ty_1__bindgen_ty_4,
    pub __spare__: __siginfo__bindgen_ty_1__bindgen_ty_5,
    _bindgen_union_align: [u64; 5usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct __siginfo__bindgen_ty_1__bindgen_ty_1 {
    pub _trapno: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout___siginfo__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<__siginfo__bindgen_ty_1__bindgen_ty_1>()
               , 4usize , concat ! (
               "Size of: " , stringify ! (
               __siginfo__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<__siginfo__bindgen_ty_1__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                __siginfo__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo__bindgen_ty_1__bindgen_ty_1 ) )
                . _trapno as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __siginfo__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! (
                _trapno ) ));
}
impl Clone for __siginfo__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct __siginfo__bindgen_ty_1__bindgen_ty_2 {
    pub _timerid: ::kernel::sys::raw::c_int,
    pub _overrun: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout___siginfo__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<__siginfo__bindgen_ty_1__bindgen_ty_2>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               __siginfo__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (::core::mem::align_of::<__siginfo__bindgen_ty_1__bindgen_ty_2>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                __siginfo__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo__bindgen_ty_1__bindgen_ty_2 ) )
                . _timerid as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __siginfo__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify ! (
                _timerid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo__bindgen_ty_1__bindgen_ty_2 ) )
                . _overrun as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                __siginfo__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify ! (
                _overrun ) ));
}
impl Clone for __siginfo__bindgen_ty_1__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct __siginfo__bindgen_ty_1__bindgen_ty_3 {
    pub _mqd: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout___siginfo__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(::core::mem::size_of::<__siginfo__bindgen_ty_1__bindgen_ty_3>()
               , 4usize , concat ! (
               "Size of: " , stringify ! (
               __siginfo__bindgen_ty_1__bindgen_ty_3 ) ));
    assert_eq! (::core::mem::align_of::<__siginfo__bindgen_ty_1__bindgen_ty_3>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                __siginfo__bindgen_ty_1__bindgen_ty_3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo__bindgen_ty_1__bindgen_ty_3 ) )
                . _mqd as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __siginfo__bindgen_ty_1__bindgen_ty_3 ) , "::" , stringify ! (
                _mqd ) ));
}
impl Clone for __siginfo__bindgen_ty_1__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct __siginfo__bindgen_ty_1__bindgen_ty_4 {
    pub _band: ::kernel::sys::raw::c_long,
}
#[test]
fn bindgen_test_layout___siginfo__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(::core::mem::size_of::<__siginfo__bindgen_ty_1__bindgen_ty_4>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               __siginfo__bindgen_ty_1__bindgen_ty_4 ) ));
    assert_eq! (::core::mem::align_of::<__siginfo__bindgen_ty_1__bindgen_ty_4>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                __siginfo__bindgen_ty_1__bindgen_ty_4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo__bindgen_ty_1__bindgen_ty_4 ) )
                . _band as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __siginfo__bindgen_ty_1__bindgen_ty_4 ) , "::" , stringify ! (
                _band ) ));
}
impl Clone for __siginfo__bindgen_ty_1__bindgen_ty_4 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct __siginfo__bindgen_ty_1__bindgen_ty_5 {
    pub __spare1__: ::kernel::sys::raw::c_long,
    pub __spare2__: [::kernel::sys::raw::c_int; 7usize],
}
#[test]
fn bindgen_test_layout___siginfo__bindgen_ty_1__bindgen_ty_5() {
    assert_eq!(::core::mem::size_of::<__siginfo__bindgen_ty_1__bindgen_ty_5>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               __siginfo__bindgen_ty_1__bindgen_ty_5 ) ));
    assert_eq! (::core::mem::align_of::<__siginfo__bindgen_ty_1__bindgen_ty_5>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                __siginfo__bindgen_ty_1__bindgen_ty_5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo__bindgen_ty_1__bindgen_ty_5 ) )
                . __spare1__ as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __siginfo__bindgen_ty_1__bindgen_ty_5 ) , "::" , stringify ! (
                __spare1__ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo__bindgen_ty_1__bindgen_ty_5 ) )
                . __spare2__ as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                __siginfo__bindgen_ty_1__bindgen_ty_5 ) , "::" , stringify ! (
                __spare2__ ) ));
}
impl Clone for __siginfo__bindgen_ty_1__bindgen_ty_5 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout___siginfo__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<__siginfo__bindgen_ty_1>() , 40usize ,
               concat ! (
               "Size of: " , stringify ! ( __siginfo__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<__siginfo__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( __siginfo__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo__bindgen_ty_1 ) ) . _fault as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo__bindgen_ty_1
                ) , "::" , stringify ! ( _fault ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo__bindgen_ty_1 ) ) . _timer as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo__bindgen_ty_1
                ) , "::" , stringify ! ( _timer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo__bindgen_ty_1 ) ) . _mesgq as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo__bindgen_ty_1
                ) , "::" , stringify ! ( _mesgq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo__bindgen_ty_1 ) ) . _poll as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo__bindgen_ty_1
                ) , "::" , stringify ! ( _poll ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo__bindgen_ty_1 ) ) . __spare__
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo__bindgen_ty_1
                ) , "::" , stringify ! ( __spare__ ) ));
}
impl Clone for __siginfo__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for __siginfo__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for __siginfo__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "__siginfo__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout___siginfo() {
    assert_eq!(::core::mem::size_of::<__siginfo>() , 80usize , concat ! (
               "Size of: " , stringify ! ( __siginfo ) ));
    assert_eq! (::core::mem::align_of::<__siginfo>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __siginfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo ) ) . si_signo as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo ) , "::" ,
                stringify ! ( si_signo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo ) ) . si_errno as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo ) , "::" ,
                stringify ! ( si_errno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo ) ) . si_code as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo ) , "::" ,
                stringify ! ( si_code ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo ) ) . si_pid as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo ) , "::" ,
                stringify ! ( si_pid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo ) ) . si_uid as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo ) , "::" ,
                stringify ! ( si_uid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo ) ) . si_status as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo ) , "::" ,
                stringify ! ( si_status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo ) ) . si_addr as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo ) , "::" ,
                stringify ! ( si_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo ) ) . si_value as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo ) , "::" ,
                stringify ! ( si_value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo ) ) . _reason as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo ) , "::" ,
                stringify ! ( _reason ) ));
}
impl Clone for __siginfo {
    fn clone(&self) -> Self { *self }
}
impl Default for __siginfo {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for __siginfo {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "__siginfo {{ si_signo: {:?}, si_errno: {:?}, si_code: {:?}, si_pid: {:?}, si_uid: {:?}, si_status: {:?}, si_addr: {:?}, si_value: {:?}, _reason: {:?} }}"
               , self . si_signo , self . si_errno , self . si_code , self .
               si_pid , self . si_uid , self . si_status , self . si_addr ,
               self . si_value , self . _reason)
    }
}
pub type siginfo_t = __siginfo;
#[repr(C)]
#[derive(Copy)]
pub struct siginfo32 {
    pub si_signo: ::kernel::sys::raw::c_int,
    pub si_errno: ::kernel::sys::raw::c_int,
    pub si_code: ::kernel::sys::raw::c_int,
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_status: ::kernel::sys::raw::c_int,
    pub si_addr: u32,
    pub si_value: sigval32,
    pub _reason: siginfo32__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub union siginfo32__bindgen_ty_1 {
    pub _fault: siginfo32__bindgen_ty_1__bindgen_ty_1,
    pub _timer: siginfo32__bindgen_ty_1__bindgen_ty_2,
    pub _mesgq: siginfo32__bindgen_ty_1__bindgen_ty_3,
    pub _poll: siginfo32__bindgen_ty_1__bindgen_ty_4,
    pub __spare__: siginfo32__bindgen_ty_1__bindgen_ty_5,
    _bindgen_union_align: [u32; 8usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct siginfo32__bindgen_ty_1__bindgen_ty_1 {
    pub _trapno: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_siginfo32__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<siginfo32__bindgen_ty_1__bindgen_ty_1>()
               , 4usize , concat ! (
               "Size of: " , stringify ! (
               siginfo32__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<siginfo32__bindgen_ty_1__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                siginfo32__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo32__bindgen_ty_1__bindgen_ty_1 ) )
                . _trapno as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo32__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! (
                _trapno ) ));
}
impl Clone for siginfo32__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct siginfo32__bindgen_ty_1__bindgen_ty_2 {
    pub _timerid: ::kernel::sys::raw::c_int,
    pub _overrun: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_siginfo32__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<siginfo32__bindgen_ty_1__bindgen_ty_2>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               siginfo32__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (::core::mem::align_of::<siginfo32__bindgen_ty_1__bindgen_ty_2>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                siginfo32__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo32__bindgen_ty_1__bindgen_ty_2 ) )
                . _timerid as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo32__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify ! (
                _timerid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo32__bindgen_ty_1__bindgen_ty_2 ) )
                . _overrun as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo32__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify ! (
                _overrun ) ));
}
impl Clone for siginfo32__bindgen_ty_1__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct siginfo32__bindgen_ty_1__bindgen_ty_3 {
    pub _mqd: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_siginfo32__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(::core::mem::size_of::<siginfo32__bindgen_ty_1__bindgen_ty_3>()
               , 4usize , concat ! (
               "Size of: " , stringify ! (
               siginfo32__bindgen_ty_1__bindgen_ty_3 ) ));
    assert_eq! (::core::mem::align_of::<siginfo32__bindgen_ty_1__bindgen_ty_3>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                siginfo32__bindgen_ty_1__bindgen_ty_3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo32__bindgen_ty_1__bindgen_ty_3 ) )
                . _mqd as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo32__bindgen_ty_1__bindgen_ty_3 ) , "::" , stringify ! (
                _mqd ) ));
}
impl Clone for siginfo32__bindgen_ty_1__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct siginfo32__bindgen_ty_1__bindgen_ty_4 {
    pub _band: i32,
}
#[test]
fn bindgen_test_layout_siginfo32__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(::core::mem::size_of::<siginfo32__bindgen_ty_1__bindgen_ty_4>()
               , 4usize , concat ! (
               "Size of: " , stringify ! (
               siginfo32__bindgen_ty_1__bindgen_ty_4 ) ));
    assert_eq! (::core::mem::align_of::<siginfo32__bindgen_ty_1__bindgen_ty_4>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                siginfo32__bindgen_ty_1__bindgen_ty_4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo32__bindgen_ty_1__bindgen_ty_4 ) )
                . _band as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo32__bindgen_ty_1__bindgen_ty_4 ) , "::" , stringify ! (
                _band ) ));
}
impl Clone for siginfo32__bindgen_ty_1__bindgen_ty_4 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct siginfo32__bindgen_ty_1__bindgen_ty_5 {
    pub __spare1__: i32,
    pub __spare2__: [::kernel::sys::raw::c_int; 7usize],
}
#[test]
fn bindgen_test_layout_siginfo32__bindgen_ty_1__bindgen_ty_5() {
    assert_eq!(::core::mem::size_of::<siginfo32__bindgen_ty_1__bindgen_ty_5>()
               , 32usize , concat ! (
               "Size of: " , stringify ! (
               siginfo32__bindgen_ty_1__bindgen_ty_5 ) ));
    assert_eq! (::core::mem::align_of::<siginfo32__bindgen_ty_1__bindgen_ty_5>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                siginfo32__bindgen_ty_1__bindgen_ty_5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo32__bindgen_ty_1__bindgen_ty_5 ) )
                . __spare1__ as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo32__bindgen_ty_1__bindgen_ty_5 ) , "::" , stringify ! (
                __spare1__ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo32__bindgen_ty_1__bindgen_ty_5 ) )
                . __spare2__ as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo32__bindgen_ty_1__bindgen_ty_5 ) , "::" , stringify ! (
                __spare2__ ) ));
}
impl Clone for siginfo32__bindgen_ty_1__bindgen_ty_5 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_siginfo32__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<siginfo32__bindgen_ty_1>() , 32usize ,
               concat ! (
               "Size of: " , stringify ! ( siginfo32__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<siginfo32__bindgen_ty_1>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( siginfo32__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo32__bindgen_ty_1 ) ) . _fault as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo32__bindgen_ty_1
                ) , "::" , stringify ! ( _fault ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo32__bindgen_ty_1 ) ) . _timer as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo32__bindgen_ty_1
                ) , "::" , stringify ! ( _timer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo32__bindgen_ty_1 ) ) . _mesgq as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo32__bindgen_ty_1
                ) , "::" , stringify ! ( _mesgq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo32__bindgen_ty_1 ) ) . _poll as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo32__bindgen_ty_1
                ) , "::" , stringify ! ( _poll ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo32__bindgen_ty_1 ) ) . __spare__
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo32__bindgen_ty_1
                ) , "::" , stringify ! ( __spare__ ) ));
}
impl Clone for siginfo32__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for siginfo32__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for siginfo32__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "siginfo32__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_siginfo32() {
    assert_eq!(::core::mem::size_of::<siginfo32>() , 64usize , concat ! (
               "Size of: " , stringify ! ( siginfo32 ) ));
    assert_eq! (::core::mem::align_of::<siginfo32>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( siginfo32 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo32 ) ) . si_signo as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo32 ) , "::" ,
                stringify ! ( si_signo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo32 ) ) . si_errno as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo32 ) , "::" ,
                stringify ! ( si_errno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo32 ) ) . si_code as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo32 ) , "::" ,
                stringify ! ( si_code ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo32 ) ) . si_pid as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo32 ) , "::" ,
                stringify ! ( si_pid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo32 ) ) . si_uid as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo32 ) , "::" ,
                stringify ! ( si_uid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo32 ) ) . si_status as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo32 ) , "::" ,
                stringify ! ( si_status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo32 ) ) . si_addr as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo32 ) , "::" ,
                stringify ! ( si_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo32 ) ) . si_value as * const _ as
                usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo32 ) , "::" ,
                stringify ! ( si_value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo32 ) ) . _reason as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo32 ) , "::" ,
                stringify ! ( _reason ) ));
}
impl Clone for siginfo32 {
    fn clone(&self) -> Self { *self }
}
impl Default for siginfo32 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for siginfo32 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "siginfo32 {{ si_signo: {:?}, si_errno: {:?}, si_code: {:?}, si_pid: {:?}, si_uid: {:?}, si_status: {:?}, si_addr: {:?}, si_value: {:?}, _reason: {:?} }}"
               , self . si_signo , self . si_errno , self . si_code , self .
               si_pid , self . si_uid , self . si_status , self . si_addr ,
               self . si_value , self . _reason)
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct sigaction {
    pub __sigaction_u: sigaction__bindgen_ty_1,
    pub sa_flags: ::kernel::sys::raw::c_int,
    pub sa_mask: sigset_t,
}
#[repr(C)]
#[derive(Copy)]
pub union sigaction__bindgen_ty_1 {
    pub __sa_handler: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                      ::kernel::sys::raw::c_int)>,
    pub __sa_sigaction: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                        ::kernel::sys::raw::c_int,
                                                                    arg2:
                                                                        *mut __siginfo,
                                                                    arg3:
                                                                        *mut ::kernel::sys::raw::c_void)>,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_sigaction__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<sigaction__bindgen_ty_1>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( sigaction__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<sigaction__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( sigaction__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigaction__bindgen_ty_1 ) ) .
                __sa_handler as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigaction__bindgen_ty_1
                ) , "::" , stringify ! ( __sa_handler ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigaction__bindgen_ty_1 ) ) .
                __sa_sigaction as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigaction__bindgen_ty_1
                ) , "::" , stringify ! ( __sa_sigaction ) ));
}
impl Clone for sigaction__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for sigaction__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for sigaction__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "sigaction__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_sigaction() {
    assert_eq!(::core::mem::size_of::<sigaction>() , 32usize , concat ! (
               "Size of: " , stringify ! ( sigaction ) ));
    assert_eq! (::core::mem::align_of::<sigaction>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sigaction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigaction ) ) . __sigaction_u as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigaction ) , "::" ,
                stringify ! ( __sigaction_u ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigaction ) ) . sa_flags as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sigaction ) , "::" ,
                stringify ! ( sa_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigaction ) ) . sa_mask as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( sigaction ) , "::" ,
                stringify ! ( sa_mask ) ));
}
impl Clone for sigaction {
    fn clone(&self) -> Self { *self }
}
impl Default for sigaction {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for sigaction {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "sigaction {{ __sigaction_u: {:?}, sa_flags: {:?}, sa_mask: {:?} }}"
               , self . __sigaction_u , self . sa_flags , self . sa_mask)
    }
}
pub type sig_t = __sighandler_t;
pub type __siginfohandler_t =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    ::kernel::sys::raw::c_int,
                                                arg2: *mut __siginfo,
                                                arg3:
                                                    *mut ::kernel::sys::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sigaltstack {
    pub ss_sp: *mut ::kernel::sys::raw::c_void,
    pub ss_size: __size_t,
    pub ss_flags: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigaltstack() {
    assert_eq!(::core::mem::size_of::<sigaltstack>() , 24usize , concat ! (
               "Size of: " , stringify ! ( sigaltstack ) ));
    assert_eq! (::core::mem::align_of::<sigaltstack>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sigaltstack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigaltstack ) ) . ss_sp as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigaltstack ) , "::" ,
                stringify ! ( ss_sp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigaltstack ) ) . ss_size as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sigaltstack ) , "::" ,
                stringify ! ( ss_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigaltstack ) ) . ss_flags as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( sigaltstack ) , "::" ,
                stringify ! ( ss_flags ) ));
}
impl Clone for sigaltstack {
    fn clone(&self) -> Self { *self }
}
impl Default for sigaltstack {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type stack_t = sigaltstack;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sigvec {
    pub sv_handler: __sighandler_t,
    pub sv_mask: ::kernel::sys::raw::c_int,
    pub sv_flags: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigvec() {
    assert_eq!(::core::mem::size_of::<sigvec>() , 16usize , concat ! (
               "Size of: " , stringify ! ( sigvec ) ));
    assert_eq! (::core::mem::align_of::<sigvec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sigvec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigvec ) ) . sv_handler as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigvec ) , "::" ,
                stringify ! ( sv_handler ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigvec ) ) . sv_mask as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sigvec ) , "::" ,
                stringify ! ( sv_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigvec ) ) . sv_flags as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( sigvec ) , "::" ,
                stringify ! ( sv_flags ) ));
}
impl Clone for sigvec {
    fn clone(&self) -> Self { *self }
}
impl Default for sigvec {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sigstack {
    pub ss_sp: *mut ::kernel::sys::raw::c_void,
    pub ss_onstack: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigstack() {
    assert_eq!(::core::mem::size_of::<sigstack>() , 16usize , concat ! (
               "Size of: " , stringify ! ( sigstack ) ));
    assert_eq! (::core::mem::align_of::<sigstack>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sigstack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigstack ) ) . ss_sp as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigstack ) , "::" ,
                stringify ! ( ss_sp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigstack ) ) . ss_onstack as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sigstack ) , "::" ,
                stringify ! ( ss_onstack ) ));
}
impl Clone for sigstack {
    fn clone(&self) -> Self { *self }
}
impl Default for sigstack {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    pub fn signal(arg1: ::kernel::sys::raw::c_int, arg2: __sighandler_t)
     -> __sighandler_t;
}
#[repr(C)]
#[derive(Copy)]
pub struct sigacts {
    pub ps_sigact: [sig_t; 128usize],
    pub ps_catchmask: [sigset_t; 128usize],
    pub ps_sigonstack: sigset_t,
    pub ps_sigintr: sigset_t,
    pub ps_sigreset: sigset_t,
    pub ps_signodefer: sigset_t,
    pub ps_siginfo: sigset_t,
    pub ps_sigignore: sigset_t,
    pub ps_sigcatch: sigset_t,
    pub ps_freebsd4: sigset_t,
    pub ps_osigset: sigset_t,
    pub ps_usertramp: sigset_t,
    pub ps_flag: ::kernel::sys::raw::c_int,
    pub ps_refcnt: u_int,
    pub ps_mtx: mtx,
}
#[test]
fn bindgen_test_layout_sigacts() {
    assert_eq!(::core::mem::size_of::<sigacts>() , 3272usize , concat ! (
               "Size of: " , stringify ! ( sigacts ) ));
    assert_eq! (::core::mem::align_of::<sigacts>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sigacts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigacts ) ) . ps_sigact as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigacts ) , "::" ,
                stringify ! ( ps_sigact ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigacts ) ) . ps_catchmask as * const _
                as usize } , 1024usize , concat ! (
                "Alignment of field: " , stringify ! ( sigacts ) , "::" ,
                stringify ! ( ps_catchmask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigacts ) ) . ps_sigonstack as * const _
                as usize } , 3072usize , concat ! (
                "Alignment of field: " , stringify ! ( sigacts ) , "::" ,
                stringify ! ( ps_sigonstack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigacts ) ) . ps_sigintr as * const _ as
                usize } , 3088usize , concat ! (
                "Alignment of field: " , stringify ! ( sigacts ) , "::" ,
                stringify ! ( ps_sigintr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigacts ) ) . ps_sigreset as * const _ as
                usize } , 3104usize , concat ! (
                "Alignment of field: " , stringify ! ( sigacts ) , "::" ,
                stringify ! ( ps_sigreset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigacts ) ) . ps_signodefer as * const _
                as usize } , 3120usize , concat ! (
                "Alignment of field: " , stringify ! ( sigacts ) , "::" ,
                stringify ! ( ps_signodefer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigacts ) ) . ps_siginfo as * const _ as
                usize } , 3136usize , concat ! (
                "Alignment of field: " , stringify ! ( sigacts ) , "::" ,
                stringify ! ( ps_siginfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigacts ) ) . ps_sigignore as * const _
                as usize } , 3152usize , concat ! (
                "Alignment of field: " , stringify ! ( sigacts ) , "::" ,
                stringify ! ( ps_sigignore ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigacts ) ) . ps_sigcatch as * const _ as
                usize } , 3168usize , concat ! (
                "Alignment of field: " , stringify ! ( sigacts ) , "::" ,
                stringify ! ( ps_sigcatch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigacts ) ) . ps_freebsd4 as * const _ as
                usize } , 3184usize , concat ! (
                "Alignment of field: " , stringify ! ( sigacts ) , "::" ,
                stringify ! ( ps_freebsd4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigacts ) ) . ps_osigset as * const _ as
                usize } , 3200usize , concat ! (
                "Alignment of field: " , stringify ! ( sigacts ) , "::" ,
                stringify ! ( ps_osigset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigacts ) ) . ps_usertramp as * const _
                as usize } , 3216usize , concat ! (
                "Alignment of field: " , stringify ! ( sigacts ) , "::" ,
                stringify ! ( ps_usertramp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigacts ) ) . ps_flag as * const _ as
                usize } , 3232usize , concat ! (
                "Alignment of field: " , stringify ! ( sigacts ) , "::" ,
                stringify ! ( ps_flag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigacts ) ) . ps_refcnt as * const _ as
                usize } , 3236usize , concat ! (
                "Alignment of field: " , stringify ! ( sigacts ) , "::" ,
                stringify ! ( ps_refcnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigacts ) ) . ps_mtx as * const _ as
                usize } , 3240usize , concat ! (
                "Alignment of field: " , stringify ! ( sigacts ) , "::" ,
                stringify ! ( ps_mtx ) ));
}
impl Clone for sigacts {
    fn clone(&self) -> Self { *self }
}
impl Default for sigacts {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for sigacts {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "sigacts {{ ps_sigact: [{}], ps_catchmask: [{}], ps_sigonstack: {:?}, ps_sigintr: {:?}, ps_sigreset: {:?}, ps_signodefer: {:?}, ps_siginfo: {:?}, ps_sigignore: {:?}, ps_sigcatch: {:?}, ps_freebsd4: {:?}, ps_osigset: {:?}, ps_usertramp: {:?}, ps_flag: {:?}, ps_refcnt: {:?}, ps_mtx: {:?} }}"
               , self . ps_sigact . iter (  ) . enumerate (  ) . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ) , self . ps_catchmask . iter (  ) . enumerate (
               ) . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ) , self . ps_sigonstack , self . ps_sigintr , self
               . ps_sigreset , self . ps_signodefer , self . ps_siginfo , self
               . ps_sigignore , self . ps_sigcatch , self . ps_freebsd4 , self
               . ps_osigset , self . ps_usertramp , self . ps_flag , self .
               ps_refcnt , self . ps_mtx)
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct ksiginfo {
    pub ksi_link: ksiginfo__bindgen_ty_1,
    pub ksi_info: siginfo_t,
    pub ksi_flags: ::kernel::sys::raw::c_int,
    pub ksi_sigq: *mut sigqueue,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ksiginfo__bindgen_ty_1 {
    pub tqe_next: *mut ksiginfo,
    pub tqe_prev: *mut *mut ksiginfo,
}
#[test]
fn bindgen_test_layout_ksiginfo__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<ksiginfo__bindgen_ty_1>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( ksiginfo__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<ksiginfo__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( ksiginfo__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ksiginfo__bindgen_ty_1 ) ) . tqe_next as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ksiginfo__bindgen_ty_1
                ) , "::" , stringify ! ( tqe_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ksiginfo__bindgen_ty_1 ) ) . tqe_prev as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ksiginfo__bindgen_ty_1
                ) , "::" , stringify ! ( tqe_prev ) ));
}
impl Clone for ksiginfo__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for ksiginfo__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_ksiginfo() {
    assert_eq!(::core::mem::size_of::<ksiginfo>() , 112usize , concat ! (
               "Size of: " , stringify ! ( ksiginfo ) ));
    assert_eq! (::core::mem::align_of::<ksiginfo>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ksiginfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ksiginfo ) ) . ksi_link as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ksiginfo ) , "::" ,
                stringify ! ( ksi_link ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ksiginfo ) ) . ksi_info as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ksiginfo ) , "::" ,
                stringify ! ( ksi_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ksiginfo ) ) . ksi_flags as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( ksiginfo ) , "::" ,
                stringify ! ( ksi_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ksiginfo ) ) . ksi_sigq as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( ksiginfo ) , "::" ,
                stringify ! ( ksi_sigq ) ));
}
impl Clone for ksiginfo {
    fn clone(&self) -> Self { *self }
}
impl Default for ksiginfo {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for ksiginfo {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "ksiginfo {{ ksi_link: {:?}, ksi_info: {:?}, ksi_flags: {:?}, ksi_sigq: {:?} }}"
               , self . ksi_link , self . ksi_info , self . ksi_flags , self .
               ksi_sigq)
    }
}
pub type ksiginfo_t = ksiginfo;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sigqueue {
    pub sq_signals: sigset_t,
    pub sq_kill: sigset_t,
    pub sq_ptrace: sigset_t,
    pub sq_list: sigqueue__bindgen_ty_1,
    pub sq_proc: *mut proc_,
    pub sq_flags: ::kernel::sys::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sigqueue__bindgen_ty_1 {
    pub tqh_first: *mut ksiginfo,
    pub tqh_last: *mut *mut ksiginfo,
}
#[test]
fn bindgen_test_layout_sigqueue__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<sigqueue__bindgen_ty_1>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( sigqueue__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<sigqueue__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( sigqueue__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigqueue__bindgen_ty_1 ) ) . tqh_first as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigqueue__bindgen_ty_1
                ) , "::" , stringify ! ( tqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigqueue__bindgen_ty_1 ) ) . tqh_last as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sigqueue__bindgen_ty_1
                ) , "::" , stringify ! ( tqh_last ) ));
}
impl Clone for sigqueue__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for sigqueue__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_sigqueue() {
    assert_eq!(::core::mem::size_of::<sigqueue>() , 80usize , concat ! (
               "Size of: " , stringify ! ( sigqueue ) ));
    assert_eq! (::core::mem::align_of::<sigqueue>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sigqueue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigqueue ) ) . sq_signals as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigqueue ) , "::" ,
                stringify ! ( sq_signals ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigqueue ) ) . sq_kill as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( sigqueue ) , "::" ,
                stringify ! ( sq_kill ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigqueue ) ) . sq_ptrace as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( sigqueue ) , "::" ,
                stringify ! ( sq_ptrace ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigqueue ) ) . sq_list as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( sigqueue ) , "::" ,
                stringify ! ( sq_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigqueue ) ) . sq_proc as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( sigqueue ) , "::" ,
                stringify ! ( sq_proc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigqueue ) ) . sq_flags as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( sigqueue ) , "::" ,
                stringify ! ( sq_flags ) ));
}
impl Clone for sigqueue {
    fn clone(&self) -> Self { *self }
}
impl Default for sigqueue {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type sigqueue_t = sigqueue;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pgrp {
    pub pg_hash: pgrp__bindgen_ty_1,
    pub pg_members: pgrp__bindgen_ty_2,
    pub pg_session: *mut session,
    pub pg_sigiolst: sigiolst,
    pub pg_id: pid_t,
    pub pg_jobc: ::kernel::sys::raw::c_int,
    pub pg_mtx: mtx,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pgrp__bindgen_ty_1 {
    pub le_next: *mut pgrp,
    pub le_prev: *mut *mut pgrp,
}
#[test]
fn bindgen_test_layout_pgrp__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<pgrp__bindgen_ty_1>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( pgrp__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<pgrp__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( pgrp__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgrp__bindgen_ty_1 ) ) . le_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pgrp__bindgen_ty_1 ) ,
                "::" , stringify ! ( le_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgrp__bindgen_ty_1 ) ) . le_prev as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pgrp__bindgen_ty_1 ) ,
                "::" , stringify ! ( le_prev ) ));
}
impl Clone for pgrp__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for pgrp__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pgrp__bindgen_ty_2 {
    pub lh_first: *mut proc_,
}
#[test]
fn bindgen_test_layout_pgrp__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<pgrp__bindgen_ty_2>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( pgrp__bindgen_ty_2 ) ));
    assert_eq! (::core::mem::align_of::<pgrp__bindgen_ty_2>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( pgrp__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgrp__bindgen_ty_2 ) ) . lh_first as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pgrp__bindgen_ty_2 ) ,
                "::" , stringify ! ( lh_first ) ));
}
impl Clone for pgrp__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for pgrp__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_pgrp() {
    assert_eq!(::core::mem::size_of::<pgrp>() , 80usize , concat ! (
               "Size of: " , stringify ! ( pgrp ) ));
    assert_eq! (::core::mem::align_of::<pgrp>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pgrp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgrp ) ) . pg_hash as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pgrp ) , "::" ,
                stringify ! ( pg_hash ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgrp ) ) . pg_members as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( pgrp ) , "::" ,
                stringify ! ( pg_members ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgrp ) ) . pg_session as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( pgrp ) , "::" ,
                stringify ! ( pg_session ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgrp ) ) . pg_sigiolst as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( pgrp ) , "::" ,
                stringify ! ( pg_sigiolst ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgrp ) ) . pg_id as * const _ as usize }
                , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( pgrp ) , "::" ,
                stringify ! ( pg_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgrp ) ) . pg_jobc as * const _ as usize
                } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( pgrp ) , "::" ,
                stringify ! ( pg_jobc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgrp ) ) . pg_mtx as * const _ as usize }
                , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( pgrp ) , "::" ,
                stringify ! ( pg_mtx ) ));
}
impl Clone for pgrp {
    fn clone(&self) -> Self { *self }
}
impl Default for pgrp {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    #[link_name = "sigio_lock"]
    pub static mut sigio_lock: mtx;
}
extern "C" {
    pub fn sigdeferstop_impl(mode: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sigallowstop_impl(prev: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn cursig(td: *mut thread) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn execsigs(p: *mut proc_);
}
extern "C" {
    pub fn gsignal(pgid: ::kernel::sys::raw::c_int,
                   sig: ::kernel::sys::raw::c_int, ksi: *mut ksiginfo_t);
}
extern "C" {
    pub fn killproc(p: *mut proc_, why: *mut ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn ksiginfo_alloc(wait: ::kernel::sys::raw::c_int) -> *mut ksiginfo_t;
}
extern "C" {
    pub fn ksiginfo_free(ksi: *mut ksiginfo_t);
}
extern "C" {
    pub fn pksignal(p: *mut proc_, sig: ::kernel::sys::raw::c_int,
                    ksi: *mut ksiginfo_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn pgsigio(sigiop: *mut *mut sigio, sig: ::kernel::sys::raw::c_int,
                   checkctty: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn pgsignal(pgrp: *mut pgrp, sig: ::kernel::sys::raw::c_int,
                    checkctty: ::kernel::sys::raw::c_int,
                    ksi: *mut ksiginfo_t);
}
extern "C" {
    pub fn postsig(sig: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn kern_psignal(p: *mut proc_, sig: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn ptracestop(td: *mut thread, sig: ::kernel::sys::raw::c_int,
                      si: *mut ksiginfo_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sendsig(catcher: sig_t, ksi: *mut ksiginfo_t,
                   retmask: *mut sigset_t);
}
extern "C" {
    pub fn sigacts_alloc() -> *mut sigacts;
}
extern "C" {
    pub fn sigacts_copy(dest: *mut sigacts, src: *mut sigacts);
}
extern "C" {
    pub fn sigacts_free(ps: *mut sigacts);
}
extern "C" {
    pub fn sigacts_hold(ps: *mut sigacts) -> *mut sigacts;
}
extern "C" {
    pub fn sigacts_shared(ps: *mut sigacts) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sigexit(td: *mut thread, sig: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn sigev_findtd(p: *mut proc_, sigev: *mut sigevent,
                        arg1: *mut *mut thread) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sig_ffs(set: *mut sigset_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn siginit(p: *mut proc_);
}
extern "C" {
    pub fn signotify(td: *mut thread);
}
extern "C" {
    pub fn sigqueue_delete(queue: *mut sigqueue,
                           sig: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn sigqueue_delete_proc(p: *mut proc_,
                                sig: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn sigqueue_flush(queue: *mut sigqueue);
}
extern "C" {
    pub fn sigqueue_init(queue: *mut sigqueue, p: *mut proc_);
}
extern "C" {
    pub fn sigqueue_take(ksi: *mut ksiginfo_t);
}
extern "C" {
    pub fn tdksignal(td: *mut thread, sig: ::kernel::sys::raw::c_int,
                     ksi: *mut ksiginfo_t);
}
extern "C" {
    pub fn tdsendsignal(p: *mut proc_, td: *mut thread,
                        sig: ::kernel::sys::raw::c_int, ksi: *mut ksiginfo_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn tdsigcleanup(td: *mut thread);
}
extern "C" {
    pub fn tdsignal(td: *mut thread, sig: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn trapsignal(td: *mut thread, ksi: *mut ksiginfo_t);
}
#[repr(C)]
#[derive(Copy)]
pub struct __mcontext {
    pub mc_onstack: __register_t,
    pub mc_rdi: __register_t,
    pub mc_rsi: __register_t,
    pub mc_rdx: __register_t,
    pub mc_rcx: __register_t,
    pub mc_r8: __register_t,
    pub mc_r9: __register_t,
    pub mc_rax: __register_t,
    pub mc_rbx: __register_t,
    pub mc_rbp: __register_t,
    pub mc_r10: __register_t,
    pub mc_r11: __register_t,
    pub mc_r12: __register_t,
    pub mc_r13: __register_t,
    pub mc_r14: __register_t,
    pub mc_r15: __register_t,
    pub mc_trapno: __uint32_t,
    pub mc_fs: __uint16_t,
    pub mc_gs: __uint16_t,
    pub mc_addr: __register_t,
    pub mc_flags: __uint32_t,
    pub mc_es: __uint16_t,
    pub mc_ds: __uint16_t,
    pub mc_err: __register_t,
    pub mc_rip: __register_t,
    pub mc_cs: __register_t,
    pub mc_rflags: __register_t,
    pub mc_rsp: __register_t,
    pub mc_ss: __register_t,
    pub mc_len: ::kernel::sys::raw::c_long,
    pub mc_fpformat: ::kernel::sys::raw::c_long,
    pub mc_ownedfp: ::kernel::sys::raw::c_long,
    pub mc_fpstate: [::kernel::sys::raw::c_long; 64usize],
    pub mc_fsbase: __register_t,
    pub mc_gsbase: __register_t,
    pub mc_xfpustate: __register_t,
    pub mc_xfpustate_len: __register_t,
    pub mc_spare: [::kernel::sys::raw::c_long; 4usize],
}
#[test]
fn bindgen_test_layout___mcontext() {
    assert_eq!(::core::mem::size_of::<__mcontext>() , 800usize , concat ! (
               "Size of: " , stringify ! ( __mcontext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_onstack as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_onstack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_rdi as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_rdi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_rsi as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_rsi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_rdx as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_rdx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_rcx as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_rcx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_r8 as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_r8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_r9 as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_r9 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_rax as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_rax ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_rbx as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_rbx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_rbp as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_rbp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_r10 as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_r10 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_r11 as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_r11 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_r12 as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_r12 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_r13 as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_r13 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_r14 as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_r14 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_r15 as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_r15 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_trapno as * const _
                as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_trapno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_fs as * const _ as
                usize } , 132usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_fs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_gs as * const _ as
                usize } , 134usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_gs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_addr as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_flags as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_es as * const _ as
                usize } , 148usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_es ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_ds as * const _ as
                usize } , 150usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_ds ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_err as * const _ as
                usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_err ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_rip as * const _ as
                usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_rip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_cs as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_cs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_rflags as * const _
                as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_rflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_rsp as * const _ as
                usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_rsp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_ss as * const _ as
                usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_ss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_len as * const _ as
                usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_fpformat as * const _
                as usize } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_fpformat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_ownedfp as * const _
                as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_ownedfp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_fpstate as * const _
                as usize } , 224usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_fpstate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_fsbase as * const _
                as usize } , 736usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_fsbase ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_gsbase as * const _
                as usize } , 744usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_gsbase ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_xfpustate as * const
                _ as usize } , 752usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_xfpustate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_xfpustate_len as *
                const _ as usize } , 760usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_xfpustate_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_spare as * const _ as
                usize } , 768usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_spare ) ));
}
impl Clone for __mcontext {
    fn clone(&self) -> Self { *self }
}
impl Default for __mcontext {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for __mcontext {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "__mcontext {{ mc_onstack: {:?}, mc_rdi: {:?}, mc_rsi: {:?}, mc_rdx: {:?}, mc_rcx: {:?}, mc_r8: {:?}, mc_r9: {:?}, mc_rax: {:?}, mc_rbx: {:?}, mc_rbp: {:?}, mc_r10: {:?}, mc_r11: {:?}, mc_r12: {:?}, mc_r13: {:?}, mc_r14: {:?}, mc_r15: {:?}, mc_trapno: {:?}, mc_fs: {:?}, mc_gs: {:?}, mc_addr: {:?}, mc_flags: {:?}, mc_es: {:?}, mc_ds: {:?}, mc_err: {:?}, mc_rip: {:?}, mc_cs: {:?}, mc_rflags: {:?}, mc_rsp: {:?}, mc_ss: {:?}, mc_len: {:?}, mc_fpformat: {:?}, mc_ownedfp: {:?}, mc_fpstate: [{}], mc_fsbase: {:?}, mc_gsbase: {:?}, mc_xfpustate: {:?}, mc_xfpustate_len: {:?}, mc_spare: {:?} }}"
               , self . mc_onstack , self . mc_rdi , self . mc_rsi , self .
               mc_rdx , self . mc_rcx , self . mc_r8 , self . mc_r9 , self .
               mc_rax , self . mc_rbx , self . mc_rbp , self . mc_r10 , self .
               mc_r11 , self . mc_r12 , self . mc_r13 , self . mc_r14 , self .
               mc_r15 , self . mc_trapno , self . mc_fs , self . mc_gs , self
               . mc_addr , self . mc_flags , self . mc_es , self . mc_ds ,
               self . mc_err , self . mc_rip , self . mc_cs , self . mc_rflags
               , self . mc_rsp , self . mc_ss , self . mc_len , self .
               mc_fpformat , self . mc_ownedfp , self . mc_fpstate . iter (  )
               . enumerate (  ) . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ) , self . mc_fsbase , self . mc_gsbase , self .
               mc_xfpustate , self . mc_xfpustate_len , self . mc_spare)
    }
}
pub type mcontext_t = __mcontext;
#[repr(C)]
#[derive(Copy)]
pub struct __ucontext {
    pub uc_sigmask: __sigset_t,
    pub uc_mcontext: mcontext_t,
    pub uc_link: *mut __ucontext,
    pub uc_stack: sigaltstack,
    pub uc_flags: ::kernel::sys::raw::c_int,
    pub __spare__: [::kernel::sys::raw::c_int; 4usize],
    pub __bindgen_padding_0: [u32; 3usize],
}
#[test]
fn bindgen_test_layout___ucontext() {
    assert_eq!(::core::mem::size_of::<__ucontext>() , 880usize , concat ! (
               "Size of: " , stringify ! ( __ucontext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __ucontext ) ) . uc_sigmask as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __ucontext ) , "::" ,
                stringify ! ( uc_sigmask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __ucontext ) ) . uc_mcontext as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __ucontext ) , "::" ,
                stringify ! ( uc_mcontext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __ucontext ) ) . uc_link as * const _ as
                usize } , 816usize , concat ! (
                "Alignment of field: " , stringify ! ( __ucontext ) , "::" ,
                stringify ! ( uc_link ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __ucontext ) ) . uc_stack as * const _ as
                usize } , 824usize , concat ! (
                "Alignment of field: " , stringify ! ( __ucontext ) , "::" ,
                stringify ! ( uc_stack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __ucontext ) ) . uc_flags as * const _ as
                usize } , 848usize , concat ! (
                "Alignment of field: " , stringify ! ( __ucontext ) , "::" ,
                stringify ! ( uc_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __ucontext ) ) . __spare__ as * const _
                as usize } , 852usize , concat ! (
                "Alignment of field: " , stringify ! ( __ucontext ) , "::" ,
                stringify ! ( __spare__ ) ));
}
impl Clone for __ucontext {
    fn clone(&self) -> Self { *self }
}
impl Default for __ucontext {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for __ucontext {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "__ucontext {{ uc_sigmask: {:?}, uc_mcontext: {:?}, uc_link: {:?}, uc_stack: {:?}, uc_flags: {:?}, __spare__: {:?} }}"
               , self . uc_sigmask , self . uc_mcontext , self . uc_link ,
               self . uc_stack , self . uc_flags , self . __spare__)
    }
}
pub type ucontext_t = __ucontext;
extern "C" {
    pub fn get_mcontext(arg1: *mut thread, arg2: *mut mcontext_t,
                        arg3: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn set_mcontext(arg1: *mut thread, arg2: *mut mcontext_t)
     -> ::kernel::sys::raw::c_int;
}
pub type au_id_t = uid_t;
pub type au_asid_t = pid_t;
pub type au_event_t = u_int16_t;
pub type au_emod_t = u_int16_t;
pub type au_class_t = u_int32_t;
pub type au_asflgs_t = u_int64_t;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct au_tid {
    pub port: u_int32_t,
    pub machine: u_int32_t,
}
#[test]
fn bindgen_test_layout_au_tid() {
    assert_eq!(::core::mem::size_of::<au_tid>() , 8usize , concat ! (
               "Size of: " , stringify ! ( au_tid ) ));
    assert_eq! (::core::mem::align_of::<au_tid>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( au_tid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const au_tid ) ) . port as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( au_tid ) , "::" ,
                stringify ! ( port ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const au_tid ) ) . machine as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( au_tid ) , "::" ,
                stringify ! ( machine ) ));
}
impl Clone for au_tid {
    fn clone(&self) -> Self { *self }
}
pub type au_tid_t = au_tid;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct au_tid_addr {
    pub at_port: u_int32_t,
    pub at_type: u_int32_t,
    pub at_addr: [u_int32_t; 4usize],
}
#[test]
fn bindgen_test_layout_au_tid_addr() {
    assert_eq!(::core::mem::size_of::<au_tid_addr>() , 24usize , concat ! (
               "Size of: " , stringify ! ( au_tid_addr ) ));
    assert_eq! (::core::mem::align_of::<au_tid_addr>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( au_tid_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const au_tid_addr ) ) . at_port as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( au_tid_addr ) , "::" ,
                stringify ! ( at_port ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const au_tid_addr ) ) . at_type as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( au_tid_addr ) , "::" ,
                stringify ! ( at_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const au_tid_addr ) ) . at_addr as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( au_tid_addr ) , "::" ,
                stringify ! ( at_addr ) ));
}
impl Clone for au_tid_addr {
    fn clone(&self) -> Self { *self }
}
pub type au_tid_addr_t = au_tid_addr;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct au_mask {
    pub am_success: ::kernel::sys::raw::c_uint,
    pub am_failure: ::kernel::sys::raw::c_uint,
}
#[test]
fn bindgen_test_layout_au_mask() {
    assert_eq!(::core::mem::size_of::<au_mask>() , 8usize , concat ! (
               "Size of: " , stringify ! ( au_mask ) ));
    assert_eq! (::core::mem::align_of::<au_mask>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( au_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const au_mask ) ) . am_success as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( au_mask ) , "::" ,
                stringify ! ( am_success ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const au_mask ) ) . am_failure as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( au_mask ) , "::" ,
                stringify ! ( am_failure ) ));
}
impl Clone for au_mask {
    fn clone(&self) -> Self { *self }
}
pub type au_mask_t = au_mask;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct auditinfo {
    pub ai_auid: au_id_t,
    pub ai_mask: au_mask_t,
    pub ai_termid: au_tid_t,
    pub ai_asid: au_asid_t,
}
#[test]
fn bindgen_test_layout_auditinfo() {
    assert_eq!(::core::mem::size_of::<auditinfo>() , 24usize , concat ! (
               "Size of: " , stringify ! ( auditinfo ) ));
    assert_eq! (::core::mem::align_of::<auditinfo>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( auditinfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const auditinfo ) ) . ai_auid as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( auditinfo ) , "::" ,
                stringify ! ( ai_auid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const auditinfo ) ) . ai_mask as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( auditinfo ) , "::" ,
                stringify ! ( ai_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const auditinfo ) ) . ai_termid as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( auditinfo ) , "::" ,
                stringify ! ( ai_termid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const auditinfo ) ) . ai_asid as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( auditinfo ) , "::" ,
                stringify ! ( ai_asid ) ));
}
impl Clone for auditinfo {
    fn clone(&self) -> Self { *self }
}
pub type auditinfo_t = auditinfo;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct auditinfo_addr {
    pub ai_auid: au_id_t,
    pub ai_mask: au_mask_t,
    pub ai_termid: au_tid_addr_t,
    pub ai_asid: au_asid_t,
    pub ai_flags: au_asflgs_t,
}
#[test]
fn bindgen_test_layout_auditinfo_addr() {
    assert_eq!(::core::mem::size_of::<auditinfo_addr>() , 48usize , concat ! (
               "Size of: " , stringify ! ( auditinfo_addr ) ));
    assert_eq! (::core::mem::align_of::<auditinfo_addr>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( auditinfo_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const auditinfo_addr ) ) . ai_auid as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( auditinfo_addr ) , "::"
                , stringify ! ( ai_auid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const auditinfo_addr ) ) . ai_mask as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( auditinfo_addr ) , "::"
                , stringify ! ( ai_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const auditinfo_addr ) ) . ai_termid as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( auditinfo_addr ) , "::"
                , stringify ! ( ai_termid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const auditinfo_addr ) ) . ai_asid as * const _
                as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( auditinfo_addr ) , "::"
                , stringify ! ( ai_asid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const auditinfo_addr ) ) . ai_flags as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( auditinfo_addr ) , "::"
                , stringify ! ( ai_flags ) ));
}
impl Clone for auditinfo_addr {
    fn clone(&self) -> Self { *self }
}
pub type auditinfo_addr_t = auditinfo_addr;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct auditpinfo {
    pub ap_pid: pid_t,
    pub ap_auid: au_id_t,
    pub ap_mask: au_mask_t,
    pub ap_termid: au_tid_t,
    pub ap_asid: au_asid_t,
}
#[test]
fn bindgen_test_layout_auditpinfo() {
    assert_eq!(::core::mem::size_of::<auditpinfo>() , 28usize , concat ! (
               "Size of: " , stringify ! ( auditpinfo ) ));
    assert_eq! (::core::mem::align_of::<auditpinfo>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( auditpinfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const auditpinfo ) ) . ap_pid as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( auditpinfo ) , "::" ,
                stringify ! ( ap_pid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const auditpinfo ) ) . ap_auid as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( auditpinfo ) , "::" ,
                stringify ! ( ap_auid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const auditpinfo ) ) . ap_mask as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( auditpinfo ) , "::" ,
                stringify ! ( ap_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const auditpinfo ) ) . ap_termid as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( auditpinfo ) , "::" ,
                stringify ! ( ap_termid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const auditpinfo ) ) . ap_asid as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( auditpinfo ) , "::" ,
                stringify ! ( ap_asid ) ));
}
impl Clone for auditpinfo {
    fn clone(&self) -> Self { *self }
}
pub type auditpinfo_t = auditpinfo;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct auditpinfo_addr {
    pub ap_pid: pid_t,
    pub ap_auid: au_id_t,
    pub ap_mask: au_mask_t,
    pub ap_termid: au_tid_addr_t,
    pub ap_asid: au_asid_t,
    pub ap_flags: au_asflgs_t,
}
#[test]
fn bindgen_test_layout_auditpinfo_addr() {
    assert_eq!(::core::mem::size_of::<auditpinfo_addr>() , 56usize , concat !
               ( "Size of: " , stringify ! ( auditpinfo_addr ) ));
    assert_eq! (::core::mem::align_of::<auditpinfo_addr>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( auditpinfo_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const auditpinfo_addr ) ) . ap_pid as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( auditpinfo_addr ) ,
                "::" , stringify ! ( ap_pid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const auditpinfo_addr ) ) . ap_auid as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( auditpinfo_addr ) ,
                "::" , stringify ! ( ap_auid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const auditpinfo_addr ) ) . ap_mask as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( auditpinfo_addr ) ,
                "::" , stringify ! ( ap_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const auditpinfo_addr ) ) . ap_termid as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( auditpinfo_addr ) ,
                "::" , stringify ! ( ap_termid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const auditpinfo_addr ) ) . ap_asid as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( auditpinfo_addr ) ,
                "::" , stringify ! ( ap_asid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const auditpinfo_addr ) ) . ap_flags as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( auditpinfo_addr ) ,
                "::" , stringify ! ( ap_flags ) ));
}
impl Clone for auditpinfo_addr {
    fn clone(&self) -> Self { *self }
}
pub type auditpinfo_addr_t = auditpinfo_addr;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct au_session {
    pub as_aia_p: *mut auditinfo_addr_t,
    pub as_mask: au_mask_t,
}
#[test]
fn bindgen_test_layout_au_session() {
    assert_eq!(::core::mem::size_of::<au_session>() , 16usize , concat ! (
               "Size of: " , stringify ! ( au_session ) ));
    assert_eq! (::core::mem::align_of::<au_session>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( au_session ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const au_session ) ) . as_aia_p as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( au_session ) , "::" ,
                stringify ! ( as_aia_p ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const au_session ) ) . as_mask as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( au_session ) , "::" ,
                stringify ! ( as_mask ) ));
}
impl Clone for au_session {
    fn clone(&self) -> Self { *self }
}
impl Default for au_session {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type au_session_t = au_session;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct au_token {
    _unused: [u8; 0],
}
pub type token_t = au_token;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct au_qctrl {
    pub aq_hiwater: ::kernel::sys::raw::c_int,
    pub aq_lowater: ::kernel::sys::raw::c_int,
    pub aq_bufsz: ::kernel::sys::raw::c_int,
    pub aq_delay: ::kernel::sys::raw::c_int,
    pub aq_minfree: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_au_qctrl() {
    assert_eq!(::core::mem::size_of::<au_qctrl>() , 20usize , concat ! (
               "Size of: " , stringify ! ( au_qctrl ) ));
    assert_eq! (::core::mem::align_of::<au_qctrl>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( au_qctrl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const au_qctrl ) ) . aq_hiwater as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( au_qctrl ) , "::" ,
                stringify ! ( aq_hiwater ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const au_qctrl ) ) . aq_lowater as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( au_qctrl ) , "::" ,
                stringify ! ( aq_lowater ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const au_qctrl ) ) . aq_bufsz as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( au_qctrl ) , "::" ,
                stringify ! ( aq_bufsz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const au_qctrl ) ) . aq_delay as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( au_qctrl ) , "::" ,
                stringify ! ( aq_delay ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const au_qctrl ) ) . aq_minfree as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( au_qctrl ) , "::" ,
                stringify ! ( aq_minfree ) ));
}
impl Clone for au_qctrl {
    fn clone(&self) -> Self { *self }
}
pub type au_qctrl_t = au_qctrl;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct audit_stat {
    pub as_version: ::kernel::sys::raw::c_uint,
    pub as_numevent: ::kernel::sys::raw::c_uint,
    pub as_generated: ::kernel::sys::raw::c_int,
    pub as_nonattrib: ::kernel::sys::raw::c_int,
    pub as_kernel: ::kernel::sys::raw::c_int,
    pub as_audit: ::kernel::sys::raw::c_int,
    pub as_auditctl: ::kernel::sys::raw::c_int,
    pub as_enqueue: ::kernel::sys::raw::c_int,
    pub as_written: ::kernel::sys::raw::c_int,
    pub as_wblocked: ::kernel::sys::raw::c_int,
    pub as_rblocked: ::kernel::sys::raw::c_int,
    pub as_dropped: ::kernel::sys::raw::c_int,
    pub as_totalsize: ::kernel::sys::raw::c_int,
    pub as_memused: ::kernel::sys::raw::c_uint,
}
#[test]
fn bindgen_test_layout_audit_stat() {
    assert_eq!(::core::mem::size_of::<audit_stat>() , 56usize , concat ! (
               "Size of: " , stringify ! ( audit_stat ) ));
    assert_eq! (::core::mem::align_of::<audit_stat>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( audit_stat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const audit_stat ) ) . as_version as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( audit_stat ) , "::" ,
                stringify ! ( as_version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const audit_stat ) ) . as_numevent as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( audit_stat ) , "::" ,
                stringify ! ( as_numevent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const audit_stat ) ) . as_generated as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( audit_stat ) , "::" ,
                stringify ! ( as_generated ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const audit_stat ) ) . as_nonattrib as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( audit_stat ) , "::" ,
                stringify ! ( as_nonattrib ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const audit_stat ) ) . as_kernel as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( audit_stat ) , "::" ,
                stringify ! ( as_kernel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const audit_stat ) ) . as_audit as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( audit_stat ) , "::" ,
                stringify ! ( as_audit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const audit_stat ) ) . as_auditctl as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( audit_stat ) , "::" ,
                stringify ! ( as_auditctl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const audit_stat ) ) . as_enqueue as * const _
                as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( audit_stat ) , "::" ,
                stringify ! ( as_enqueue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const audit_stat ) ) . as_written as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( audit_stat ) , "::" ,
                stringify ! ( as_written ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const audit_stat ) ) . as_wblocked as * const _
                as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( audit_stat ) , "::" ,
                stringify ! ( as_wblocked ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const audit_stat ) ) . as_rblocked as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( audit_stat ) , "::" ,
                stringify ! ( as_rblocked ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const audit_stat ) ) . as_dropped as * const _
                as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( audit_stat ) , "::" ,
                stringify ! ( as_dropped ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const audit_stat ) ) . as_totalsize as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( audit_stat ) , "::" ,
                stringify ! ( as_totalsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const audit_stat ) ) . as_memused as * const _
                as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( audit_stat ) , "::" ,
                stringify ! ( as_memused ) ));
}
impl Clone for audit_stat {
    fn clone(&self) -> Self { *self }
}
pub type au_stat_t = audit_stat;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct audit_fstat {
    pub af_filesz: u_int64_t,
    pub af_currsz: u_int64_t,
}
#[test]
fn bindgen_test_layout_audit_fstat() {
    assert_eq!(::core::mem::size_of::<audit_fstat>() , 16usize , concat ! (
               "Size of: " , stringify ! ( audit_fstat ) ));
    assert_eq! (::core::mem::align_of::<audit_fstat>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( audit_fstat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const audit_fstat ) ) . af_filesz as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( audit_fstat ) , "::" ,
                stringify ! ( af_filesz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const audit_fstat ) ) . af_currsz as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( audit_fstat ) , "::" ,
                stringify ! ( af_currsz ) ));
}
impl Clone for audit_fstat {
    fn clone(&self) -> Self { *self }
}
pub type au_fstat_t = audit_fstat;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct au_evclass_map {
    pub ec_number: au_event_t,
    pub ec_class: au_class_t,
}
#[test]
fn bindgen_test_layout_au_evclass_map() {
    assert_eq!(::core::mem::size_of::<au_evclass_map>() , 8usize , concat ! (
               "Size of: " , stringify ! ( au_evclass_map ) ));
    assert_eq! (::core::mem::align_of::<au_evclass_map>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( au_evclass_map ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const au_evclass_map ) ) . ec_number as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( au_evclass_map ) , "::"
                , stringify ! ( ec_number ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const au_evclass_map ) ) . ec_class as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( au_evclass_map ) , "::"
                , stringify ! ( ec_class ) ));
}
impl Clone for au_evclass_map {
    fn clone(&self) -> Self { *self }
}
pub type au_evclass_map_t = au_evclass_map;
#[repr(C)]
#[derive(Copy)]
pub struct au_evname_map {
    pub en_number: au_event_t,
    pub en_name: [::kernel::sys::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_au_evname_map() {
    assert_eq!(::core::mem::size_of::<au_evname_map>() , 66usize , concat ! (
               "Size of: " , stringify ! ( au_evname_map ) ));
    assert_eq! (::core::mem::align_of::<au_evname_map>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( au_evname_map ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const au_evname_map ) ) . en_number as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( au_evname_map ) , "::"
                , stringify ! ( en_number ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const au_evname_map ) ) . en_name as * const _
                as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( au_evname_map ) , "::"
                , stringify ! ( en_name ) ));
}
impl Clone for au_evname_map {
    fn clone(&self) -> Self { *self }
}
impl Default for au_evname_map {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for au_evname_map {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "au_evname_map {{ en_number: {:?}, en_name: [{}] }}" , self
               . en_number , self . en_name . iter (  ) . enumerate (  ) . map
               (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ))
    }
}
pub type au_evname_map_t = au_evname_map;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct loginclass {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xucred {
    pub cr_version: u_int,
    pub cr_uid: uid_t,
    pub cr_ngroups: ::kernel::sys::raw::c_short,
    pub cr_groups: [gid_t; 16usize],
    pub _cr_unused1: *mut ::kernel::sys::raw::c_void,
}
#[test]
fn bindgen_test_layout_xucred() {
    assert_eq!(::core::mem::size_of::<xucred>() , 88usize , concat ! (
               "Size of: " , stringify ! ( xucred ) ));
    assert_eq! (::core::mem::align_of::<xucred>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( xucred ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xucred ) ) . cr_version as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xucred ) , "::" ,
                stringify ! ( cr_version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xucred ) ) . cr_uid as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( xucred ) , "::" ,
                stringify ! ( cr_uid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xucred ) ) . cr_ngroups as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xucred ) , "::" ,
                stringify ! ( cr_ngroups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xucred ) ) . cr_groups as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( xucred ) , "::" ,
                stringify ! ( cr_groups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xucred ) ) . _cr_unused1 as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( xucred ) , "::" ,
                stringify ! ( _cr_unused1 ) ));
}
impl Clone for xucred {
    fn clone(&self) -> Self { *self }
}
impl Default for xucred {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    pub fn change_egid(newcred: *mut ucred, egid: gid_t);
}
extern "C" {
    pub fn change_euid(newcred: *mut ucred, euip: *mut uidinfo);
}
extern "C" {
    pub fn change_rgid(newcred: *mut ucred, rgid: gid_t);
}
extern "C" {
    pub fn change_ruid(newcred: *mut ucred, ruip: *mut uidinfo);
}
extern "C" {
    pub fn change_svgid(newcred: *mut ucred, svgid: gid_t);
}
extern "C" {
    pub fn change_svuid(newcred: *mut ucred, svuid: uid_t);
}
extern "C" {
    pub fn crcopy(dest: *mut ucred, src: *mut ucred);
}
extern "C" {
    pub fn crcopysafe(p: *mut proc_, cr: *mut ucred) -> *mut ucred;
}
extern "C" {
    pub fn crdup(cr: *mut ucred) -> *mut ucred;
}
extern "C" {
    pub fn crextend(cr: *mut ucred, n: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn proc_set_cred_init(p: *mut proc_, cr: *mut ucred);
}
extern "C" {
    pub fn proc_set_cred(p: *mut proc_, cr: *mut ucred) -> *mut ucred;
}
extern "C" {
    pub fn crfree(cr: *mut ucred);
}
extern "C" {
    pub fn crget() -> *mut ucred;
}
extern "C" {
    pub fn crhold(cr: *mut ucred) -> *mut ucred;
}
extern "C" {
    pub fn cru2x(cr: *mut ucred, xcr: *mut xucred);
}
extern "C" {
    pub fn crsetgroups(cr: *mut ucred, n: ::kernel::sys::raw::c_int,
                       groups: *mut gid_t);
}
extern "C" {
    pub fn groupmember(gid: gid_t, cred: *mut ucred)
     -> ::kernel::sys::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct _domainset {
    pub __bits: [::kernel::sys::raw::c_long; 1usize],
}
#[test]
fn bindgen_test_layout__domainset() {
    assert_eq!(::core::mem::size_of::<_domainset>() , 8usize , concat ! (
               "Size of: " , stringify ! ( _domainset ) ));
    assert_eq! (::core::mem::align_of::<_domainset>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _domainset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _domainset ) ) . __bits as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _domainset ) , "::" ,
                stringify ! ( __bits ) ));
}
impl Clone for _domainset {
    fn clone(&self) -> Self { *self }
}
pub type domainset_t = _domainset;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct domainset {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct domainset_ref {
    pub dr_policy: *mut domainset,
    pub dr_iterator: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_domainset_ref() {
    assert_eq!(::core::mem::size_of::<domainset_ref>() , 16usize , concat ! (
               "Size of: " , stringify ! ( domainset_ref ) ));
    assert_eq! (::core::mem::align_of::<domainset_ref>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( domainset_ref ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const domainset_ref ) ) . dr_policy as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( domainset_ref ) , "::"
                , stringify ! ( dr_policy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const domainset_ref ) ) . dr_iterator as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( domainset_ref ) , "::"
                , stringify ! ( dr_iterator ) ));
}
impl Clone for domainset_ref {
    fn clone(&self) -> Self { *self }
}
impl Default for domainset_ref {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct proc_ldt {
    pub ldt_base: caddr_t,
    pub ldt_refcnt: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_proc_ldt() {
    assert_eq!(::core::mem::size_of::<proc_ldt>() , 16usize , concat ! (
               "Size of: " , stringify ! ( proc_ldt ) ));
    assert_eq! (::core::mem::align_of::<proc_ldt>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( proc_ldt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ldt ) ) . ldt_base as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ldt ) , "::" ,
                stringify ! ( ldt_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ldt ) ) . ldt_refcnt as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ldt ) , "::" ,
                stringify ! ( ldt_refcnt ) ));
}
impl Clone for proc_ldt {
    fn clone(&self) -> Self { *self }
}
impl Default for proc_ldt {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pmap_invl_gen {
    pub gen: u_long,
    pub link: pmap_invl_gen__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pmap_invl_gen__bindgen_ty_1 {
    pub le_next: *mut pmap_invl_gen,
    pub le_prev: *mut *mut pmap_invl_gen,
}
#[test]
fn bindgen_test_layout_pmap_invl_gen__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<pmap_invl_gen__bindgen_ty_1>() , 16usize
               , concat ! (
               "Size of: " , stringify ! ( pmap_invl_gen__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<pmap_invl_gen__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( pmap_invl_gen__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pmap_invl_gen__bindgen_ty_1 ) ) . le_next
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pmap_invl_gen__bindgen_ty_1 ) , "::" , stringify ! ( le_next )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pmap_invl_gen__bindgen_ty_1 ) ) . le_prev
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                pmap_invl_gen__bindgen_ty_1 ) , "::" , stringify ! ( le_prev )
                ));
}
impl Clone for pmap_invl_gen__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for pmap_invl_gen__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_pmap_invl_gen() {
    assert_eq!(::core::mem::size_of::<pmap_invl_gen>() , 24usize , concat ! (
               "Size of: " , stringify ! ( pmap_invl_gen ) ));
    assert_eq! (::core::mem::align_of::<pmap_invl_gen>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pmap_invl_gen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pmap_invl_gen ) ) . gen as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pmap_invl_gen ) , "::"
                , stringify ! ( gen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pmap_invl_gen ) ) . link as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pmap_invl_gen ) , "::"
                , stringify ! ( link ) ));
}
impl Clone for pmap_invl_gen {
    fn clone(&self) -> Self { *self }
}
impl Default for pmap_invl_gen {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mdthread {
    pub md_spinlock_count: ::kernel::sys::raw::c_int,
    pub md_saved_flags: register_t,
    pub md_spurflt_addr: register_t,
    pub md_invl_gen: pmap_invl_gen,
}
#[test]
fn bindgen_test_layout_mdthread() {
    assert_eq!(::core::mem::size_of::<mdthread>() , 48usize , concat ! (
               "Size of: " , stringify ! ( mdthread ) ));
    assert_eq! (::core::mem::align_of::<mdthread>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( mdthread ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mdthread ) ) . md_spinlock_count as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mdthread ) , "::" ,
                stringify ! ( md_spinlock_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mdthread ) ) . md_saved_flags as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mdthread ) , "::" ,
                stringify ! ( md_saved_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mdthread ) ) . md_spurflt_addr as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mdthread ) , "::" ,
                stringify ! ( md_spurflt_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mdthread ) ) . md_invl_gen as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( mdthread ) , "::" ,
                stringify ! ( md_invl_gen ) ));
}
impl Clone for mdthread {
    fn clone(&self) -> Self { *self }
}
impl Default for mdthread {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mdproc {
    pub md_ldt: *mut proc_ldt,
    pub md_ldt_sd: system_segment_descriptor,
}
#[test]
fn bindgen_test_layout_mdproc() {
    assert_eq!(::core::mem::size_of::<mdproc>() , 24usize , concat ! (
               "Size of: " , stringify ! ( mdproc ) ));
    assert_eq! (::core::mem::align_of::<mdproc>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( mdproc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mdproc ) ) . md_ldt as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mdproc ) , "::" ,
                stringify ! ( md_ldt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mdproc ) ) . md_ldt_sd as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mdproc ) , "::" ,
                stringify ! ( md_ldt_sd ) ));
}
impl Clone for mdproc {
    fn clone(&self) -> Self { *self }
}
impl Default for mdproc {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct syscall_args {
    pub code: u_int,
    pub callp: *mut sysent,
    pub args: [register_t; 8usize],
    pub narg: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_syscall_args() {
    assert_eq!(::core::mem::size_of::<syscall_args>() , 88usize , concat ! (
               "Size of: " , stringify ! ( syscall_args ) ));
    assert_eq! (::core::mem::align_of::<syscall_args>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( syscall_args ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const syscall_args ) ) . code as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( syscall_args ) , "::" ,
                stringify ! ( code ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const syscall_args ) ) . callp as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( syscall_args ) , "::" ,
                stringify ! ( callp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const syscall_args ) ) . args as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( syscall_args ) , "::" ,
                stringify ! ( args ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const syscall_args ) ) . narg as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( syscall_args ) , "::" ,
                stringify ! ( narg ) ));
}
impl Clone for syscall_args {
    fn clone(&self) -> Self { *self }
}
impl Default for syscall_args {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    pub fn user_ldt_alloc(arg1: *mut proc_, arg2: ::kernel::sys::raw::c_int)
     -> *mut proc_ldt;
}
extern "C" {
    pub fn user_ldt_free(arg1: *mut thread);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sysarch_args {
    _unused: [u8; 0],
}
extern "C" {
    pub fn sysarch_ldt(td: *mut thread, uap: *mut sysarch_args,
                       uap_space: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn amd64_set_ldt_data(td: *mut thread,
                              start: ::kernel::sys::raw::c_int,
                              num: ::kernel::sys::raw::c_int,
                              descs: *mut user_segment_descriptor)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "dt_lock"]
    pub static mut dt_lock: mtx;
}
extern "C" {
    #[link_name = "max_ldt_segment"]
    pub static mut max_ldt_segment: ::kernel::sys::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct epoch_section {
    pub bucket: ::kernel::sys::raw::c_uint,
}
#[test]
fn bindgen_test_layout_epoch_section() {
    assert_eq!(::core::mem::size_of::<epoch_section>() , 4usize , concat ! (
               "Size of: " , stringify ! ( epoch_section ) ));
    assert_eq! (::core::mem::align_of::<epoch_section>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( epoch_section ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const epoch_section ) ) . bucket as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( epoch_section ) , "::"
                , stringify ! ( bucket ) ));
}
impl Clone for epoch_section {
    fn clone(&self) -> Self { *self }
}
pub type epoch_section_t = epoch_section;
#[repr(C)]
#[derive(Copy)]
pub struct session {
    pub s_count: u_int,
    pub s_leader: *mut proc_,
    pub s_ttyvp: *mut vnode,
    pub s_ttydp: *mut cdev_priv,
    pub s_ttyp: *mut tty,
    pub s_sid: pid_t,
    pub s_login: [::kernel::sys::raw::c_char; 40usize],
    pub s_mtx: mtx,
}
#[test]
fn bindgen_test_layout_session() {
    assert_eq!(::core::mem::size_of::<session>() , 120usize , concat ! (
               "Size of: " , stringify ! ( session ) ));
    assert_eq! (::core::mem::align_of::<session>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( session ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const session ) ) . s_count as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( session ) , "::" ,
                stringify ! ( s_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const session ) ) . s_leader as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( session ) , "::" ,
                stringify ! ( s_leader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const session ) ) . s_ttyvp as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( session ) , "::" ,
                stringify ! ( s_ttyvp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const session ) ) . s_ttydp as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( session ) , "::" ,
                stringify ! ( s_ttydp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const session ) ) . s_ttyp as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( session ) , "::" ,
                stringify ! ( s_ttyp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const session ) ) . s_sid as * const _ as usize
                } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( session ) , "::" ,
                stringify ! ( s_sid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const session ) ) . s_login as * const _ as
                usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( session ) , "::" ,
                stringify ! ( s_login ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const session ) ) . s_mtx as * const _ as usize
                } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( session ) , "::" ,
                stringify ! ( s_mtx ) ));
}
impl Clone for session {
    fn clone(&self) -> Self { *self }
}
impl Default for session {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for session {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "session {{ s_count: {:?}, s_leader: {:?}, s_ttyvp: {:?}, s_ttydp: {:?}, s_ttyp: {:?}, s_sid: {:?}, s_login: [{}], s_mtx: {:?} }}"
               , self . s_count , self . s_leader , self . s_ttyvp , self .
               s_ttydp , self . s_ttyp , self . s_sid , self . s_login . iter
               (  ) . enumerate (  ) . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ) , self . s_mtx)
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct pargs {
    pub ar_ref: u_int,
    pub ar_length: u_int,
    pub ar_args: [u_char; 1usize],
}
#[test]
fn bindgen_test_layout_pargs() {
    assert_eq!(::core::mem::size_of::<pargs>() , 12usize , concat ! (
               "Size of: " , stringify ! ( pargs ) ));
    assert_eq! (::core::mem::align_of::<pargs>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( pargs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pargs ) ) . ar_ref as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pargs ) , "::" ,
                stringify ! ( ar_ref ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pargs ) ) . ar_length as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( pargs ) , "::" ,
                stringify ! ( ar_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pargs ) ) . ar_args as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pargs ) , "::" ,
                stringify ! ( ar_args ) ));
}
impl Clone for pargs {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cpuset {
    pub cs_mask: cpuset_t,
    pub cs_domain: *mut domainset,
    pub cs_ref: u_int,
    pub cs_flags: ::kernel::sys::raw::c_int,
    pub cs_id: cpusetid_t,
    pub cs_parent: *mut cpuset,
    pub cs_link: cpuset__bindgen_ty_1,
    pub cs_siblings: cpuset__bindgen_ty_2,
    pub cs_children: setlist,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cpuset__bindgen_ty_1 {
    pub le_next: *mut cpuset,
    pub le_prev: *mut *mut cpuset,
}
#[test]
fn bindgen_test_layout_cpuset__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<cpuset__bindgen_ty_1>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( cpuset__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<cpuset__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( cpuset__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuset__bindgen_ty_1 ) ) . le_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuset__bindgen_ty_1 )
                , "::" , stringify ! ( le_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuset__bindgen_ty_1 ) ) . le_prev as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuset__bindgen_ty_1 )
                , "::" , stringify ! ( le_prev ) ));
}
impl Clone for cpuset__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for cpuset__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cpuset__bindgen_ty_2 {
    pub le_next: *mut cpuset,
    pub le_prev: *mut *mut cpuset,
}
#[test]
fn bindgen_test_layout_cpuset__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<cpuset__bindgen_ty_2>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( cpuset__bindgen_ty_2 )
               ));
    assert_eq! (::core::mem::align_of::<cpuset__bindgen_ty_2>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( cpuset__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuset__bindgen_ty_2 ) ) . le_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuset__bindgen_ty_2 )
                , "::" , stringify ! ( le_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuset__bindgen_ty_2 ) ) . le_prev as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuset__bindgen_ty_2 )
                , "::" , stringify ! ( le_prev ) ));
}
impl Clone for cpuset__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for cpuset__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_cpuset() {
    assert_eq!(::core::mem::size_of::<cpuset>() , 104usize , concat ! (
               "Size of: " , stringify ! ( cpuset ) ));
    assert_eq! (::core::mem::align_of::<cpuset>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( cpuset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuset ) ) . cs_mask as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuset ) , "::" ,
                stringify ! ( cs_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuset ) ) . cs_domain as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuset ) , "::" ,
                stringify ! ( cs_domain ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuset ) ) . cs_ref as * const _ as usize
                } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuset ) , "::" ,
                stringify ! ( cs_ref ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuset ) ) . cs_flags as * const _ as
                usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuset ) , "::" ,
                stringify ! ( cs_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuset ) ) . cs_id as * const _ as usize
                } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuset ) , "::" ,
                stringify ! ( cs_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuset ) ) . cs_parent as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuset ) , "::" ,
                stringify ! ( cs_parent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuset ) ) . cs_link as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuset ) , "::" ,
                stringify ! ( cs_link ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuset ) ) . cs_siblings as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuset ) , "::" ,
                stringify ! ( cs_siblings ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuset ) ) . cs_children as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuset ) , "::" ,
                stringify ! ( cs_children ) ));
}
impl Clone for cpuset {
    fn clone(&self) -> Self { *self }
}
impl Default for cpuset {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct filecaps {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct filemon {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kaioinfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kaudit_record {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kdtrace_proc {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kdtrace_thread {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mqueue_notifier {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nlminfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct p_sched {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct procdesc {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct racct {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sbuf {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sleepqueue {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct td_sched {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct turnstile {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_map {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_map_entry {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct rusage_ext {
    pub rux_runtime: u64,
    pub rux_uticks: u64,
    pub rux_sticks: u64,
    pub rux_iticks: u64,
    pub rux_uu: u64,
    pub rux_su: u64,
    pub rux_tu: u64,
}
#[test]
fn bindgen_test_layout_rusage_ext() {
    assert_eq!(::core::mem::size_of::<rusage_ext>() , 56usize , concat ! (
               "Size of: " , stringify ! ( rusage_ext ) ));
    assert_eq! (::core::mem::align_of::<rusage_ext>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rusage_ext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_ext ) ) . rux_runtime as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_ext ) , "::" ,
                stringify ! ( rux_runtime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_ext ) ) . rux_uticks as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_ext ) , "::" ,
                stringify ! ( rux_uticks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_ext ) ) . rux_sticks as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_ext ) , "::" ,
                stringify ! ( rux_sticks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_ext ) ) . rux_iticks as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_ext ) , "::" ,
                stringify ! ( rux_iticks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_ext ) ) . rux_uu as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_ext ) , "::" ,
                stringify ! ( rux_uu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_ext ) ) . rux_su as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_ext ) , "::" ,
                stringify ! ( rux_su ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_ext ) ) . rux_tu as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_ext ) , "::" ,
                stringify ! ( rux_tu ) ));
}
impl Clone for rusage_ext {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct thread0_storage {
    pub t0st_thread: thread,
    pub t0st_sched: [u64; 10usize],
}
#[test]
fn bindgen_test_layout_thread0_storage() {
    assert_eq!(::core::mem::size_of::<thread0_storage>() , 1432usize , concat
               ! ( "Size of: " , stringify ! ( thread0_storage ) ));
    assert_eq! (::core::mem::align_of::<thread0_storage>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( thread0_storage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread0_storage ) ) . t0st_thread as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( thread0_storage ) ,
                "::" , stringify ! ( t0st_thread ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread0_storage ) ) . t0st_sched as *
                const _ as usize } , 1352usize , concat ! (
                "Alignment of field: " , stringify ! ( thread0_storage ) ,
                "::" , stringify ! ( t0st_sched ) ));
}
impl Clone for thread0_storage {
    fn clone(&self) -> Self { *self }
}
impl Default for thread0_storage {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for thread0_storage {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "thread0_storage {{ t0st_thread: {:?}, t0st_sched: {:?} }}"
               , self . t0st_thread , self . t0st_sched)
    }
}
extern "C" {
    pub fn thread_lock_block(arg1: *mut thread) -> *mut mtx;
}
extern "C" {
    pub fn thread_lock_unblock(arg1: *mut thread, arg2: *mut mtx);
}
extern "C" {
    pub fn thread_lock_set(arg1: *mut thread, arg2: *mut mtx);
}
extern "C" {
    #[link_name = "M_PARGS"]
    pub static mut M_PARGS: [malloc_type; 1usize];
}
extern "C" {
    #[link_name = "M_PGRP"]
    pub static mut M_PGRP: [malloc_type; 1usize];
}
extern "C" {
    #[link_name = "M_SESSION"]
    pub static mut M_SESSION: [malloc_type; 1usize];
}
extern "C" {
    #[link_name = "M_SUBPROC"]
    pub static mut M_SUBPROC: [malloc_type; 1usize];
}
extern "C" {
    #[link_name = "pid_max"]
    pub static mut pid_max: pid_t;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pidhashhead {
    pub lh_first: *mut proc_,
}
#[test]
fn bindgen_test_layout_pidhashhead() {
    assert_eq!(::core::mem::size_of::<pidhashhead>() , 8usize , concat ! (
               "Size of: " , stringify ! ( pidhashhead ) ));
    assert_eq! (::core::mem::align_of::<pidhashhead>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pidhashhead ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pidhashhead ) ) . lh_first as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pidhashhead ) , "::" ,
                stringify ! ( lh_first ) ));
}
impl Clone for pidhashhead {
    fn clone(&self) -> Self { *self }
}
impl Default for pidhashhead {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    #[link_name = "pidhashtbl"]
    pub static mut pidhashtbl: *mut pidhashhead;
}
extern "C" {
    #[link_name = "pidhash"]
    pub static mut pidhash: u_long;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tidhashhead {
    pub lh_first: *mut thread,
}
#[test]
fn bindgen_test_layout_tidhashhead() {
    assert_eq!(::core::mem::size_of::<tidhashhead>() , 8usize , concat ! (
               "Size of: " , stringify ! ( tidhashhead ) ));
    assert_eq! (::core::mem::align_of::<tidhashhead>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( tidhashhead ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tidhashhead ) ) . lh_first as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tidhashhead ) , "::" ,
                stringify ! ( lh_first ) ));
}
impl Clone for tidhashhead {
    fn clone(&self) -> Self { *self }
}
impl Default for tidhashhead {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    #[link_name = "tidhashtbl"]
    pub static mut tidhashtbl: *mut tidhashhead;
}
extern "C" {
    #[link_name = "tidhash"]
    pub static mut tidhash: u_long;
}
extern "C" {
    #[link_name = "tidhash_lock"]
    pub static mut tidhash_lock: rwlock;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pgrphashhead {
    pub lh_first: *mut pgrp,
}
#[test]
fn bindgen_test_layout_pgrphashhead() {
    assert_eq!(::core::mem::size_of::<pgrphashhead>() , 8usize , concat ! (
               "Size of: " , stringify ! ( pgrphashhead ) ));
    assert_eq! (::core::mem::align_of::<pgrphashhead>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pgrphashhead ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgrphashhead ) ) . lh_first as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pgrphashhead ) , "::" ,
                stringify ! ( lh_first ) ));
}
impl Clone for pgrphashhead {
    fn clone(&self) -> Self { *self }
}
impl Default for pgrphashhead {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    #[link_name = "pgrphashtbl"]
    pub static mut pgrphashtbl: *mut pgrphashhead;
}
extern "C" {
    #[link_name = "pgrphash"]
    pub static mut pgrphash: u_long;
}
extern "C" {
    #[link_name = "allproc_lock"]
    pub static mut allproc_lock: sx;
}
extern "C" {
    #[link_name = "allproc_gen"]
    pub static mut allproc_gen: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "proctree_lock"]
    pub static mut proctree_lock: sx;
}
extern "C" {
    #[link_name = "ppeers_lock"]
    pub static mut ppeers_lock: mtx;
}
extern "C" {
    #[link_name = "proc0"]
    pub static mut proc0: proc_;
}
extern "C" {
    #[link_name = "thread0_st"]
    pub static mut thread0_st: thread0_storage;
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct vmspace {
    pub _address: u8,
}
impl Clone for vmspace {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "vmspace0"]
    pub static mut vmspace0: vmspace;
}
extern "C" {
    #[link_name = "hogticks"]
    pub static mut hogticks: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "lastpid"]
    pub static mut lastpid: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "nprocs"]
    pub static mut nprocs: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "maxproc"]
    pub static mut maxproc: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "maxprocperuid"]
    pub static mut maxprocperuid: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "ps_arg_cache_limit"]
    pub static mut ps_arg_cache_limit: u_long;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct proclist {
    pub lh_first: *mut proc_,
}
#[test]
fn bindgen_test_layout_proclist() {
    assert_eq!(::core::mem::size_of::<proclist>() , 8usize , concat ! (
               "Size of: " , stringify ! ( proclist ) ));
    assert_eq! (::core::mem::align_of::<proclist>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( proclist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proclist ) ) . lh_first as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( proclist ) , "::" ,
                stringify ! ( lh_first ) ));
}
impl Clone for proclist {
    fn clone(&self) -> Self { *self }
}
impl Default for proclist {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct procqueue {
    pub tqh_first: *mut proc_,
    pub tqh_last: *mut *mut proc_,
}
#[test]
fn bindgen_test_layout_procqueue() {
    assert_eq!(::core::mem::size_of::<procqueue>() , 16usize , concat ! (
               "Size of: " , stringify ! ( procqueue ) ));
    assert_eq! (::core::mem::align_of::<procqueue>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( procqueue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const procqueue ) ) . tqh_first as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( procqueue ) , "::" ,
                stringify ! ( tqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const procqueue ) ) . tqh_last as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( procqueue ) , "::" ,
                stringify ! ( tqh_last ) ));
}
impl Clone for procqueue {
    fn clone(&self) -> Self { *self }
}
impl Default for procqueue {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct threadqueue {
    pub tqh_first: *mut thread,
    pub tqh_last: *mut *mut thread,
}
#[test]
fn bindgen_test_layout_threadqueue() {
    assert_eq!(::core::mem::size_of::<threadqueue>() , 16usize , concat ! (
               "Size of: " , stringify ! ( threadqueue ) ));
    assert_eq! (::core::mem::align_of::<threadqueue>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( threadqueue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const threadqueue ) ) . tqh_first as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( threadqueue ) , "::" ,
                stringify ! ( tqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const threadqueue ) ) . tqh_last as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( threadqueue ) , "::" ,
                stringify ! ( tqh_last ) ));
}
impl Clone for threadqueue {
    fn clone(&self) -> Self { *self }
}
impl Default for threadqueue {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    #[link_name = "allproc"]
    pub static mut allproc: proclist;
}
extern "C" {
    #[link_name = "zombproc"]
    pub static mut zombproc: proclist;
}
extern "C" {
    #[link_name = "initproc"]
    pub static mut initproc: *mut proc_;
}
extern "C" {
    #[link_name = "pageproc"]
    pub static mut pageproc: *mut proc_;
}
extern "C" {
    #[link_name = "proc_zone"]
    pub static mut proc_zone: *mut uma_zone;
}
extern "C" {
    pub fn pfind(arg1: pid_t) -> *mut proc_;
}
extern "C" {
    pub fn pfind_any(arg1: pid_t) -> *mut proc_;
}
extern "C" {
    pub fn pfind_locked(pid: pid_t) -> *mut proc_;
}
extern "C" {
    pub fn pgfind(arg1: pid_t) -> *mut pgrp;
}
extern "C" {
    pub fn zpfind(arg1: pid_t) -> *mut proc_;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct fork_req {
    pub fr_flags: ::kernel::sys::raw::c_int,
    pub fr_pages: ::kernel::sys::raw::c_int,
    pub fr_pidp: *mut ::kernel::sys::raw::c_int,
    pub fr_procp: *mut *mut proc_,
    pub fr_pd_fd: *mut ::kernel::sys::raw::c_int,
    pub fr_pd_flags: ::kernel::sys::raw::c_int,
    pub fr_pd_fcaps: *mut filecaps,
}
#[test]
fn bindgen_test_layout_fork_req() {
    assert_eq!(::core::mem::size_of::<fork_req>() , 48usize , concat ! (
               "Size of: " , stringify ! ( fork_req ) ));
    assert_eq! (::core::mem::align_of::<fork_req>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( fork_req ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fork_req ) ) . fr_flags as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( fork_req ) , "::" ,
                stringify ! ( fr_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fork_req ) ) . fr_pages as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( fork_req ) , "::" ,
                stringify ! ( fr_pages ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fork_req ) ) . fr_pidp as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( fork_req ) , "::" ,
                stringify ! ( fr_pidp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fork_req ) ) . fr_procp as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( fork_req ) , "::" ,
                stringify ! ( fr_procp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fork_req ) ) . fr_pd_fd as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( fork_req ) , "::" ,
                stringify ! ( fr_pd_fd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fork_req ) ) . fr_pd_flags as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( fork_req ) , "::" ,
                stringify ! ( fr_pd_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fork_req ) ) . fr_pd_fcaps as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( fork_req ) , "::" ,
                stringify ! ( fr_pd_fcaps ) ));
}
impl Clone for fork_req {
    fn clone(&self) -> Self { *self }
}
impl Default for fork_req {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    pub fn pget(pid: pid_t, flags: ::kernel::sys::raw::c_int,
                pp: *mut *mut proc_) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn ast(framep: *mut trapframe);
}
extern "C" {
    pub fn choosethread() -> *mut thread;
}
extern "C" {
    pub fn cr_cansee(u1: *mut ucred, u2: *mut ucred)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn cr_canseesocket(cred: *mut ucred, so: *mut socket)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn cr_canseeothergids(u1: *mut ucred, u2: *mut ucred)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn cr_canseeotheruids(u1: *mut ucred, u2: *mut ucred)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn cr_canseejailproc(u1: *mut ucred, u2: *mut ucred)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn cr_cansignal(cred: *mut ucred, proc_: *mut proc_,
                        signum: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn enterpgrp(p: *mut proc_, pgid: pid_t, pgrp: *mut pgrp,
                     sess: *mut session) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn enterthispgrp(p: *mut proc_, pgrp: *mut pgrp)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn faultin(p: *mut proc_);
}
extern "C" {
    pub fn fixjobc(p: *mut proc_, pgrp: *mut pgrp,
                   entering: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn fork1(arg1: *mut thread, arg2: *mut fork_req)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn fork_exit(arg1:
                         ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                         *mut ::kernel::sys::raw::c_void,
                                                                     arg2:
                                                                         *mut trapframe)>,
                     arg2: *mut ::kernel::sys::raw::c_void,
                     arg3: *mut trapframe);
}
extern "C" {
    pub fn fork_return(arg1: *mut thread, arg2: *mut trapframe);
}
extern "C" {
    pub fn inferior(p: *mut proc_) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn kern_proc_vmmap_resident(map: *mut vm_map,
                                    entry: *mut vm_map_entry,
                                    resident_count:
                                        *mut ::kernel::sys::raw::c_int,
                                    super_: *mut bool_);
}
extern "C" {
    pub fn kern_yield(arg1: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn kick_proc0();
}
extern "C" {
    pub fn killjobc();
}
extern "C" {
    pub fn leavepgrp(p: *mut proc_) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn maybe_preempt(td: *mut thread) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn maybe_yield();
}
extern "C" {
    pub fn mi_switch(flags: ::kernel::sys::raw::c_int, newtd: *mut thread);
}
extern "C" {
    pub fn p_candebug(td: *mut thread, p: *mut proc_)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn p_cansee(td: *mut thread, p: *mut proc_)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn p_cansched(td: *mut thread, p: *mut proc_)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn p_cansignal(td: *mut thread, p: *mut proc_,
                       signum: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn p_canwait(td: *mut thread, p: *mut proc_)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn pargs_alloc(len: ::kernel::sys::raw::c_int) -> *mut pargs;
}
extern "C" {
    pub fn pargs_drop(pa: *mut pargs);
}
extern "C" {
    pub fn pargs_hold(pa: *mut pargs);
}
extern "C" {
    pub fn proc_getargv(td: *mut thread, p: *mut proc_, sb: *mut sbuf)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn proc_getauxv(td: *mut thread, p: *mut proc_, sb: *mut sbuf)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn proc_getenvv(td: *mut thread, p: *mut proc_, sb: *mut sbuf)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn procinit();
}
extern "C" {
    pub fn proc_linkup0(p: *mut proc_, td: *mut thread);
}
extern "C" {
    pub fn proc_linkup(p: *mut proc_, td: *mut thread);
}
extern "C" {
    pub fn proc_realparent(child: *mut proc_) -> *mut proc_;
}
extern "C" {
    pub fn proc_reap(td: *mut thread, p: *mut proc_,
                     status: *mut ::kernel::sys::raw::c_int,
                     options: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn proc_reparent(child: *mut proc_, newparent: *mut proc_);
}
extern "C" {
    pub fn proc_set_traced(p: *mut proc_, stop: bool_);
}
extern "C" {
    pub fn pstats_alloc() -> *mut pstats;
}
extern "C" {
    pub fn pstats_fork(src: *mut pstats, dst: *mut pstats);
}
extern "C" {
    pub fn pstats_free(ps: *mut pstats);
}
extern "C" {
    pub fn reaper_abandon_children(p: *mut proc_, exiting: bool_);
}
extern "C" {
    pub fn securelevel_ge(cr: *mut ucred, level: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn securelevel_gt(cr: *mut ucred, level: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sess_hold(arg1: *mut session);
}
extern "C" {
    pub fn sess_release(arg1: *mut session);
}
extern "C" {
    pub fn setrunnable(arg1: *mut thread) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn setsugid(p: *mut proc_);
}
extern "C" {
    pub fn should_yield() -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sigonstack(sp: usize) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn stopevent(arg1: *mut proc_, arg2: u_int, arg3: u_int);
}
extern "C" {
    pub fn tdfind(arg1: lwpid_t, arg2: pid_t) -> *mut thread;
}
extern "C" {
    pub fn threadinit();
}
extern "C" {
    pub fn tidhash_add(arg1: *mut thread);
}
extern "C" {
    pub fn tidhash_remove(arg1: *mut thread);
}
extern "C" {
    pub fn cpu_idle(arg1: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn cpu_idle_wakeup(arg1: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "cpu_idle_hook"]
    pub static mut cpu_idle_hook:
               ::core::option::Option<unsafe extern "C" fn(arg1: sbintime_t)>;
}
extern "C" {
    pub fn cpu_switch(arg1: *mut thread, arg2: *mut thread, arg3: *mut mtx);
}
extern "C" {
    pub fn cpu_throw(arg1: *mut thread, arg2: *mut thread);
}
extern "C" {
    pub fn unsleep(arg1: *mut thread);
}
extern "C" {
    pub fn userret(arg1: *mut thread, arg2: *mut trapframe);
}
extern "C" {
    pub fn cpu_exit(arg1: *mut thread);
}
extern "C" {
    pub fn exit1(arg1: *mut thread, arg2: ::kernel::sys::raw::c_int,
                 arg3: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn cpu_copy_thread(td: *mut thread, td0: *mut thread);
}
extern "C" {
    pub fn cpu_fetch_syscall_args(td: *mut thread)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn cpu_fork(arg1: *mut thread, arg2: *mut proc_, arg3: *mut thread,
                    arg4: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn cpu_fork_kthread_handler(arg1: *mut thread,
                                    arg2:
                                        ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                                        *mut ::kernel::sys::raw::c_void)>,
                                    arg3: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn cpu_set_syscall_retval(arg1: *mut thread,
                                  arg2: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn cpu_set_upcall(arg1: *mut thread,
                          arg2:
                              ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                              *mut ::kernel::sys::raw::c_void)>,
                          arg3: *mut ::kernel::sys::raw::c_void,
                          arg4: *mut stack_t);
}
extern "C" {
    pub fn cpu_set_user_tls(arg1: *mut thread,
                            tls_base: *mut ::kernel::sys::raw::c_void)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn cpu_thread_alloc(arg1: *mut thread);
}
extern "C" {
    pub fn cpu_thread_clean(arg1: *mut thread);
}
extern "C" {
    pub fn cpu_thread_exit(arg1: *mut thread);
}
extern "C" {
    pub fn cpu_thread_free(arg1: *mut thread);
}
extern "C" {
    pub fn cpu_thread_swapin(arg1: *mut thread);
}
extern "C" {
    pub fn cpu_thread_swapout(arg1: *mut thread);
}
extern "C" {
    pub fn thread_alloc(pages: ::kernel::sys::raw::c_int) -> *mut thread;
}
extern "C" {
    pub fn thread_alloc_stack(arg1: *mut thread,
                              pages: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn thread_cow_get_proc(newtd: *mut thread, p: *mut proc_);
}
extern "C" {
    pub fn thread_cow_get(newtd: *mut thread, td: *mut thread);
}
extern "C" {
    pub fn thread_cow_free(td: *mut thread);
}
extern "C" {
    pub fn thread_cow_update(td: *mut thread);
}
extern "C" {
    pub fn thread_create(td: *mut thread, rtp: *mut rtprio,
                         initialize_thread:
                             ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                             *mut thread,
                                                                         arg2:
                                                                             *mut ::kernel::sys::raw::c_void)
                                                        ->
                                                            ::kernel::sys::raw::c_int>,
                         thunk: *mut ::kernel::sys::raw::c_void)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn thread_exit();
}
extern "C" {
    pub fn thread_free(td: *mut thread);
}
extern "C" {
    pub fn thread_link(td: *mut thread, p: *mut proc_);
}
extern "C" {
    pub fn thread_reap();
}
extern "C" {
    pub fn thread_single(p: *mut proc_, how: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn thread_single_end(p: *mut proc_, how: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn thread_stash(td: *mut thread);
}
extern "C" {
    pub fn thread_stopped(p: *mut proc_);
}
extern "C" {
    pub fn childproc_stopped(child: *mut proc_,
                             reason: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn childproc_continued(child: *mut proc_);
}
extern "C" {
    pub fn childproc_exited(child: *mut proc_);
}
extern "C" {
    pub fn thread_suspend_check(how: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn thread_suspend_check_needed() -> bool_;
}
extern "C" {
    pub fn thread_suspend_switch(arg1: *mut thread, p: *mut proc_);
}
extern "C" {
    pub fn thread_suspend_one(td: *mut thread);
}
extern "C" {
    pub fn thread_unlink(td: *mut thread);
}
extern "C" {
    pub fn thread_unsuspend(p: *mut proc_);
}
extern "C" {
    pub fn thread_wait(p: *mut proc_);
}
extern "C" {
    pub fn thread_find(p: *mut proc_, tid: lwpid_t) -> *mut thread;
}
extern "C" {
    pub fn stop_all_proc();
}
extern "C" {
    pub fn resume_all_proc();
}
extern "C" {
    #[link_name = "softdep_ast_cleanup"]
    pub static mut softdep_ast_cleanup:
               ::core::option::Option<unsafe extern "C" fn(arg1:
                                                               *mut thread)>;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct epoch {
    _unused: [u8; 0],
}
pub type epoch_t = *mut epoch;
extern "C" {
    #[link_name = "global_epoch"]
    pub static mut global_epoch: epoch_t;
}
extern "C" {
    #[link_name = "global_epoch_preempt"]
    pub static mut global_epoch_preempt: epoch_t;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct epoch_context {
    pub data: [*mut ::kernel::sys::raw::c_void; 2usize],
}
#[test]
fn bindgen_test_layout_epoch_context() {
    assert_eq!(::core::mem::size_of::<epoch_context>() , 16usize , concat ! (
               "Size of: " , stringify ! ( epoch_context ) ));
    assert_eq! (::core::mem::align_of::<epoch_context>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( epoch_context ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const epoch_context ) ) . data as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( epoch_context ) , "::"
                , stringify ! ( data ) ));
}
impl Clone for epoch_context {
    fn clone(&self) -> Self { *self }
}
impl Default for epoch_context {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type epoch_context_t = *mut epoch_context;
extern "C" {
    pub fn epoch_alloc(flags: ::kernel::sys::raw::c_int) -> epoch_t;
}
extern "C" {
    pub fn epoch_free(epoch: epoch_t);
}
extern "C" {
    pub fn epoch_enter(epoch: epoch_t);
}
extern "C" {
    pub fn epoch_enter_preempt_internal(epoch: epoch_t, td: *mut thread);
}
extern "C" {
    pub fn epoch_exit(epoch: epoch_t);
}
extern "C" {
    pub fn epoch_exit_preempt_internal(epoch: epoch_t, td: *mut thread);
}
extern "C" {
    pub fn epoch_wait(epoch: epoch_t);
}
extern "C" {
    pub fn epoch_wait_preempt(epoch: epoch_t);
}
extern "C" {
    pub fn epoch_call(epoch: epoch_t, ctx: epoch_context_t,
                      callback:
                          ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                          epoch_context_t)>);
}
extern "C" {
    pub fn in_epoch() -> ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "pcpu_entry_epoch_cb_count"]
    pub static mut pcpu_entry_epoch_cb_count: ::kernel::sys::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct grouptask {
    pub gt_task: gtask,
    pub gt_taskqueue: *mut ::kernel::sys::raw::c_void,
    pub gt_list: grouptask__bindgen_ty_1,
    pub gt_uniq: *mut ::kernel::sys::raw::c_void,
    pub gt_name: [::kernel::sys::raw::c_char; 32usize],
    pub gt_irq: i16,
    pub gt_cpu: i16,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct grouptask__bindgen_ty_1 {
    pub le_next: *mut grouptask,
    pub le_prev: *mut *mut grouptask,
}
#[test]
fn bindgen_test_layout_grouptask__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<grouptask__bindgen_ty_1>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( grouptask__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<grouptask__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( grouptask__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const grouptask__bindgen_ty_1 ) ) . le_next as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( grouptask__bindgen_ty_1
                ) , "::" , stringify ! ( le_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const grouptask__bindgen_ty_1 ) ) . le_prev as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( grouptask__bindgen_ty_1
                ) , "::" , stringify ! ( le_prev ) ));
}
impl Clone for grouptask__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for grouptask__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_grouptask() {
    assert_eq!(::core::mem::size_of::<grouptask>() , 104usize , concat ! (
               "Size of: " , stringify ! ( grouptask ) ));
    assert_eq! (::core::mem::align_of::<grouptask>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( grouptask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const grouptask ) ) . gt_task as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( grouptask ) , "::" ,
                stringify ! ( gt_task ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const grouptask ) ) . gt_taskqueue as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( grouptask ) , "::" ,
                stringify ! ( gt_taskqueue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const grouptask ) ) . gt_list as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( grouptask ) , "::" ,
                stringify ! ( gt_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const grouptask ) ) . gt_uniq as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( grouptask ) , "::" ,
                stringify ! ( gt_uniq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const grouptask ) ) . gt_name as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( grouptask ) , "::" ,
                stringify ! ( gt_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const grouptask ) ) . gt_irq as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( grouptask ) , "::" ,
                stringify ! ( gt_irq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const grouptask ) ) . gt_cpu as * const _ as
                usize } , 98usize , concat ! (
                "Alignment of field: " , stringify ! ( grouptask ) , "::" ,
                stringify ! ( gt_cpu ) ));
}
impl Clone for grouptask {
    fn clone(&self) -> Self { *self }
}
impl Default for grouptask {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    #[link_name = "pcpu_entry_epoch_cb_task"]
    pub static mut pcpu_entry_epoch_cb_task: grouptask;
}
extern "C" {
    #[link_name = "lockstat_enabled"]
    pub static mut lockstat_enabled: bool_;
}
extern "C" {
    pub fn _mtx_init(c: *mut usize, name: *const ::kernel::sys::raw::c_char,
                     type_: *const ::kernel::sys::raw::c_char,
                     opts: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn _mtx_destroy(c: *mut usize);
}
extern "C" {
    pub fn mtx_sysinit(arg: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn _mtx_trylock_flags_int(m: *mut mtx,
                                  opts: ::kernel::sys::raw::c_int,
                                  file: *const ::kernel::sys::raw::c_char,
                                  line: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn _mtx_trylock_flags_(c: *mut usize, opts: ::kernel::sys::raw::c_int,
                               file: *const ::kernel::sys::raw::c_char,
                               line: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn mutex_init();
}
extern "C" {
    pub fn __mtx_lock_sleep(c: *mut usize, v: usize,
                            opts: ::kernel::sys::raw::c_int,
                            file: *const ::kernel::sys::raw::c_char,
                            line: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn __mtx_unlock_sleep(c: *mut usize, v: usize,
                              opts: ::kernel::sys::raw::c_int,
                              file: *const ::kernel::sys::raw::c_char,
                              line: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn __mtx_lock_flags(c: *mut usize, opts: ::kernel::sys::raw::c_int,
                            file: *const ::kernel::sys::raw::c_char,
                            line: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn __mtx_unlock_flags(c: *mut usize, opts: ::kernel::sys::raw::c_int,
                              file: *const ::kernel::sys::raw::c_char,
                              line: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn __mtx_lock_spin_flags(c: *mut usize,
                                 opts: ::kernel::sys::raw::c_int,
                                 file: *const ::kernel::sys::raw::c_char,
                                 line: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn __mtx_trylock_spin_flags(c: *mut usize,
                                    opts: ::kernel::sys::raw::c_int,
                                    file: *const ::kernel::sys::raw::c_char,
                                    line: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn __mtx_unlock_spin_flags(c: *mut usize,
                                   opts: ::kernel::sys::raw::c_int,
                                   file: *const ::kernel::sys::raw::c_char,
                                   line: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn mtx_spin_wait_unlocked(m: *mut mtx);
}
extern "C" {
    pub fn thread_lock_flags_(arg1: *mut thread,
                              arg2: ::kernel::sys::raw::c_int,
                              arg3: *const ::kernel::sys::raw::c_char,
                              arg4: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn _thread_lock(td: *mut thread, opts: ::kernel::sys::raw::c_int,
                        file: *const ::kernel::sys::raw::c_char,
                        line: ::kernel::sys::raw::c_int);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mtx_pool {
    _unused: [u8; 0],
}
extern "C" {
    pub fn mtx_pool_create(mtx_name: *const ::kernel::sys::raw::c_char,
                           pool_size: ::kernel::sys::raw::c_int,
                           opts: ::kernel::sys::raw::c_int) -> *mut mtx_pool;
}
extern "C" {
    pub fn mtx_pool_destroy(poolp: *mut *mut mtx_pool);
}
extern "C" {
    pub fn mtx_pool_find(pool: *mut mtx_pool,
                         ptr: *mut ::kernel::sys::raw::c_void) -> *mut mtx;
}
extern "C" {
    pub fn mtx_pool_alloc(pool: *mut mtx_pool) -> *mut mtx;
}
extern "C" {
    #[link_name = "mtxpool_sleep"]
    pub static mut mtxpool_sleep: *mut mtx_pool;
}
extern "C" {
    #[link_name = "Giant"]
    pub static mut Giant: mtx;
}
extern "C" {
    #[link_name = "blocked_lock"]
    pub static mut blocked_lock: mtx;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mtx_args {
    pub ma_mtx: *mut ::kernel::sys::raw::c_void,
    pub ma_desc: *const ::kernel::sys::raw::c_char,
    pub ma_opts: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_mtx_args() {
    assert_eq!(::core::mem::size_of::<mtx_args>() , 24usize , concat ! (
               "Size of: " , stringify ! ( mtx_args ) ));
    assert_eq! (::core::mem::align_of::<mtx_args>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( mtx_args ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mtx_args ) ) . ma_mtx as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mtx_args ) , "::" ,
                stringify ! ( ma_mtx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mtx_args ) ) . ma_desc as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mtx_args ) , "::" ,
                stringify ! ( ma_desc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mtx_args ) ) . ma_opts as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mtx_args ) , "::" ,
                stringify ! ( ma_opts ) ));
}
impl Clone for mtx_args {
    fn clone(&self) -> Self { *self }
}
impl Default for mtx_args {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct rwlock_padalign {
    pub lock_object: lock_object,
    pub rw_lock: usize,
    pub __bindgen_padding_0: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_rwlock_padalign() {
    assert_eq!(::core::mem::size_of::<rwlock_padalign>() , 64usize , concat !
               ( "Size of: " , stringify ! ( rwlock_padalign ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rwlock_padalign ) ) . lock_object as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rwlock_padalign ) ,
                "::" , stringify ! ( lock_object ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rwlock_padalign ) ) . rw_lock as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rwlock_padalign ) ,
                "::" , stringify ! ( rw_lock ) ));
}
impl Clone for rwlock_padalign {
    fn clone(&self) -> Self { *self }
}
impl Default for rwlock_padalign {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for rwlock_padalign {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "rwlock_padalign {{ lock_object: {:?}, rw_lock: {:?} }}" ,
               self . lock_object , self . rw_lock)
    }
}
extern "C" {
    pub fn _rw_init_flags(c: *mut usize,
                          name: *const ::kernel::sys::raw::c_char,
                          opts: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn _rw_destroy(c: *mut usize);
}
extern "C" {
    pub fn rw_sysinit(arg: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn rw_sysinit_flags(arg: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn _rw_wowned(c: *const usize) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn _rw_wlock_cookie(c: *mut usize,
                            file: *const ::kernel::sys::raw::c_char,
                            line: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn __rw_try_wlock_int(rw: *mut rwlock,
                              file: *const ::kernel::sys::raw::c_char,
                              line: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn __rw_try_wlock(c: *mut usize,
                          file: *const ::kernel::sys::raw::c_char,
                          line: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn _rw_wunlock_cookie(c: *mut usize,
                              file: *const ::kernel::sys::raw::c_char,
                              line: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn __rw_rlock_int(rw: *mut rwlock,
                          file: *const ::kernel::sys::raw::c_char,
                          line: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn __rw_rlock(c: *mut usize, file: *const ::kernel::sys::raw::c_char,
                      line: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn __rw_try_rlock_int(rw: *mut rwlock,
                              file: *const ::kernel::sys::raw::c_char,
                              line: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn __rw_try_rlock(c: *mut usize,
                          file: *const ::kernel::sys::raw::c_char,
                          line: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn _rw_runlock_cookie_int(rw: *mut rwlock,
                                  file: *const ::kernel::sys::raw::c_char,
                                  line: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn _rw_runlock_cookie(c: *mut usize,
                              file: *const ::kernel::sys::raw::c_char,
                              line: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn __rw_wlock_hard(c: *mut usize, v: usize,
                           file: *const ::kernel::sys::raw::c_char,
                           line: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn __rw_wunlock_hard(c: *mut usize, v: usize,
                             file: *const ::kernel::sys::raw::c_char,
                             line: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn __rw_try_upgrade_int(rw: *mut rwlock,
                                file: *const ::kernel::sys::raw::c_char,
                                line: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn __rw_try_upgrade(c: *mut usize,
                            file: *const ::kernel::sys::raw::c_char,
                            line: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn __rw_downgrade_int(rw: *mut rwlock,
                              file: *const ::kernel::sys::raw::c_char,
                              line: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn __rw_downgrade(c: *mut usize,
                          file: *const ::kernel::sys::raw::c_char,
                          line: ::kernel::sys::raw::c_int);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rw_args {
    pub ra_rw: *mut ::kernel::sys::raw::c_void,
    pub ra_desc: *const ::kernel::sys::raw::c_char,
    pub ra_flags: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_rw_args() {
    assert_eq!(::core::mem::size_of::<rw_args>() , 24usize , concat ! (
               "Size of: " , stringify ! ( rw_args ) ));
    assert_eq! (::core::mem::align_of::<rw_args>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rw_args ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rw_args ) ) . ra_rw as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rw_args ) , "::" ,
                stringify ! ( ra_rw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rw_args ) ) . ra_desc as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rw_args ) , "::" ,
                stringify ! ( ra_desc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rw_args ) ) . ra_flags as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rw_args ) , "::" ,
                stringify ! ( ra_flags ) ));
}
impl Clone for rw_args {
    fn clone(&self) -> Self { *self }
}
impl Default for rw_args {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    pub fn sx_sysinit(arg: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn sx_init_flags(sx: *mut sx,
                         description: *const ::kernel::sys::raw::c_char,
                         opts: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn sx_destroy(sx: *mut sx);
}
extern "C" {
    pub fn sx_try_slock_int(sx: *mut sx,
                            file: *const ::kernel::sys::raw::c_char,
                            line: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sx_try_slock_(sx: *mut sx, file: *const ::kernel::sys::raw::c_char,
                         line: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sx_try_xlock_int(sx: *mut sx,
                            file: *const ::kernel::sys::raw::c_char,
                            line: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sx_try_xlock_(sx: *mut sx, file: *const ::kernel::sys::raw::c_char,
                         line: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sx_try_upgrade_int(sx: *mut sx,
                              file: *const ::kernel::sys::raw::c_char,
                              line: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sx_try_upgrade_(sx: *mut sx,
                           file: *const ::kernel::sys::raw::c_char,
                           line: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sx_downgrade_int(sx: *mut sx,
                            file: *const ::kernel::sys::raw::c_char,
                            line: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn sx_downgrade_(sx: *mut sx, file: *const ::kernel::sys::raw::c_char,
                         line: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn _sx_slock_int(sx: *mut sx, opts: ::kernel::sys::raw::c_int,
                         file: *const ::kernel::sys::raw::c_char,
                         line: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn _sx_slock(sx: *mut sx, opts: ::kernel::sys::raw::c_int,
                     file: *const ::kernel::sys::raw::c_char,
                     line: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn _sx_xlock(sx: *mut sx, opts: ::kernel::sys::raw::c_int,
                     file: *const ::kernel::sys::raw::c_char,
                     line: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn _sx_sunlock_int(sx: *mut sx,
                           file: *const ::kernel::sys::raw::c_char,
                           line: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn _sx_sunlock(sx: *mut sx, file: *const ::kernel::sys::raw::c_char,
                       line: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn _sx_xunlock(sx: *mut sx, file: *const ::kernel::sys::raw::c_char,
                       line: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn _sx_xlock_hard(sx: *mut sx, x: usize,
                          opts: ::kernel::sys::raw::c_int,
                          file: *const ::kernel::sys::raw::c_char,
                          line: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn _sx_xunlock_hard(sx: *mut sx, x: usize,
                            file: *const ::kernel::sys::raw::c_char,
                            line: ::kernel::sys::raw::c_int);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sx_args {
    pub sa_sx: *mut sx,
    pub sa_desc: *const ::kernel::sys::raw::c_char,
    pub sa_flags: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_sx_args() {
    assert_eq!(::core::mem::size_of::<sx_args>() , 24usize , concat ! (
               "Size of: " , stringify ! ( sx_args ) ));
    assert_eq! (::core::mem::align_of::<sx_args>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sx_args ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sx_args ) ) . sa_sx as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sx_args ) , "::" ,
                stringify ! ( sa_sx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sx_args ) ) . sa_desc as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sx_args ) , "::" ,
                stringify ! ( sa_desc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sx_args ) ) . sa_flags as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( sx_args ) , "::" ,
                stringify ! ( sa_flags ) ));
}
impl Clone for sx_args {
    fn clone(&self) -> Self { *self }
}
impl Default for sx_args {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type task_fn_t =
    ::core::option::Option<unsafe extern "C" fn(context:
                                                    *mut ::kernel::sys::raw::c_void,
                                                pending:
                                                    ::kernel::sys::raw::c_int)>;
pub type gtask_fn_t =
    ::core::option::Option<unsafe extern "C" fn(context:
                                                    *mut ::kernel::sys::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct task {
    pub ta_link: task__bindgen_ty_1,
    pub ta_pending: u16,
    pub ta_priority: u_short,
    pub ta_func: task_fn_t,
    pub ta_context: *mut ::kernel::sys::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct task__bindgen_ty_1 {
    pub stqe_next: *mut task,
}
#[test]
fn bindgen_test_layout_task__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<task__bindgen_ty_1>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( task__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<task__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( task__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const task__bindgen_ty_1 ) ) . stqe_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( task__bindgen_ty_1 ) ,
                "::" , stringify ! ( stqe_next ) ));
}
impl Clone for task__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for task__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_task() {
    assert_eq!(::core::mem::size_of::<task>() , 32usize , concat ! (
               "Size of: " , stringify ! ( task ) ));
    assert_eq! (::core::mem::align_of::<task>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( task ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const task ) ) . ta_link as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( task ) , "::" ,
                stringify ! ( ta_link ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const task ) ) . ta_pending as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( task ) , "::" ,
                stringify ! ( ta_pending ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const task ) ) . ta_priority as * const _ as
                usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( task ) , "::" ,
                stringify ! ( ta_priority ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const task ) ) . ta_func as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( task ) , "::" ,
                stringify ! ( ta_func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const task ) ) . ta_context as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( task ) , "::" ,
                stringify ! ( ta_context ) ));
}
impl Clone for task {
    fn clone(&self) -> Self { *self }
}
impl Default for task {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct gtask {
    pub ta_link: gtask__bindgen_ty_1,
    pub ta_flags: u16,
    pub ta_priority: u_short,
    pub ta_func: gtask_fn_t,
    pub ta_context: *mut ::kernel::sys::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct gtask__bindgen_ty_1 {
    pub stqe_next: *mut gtask,
}
#[test]
fn bindgen_test_layout_gtask__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<gtask__bindgen_ty_1>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( gtask__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<gtask__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( gtask__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gtask__bindgen_ty_1 ) ) . stqe_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( gtask__bindgen_ty_1 ) ,
                "::" , stringify ! ( stqe_next ) ));
}
impl Clone for gtask__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for gtask__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_gtask() {
    assert_eq!(::core::mem::size_of::<gtask>() , 32usize , concat ! (
               "Size of: " , stringify ! ( gtask ) ));
    assert_eq! (::core::mem::align_of::<gtask>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( gtask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gtask ) ) . ta_link as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( gtask ) , "::" ,
                stringify ! ( ta_link ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gtask ) ) . ta_flags as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( gtask ) , "::" ,
                stringify ! ( ta_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gtask ) ) . ta_priority as * const _ as
                usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( gtask ) , "::" ,
                stringify ! ( ta_priority ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gtask ) ) . ta_func as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( gtask ) , "::" ,
                stringify ! ( ta_func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gtask ) ) . ta_context as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( gtask ) , "::" ,
                stringify ! ( ta_context ) ));
}
impl Clone for gtask {
    fn clone(&self) -> Self { *self }
}
impl Default for gtask {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct altq_pktattr {
    pub pattr_class: *mut ::kernel::sys::raw::c_void,
    pub pattr_af: ::kernel::sys::raw::c_int,
    pub pattr_hdr: caddr_t,
}
#[test]
fn bindgen_test_layout_altq_pktattr() {
    assert_eq!(::core::mem::size_of::<altq_pktattr>() , 24usize , concat ! (
               "Size of: " , stringify ! ( altq_pktattr ) ));
    assert_eq! (::core::mem::align_of::<altq_pktattr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( altq_pktattr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const altq_pktattr ) ) . pattr_class as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( altq_pktattr ) , "::" ,
                stringify ! ( pattr_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const altq_pktattr ) ) . pattr_af as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( altq_pktattr ) , "::" ,
                stringify ! ( pattr_af ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const altq_pktattr ) ) . pattr_hdr as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( altq_pktattr ) , "::" ,
                stringify ! ( pattr_hdr ) ));
}
impl Clone for altq_pktattr {
    fn clone(&self) -> Self { *self }
}
impl Default for altq_pktattr {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct tb_regulator {
    pub tbr_rate: i64,
    pub tbr_depth: i64,
    pub tbr_token: i64,
    pub tbr_filluptime: i64,
    pub tbr_last: u_int64_t,
    pub tbr_lastop: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_tb_regulator() {
    assert_eq!(::core::mem::size_of::<tb_regulator>() , 48usize , concat ! (
               "Size of: " , stringify ! ( tb_regulator ) ));
    assert_eq! (::core::mem::align_of::<tb_regulator>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( tb_regulator ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tb_regulator ) ) . tbr_rate as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tb_regulator ) , "::" ,
                stringify ! ( tbr_rate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tb_regulator ) ) . tbr_depth as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tb_regulator ) , "::" ,
                stringify ! ( tbr_depth ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tb_regulator ) ) . tbr_token as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( tb_regulator ) , "::" ,
                stringify ! ( tbr_token ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tb_regulator ) ) . tbr_filluptime as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( tb_regulator ) , "::" ,
                stringify ! ( tbr_filluptime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tb_regulator ) ) . tbr_last as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( tb_regulator ) , "::" ,
                stringify ! ( tbr_last ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tb_regulator ) ) . tbr_lastop as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( tb_regulator ) , "::" ,
                stringify ! ( tbr_lastop ) ));
}
impl Clone for tb_regulator {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct top_cdnr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifaltq {
    pub ifq_head: *mut mbuf,
    pub ifq_tail: *mut mbuf,
    pub ifq_len: ::kernel::sys::raw::c_int,
    pub ifq_maxlen: ::kernel::sys::raw::c_int,
    pub ifq_mtx: mtx,
    pub ifq_drv_head: *mut mbuf,
    pub ifq_drv_tail: *mut mbuf,
    pub ifq_drv_len: ::kernel::sys::raw::c_int,
    pub ifq_drv_maxlen: ::kernel::sys::raw::c_int,
    pub altq_type: ::kernel::sys::raw::c_int,
    pub altq_flags: ::kernel::sys::raw::c_int,
    pub altq_disc: *mut ::kernel::sys::raw::c_void,
    pub altq_ifp: *mut ifnet,
    pub altq_enqueue: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ifaltq,
                                                                  arg2:
                                                                      *mut mbuf,
                                                                  arg3:
                                                                      *mut altq_pktattr)
                                                 ->
                                                     ::kernel::sys::raw::c_int>,
    pub altq_dequeue: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ifaltq,
                                                                  arg2:
                                                                      ::kernel::sys::raw::c_int)
                                                 -> *mut mbuf>,
    pub altq_request: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ifaltq,
                                                                  arg2:
                                                                      ::kernel::sys::raw::c_int,
                                                                  arg3:
                                                                      *mut ::kernel::sys::raw::c_void)
                                                 ->
                                                     ::kernel::sys::raw::c_int>,
    pub altq_clfier: *mut ::kernel::sys::raw::c_void,
    pub altq_classify: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                       *mut ::kernel::sys::raw::c_void,
                                                                   arg2:
                                                                       *mut mbuf,
                                                                   arg3:
                                                                       ::kernel::sys::raw::c_int)
                                                  ->
                                                      *mut ::kernel::sys::raw::c_void>,
    pub altq_tbr: *mut tb_regulator,
    pub altq_cdnr: *mut top_cdnr,
}
#[test]
fn bindgen_test_layout_ifaltq() {
    assert_eq!(::core::mem::size_of::<ifaltq>() , 160usize , concat ! (
               "Size of: " , stringify ! ( ifaltq ) ));
    assert_eq! (::core::mem::align_of::<ifaltq>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ifaltq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaltq ) ) . ifq_head as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaltq ) , "::" ,
                stringify ! ( ifq_head ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaltq ) ) . ifq_tail as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaltq ) , "::" ,
                stringify ! ( ifq_tail ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaltq ) ) . ifq_len as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaltq ) , "::" ,
                stringify ! ( ifq_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaltq ) ) . ifq_maxlen as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaltq ) , "::" ,
                stringify ! ( ifq_maxlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaltq ) ) . ifq_mtx as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaltq ) , "::" ,
                stringify ! ( ifq_mtx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaltq ) ) . ifq_drv_head as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaltq ) , "::" ,
                stringify ! ( ifq_drv_head ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaltq ) ) . ifq_drv_tail as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaltq ) , "::" ,
                stringify ! ( ifq_drv_tail ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaltq ) ) . ifq_drv_len as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaltq ) , "::" ,
                stringify ! ( ifq_drv_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaltq ) ) . ifq_drv_maxlen as * const _
                as usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaltq ) , "::" ,
                stringify ! ( ifq_drv_maxlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaltq ) ) . altq_type as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaltq ) , "::" ,
                stringify ! ( altq_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaltq ) ) . altq_flags as * const _ as
                usize } , 84usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaltq ) , "::" ,
                stringify ! ( altq_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaltq ) ) . altq_disc as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaltq ) , "::" ,
                stringify ! ( altq_disc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaltq ) ) . altq_ifp as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaltq ) , "::" ,
                stringify ! ( altq_ifp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaltq ) ) . altq_enqueue as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaltq ) , "::" ,
                stringify ! ( altq_enqueue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaltq ) ) . altq_dequeue as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaltq ) , "::" ,
                stringify ! ( altq_dequeue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaltq ) ) . altq_request as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaltq ) , "::" ,
                stringify ! ( altq_request ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaltq ) ) . altq_clfier as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaltq ) , "::" ,
                stringify ! ( altq_clfier ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaltq ) ) . altq_classify as * const _
                as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaltq ) , "::" ,
                stringify ! ( altq_classify ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaltq ) ) . altq_tbr as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaltq ) , "::" ,
                stringify ! ( altq_tbr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaltq ) ) . altq_cdnr as * const _ as
                usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaltq ) , "::" ,
                stringify ! ( altq_cdnr ) ));
}
impl Clone for ifaltq {
    fn clone(&self) -> Self { *self }
}
impl Default for ifaltq {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct altq_tag {
    pub qid: u_int32_t,
    pub af: ::kernel::sys::raw::c_int,
    pub hdr: *mut ::kernel::sys::raw::c_void,
}
#[test]
fn bindgen_test_layout_altq_tag() {
    assert_eq!(::core::mem::size_of::<altq_tag>() , 16usize , concat ! (
               "Size of: " , stringify ! ( altq_tag ) ));
    assert_eq! (::core::mem::align_of::<altq_tag>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( altq_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const altq_tag ) ) . qid as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( altq_tag ) , "::" ,
                stringify ! ( qid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const altq_tag ) ) . af as * const _ as usize }
                , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( altq_tag ) , "::" ,
                stringify ! ( af ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const altq_tag ) ) . hdr as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( altq_tag ) , "::" ,
                stringify ! ( hdr ) ));
}
impl Clone for altq_tag {
    fn clone(&self) -> Self { *self }
}
impl Default for altq_tag {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    pub fn altq_attach(arg1: *mut ifaltq, arg2: ::kernel::sys::raw::c_int,
                       arg3: *mut ::kernel::sys::raw::c_void,
                       arg4:
                           ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                           *mut ifaltq,
                                                                       arg2:
                                                                           *mut mbuf,
                                                                       arg3:
                                                                           *mut altq_pktattr)
                                                      ->
                                                          ::kernel::sys::raw::c_int>,
                       arg5:
                           ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                           *mut ifaltq,
                                                                       arg2:
                                                                           ::kernel::sys::raw::c_int)
                                                      -> *mut mbuf>,
                       arg6:
                           ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                           *mut ifaltq,
                                                                       arg2:
                                                                           ::kernel::sys::raw::c_int,
                                                                       arg3:
                                                                           *mut ::kernel::sys::raw::c_void)
                                                      ->
                                                          ::kernel::sys::raw::c_int>,
                       arg7: *mut ::kernel::sys::raw::c_void,
                       arg8:
                           ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                           *mut ::kernel::sys::raw::c_void,
                                                                       arg2:
                                                                           *mut mbuf,
                                                                       arg3:
                                                                           ::kernel::sys::raw::c_int)
                                                      ->
                                                          *mut ::kernel::sys::raw::c_void>)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn altq_detach(arg1: *mut ifaltq) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn altq_enable(arg1: *mut ifaltq) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn altq_disable(arg1: *mut ifaltq) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "tbr_dequeue_ptr"]
    pub static mut tbr_dequeue_ptr:
               ::core::option::Option<unsafe extern "C" fn(arg1: *mut ifaltq,
                                                           arg2:
                                                               ::kernel::sys::raw::c_int)
                                          -> *mut mbuf>;
}
extern "C" {
    #[link_name = "altq_input"]
    pub static mut altq_input:
               ::core::option::Option<unsafe extern "C" fn(arg1: *mut mbuf,
                                                           arg2:
                                                               ::kernel::sys::raw::c_int)
                                          -> ::kernel::sys::raw::c_int>;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifnethead {
    pub cstqh_first: *mut ifnet,
    pub cstqh_last: *mut *mut ifnet,
}
#[test]
fn bindgen_test_layout_ifnethead() {
    assert_eq!(::core::mem::size_of::<ifnethead>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ifnethead ) ));
    assert_eq! (::core::mem::align_of::<ifnethead>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ifnethead ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnethead ) ) . cstqh_first as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnethead ) , "::" ,
                stringify ! ( cstqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnethead ) ) . cstqh_last as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnethead ) , "::" ,
                stringify ! ( cstqh_last ) ));
}
impl Clone for ifnethead {
    fn clone(&self) -> Self { *self }
}
impl Default for ifnethead {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifaddrhead {
    pub cstqh_first: *mut ifaddr,
    pub cstqh_last: *mut *mut ifaddr,
}
#[test]
fn bindgen_test_layout_ifaddrhead() {
    assert_eq!(::core::mem::size_of::<ifaddrhead>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ifaddrhead ) ));
    assert_eq! (::core::mem::align_of::<ifaddrhead>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ifaddrhead ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaddrhead ) ) . cstqh_first as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaddrhead ) , "::" ,
                stringify ! ( cstqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaddrhead ) ) . cstqh_last as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaddrhead ) , "::" ,
                stringify ! ( cstqh_last ) ));
}
impl Clone for ifaddrhead {
    fn clone(&self) -> Self { *self }
}
impl Default for ifaddrhead {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifmultihead {
    pub cstqh_first: *mut ifmultiaddr,
    pub cstqh_last: *mut *mut ifmultiaddr,
}
#[test]
fn bindgen_test_layout_ifmultihead() {
    assert_eq!(::core::mem::size_of::<ifmultihead>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ifmultihead ) ));
    assert_eq! (::core::mem::align_of::<ifmultihead>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ifmultihead ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmultihead ) ) . cstqh_first as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmultihead ) , "::" ,
                stringify ! ( cstqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmultihead ) ) . cstqh_last as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmultihead ) , "::" ,
                stringify ! ( cstqh_last ) ));
}
impl Clone for ifmultihead {
    fn clone(&self) -> Self { *self }
}
impl Default for ifmultihead {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifgrouphead {
    pub cstqh_first: *mut ifg_group,
    pub cstqh_last: *mut *mut ifg_group,
}
#[test]
fn bindgen_test_layout_ifgrouphead() {
    assert_eq!(::core::mem::size_of::<ifgrouphead>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ifgrouphead ) ));
    assert_eq! (::core::mem::align_of::<ifgrouphead>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ifgrouphead ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifgrouphead ) ) . cstqh_first as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifgrouphead ) , "::" ,
                stringify ! ( cstqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifgrouphead ) ) . cstqh_last as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifgrouphead ) , "::" ,
                stringify ! ( cstqh_last ) ));
}
impl Clone for ifgrouphead {
    fn clone(&self) -> Self { *self }
}
impl Default for ifgrouphead {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pfil_head {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "link_pfil_hook"]
    pub static mut link_pfil_hook: pfil_head;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hhook_head {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "ipsec_hhh_in"]
    pub static mut ipsec_hhh_in: [*mut hhook_head; 2usize];
}
extern "C" {
    #[link_name = "ipsec_hhh_out"]
    pub static mut ipsec_hhh_out: [*mut hhook_head; 2usize];
}
extern "C" {
    #[link_name = "net_epoch_preempt"]
    pub static mut net_epoch_preempt: epoch_t;
}
extern "C" {
    #[link_name = "net_epoch"]
    pub static mut net_epoch: epoch_t;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ift_counter {
    IFCOUNTER_IPACKETS = 0,
    IFCOUNTER_IERRORS = 1,
    IFCOUNTER_OPACKETS = 2,
    IFCOUNTER_OERRORS = 3,
    IFCOUNTER_COLLISIONS = 4,
    IFCOUNTER_IBYTES = 5,
    IFCOUNTER_OBYTES = 6,
    IFCOUNTER_IMCASTS = 7,
    IFCOUNTER_OMCASTS = 8,
    IFCOUNTER_IQDROPS = 9,
    IFCOUNTER_OQDROPS = 10,
    IFCOUNTER_NOPROTO = 11,
    IFCOUNTERS = 12,
}
pub type if_t = *mut ifnet;
pub type if_start_fn_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: if_t)>;
pub type if_ioctl_fn_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: if_t, arg2: u_long,
                                                arg3: caddr_t)
                               -> ::kernel::sys::raw::c_int>;
pub type if_init_fn_t =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void)>;
pub type if_qflush_fn_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: if_t)>;
pub type if_transmit_fn_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: if_t, arg2: *mut mbuf)
                               -> ::kernel::sys::raw::c_int>;
pub type if_get_counter_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: if_t, arg2: ift_counter)
                               -> u64>;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct ifnet_hw_tsomax {
    pub tsomaxbytes: u_int,
    pub tsomaxsegcount: u_int,
    pub tsomaxsegsize: u_int,
}
#[test]
fn bindgen_test_layout_ifnet_hw_tsomax() {
    assert_eq!(::core::mem::size_of::<ifnet_hw_tsomax>() , 12usize , concat !
               ( "Size of: " , stringify ! ( ifnet_hw_tsomax ) ));
    assert_eq! (::core::mem::align_of::<ifnet_hw_tsomax>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( ifnet_hw_tsomax ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet_hw_tsomax ) ) . tsomaxbytes as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet_hw_tsomax ) ,
                "::" , stringify ! ( tsomaxbytes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet_hw_tsomax ) ) . tsomaxsegcount as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet_hw_tsomax ) ,
                "::" , stringify ! ( tsomaxsegcount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet_hw_tsomax ) ) . tsomaxsegsize as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet_hw_tsomax ) ,
                "::" , stringify ! ( tsomaxsegsize ) ));
}
impl Clone for ifnet_hw_tsomax {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ife_type { IFENCAP_LL = 1, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct if_encap_req {
    pub buf: *mut u_char,
    pub bufsize: usize,
    pub rtype: ife_type,
    pub flags: u32,
    pub family: ::kernel::sys::raw::c_int,
    pub lladdr_off: ::kernel::sys::raw::c_int,
    pub lladdr_len: ::kernel::sys::raw::c_int,
    pub lladdr: *mut ::kernel::sys::raw::c_char,
    pub hdata: *mut ::kernel::sys::raw::c_char,
}
#[test]
fn bindgen_test_layout_if_encap_req() {
    assert_eq!(::core::mem::size_of::<if_encap_req>() , 56usize , concat ! (
               "Size of: " , stringify ! ( if_encap_req ) ));
    assert_eq! (::core::mem::align_of::<if_encap_req>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( if_encap_req ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_encap_req ) ) . buf as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_encap_req ) , "::" ,
                stringify ! ( buf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_encap_req ) ) . bufsize as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( if_encap_req ) , "::" ,
                stringify ! ( bufsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_encap_req ) ) . rtype as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( if_encap_req ) , "::" ,
                stringify ! ( rtype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_encap_req ) ) . flags as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( if_encap_req ) , "::" ,
                stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_encap_req ) ) . family as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( if_encap_req ) , "::" ,
                stringify ! ( family ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_encap_req ) ) . lladdr_off as * const
                _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( if_encap_req ) , "::" ,
                stringify ! ( lladdr_off ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_encap_req ) ) . lladdr_len as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( if_encap_req ) , "::" ,
                stringify ! ( lladdr_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_encap_req ) ) . lladdr as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( if_encap_req ) , "::" ,
                stringify ! ( lladdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_encap_req ) ) . hdata as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( if_encap_req ) , "::" ,
                stringify ! ( hdata ) ));
}
impl Clone for if_encap_req {
    fn clone(&self) -> Self { *self }
}
impl Default for if_encap_req {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct if_snd_tag_alloc_header {
    pub type_: u32,
    pub flowid: u32,
    pub flowtype: u32,
}
#[test]
fn bindgen_test_layout_if_snd_tag_alloc_header() {
    assert_eq!(::core::mem::size_of::<if_snd_tag_alloc_header>() , 12usize ,
               concat ! (
               "Size of: " , stringify ! ( if_snd_tag_alloc_header ) ));
    assert_eq! (::core::mem::align_of::<if_snd_tag_alloc_header>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( if_snd_tag_alloc_header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_snd_tag_alloc_header ) ) . type_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_snd_tag_alloc_header
                ) , "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_snd_tag_alloc_header ) ) . flowid as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( if_snd_tag_alloc_header
                ) , "::" , stringify ! ( flowid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_snd_tag_alloc_header ) ) . flowtype as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( if_snd_tag_alloc_header
                ) , "::" , stringify ! ( flowtype ) ));
}
impl Clone for if_snd_tag_alloc_header {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct if_snd_tag_alloc_rate_limit {
    pub hdr: if_snd_tag_alloc_header,
    pub max_rate: u64,
}
#[test]
fn bindgen_test_layout_if_snd_tag_alloc_rate_limit() {
    assert_eq!(::core::mem::size_of::<if_snd_tag_alloc_rate_limit>() , 24usize
               , concat ! (
               "Size of: " , stringify ! ( if_snd_tag_alloc_rate_limit ) ));
    assert_eq! (::core::mem::align_of::<if_snd_tag_alloc_rate_limit>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( if_snd_tag_alloc_rate_limit )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_snd_tag_alloc_rate_limit ) ) . hdr as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                if_snd_tag_alloc_rate_limit ) , "::" , stringify ! ( hdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_snd_tag_alloc_rate_limit ) ) .
                max_rate as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                if_snd_tag_alloc_rate_limit ) , "::" , stringify ! ( max_rate
                ) ));
}
impl Clone for if_snd_tag_alloc_rate_limit {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct if_snd_tag_rate_limit_params {
    pub max_rate: u64,
    pub queue_level: u32,
    pub reserved: u32,
}
#[test]
fn bindgen_test_layout_if_snd_tag_rate_limit_params() {
    assert_eq!(::core::mem::size_of::<if_snd_tag_rate_limit_params>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( if_snd_tag_rate_limit_params ) ));
    assert_eq! (::core::mem::align_of::<if_snd_tag_rate_limit_params>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( if_snd_tag_rate_limit_params )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_snd_tag_rate_limit_params ) ) .
                max_rate as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                if_snd_tag_rate_limit_params ) , "::" , stringify ! ( max_rate
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_snd_tag_rate_limit_params ) ) .
                queue_level as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                if_snd_tag_rate_limit_params ) , "::" , stringify ! (
                queue_level ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_snd_tag_rate_limit_params ) ) .
                reserved as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                if_snd_tag_rate_limit_params ) , "::" , stringify ! ( reserved
                ) ));
}
impl Clone for if_snd_tag_rate_limit_params {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union if_snd_tag_alloc_params {
    pub hdr: if_snd_tag_alloc_header,
    pub rate_limit: if_snd_tag_alloc_rate_limit,
    pub unlimited: if_snd_tag_alloc_rate_limit,
    _bindgen_union_align: [u64; 3usize],
}
#[test]
fn bindgen_test_layout_if_snd_tag_alloc_params() {
    assert_eq!(::core::mem::size_of::<if_snd_tag_alloc_params>() , 24usize ,
               concat ! (
               "Size of: " , stringify ! ( if_snd_tag_alloc_params ) ));
    assert_eq! (::core::mem::align_of::<if_snd_tag_alloc_params>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( if_snd_tag_alloc_params ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_snd_tag_alloc_params ) ) . hdr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_snd_tag_alloc_params
                ) , "::" , stringify ! ( hdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_snd_tag_alloc_params ) ) . rate_limit
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_snd_tag_alloc_params
                ) , "::" , stringify ! ( rate_limit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_snd_tag_alloc_params ) ) . unlimited
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_snd_tag_alloc_params
                ) , "::" , stringify ! ( unlimited ) ));
}
impl Clone for if_snd_tag_alloc_params {
    fn clone(&self) -> Self { *self }
}
impl Default for if_snd_tag_alloc_params {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for if_snd_tag_alloc_params {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "if_snd_tag_alloc_params {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy)]
pub union if_snd_tag_modify_params {
    pub rate_limit: if_snd_tag_rate_limit_params,
    pub unlimited: if_snd_tag_rate_limit_params,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_if_snd_tag_modify_params() {
    assert_eq!(::core::mem::size_of::<if_snd_tag_modify_params>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( if_snd_tag_modify_params ) ));
    assert_eq! (::core::mem::align_of::<if_snd_tag_modify_params>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( if_snd_tag_modify_params ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_snd_tag_modify_params ) ) . rate_limit
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                if_snd_tag_modify_params ) , "::" , stringify ! ( rate_limit )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_snd_tag_modify_params ) ) . unlimited
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                if_snd_tag_modify_params ) , "::" , stringify ! ( unlimited )
                ));
}
impl Clone for if_snd_tag_modify_params {
    fn clone(&self) -> Self { *self }
}
impl Default for if_snd_tag_modify_params {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for if_snd_tag_modify_params {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "if_snd_tag_modify_params {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy)]
pub union if_snd_tag_query_params {
    pub rate_limit: if_snd_tag_rate_limit_params,
    pub unlimited: if_snd_tag_rate_limit_params,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_if_snd_tag_query_params() {
    assert_eq!(::core::mem::size_of::<if_snd_tag_query_params>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( if_snd_tag_query_params ) ));
    assert_eq! (::core::mem::align_of::<if_snd_tag_query_params>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( if_snd_tag_query_params ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_snd_tag_query_params ) ) . rate_limit
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_snd_tag_query_params
                ) , "::" , stringify ! ( rate_limit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_snd_tag_query_params ) ) . unlimited
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_snd_tag_query_params
                ) , "::" , stringify ! ( unlimited ) ));
}
impl Clone for if_snd_tag_query_params {
    fn clone(&self) -> Self { *self }
}
impl Default for if_snd_tag_query_params {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for if_snd_tag_query_params {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "if_snd_tag_query_params {{ union }}")
    }
}
pub type if_snd_tag_alloc_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ifnet,
                                                arg2:
                                                    *mut if_snd_tag_alloc_params,
                                                arg3: *mut *mut m_snd_tag)
                               -> ::kernel::sys::raw::c_int>;
pub type if_snd_tag_modify_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut m_snd_tag,
                                                arg2:
                                                    *mut if_snd_tag_modify_params)
                               -> ::kernel::sys::raw::c_int>;
pub type if_snd_tag_query_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut m_snd_tag,
                                                arg2:
                                                    *mut if_snd_tag_query_params)
                               -> ::kernel::sys::raw::c_int>;
pub type if_snd_tag_free_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut m_snd_tag)>;
#[repr(C)]
#[derive(Copy)]
pub struct ifnet {
    pub if_link: ifnet__bindgen_ty_1,
    pub if_clones: ifnet__bindgen_ty_2,
    pub if_groups: ifnet__bindgen_ty_3,
    pub if_alloctype: u_char,
    pub if_softc: *mut ::kernel::sys::raw::c_void,
    pub if_llsoftc: *mut ::kernel::sys::raw::c_void,
    pub if_l2com: *mut ::kernel::sys::raw::c_void,
    pub if_dname: *const ::kernel::sys::raw::c_char,
    pub if_dunit: ::kernel::sys::raw::c_int,
    pub if_index: u_short,
    pub if_index_reserved: ::kernel::sys::raw::c_short,
    pub if_xname: [::kernel::sys::raw::c_char; 16usize],
    pub if_description: *mut ::kernel::sys::raw::c_char,
    pub if_flags: ::kernel::sys::raw::c_int,
    pub if_drv_flags: ::kernel::sys::raw::c_int,
    pub if_capabilities: ::kernel::sys::raw::c_int,
    pub if_capenable: ::kernel::sys::raw::c_int,
    pub if_linkmib: *mut ::kernel::sys::raw::c_void,
    pub if_linkmiblen: usize,
    pub if_refcount: u_int,
    pub if_type: u8,
    pub if_addrlen: u8,
    pub if_hdrlen: u8,
    pub if_link_state: u8,
    pub if_mtu: u32,
    pub if_metric: u32,
    pub if_baudrate: u64,
    pub if_hwassist: u64,
    pub if_epoch: time_t,
    pub if_lastchange: timeval,
    pub if_snd: ifaltq,
    pub if_linktask: task,
    pub if_addr_lock: mtx,
    pub if_addrhead: ifaddrhead,
    pub if_multiaddrs: ifmultihead,
    pub if_amcount: ::kernel::sys::raw::c_int,
    pub if_addr: *mut ifaddr,
    pub if_hw_addr: *mut ::kernel::sys::raw::c_void,
    pub if_broadcastaddr: *const u_int8_t,
    pub if_afdata_lock: mtx,
    pub if_afdata: [*mut ::kernel::sys::raw::c_void; 42usize],
    pub if_afdata_initialized: ::kernel::sys::raw::c_int,
    pub if_fib: u_int,
    pub if_vnet: *mut vnet,
    pub if_home_vnet: *mut vnet,
    pub if_vlantrunk: *mut ifvlantrunk,
    pub if_bpf: *mut bpf_if,
    pub if_pcount: ::kernel::sys::raw::c_int,
    pub if_bridge: *mut ::kernel::sys::raw::c_void,
    pub if_lagg: *mut ::kernel::sys::raw::c_void,
    pub if_pf_kif: *mut ::kernel::sys::raw::c_void,
    pub if_carp: *mut carp_if,
    pub if_label: *mut label,
    pub if_netmap: *mut netmap_adapter,
    pub if_output: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                   *mut ifnet,
                                                               arg2:
                                                                   *mut mbuf,
                                                               arg3:
                                                                   *const sockaddr,
                                                               arg4:
                                                                   *mut route)
                                              -> ::kernel::sys::raw::c_int>,
    pub if_input: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                  *mut ifnet,
                                                              arg2:
                                                                  *mut mbuf)>,
    pub if_bridge_input: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                         *mut ifnet,
                                                                     arg2:
                                                                         *mut mbuf)
                                                    -> *mut mbuf>,
    pub if_bridge_output: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                          *mut ifnet,
                                                                      arg2:
                                                                          *mut mbuf,
                                                                      arg3:
                                                                          *mut sockaddr,
                                                                      arg4:
                                                                          *mut rtentry)
                                                     ->
                                                         ::kernel::sys::raw::c_int>,
    pub if_bridge_linkstate: ::core::option::Option<unsafe extern "C" fn(ifp:
                                                                             *mut ifnet)>,
    pub if_start: if_start_fn_t,
    pub if_ioctl: if_ioctl_fn_t,
    pub if_init: if_init_fn_t,
    pub if_resolvemulti: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                         *mut ifnet,
                                                                     arg2:
                                                                         *mut *mut sockaddr,
                                                                     arg3:
                                                                         *mut sockaddr)
                                                    ->
                                                        ::kernel::sys::raw::c_int>,
    pub if_qflush: if_qflush_fn_t,
    pub if_transmit: if_transmit_fn_t,
    pub if_reassign: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                     *mut ifnet,
                                                                 arg2:
                                                                     *mut vnet,
                                                                 arg3:
                                                                     *mut ::kernel::sys::raw::c_char)>,
    pub if_get_counter: if_get_counter_t,
    pub if_requestencap: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                         *mut ifnet,
                                                                     arg2:
                                                                         *mut if_encap_req)
                                                    ->
                                                        ::kernel::sys::raw::c_int>,
    pub if_counters: [counter_u64_t; 12usize],
    pub if_hw_tsomax: u_int,
    pub if_hw_tsomaxsegcount: u_int,
    pub if_hw_tsomaxsegsize: u_int,
    pub if_snd_tag_alloc: if_snd_tag_alloc_t,
    pub if_snd_tag_modify: if_snd_tag_modify_t,
    pub if_snd_tag_query: if_snd_tag_query_t,
    pub if_snd_tag_free: if_snd_tag_free_t,
    pub if_pcp: u8,
    pub if_netdump_methods: *mut netdump_methods,
    pub if_epoch_ctx: epoch_context,
    pub if_ispare: [::kernel::sys::raw::c_int; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifnet__bindgen_ty_1 {
    pub cstqe_next: *mut ifnet,
}
#[test]
fn bindgen_test_layout_ifnet__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<ifnet__bindgen_ty_1>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( ifnet__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<ifnet__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( ifnet__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet__bindgen_ty_1 ) ) . cstqe_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet__bindgen_ty_1 ) ,
                "::" , stringify ! ( cstqe_next ) ));
}
impl Clone for ifnet__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for ifnet__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifnet__bindgen_ty_2 {
    pub le_next: *mut ifnet,
    pub le_prev: *mut *mut ifnet,
}
#[test]
fn bindgen_test_layout_ifnet__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<ifnet__bindgen_ty_2>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( ifnet__bindgen_ty_2 )
               ));
    assert_eq! (::core::mem::align_of::<ifnet__bindgen_ty_2>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( ifnet__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet__bindgen_ty_2 ) ) . le_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet__bindgen_ty_2 ) ,
                "::" , stringify ! ( le_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet__bindgen_ty_2 ) ) . le_prev as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet__bindgen_ty_2 ) ,
                "::" , stringify ! ( le_prev ) ));
}
impl Clone for ifnet__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for ifnet__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifnet__bindgen_ty_3 {
    pub cstqh_first: *mut ifg_list,
    pub cstqh_last: *mut *mut ifg_list,
}
#[test]
fn bindgen_test_layout_ifnet__bindgen_ty_3() {
    assert_eq!(::core::mem::size_of::<ifnet__bindgen_ty_3>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( ifnet__bindgen_ty_3 )
               ));
    assert_eq! (::core::mem::align_of::<ifnet__bindgen_ty_3>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( ifnet__bindgen_ty_3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet__bindgen_ty_3 ) ) . cstqh_first as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet__bindgen_ty_3 ) ,
                "::" , stringify ! ( cstqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet__bindgen_ty_3 ) ) . cstqh_last as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet__bindgen_ty_3 ) ,
                "::" , stringify ! ( cstqh_last ) ));
}
impl Clone for ifnet__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
impl Default for ifnet__bindgen_ty_3 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_ifnet() {
    assert_eq!(::core::mem::size_of::<ifnet>() , 1256usize , concat ! (
               "Size of: " , stringify ! ( ifnet ) ));
    assert_eq! (::core::mem::align_of::<ifnet>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ifnet ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_link as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_link ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_clones as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_clones ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_groups as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_groups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_alloctype as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_alloctype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_softc as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_softc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_llsoftc as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_llsoftc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_l2com as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_l2com ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_dname as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_dname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_dunit as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_dunit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_index as * const _ as
                usize } , 84usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_index_reserved as * const
                _ as usize } , 86usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_index_reserved ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_xname as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_xname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_description as * const _
                as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_description ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_flags as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_drv_flags as * const _ as
                usize } , 116usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_drv_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_capabilities as * const _
                as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_capabilities ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_capenable as * const _ as
                usize } , 124usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_capenable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_linkmib as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_linkmib ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_linkmiblen as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_linkmiblen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_refcount as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_refcount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_type as * const _ as usize
                } , 148usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_addrlen as * const _ as
                usize } , 149usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_addrlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_hdrlen as * const _ as
                usize } , 150usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_hdrlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_link_state as * const _ as
                usize } , 151usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_link_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_mtu as * const _ as usize
                } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_mtu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_metric as * const _ as
                usize } , 156usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_metric ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_baudrate as * const _ as
                usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_baudrate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_hwassist as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_hwassist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_epoch as * const _ as
                usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_epoch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_lastchange as * const _ as
                usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_lastchange ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_snd as * const _ as usize
                } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_snd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_linktask as * const _ as
                usize } , 360usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_linktask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_addr_lock as * const _ as
                usize } , 392usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_addr_lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_addrhead as * const _ as
                usize } , 424usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_addrhead ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_multiaddrs as * const _ as
                usize } , 440usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_multiaddrs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_amcount as * const _ as
                usize } , 456usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_amcount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_addr as * const _ as usize
                } , 464usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_hw_addr as * const _ as
                usize } , 472usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_hw_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_broadcastaddr as * const _
                as usize } , 480usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_broadcastaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_afdata_lock as * const _
                as usize } , 488usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_afdata_lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_afdata as * const _ as
                usize } , 520usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_afdata ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_afdata_initialized as *
                const _ as usize } , 856usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_afdata_initialized ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_fib as * const _ as usize
                } , 860usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_fib ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_vnet as * const _ as usize
                } , 864usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_vnet ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_home_vnet as * const _ as
                usize } , 872usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_home_vnet ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_vlantrunk as * const _ as
                usize } , 880usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_vlantrunk ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_bpf as * const _ as usize
                } , 888usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_bpf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_pcount as * const _ as
                usize } , 896usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_pcount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_bridge as * const _ as
                usize } , 904usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_bridge ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_lagg as * const _ as usize
                } , 912usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_lagg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_pf_kif as * const _ as
                usize } , 920usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_pf_kif ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_carp as * const _ as usize
                } , 928usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_carp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_label as * const _ as
                usize } , 936usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_label ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_netmap as * const _ as
                usize } , 944usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_netmap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_output as * const _ as
                usize } , 952usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_output ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_input as * const _ as
                usize } , 960usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_input ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_bridge_input as * const _
                as usize } , 968usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_bridge_input ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_bridge_output as * const _
                as usize } , 976usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_bridge_output ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_bridge_linkstate as *
                const _ as usize } , 984usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_bridge_linkstate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_start as * const _ as
                usize } , 992usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_start ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_ioctl as * const _ as
                usize } , 1000usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_ioctl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_init as * const _ as usize
                } , 1008usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_init ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_resolvemulti as * const _
                as usize } , 1016usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_resolvemulti ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_qflush as * const _ as
                usize } , 1024usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_qflush ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_transmit as * const _ as
                usize } , 1032usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_transmit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_reassign as * const _ as
                usize } , 1040usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_reassign ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_get_counter as * const _
                as usize } , 1048usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_get_counter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_requestencap as * const _
                as usize } , 1056usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_requestencap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_counters as * const _ as
                usize } , 1064usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_counters ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_hw_tsomax as * const _ as
                usize } , 1160usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_hw_tsomax ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_hw_tsomaxsegcount as *
                const _ as usize } , 1164usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_hw_tsomaxsegcount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_hw_tsomaxsegsize as *
                const _ as usize } , 1168usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_hw_tsomaxsegsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_snd_tag_alloc as * const _
                as usize } , 1176usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_snd_tag_alloc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_snd_tag_modify as * const
                _ as usize } , 1184usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_snd_tag_modify ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_snd_tag_query as * const _
                as usize } , 1192usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_snd_tag_query ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_snd_tag_free as * const _
                as usize } , 1200usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_snd_tag_free ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_pcp as * const _ as usize
                } , 1208usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_pcp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_netdump_methods as * const
                _ as usize } , 1216usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_netdump_methods ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_epoch_ctx as * const _ as
                usize } , 1224usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_epoch_ctx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_ispare as * const _ as
                usize } , 1240usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_ispare ) ));
}
impl Clone for ifnet {
    fn clone(&self) -> Self { *self }
}
impl Default for ifnet {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for ifnet {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "ifnet {{ if_link: {:?}, if_clones: {:?}, if_groups: {:?}, if_alloctype: {:?}, if_softc: {:?}, if_llsoftc: {:?}, if_l2com: {:?}, if_dname: {:?}, if_dunit: {:?}, if_index: {:?}, if_index_reserved: {:?}, if_xname: {:?}, if_description: {:?}, if_flags: {:?}, if_drv_flags: {:?}, if_capabilities: {:?}, if_capenable: {:?}, if_linkmib: {:?}, if_linkmiblen: {:?}, if_refcount: {:?}, if_type: {:?}, if_addrlen: {:?}, if_hdrlen: {:?}, if_link_state: {:?}, if_mtu: {:?}, if_metric: {:?}, if_baudrate: {:?}, if_hwassist: {:?}, if_epoch: {:?}, if_lastchange: {:?}, if_snd: {:?}, if_linktask: {:?}, if_addr_lock: {:?}, if_addrhead: {:?}, if_multiaddrs: {:?}, if_amcount: {:?}, if_addr: {:?}, if_hw_addr: {:?}, if_broadcastaddr: {:?}, if_afdata_lock: {:?}, if_afdata: [{}], if_afdata_initialized: {:?}, if_fib: {:?}, if_vnet: {:?}, if_home_vnet: {:?}, if_vlantrunk: {:?}, if_bpf: {:?}, if_pcount: {:?}, if_bridge: {:?}, if_lagg: {:?}, if_pf_kif: {:?}, if_carp: {:?}, if_label: {:?}, if_netmap: {:?}, if_output: {:?}, if_input: {:?}, if_bridge_input: {:?}, if_bridge_output: {:?}, if_bridge_linkstate: {:?}, if_start: {:?}, if_ioctl: {:?}, if_init: {:?}, if_resolvemulti: {:?}, if_qflush: {:?}, if_transmit: {:?}, if_reassign: {:?}, if_get_counter: {:?}, if_requestencap: {:?}, if_counters: {:?}, if_hw_tsomax: {:?}, if_hw_tsomaxsegcount: {:?}, if_hw_tsomaxsegsize: {:?}, if_snd_tag_alloc: {:?}, if_snd_tag_modify: {:?}, if_snd_tag_query: {:?}, if_snd_tag_free: {:?}, if_pcp: {:?}, if_netdump_methods: {:?}, if_epoch_ctx: {:?}, if_ispare: {:?} }}"
               , self . if_link , self . if_clones , self . if_groups , self .
               if_alloctype , self . if_softc , self . if_llsoftc , self .
               if_l2com , self . if_dname , self . if_dunit , self . if_index
               , self . if_index_reserved , self . if_xname , self .
               if_description , self . if_flags , self . if_drv_flags , self .
               if_capabilities , self . if_capenable , self . if_linkmib ,
               self . if_linkmiblen , self . if_refcount , self . if_type ,
               self . if_addrlen , self . if_hdrlen , self . if_link_state ,
               self . if_mtu , self . if_metric , self . if_baudrate , self .
               if_hwassist , self . if_epoch , self . if_lastchange , self .
               if_snd , self . if_linktask , self . if_addr_lock , self .
               if_addrhead , self . if_multiaddrs , self . if_amcount , self .
               if_addr , self . if_hw_addr , self . if_broadcastaddr , self .
               if_afdata_lock , self . if_afdata . iter (  ) . enumerate (  )
               . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ) , self . if_afdata_initialized , self . if_fib ,
               self . if_vnet , self . if_home_vnet , self . if_vlantrunk ,
               self . if_bpf , self . if_pcount , self . if_bridge , self .
               if_lagg , self . if_pf_kif , self . if_carp , self . if_label ,
               self . if_netmap , self . if_output , self . if_input , self .
               if_bridge_input , self . if_bridge_output , self .
               if_bridge_linkstate , self . if_start , self . if_ioctl , self
               . if_init , self . if_resolvemulti , self . if_qflush , self .
               if_transmit , self . if_reassign , self . if_get_counter , self
               . if_requestencap , self . if_counters , self . if_hw_tsomax ,
               self . if_hw_tsomaxsegcount , self . if_hw_tsomaxsegsize , self
               . if_snd_tag_alloc , self . if_snd_tag_modify , self .
               if_snd_tag_query , self . if_snd_tag_free , self . if_pcp ,
               self . if_netdump_methods , self . if_epoch_ctx , self .
               if_ispare)
    }
}
extern "C" {
    pub fn if_addr_rlock(ifp: *mut ifnet);
}
extern "C" {
    pub fn if_addr_runlock(ifp: *mut ifnet);
}
extern "C" {
    pub fn if_maddr_rlock(ifp: if_t);
}
extern "C" {
    pub fn if_maddr_runlock(ifp: if_t);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifg_group {
    pub ifg_group: [::kernel::sys::raw::c_char; 16usize],
    pub ifg_refcnt: u_int,
    pub ifg_pf_kif: *mut ::kernel::sys::raw::c_void,
    pub ifg_members: ifg_group__bindgen_ty_1,
    pub ifg_next: ifg_group__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifg_group__bindgen_ty_1 {
    pub cstqh_first: *mut ifg_member,
    pub cstqh_last: *mut *mut ifg_member,
}
#[test]
fn bindgen_test_layout_ifg_group__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<ifg_group__bindgen_ty_1>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( ifg_group__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<ifg_group__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( ifg_group__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifg_group__bindgen_ty_1 ) ) . cstqh_first
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifg_group__bindgen_ty_1
                ) , "::" , stringify ! ( cstqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifg_group__bindgen_ty_1 ) ) . cstqh_last
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifg_group__bindgen_ty_1
                ) , "::" , stringify ! ( cstqh_last ) ));
}
impl Clone for ifg_group__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for ifg_group__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifg_group__bindgen_ty_2 {
    pub cstqe_next: *mut ifg_group,
}
#[test]
fn bindgen_test_layout_ifg_group__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<ifg_group__bindgen_ty_2>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( ifg_group__bindgen_ty_2 ) ));
    assert_eq! (::core::mem::align_of::<ifg_group__bindgen_ty_2>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( ifg_group__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifg_group__bindgen_ty_2 ) ) . cstqe_next
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifg_group__bindgen_ty_2
                ) , "::" , stringify ! ( cstqe_next ) ));
}
impl Clone for ifg_group__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for ifg_group__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_ifg_group() {
    assert_eq!(::core::mem::size_of::<ifg_group>() , 56usize , concat ! (
               "Size of: " , stringify ! ( ifg_group ) ));
    assert_eq! (::core::mem::align_of::<ifg_group>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ifg_group ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifg_group ) ) . ifg_group as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifg_group ) , "::" ,
                stringify ! ( ifg_group ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifg_group ) ) . ifg_refcnt as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ifg_group ) , "::" ,
                stringify ! ( ifg_refcnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifg_group ) ) . ifg_pf_kif as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ifg_group ) , "::" ,
                stringify ! ( ifg_pf_kif ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifg_group ) ) . ifg_members as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( ifg_group ) , "::" ,
                stringify ! ( ifg_members ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifg_group ) ) . ifg_next as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( ifg_group ) , "::" ,
                stringify ! ( ifg_next ) ));
}
impl Clone for ifg_group {
    fn clone(&self) -> Self { *self }
}
impl Default for ifg_group {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifg_member {
    pub ifgm_next: ifg_member__bindgen_ty_1,
    pub ifgm_ifp: *mut ifnet,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifg_member__bindgen_ty_1 {
    pub cstqe_next: *mut ifg_member,
}
#[test]
fn bindgen_test_layout_ifg_member__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<ifg_member__bindgen_ty_1>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( ifg_member__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<ifg_member__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( ifg_member__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifg_member__bindgen_ty_1 ) ) . cstqe_next
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                ifg_member__bindgen_ty_1 ) , "::" , stringify ! ( cstqe_next )
                ));
}
impl Clone for ifg_member__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for ifg_member__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_ifg_member() {
    assert_eq!(::core::mem::size_of::<ifg_member>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ifg_member ) ));
    assert_eq! (::core::mem::align_of::<ifg_member>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ifg_member ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifg_member ) ) . ifgm_next as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifg_member ) , "::" ,
                stringify ! ( ifgm_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifg_member ) ) . ifgm_ifp as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifg_member ) , "::" ,
                stringify ! ( ifgm_ifp ) ));
}
impl Clone for ifg_member {
    fn clone(&self) -> Self { *self }
}
impl Default for ifg_member {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifg_list {
    pub ifgl_group: *mut ifg_group,
    pub ifgl_next: ifg_list__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifg_list__bindgen_ty_1 {
    pub cstqe_next: *mut ifg_list,
}
#[test]
fn bindgen_test_layout_ifg_list__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<ifg_list__bindgen_ty_1>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( ifg_list__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<ifg_list__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( ifg_list__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifg_list__bindgen_ty_1 ) ) . cstqe_next
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifg_list__bindgen_ty_1
                ) , "::" , stringify ! ( cstqe_next ) ));
}
impl Clone for ifg_list__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for ifg_list__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_ifg_list() {
    assert_eq!(::core::mem::size_of::<ifg_list>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ifg_list ) ));
    assert_eq! (::core::mem::align_of::<ifg_list>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ifg_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifg_list ) ) . ifgl_group as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifg_list ) , "::" ,
                stringify ! ( ifgl_group ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifg_list ) ) . ifgl_next as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifg_list ) , "::" ,
                stringify ! ( ifgl_next ) ));
}
impl Clone for ifg_list {
    fn clone(&self) -> Self { *self }
}
impl Default for ifg_list {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifaddr {
    pub ifa_addr: *mut sockaddr,
    pub ifa_dstaddr: *mut sockaddr,
    pub ifa_netmask: *mut sockaddr,
    pub ifa_ifp: *mut ifnet,
    pub ifa_carp: *mut carp_softc,
    pub ifa_link: ifaddr__bindgen_ty_1,
    pub ifa_rtrequest: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                       ::kernel::sys::raw::c_int,
                                                                   arg2:
                                                                       *mut rtentry,
                                                                   arg3:
                                                                       *mut rt_addrinfo)>,
    pub ifa_flags: u_short,
    pub ifa_refcnt: u_int,
    pub ifa_ipackets: counter_u64_t,
    pub ifa_opackets: counter_u64_t,
    pub ifa_ibytes: counter_u64_t,
    pub ifa_obytes: counter_u64_t,
    pub ifa_epoch_ctx: epoch_context,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifaddr__bindgen_ty_1 {
    pub cstqe_next: *mut ifaddr,
}
#[test]
fn bindgen_test_layout_ifaddr__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<ifaddr__bindgen_ty_1>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( ifaddr__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<ifaddr__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( ifaddr__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaddr__bindgen_ty_1 ) ) . cstqe_next as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaddr__bindgen_ty_1 )
                , "::" , stringify ! ( cstqe_next ) ));
}
impl Clone for ifaddr__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for ifaddr__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_ifaddr() {
    assert_eq!(::core::mem::size_of::<ifaddr>() , 112usize , concat ! (
               "Size of: " , stringify ! ( ifaddr ) ));
    assert_eq! (::core::mem::align_of::<ifaddr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ifaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaddr ) ) . ifa_addr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaddr ) , "::" ,
                stringify ! ( ifa_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaddr ) ) . ifa_dstaddr as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaddr ) , "::" ,
                stringify ! ( ifa_dstaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaddr ) ) . ifa_netmask as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaddr ) , "::" ,
                stringify ! ( ifa_netmask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaddr ) ) . ifa_ifp as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaddr ) , "::" ,
                stringify ! ( ifa_ifp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaddr ) ) . ifa_carp as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaddr ) , "::" ,
                stringify ! ( ifa_carp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaddr ) ) . ifa_link as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaddr ) , "::" ,
                stringify ! ( ifa_link ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaddr ) ) . ifa_rtrequest as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaddr ) , "::" ,
                stringify ! ( ifa_rtrequest ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaddr ) ) . ifa_flags as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaddr ) , "::" ,
                stringify ! ( ifa_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaddr ) ) . ifa_refcnt as * const _ as
                usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaddr ) , "::" ,
                stringify ! ( ifa_refcnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaddr ) ) . ifa_ipackets as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaddr ) , "::" ,
                stringify ! ( ifa_ipackets ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaddr ) ) . ifa_opackets as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaddr ) , "::" ,
                stringify ! ( ifa_opackets ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaddr ) ) . ifa_ibytes as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaddr ) , "::" ,
                stringify ! ( ifa_ibytes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaddr ) ) . ifa_obytes as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaddr ) , "::" ,
                stringify ! ( ifa_obytes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaddr ) ) . ifa_epoch_ctx as * const _
                as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaddr ) , "::" ,
                stringify ! ( ifa_epoch_ctx ) ));
}
impl Clone for ifaddr {
    fn clone(&self) -> Self { *self }
}
impl Default for ifaddr {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    pub fn ifa_alloc(size: usize, flags: ::kernel::sys::raw::c_int)
     -> *mut ifaddr;
}
extern "C" {
    pub fn ifa_free(ifa: *mut ifaddr);
}
extern "C" {
    pub fn ifa_ref(ifa: *mut ifaddr);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifmultiaddr {
    pub ifma_link: ifmultiaddr__bindgen_ty_1,
    pub ifma_addr: *mut sockaddr,
    pub ifma_lladdr: *mut sockaddr,
    pub ifma_ifp: *mut ifnet,
    pub ifma_refcount: u_int,
    pub ifma_protospec: *mut ::kernel::sys::raw::c_void,
    pub ifma_llifma: *mut ifmultiaddr,
    pub ifma_epoch_ctx: epoch_context,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifmultiaddr__bindgen_ty_1 {
    pub cstqe_next: *mut ifmultiaddr,
}
#[test]
fn bindgen_test_layout_ifmultiaddr__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<ifmultiaddr__bindgen_ty_1>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( ifmultiaddr__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<ifmultiaddr__bindgen_ty_1>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( ifmultiaddr__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmultiaddr__bindgen_ty_1 ) ) .
                cstqe_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                ifmultiaddr__bindgen_ty_1 ) , "::" , stringify ! ( cstqe_next
                ) ));
}
impl Clone for ifmultiaddr__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for ifmultiaddr__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_ifmultiaddr() {
    assert_eq!(::core::mem::size_of::<ifmultiaddr>() , 72usize , concat ! (
               "Size of: " , stringify ! ( ifmultiaddr ) ));
    assert_eq! (::core::mem::align_of::<ifmultiaddr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ifmultiaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmultiaddr ) ) . ifma_link as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmultiaddr ) , "::" ,
                stringify ! ( ifma_link ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmultiaddr ) ) . ifma_addr as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmultiaddr ) , "::" ,
                stringify ! ( ifma_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmultiaddr ) ) . ifma_lladdr as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmultiaddr ) , "::" ,
                stringify ! ( ifma_lladdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmultiaddr ) ) . ifma_ifp as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmultiaddr ) , "::" ,
                stringify ! ( ifma_ifp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmultiaddr ) ) . ifma_refcount as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmultiaddr ) , "::" ,
                stringify ! ( ifma_refcount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmultiaddr ) ) . ifma_protospec as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmultiaddr ) , "::" ,
                stringify ! ( ifma_protospec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmultiaddr ) ) . ifma_llifma as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmultiaddr ) , "::" ,
                stringify ! ( ifma_llifma ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmultiaddr ) ) . ifma_epoch_ctx as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmultiaddr ) , "::" ,
                stringify ! ( ifma_epoch_ctx ) ));
}
impl Clone for ifmultiaddr {
    fn clone(&self) -> Self { *self }
}
impl Default for ifmultiaddr {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    #[link_name = "ifnet_rwlock"]
    pub static mut ifnet_rwlock: rwlock;
}
extern "C" {
    #[link_name = "ifnet_sxlock"]
    pub static mut ifnet_sxlock: sx;
}
extern "C" {
    pub fn ifnet_byindex(idx: u_short) -> *mut ifnet;
}
extern "C" {
    pub fn ifnet_byindex_locked(idx: u_short) -> *mut ifnet;
}
extern "C" {
    pub fn ifnet_byindex_ref(idx: u_short) -> *mut ifnet;
}
extern "C" {
    pub fn ifaddr_byindex(idx: u_short) -> *mut ifaddr;
}
extern "C" {
    #[link_name = "ifnet"]
    pub static mut ifnet: ifnethead;
}
extern "C" {
    #[link_name = "ifg_head"]
    pub static mut ifg_head: ifgrouphead;
}
extern "C" {
    #[link_name = "if_index"]
    pub static mut if_index: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "loif"]
    pub static mut loif: *mut ifnet;
}
extern "C" {
    pub fn if_addgroup(arg1: *mut ifnet,
                       arg2: *const ::kernel::sys::raw::c_char)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_delgroup(arg1: *mut ifnet,
                       arg2: *const ::kernel::sys::raw::c_char)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_addmulti(arg1: *mut ifnet, arg2: *mut sockaddr,
                       arg3: *mut *mut ifmultiaddr)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_allmulti(arg1: *mut ifnet, arg2: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_alloc(arg1: u_char) -> *mut ifnet;
}
extern "C" {
    pub fn if_attach(arg1: *mut ifnet);
}
extern "C" {
    pub fn if_dead(arg1: *mut ifnet);
}
extern "C" {
    pub fn if_delmulti(arg1: *mut ifnet, arg2: *mut sockaddr)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_delmulti_ifma(arg1: *mut ifmultiaddr);
}
extern "C" {
    pub fn if_delmulti_ifma_flags(arg1: *mut ifmultiaddr,
                                  flags: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn if_detach(arg1: *mut ifnet);
}
extern "C" {
    pub fn if_purgeaddrs(arg1: *mut ifnet);
}
extern "C" {
    pub fn if_delallmulti(arg1: *mut ifnet);
}
extern "C" {
    pub fn if_down(arg1: *mut ifnet);
}
extern "C" {
    pub fn if_findmulti(arg1: *mut ifnet, arg2: *const sockaddr)
     -> *mut ifmultiaddr;
}
extern "C" {
    pub fn if_freemulti(ifma: *mut ifmultiaddr);
}
extern "C" {
    pub fn if_free(arg1: *mut ifnet);
}
extern "C" {
    pub fn if_initname(arg1: *mut ifnet,
                       arg2: *const ::kernel::sys::raw::c_char,
                       arg3: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn if_link_state_change(arg1: *mut ifnet,
                                arg2: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn if_printf(arg1: *mut ifnet,
                     arg2: *const ::kernel::sys::raw::c_char, ...)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_ref(arg1: *mut ifnet);
}
extern "C" {
    pub fn if_rele(arg1: *mut ifnet);
}
extern "C" {
    pub fn if_setlladdr(arg1: *mut ifnet, arg2: *const u_char,
                        arg3: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_up(arg1: *mut ifnet);
}
extern "C" {
    pub fn ifioctl(arg1: *mut socket, arg2: u_long, arg3: caddr_t,
                   arg4: *mut thread) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn ifpromisc(arg1: *mut ifnet, arg2: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn ifunit(arg1: *const ::kernel::sys::raw::c_char) -> *mut ifnet;
}
extern "C" {
    pub fn ifunit_ref(arg1: *const ::kernel::sys::raw::c_char) -> *mut ifnet;
}
extern "C" {
    pub fn ifa_add_loopback_route(arg1: *mut ifaddr, arg2: *mut sockaddr)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn ifa_del_loopback_route(arg1: *mut ifaddr, arg2: *mut sockaddr)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn ifa_switch_loopback_route(arg1: *mut ifaddr, arg2: *mut sockaddr)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn ifa_ifwithaddr(arg1: *const sockaddr) -> *mut ifaddr;
}
extern "C" {
    pub fn ifa_ifwithaddr_check(arg1: *const sockaddr)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn ifa_ifwithbroadaddr(arg1: *const sockaddr,
                               arg2: ::kernel::sys::raw::c_int)
     -> *mut ifaddr;
}
extern "C" {
    pub fn ifa_ifwithdstaddr(arg1: *const sockaddr,
                             arg2: ::kernel::sys::raw::c_int) -> *mut ifaddr;
}
extern "C" {
    pub fn ifa_ifwithnet(arg1: *const sockaddr,
                         arg2: ::kernel::sys::raw::c_int,
                         arg3: ::kernel::sys::raw::c_int) -> *mut ifaddr;
}
extern "C" {
    pub fn ifa_ifwithroute(arg1: ::kernel::sys::raw::c_int,
                           arg2: *const sockaddr, arg3: *mut sockaddr,
                           arg4: u_int) -> *mut ifaddr;
}
extern "C" {
    pub fn ifaof_ifpforaddr(arg1: *const sockaddr, arg2: *mut ifnet)
     -> *mut ifaddr;
}
extern "C" {
    pub fn ifa_preferred(arg1: *mut ifaddr, arg2: *mut ifaddr)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_simloop(ifp: *mut ifnet, m: *mut mbuf,
                      af: ::kernel::sys::raw::c_int,
                      hlen: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
pub type if_com_alloc_t =
    ::core::option::Option<unsafe extern "C" fn(type_: u_char,
                                                ifp: *mut ifnet)
                               -> *mut ::kernel::sys::raw::c_void>;
pub type if_com_free_t =
    ::core::option::Option<unsafe extern "C" fn(com:
                                                    *mut ::kernel::sys::raw::c_void,
                                                type_: u_char)>;
extern "C" {
    pub fn if_register_com_alloc(type_: u_char, a: if_com_alloc_t,
                                 f: if_com_free_t);
}
extern "C" {
    pub fn if_deregister_com_alloc(type_: u_char);
}
extern "C" {
    pub fn if_data_copy(arg1: *mut ifnet, arg2: *mut if_data);
}
extern "C" {
    pub fn if_get_counter_default(arg1: *mut ifnet, arg2: ift_counter) -> u64;
}
extern "C" {
    pub fn if_inc_counter(arg1: *mut ifnet, arg2: ift_counter, arg3: i64);
}
extern "C" {
    pub fn if_setbaudrate(ifp: if_t, baudrate: u64) -> u64;
}
extern "C" {
    pub fn if_getbaudrate(ifp: if_t) -> u64;
}
extern "C" {
    pub fn if_setcapabilities(ifp: if_t,
                              capabilities: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_setcapabilitiesbit(ifp: if_t, setbit: ::kernel::sys::raw::c_int,
                                 clearbit: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_getcapabilities(ifp: if_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_togglecapenable(ifp: if_t, togglecap: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_setcapenable(ifp: if_t, capenable: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_setcapenablebit(ifp: if_t, setcap: ::kernel::sys::raw::c_int,
                              clearcap: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_getcapenable(ifp: if_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_getdname(ifp: if_t) -> *const ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn if_setdev(ifp: if_t, dev: *mut ::kernel::sys::raw::c_void)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_setdrvflagbits(ifp: if_t,
                             if_setflags: ::kernel::sys::raw::c_int,
                             clear_flags: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_getdrvflags(ifp: if_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_setdrvflags(ifp: if_t, flags: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_clearhwassist(ifp: if_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_sethwassistbits(ifp: if_t, toset: ::kernel::sys::raw::c_int,
                              toclear: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_sethwassist(ifp: if_t, hwassist_bit: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_gethwassist(ifp: if_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_setsoftc(ifp: if_t, softc: *mut ::kernel::sys::raw::c_void)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_getsoftc(ifp: if_t) -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn if_setflags(ifp: if_t, flags: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_gethwaddr(ifp: if_t, arg1: *mut ifreq)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_setmtu(ifp: if_t, mtu: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_getmtu(ifp: if_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_getmtu_family(ifp: if_t, family: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_setflagbits(ifp: if_t, set: ::kernel::sys::raw::c_int,
                          clear: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_getflags(ifp: if_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_sendq_empty(ifp: if_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_setsendqready(ifp: if_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_setsendqlen(ifp: if_t, tx_desc_count: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_sethwtsomax(ifp: if_t, if_hw_tsomax: u_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_sethwtsomaxsegcount(ifp: if_t, if_hw_tsomaxsegcount: u_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_sethwtsomaxsegsize(ifp: if_t, if_hw_tsomaxsegsize: u_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_gethwtsomax(ifp: if_t) -> u_int;
}
extern "C" {
    pub fn if_gethwtsomaxsegcount(ifp: if_t) -> u_int;
}
extern "C" {
    pub fn if_gethwtsomaxsegsize(ifp: if_t) -> u_int;
}
extern "C" {
    pub fn if_input(ifp: if_t, sendmp: *mut mbuf)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_sendq_prepend(ifp: if_t, m: *mut mbuf)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_dequeue(ifp: if_t) -> *mut mbuf;
}
extern "C" {
    pub fn if_setifheaderlen(ifp: if_t, len: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_setrcvif(m: *mut mbuf, ifp: if_t);
}
extern "C" {
    pub fn if_setvtag(m: *mut mbuf, tag: u_int16_t);
}
extern "C" {
    pub fn if_getvtag(m: *mut mbuf) -> u_int16_t;
}
extern "C" {
    pub fn if_vlantrunkinuse(ifp: if_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_getlladdr(ifp: if_t) -> caddr_t;
}
extern "C" {
    pub fn if_gethandle(arg1: u_char) -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn if_bpfmtap(ifp: if_t, m: *mut mbuf);
}
extern "C" {
    pub fn if_etherbpfmtap(ifp: if_t, m: *mut mbuf);
}
extern "C" {
    pub fn if_vlancap(ifp: if_t);
}
extern "C" {
    pub fn if_setupmultiaddr(ifp: if_t, mta: *mut ::kernel::sys::raw::c_void,
                             cnt: *mut ::kernel::sys::raw::c_int,
                             max: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_multiaddr_array(ifp: if_t, mta: *mut ::kernel::sys::raw::c_void,
                              cnt: *mut ::kernel::sys::raw::c_int,
                              max: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_multiaddr_count(ifp: if_t, max: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_multi_apply(ifp: *mut ifnet,
                          filter:
                              ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                              *mut ::kernel::sys::raw::c_void,
                                                                          arg2:
                                                                              *mut ifmultiaddr,
                                                                          arg3:
                                                                              ::kernel::sys::raw::c_int)
                                                         ->
                                                             ::kernel::sys::raw::c_int>,
                          arg: *mut ::kernel::sys::raw::c_void)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_getamcount(ifp: if_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_getifaddr(ifp: if_t) -> *mut ifaddr;
}
extern "C" {
    pub fn if_setinitfn(ifp: if_t,
                        arg1:
                            ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                            *mut ::kernel::sys::raw::c_void)>);
}
extern "C" {
    pub fn if_setioctlfn(ifp: if_t,
                         arg1:
                             ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                             if_t,
                                                                         arg2:
                                                                             u_long,
                                                                         arg3:
                                                                             caddr_t)
                                                        ->
                                                            ::kernel::sys::raw::c_int>);
}
extern "C" {
    pub fn if_setstartfn(ifp: if_t,
                         arg1:
                             ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                             if_t)>);
}
extern "C" {
    pub fn if_settransmitfn(ifp: if_t, arg1: if_transmit_fn_t);
}
extern "C" {
    pub fn if_setqflushfn(ifp: if_t, arg1: if_qflush_fn_t);
}
extern "C" {
    pub fn if_setgetcounterfn(ifp: if_t, arg1: if_get_counter_t);
}
extern "C" {
    pub fn drbr_inuse_drv(ifp: if_t, br: *mut buf_ring)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn drbr_dequeue_drv(ifp: if_t, br: *mut buf_ring) -> *mut mbuf;
}
extern "C" {
    pub fn drbr_needs_enqueue_drv(ifp: if_t, br: *mut buf_ring)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn drbr_enqueue_drv(ifp: if_t, br: *mut buf_ring, m: *mut mbuf)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_hw_tsomax_common(ifp: if_t, arg1: *mut ifnet_hw_tsomax);
}
extern "C" {
    pub fn if_hw_tsomax_update(ifp: if_t, arg1: *mut ifnet_hw_tsomax)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn ifr_data_get_ptr(ifrp: *mut ::kernel::sys::raw::c_void)
     -> *mut ::kernel::sys::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifqueue {
    pub ifq_head: *mut mbuf,
    pub ifq_tail: *mut mbuf,
    pub ifq_len: ::kernel::sys::raw::c_int,
    pub ifq_maxlen: ::kernel::sys::raw::c_int,
    pub ifq_mtx: mtx,
}
#[test]
fn bindgen_test_layout_ifqueue() {
    assert_eq!(::core::mem::size_of::<ifqueue>() , 56usize , concat ! (
               "Size of: " , stringify ! ( ifqueue ) ));
    assert_eq! (::core::mem::align_of::<ifqueue>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ifqueue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifqueue ) ) . ifq_head as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifqueue ) , "::" ,
                stringify ! ( ifq_head ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifqueue ) ) . ifq_tail as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifqueue ) , "::" ,
                stringify ! ( ifq_tail ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifqueue ) ) . ifq_len as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ifqueue ) , "::" ,
                stringify ! ( ifq_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifqueue ) ) . ifq_maxlen as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( ifqueue ) , "::" ,
                stringify ! ( ifq_maxlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifqueue ) ) . ifq_mtx as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ifqueue ) , "::" ,
                stringify ! ( ifq_mtx ) ));
}
impl Clone for ifqueue {
    fn clone(&self) -> Self { *self }
}
impl Default for ifqueue {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    pub fn if_handoff(ifq: *mut ifqueue, m: *mut mbuf, ifp: *mut ifnet,
                      adjust: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_start(arg1: *mut ifnet);
}
extern "C" {
    #[link_name = "ifqmaxlen"]
    pub static mut ifqmaxlen: ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_qflush(arg1: *mut ifnet);
}
extern "C" {
    pub fn ifq_init(arg1: *mut ifaltq, ifp: *mut ifnet);
}
extern "C" {
    pub fn ifq_delete(arg1: *mut ifaltq);
}
pub type ifm_change_cb_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ifnet)
                               -> ::kernel::sys::raw::c_int>;
pub type ifm_stat_cb_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ifnet,
                                                req: *mut ifmediareq)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifmedia_entry {
    pub ifm_list: ifmedia_entry__bindgen_ty_1,
    pub ifm_media: ::kernel::sys::raw::c_int,
    pub ifm_data: ::kernel::sys::raw::c_int,
    pub ifm_aux: *mut ::kernel::sys::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifmedia_entry__bindgen_ty_1 {
    pub le_next: *mut ifmedia_entry,
    pub le_prev: *mut *mut ifmedia_entry,
}
#[test]
fn bindgen_test_layout_ifmedia_entry__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<ifmedia_entry__bindgen_ty_1>() , 16usize
               , concat ! (
               "Size of: " , stringify ! ( ifmedia_entry__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<ifmedia_entry__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( ifmedia_entry__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmedia_entry__bindgen_ty_1 ) ) . le_next
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                ifmedia_entry__bindgen_ty_1 ) , "::" , stringify ! ( le_next )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmedia_entry__bindgen_ty_1 ) ) . le_prev
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                ifmedia_entry__bindgen_ty_1 ) , "::" , stringify ! ( le_prev )
                ));
}
impl Clone for ifmedia_entry__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for ifmedia_entry__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_ifmedia_entry() {
    assert_eq!(::core::mem::size_of::<ifmedia_entry>() , 32usize , concat ! (
               "Size of: " , stringify ! ( ifmedia_entry ) ));
    assert_eq! (::core::mem::align_of::<ifmedia_entry>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ifmedia_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmedia_entry ) ) . ifm_list as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmedia_entry ) , "::"
                , stringify ! ( ifm_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmedia_entry ) ) . ifm_media as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmedia_entry ) , "::"
                , stringify ! ( ifm_media ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmedia_entry ) ) . ifm_data as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmedia_entry ) , "::"
                , stringify ! ( ifm_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmedia_entry ) ) . ifm_aux as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmedia_entry ) , "::"
                , stringify ! ( ifm_aux ) ));
}
impl Clone for ifmedia_entry {
    fn clone(&self) -> Self { *self }
}
impl Default for ifmedia_entry {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    pub fn ifmedia_init(ifm: *mut ifmedia,
                        dontcare_mask: ::kernel::sys::raw::c_int,
                        change_callback: ifm_change_cb_t,
                        status_callback: ifm_stat_cb_t);
}
extern "C" {
    pub fn ifmedia_removeall(ifm: *mut ifmedia);
}
extern "C" {
    pub fn ifmedia_add(ifm: *mut ifmedia, mword: ::kernel::sys::raw::c_int,
                       data: ::kernel::sys::raw::c_int,
                       aux: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn ifmedia_list_add(mp: *mut ifmedia, lp: *mut ifmedia_entry,
                            count: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn ifmedia_set(ifm: *mut ifmedia, mword: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn ifmedia_ioctl(ifp: *mut ifnet, ifr: *mut ifreq, ifm: *mut ifmedia,
                         cmd: u_long) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn ifmedia_baudrate(arg1: ::kernel::sys::raw::c_int) -> u64;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifmedia_description {
    pub ifmt_word: ::kernel::sys::raw::c_int,
    pub ifmt_string: *const ::kernel::sys::raw::c_char,
}
#[test]
fn bindgen_test_layout_ifmedia_description() {
    assert_eq!(::core::mem::size_of::<ifmedia_description>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( ifmedia_description )
               ));
    assert_eq! (::core::mem::align_of::<ifmedia_description>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( ifmedia_description ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmedia_description ) ) . ifmt_word as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmedia_description ) ,
                "::" , stringify ! ( ifmt_word ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmedia_description ) ) . ifmt_string as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmedia_description ) ,
                "::" , stringify ! ( ifmt_string ) ));
}
impl Clone for ifmedia_description {
    fn clone(&self) -> Self { *self }
}
impl Default for ifmedia_description {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct ifmedia_baudrate {
    pub ifmb_word: ::kernel::sys::raw::c_int,
    pub ifmb_baudrate: u64,
}
#[test]
fn bindgen_test_layout_ifmedia_baudrate() {
    assert_eq!(::core::mem::size_of::<ifmedia_baudrate>() , 16usize , concat !
               ( "Size of: " , stringify ! ( ifmedia_baudrate ) ));
    assert_eq! (::core::mem::align_of::<ifmedia_baudrate>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( ifmedia_baudrate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmedia_baudrate ) ) . ifmb_word as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmedia_baudrate ) ,
                "::" , stringify ! ( ifmb_word ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmedia_baudrate ) ) . ifmb_baudrate as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmedia_baudrate ) ,
                "::" , stringify ! ( ifmb_baudrate ) ));
}
impl Clone for ifmedia_baudrate {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifmedia_status_description {
    pub ifms_type: ::kernel::sys::raw::c_int,
    pub ifms_valid: ::kernel::sys::raw::c_int,
    pub ifms_bit: ::kernel::sys::raw::c_int,
    pub ifms_string: [*const ::kernel::sys::raw::c_char; 2usize],
}
#[test]
fn bindgen_test_layout_ifmedia_status_description() {
    assert_eq!(::core::mem::size_of::<ifmedia_status_description>() , 32usize
               , concat ! (
               "Size of: " , stringify ! ( ifmedia_status_description ) ));
    assert_eq! (::core::mem::align_of::<ifmedia_status_description>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( ifmedia_status_description )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmedia_status_description ) ) .
                ifms_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                ifmedia_status_description ) , "::" , stringify ! ( ifms_type
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmedia_status_description ) ) .
                ifms_valid as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                ifmedia_status_description ) , "::" , stringify ! ( ifms_valid
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmedia_status_description ) ) . ifms_bit
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                ifmedia_status_description ) , "::" , stringify ! ( ifms_bit )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmedia_status_description ) ) .
                ifms_string as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                ifmedia_status_description ) , "::" , stringify ! (
                ifms_string ) ));
}
impl Clone for ifmedia_status_description {
    fn clone(&self) -> Self { *self }
}
impl Default for ifmedia_status_description {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy)]
pub struct ether_header {
    pub ether_dhost: [u_char; 6usize],
    pub ether_shost: [u_char; 6usize],
    pub ether_type: u_short,
}
#[test]
fn bindgen_test_layout_ether_header() {
    assert_eq!(::core::mem::size_of::<ether_header>() , 14usize , concat ! (
               "Size of: " , stringify ! ( ether_header ) ));
    assert_eq! (::core::mem::align_of::<ether_header>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( ether_header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ether_header ) ) . ether_dhost as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ether_header ) , "::" ,
                stringify ! ( ether_dhost ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ether_header ) ) . ether_shost as * const
                _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( ether_header ) , "::" ,
                stringify ! ( ether_shost ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ether_header ) ) . ether_type as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( ether_header ) , "::" ,
                stringify ! ( ether_type ) ));
}
impl Clone for ether_header {
    fn clone(&self) -> Self { *self }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy)]
pub struct ether_addr {
    pub octet: [u_char; 6usize],
}
#[test]
fn bindgen_test_layout_ether_addr() {
    assert_eq!(::core::mem::size_of::<ether_addr>() , 6usize , concat ! (
               "Size of: " , stringify ! ( ether_addr ) ));
    assert_eq! (::core::mem::align_of::<ether_addr>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( ether_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ether_addr ) ) . octet as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ether_addr ) , "::" ,
                stringify ! ( octet ) ));
}
impl Clone for ether_addr {
    fn clone(&self) -> Self { *self }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy)]
pub struct ether_vlan_header {
    pub evl_dhost: [u8; 6usize],
    pub evl_shost: [u8; 6usize],
    pub evl_encap_proto: u16,
    pub evl_tag: u16,
    pub evl_proto: u16,
}
#[test]
fn bindgen_test_layout_ether_vlan_header() {
    assert_eq!(::core::mem::size_of::<ether_vlan_header>() , 18usize , concat
               ! ( "Size of: " , stringify ! ( ether_vlan_header ) ));
    assert_eq! (::core::mem::align_of::<ether_vlan_header>() , 1usize , concat
                ! ( "Alignment of " , stringify ! ( ether_vlan_header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ether_vlan_header ) ) . evl_dhost as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ether_vlan_header ) ,
                "::" , stringify ! ( evl_dhost ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ether_vlan_header ) ) . evl_shost as *
                const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( ether_vlan_header ) ,
                "::" , stringify ! ( evl_shost ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ether_vlan_header ) ) . evl_encap_proto
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( ether_vlan_header ) ,
                "::" , stringify ! ( evl_encap_proto ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ether_vlan_header ) ) . evl_tag as *
                const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( ether_vlan_header ) ,
                "::" , stringify ! ( evl_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ether_vlan_header ) ) . evl_proto as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ether_vlan_header ) ,
                "::" , stringify ! ( evl_proto ) ));
}
impl Clone for ether_vlan_header {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_if {
    _unused: [u8; 0],
}
extern "C" {
    pub fn ether_crc32_le(arg1: *const u8, arg2: usize) -> u32;
}
extern "C" {
    pub fn ether_crc32_be(arg1: *const u8, arg2: usize) -> u32;
}
extern "C" {
    pub fn ether_demux(arg1: *mut ifnet, arg2: *mut mbuf);
}
extern "C" {
    pub fn ether_ifattach(arg1: *mut ifnet, arg2: *const u_int8_t);
}
extern "C" {
    pub fn ether_ifdetach(arg1: *mut ifnet);
}
extern "C" {
    pub fn ether_ioctl(arg1: *mut ifnet, arg2: u_long, arg3: caddr_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn ether_output(arg1: *mut ifnet, arg2: *mut mbuf,
                        arg3: *const sockaddr, arg4: *mut route)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn ether_output_frame(arg1: *mut ifnet, arg2: *mut mbuf)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn ether_sprintf(arg1: *const u_int8_t)
     -> *mut ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn ether_vlan_mtap(arg1: *mut bpf_if, arg2: *mut mbuf,
                           arg3: *mut ::kernel::sys::raw::c_void,
                           arg4: u_int);
}
extern "C" {
    pub fn ether_vlanencap(arg1: *mut mbuf, arg2: u16) -> *mut mbuf;
}
extern "C" {
    pub fn ether_8021q_frame(mp: *mut *mut mbuf, ife: *mut ifnet,
                             p: *mut ifnet, vid: u16, pcp: u8) -> bool_;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct kobj {
    pub ops: kobj_ops_t,
}
#[test]
fn bindgen_test_layout_kobj() {
    assert_eq!(::core::mem::size_of::<kobj>() , 8usize , concat ! (
               "Size of: " , stringify ! ( kobj ) ));
    assert_eq! (::core::mem::align_of::<kobj>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kobj ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kobj ) ) . ops as * const _ as usize } ,
                0usize , concat ! (
                "Alignment of field: " , stringify ! ( kobj ) , "::" ,
                stringify ! ( ops ) ));
}
impl Clone for kobj {
    fn clone(&self) -> Self { *self }
}
impl Default for kobj {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type kobj_t = *mut kobj;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct kobj_class {
    pub name: *const ::kernel::sys::raw::c_char,
    pub methods: *mut kobj_method_t,
    pub size: usize,
    pub baseclasses: *mut kobj_class_t,
    pub refs: u_int,
    pub ops: kobj_ops_t,
}
#[test]
fn bindgen_test_layout_kobj_class() {
    assert_eq!(::core::mem::size_of::<kobj_class>() , 48usize , concat ! (
               "Size of: " , stringify ! ( kobj_class ) ));
    assert_eq! (::core::mem::align_of::<kobj_class>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kobj_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kobj_class ) ) . name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kobj_class ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kobj_class ) ) . methods as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kobj_class ) , "::" ,
                stringify ! ( methods ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kobj_class ) ) . size as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( kobj_class ) , "::" ,
                stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kobj_class ) ) . baseclasses as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( kobj_class ) , "::" ,
                stringify ! ( baseclasses ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kobj_class ) ) . refs as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( kobj_class ) , "::" ,
                stringify ! ( refs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kobj_class ) ) . ops as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( kobj_class ) , "::" ,
                stringify ! ( ops ) ));
}
impl Clone for kobj_class {
    fn clone(&self) -> Self { *self }
}
impl Default for kobj_class {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type kobj_class_t = *mut kobj_class;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct kobj_method {
    pub desc: kobjop_desc_t,
    pub func: kobjop_t,
}
#[test]
fn bindgen_test_layout_kobj_method() {
    assert_eq!(::core::mem::size_of::<kobj_method>() , 16usize , concat ! (
               "Size of: " , stringify ! ( kobj_method ) ));
    assert_eq! (::core::mem::align_of::<kobj_method>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kobj_method ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kobj_method ) ) . desc as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kobj_method ) , "::" ,
                stringify ! ( desc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kobj_method ) ) . func as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kobj_method ) , "::" ,
                stringify ! ( func ) ));
}
impl Clone for kobj_method {
    fn clone(&self) -> Self { *self }
}
impl Default for kobj_method {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type kobj_method_t = kobj_method;
pub type kobjop_t =
    ::core::option::Option<unsafe extern "C" fn()
                               -> ::kernel::sys::raw::c_int>;
#[repr(C)]
#[derive(Copy)]
pub struct kobj_ops {
    pub cache: [*mut kobj_method_t; 256usize],
    pub cls: kobj_class_t,
}
#[test]
fn bindgen_test_layout_kobj_ops() {
    assert_eq!(::core::mem::size_of::<kobj_ops>() , 2056usize , concat ! (
               "Size of: " , stringify ! ( kobj_ops ) ));
    assert_eq! (::core::mem::align_of::<kobj_ops>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kobj_ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kobj_ops ) ) . cache as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kobj_ops ) , "::" ,
                stringify ! ( cache ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kobj_ops ) ) . cls as * const _ as usize
                } , 2048usize , concat ! (
                "Alignment of field: " , stringify ! ( kobj_ops ) , "::" ,
                stringify ! ( cls ) ));
}
impl Clone for kobj_ops {
    fn clone(&self) -> Self { *self }
}
impl Default for kobj_ops {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for kobj_ops {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "kobj_ops {{ cache: [{}], cls: {:?} }}" , self . cache .
               iter (  ) . enumerate (  ) . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ) , self . cls)
    }
}
pub type kobj_ops_t = *mut kobj_ops;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct kobjop_desc {
    pub id: ::kernel::sys::raw::c_uint,
    pub deflt: kobj_method_t,
}
#[test]
fn bindgen_test_layout_kobjop_desc() {
    assert_eq!(::core::mem::size_of::<kobjop_desc>() , 24usize , concat ! (
               "Size of: " , stringify ! ( kobjop_desc ) ));
    assert_eq! (::core::mem::align_of::<kobjop_desc>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kobjop_desc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kobjop_desc ) ) . id as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kobjop_desc ) , "::" ,
                stringify ! ( id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kobjop_desc ) ) . deflt as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kobjop_desc ) , "::" ,
                stringify ! ( deflt ) ));
}
impl Clone for kobjop_desc {
    fn clone(&self) -> Self { *self }
}
impl Default for kobjop_desc {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type kobjop_desc_t = *mut kobjop_desc;
extern "C" {
    pub fn kobj_class_compile(cls: kobj_class_t);
}
extern "C" {
    pub fn kobj_class_compile_static(cls: kobj_class_t, ops: kobj_ops_t);
}
extern "C" {
    pub fn kobj_class_free(cls: kobj_class_t);
}
extern "C" {
    pub fn kobj_create(cls: kobj_class_t, mtype: *mut malloc_type,
                       mflags: ::kernel::sys::raw::c_int) -> kobj_t;
}
extern "C" {
    pub fn kobj_init(obj: kobj_t, cls: kobj_class_t);
}
extern "C" {
    pub fn kobj_init_static(obj: kobj_t, cls: kobj_class_t);
}
extern "C" {
    pub fn kobj_delete(obj: kobj_t, mtype: *mut malloc_type);
}
extern "C" {
    pub fn kobj_lookup_method(cls: kobj_class_t, cep: *mut *mut kobj_method_t,
                              desc: kobjop_desc_t) -> *mut kobj_method_t;
}
extern "C" {
    pub fn kobj_error_method() -> ::kernel::sys::raw::c_int;
}
pub type bus_addr_t = u64;
pub type bus_size_t = u64;
pub type bus_space_tag_t = u64;
pub type bus_space_handle_t = u64;
pub type bus_dmasync_op_t = ::kernel::sys::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bus_dma_tag {
    _unused: [u8; 0],
}
pub type bus_dma_tag_t = *mut bus_dma_tag;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bus_dmamap {
    _unused: [u8; 0],
}
pub type bus_dmamap_t = *mut bus_dmamap;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum bus_dma_lock_op_t { BUS_DMA_LOCK = 1, BUS_DMA_UNLOCK = 2, }
pub type bus_dma_lock_t =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: bus_dma_lock_op_t)>;
/// @brief Interface information structure.
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct u_businfo {
    /// < @brief interface version
    pub ub_version: ::kernel::sys::raw::c_int,
    /// < @brief generation count
    pub ub_generation: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_u_businfo() {
    assert_eq!(::core::mem::size_of::<u_businfo>() , 8usize , concat ! (
               "Size of: " , stringify ! ( u_businfo ) ));
    assert_eq! (::core::mem::align_of::<u_businfo>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( u_businfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_businfo ) ) . ub_version as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( u_businfo ) , "::" ,
                stringify ! ( ub_version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_businfo ) ) . ub_generation as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( u_businfo ) , "::" ,
                stringify ! ( ub_generation ) ));
}
impl Clone for u_businfo {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
/// @brief State of the device.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum device_state {
    DS_NOTPRESENT = 10,
    DS_ALIVE = 20,
    DS_ATTACHING = 25,
    DS_ATTACHED = 30,
    DS_BUSY = 40,
}
pub use self::device_state as device_state_t;
/// @brief Device information exported to userspace.
#[repr(C)]
#[derive(Copy)]
pub struct u_device {
    pub dv_handle: usize,
    pub dv_parent: usize,
    /// < @brief Name of device in tree.
    pub dv_name: [::kernel::sys::raw::c_char; 32usize],
    /// < @brief Driver description
    pub dv_desc: [::kernel::sys::raw::c_char; 32usize],
    /// < @brief Driver name
    pub dv_drivername: [::kernel::sys::raw::c_char; 32usize],
    /// < @brief Plug and play info
    pub dv_pnpinfo: [::kernel::sys::raw::c_char; 128usize],
    /// < @brief Where is the device?
    pub dv_location: [::kernel::sys::raw::c_char; 128usize],
    /// < @brief API Flags for device
    pub dv_devflags: u32,
    /// < @brief flags for dev state
    pub dv_flags: u16,
    /// < @brief State of attachment
    pub dv_state: device_state_t,
}
#[test]
fn bindgen_test_layout_u_device() {
    assert_eq!(::core::mem::size_of::<u_device>() , 384usize , concat ! (
               "Size of: " , stringify ! ( u_device ) ));
    assert_eq! (::core::mem::align_of::<u_device>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( u_device ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_device ) ) . dv_handle as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( u_device ) , "::" ,
                stringify ! ( dv_handle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_device ) ) . dv_parent as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( u_device ) , "::" ,
                stringify ! ( dv_parent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_device ) ) . dv_name as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( u_device ) , "::" ,
                stringify ! ( dv_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_device ) ) . dv_desc as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( u_device ) , "::" ,
                stringify ! ( dv_desc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_device ) ) . dv_drivername as * const _
                as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( u_device ) , "::" ,
                stringify ! ( dv_drivername ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_device ) ) . dv_pnpinfo as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( u_device ) , "::" ,
                stringify ! ( dv_pnpinfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_device ) ) . dv_location as * const _
                as usize } , 240usize , concat ! (
                "Alignment of field: " , stringify ! ( u_device ) , "::" ,
                stringify ! ( dv_location ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_device ) ) . dv_devflags as * const _
                as usize } , 368usize , concat ! (
                "Alignment of field: " , stringify ! ( u_device ) , "::" ,
                stringify ! ( dv_devflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_device ) ) . dv_flags as * const _ as
                usize } , 372usize , concat ! (
                "Alignment of field: " , stringify ! ( u_device ) , "::" ,
                stringify ! ( dv_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_device ) ) . dv_state as * const _ as
                usize } , 376usize , concat ! (
                "Alignment of field: " , stringify ! ( u_device ) , "::" ,
                stringify ! ( dv_state ) ));
}
impl Clone for u_device {
    fn clone(&self) -> Self { *self }
}
impl Default for u_device {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for u_device {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "u_device {{ dv_handle: {:?}, dv_parent: {:?}, dv_name: [{}], dv_desc: [{}], dv_drivername: [{}], dv_pnpinfo: [{}], dv_location: [{}], dv_devflags: {:?}, dv_flags: {:?}, dv_state: {:?} }}"
               , self . dv_handle , self . dv_parent , self . dv_name . iter (
                ) . enumerate (  ) . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ) , self . dv_desc . iter (  ) . enumerate (  ) .
               map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ) , self . dv_drivername . iter (  ) . enumerate (
               ) . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ) , self . dv_pnpinfo . iter (  ) . enumerate (  )
               . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ) , self . dv_location . iter (  ) . enumerate (  )
               . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ) , self . dv_devflags , self . dv_flags , self .
               dv_state)
    }
}
/// @brief Device request structure used for ioctl's.
///
/// Used for ioctl's on /dev/devctl2.  All device ioctl's
/// must have parameter definitions which begin with dr_name.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct devreq_buffer {
    pub buffer: *mut ::kernel::sys::raw::c_void,
    pub length: usize,
}
#[test]
fn bindgen_test_layout_devreq_buffer() {
    assert_eq!(::core::mem::size_of::<devreq_buffer>() , 16usize , concat ! (
               "Size of: " , stringify ! ( devreq_buffer ) ));
    assert_eq! (::core::mem::align_of::<devreq_buffer>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( devreq_buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const devreq_buffer ) ) . buffer as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( devreq_buffer ) , "::"
                , stringify ! ( buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const devreq_buffer ) ) . length as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( devreq_buffer ) , "::"
                , stringify ! ( length ) ));
}
impl Clone for devreq_buffer {
    fn clone(&self) -> Self { *self }
}
impl Default for devreq_buffer {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct devreq {
    pub dr_name: [::kernel::sys::raw::c_char; 128usize],
    pub dr_flags: ::kernel::sys::raw::c_int,
    pub dr_dru: devreq__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub union devreq__bindgen_ty_1 {
    pub dru_buffer: devreq_buffer,
    pub dru_data: *mut ::kernel::sys::raw::c_void,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_devreq__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<devreq__bindgen_ty_1>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( devreq__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<devreq__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( devreq__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const devreq__bindgen_ty_1 ) ) . dru_buffer as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( devreq__bindgen_ty_1 )
                , "::" , stringify ! ( dru_buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const devreq__bindgen_ty_1 ) ) . dru_data as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( devreq__bindgen_ty_1 )
                , "::" , stringify ! ( dru_data ) ));
}
impl Clone for devreq__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for devreq__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for devreq__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "devreq__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_devreq() {
    assert_eq!(::core::mem::size_of::<devreq>() , 152usize , concat ! (
               "Size of: " , stringify ! ( devreq ) ));
    assert_eq! (::core::mem::align_of::<devreq>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( devreq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const devreq ) ) . dr_name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( devreq ) , "::" ,
                stringify ! ( dr_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const devreq ) ) . dr_flags as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( devreq ) , "::" ,
                stringify ! ( dr_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const devreq ) ) . dr_dru as * const _ as usize
                } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( devreq ) , "::" ,
                stringify ! ( dr_dru ) ));
}
impl Clone for devreq {
    fn clone(&self) -> Self { *self }
}
impl Default for devreq {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for devreq {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "devreq {{ dr_name: [{}], dr_flags: {:?}, dr_dru: {:?} }}"
               , self . dr_name . iter (  ) . enumerate (  ) . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ) , self . dr_flags , self . dr_dru)
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ktr_entry {
    pub ktr_timestamp: u_int64_t,
    pub ktr_cpu: ::kernel::sys::raw::c_int,
    pub ktr_line: ::kernel::sys::raw::c_int,
    pub ktr_file: *const ::kernel::sys::raw::c_char,
    pub ktr_desc: *const ::kernel::sys::raw::c_char,
    pub ktr_thread: *mut thread,
    pub ktr_parms: [u_long; 6usize],
}
#[test]
fn bindgen_test_layout_ktr_entry() {
    assert_eq!(::core::mem::size_of::<ktr_entry>() , 88usize , concat ! (
               "Size of: " , stringify ! ( ktr_entry ) ));
    assert_eq! (::core::mem::align_of::<ktr_entry>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ktr_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ktr_entry ) ) . ktr_timestamp as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ktr_entry ) , "::" ,
                stringify ! ( ktr_timestamp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ktr_entry ) ) . ktr_cpu as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ktr_entry ) , "::" ,
                stringify ! ( ktr_cpu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ktr_entry ) ) . ktr_line as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( ktr_entry ) , "::" ,
                stringify ! ( ktr_line ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ktr_entry ) ) . ktr_file as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ktr_entry ) , "::" ,
                stringify ! ( ktr_file ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ktr_entry ) ) . ktr_desc as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ktr_entry ) , "::" ,
                stringify ! ( ktr_desc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ktr_entry ) ) . ktr_thread as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( ktr_entry ) , "::" ,
                stringify ! ( ktr_thread ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ktr_entry ) ) . ktr_parms as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( ktr_entry ) , "::" ,
                stringify ! ( ktr_parms ) ));
}
impl Clone for ktr_entry {
    fn clone(&self) -> Self { *self }
}
impl Default for ktr_entry {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    #[link_name = "ktr_cpumask"]
    pub static mut ktr_cpumask: cpuset_t;
}
extern "C" {
    #[link_name = "ktr_mask"]
    pub static mut ktr_mask: u64;
}
extern "C" {
    #[link_name = "ktr_entries"]
    pub static mut ktr_entries: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "ktr_verbose"]
    pub static mut ktr_verbose: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "ktr_idx"]
    pub static mut ktr_idx: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "ktr_buf"]
    pub static mut ktr_buf: *mut ktr_entry;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry {
    pub ee_link: eventhandler_entry__bindgen_ty_1,
    pub ee_priority: ::kernel::sys::raw::c_int,
    pub ee_arg: *mut ::kernel::sys::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry__bindgen_ty_1 {
    pub tqe_next: *mut eventhandler_entry,
    pub tqe_prev: *mut *mut eventhandler_entry,
}
#[test]
fn bindgen_test_layout_eventhandler_entry__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry__bindgen_ty_1>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry__bindgen_ty_1 ) ) .
                tqe_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry__bindgen_ty_1 ) , "::" , stringify ! (
                tqe_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry__bindgen_ty_1 ) ) .
                tqe_prev as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry__bindgen_ty_1 ) , "::" , stringify ! (
                tqe_prev ) ));
}
impl Clone for eventhandler_entry__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_eventhandler_entry() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry>() , 32usize , concat
               ! ( "Size of: " , stringify ! ( eventhandler_entry ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry ) ) . ee_link as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( eventhandler_entry ) ,
                "::" , stringify ! ( ee_link ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry ) ) . ee_priority as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( eventhandler_entry ) ,
                "::" , stringify ! ( ee_priority ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry ) ) . ee_arg as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( eventhandler_entry ) ,
                "::" , stringify ! ( ee_arg ) ));
}
impl Clone for eventhandler_entry {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_list {
    pub el_name: *mut ::kernel::sys::raw::c_char,
    pub el_flags: ::kernel::sys::raw::c_int,
    pub el_runcount: u_int,
    pub el_lock: mtx,
    pub el_link: eventhandler_list__bindgen_ty_1,
    pub el_entries: eventhandler_list__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_list__bindgen_ty_1 {
    pub tqe_next: *mut eventhandler_list,
    pub tqe_prev: *mut *mut eventhandler_list,
}
#[test]
fn bindgen_test_layout_eventhandler_list__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<eventhandler_list__bindgen_ty_1>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_list__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_list__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_list__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_list__bindgen_ty_1 ) ) .
                tqe_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_list__bindgen_ty_1 ) , "::" , stringify ! (
                tqe_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_list__bindgen_ty_1 ) ) .
                tqe_prev as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_list__bindgen_ty_1 ) , "::" , stringify ! (
                tqe_prev ) ));
}
impl Clone for eventhandler_list__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_list__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_list__bindgen_ty_2 {
    pub tqh_first: *mut eventhandler_entry,
    pub tqh_last: *mut *mut eventhandler_entry,
}
#[test]
fn bindgen_test_layout_eventhandler_list__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<eventhandler_list__bindgen_ty_2>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_list__bindgen_ty_2 )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_list__bindgen_ty_2>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_list__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_list__bindgen_ty_2 ) ) .
                tqh_first as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_list__bindgen_ty_2 ) , "::" , stringify ! (
                tqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_list__bindgen_ty_2 ) ) .
                tqh_last as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_list__bindgen_ty_2 ) , "::" , stringify ! (
                tqh_last ) ));
}
impl Clone for eventhandler_list__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_list__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_eventhandler_list() {
    assert_eq!(::core::mem::size_of::<eventhandler_list>() , 80usize , concat
               ! ( "Size of: " , stringify ! ( eventhandler_list ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_list>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( eventhandler_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_list ) ) . el_name as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( eventhandler_list ) ,
                "::" , stringify ! ( el_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_list ) ) . el_flags as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( eventhandler_list ) ,
                "::" , stringify ! ( el_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_list ) ) . el_runcount as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( eventhandler_list ) ,
                "::" , stringify ! ( el_runcount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_list ) ) . el_lock as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( eventhandler_list ) ,
                "::" , stringify ! ( el_lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_list ) ) . el_link as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( eventhandler_list ) ,
                "::" , stringify ! ( el_link ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_list ) ) . el_entries as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( eventhandler_list ) ,
                "::" , stringify ! ( el_entries ) ));
}
impl Clone for eventhandler_list {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_list {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type eventhandler_tag = *mut eventhandler_entry;
extern "C" {
    pub fn eventhandler_register(list: *mut eventhandler_list,
                                 name: *const ::kernel::sys::raw::c_char,
                                 func: *mut ::kernel::sys::raw::c_void,
                                 arg: *mut ::kernel::sys::raw::c_void,
                                 priority: ::kernel::sys::raw::c_int)
     -> eventhandler_tag;
}
extern "C" {
    pub fn eventhandler_deregister(list: *mut eventhandler_list,
                                   tag: eventhandler_tag);
}
extern "C" {
    pub fn eventhandler_deregister_nowait(list: *mut eventhandler_list,
                                          tag: eventhandler_tag);
}
extern "C" {
    pub fn eventhandler_find_list(name: *const ::kernel::sys::raw::c_char)
     -> *mut eventhandler_list;
}
extern "C" {
    pub fn eventhandler_prune_list(list: *mut eventhandler_list);
}
extern "C" {
    pub fn eventhandler_create_list(name: *const ::kernel::sys::raw::c_char)
     -> *mut eventhandler_list;
}
pub type shutdown_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2:
                                                    ::kernel::sys::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_shutdown_pre_sync {
    pub ee: eventhandler_entry,
    pub eh_func: shutdown_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_shutdown_pre_sync() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_shutdown_pre_sync>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_shutdown_pre_sync ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_shutdown_pre_sync>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_shutdown_pre_sync ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_shutdown_pre_sync ) )
                . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_shutdown_pre_sync ) , "::" , stringify ! (
                ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_shutdown_pre_sync ) )
                . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_shutdown_pre_sync ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_shutdown_pre_sync {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_shutdown_pre_sync {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __hack {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_shutdown_post_sync {
    pub ee: eventhandler_entry,
    pub eh_func: shutdown_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_shutdown_post_sync() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_shutdown_post_sync>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_shutdown_post_sync ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_shutdown_post_sync>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_shutdown_post_sync ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_shutdown_post_sync ) )
                . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_shutdown_post_sync ) , "::" , stringify ! (
                ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_shutdown_post_sync ) )
                . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_shutdown_post_sync ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_shutdown_post_sync {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_shutdown_post_sync {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_shutdown_final {
    pub ee: eventhandler_entry,
    pub eh_func: shutdown_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_shutdown_final() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_shutdown_final>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_shutdown_final )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_shutdown_final>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_shutdown_final ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_shutdown_final ) ) .
                ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_shutdown_final ) , "::" , stringify ! ( ee
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_shutdown_final ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_shutdown_final ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_shutdown_final {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_shutdown_final {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type power_change_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_power_resume {
    pub ee: eventhandler_entry,
    pub eh_func: power_change_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_power_resume() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_power_resume>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_power_resume )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_power_resume>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_power_resume ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_power_resume ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_power_resume ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_power_resume ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_power_resume ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_power_resume {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_power_resume {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_power_suspend {
    pub ee: eventhandler_entry,
    pub eh_func: power_change_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_power_suspend() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_power_suspend>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_power_suspend )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_power_suspend>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_power_suspend ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_power_suspend ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_power_suspend ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_power_suspend ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_power_suspend ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_power_suspend {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_power_suspend {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_power_suspend_early {
    pub ee: eventhandler_entry,
    pub eh_func: power_change_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_power_suspend_early() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_power_suspend_early>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_power_suspend_early ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_power_suspend_early>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_power_suspend_early ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_power_suspend_early )
                ) . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_power_suspend_early ) , "::" , stringify !
                ( ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_power_suspend_early )
                ) . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_power_suspend_early ) , "::" , stringify !
                ( eh_func ) ));
}
impl Clone for eventhandler_entry_power_suspend_early {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_power_suspend_early {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type vm_lowmem_handler_t =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2:
                                                    ::kernel::sys::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_vm_lowmem {
    pub ee: eventhandler_entry,
    pub eh_func: vm_lowmem_handler_t,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_vm_lowmem() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_vm_lowmem>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_vm_lowmem ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_vm_lowmem>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_vm_lowmem )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_vm_lowmem ) ) . ee as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_vm_lowmem ) , "::" , stringify ! ( ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_vm_lowmem ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_vm_lowmem ) , "::" , stringify ! ( eh_func
                ) ));
}
impl Clone for eventhandler_entry_vm_lowmem {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_vm_lowmem {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type mountroot_handler_t =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_mountroot {
    pub ee: eventhandler_entry,
    pub eh_func: mountroot_handler_t,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_mountroot() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_mountroot>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_mountroot ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_mountroot>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_mountroot )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_mountroot ) ) . ee as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_mountroot ) , "::" , stringify ! ( ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_mountroot ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_mountroot ) , "::" , stringify ! ( eh_func
                ) ));
}
impl Clone for eventhandler_entry_mountroot {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_mountroot {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mount {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnode {
    _unused: [u8; 0],
}
pub type vfs_mounted_notify_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut mount,
                                                arg3: *mut vnode,
                                                arg4: *mut thread)>;
pub type vfs_unmounted_notify_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut mount,
                                                arg3: *mut thread)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_vfs_mounted {
    pub ee: eventhandler_entry,
    pub eh_func: vfs_mounted_notify_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_vfs_mounted() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_vfs_mounted>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_vfs_mounted )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_vfs_mounted>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_vfs_mounted
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_vfs_mounted ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_vfs_mounted ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_vfs_mounted ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_vfs_mounted ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_vfs_mounted {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_vfs_mounted {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_vfs_unmounted {
    pub ee: eventhandler_entry,
    pub eh_func: vfs_unmounted_notify_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_vfs_unmounted() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_vfs_unmounted>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_vfs_unmounted )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_vfs_unmounted>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_vfs_unmounted ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_vfs_unmounted ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_vfs_unmounted ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_vfs_unmounted ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_vfs_unmounted ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_vfs_unmounted {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_vfs_unmounted {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct image_params {
    _unused: [u8; 0],
}
pub type exitlist_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut proc_)>;
pub type forklist_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut proc_,
                                                arg3: *mut proc_,
                                                arg4:
                                                    ::kernel::sys::raw::c_int)>;
pub type execlist_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut proc_,
                                                arg3: *mut image_params)>;
pub type proc_ctor_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut proc_)>;
pub type proc_dtor_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut proc_)>;
pub type proc_init_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut proc_)>;
pub type proc_fini_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut proc_)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_process_ctor {
    pub ee: eventhandler_entry,
    pub eh_func: proc_ctor_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_process_ctor() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_process_ctor>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_process_ctor )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_process_ctor>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_process_ctor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_ctor ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_ctor ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_ctor ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_ctor ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_process_ctor {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_process_ctor {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_process_dtor {
    pub ee: eventhandler_entry,
    pub eh_func: proc_dtor_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_process_dtor() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_process_dtor>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_process_dtor )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_process_dtor>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_process_dtor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_dtor ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_dtor ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_dtor ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_dtor ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_process_dtor {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_process_dtor {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_process_init {
    pub ee: eventhandler_entry,
    pub eh_func: proc_init_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_process_init() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_process_init>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_process_init )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_process_init>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_process_init ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_init ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_init ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_init ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_init ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_process_init {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_process_init {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_process_fini {
    pub ee: eventhandler_entry,
    pub eh_func: proc_fini_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_process_fini() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_process_fini>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_process_fini )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_process_fini>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_process_fini ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_fini ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_fini ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_fini ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_fini ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_process_fini {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_process_fini {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_process_exit {
    pub ee: eventhandler_entry,
    pub eh_func: exitlist_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_process_exit() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_process_exit>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_process_exit )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_process_exit>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_process_exit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_exit ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_exit ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_exit ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_exit ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_process_exit {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_process_exit {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_process_fork {
    pub ee: eventhandler_entry,
    pub eh_func: forklist_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_process_fork() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_process_fork>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_process_fork )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_process_fork>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_process_fork ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_fork ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_fork ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_fork ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_fork ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_process_fork {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_process_fork {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_process_exec {
    pub ee: eventhandler_entry,
    pub eh_func: execlist_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_process_exec() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_process_exec>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_process_exec )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_process_exec>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_process_exec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_exec ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_exec ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_exec ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_exec ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_process_exec {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_process_exec {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type app_coredump_start_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut thread,
                                                name:
                                                    *mut ::kernel::sys::raw::c_char)>;
pub type app_coredump_progress_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                td: *mut thread,
                                                byte_count:
                                                    ::kernel::sys::raw::c_int)>;
pub type app_coredump_finish_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                td: *mut thread)>;
pub type app_coredump_error_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                td: *mut thread,
                                                msg:
                                                    *mut ::kernel::sys::raw::c_char, ...)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_app_coredump_start {
    pub ee: eventhandler_entry,
    pub eh_func: app_coredump_start_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_app_coredump_start() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_app_coredump_start>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_app_coredump_start ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_app_coredump_start>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_app_coredump_start ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_app_coredump_start ) )
                . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_app_coredump_start ) , "::" , stringify ! (
                ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_app_coredump_start ) )
                . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_app_coredump_start ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_app_coredump_start {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_app_coredump_start {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_app_coredump_progress {
    pub ee: eventhandler_entry,
    pub eh_func: app_coredump_progress_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_app_coredump_progress() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_app_coredump_progress>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_app_coredump_progress ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_app_coredump_progress>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_app_coredump_progress ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const eventhandler_entry_app_coredump_progress ) )
                . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_app_coredump_progress ) , "::" , stringify
                ! ( ee ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const eventhandler_entry_app_coredump_progress ) )
                . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_app_coredump_progress ) , "::" , stringify
                ! ( eh_func ) ));
}
impl Clone for eventhandler_entry_app_coredump_progress {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_app_coredump_progress {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_app_coredump_finish {
    pub ee: eventhandler_entry,
    pub eh_func: app_coredump_finish_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_app_coredump_finish() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_app_coredump_finish>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_app_coredump_finish ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_app_coredump_finish>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_app_coredump_finish ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_app_coredump_finish )
                ) . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_app_coredump_finish ) , "::" , stringify !
                ( ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_app_coredump_finish )
                ) . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_app_coredump_finish ) , "::" , stringify !
                ( eh_func ) ));
}
impl Clone for eventhandler_entry_app_coredump_finish {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_app_coredump_finish {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_app_coredump_error {
    pub ee: eventhandler_entry,
    pub eh_func: app_coredump_error_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_app_coredump_error() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_app_coredump_error>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_app_coredump_error ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_app_coredump_error>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_app_coredump_error ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_app_coredump_error ) )
                . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_app_coredump_error ) , "::" , stringify ! (
                ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_app_coredump_error ) )
                . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_app_coredump_error ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_app_coredump_error {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_app_coredump_error {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type thread_ctor_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut thread)>;
pub type thread_dtor_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut thread)>;
pub type thread_fini_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut thread)>;
pub type thread_init_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut thread)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_thread_ctor {
    pub ee: eventhandler_entry,
    pub eh_func: thread_ctor_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_thread_ctor() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_thread_ctor>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_thread_ctor )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_thread_ctor>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_thread_ctor
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_thread_ctor ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_thread_ctor ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_thread_ctor ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_thread_ctor ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_thread_ctor {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_thread_ctor {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_thread_dtor {
    pub ee: eventhandler_entry,
    pub eh_func: thread_dtor_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_thread_dtor() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_thread_dtor>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_thread_dtor )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_thread_dtor>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_thread_dtor
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_thread_dtor ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_thread_dtor ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_thread_dtor ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_thread_dtor ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_thread_dtor {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_thread_dtor {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_thread_init {
    pub ee: eventhandler_entry,
    pub eh_func: thread_init_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_thread_init() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_thread_init>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_thread_init )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_thread_init>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_thread_init
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_thread_init ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_thread_init ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_thread_init ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_thread_init ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_thread_init {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_thread_init {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_thread_fini {
    pub ee: eventhandler_entry,
    pub eh_func: thread_fini_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_thread_fini() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_thread_fini>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_thread_fini )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_thread_fini>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_thread_fini
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_thread_fini ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_thread_fini ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_thread_fini ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_thread_fini ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_thread_fini {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_thread_fini {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type uma_zone_chfn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_nmbclusters_change {
    pub ee: eventhandler_entry,
    pub eh_func: uma_zone_chfn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_nmbclusters_change() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_nmbclusters_change>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_nmbclusters_change ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_nmbclusters_change>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_nmbclusters_change ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_nmbclusters_change ) )
                . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_nmbclusters_change ) , "::" , stringify ! (
                ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_nmbclusters_change ) )
                . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_nmbclusters_change ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_nmbclusters_change {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_nmbclusters_change {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_nmbufs_change {
    pub ee: eventhandler_entry,
    pub eh_func: uma_zone_chfn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_nmbufs_change() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_nmbufs_change>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_nmbufs_change )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_nmbufs_change>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_nmbufs_change ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_nmbufs_change ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_nmbufs_change ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_nmbufs_change ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_nmbufs_change ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_nmbufs_change {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_nmbufs_change {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_maxsockets_change {
    pub ee: eventhandler_entry,
    pub eh_func: uma_zone_chfn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_maxsockets_change() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_maxsockets_change>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_maxsockets_change ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_maxsockets_change>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_maxsockets_change ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_maxsockets_change ) )
                . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_maxsockets_change ) , "::" , stringify ! (
                ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_maxsockets_change ) )
                . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_maxsockets_change ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_maxsockets_change {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_maxsockets_change {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type kld_load_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut linker_file)>;
pub type kld_unload_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2:
                                                    *const ::kernel::sys::raw::c_char,
                                                arg3: caddr_t, arg4: usize)>;
pub type kld_unload_try_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut linker_file,
                                                arg3:
                                                    *mut ::kernel::sys::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_kld_load {
    pub ee: eventhandler_entry,
    pub eh_func: kld_load_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_kld_load() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_kld_load>() , 40usize
               , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_kld_load ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_kld_load>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_kld_load )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_kld_load ) ) . ee as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_kld_load ) , "::" , stringify ! ( ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_kld_load ) ) . eh_func
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_kld_load ) , "::" , stringify ! ( eh_func )
                ));
}
impl Clone for eventhandler_entry_kld_load {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_kld_load {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_kld_unload {
    pub ee: eventhandler_entry,
    pub eh_func: kld_unload_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_kld_unload() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_kld_unload>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_kld_unload ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_kld_unload>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_kld_unload
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_kld_unload ) ) . ee as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_kld_unload ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_kld_unload ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_kld_unload ) , "::" , stringify ! ( eh_func
                ) ));
}
impl Clone for eventhandler_entry_kld_unload {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_kld_unload {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_kld_unload_try {
    pub ee: eventhandler_entry,
    pub eh_func: kld_unload_try_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_kld_unload_try() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_kld_unload_try>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_kld_unload_try )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_kld_unload_try>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_kld_unload_try ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_kld_unload_try ) ) .
                ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_kld_unload_try ) , "::" , stringify ! ( ee
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_kld_unload_try ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_kld_unload_try ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_kld_unload_try {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_kld_unload_try {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fb_info {
    _unused: [u8; 0],
}
pub type register_framebuffer_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut fb_info)>;
pub type unregister_framebuffer_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut fb_info)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_register_framebuffer {
    pub ee: eventhandler_entry,
    pub eh_func: register_framebuffer_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_register_framebuffer() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_register_framebuffer>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_register_framebuffer ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_register_framebuffer>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_register_framebuffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_register_framebuffer )
                ) . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_register_framebuffer ) , "::" , stringify !
                ( ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_register_framebuffer )
                ) . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_register_framebuffer ) , "::" , stringify !
                ( eh_func ) ));
}
impl Clone for eventhandler_entry_register_framebuffer {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_register_framebuffer {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_unregister_framebuffer {
    pub ee: eventhandler_entry,
    pub eh_func: unregister_framebuffer_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_unregister_framebuffer() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_unregister_framebuffer>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_unregister_framebuffer ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_unregister_framebuffer>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_unregister_framebuffer ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const eventhandler_entry_unregister_framebuffer ) )
                . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_unregister_framebuffer ) , "::" , stringify
                ! ( ee ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const eventhandler_entry_unregister_framebuffer ) )
                . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_unregister_framebuffer ) , "::" , stringify
                ! ( eh_func ) ));
}
impl Clone for eventhandler_entry_unregister_framebuffer {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_unregister_framebuffer {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cam_path {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ata_params {
    _unused: [u8; 0],
}
pub type ada_probe_veto_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut cam_path,
                                                arg3: *mut ata_params,
                                                arg4:
                                                    *mut ::kernel::sys::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_ada_probe_veto {
    pub ee: eventhandler_entry,
    pub eh_func: ada_probe_veto_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_ada_probe_veto() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_ada_probe_veto>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_ada_probe_veto )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_ada_probe_veto>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_ada_probe_veto ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_ada_probe_veto ) ) .
                ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_ada_probe_veto ) , "::" , stringify ! ( ee
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_ada_probe_veto ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_ada_probe_veto ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_ada_probe_veto {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_ada_probe_veto {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct swdevt {
    _unused: [u8; 0],
}
pub type swapon_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut swdevt)>;
pub type swapoff_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut swdevt)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_swapon {
    pub ee: eventhandler_entry,
    pub eh_func: swapon_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_swapon() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_swapon>() , 40usize ,
               concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_swapon ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_swapon>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_swapon )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_swapon ) ) . ee as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_swapon ) , "::" , stringify ! ( ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_swapon ) ) . eh_func
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_swapon ) , "::" , stringify ! ( eh_func )
                ));
}
impl Clone for eventhandler_entry_swapon {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_swapon {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_swapoff {
    pub ee: eventhandler_entry,
    pub eh_func: swapoff_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_swapoff() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_swapoff>() , 40usize
               , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_swapoff ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_swapoff>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_swapoff )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_swapoff ) ) . ee as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_swapoff ) , "::" , stringify ! ( ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_swapoff ) ) . eh_func
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_swapoff ) , "::" , stringify ! ( eh_func )
                ));
}
impl Clone for eventhandler_entry_swapoff {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_swapoff {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum evhdev_detach {
    EVHDEV_DETACH_BEGIN = 0,
    EVHDEV_DETACH_COMPLETE = 1,
    EVHDEV_DETACH_FAILED = 2,
}
pub type device_attach_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: device_t)>;
pub type device_detach_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: device_t,
                                                arg3: evhdev_detach)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_device_attach {
    pub ee: eventhandler_entry,
    pub eh_func: device_attach_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_device_attach() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_device_attach>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_device_attach )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_device_attach>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_device_attach ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_device_attach ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_device_attach ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_device_attach ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_device_attach ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_device_attach {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_device_attach {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_device_detach {
    pub ee: eventhandler_entry,
    pub eh_func: device_detach_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_device_detach() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_device_detach>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_device_detach )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_device_detach>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_device_detach ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_device_detach ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_device_detach ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_device_detach ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_device_detach ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_device_detach {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_device_detach {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    /// devctl hooks.  Typically one should use the devctl_notify
/// hook to send the message.  However, devctl_queue_data is also
/// included in case devctl_notify isn't sufficiently general.
    pub fn devctl_process_running() -> boolean_t;
}
extern "C" {
    pub fn devctl_notify_f(__system: *const ::kernel::sys::raw::c_char,
                           __subsystem: *const ::kernel::sys::raw::c_char,
                           __type: *const ::kernel::sys::raw::c_char,
                           __data: *const ::kernel::sys::raw::c_char,
                           __flags: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn devctl_notify(__system: *const ::kernel::sys::raw::c_char,
                         __subsystem: *const ::kernel::sys::raw::c_char,
                         __type: *const ::kernel::sys::raw::c_char,
                         __data: *const ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn devctl_queue_data_f(__data: *mut ::kernel::sys::raw::c_char,
                               __flags: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn devctl_queue_data(__data: *mut ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn devctl_safe_quote(__dst: *mut ::kernel::sys::raw::c_char,
                             __src: *const ::kernel::sys::raw::c_char,
                             len: usize);
}
/// Device name parsers.  Hook to allow device enumerators to map
/// scheme-specific names to a device.
pub type dev_lookup_fn =
    ::core::option::Option<unsafe extern "C" fn(arg:
                                                    *mut ::kernel::sys::raw::c_void,
                                                name:
                                                    *const ::kernel::sys::raw::c_char,
                                                result: *mut device_t)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_dev_lookup {
    pub ee: eventhandler_entry,
    pub eh_func: dev_lookup_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_dev_lookup() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_dev_lookup>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_dev_lookup ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_dev_lookup>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_dev_lookup
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_dev_lookup ) ) . ee as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_dev_lookup ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_dev_lookup ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_dev_lookup ) , "::" , stringify ! ( eh_func
                ) ));
}
impl Clone for eventhandler_entry_dev_lookup {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_dev_lookup {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
/// @brief A device driver (included mainly for compatibility with
/// FreeBSD 4.x).
pub type driver_t = kobj_class;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct devclass {
    _unused: [u8; 0],
}
/// @brief A device class
///
/// The devclass object has two main functions in the system. The first
/// is to manage the allocation of unit numbers for device instances
/// and the second is to hold the list of device drivers for a
/// particular bus type. Each devclass has a name and there cannot be
/// two devclasses with the same name. This ensures that unique unit
/// numbers are allocated to device instances.
///
/// Drivers that support several different bus attachments (e.g. isa,
/// pci, pccard) should all use the same devclass to ensure that unit
/// numbers do not conflict.
///
/// Each devclass may also have a parent devclass. This is used when
/// searching for device drivers to allow a form of inheritance. When
/// matching drivers with devices, first the driver list of the parent
/// device's devclass is searched. If no driver is found in that list,
/// the search continues in the parent devclass (if any).
pub type devclass_t = *mut devclass;
/// @brief Driver interrupt service routines
///
/// The filter routine is run in primary interrupt context and may not
/// block or use regular mutexes.  It may only use spin mutexes for
/// synchronization.  The filter may either completely handle the
/// interrupt or it may perform some of the work and defer more
/// expensive work to the regular interrupt handler.  If a filter
/// routine is not registered by the driver, then the regular interrupt
/// handler is always used to handle interrupts from this device.
///
/// The regular interrupt handler executes in its own thread context
/// and may use regular mutexes.  However, it is prohibited from
/// sleeping on a sleep queue.
pub type driver_filter_t =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void)
                               -> ::kernel::sys::raw::c_int>;
pub type driver_intr_t =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void)>;
#[repr(u32)]
/// @brief Interrupt type bits.
///
/// These flags are used both by newbus interrupt
/// registration (nexus.c) and also in struct intrec, which defines
/// interrupt properties.
///
/// XXX We should probably revisit this and remove the vestiges of the
/// spls implicit in names like INTR_TYPE_TTY. In the meantime, don't
/// confuse things by renaming them (Grog, 18 July 2000).
///
/// Buses which do interrupt remapping will want to change their type
/// to reflect what sort of devices are underneath.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum intr_type {
    INTR_TYPE_TTY = 1,
    INTR_TYPE_BIO = 2,
    INTR_TYPE_NET = 4,
    INTR_TYPE_CAM = 8,
    INTR_TYPE_MISC = 16,
    INTR_TYPE_CLK = 32,
    INTR_TYPE_AV = 64,
    INTR_EXCL = 256,
    INTR_MPSAFE = 512,
    INTR_ENTROPY = 1024,
    INTR_MD1 = 4096,
    INTR_MD2 = 8192,
    INTR_MD3 = 16384,
    INTR_MD4 = 32768,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum intr_trigger {
    INTR_TRIGGER_INVALID = -1,
    INTR_TRIGGER_CONFORM = 0,
    INTR_TRIGGER_EDGE = 1,
    INTR_TRIGGER_LEVEL = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum intr_polarity {
    INTR_POLARITY_CONFORM = 0,
    INTR_POLARITY_HIGH = 1,
    INTR_POLARITY_LOW = 2,
}
#[repr(u32)]
/// CPU sets supported by bus_get_cpus().  Note that not all sets may be
/// supported for a given device.  If a request is not supported by a
/// device (or its parents), then bus_get_cpus() will fail with EINVAL.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum cpu_sets { LOCAL_CPUS = 0, INTR_CPUS = 1, }
pub type devop_t =
    ::core::option::Option<unsafe extern "C" fn()
                               -> ::kernel::sys::raw::c_int>;
/// @brief This structure is deprecated.
///
/// Use the kobj(9) macro DEFINE_CLASS to
/// declare classes which implement device drivers.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct driver {
    pub name: *const ::kernel::sys::raw::c_char,
    pub methods: *mut kobj_method_t,
    pub size: usize,
    pub baseclasses: *mut kobj_class_t,
    pub refs: u_int,
    pub ops: kobj_ops_t,
}
#[test]
fn bindgen_test_layout_driver() {
    assert_eq!(::core::mem::size_of::<driver>() , 48usize , concat ! (
               "Size of: " , stringify ! ( driver ) ));
    assert_eq! (::core::mem::align_of::<driver>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( driver ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const driver ) ) . name as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( driver ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const driver ) ) . methods as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( driver ) , "::" ,
                stringify ! ( methods ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const driver ) ) . size as * const _ as usize }
                , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( driver ) , "::" ,
                stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const driver ) ) . baseclasses as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( driver ) , "::" ,
                stringify ! ( baseclasses ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const driver ) ) . refs as * const _ as usize }
                , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( driver ) , "::" ,
                stringify ! ( refs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const driver ) ) . ops as * const _ as usize }
                , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( driver ) , "::" ,
                stringify ! ( ops ) ));
}
impl Clone for driver {
    fn clone(&self) -> Self { *self }
}
impl Default for driver {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
/// @brief A resource mapping.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct resource_map {
    pub r_bustag: bus_space_tag_t,
    pub r_bushandle: bus_space_handle_t,
    pub r_size: bus_size_t,
    pub r_vaddr: *mut ::kernel::sys::raw::c_void,
}
#[test]
fn bindgen_test_layout_resource_map() {
    assert_eq!(::core::mem::size_of::<resource_map>() , 32usize , concat ! (
               "Size of: " , stringify ! ( resource_map ) ));
    assert_eq! (::core::mem::align_of::<resource_map>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( resource_map ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_map ) ) . r_bustag as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_map ) , "::" ,
                stringify ! ( r_bustag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_map ) ) . r_bushandle as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_map ) , "::" ,
                stringify ! ( r_bushandle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_map ) ) . r_size as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_map ) , "::" ,
                stringify ! ( r_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_map ) ) . r_vaddr as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_map ) , "::" ,
                stringify ! ( r_vaddr ) ));
}
impl Clone for resource_map {
    fn clone(&self) -> Self { *self }
}
impl Default for resource_map {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
/// @brief Optional properties of a resource mapping request.
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct resource_map_request {
    pub size: usize,
    pub offset: rman_res_t,
    pub length: rman_res_t,
    pub memattr: vm_memattr_t,
}
#[test]
fn bindgen_test_layout_resource_map_request() {
    assert_eq!(::core::mem::size_of::<resource_map_request>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( resource_map_request )
               ));
    assert_eq! (::core::mem::align_of::<resource_map_request>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( resource_map_request ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_map_request ) ) . size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_map_request )
                , "::" , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_map_request ) ) . offset as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_map_request )
                , "::" , stringify ! ( offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_map_request ) ) . length as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_map_request )
                , "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_map_request ) ) . memattr as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_map_request )
                , "::" , stringify ! ( memattr ) ));
}
impl Clone for resource_map_request {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn resource_init_map_request_impl(_args: *mut resource_map_request,
                                          _sz: usize);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct resource {
    _unused: [u8; 0],
}
/// @brief An entry for a single resource in a resource list.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct resource_list_entry {
    pub link: resource_list_entry__bindgen_ty_1,
    /// < @brief type argument to alloc_resource
    pub type_: ::kernel::sys::raw::c_int,
    /// < @brief resource identifier
    pub rid: ::kernel::sys::raw::c_int,
    /// < @brief resource flags
    pub flags: ::kernel::sys::raw::c_int,
    /// < @brief the real resource when allocated
    pub res: *mut resource,
    /// < @brief start of resource range
    pub start: rman_res_t,
    /// < @brief end of resource range
    pub end: rman_res_t,
    /// < @brief count within range
    pub count: rman_res_t,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct resource_list_entry__bindgen_ty_1 {
    pub stqe_next: *mut resource_list_entry,
}
#[test]
fn bindgen_test_layout_resource_list_entry__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<resource_list_entry__bindgen_ty_1>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( resource_list_entry__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<resource_list_entry__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                resource_list_entry__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_list_entry__bindgen_ty_1 ) ) .
                stqe_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                resource_list_entry__bindgen_ty_1 ) , "::" , stringify ! (
                stqe_next ) ));
}
impl Clone for resource_list_entry__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for resource_list_entry__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_resource_list_entry() {
    assert_eq!(::core::mem::size_of::<resource_list_entry>() , 56usize ,
               concat ! ( "Size of: " , stringify ! ( resource_list_entry )
               ));
    assert_eq! (::core::mem::align_of::<resource_list_entry>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( resource_list_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_list_entry ) ) . link as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_list_entry ) ,
                "::" , stringify ! ( link ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_list_entry ) ) . type_ as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_list_entry ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_list_entry ) ) . rid as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_list_entry ) ,
                "::" , stringify ! ( rid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_list_entry ) ) . flags as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_list_entry ) ,
                "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_list_entry ) ) . res as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_list_entry ) ,
                "::" , stringify ! ( res ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_list_entry ) ) . start as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_list_entry ) ,
                "::" , stringify ! ( start ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_list_entry ) ) . end as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_list_entry ) ,
                "::" , stringify ! ( end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_list_entry ) ) . count as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_list_entry ) ,
                "::" , stringify ! ( count ) ));
}
impl Clone for resource_list_entry {
    fn clone(&self) -> Self { *self }
}
impl Default for resource_list_entry {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct resource_list {
    pub stqh_first: *mut resource_list_entry,
    pub stqh_last: *mut *mut resource_list_entry,
}
#[test]
fn bindgen_test_layout_resource_list() {
    assert_eq!(::core::mem::size_of::<resource_list>() , 16usize , concat ! (
               "Size of: " , stringify ! ( resource_list ) ));
    assert_eq! (::core::mem::align_of::<resource_list>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( resource_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_list ) ) . stqh_first as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_list ) , "::"
                , stringify ! ( stqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_list ) ) . stqh_last as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_list ) , "::"
                , stringify ! ( stqh_last ) ));
}
impl Clone for resource_list {
    fn clone(&self) -> Self { *self }
}
impl Default for resource_list {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    pub fn resource_list_init(rl: *mut resource_list);
}
extern "C" {
    pub fn resource_list_free(rl: *mut resource_list);
}
extern "C" {
    pub fn resource_list_add(rl: *mut resource_list,
                             type_: ::kernel::sys::raw::c_int,
                             rid: ::kernel::sys::raw::c_int,
                             start: rman_res_t, end: rman_res_t,
                             count: rman_res_t) -> *mut resource_list_entry;
}
extern "C" {
    pub fn resource_list_add_next(rl: *mut resource_list,
                                  type_: ::kernel::sys::raw::c_int,
                                  start: rman_res_t, end: rman_res_t,
                                  count: rman_res_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn resource_list_busy(rl: *mut resource_list,
                              type_: ::kernel::sys::raw::c_int,
                              rid: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn resource_list_reserved(rl: *mut resource_list,
                                  type_: ::kernel::sys::raw::c_int,
                                  rid: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn resource_list_find(rl: *mut resource_list,
                              type_: ::kernel::sys::raw::c_int,
                              rid: ::kernel::sys::raw::c_int)
     -> *mut resource_list_entry;
}
extern "C" {
    pub fn resource_list_delete(rl: *mut resource_list,
                                type_: ::kernel::sys::raw::c_int,
                                rid: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn resource_list_alloc(rl: *mut resource_list, bus: device_t,
                               child: device_t,
                               type_: ::kernel::sys::raw::c_int,
                               rid: *mut ::kernel::sys::raw::c_int,
                               start: rman_res_t, end: rman_res_t,
                               count: rman_res_t, flags: u_int)
     -> *mut resource;
}
extern "C" {
    pub fn resource_list_release(rl: *mut resource_list, bus: device_t,
                                 child: device_t,
                                 type_: ::kernel::sys::raw::c_int,
                                 rid: ::kernel::sys::raw::c_int,
                                 res: *mut resource)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn resource_list_release_active(rl: *mut resource_list, bus: device_t,
                                        child: device_t,
                                        type_: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn resource_list_reserve(rl: *mut resource_list, bus: device_t,
                                 child: device_t,
                                 type_: ::kernel::sys::raw::c_int,
                                 rid: *mut ::kernel::sys::raw::c_int,
                                 start: rman_res_t, end: rman_res_t,
                                 count: rman_res_t, flags: u_int)
     -> *mut resource;
}
extern "C" {
    pub fn resource_list_unreserve(rl: *mut resource_list, bus: device_t,
                                   child: device_t,
                                   type_: ::kernel::sys::raw::c_int,
                                   rid: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn resource_list_purge(rl: *mut resource_list);
}
extern "C" {
    pub fn resource_list_print_type(rl: *mut resource_list,
                                    name: *const ::kernel::sys::raw::c_char,
                                    type_: ::kernel::sys::raw::c_int,
                                    format: *const ::kernel::sys::raw::c_char)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "root_bus"]
    pub static mut root_bus: device_t;
}
extern "C" {
    #[link_name = "root_devclass"]
    pub static mut root_devclass: devclass_t;
}
extern "C" {
    pub fn root_bus_configure();
}
extern "C" {
    pub fn bus_generic_activate_resource(dev: device_t, child: device_t,
                                         type_: ::kernel::sys::raw::c_int,
                                         rid: ::kernel::sys::raw::c_int,
                                         r: *mut resource)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_add_child(dev: device_t, order: u_int,
                                 name: *const ::kernel::sys::raw::c_char,
                                 unit: ::kernel::sys::raw::c_int) -> device_t;
}
extern "C" {
    pub fn bus_generic_adjust_resource(bus: device_t, child: device_t,
                                       type_: ::kernel::sys::raw::c_int,
                                       r: *mut resource, start: rman_res_t,
                                       end: rman_res_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_alloc_resource(bus: device_t, child: device_t,
                                      type_: ::kernel::sys::raw::c_int,
                                      rid: *mut ::kernel::sys::raw::c_int,
                                      start: rman_res_t, end: rman_res_t,
                                      count: rman_res_t, flags: u_int)
     -> *mut resource;
}
extern "C" {
    pub fn bus_generic_attach(dev: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_bind_intr(dev: device_t, child: device_t,
                                 irq: *mut resource,
                                 cpu: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_child_present(dev: device_t, child: device_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_config_intr(arg1: device_t,
                                   arg2: ::kernel::sys::raw::c_int,
                                   arg3: intr_trigger, arg4: intr_polarity)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_describe_intr(dev: device_t, child: device_t,
                                     irq: *mut resource,
                                     cookie: *mut ::kernel::sys::raw::c_void,
                                     descr: *const ::kernel::sys::raw::c_char)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_deactivate_resource(dev: device_t, child: device_t,
                                           type_: ::kernel::sys::raw::c_int,
                                           rid: ::kernel::sys::raw::c_int,
                                           r: *mut resource)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_detach(dev: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_driver_added(dev: device_t, driver: *mut driver_t);
}
extern "C" {
    pub fn bus_generic_get_cpus(dev: device_t, child: device_t, op: cpu_sets,
                                setsize: usize, cpuset: *mut _cpuset)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_get_dma_tag(dev: device_t, child: device_t)
     -> bus_dma_tag_t;
}
extern "C" {
    pub fn bus_generic_get_bus_tag(dev: device_t, child: device_t)
     -> bus_space_tag_t;
}
extern "C" {
    pub fn bus_generic_get_domain(dev: device_t, child: device_t,
                                  domain: *mut ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_get_resource_list(arg1: device_t, arg2: device_t)
     -> *mut resource_list;
}
extern "C" {
    pub fn bus_generic_map_resource(dev: device_t, child: device_t,
                                    type_: ::kernel::sys::raw::c_int,
                                    r: *mut resource,
                                    args: *mut resource_map_request,
                                    map: *mut resource_map)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_new_pass(dev: device_t);
}
extern "C" {
    pub fn bus_print_child_header(dev: device_t, child: device_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_print_child_domain(dev: device_t, child: device_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_print_child_footer(dev: device_t, child: device_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_print_child(dev: device_t, child: device_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_probe(dev: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_read_ivar(dev: device_t, child: device_t,
                                 which: ::kernel::sys::raw::c_int,
                                 result: *mut usize)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_release_resource(bus: device_t, child: device_t,
                                        type_: ::kernel::sys::raw::c_int,
                                        rid: ::kernel::sys::raw::c_int,
                                        r: *mut resource)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_resume(dev: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_resume_child(dev: device_t, child: device_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_setup_intr(dev: device_t, child: device_t,
                                  irq: *mut resource,
                                  flags: ::kernel::sys::raw::c_int,
                                  filter: driver_filter_t,
                                  intr: driver_intr_t,
                                  arg: *mut ::kernel::sys::raw::c_void,
                                  cookiep:
                                      *mut *mut ::kernel::sys::raw::c_void)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_rl_alloc_resource(arg1: device_t, arg2: device_t,
                                         arg3: ::kernel::sys::raw::c_int,
                                         arg4: *mut ::kernel::sys::raw::c_int,
                                         arg5: rman_res_t, arg6: rman_res_t,
                                         arg7: rman_res_t, arg8: u_int)
     -> *mut resource;
}
extern "C" {
    pub fn bus_generic_rl_delete_resource(arg1: device_t, arg2: device_t,
                                          arg3: ::kernel::sys::raw::c_int,
                                          arg4: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn bus_generic_rl_get_resource(arg1: device_t, arg2: device_t,
                                       arg3: ::kernel::sys::raw::c_int,
                                       arg4: ::kernel::sys::raw::c_int,
                                       arg5: *mut rman_res_t,
                                       arg6: *mut rman_res_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_rl_set_resource(arg1: device_t, arg2: device_t,
                                       arg3: ::kernel::sys::raw::c_int,
                                       arg4: ::kernel::sys::raw::c_int,
                                       arg5: rman_res_t, arg6: rman_res_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_rl_release_resource(arg1: device_t, arg2: device_t,
                                           arg3: ::kernel::sys::raw::c_int,
                                           arg4: ::kernel::sys::raw::c_int,
                                           arg5: *mut resource)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_shutdown(dev: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_suspend(dev: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_suspend_child(dev: device_t, child: device_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_teardown_intr(dev: device_t, child: device_t,
                                     irq: *mut resource,
                                     cookie: *mut ::kernel::sys::raw::c_void)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_unmap_resource(dev: device_t, child: device_t,
                                      type_: ::kernel::sys::raw::c_int,
                                      r: *mut resource,
                                      map: *mut resource_map)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_write_ivar(dev: device_t, child: device_t,
                                  which: ::kernel::sys::raw::c_int,
                                  value: usize) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_null_rescan(dev: device_t) -> ::kernel::sys::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct resource_spec {
    pub type_: ::kernel::sys::raw::c_int,
    pub rid: ::kernel::sys::raw::c_int,
    pub flags: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_resource_spec() {
    assert_eq!(::core::mem::size_of::<resource_spec>() , 12usize , concat ! (
               "Size of: " , stringify ! ( resource_spec ) ));
    assert_eq! (::core::mem::align_of::<resource_spec>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( resource_spec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_spec ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_spec ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_spec ) ) . rid as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_spec ) , "::"
                , stringify ! ( rid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_spec ) ) . flags as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_spec ) , "::"
                , stringify ! ( flags ) ));
}
impl Clone for resource_spec {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn bus_alloc_resources(dev: device_t, rs: *mut resource_spec,
                               res: *mut *mut resource)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_release_resources(dev: device_t, rs: *const resource_spec,
                                 res: *mut *mut resource);
}
extern "C" {
    pub fn bus_adjust_resource(child: device_t,
                               type_: ::kernel::sys::raw::c_int,
                               r: *mut resource, start: rman_res_t,
                               end: rman_res_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_alloc_resource(dev: device_t, type_: ::kernel::sys::raw::c_int,
                              rid: *mut ::kernel::sys::raw::c_int,
                              start: rman_res_t, end: rman_res_t,
                              count: rman_res_t, flags: u_int)
     -> *mut resource;
}
extern "C" {
    pub fn bus_activate_resource(dev: device_t,
                                 type_: ::kernel::sys::raw::c_int,
                                 rid: ::kernel::sys::raw::c_int,
                                 r: *mut resource)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_deactivate_resource(dev: device_t,
                                   type_: ::kernel::sys::raw::c_int,
                                   rid: ::kernel::sys::raw::c_int,
                                   r: *mut resource)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_map_resource(dev: device_t, type_: ::kernel::sys::raw::c_int,
                            r: *mut resource, args: *mut resource_map_request,
                            map: *mut resource_map)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_unmap_resource(dev: device_t, type_: ::kernel::sys::raw::c_int,
                              r: *mut resource, map: *mut resource_map)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_get_cpus(dev: device_t, op: cpu_sets, setsize: usize,
                        cpuset: *mut _cpuset) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_get_dma_tag(dev: device_t) -> bus_dma_tag_t;
}
extern "C" {
    pub fn bus_get_bus_tag(dev: device_t) -> bus_space_tag_t;
}
extern "C" {
    pub fn bus_get_domain(dev: device_t,
                          domain: *mut ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_release_resource(dev: device_t,
                                type_: ::kernel::sys::raw::c_int,
                                rid: ::kernel::sys::raw::c_int,
                                r: *mut resource)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_free_resource(dev: device_t, type_: ::kernel::sys::raw::c_int,
                             r: *mut resource) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_setup_intr(dev: device_t, r: *mut resource,
                          flags: ::kernel::sys::raw::c_int,
                          filter: driver_filter_t, handler: driver_intr_t,
                          arg: *mut ::kernel::sys::raw::c_void,
                          cookiep: *mut *mut ::kernel::sys::raw::c_void)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_teardown_intr(dev: device_t, r: *mut resource,
                             cookie: *mut ::kernel::sys::raw::c_void)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_bind_intr(dev: device_t, r: *mut resource,
                         cpu: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_describe_intr(dev: device_t, irq: *mut resource,
                             cookie: *mut ::kernel::sys::raw::c_void,
                             fmt: *const ::kernel::sys::raw::c_char, ...)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_set_resource(dev: device_t, type_: ::kernel::sys::raw::c_int,
                            rid: ::kernel::sys::raw::c_int, start: rman_res_t,
                            count: rman_res_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_get_resource(dev: device_t, type_: ::kernel::sys::raw::c_int,
                            rid: ::kernel::sys::raw::c_int,
                            startp: *mut rman_res_t, countp: *mut rman_res_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_get_resource_start(dev: device_t,
                                  type_: ::kernel::sys::raw::c_int,
                                  rid: ::kernel::sys::raw::c_int)
     -> rman_res_t;
}
extern "C" {
    pub fn bus_get_resource_count(dev: device_t,
                                  type_: ::kernel::sys::raw::c_int,
                                  rid: ::kernel::sys::raw::c_int)
     -> rman_res_t;
}
extern "C" {
    pub fn bus_delete_resource(dev: device_t,
                               type_: ::kernel::sys::raw::c_int,
                               rid: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn bus_child_present(child: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_child_pnpinfo_str(child: device_t,
                                 buf: *mut ::kernel::sys::raw::c_char,
                                 buflen: usize) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_child_location_str(child: device_t,
                                  buf: *mut ::kernel::sys::raw::c_char,
                                  buflen: usize) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_enumerate_hinted_children(bus: device_t);
}
extern "C" {
    pub fn device_add_child(dev: device_t,
                            name: *const ::kernel::sys::raw::c_char,
                            unit: ::kernel::sys::raw::c_int) -> device_t;
}
extern "C" {
    pub fn device_add_child_ordered(dev: device_t, order: u_int,
                                    name: *const ::kernel::sys::raw::c_char,
                                    unit: ::kernel::sys::raw::c_int)
     -> device_t;
}
extern "C" {
    pub fn device_busy(dev: device_t);
}
extern "C" {
    pub fn device_delete_child(dev: device_t, child: device_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn device_delete_children(dev: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn device_attach(dev: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn device_detach(dev: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn device_disable(dev: device_t);
}
extern "C" {
    pub fn device_enable(dev: device_t);
}
extern "C" {
    pub fn device_find_child(dev: device_t,
                             classname: *const ::kernel::sys::raw::c_char,
                             unit: ::kernel::sys::raw::c_int) -> device_t;
}
extern "C" {
    pub fn device_get_desc(dev: device_t)
     -> *const ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn device_get_devclass(dev: device_t) -> devclass_t;
}
extern "C" {
    pub fn device_get_driver(dev: device_t) -> *mut driver_t;
}
extern "C" {
    pub fn device_get_flags(dev: device_t) -> u_int32_t;
}
extern "C" {
    pub fn device_get_parent(dev: device_t) -> device_t;
}
extern "C" {
    pub fn device_get_children(dev: device_t, listp: *mut *mut device_t,
                               countp: *mut ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn device_get_ivars(dev: device_t) -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn device_set_ivars(dev: device_t,
                            ivars: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn device_get_name(dev: device_t)
     -> *const ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn device_get_nameunit(dev: device_t)
     -> *const ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn device_get_softc(dev: device_t) -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn device_get_state(dev: device_t) -> device_state_t;
}
extern "C" {
    pub fn device_get_unit(dev: device_t) -> ::kernel::sys::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sysctl_ctx_list {
    _unused: [u8; 0],
}
extern "C" {
    pub fn device_get_sysctl_ctx(dev: device_t) -> *mut sysctl_ctx_list;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sysctl_oid {
    _unused: [u8; 0],
}
extern "C" {
    pub fn device_get_sysctl_tree(dev: device_t) -> *mut sysctl_oid;
}
extern "C" {
    pub fn device_has_quiet_children(dev: device_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn device_is_alive(dev: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn device_is_attached(dev: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn device_is_enabled(dev: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn device_is_suspended(dev: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn device_is_quiet(dev: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn device_lookup_by_name(name: *const ::kernel::sys::raw::c_char)
     -> device_t;
}
extern "C" {
    pub fn device_print_prettyname(dev: device_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn device_printf(dev: device_t,
                         arg1: *const ::kernel::sys::raw::c_char, ...)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn device_probe(dev: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn device_probe_and_attach(dev: device_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn device_probe_child(bus: device_t, dev: device_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn device_quiesce(dev: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn device_quiet(dev: device_t);
}
extern "C" {
    pub fn device_quiet_children(dev: device_t);
}
extern "C" {
    pub fn device_set_desc(dev: device_t,
                           desc: *const ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn device_set_desc_copy(dev: device_t,
                                desc: *const ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn device_set_devclass(dev: device_t,
                               classname: *const ::kernel::sys::raw::c_char)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn device_set_devclass_fixed(dev: device_t,
                                     classname:
                                         *const ::kernel::sys::raw::c_char)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn device_set_driver(dev: device_t, driver: *mut driver_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn device_set_flags(dev: device_t, flags: u_int32_t);
}
extern "C" {
    pub fn device_set_softc(dev: device_t,
                            softc: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn device_free_softc(softc: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn device_claim_softc(dev: device_t);
}
extern "C" {
    pub fn device_set_unit(dev: device_t, unit: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn device_shutdown(dev: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn device_unbusy(dev: device_t);
}
extern "C" {
    pub fn device_verbose(dev: device_t);
}
extern "C" {
    pub fn devclass_add_driver(dc: devclass_t, driver: *mut driver_t,
                               pass: ::kernel::sys::raw::c_int,
                               dcp: *mut devclass_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn devclass_create(classname: *const ::kernel::sys::raw::c_char)
     -> devclass_t;
}
extern "C" {
    pub fn devclass_delete_driver(busclass: devclass_t, driver: *mut driver_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn devclass_find(classname: *const ::kernel::sys::raw::c_char)
     -> devclass_t;
}
extern "C" {
    pub fn devclass_get_name(dc: devclass_t)
     -> *const ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn devclass_get_device(dc: devclass_t,
                               unit: ::kernel::sys::raw::c_int) -> device_t;
}
extern "C" {
    pub fn devclass_get_softc(dc: devclass_t, unit: ::kernel::sys::raw::c_int)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn devclass_get_devices(dc: devclass_t, listp: *mut *mut device_t,
                                countp: *mut ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn devclass_get_drivers(dc: devclass_t,
                                listp: *mut *mut *mut driver_t,
                                countp: *mut ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn devclass_get_count(dc: devclass_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn devclass_get_maxunit(dc: devclass_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn devclass_find_free_unit(dc: devclass_t,
                                   unit: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn devclass_set_parent(dc: devclass_t, pdc: devclass_t);
}
extern "C" {
    pub fn devclass_get_parent(dc: devclass_t) -> devclass_t;
}
extern "C" {
    pub fn devclass_get_sysctl_ctx(dc: devclass_t) -> *mut sysctl_ctx_list;
}
extern "C" {
    pub fn devclass_get_sysctl_tree(dc: devclass_t) -> *mut sysctl_oid;
}
extern "C" {
    pub fn resource_int_value(name: *const ::kernel::sys::raw::c_char,
                              unit: ::kernel::sys::raw::c_int,
                              resname: *const ::kernel::sys::raw::c_char,
                              result: *mut ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn resource_long_value(name: *const ::kernel::sys::raw::c_char,
                               unit: ::kernel::sys::raw::c_int,
                               resname: *const ::kernel::sys::raw::c_char,
                               result: *mut ::kernel::sys::raw::c_long)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn resource_string_value(name: *const ::kernel::sys::raw::c_char,
                                 unit: ::kernel::sys::raw::c_int,
                                 resname: *const ::kernel::sys::raw::c_char,
                                 result:
                                     *mut *const ::kernel::sys::raw::c_char)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn resource_disabled(name: *const ::kernel::sys::raw::c_char,
                             unit: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn resource_find_match(anchor: *mut ::kernel::sys::raw::c_int,
                               name: *mut *const ::kernel::sys::raw::c_char,
                               unit: *mut ::kernel::sys::raw::c_int,
                               resname: *const ::kernel::sys::raw::c_char,
                               value: *const ::kernel::sys::raw::c_char)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn resource_find_dev(anchor: *mut ::kernel::sys::raw::c_int,
                             name: *const ::kernel::sys::raw::c_char,
                             unit: *mut ::kernel::sys::raw::c_int,
                             resname: *const ::kernel::sys::raw::c_char,
                             value: *const ::kernel::sys::raw::c_char)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn resource_unset_value(name: *const ::kernel::sys::raw::c_char,
                                unit: ::kernel::sys::raw::c_int,
                                resname: *const ::kernel::sys::raw::c_char)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_data_generation_check(generation: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_data_generation_update();
}
extern "C" {
    #[link_name = "bus_current_pass"]
    pub static mut bus_current_pass: ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_set_pass(pass: ::kernel::sys::raw::c_int);
}
extern "C" {
    #[link_name = "device_probe_desc"]
    pub static mut device_probe_desc: kobjop_desc;
}
/// @brief A function implementing the DEVICE_PROBE() method
pub type device_probe_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "device_identify_desc"]
    pub static mut device_identify_desc: kobjop_desc;
}
/// @brief A function implementing the DEVICE_IDENTIFY() method
pub type device_identify_t =
    ::core::option::Option<unsafe extern "C" fn(driver: *mut driver_t,
                                                parent: device_t)>;
extern "C" {
    #[link_name = "device_attach_desc"]
    pub static mut device_attach_desc: kobjop_desc;
}
/// @brief A function implementing the DEVICE_ATTACH() method
pub type device_attach_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "device_detach_desc"]
    pub static mut device_detach_desc: kobjop_desc;
}
/// @brief A function implementing the DEVICE_DETACH() method
pub type device_detach_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "device_shutdown_desc"]
    pub static mut device_shutdown_desc: kobjop_desc;
}
/// @brief A function implementing the DEVICE_SHUTDOWN() method
pub type device_shutdown_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "device_suspend_desc"]
    pub static mut device_suspend_desc: kobjop_desc;
}
/// @brief A function implementing the DEVICE_SUSPEND() method
pub type device_suspend_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "device_resume_desc"]
    pub static mut device_resume_desc: kobjop_desc;
}
/// @brief A function implementing the DEVICE_RESUME() method
pub type device_resume_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "device_quiesce_desc"]
    pub static mut device_quiesce_desc: kobjop_desc;
}
/// @brief A function implementing the DEVICE_QUIESCE() method
pub type device_quiesce_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "device_register_desc"]
    pub static mut device_register_desc: kobjop_desc;
}
/// @brief A function implementing the DEVICE_REGISTER() method
pub type device_register_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t)
                               -> *mut ::kernel::sys::raw::c_void>;
extern "C" {
    #[link_name = "bus_print_child_desc"]
    pub static mut bus_print_child_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_PRINT_CHILD() method
pub type bus_print_child_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_probe_nomatch_desc"]
    pub static mut bus_probe_nomatch_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_PROBE_NOMATCH() method
pub type bus_probe_nomatch_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t)>;
extern "C" {
    #[link_name = "bus_read_ivar_desc"]
    pub static mut bus_read_ivar_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_READ_IVAR() method
pub type bus_read_ivar_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t,
                                                _index:
                                                    ::kernel::sys::raw::c_int,
                                                _result: *mut usize)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_write_ivar_desc"]
    pub static mut bus_write_ivar_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_WRITE_IVAR() method
pub type bus_write_ivar_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t,
                                                _indx:
                                                    ::kernel::sys::raw::c_int,
                                                _value: usize)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_child_deleted_desc"]
    pub static mut bus_child_deleted_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_CHILD_DELETED() method
pub type bus_child_deleted_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t)>;
extern "C" {
    #[link_name = "bus_child_detached_desc"]
    pub static mut bus_child_detached_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_CHILD_DETACHED() method
pub type bus_child_detached_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t)>;
extern "C" {
    #[link_name = "bus_driver_added_desc"]
    pub static mut bus_driver_added_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_DRIVER_ADDED() method
pub type bus_driver_added_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _driver: *mut driver_t)>;
extern "C" {
    #[link_name = "bus_add_child_desc"]
    pub static mut bus_add_child_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_ADD_CHILD() method
pub type bus_add_child_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t, _order: u_int,
                                                _name:
                                                    *const ::kernel::sys::raw::c_char,
                                                _unit:
                                                    ::kernel::sys::raw::c_int)
                               -> device_t>;
extern "C" {
    #[link_name = "bus_rescan_desc"]
    pub static mut bus_rescan_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_RESCAN() method
pub type bus_rescan_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_alloc_resource_desc"]
    pub static mut bus_alloc_resource_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_ALLOC_RESOURCE() method
pub type bus_alloc_resource_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t,
                                                _type:
                                                    ::kernel::sys::raw::c_int,
                                                _rid:
                                                    *mut ::kernel::sys::raw::c_int,
                                                _start: rman_res_t,
                                                _end: rman_res_t,
                                                _count: rman_res_t,
                                                _flags: u_int)
                               -> *mut resource>;
extern "C" {
    #[link_name = "bus_activate_resource_desc"]
    pub static mut bus_activate_resource_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_ACTIVATE_RESOURCE() method
pub type bus_activate_resource_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t,
                                                _type:
                                                    ::kernel::sys::raw::c_int,
                                                _rid:
                                                    ::kernel::sys::raw::c_int,
                                                _r: *mut resource)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_map_resource_desc"]
    pub static mut bus_map_resource_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_MAP_RESOURCE() method
pub type bus_map_resource_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t,
                                                _type:
                                                    ::kernel::sys::raw::c_int,
                                                _r: *mut resource,
                                                _args:
                                                    *mut resource_map_request,
                                                _map: *mut resource_map)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_unmap_resource_desc"]
    pub static mut bus_unmap_resource_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_UNMAP_RESOURCE() method
pub type bus_unmap_resource_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t,
                                                _type:
                                                    ::kernel::sys::raw::c_int,
                                                _r: *mut resource,
                                                _map: *mut resource_map)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_deactivate_resource_desc"]
    pub static mut bus_deactivate_resource_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_DEACTIVATE_RESOURCE() method
pub type bus_deactivate_resource_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t,
                                                _type:
                                                    ::kernel::sys::raw::c_int,
                                                _rid:
                                                    ::kernel::sys::raw::c_int,
                                                _r: *mut resource)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_adjust_resource_desc"]
    pub static mut bus_adjust_resource_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_ADJUST_RESOURCE() method
pub type bus_adjust_resource_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t,
                                                _type:
                                                    ::kernel::sys::raw::c_int,
                                                _res: *mut resource,
                                                _start: rman_res_t,
                                                _end: rman_res_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_release_resource_desc"]
    pub static mut bus_release_resource_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_RELEASE_RESOURCE() method
pub type bus_release_resource_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t,
                                                _type:
                                                    ::kernel::sys::raw::c_int,
                                                _rid:
                                                    ::kernel::sys::raw::c_int,
                                                _res: *mut resource)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_setup_intr_desc"]
    pub static mut bus_setup_intr_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_SETUP_INTR() method
pub type bus_setup_intr_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t,
                                                _irq: *mut resource,
                                                _flags:
                                                    ::kernel::sys::raw::c_int,
                                                _filter: driver_filter_t,
                                                _intr: driver_intr_t,
                                                _arg:
                                                    *mut ::kernel::sys::raw::c_void,
                                                _cookiep:
                                                    *mut *mut ::kernel::sys::raw::c_void)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_teardown_intr_desc"]
    pub static mut bus_teardown_intr_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_TEARDOWN_INTR() method
pub type bus_teardown_intr_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t,
                                                _irq: *mut resource,
                                                _cookie:
                                                    *mut ::kernel::sys::raw::c_void)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_set_resource_desc"]
    pub static mut bus_set_resource_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_SET_RESOURCE() method
pub type bus_set_resource_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t,
                                                _type:
                                                    ::kernel::sys::raw::c_int,
                                                _rid:
                                                    ::kernel::sys::raw::c_int,
                                                _start: rman_res_t,
                                                _count: rman_res_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_get_resource_desc"]
    pub static mut bus_get_resource_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_GET_RESOURCE() method
pub type bus_get_resource_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t,
                                                _type:
                                                    ::kernel::sys::raw::c_int,
                                                _rid:
                                                    ::kernel::sys::raw::c_int,
                                                _startp: *mut rman_res_t,
                                                _countp: *mut rman_res_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_delete_resource_desc"]
    pub static mut bus_delete_resource_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_DELETE_RESOURCE() method
pub type bus_delete_resource_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t,
                                                _type:
                                                    ::kernel::sys::raw::c_int,
                                                _rid:
                                                    ::kernel::sys::raw::c_int)>;
extern "C" {
    #[link_name = "bus_get_resource_list_desc"]
    pub static mut bus_get_resource_list_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_GET_RESOURCE_LIST() method
pub type bus_get_resource_list_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t)
                               -> *mut resource_list>;
extern "C" {
    #[link_name = "bus_child_present_desc"]
    pub static mut bus_child_present_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_CHILD_PRESENT() method
pub type bus_child_present_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_child_pnpinfo_str_desc"]
    pub static mut bus_child_pnpinfo_str_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_CHILD_PNPINFO_STR() method
pub type bus_child_pnpinfo_str_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t,
                                                _buf:
                                                    *mut ::kernel::sys::raw::c_char,
                                                _buflen: usize)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_child_location_str_desc"]
    pub static mut bus_child_location_str_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_CHILD_LOCATION_STR() method
pub type bus_child_location_str_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t,
                                                _buf:
                                                    *mut ::kernel::sys::raw::c_char,
                                                _buflen: usize)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_bind_intr_desc"]
    pub static mut bus_bind_intr_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_BIND_INTR() method
pub type bus_bind_intr_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t,
                                                _irq: *mut resource,
                                                _cpu:
                                                    ::kernel::sys::raw::c_int)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_config_intr_desc"]
    pub static mut bus_config_intr_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_CONFIG_INTR() method
pub type bus_config_intr_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _irq:
                                                    ::kernel::sys::raw::c_int,
                                                _trig: intr_trigger,
                                                _pol: intr_polarity)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_describe_intr_desc"]
    pub static mut bus_describe_intr_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_DESCRIBE_INTR() method
pub type bus_describe_intr_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t,
                                                _irq: *mut resource,
                                                _cookie:
                                                    *mut ::kernel::sys::raw::c_void,
                                                _descr:
                                                    *const ::kernel::sys::raw::c_char)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_hinted_child_desc"]
    pub static mut bus_hinted_child_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_HINTED_CHILD() method
pub type bus_hinted_child_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _dname:
                                                    *const ::kernel::sys::raw::c_char,
                                                _dunit:
                                                    ::kernel::sys::raw::c_int)>;
extern "C" {
    #[link_name = "bus_get_dma_tag_desc"]
    pub static mut bus_get_dma_tag_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_GET_DMA_TAG() method
pub type bus_get_dma_tag_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t)
                               -> bus_dma_tag_t>;
extern "C" {
    #[link_name = "bus_get_bus_tag_desc"]
    pub static mut bus_get_bus_tag_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_GET_BUS_TAG() method
pub type bus_get_bus_tag_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t)
                               -> bus_space_tag_t>;
extern "C" {
    #[link_name = "bus_hint_device_unit_desc"]
    pub static mut bus_hint_device_unit_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_HINT_DEVICE_UNIT() method
pub type bus_hint_device_unit_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t,
                                                _name:
                                                    *const ::kernel::sys::raw::c_char,
                                                _unitp:
                                                    *mut ::kernel::sys::raw::c_int)>;
extern "C" {
    #[link_name = "bus_new_pass_desc"]
    pub static mut bus_new_pass_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_NEW_PASS() method
pub type bus_new_pass_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t)>;
extern "C" {
    #[link_name = "bus_remap_intr_desc"]
    pub static mut bus_remap_intr_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_REMAP_INTR() method
pub type bus_remap_intr_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t, _irq: u_int)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_suspend_child_desc"]
    pub static mut bus_suspend_child_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_SUSPEND_CHILD() method
pub type bus_suspend_child_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_resume_child_desc"]
    pub static mut bus_resume_child_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_RESUME_CHILD() method
pub type bus_resume_child_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_get_domain_desc"]
    pub static mut bus_get_domain_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_GET_DOMAIN() method
pub type bus_get_domain_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t,
                                                _domain:
                                                    *mut ::kernel::sys::raw::c_int)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_get_cpus_desc"]
    pub static mut bus_get_cpus_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_GET_CPUS() method
pub type bus_get_cpus_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t,
                                                _op: cpu_sets,
                                                _setsize: usize,
                                                _cpuset: *mut cpuset_t)
                               -> ::kernel::sys::raw::c_int>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct module {
    _unused: [u8; 0],
}
extern "C" {
    pub fn driver_module_handler(arg1: *mut module,
                                 arg2: ::kernel::sys::raw::c_int,
                                 arg3: *mut ::kernel::sys::raw::c_void)
     -> ::kernel::sys::raw::c_int;
}
/// Module support for automatically adding drivers to buses.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct driver_module_data {
    pub dmd_chainevh: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut module,
                                                                  arg2:
                                                                      ::kernel::sys::raw::c_int,
                                                                  arg3:
                                                                      *mut ::kernel::sys::raw::c_void)
                                                 ->
                                                     ::kernel::sys::raw::c_int>,
    pub dmd_chainarg: *mut ::kernel::sys::raw::c_void,
    pub dmd_busname: *const ::kernel::sys::raw::c_char,
    pub dmd_driver: kobj_class_t,
    pub dmd_devclass: *mut devclass_t,
    pub dmd_pass: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_driver_module_data() {
    assert_eq!(::core::mem::size_of::<driver_module_data>() , 48usize , concat
               ! ( "Size of: " , stringify ! ( driver_module_data ) ));
    assert_eq! (::core::mem::align_of::<driver_module_data>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( driver_module_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const driver_module_data ) ) . dmd_chainevh as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( driver_module_data ) ,
                "::" , stringify ! ( dmd_chainevh ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const driver_module_data ) ) . dmd_chainarg as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( driver_module_data ) ,
                "::" , stringify ! ( dmd_chainarg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const driver_module_data ) ) . dmd_busname as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( driver_module_data ) ,
                "::" , stringify ! ( dmd_busname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const driver_module_data ) ) . dmd_driver as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( driver_module_data ) ,
                "::" , stringify ! ( dmd_driver ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const driver_module_data ) ) . dmd_devclass as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( driver_module_data ) ,
                "::" , stringify ! ( dmd_devclass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const driver_module_data ) ) . dmd_pass as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( driver_module_data ) ,
                "::" , stringify ! ( dmd_pass ) ));
}
impl Clone for driver_module_data {
    fn clone(&self) -> Self { *self }
}
impl Default for driver_module_data {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct setlist {
    pub lh_first: *mut cpuset,
}
#[test]
fn bindgen_test_layout_setlist() {
    assert_eq!(::core::mem::size_of::<setlist>() , 8usize , concat ! (
               "Size of: " , stringify ! ( setlist ) ));
    assert_eq! (::core::mem::align_of::<setlist>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( setlist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const setlist ) ) . lh_first as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( setlist ) , "::" ,
                stringify ! ( lh_first ) ));
}
impl Clone for setlist {
    fn clone(&self) -> Self { *self }
}
impl Default for setlist {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    #[link_name = "cpuset_root"]
    pub static mut cpuset_root: *mut cpuset_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct prison {
    _unused: [u8; 0],
}
extern "C" {
    pub fn cpuset_thread0() -> *mut cpuset;
}
extern "C" {
    pub fn cpuset_ref(arg1: *mut cpuset) -> *mut cpuset;
}
extern "C" {
    pub fn cpuset_rel(arg1: *mut cpuset);
}
extern "C" {
    pub fn cpuset_setthread(id: lwpid_t, arg1: *mut cpuset_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn cpuset_setithread(id: lwpid_t, cpu: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn cpuset_create_root(arg1: *mut prison, arg2: *mut *mut cpuset)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn cpuset_setproc_update_set(arg1: *mut proc_, arg2: *mut cpuset)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn cpuset_which(arg1: cpuwhich_t, arg2: id_t, arg3: *mut *mut proc_,
                        arg4: *mut *mut thread, arg5: *mut *mut cpuset)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn cpuset_kernthread(arg1: *mut thread);
}
extern "C" {
    pub fn cpusetobj_strprint(arg1: *mut ::kernel::sys::raw::c_char,
                              arg2: *const cpuset_t)
     -> *mut ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn cpusetobj_strscan(arg1: *mut cpuset_t,
                             arg2: *const ::kernel::sys::raw::c_char)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_space_map(tag: bus_space_tag_t, addr: bus_addr_t,
                         size: bus_size_t, flags: ::kernel::sys::raw::c_int,
                         bshp: *mut bus_space_handle_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_space_unmap(tag: bus_space_tag_t, bsh: bus_space_handle_t,
                           size: bus_size_t);
}
extern "C" {
    pub fn bus_space_alloc(t: bus_space_tag_t, rstart: bus_addr_t,
                           rend: bus_addr_t, size: bus_size_t,
                           align: bus_size_t, boundary: bus_size_t,
                           flags: ::kernel::sys::raw::c_int,
                           addrp: *mut bus_addr_t,
                           bshp: *mut bus_space_handle_t)
     -> ::kernel::sys::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ccb {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bio {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct memdesc {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pmap {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct bus_dma_segment {
    pub ds_addr: bus_addr_t,
    pub ds_len: bus_size_t,
}
#[test]
fn bindgen_test_layout_bus_dma_segment() {
    assert_eq!(::core::mem::size_of::<bus_dma_segment>() , 16usize , concat !
               ( "Size of: " , stringify ! ( bus_dma_segment ) ));
    assert_eq! (::core::mem::align_of::<bus_dma_segment>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( bus_dma_segment ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_segment ) ) . ds_addr as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_segment ) ,
                "::" , stringify ! ( ds_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_segment ) ) . ds_len as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_segment ) ,
                "::" , stringify ! ( ds_len ) ));
}
impl Clone for bus_dma_segment {
    fn clone(&self) -> Self { *self }
}
pub type bus_dma_segment_t = bus_dma_segment;
pub type bus_dma_filter_t =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: bus_addr_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    pub fn busdma_lock_mutex(arg: *mut ::kernel::sys::raw::c_void,
                             op: bus_dma_lock_op_t);
}
extern "C" {
    pub fn bus_dma_tag_create(parent: bus_dma_tag_t, alignment: bus_size_t,
                              boundary: bus_addr_t, lowaddr: bus_addr_t,
                              highaddr: bus_addr_t,
                              filtfunc: bus_dma_filter_t,
                              filtfuncarg: *mut ::kernel::sys::raw::c_void,
                              maxsize: bus_size_t,
                              nsegments: ::kernel::sys::raw::c_int,
                              maxsegsz: bus_size_t,
                              flags: ::kernel::sys::raw::c_int,
                              lockfunc: bus_dma_lock_t,
                              lockfuncarg: *mut ::kernel::sys::raw::c_void,
                              dmat: *mut bus_dma_tag_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_dma_tag_set_domain(dmat: bus_dma_tag_t,
                                  domain: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_dma_tag_destroy(dmat: bus_dma_tag_t)
     -> ::kernel::sys::raw::c_int;
}
pub type bus_dmamap_callback_t =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut bus_dma_segment_t,
                                                arg3:
                                                    ::kernel::sys::raw::c_int,
                                                arg4:
                                                    ::kernel::sys::raw::c_int)>;
pub type bus_dmamap_callback2_t =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut bus_dma_segment_t,
                                                arg3:
                                                    ::kernel::sys::raw::c_int,
                                                arg4: bus_size_t,
                                                arg5:
                                                    ::kernel::sys::raw::c_int)>;
extern "C" {
    pub fn bus_dmamap_load(dmat: bus_dma_tag_t, map: bus_dmamap_t,
                           buf: *mut ::kernel::sys::raw::c_void,
                           buflen: bus_size_t,
                           callback: bus_dmamap_callback_t,
                           callback_arg: *mut ::kernel::sys::raw::c_void,
                           flags: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_dmamap_load_mbuf(dmat: bus_dma_tag_t, map: bus_dmamap_t,
                                mbuf: *mut mbuf,
                                callback: bus_dmamap_callback2_t,
                                callback_arg: *mut ::kernel::sys::raw::c_void,
                                flags: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_dmamap_load_mbuf_sg(dmat: bus_dma_tag_t, map: bus_dmamap_t,
                                   mbuf: *mut mbuf,
                                   segs: *mut bus_dma_segment_t,
                                   nsegs: *mut ::kernel::sys::raw::c_int,
                                   flags: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_dmamap_load_uio(dmat: bus_dma_tag_t, map: bus_dmamap_t,
                               ui: *mut uio, callback: bus_dmamap_callback2_t,
                               callback_arg: *mut ::kernel::sys::raw::c_void,
                               flags: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_dmamap_load_ccb(dmat: bus_dma_tag_t, map: bus_dmamap_t,
                               ccb: *mut ccb, callback: bus_dmamap_callback_t,
                               callback_arg: *mut ::kernel::sys::raw::c_void,
                               flags: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_dmamap_load_bio(dmat: bus_dma_tag_t, map: bus_dmamap_t,
                               bio: *mut bio, callback: bus_dmamap_callback_t,
                               callback_arg: *mut ::kernel::sys::raw::c_void,
                               flags: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_dmamap_load_mem(dmat: bus_dma_tag_t, map: bus_dmamap_t,
                               mem: *mut memdesc,
                               callback: bus_dmamap_callback_t,
                               callback_arg: *mut ::kernel::sys::raw::c_void,
                               flags: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_dmamap_load_ma_triv(dmat: bus_dma_tag_t, map: bus_dmamap_t,
                                   ma: *mut *mut vm_page, tlen: bus_size_t,
                                   ma_offs: ::kernel::sys::raw::c_int,
                                   flags: ::kernel::sys::raw::c_int,
                                   segs: *mut bus_dma_segment_t,
                                   segp: *mut ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct bus_dma_tag_common {
    pub impl_: *mut bus_dma_impl,
    pub parent: *mut bus_dma_tag_common,
    pub alignment: bus_size_t,
    pub boundary: bus_addr_t,
    pub lowaddr: bus_addr_t,
    pub highaddr: bus_addr_t,
    pub filter: bus_dma_filter_t,
    pub filterarg: *mut ::kernel::sys::raw::c_void,
    pub maxsize: bus_size_t,
    pub nsegments: u_int,
    pub maxsegsz: bus_size_t,
    pub flags: ::kernel::sys::raw::c_int,
    pub lockfunc: bus_dma_lock_t,
    pub lockfuncarg: *mut ::kernel::sys::raw::c_void,
    pub ref_count: ::kernel::sys::raw::c_int,
    pub domain: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_bus_dma_tag_common() {
    assert_eq!(::core::mem::size_of::<bus_dma_tag_common>() , 120usize ,
               concat ! ( "Size of: " , stringify ! ( bus_dma_tag_common ) ));
    assert_eq! (::core::mem::align_of::<bus_dma_tag_common>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( bus_dma_tag_common ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_tag_common ) ) . impl_ as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_tag_common ) ,
                "::" , stringify ! ( impl_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_tag_common ) ) . parent as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_tag_common ) ,
                "::" , stringify ! ( parent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_tag_common ) ) . alignment as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_tag_common ) ,
                "::" , stringify ! ( alignment ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_tag_common ) ) . boundary as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_tag_common ) ,
                "::" , stringify ! ( boundary ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_tag_common ) ) . lowaddr as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_tag_common ) ,
                "::" , stringify ! ( lowaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_tag_common ) ) . highaddr as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_tag_common ) ,
                "::" , stringify ! ( highaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_tag_common ) ) . filter as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_tag_common ) ,
                "::" , stringify ! ( filter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_tag_common ) ) . filterarg as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_tag_common ) ,
                "::" , stringify ! ( filterarg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_tag_common ) ) . maxsize as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_tag_common ) ,
                "::" , stringify ! ( maxsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_tag_common ) ) . nsegments as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_tag_common ) ,
                "::" , stringify ! ( nsegments ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_tag_common ) ) . maxsegsz as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_tag_common ) ,
                "::" , stringify ! ( maxsegsz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_tag_common ) ) . flags as * const
                _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_tag_common ) ,
                "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_tag_common ) ) . lockfunc as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_tag_common ) ,
                "::" , stringify ! ( lockfunc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_tag_common ) ) . lockfuncarg as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_tag_common ) ,
                "::" , stringify ! ( lockfuncarg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_tag_common ) ) . ref_count as *
                const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_tag_common ) ,
                "::" , stringify ! ( ref_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_tag_common ) ) . domain as *
                const _ as usize } , 116usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_tag_common ) ,
                "::" , stringify ! ( domain ) ));
}
impl Clone for bus_dma_tag_common {
    fn clone(&self) -> Self { *self }
}
impl Default for bus_dma_tag_common {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct bus_dma_impl {
    pub tag_create: ::core::option::Option<unsafe extern "C" fn(parent:
                                                                    bus_dma_tag_t,
                                                                alignment:
                                                                    bus_size_t,
                                                                boundary:
                                                                    bus_addr_t,
                                                                lowaddr:
                                                                    bus_addr_t,
                                                                highaddr:
                                                                    bus_addr_t,
                                                                filter:
                                                                    bus_dma_filter_t,
                                                                filterarg:
                                                                    *mut ::kernel::sys::raw::c_void,
                                                                maxsize:
                                                                    bus_size_t,
                                                                nsegments:
                                                                    ::kernel::sys::raw::c_int,
                                                                maxsegsz:
                                                                    bus_size_t,
                                                                flags:
                                                                    ::kernel::sys::raw::c_int,
                                                                lockfunc:
                                                                    bus_dma_lock_t,
                                                                lockfuncarg:
                                                                    *mut ::kernel::sys::raw::c_void,
                                                                dmat:
                                                                    *mut bus_dma_tag_t)
                                               -> ::kernel::sys::raw::c_int>,
    pub tag_destroy: ::core::option::Option<unsafe extern "C" fn(dmat:
                                                                     bus_dma_tag_t)
                                                -> ::kernel::sys::raw::c_int>,
    pub tag_set_domain: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                        bus_dma_tag_t)
                                                   ->
                                                       ::kernel::sys::raw::c_int>,
    pub map_create: ::core::option::Option<unsafe extern "C" fn(dmat:
                                                                    bus_dma_tag_t,
                                                                flags:
                                                                    ::kernel::sys::raw::c_int,
                                                                mapp:
                                                                    *mut bus_dmamap_t)
                                               -> ::kernel::sys::raw::c_int>,
    pub map_destroy: ::core::option::Option<unsafe extern "C" fn(dmat:
                                                                     bus_dma_tag_t,
                                                                 map:
                                                                     bus_dmamap_t)
                                                -> ::kernel::sys::raw::c_int>,
    pub mem_alloc: ::core::option::Option<unsafe extern "C" fn(dmat:
                                                                   bus_dma_tag_t,
                                                               vaddr:
                                                                   *mut *mut ::kernel::sys::raw::c_void,
                                                               flags:
                                                                   ::kernel::sys::raw::c_int,
                                                               mapp:
                                                                   *mut bus_dmamap_t)
                                              -> ::kernel::sys::raw::c_int>,
    pub mem_free: ::core::option::Option<unsafe extern "C" fn(dmat:
                                                                  bus_dma_tag_t,
                                                              vaddr:
                                                                  *mut ::kernel::sys::raw::c_void,
                                                              map:
                                                                  bus_dmamap_t)>,
    pub load_ma: ::core::option::Option<unsafe extern "C" fn(dmat:
                                                                 bus_dma_tag_t,
                                                             map:
                                                                 bus_dmamap_t,
                                                             ma:
                                                                 *mut *mut vm_page,
                                                             tlen: bus_size_t,
                                                             ma_offs:
                                                                 ::kernel::sys::raw::c_int,
                                                             flags:
                                                                 ::kernel::sys::raw::c_int,
                                                             segs:
                                                                 *mut bus_dma_segment_t,
                                                             segp:
                                                                 *mut ::kernel::sys::raw::c_int)
                                            -> ::kernel::sys::raw::c_int>,
    pub load_phys: ::core::option::Option<unsafe extern "C" fn(dmat:
                                                                   bus_dma_tag_t,
                                                               map:
                                                                   bus_dmamap_t,
                                                               buf:
                                                                   vm_paddr_t,
                                                               buflen:
                                                                   bus_size_t,
                                                               flags:
                                                                   ::kernel::sys::raw::c_int,
                                                               segs:
                                                                   *mut bus_dma_segment_t,
                                                               segp:
                                                                   *mut ::kernel::sys::raw::c_int)
                                              -> ::kernel::sys::raw::c_int>,
    pub load_buffer: ::core::option::Option<unsafe extern "C" fn(dmat:
                                                                     bus_dma_tag_t,
                                                                 map:
                                                                     bus_dmamap_t,
                                                                 buf:
                                                                     *mut ::kernel::sys::raw::c_void,
                                                                 buflen:
                                                                     bus_size_t,
                                                                 pmap:
                                                                     *mut pmap,
                                                                 flags:
                                                                     ::kernel::sys::raw::c_int,
                                                                 segs:
                                                                     *mut bus_dma_segment_t,
                                                                 segp:
                                                                     *mut ::kernel::sys::raw::c_int)
                                                -> ::kernel::sys::raw::c_int>,
    pub map_waitok: ::core::option::Option<unsafe extern "C" fn(dmat:
                                                                    bus_dma_tag_t,
                                                                map:
                                                                    bus_dmamap_t,
                                                                mem:
                                                                    *mut memdesc,
                                                                callback:
                                                                    bus_dmamap_callback_t,
                                                                callback_arg:
                                                                    *mut ::kernel::sys::raw::c_void)>,
    pub map_complete: ::core::option::Option<unsafe extern "C" fn(dmat:
                                                                      bus_dma_tag_t,
                                                                  map:
                                                                      bus_dmamap_t,
                                                                  segs:
                                                                      *mut bus_dma_segment_t,
                                                                  nsegs:
                                                                      ::kernel::sys::raw::c_int,
                                                                  error:
                                                                      ::kernel::sys::raw::c_int)
                                                 -> *mut bus_dma_segment_t>,
    pub map_unload: ::core::option::Option<unsafe extern "C" fn(dmat:
                                                                    bus_dma_tag_t,
                                                                map:
                                                                    bus_dmamap_t)>,
    pub map_sync: ::core::option::Option<unsafe extern "C" fn(dmat:
                                                                  bus_dma_tag_t,
                                                              map:
                                                                  bus_dmamap_t,
                                                              op:
                                                                  bus_dmasync_op_t)>,
}
#[test]
fn bindgen_test_layout_bus_dma_impl() {
    assert_eq!(::core::mem::size_of::<bus_dma_impl>() , 112usize , concat ! (
               "Size of: " , stringify ! ( bus_dma_impl ) ));
    assert_eq! (::core::mem::align_of::<bus_dma_impl>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( bus_dma_impl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_impl ) ) . tag_create as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_impl ) , "::" ,
                stringify ! ( tag_create ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_impl ) ) . tag_destroy as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_impl ) , "::" ,
                stringify ! ( tag_destroy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_impl ) ) . tag_set_domain as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_impl ) , "::" ,
                stringify ! ( tag_set_domain ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_impl ) ) . map_create as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_impl ) , "::" ,
                stringify ! ( map_create ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_impl ) ) . map_destroy as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_impl ) , "::" ,
                stringify ! ( map_destroy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_impl ) ) . mem_alloc as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_impl ) , "::" ,
                stringify ! ( mem_alloc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_impl ) ) . mem_free as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_impl ) , "::" ,
                stringify ! ( mem_free ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_impl ) ) . load_ma as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_impl ) , "::" ,
                stringify ! ( load_ma ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_impl ) ) . load_phys as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_impl ) , "::" ,
                stringify ! ( load_phys ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_impl ) ) . load_buffer as * const
                _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_impl ) , "::" ,
                stringify ! ( load_buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_impl ) ) . map_waitok as * const
                _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_impl ) , "::" ,
                stringify ! ( map_waitok ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_impl ) ) . map_complete as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_impl ) , "::" ,
                stringify ! ( map_complete ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_impl ) ) . map_unload as * const
                _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_impl ) , "::" ,
                stringify ! ( map_unload ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_impl ) ) . map_sync as * const _
                as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_impl ) , "::" ,
                stringify ! ( map_sync ) ));
}
impl Clone for bus_dma_impl {
    fn clone(&self) -> Self { *self }
}
impl Default for bus_dma_impl {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for bus_dma_impl {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "bus_dma_impl {{ tag_create: FunctionPointer, tag_destroy: {:?}, tag_set_domain: {:?}, map_create: {:?}, map_destroy: {:?}, mem_alloc: {:?}, mem_free: {:?}, load_ma: {:?}, load_phys: {:?}, load_buffer: {:?}, map_waitok: {:?}, map_complete: {:?}, map_unload: {:?}, map_sync: {:?} }}"
               , self . tag_destroy , self . tag_set_domain , self .
               map_create , self . map_destroy , self . mem_alloc , self .
               mem_free , self . load_ma , self . load_phys , self .
               load_buffer , self . map_waitok , self . map_complete , self .
               map_unload , self . map_sync)
    }
}
extern "C" {
    pub fn bus_dma_dflt_lock(arg: *mut ::kernel::sys::raw::c_void,
                             op: bus_dma_lock_op_t);
}
extern "C" {
    pub fn bus_dma_run_filter(dmat: *mut bus_dma_tag_common,
                              paddr: bus_addr_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn common_bus_dma_tag_create(parent: *mut bus_dma_tag_common,
                                     alignment: bus_size_t,
                                     boundary: bus_addr_t,
                                     lowaddr: bus_addr_t,
                                     highaddr: bus_addr_t,
                                     filter: bus_dma_filter_t,
                                     filterarg:
                                         *mut ::kernel::sys::raw::c_void,
                                     maxsize: bus_size_t,
                                     nsegments: ::kernel::sys::raw::c_int,
                                     maxsegsz: bus_size_t,
                                     flags: ::kernel::sys::raw::c_int,
                                     lockfunc: bus_dma_lock_t,
                                     lockfuncarg:
                                         *mut ::kernel::sys::raw::c_void,
                                     sz: usize,
                                     dmat:
                                         *mut *mut ::kernel::sys::raw::c_void)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "bus_dma_bounce_impl"]
    pub static mut bus_dma_bounce_impl: bus_dma_impl;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvlist {
    _unused: [u8; 0],
}
pub type nvlist_t = nvlist;
extern "C" {
    #[link_name = "M_NVLIST"]
    pub static mut M_NVLIST: [malloc_type; 1usize];
}
extern "C" {
    pub fn nvlist_create(flags: ::kernel::sys::raw::c_int) -> *mut nvlist_t;
}
extern "C" {
    pub fn nvlist_destroy(nvl: *mut nvlist_t);
}
extern "C" {
    pub fn nvlist_error(nvl: *const nvlist_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn nvlist_empty(nvl: *const nvlist_t) -> bool_;
}
extern "C" {
    pub fn nvlist_flags(nvl: *const nvlist_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn nvlist_set_error(nvl: *mut nvlist_t,
                            error: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn nvlist_clone(nvl: *const nvlist_t) -> *mut nvlist_t;
}
extern "C" {
    pub fn nvlist_size(nvl: *const nvlist_t) -> usize;
}
extern "C" {
    pub fn nvlist_pack(nvl: *const nvlist_t, sizep: *mut usize)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn nvlist_unpack(buf: *const ::kernel::sys::raw::c_void, size: usize,
                         flags: ::kernel::sys::raw::c_int) -> *mut nvlist_t;
}
extern "C" {
    pub fn nvlist_send(sock: ::kernel::sys::raw::c_int, nvl: *const nvlist_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn nvlist_recv(sock: ::kernel::sys::raw::c_int,
                       flags: ::kernel::sys::raw::c_int) -> *mut nvlist_t;
}
extern "C" {
    pub fn nvlist_xfer(sock: ::kernel::sys::raw::c_int, nvl: *mut nvlist_t,
                       flags: ::kernel::sys::raw::c_int) -> *mut nvlist_t;
}
extern "C" {
    pub fn nvlist_next(nvl: *const nvlist_t,
                       typep: *mut ::kernel::sys::raw::c_int,
                       cookiep: *mut *mut ::kernel::sys::raw::c_void)
     -> *const ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn nvlist_get_parent(nvl: *const nvlist_t,
                             cookiep: *mut *mut ::kernel::sys::raw::c_void)
     -> *const nvlist_t;
}
extern "C" {
    pub fn nvlist_get_array_next(nvl: *const nvlist_t) -> *const nvlist_t;
}
extern "C" {
    pub fn nvlist_in_array(nvl: *const nvlist_t) -> bool_;
}
extern "C" {
    pub fn nvlist_get_pararr(nvl: *const nvlist_t,
                             cookiep: *mut *mut ::kernel::sys::raw::c_void)
     -> *const nvlist_t;
}
extern "C" {
    pub fn nvlist_exists(nvl: *const nvlist_t,
                         name: *const ::kernel::sys::raw::c_char) -> bool_;
}
extern "C" {
    pub fn nvlist_exists_type(nvl: *const nvlist_t,
                              name: *const ::kernel::sys::raw::c_char,
                              type_: ::kernel::sys::raw::c_int) -> bool_;
}
extern "C" {
    pub fn nvlist_exists_null(nvl: *const nvlist_t,
                              name: *const ::kernel::sys::raw::c_char)
     -> bool_;
}
extern "C" {
    pub fn nvlist_exists_bool(nvl: *const nvlist_t,
                              name: *const ::kernel::sys::raw::c_char)
     -> bool_;
}
extern "C" {
    pub fn nvlist_exists_number(nvl: *const nvlist_t,
                                name: *const ::kernel::sys::raw::c_char)
     -> bool_;
}
extern "C" {
    pub fn nvlist_exists_string(nvl: *const nvlist_t,
                                name: *const ::kernel::sys::raw::c_char)
     -> bool_;
}
extern "C" {
    pub fn nvlist_exists_nvlist(nvl: *const nvlist_t,
                                name: *const ::kernel::sys::raw::c_char)
     -> bool_;
}
extern "C" {
    pub fn nvlist_exists_binary(nvl: *const nvlist_t,
                                name: *const ::kernel::sys::raw::c_char)
     -> bool_;
}
extern "C" {
    pub fn nvlist_exists_bool_array(nvl: *const nvlist_t,
                                    name: *const ::kernel::sys::raw::c_char)
     -> bool_;
}
extern "C" {
    pub fn nvlist_exists_number_array(nvl: *const nvlist_t,
                                      name: *const ::kernel::sys::raw::c_char)
     -> bool_;
}
extern "C" {
    pub fn nvlist_exists_string_array(nvl: *const nvlist_t,
                                      name: *const ::kernel::sys::raw::c_char)
     -> bool_;
}
extern "C" {
    pub fn nvlist_exists_nvlist_array(nvl: *const nvlist_t,
                                      name: *const ::kernel::sys::raw::c_char)
     -> bool_;
}
extern "C" {
    pub fn nvlist_add_null(nvl: *mut nvlist_t,
                           name: *const ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn nvlist_add_bool(nvl: *mut nvlist_t,
                           name: *const ::kernel::sys::raw::c_char,
                           value: bool_);
}
extern "C" {
    pub fn nvlist_add_number(nvl: *mut nvlist_t,
                             name: *const ::kernel::sys::raw::c_char,
                             value: u64);
}
extern "C" {
    pub fn nvlist_add_string(nvl: *mut nvlist_t,
                             name: *const ::kernel::sys::raw::c_char,
                             value: *const ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn nvlist_add_stringf(nvl: *mut nvlist_t,
                              name: *const ::kernel::sys::raw::c_char,
                              valuefmt:
                                  *const ::kernel::sys::raw::c_char, ...);
}
extern "C" {
    pub fn nvlist_add_nvlist(nvl: *mut nvlist_t,
                             name: *const ::kernel::sys::raw::c_char,
                             value: *const nvlist_t);
}
extern "C" {
    pub fn nvlist_add_binary(nvl: *mut nvlist_t,
                             name: *const ::kernel::sys::raw::c_char,
                             value: *const ::kernel::sys::raw::c_void,
                             size: usize);
}
extern "C" {
    pub fn nvlist_add_bool_array(nvl: *mut nvlist_t,
                                 name: *const ::kernel::sys::raw::c_char,
                                 value: *const bool_, nitems: usize);
}
extern "C" {
    pub fn nvlist_add_number_array(nvl: *mut nvlist_t,
                                   name: *const ::kernel::sys::raw::c_char,
                                   value: *const u64, nitems: usize);
}
extern "C" {
    pub fn nvlist_add_string_array(nvl: *mut nvlist_t,
                                   name: *const ::kernel::sys::raw::c_char,
                                   value:
                                       *const *const ::kernel::sys::raw::c_char,
                                   nitems: usize);
}
extern "C" {
    pub fn nvlist_add_nvlist_array(nvl: *mut nvlist_t,
                                   name: *const ::kernel::sys::raw::c_char,
                                   value: *const *const nvlist_t,
                                   nitems: usize);
}
extern "C" {
    pub fn nvlist_move_string(nvl: *mut nvlist_t,
                              name: *const ::kernel::sys::raw::c_char,
                              value: *mut ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn nvlist_move_nvlist(nvl: *mut nvlist_t,
                              name: *const ::kernel::sys::raw::c_char,
                              value: *mut nvlist_t);
}
extern "C" {
    pub fn nvlist_move_binary(nvl: *mut nvlist_t,
                              name: *const ::kernel::sys::raw::c_char,
                              value: *mut ::kernel::sys::raw::c_void,
                              size: usize);
}
extern "C" {
    pub fn nvlist_move_bool_array(nvl: *mut nvlist_t,
                                  name: *const ::kernel::sys::raw::c_char,
                                  value: *mut bool_, nitems: usize);
}
extern "C" {
    pub fn nvlist_move_string_array(nvl: *mut nvlist_t,
                                    name: *const ::kernel::sys::raw::c_char,
                                    value:
                                        *mut *mut ::kernel::sys::raw::c_char,
                                    nitems: usize);
}
extern "C" {
    pub fn nvlist_move_nvlist_array(nvl: *mut nvlist_t,
                                    name: *const ::kernel::sys::raw::c_char,
                                    value: *mut *mut nvlist_t, nitems: usize);
}
extern "C" {
    pub fn nvlist_move_number_array(nvl: *mut nvlist_t,
                                    name: *const ::kernel::sys::raw::c_char,
                                    value: *mut u64, nitems: usize);
}
extern "C" {
    pub fn nvlist_get_bool(nvl: *const nvlist_t,
                           name: *const ::kernel::sys::raw::c_char) -> bool_;
}
extern "C" {
    pub fn nvlist_get_number(nvl: *const nvlist_t,
                             name: *const ::kernel::sys::raw::c_char) -> u64;
}
extern "C" {
    pub fn nvlist_get_string(nvl: *const nvlist_t,
                             name: *const ::kernel::sys::raw::c_char)
     -> *const ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn nvlist_get_nvlist(nvl: *const nvlist_t,
                             name: *const ::kernel::sys::raw::c_char)
     -> *const nvlist_t;
}
extern "C" {
    pub fn nvlist_get_binary(nvl: *const nvlist_t,
                             name: *const ::kernel::sys::raw::c_char,
                             sizep: *mut usize)
     -> *const ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn nvlist_get_bool_array(nvl: *const nvlist_t,
                                 name: *const ::kernel::sys::raw::c_char,
                                 nitemsp: *mut usize) -> *const bool_;
}
extern "C" {
    pub fn nvlist_get_number_array(nvl: *const nvlist_t,
                                   name: *const ::kernel::sys::raw::c_char,
                                   nitemsp: *mut usize) -> *const u64;
}
extern "C" {
    pub fn nvlist_get_string_array(nvl: *const nvlist_t,
                                   name: *const ::kernel::sys::raw::c_char,
                                   nitemsp: *mut usize)
     -> *const *const ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn nvlist_get_nvlist_array(nvl: *const nvlist_t,
                                   name: *const ::kernel::sys::raw::c_char,
                                   nitemsp: *mut usize)
     -> *const *const nvlist_t;
}
extern "C" {
    pub fn nvlist_take_bool(nvl: *mut nvlist_t,
                            name: *const ::kernel::sys::raw::c_char) -> bool_;
}
extern "C" {
    pub fn nvlist_take_number(nvl: *mut nvlist_t,
                              name: *const ::kernel::sys::raw::c_char) -> u64;
}
extern "C" {
    pub fn nvlist_take_string(nvl: *mut nvlist_t,
                              name: *const ::kernel::sys::raw::c_char)
     -> *mut ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn nvlist_take_nvlist(nvl: *mut nvlist_t,
                              name: *const ::kernel::sys::raw::c_char)
     -> *mut nvlist_t;
}
extern "C" {
    pub fn nvlist_take_binary(nvl: *mut nvlist_t,
                              name: *const ::kernel::sys::raw::c_char,
                              sizep: *mut usize)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn nvlist_take_bool_array(nvl: *mut nvlist_t,
                                  name: *const ::kernel::sys::raw::c_char,
                                  nitemsp: *mut usize) -> *mut bool_;
}
extern "C" {
    pub fn nvlist_take_number_array(nvl: *mut nvlist_t,
                                    name: *const ::kernel::sys::raw::c_char,
                                    nitemsp: *mut usize) -> *mut u64;
}
extern "C" {
    pub fn nvlist_take_string_array(nvl: *mut nvlist_t,
                                    name: *const ::kernel::sys::raw::c_char,
                                    nitemsp: *mut usize)
     -> *mut *mut ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn nvlist_take_nvlist_array(nvl: *mut nvlist_t,
                                    name: *const ::kernel::sys::raw::c_char,
                                    nitemsp: *mut usize)
     -> *mut *mut nvlist_t;
}
extern "C" {
    pub fn nvlist_free(nvl: *mut nvlist_t,
                       name: *const ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn nvlist_free_type(nvl: *mut nvlist_t,
                            name: *const ::kernel::sys::raw::c_char,
                            type_: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn nvlist_free_null(nvl: *mut nvlist_t,
                            name: *const ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn nvlist_free_bool(nvl: *mut nvlist_t,
                            name: *const ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn nvlist_free_number(nvl: *mut nvlist_t,
                              name: *const ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn nvlist_free_string(nvl: *mut nvlist_t,
                              name: *const ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn nvlist_free_nvlist(nvl: *mut nvlist_t,
                              name: *const ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn nvlist_free_binary(nvl: *mut nvlist_t,
                              name: *const ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn nvlist_free_bool_array(nvl: *mut nvlist_t,
                                  name: *const ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn nvlist_free_number_array(nvl: *mut nvlist_t,
                                    name: *const ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn nvlist_free_string_array(nvl: *mut nvlist_t,
                                    name: *const ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn nvlist_free_nvlist_array(nvl: *mut nvlist_t,
                                    name: *const ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn nvlist_free_binary_array(nvl: *mut nvlist_t,
                                    name: *const ::kernel::sys::raw::c_char);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct taskqueue {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct taskqgroup {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy)]
pub struct timeout_task {
    pub q: *mut taskqueue,
    pub t: task,
    pub c: callout,
    pub f: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_timeout_task() {
    assert_eq!(::core::mem::size_of::<timeout_task>() , 112usize , concat ! (
               "Size of: " , stringify ! ( timeout_task ) ));
    assert_eq! (::core::mem::align_of::<timeout_task>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timeout_task ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeout_task ) ) . q as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timeout_task ) , "::" ,
                stringify ! ( q ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeout_task ) ) . t as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timeout_task ) , "::" ,
                stringify ! ( t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeout_task ) ) . c as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( timeout_task ) , "::" ,
                stringify ! ( c ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeout_task ) ) . f as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( timeout_task ) , "::" ,
                stringify ! ( f ) ));
}
impl Clone for timeout_task {
    fn clone(&self) -> Self { *self }
}
impl Default for timeout_task {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for timeout_task {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "timeout_task {{ q: {:?}, t: {:?}, c: {:?}, f: {:?} }}" ,
               self . q , self . t , self . c , self . f)
    }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum taskqueue_callback_type {
    TASKQUEUE_CALLBACK_TYPE_INIT = 0,
    TASKQUEUE_CALLBACK_TYPE_SHUTDOWN = 1,
}
pub type taskqueue_callback_fn =
    ::core::option::Option<unsafe extern "C" fn(context:
                                                    *mut ::kernel::sys::raw::c_void)>;
pub type taskqueue_enqueue_fn =
    ::core::option::Option<unsafe extern "C" fn(context:
                                                    *mut ::kernel::sys::raw::c_void)>;
extern "C" {
    pub fn taskqueue_create(name: *const ::kernel::sys::raw::c_char,
                            mflags: ::kernel::sys::raw::c_int,
                            enqueue: taskqueue_enqueue_fn,
                            context: *mut ::kernel::sys::raw::c_void)
     -> *mut taskqueue;
}
extern "C" {
    pub fn taskqueue_start_threads(tqp: *mut *mut taskqueue,
                                   count: ::kernel::sys::raw::c_int,
                                   pri: ::kernel::sys::raw::c_int,
                                   name:
                                       *const ::kernel::sys::raw::c_char, ...)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn taskqueue_start_threads_cpuset(tqp: *mut *mut taskqueue,
                                          count: ::kernel::sys::raw::c_int,
                                          pri: ::kernel::sys::raw::c_int,
                                          mask: *mut cpuset_t,
                                          name:
                                              *const ::kernel::sys::raw::c_char, ...)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn taskqueue_enqueue(queue: *mut taskqueue, task: *mut task)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn taskqueue_enqueue_timeout(queue: *mut taskqueue,
                                     timeout_task: *mut timeout_task,
                                     ticks: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn taskqueue_enqueue_timeout_sbt(queue: *mut taskqueue,
                                         timeout_task: *mut timeout_task,
                                         sbt: sbintime_t, pr: sbintime_t,
                                         flags: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn taskqueue_poll_is_busy(queue: *mut taskqueue, task: *mut task)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn taskqueue_cancel(queue: *mut taskqueue, task: *mut task,
                            pendp: *mut u_int) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn taskqueue_cancel_timeout(queue: *mut taskqueue,
                                    timeout_task: *mut timeout_task,
                                    pendp: *mut u_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn taskqueue_drain(queue: *mut taskqueue, task: *mut task);
}
extern "C" {
    pub fn taskqueue_drain_timeout(queue: *mut taskqueue,
                                   timeout_task: *mut timeout_task);
}
extern "C" {
    pub fn taskqueue_drain_all(queue: *mut taskqueue);
}
extern "C" {
    pub fn taskqueue_free(queue: *mut taskqueue);
}
extern "C" {
    pub fn taskqueue_run(queue: *mut taskqueue);
}
extern "C" {
    pub fn taskqueue_block(queue: *mut taskqueue);
}
extern "C" {
    pub fn taskqueue_unblock(queue: *mut taskqueue);
}
extern "C" {
    pub fn taskqueue_member(queue: *mut taskqueue, td: *mut thread)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn taskqueue_set_callback(queue: *mut taskqueue,
                                  cb_type: taskqueue_callback_type,
                                  callback: taskqueue_callback_fn,
                                  context: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn taskqueue_thread_loop(arg: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn taskqueue_thread_enqueue(context: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn _timeout_task_init(queue: *mut taskqueue,
                              timeout_task: *mut timeout_task,
                              priority: ::kernel::sys::raw::c_int,
                              func: task_fn_t,
                              context: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    #[link_name = "taskqueue_swi_giant"]
    pub static mut taskqueue_swi_giant: *mut taskqueue;
}
extern "C" {
    #[link_name = "taskqueue_swi"]
    pub static mut taskqueue_swi: *mut taskqueue;
}
extern "C" {
    #[link_name = "taskqueue_thread"]
    pub static mut taskqueue_thread: *mut taskqueue;
}
extern "C" {
    #[link_name = "taskqueue_fast"]
    pub static mut taskqueue_fast: *mut taskqueue;
}
extern "C" {
    pub fn taskqueue_create_fast(name: *const ::kernel::sys::raw::c_char,
                                 mflags: ::kernel::sys::raw::c_int,
                                 enqueue: taskqueue_enqueue_fn,
                                 context: *mut ::kernel::sys::raw::c_void)
     -> *mut taskqueue;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gtaskqueue {
    _unused: [u8; 0],
}
pub type gtaskqueue_enqueue_fn =
    ::core::option::Option<unsafe extern "C" fn(context:
                                                    *mut ::kernel::sys::raw::c_void)>;
extern "C" {
    pub fn gtaskqueue_block(queue: *mut gtaskqueue);
}
extern "C" {
    pub fn gtaskqueue_unblock(queue: *mut gtaskqueue);
}
extern "C" {
    pub fn gtaskqueue_cancel(queue: *mut gtaskqueue, gtask: *mut gtask)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn gtaskqueue_drain(queue: *mut gtaskqueue, task: *mut gtask);
}
extern "C" {
    pub fn gtaskqueue_drain_all(queue: *mut gtaskqueue);
}
extern "C" {
    pub fn grouptaskqueue_enqueue(queue: *mut gtaskqueue, task: *mut gtask)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn taskqgroup_attach(qgroup: *mut taskqgroup, grptask: *mut grouptask,
                             uniq: *mut ::kernel::sys::raw::c_void,
                             irq: ::kernel::sys::raw::c_int,
                             name: *const ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn taskqgroup_attach_cpu(qgroup: *mut taskqgroup,
                                 grptask: *mut grouptask,
                                 uniq: *mut ::kernel::sys::raw::c_void,
                                 cpu: ::kernel::sys::raw::c_int,
                                 irq: ::kernel::sys::raw::c_int,
                                 name: *mut ::kernel::sys::raw::c_char)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn taskqgroup_detach(qgroup: *mut taskqgroup, gtask: *mut grouptask);
}
extern "C" {
    pub fn taskqgroup_create(name: *mut ::kernel::sys::raw::c_char)
     -> *mut taskqgroup;
}
extern "C" {
    pub fn taskqgroup_destroy(qgroup: *mut taskqgroup);
}
extern "C" {
    pub fn taskqgroup_adjust(qgroup: *mut taskqgroup,
                             cnt: ::kernel::sys::raw::c_int,
                             stride: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn taskqgroup_config_gtask_init(ctx: *mut ::kernel::sys::raw::c_void,
                                        gtask: *mut grouptask,
                                        fn_: gtask_fn_t,
                                        name:
                                            *const ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn taskqgroup_config_gtask_deinit(gtask: *mut grouptask);
}
extern "C" {
    #[link_name = "qgroup_net"]
    pub static mut qgroup_net: *mut taskqgroup;
}
extern "C" {
    #[link_name = "qgroup_softirq"]
    pub static mut qgroup_softirq: *mut taskqgroup;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct if_clone {
    _unused: [u8; 0],
}
pub type qidx_t = u16;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iflib_ctx {
    _unused: [u8; 0],
}
pub type if_ctx_t = *mut iflib_ctx;
#[repr(C)]
#[derive(Copy)]
pub struct if_shared_ctx {
    pub isc_magic: ::kernel::sys::raw::c_uint,
    pub isc_driver: *mut driver_t,
    pub isc_q_align: bus_size_t,
    pub isc_tx_maxsize: bus_size_t,
    pub isc_tx_maxsegsize: bus_size_t,
    pub isc_rx_maxsize: bus_size_t,
    pub isc_rx_maxsegsize: bus_size_t,
    pub isc_rx_nsegments: ::kernel::sys::raw::c_int,
    pub isc_admin_intrcnt: ::kernel::sys::raw::c_int,
    pub isc_vendor_info: *mut pci_vendor_info_t,
    pub isc_driver_version: *mut ::kernel::sys::raw::c_char,
    pub isc_parse_devinfo: ::core::option::Option<unsafe extern "C" fn(device_id:
                                                                           *mut u16,
                                                                       subvendor_id:
                                                                           *mut u16,
                                                                       subdevice_id:
                                                                           *mut u16,
                                                                       rev_id:
                                                                           *mut u16)>,
    pub isc_nrxd_min: [::kernel::sys::raw::c_int; 8usize],
    pub isc_nrxd_default: [::kernel::sys::raw::c_int; 8usize],
    pub isc_nrxd_max: [::kernel::sys::raw::c_int; 8usize],
    pub isc_ntxd_min: [::kernel::sys::raw::c_int; 8usize],
    pub isc_ntxd_default: [::kernel::sys::raw::c_int; 8usize],
    pub isc_ntxd_max: [::kernel::sys::raw::c_int; 8usize],
    pub __bindgen_padding_0: [u32; 10usize],
    pub isc_nfl: ::kernel::sys::raw::c_int,
    pub isc_ntxqs: ::kernel::sys::raw::c_int,
    pub isc_nrxqs: ::kernel::sys::raw::c_int,
    pub isc_rx_process_limit: ::kernel::sys::raw::c_int,
    pub isc_tx_reclaim_thresh: ::kernel::sys::raw::c_int,
    pub isc_flags: ::kernel::sys::raw::c_int,
    pub isc_name: *const ::kernel::sys::raw::c_char,
    pub __bindgen_padding_1: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_if_shared_ctx() {
    assert_eq!(::core::mem::size_of::<if_shared_ctx>() , 384usize , concat ! (
               "Size of: " , stringify ! ( if_shared_ctx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_magic as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_magic ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_driver as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_driver ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_q_align as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_q_align ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_tx_maxsize as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_tx_maxsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_tx_maxsegsize as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_tx_maxsegsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_rx_maxsize as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_rx_maxsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_rx_maxsegsize as
                * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_rx_maxsegsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_rx_nsegments as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_rx_nsegments ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_admin_intrcnt as
                * const _ as usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_admin_intrcnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_vendor_info as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_vendor_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_driver_version as
                * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_driver_version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_parse_devinfo as
                * const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_parse_devinfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_nrxd_min as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_nrxd_min ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_nrxd_default as *
                const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_nrxd_default ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_nrxd_max as *
                const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_nrxd_max ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_ntxd_min as *
                const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_ntxd_min ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_ntxd_default as *
                const _ as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_ntxd_default ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_ntxd_max as *
                const _ as usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_ntxd_max ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_nfl as * const _
                as usize } , 320usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_nfl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_ntxqs as * const
                _ as usize } , 324usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_ntxqs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_nrxqs as * const
                _ as usize } , 328usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_nrxqs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_rx_process_limit
                as * const _ as usize } , 332usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_rx_process_limit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_tx_reclaim_thresh
                as * const _ as usize } , 336usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_tx_reclaim_thresh ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_flags as * const
                _ as usize } , 340usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_name as * const _
                as usize } , 344usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_name ) ));
}
impl Clone for if_shared_ctx {
    fn clone(&self) -> Self { *self }
}
impl Default for if_shared_ctx {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for if_shared_ctx {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "if_shared_ctx {{ isc_magic: {:?}, isc_driver: {:?}, isc_q_align: {:?}, isc_tx_maxsize: {:?}, isc_tx_maxsegsize: {:?}, isc_rx_maxsize: {:?}, isc_rx_maxsegsize: {:?}, isc_rx_nsegments: {:?}, isc_admin_intrcnt: {:?}, isc_vendor_info: {:?}, isc_driver_version: {:?}, isc_parse_devinfo: {:?}, isc_nrxd_min: {:?}, isc_nrxd_default: {:?}, isc_nrxd_max: {:?}, isc_ntxd_min: {:?}, isc_ntxd_default: {:?}, isc_ntxd_max: {:?}, isc_nfl: {:?}, isc_ntxqs: {:?}, isc_nrxqs: {:?}, isc_rx_process_limit: {:?}, isc_tx_reclaim_thresh: {:?}, isc_flags: {:?}, isc_name: {:?} }}"
               , self . isc_magic , self . isc_driver , self . isc_q_align ,
               self . isc_tx_maxsize , self . isc_tx_maxsegsize , self .
               isc_rx_maxsize , self . isc_rx_maxsegsize , self .
               isc_rx_nsegments , self . isc_admin_intrcnt , self .
               isc_vendor_info , self . isc_driver_version , self .
               isc_parse_devinfo , self . isc_nrxd_min , self .
               isc_nrxd_default , self . isc_nrxd_max , self . isc_ntxd_min ,
               self . isc_ntxd_default , self . isc_ntxd_max , self . isc_nfl
               , self . isc_ntxqs , self . isc_nrxqs , self .
               isc_rx_process_limit , self . isc_tx_reclaim_thresh , self .
               isc_flags , self . isc_name)
    }
}
pub type if_shared_ctx_t = *mut if_shared_ctx;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct if_int_delay_info {
    pub iidi_ctx: if_ctx_t,
    pub iidi_offset: ::kernel::sys::raw::c_int,
    pub iidi_value: ::kernel::sys::raw::c_int,
    pub iidi_oidp: *mut sysctl_oid,
    pub iidi_req: *mut sysctl_req,
}
#[test]
fn bindgen_test_layout_if_int_delay_info() {
    assert_eq!(::core::mem::size_of::<if_int_delay_info>() , 32usize , concat
               ! ( "Size of: " , stringify ! ( if_int_delay_info ) ));
    assert_eq! (::core::mem::align_of::<if_int_delay_info>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( if_int_delay_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_int_delay_info ) ) . iidi_ctx as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_int_delay_info ) ,
                "::" , stringify ! ( iidi_ctx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_int_delay_info ) ) . iidi_offset as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( if_int_delay_info ) ,
                "::" , stringify ! ( iidi_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_int_delay_info ) ) . iidi_value as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( if_int_delay_info ) ,
                "::" , stringify ! ( iidi_value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_int_delay_info ) ) . iidi_oidp as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( if_int_delay_info ) ,
                "::" , stringify ! ( iidi_oidp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_int_delay_info ) ) . iidi_req as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( if_int_delay_info ) ,
                "::" , stringify ! ( iidi_req ) ));
}
impl Clone for if_int_delay_info {
    fn clone(&self) -> Self { *self }
}
impl Default for if_int_delay_info {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type if_int_delay_info_t = *mut if_int_delay_info;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct if_pseudo {
    _unused: [u8; 0],
}
pub type if_pseudo_t = *mut if_pseudo;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct if_rxd_frag {
    pub irf_flid: u8,
    pub irf_idx: qidx_t,
    pub irf_len: u16,
}
#[test]
fn bindgen_test_layout_if_rxd_frag() {
    assert_eq!(::core::mem::size_of::<if_rxd_frag>() , 6usize , concat ! (
               "Size of: " , stringify ! ( if_rxd_frag ) ));
    assert_eq! (::core::mem::align_of::<if_rxd_frag>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( if_rxd_frag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_frag ) ) . irf_flid as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_frag ) , "::" ,
                stringify ! ( irf_flid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_frag ) ) . irf_idx as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_frag ) , "::" ,
                stringify ! ( irf_idx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_frag ) ) . irf_len as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_frag ) , "::" ,
                stringify ! ( irf_len ) ));
}
impl Clone for if_rxd_frag {
    fn clone(&self) -> Self { *self }
}
pub type if_rxd_frag_t = *mut if_rxd_frag;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct if_rxd_info {
    pub iri_qsidx: u16,
    pub iri_vtag: u16,
    pub iri_len: u16,
    pub iri_cidx: qidx_t,
    pub iri_ifp: *mut ifnet,
    pub iri_frags: if_rxd_frag_t,
    pub iri_flowid: u32,
    pub iri_csum_flags: u32,
    pub iri_csum_data: u32,
    pub iri_flags: u8,
    pub iri_nfrags: u8,
    pub iri_rsstype: u8,
    pub iri_pad: u8,
}
#[test]
fn bindgen_test_layout_if_rxd_info() {
    assert_eq!(::core::mem::size_of::<if_rxd_info>() , 40usize , concat ! (
               "Size of: " , stringify ! ( if_rxd_info ) ));
    assert_eq! (::core::mem::align_of::<if_rxd_info>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( if_rxd_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_info ) ) . iri_qsidx as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_info ) , "::" ,
                stringify ! ( iri_qsidx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_info ) ) . iri_vtag as * const _
                as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_info ) , "::" ,
                stringify ! ( iri_vtag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_info ) ) . iri_len as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_info ) , "::" ,
                stringify ! ( iri_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_info ) ) . iri_cidx as * const _
                as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_info ) , "::" ,
                stringify ! ( iri_cidx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_info ) ) . iri_ifp as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_info ) , "::" ,
                stringify ! ( iri_ifp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_info ) ) . iri_frags as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_info ) , "::" ,
                stringify ! ( iri_frags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_info ) ) . iri_flowid as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_info ) , "::" ,
                stringify ! ( iri_flowid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_info ) ) . iri_csum_flags as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_info ) , "::" ,
                stringify ! ( iri_csum_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_info ) ) . iri_csum_data as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_info ) , "::" ,
                stringify ! ( iri_csum_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_info ) ) . iri_flags as * const _
                as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_info ) , "::" ,
                stringify ! ( iri_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_info ) ) . iri_nfrags as * const _
                as usize } , 37usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_info ) , "::" ,
                stringify ! ( iri_nfrags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_info ) ) . iri_rsstype as * const
                _ as usize } , 38usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_info ) , "::" ,
                stringify ! ( iri_rsstype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_info ) ) . iri_pad as * const _ as
                usize } , 39usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_info ) , "::" ,
                stringify ! ( iri_pad ) ));
}
impl Clone for if_rxd_info {
    fn clone(&self) -> Self { *self }
}
impl Default for if_rxd_info {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type if_rxd_info_t = *mut if_rxd_info;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct if_rxd_update {
    pub iru_paddrs: *mut u64,
    pub iru_vaddrs: *mut caddr_t,
    pub iru_idxs: *mut qidx_t,
    pub iru_pidx: qidx_t,
    pub iru_qsidx: u16,
    pub iru_count: u16,
    pub iru_buf_size: u16,
    pub iru_flidx: u8,
}
#[test]
fn bindgen_test_layout_if_rxd_update() {
    assert_eq!(::core::mem::size_of::<if_rxd_update>() , 40usize , concat ! (
               "Size of: " , stringify ! ( if_rxd_update ) ));
    assert_eq! (::core::mem::align_of::<if_rxd_update>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( if_rxd_update ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_update ) ) . iru_paddrs as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_update ) , "::"
                , stringify ! ( iru_paddrs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_update ) ) . iru_vaddrs as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_update ) , "::"
                , stringify ! ( iru_vaddrs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_update ) ) . iru_idxs as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_update ) , "::"
                , stringify ! ( iru_idxs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_update ) ) . iru_pidx as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_update ) , "::"
                , stringify ! ( iru_pidx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_update ) ) . iru_qsidx as * const
                _ as usize } , 26usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_update ) , "::"
                , stringify ! ( iru_qsidx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_update ) ) . iru_count as * const
                _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_update ) , "::"
                , stringify ! ( iru_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_update ) ) . iru_buf_size as *
                const _ as usize } , 30usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_update ) , "::"
                , stringify ! ( iru_buf_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_update ) ) . iru_flidx as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_update ) , "::"
                , stringify ! ( iru_flidx ) ));
}
impl Clone for if_rxd_update {
    fn clone(&self) -> Self { *self }
}
impl Default for if_rxd_update {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type if_rxd_update_t = *mut if_rxd_update;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct if_pkt_info {
    pub ipi_segs: *mut bus_dma_segment_t,
    pub ipi_len: u32,
    pub ipi_qsidx: u16,
    pub ipi_nsegs: qidx_t,
    pub ipi_ndescs: qidx_t,
    pub ipi_flags: u16,
    pub ipi_pidx: qidx_t,
    pub ipi_new_pidx: qidx_t,
    pub ipi_ehdrlen: u8,
    pub ipi_ip_hlen: u8,
    pub ipi_tcp_hlen: u8,
    pub ipi_ipproto: u8,
    pub ipi_csum_flags: u32,
    pub ipi_tso_segsz: u16,
    pub ipi_vtag: u16,
    pub ipi_etype: u16,
    pub ipi_tcp_hflags: u8,
    pub ipi_mflags: u8,
    pub ipi_tcp_seq: u32,
    pub ipi_tcp_sum: u32,
}
#[test]
fn bindgen_test_layout_if_pkt_info() {
    assert_eq!(::core::mem::size_of::<if_pkt_info>() , 48usize , concat ! (
               "Size of: " , stringify ! ( if_pkt_info ) ));
    assert_eq! (::core::mem::align_of::<if_pkt_info>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( if_pkt_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_pkt_info ) ) . ipi_segs as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_pkt_info ) , "::" ,
                stringify ! ( ipi_segs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_pkt_info ) ) . ipi_len as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( if_pkt_info ) , "::" ,
                stringify ! ( ipi_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_pkt_info ) ) . ipi_qsidx as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( if_pkt_info ) , "::" ,
                stringify ! ( ipi_qsidx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_pkt_info ) ) . ipi_nsegs as * const _
                as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( if_pkt_info ) , "::" ,
                stringify ! ( ipi_nsegs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_pkt_info ) ) . ipi_ndescs as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( if_pkt_info ) , "::" ,
                stringify ! ( ipi_ndescs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_pkt_info ) ) . ipi_flags as * const _
                as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( if_pkt_info ) , "::" ,
                stringify ! ( ipi_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_pkt_info ) ) . ipi_pidx as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( if_pkt_info ) , "::" ,
                stringify ! ( ipi_pidx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_pkt_info ) ) . ipi_new_pidx as * const
                _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! ( if_pkt_info ) , "::" ,
                stringify ! ( ipi_new_pidx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_pkt_info ) ) . ipi_ehdrlen as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( if_pkt_info ) , "::" ,
                stringify ! ( ipi_ehdrlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_pkt_info ) ) . ipi_ip_hlen as * const
                _ as usize } , 25usize , concat ! (
                "Alignment of field: " , stringify ! ( if_pkt_info ) , "::" ,
                stringify ! ( ipi_ip_hlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_pkt_info ) ) . ipi_tcp_hlen as * const
                _ as usize } , 26usize , concat ! (
                "Alignment of field: " , stringify ! ( if_pkt_info ) , "::" ,
                stringify ! ( ipi_tcp_hlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_pkt_info ) ) . ipi_ipproto as * const
                _ as usize } , 27usize , concat ! (
                "Alignment of field: " , stringify ! ( if_pkt_info ) , "::" ,
                stringify ! ( ipi_ipproto ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_pkt_info ) ) . ipi_csum_flags as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( if_pkt_info ) , "::" ,
                stringify ! ( ipi_csum_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_pkt_info ) ) . ipi_tso_segsz as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( if_pkt_info ) , "::" ,
                stringify ! ( ipi_tso_segsz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_pkt_info ) ) . ipi_vtag as * const _
                as usize } , 34usize , concat ! (
                "Alignment of field: " , stringify ! ( if_pkt_info ) , "::" ,
                stringify ! ( ipi_vtag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_pkt_info ) ) . ipi_etype as * const _
                as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( if_pkt_info ) , "::" ,
                stringify ! ( ipi_etype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_pkt_info ) ) . ipi_tcp_hflags as *
                const _ as usize } , 38usize , concat ! (
                "Alignment of field: " , stringify ! ( if_pkt_info ) , "::" ,
                stringify ! ( ipi_tcp_hflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_pkt_info ) ) . ipi_mflags as * const _
                as usize } , 39usize , concat ! (
                "Alignment of field: " , stringify ! ( if_pkt_info ) , "::" ,
                stringify ! ( ipi_mflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_pkt_info ) ) . ipi_tcp_seq as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( if_pkt_info ) , "::" ,
                stringify ! ( ipi_tcp_seq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_pkt_info ) ) . ipi_tcp_sum as * const
                _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( if_pkt_info ) , "::" ,
                stringify ! ( ipi_tcp_sum ) ));
}
impl Clone for if_pkt_info {
    fn clone(&self) -> Self { *self }
}
impl Default for if_pkt_info {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type if_pkt_info_t = *mut if_pkt_info;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct if_irq {
    pub ii_res: *mut resource,
    pub ii_rid: ::kernel::sys::raw::c_int,
    pub ii_tag: *mut ::kernel::sys::raw::c_void,
}
#[test]
fn bindgen_test_layout_if_irq() {
    assert_eq!(::core::mem::size_of::<if_irq>() , 24usize , concat ! (
               "Size of: " , stringify ! ( if_irq ) ));
    assert_eq! (::core::mem::align_of::<if_irq>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( if_irq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_irq ) ) . ii_res as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_irq ) , "::" ,
                stringify ! ( ii_res ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_irq ) ) . ii_rid as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( if_irq ) , "::" ,
                stringify ! ( ii_rid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_irq ) ) . ii_tag as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( if_irq ) , "::" ,
                stringify ! ( ii_tag ) ));
}
impl Clone for if_irq {
    fn clone(&self) -> Self { *self }
}
impl Default for if_irq {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type if_irq_t = *mut if_irq;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum iflib_intr_mode_t {
    IFLIB_INTR_LEGACY = 0,
    IFLIB_INTR_MSI = 1,
    IFLIB_INTR_MSIX = 2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pci_vendor_info {
    pub pvi_vendor_id: u32,
    pub pvi_device_id: u32,
    pub pvi_subvendor_id: u32,
    pub pvi_subdevice_id: u32,
    pub pvi_rev_id: u32,
    pub pvi_class_mask: u32,
    pub pvi_name: caddr_t,
}
#[test]
fn bindgen_test_layout_pci_vendor_info() {
    assert_eq!(::core::mem::size_of::<pci_vendor_info>() , 32usize , concat !
               ( "Size of: " , stringify ! ( pci_vendor_info ) ));
    assert_eq! (::core::mem::align_of::<pci_vendor_info>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( pci_vendor_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_vendor_info ) ) . pvi_vendor_id as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pci_vendor_info ) ,
                "::" , stringify ! ( pvi_vendor_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_vendor_info ) ) . pvi_device_id as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( pci_vendor_info ) ,
                "::" , stringify ! ( pvi_device_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_vendor_info ) ) . pvi_subvendor_id as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pci_vendor_info ) ,
                "::" , stringify ! ( pvi_subvendor_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_vendor_info ) ) . pvi_subdevice_id as
                * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( pci_vendor_info ) ,
                "::" , stringify ! ( pvi_subdevice_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_vendor_info ) ) . pvi_rev_id as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( pci_vendor_info ) ,
                "::" , stringify ! ( pvi_rev_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_vendor_info ) ) . pvi_class_mask as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( pci_vendor_info ) ,
                "::" , stringify ! ( pvi_class_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_vendor_info ) ) . pvi_name as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( pci_vendor_info ) ,
                "::" , stringify ! ( pvi_name ) ));
}
impl Clone for pci_vendor_info {
    fn clone(&self) -> Self { *self }
}
impl Default for pci_vendor_info {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type pci_vendor_info_t = pci_vendor_info;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct if_txrx {
    pub ift_txd_encap: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                       *mut ::kernel::sys::raw::c_void,
                                                                   arg2:
                                                                       if_pkt_info_t)
                                                  ->
                                                      ::kernel::sys::raw::c_int>,
    pub ift_txd_flush: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                       *mut ::kernel::sys::raw::c_void,
                                                                   arg2: u16,
                                                                   pidx:
                                                                       qidx_t)>,
    pub ift_txd_credits_update: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                                *mut ::kernel::sys::raw::c_void,
                                                                            qsidx:
                                                                                u16,
                                                                            clear:
                                                                                bool_)
                                                           ->
                                                               ::kernel::sys::raw::c_int>,
    pub ift_rxd_available: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                           *mut ::kernel::sys::raw::c_void,
                                                                       qsidx:
                                                                           u16,
                                                                       pidx:
                                                                           qidx_t,
                                                                       budget:
                                                                           qidx_t)
                                                      ->
                                                          ::kernel::sys::raw::c_int>,
    pub ift_rxd_pkt_get: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                         *mut ::kernel::sys::raw::c_void,
                                                                     ri:
                                                                         if_rxd_info_t)
                                                    ->
                                                        ::kernel::sys::raw::c_int>,
    pub ift_rxd_refill: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                        *mut ::kernel::sys::raw::c_void,
                                                                    iru:
                                                                        if_rxd_update_t)>,
    pub ift_rxd_flush: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                       *mut ::kernel::sys::raw::c_void,
                                                                   qsidx: u16,
                                                                   flidx: u8,
                                                                   pidx:
                                                                       qidx_t)>,
    pub ift_legacy_intr: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                         *mut ::kernel::sys::raw::c_void)
                                                    ->
                                                        ::kernel::sys::raw::c_int>,
}
#[test]
fn bindgen_test_layout_if_txrx() {
    assert_eq!(::core::mem::size_of::<if_txrx>() , 64usize , concat ! (
               "Size of: " , stringify ! ( if_txrx ) ));
    assert_eq! (::core::mem::align_of::<if_txrx>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( if_txrx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_txrx ) ) . ift_txd_encap as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_txrx ) , "::" ,
                stringify ! ( ift_txd_encap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_txrx ) ) . ift_txd_flush as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( if_txrx ) , "::" ,
                stringify ! ( ift_txd_flush ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_txrx ) ) . ift_txd_credits_update as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( if_txrx ) , "::" ,
                stringify ! ( ift_txd_credits_update ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_txrx ) ) . ift_rxd_available as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( if_txrx ) , "::" ,
                stringify ! ( ift_rxd_available ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_txrx ) ) . ift_rxd_pkt_get as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( if_txrx ) , "::" ,
                stringify ! ( ift_rxd_pkt_get ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_txrx ) ) . ift_rxd_refill as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( if_txrx ) , "::" ,
                stringify ! ( ift_rxd_refill ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_txrx ) ) . ift_rxd_flush as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( if_txrx ) , "::" ,
                stringify ! ( ift_rxd_flush ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_txrx ) ) . ift_legacy_intr as * const
                _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( if_txrx ) , "::" ,
                stringify ! ( ift_legacy_intr ) ));
}
impl Clone for if_txrx {
    fn clone(&self) -> Self { *self }
}
impl Default for if_txrx {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type if_txrx_t = *mut if_txrx;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct if_softc_ctx {
    pub isc_vectors: ::kernel::sys::raw::c_int,
    pub isc_nrxqsets: ::kernel::sys::raw::c_int,
    pub isc_ntxqsets: ::kernel::sys::raw::c_int,
    pub isc_min_tx_latency: u8,
    pub isc_rx_mvec_enable: u8,
    pub isc_txrx_budget_bytes_max: u32,
    pub isc_msix_bar: ::kernel::sys::raw::c_int,
    pub isc_tx_nsegments: ::kernel::sys::raw::c_int,
    pub isc_ntxd: [::kernel::sys::raw::c_int; 8usize],
    pub isc_nrxd: [::kernel::sys::raw::c_int; 8usize],
    pub isc_txqsizes: [u32; 8usize],
    pub isc_rxqsizes: [u32; 8usize],
    pub isc_txd_size: [u8; 8usize],
    pub isc_rxd_size: [u8; 8usize],
    pub isc_tx_tso_segments_max: ::kernel::sys::raw::c_int,
    pub isc_tx_tso_size_max: ::kernel::sys::raw::c_int,
    pub isc_tx_tso_segsize_max: ::kernel::sys::raw::c_int,
    pub isc_tx_csum_flags: ::kernel::sys::raw::c_int,
    pub isc_capenable: ::kernel::sys::raw::c_int,
    pub isc_rss_table_size: ::kernel::sys::raw::c_int,
    pub isc_rss_table_mask: ::kernel::sys::raw::c_int,
    pub isc_nrxqsets_max: ::kernel::sys::raw::c_int,
    pub isc_ntxqsets_max: ::kernel::sys::raw::c_int,
    pub isc_tx_qdepth: u32,
    pub isc_intr: iflib_intr_mode_t,
    pub isc_max_frame_size: u16,
    pub isc_min_frame_size: u16,
    pub isc_pause_frames: u32,
    pub isc_vendor_info: pci_vendor_info_t,
    pub isc_disable_msix: ::kernel::sys::raw::c_int,
    pub isc_txrx: if_txrx_t,
}
#[test]
fn bindgen_test_layout_if_softc_ctx() {
    assert_eq!(::core::mem::size_of::<if_softc_ctx>() , 272usize , concat ! (
               "Size of: " , stringify ! ( if_softc_ctx ) ));
    assert_eq! (::core::mem::align_of::<if_softc_ctx>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( if_softc_ctx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_vectors as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_vectors ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_nrxqsets as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_nrxqsets ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_ntxqsets as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_ntxqsets ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_min_tx_latency as
                * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_min_tx_latency ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_rx_mvec_enable as
                * const _ as usize } , 13usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_rx_mvec_enable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) .
                isc_txrx_budget_bytes_max as * const _ as usize } , 16usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_txrx_budget_bytes_max ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_msix_bar as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_msix_bar ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_tx_nsegments as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_tx_nsegments ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_ntxd as * const _
                as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_ntxd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_nrxd as * const _
                as usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_nrxd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_txqsizes as *
                const _ as usize } , 92usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_txqsizes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_rxqsizes as *
                const _ as usize } , 124usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_rxqsizes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_txd_size as *
                const _ as usize } , 156usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_txd_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_rxd_size as *
                const _ as usize } , 164usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_rxd_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) .
                isc_tx_tso_segments_max as * const _ as usize } , 172usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_tx_tso_segments_max ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_tx_tso_size_max as
                * const _ as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_tx_tso_size_max ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_tx_tso_segsize_max
                as * const _ as usize } , 180usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_tx_tso_segsize_max ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_tx_csum_flags as *
                const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_tx_csum_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_capenable as *
                const _ as usize } , 188usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_capenable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_rss_table_size as
                * const _ as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_rss_table_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_rss_table_mask as
                * const _ as usize } , 196usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_rss_table_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_nrxqsets_max as *
                const _ as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_nrxqsets_max ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_ntxqsets_max as *
                const _ as usize } , 204usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_ntxqsets_max ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_tx_qdepth as *
                const _ as usize } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_tx_qdepth ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_intr as * const _
                as usize } , 212usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_intr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_max_frame_size as
                * const _ as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_max_frame_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_min_frame_size as
                * const _ as usize } , 218usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_min_frame_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_pause_frames as *
                const _ as usize } , 220usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_pause_frames ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_vendor_info as *
                const _ as usize } , 224usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_vendor_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_disable_msix as *
                const _ as usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_disable_msix ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_txrx as * const _
                as usize } , 264usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_txrx ) ));
}
impl Clone for if_softc_ctx {
    fn clone(&self) -> Self { *self }
}
impl Default for if_softc_ctx {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type if_softc_ctx_t = *mut if_softc_ctx;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct iflib_dma_info {
    pub idi_paddr: bus_addr_t,
    pub idi_vaddr: caddr_t,
    pub idi_tag: bus_dma_tag_t,
    pub idi_map: bus_dmamap_t,
    pub idi_size: u32,
}
#[test]
fn bindgen_test_layout_iflib_dma_info() {
    assert_eq!(::core::mem::size_of::<iflib_dma_info>() , 40usize , concat ! (
               "Size of: " , stringify ! ( iflib_dma_info ) ));
    assert_eq! (::core::mem::align_of::<iflib_dma_info>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( iflib_dma_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const iflib_dma_info ) ) . idi_paddr as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( iflib_dma_info ) , "::"
                , stringify ! ( idi_paddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const iflib_dma_info ) ) . idi_vaddr as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( iflib_dma_info ) , "::"
                , stringify ! ( idi_vaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const iflib_dma_info ) ) . idi_tag as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( iflib_dma_info ) , "::"
                , stringify ! ( idi_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const iflib_dma_info ) ) . idi_map as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( iflib_dma_info ) , "::"
                , stringify ! ( idi_map ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const iflib_dma_info ) ) . idi_size as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( iflib_dma_info ) , "::"
                , stringify ! ( idi_size ) ));
}
impl Clone for iflib_dma_info {
    fn clone(&self) -> Self { *self }
}
impl Default for iflib_dma_info {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type iflib_dma_info_t = *mut iflib_dma_info;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum iflib_intr_type_t {
    IFLIB_INTR_RX = 0,
    IFLIB_INTR_TX = 1,
    IFLIB_INTR_RXTX = 2,
    IFLIB_INTR_ADMIN = 3,
    IFLIB_INTR_IOV = 4,
}
extern "C" {
    pub fn iflib_get_softc(ctx: if_ctx_t) -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn iflib_get_dev(ctx: if_ctx_t) -> device_t;
}
extern "C" {
    pub fn iflib_get_ifp(ctx: if_ctx_t) -> if_t;
}
extern "C" {
    pub fn iflib_get_media(ctx: if_ctx_t) -> *mut ifmedia;
}
extern "C" {
    pub fn iflib_get_softc_ctx(ctx: if_ctx_t) -> if_softc_ctx_t;
}
extern "C" {
    pub fn iflib_get_sctx(ctx: if_ctx_t) -> if_shared_ctx_t;
}
extern "C" {
    pub fn iflib_set_mac(ctx: if_ctx_t, mac: *mut u8);
}
extern "C" {
    pub fn iflib_device_probe(arg1: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn iflib_device_attach(arg1: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn iflib_device_detach(arg1: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn iflib_device_suspend(arg1: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn iflib_device_resume(arg1: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn iflib_device_shutdown(arg1: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn iflib_device_iov_init(arg1: device_t, arg2: u16,
                                 arg3: *const nvlist_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn iflib_device_iov_uninit(arg1: device_t);
}
extern "C" {
    pub fn iflib_device_iov_add_vf(arg1: device_t, arg2: u16,
                                   arg3: *const nvlist_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn iflib_device_register(dev: device_t,
                                 softc: *mut ::kernel::sys::raw::c_void,
                                 sctx: if_shared_ctx_t, ctxp: *mut if_ctx_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn iflib_device_deregister(arg1: if_ctx_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn iflib_irq_alloc(arg1: if_ctx_t, arg2: if_irq_t,
                           arg3: ::kernel::sys::raw::c_int,
                           arg4: driver_filter_t,
                           filter_arg: *mut ::kernel::sys::raw::c_void,
                           arg5: driver_intr_t,
                           arg: *mut ::kernel::sys::raw::c_void,
                           name: *mut ::kernel::sys::raw::c_char)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn iflib_irq_alloc_generic(ctx: if_ctx_t, irq: if_irq_t,
                                   rid: ::kernel::sys::raw::c_int,
                                   type_: iflib_intr_type_t,
                                   filter: driver_filter_t,
                                   filter_arg:
                                       *mut ::kernel::sys::raw::c_void,
                                   qid: ::kernel::sys::raw::c_int,
                                   name: *mut ::kernel::sys::raw::c_char)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn iflib_softirq_alloc_generic(ctx: if_ctx_t, irq: if_irq_t,
                                       type_: iflib_intr_type_t,
                                       arg: *mut ::kernel::sys::raw::c_void,
                                       qid: ::kernel::sys::raw::c_int,
                                       name: *mut ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn iflib_irq_free(ctx: if_ctx_t, irq: if_irq_t);
}
extern "C" {
    pub fn iflib_io_tqg_attach(gt: *mut grouptask,
                               uniq: *mut ::kernel::sys::raw::c_void,
                               cpu: ::kernel::sys::raw::c_int,
                               name: *mut ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn iflib_config_gtask_init(ctx: *mut ::kernel::sys::raw::c_void,
                                   gtask: *mut grouptask, fn_: gtask_fn_t,
                                   name: *const ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn iflib_config_gtask_deinit(gtask: *mut grouptask);
}
extern "C" {
    pub fn iflib_tx_intr_deferred(ctx: if_ctx_t,
                                  txqid: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn iflib_rx_intr_deferred(ctx: if_ctx_t,
                                  rxqid: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn iflib_admin_intr_deferred(ctx: if_ctx_t);
}
extern "C" {
    pub fn iflib_iov_intr_deferred(ctx: if_ctx_t);
}
extern "C" {
    pub fn iflib_link_state_change(ctx: if_ctx_t,
                                   linkstate: ::kernel::sys::raw::c_int,
                                   baudrate: u64);
}
extern "C" {
    pub fn iflib_dma_alloc(ctx: if_ctx_t, size: ::kernel::sys::raw::c_int,
                           dma: iflib_dma_info_t,
                           mapflags: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn iflib_dma_free(dma: iflib_dma_info_t);
}
extern "C" {
    pub fn iflib_dma_alloc_multi(ctx: if_ctx_t,
                                 sizes: *mut ::kernel::sys::raw::c_int,
                                 dmalist: *mut iflib_dma_info_t,
                                 mapflags: ::kernel::sys::raw::c_int,
                                 count: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn iflib_dma_free_multi(dmalist: *mut iflib_dma_info_t,
                                count: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn iflib_ctx_lock_get(arg1: if_ctx_t) -> *mut sx;
}
extern "C" {
    pub fn iflib_qset_lock_get(arg1: if_ctx_t, arg2: u16) -> *mut mtx;
}
extern "C" {
    pub fn iflib_led_create(ctx: if_ctx_t);
}
extern "C" {
    pub fn iflib_add_int_delay_sysctl(arg1: if_ctx_t,
                                      arg2: *const ::kernel::sys::raw::c_char,
                                      arg3: *const ::kernel::sys::raw::c_char,
                                      arg4: if_int_delay_info_t,
                                      arg5: ::kernel::sys::raw::c_int,
                                      arg6: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn iflib_clone_register(arg1: if_shared_ctx_t) -> if_pseudo_t;
}
extern "C" {
    pub fn iflib_clone_deregister(arg1: if_pseudo_t);
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __va_list_tag {
    pub gp_offset: ::kernel::sys::raw::c_uint,
    pub fp_offset: ::kernel::sys::raw::c_uint,
    pub overflow_arg_area: *mut ::kernel::sys::raw::c_void,
    pub reg_save_area: *mut ::kernel::sys::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(::core::mem::size_of::<__va_list_tag>() , 24usize , concat ! (
               "Size of: " , stringify ! ( __va_list_tag ) ));
    assert_eq! (::core::mem::align_of::<__va_list_tag>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __va_list_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . gp_offset as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( gp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . fp_offset as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( fp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . overflow_arg_area as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( overflow_arg_area ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . reg_save_area as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( reg_save_area ) ));
}
impl Clone for __va_list_tag {
    fn clone(&self) -> Self { *self }
}
impl Default for __va_list_tag {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct witness {
    pub _address: u8,
}
impl Clone for witness {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct filedesc {
    pub _address: u8,
}
impl Clone for filedesc {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct filedesc_to_leader {
    pub _address: u8,
}
impl Clone for filedesc_to_leader {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct pstats {
    pub _address: u8,
}
impl Clone for pstats {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct plimit {
    pub _address: u8,
}
impl Clone for plimit {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct itimers {
    pub _address: u8,
}
impl Clone for itimers {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct sysentvec {
    pub _address: u8,
}
impl Clone for sysentvec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct label {
    pub _address: u8,
}
impl Clone for label {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct ktr_request {
    pub _address: u8,
}
impl Clone for ktr_request {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct seltd {
    pub _address: u8,
}
impl Clone for seltd {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct rl_q_entry {
    pub _address: u8,
}
impl Clone for rl_q_entry {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct umtx_q {
    pub _address: u8,
}
impl Clone for umtx_q {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct file {
    pub _address: u8,
}
impl Clone for file {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct vm_object {
    pub _address: u8,
}
impl Clone for vm_object {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct uidinfo {
    pub _address: u8,
}
impl Clone for uidinfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct amd64tss {
    pub _address: u8,
}
impl Clone for amd64tss {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kaiocb {
    pub _address: u8,
}
impl Clone for kaiocb {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct aioliojob {
    pub _address: u8,
}
impl Clone for aioliojob {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct sysent {
    pub _address: u8,
}
impl Clone for sysent {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct cdev_priv {
    pub _address: u8,
}
impl Clone for cdev_priv {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct sysctl_req {
    pub _address: u8,
}
impl Clone for sysctl_req {
    fn clone(&self) -> Self { *self }
}
