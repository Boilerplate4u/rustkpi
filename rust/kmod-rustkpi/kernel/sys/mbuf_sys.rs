/* automatically generated by rust-bindgen */

#[repr(C)]
pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
impl <T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self { __BindgenUnionField(::core::marker::PhantomData) }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T { ::core::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T { ::core::mem::transmute(self) }
}
impl <T> ::core::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self { Self::new() }
}
impl <T> ::core::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::core::marker::Copy for __BindgenUnionField<T> { }
impl <T> ::core::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl <T> ::core::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) { }
}
impl <T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool { true }
}
impl <T> ::core::cmp::Eq for __BindgenUnionField<T> { }
pub const __GNUCLIKE_ASM: ::kernel::sys::raw::c_uint = 3;
pub const __GNUCLIKE___TYPEOF: ::kernel::sys::raw::c_uint = 1;
pub const __GNUCLIKE___OFFSETOF: ::kernel::sys::raw::c_uint = 1;
pub const __GNUCLIKE___SECTION: ::kernel::sys::raw::c_uint = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: ::kernel::sys::raw::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: ::kernel::sys::raw::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: ::kernel::sys::raw::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: ::kernel::sys::raw::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: ::kernel::sys::raw::c_uint = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: ::kernel::sys::raw::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: ::kernel::sys::raw::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: ::kernel::sys::raw::c_uint = 1;
pub const __CC_SUPPORTS_INLINE: ::kernel::sys::raw::c_uint = 1;
pub const __CC_SUPPORTS___INLINE: ::kernel::sys::raw::c_uint = 1;
pub const __CC_SUPPORTS___INLINE__: ::kernel::sys::raw::c_uint = 1;
pub const __CC_SUPPORTS___FUNC__: ::kernel::sys::raw::c_uint = 1;
pub const __CC_SUPPORTS_WARNING: ::kernel::sys::raw::c_uint = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: ::kernel::sys::raw::c_uint = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: ::kernel::sys::raw::c_uint = 1;
pub const __POSIX_VISIBLE: ::kernel::sys::raw::c_uint = 200809;
pub const __XSI_VISIBLE: ::kernel::sys::raw::c_uint = 700;
pub const __BSD_VISIBLE: ::kernel::sys::raw::c_uint = 1;
pub const __ISO_C_VISIBLE: ::kernel::sys::raw::c_uint = 2011;
pub const __EXT1_VISIBLE: ::kernel::sys::raw::c_uint = 1;
pub const __CHAR_BIT: ::kernel::sys::raw::c_uint = 8;
pub const __SCHAR_MAX: ::kernel::sys::raw::c_uint = 127;
pub const __SCHAR_MIN: ::kernel::sys::raw::c_int = -128;
pub const __UCHAR_MAX: ::kernel::sys::raw::c_uint = 255;
pub const __USHRT_MAX: ::kernel::sys::raw::c_uint = 65535;
pub const __SHRT_MAX: ::kernel::sys::raw::c_uint = 32767;
pub const __SHRT_MIN: ::kernel::sys::raw::c_int = -32768;
pub const __UINT_MAX: ::kernel::sys::raw::c_uint = 4294967295;
pub const __INT_MAX: ::kernel::sys::raw::c_uint = 2147483647;
pub const __INT_MIN: ::kernel::sys::raw::c_int = -2147483648;
pub const __ULONG_MAX: ::kernel::sys::raw::c_int = -1;
pub const __LONG_MAX: ::kernel::sys::raw::c_ulonglong = 9223372036854775807;
pub const __LONG_MIN: ::kernel::sys::raw::c_longlong = -9223372036854775808;
pub const __ULLONG_MAX: ::kernel::sys::raw::c_int = -1;
pub const __LLONG_MAX: ::kernel::sys::raw::c_ulonglong = 9223372036854775807;
pub const __LLONG_MIN: ::kernel::sys::raw::c_longlong = -9223372036854775808;
pub const __SSIZE_MAX: ::kernel::sys::raw::c_ulonglong = 9223372036854775807;
pub const __SIZE_T_MAX: ::kernel::sys::raw::c_int = -1;
pub const __OFF_MAX: ::kernel::sys::raw::c_ulonglong = 9223372036854775807;
pub const __OFF_MIN: ::kernel::sys::raw::c_longlong = -9223372036854775808;
pub const __UQUAD_MAX: ::kernel::sys::raw::c_int = -1;
pub const __QUAD_MAX: ::kernel::sys::raw::c_ulonglong = 9223372036854775807;
pub const __QUAD_MIN: ::kernel::sys::raw::c_longlong = -9223372036854775808;
pub const __LONG_BIT: ::kernel::sys::raw::c_uint = 64;
pub const __WORD_BIT: ::kernel::sys::raw::c_uint = 32;
pub const __MINSIGSTKSZ: ::kernel::sys::raw::c_uint = 2048;
pub const __WCHAR_MIN: ::kernel::sys::raw::c_int = -2147483648;
pub const __WCHAR_MAX: ::kernel::sys::raw::c_uint = 2147483647;
pub const _QUAD_HIGHWORD: ::kernel::sys::raw::c_uint = 1;
pub const _QUAD_LOWWORD: ::kernel::sys::raw::c_uint = 0;
pub const _LITTLE_ENDIAN: ::kernel::sys::raw::c_uint = 1234;
pub const _BIG_ENDIAN: ::kernel::sys::raw::c_uint = 4321;
pub const _PDP_ENDIAN: ::kernel::sys::raw::c_uint = 3412;
pub const _BYTE_ORDER: ::kernel::sys::raw::c_uint = 1234;
pub const LITTLE_ENDIAN: ::kernel::sys::raw::c_uint = 1234;
pub const BIG_ENDIAN: ::kernel::sys::raw::c_uint = 4321;
pub const PDP_ENDIAN: ::kernel::sys::raw::c_uint = 3412;
pub const BYTE_ORDER: ::kernel::sys::raw::c_uint = 1234;
pub const __bool_true_false_are_defined: ::kernel::sys::raw::c_uint = 1;
pub const false_: ::kernel::sys::raw::c_uint = 0;
pub const true_: ::kernel::sys::raw::c_uint = 1;
pub const _SIG_WORDS: ::kernel::sys::raw::c_uint = 4;
pub const _SIG_MAXSIG: ::kernel::sys::raw::c_uint = 128;
pub const FD_SETSIZE: ::kernel::sys::raw::c_uint = 1024;
pub const MPLOCKED: &'static [u8; 8usize] = b"lock ; \x00";
pub const OFFSETOF_MONITORBUF: ::kernel::sys::raw::c_uint = 256;
pub const CR4_PGE: ::kernel::sys::raw::c_uint = 128;
pub const INVPCID_ADDR: ::kernel::sys::raw::c_uint = 0;
pub const INVPCID_CTX: ::kernel::sys::raw::c_uint = 1;
pub const INVPCID_CTXGLOB: ::kernel::sys::raw::c_uint = 2;
pub const INVPCID_ALLCTX: ::kernel::sys::raw::c_uint = 3;
pub const MSR_FSBASE: ::kernel::sys::raw::c_uint = 3221225728;
pub const MSR_GSBASE: ::kernel::sys::raw::c_uint = 3221225729;
pub const CALLOUT_LOCAL_ALLOC: ::kernel::sys::raw::c_uint = 1;
pub const CALLOUT_ACTIVE: ::kernel::sys::raw::c_uint = 2;
pub const CALLOUT_PENDING: ::kernel::sys::raw::c_uint = 4;
pub const CALLOUT_MPSAFE: ::kernel::sys::raw::c_uint = 8;
pub const CALLOUT_RETURNUNLOCKED: ::kernel::sys::raw::c_uint = 16;
pub const CALLOUT_SHAREDLOCK: ::kernel::sys::raw::c_uint = 32;
pub const CALLOUT_DFRMIGRATION: ::kernel::sys::raw::c_uint = 64;
pub const CALLOUT_PROCESSED: ::kernel::sys::raw::c_uint = 128;
pub const CALLOUT_DIRECT: ::kernel::sys::raw::c_uint = 256;
pub const C_DIRECT_EXEC: ::kernel::sys::raw::c_uint = 1;
pub const C_PRELBITS: ::kernel::sys::raw::c_uint = 7;
pub const C_PRELRANGE: ::kernel::sys::raw::c_uint = 127;
pub const C_HARDCLOCK: ::kernel::sys::raw::c_uint = 256;
pub const C_ABSOLUTE: ::kernel::sys::raw::c_uint = 512;
pub const C_PRECALC: ::kernel::sys::raw::c_uint = 1024;
pub const C_CATCH: ::kernel::sys::raw::c_uint = 2048;
pub const CS_DRAIN: ::kernel::sys::raw::c_uint = 1;
pub const CS_EXECUTING: ::kernel::sys::raw::c_uint = 2;
pub const INT8_MIN: ::kernel::sys::raw::c_int = -128;
pub const INT16_MIN: ::kernel::sys::raw::c_int = -32768;
pub const INT32_MIN: ::kernel::sys::raw::c_int = -2147483648;
pub const INT8_MAX: ::kernel::sys::raw::c_uint = 127;
pub const INT16_MAX: ::kernel::sys::raw::c_uint = 32767;
pub const INT32_MAX: ::kernel::sys::raw::c_uint = 2147483647;
pub const UINT8_MAX: ::kernel::sys::raw::c_uint = 255;
pub const UINT16_MAX: ::kernel::sys::raw::c_uint = 65535;
pub const UINT32_MAX: ::kernel::sys::raw::c_uint = 4294967295;
pub const INT64_MIN: ::kernel::sys::raw::c_longlong = -9223372036854775808;
pub const INT64_MAX: ::kernel::sys::raw::c_ulonglong = 9223372036854775807;
pub const UINT64_MAX: ::kernel::sys::raw::c_int = -1;
pub const INT_LEAST8_MIN: ::kernel::sys::raw::c_int = -128;
pub const INT_LEAST16_MIN: ::kernel::sys::raw::c_int = -32768;
pub const INT_LEAST32_MIN: ::kernel::sys::raw::c_int = -2147483648;
pub const INT_LEAST64_MIN: ::kernel::sys::raw::c_longlong =
    -9223372036854775808;
pub const INT_LEAST8_MAX: ::kernel::sys::raw::c_uint = 127;
pub const INT_LEAST16_MAX: ::kernel::sys::raw::c_uint = 32767;
pub const INT_LEAST32_MAX: ::kernel::sys::raw::c_uint = 2147483647;
pub const INT_LEAST64_MAX: ::kernel::sys::raw::c_ulonglong =
    9223372036854775807;
pub const UINT_LEAST8_MAX: ::kernel::sys::raw::c_uint = 255;
pub const UINT_LEAST16_MAX: ::kernel::sys::raw::c_uint = 65535;
pub const UINT_LEAST32_MAX: ::kernel::sys::raw::c_uint = 4294967295;
pub const UINT_LEAST64_MAX: ::kernel::sys::raw::c_int = -1;
pub const INT_FAST8_MIN: ::kernel::sys::raw::c_int = -2147483648;
pub const INT_FAST16_MIN: ::kernel::sys::raw::c_int = -2147483648;
pub const INT_FAST32_MIN: ::kernel::sys::raw::c_int = -2147483648;
pub const INT_FAST64_MIN: ::kernel::sys::raw::c_longlong =
    -9223372036854775808;
pub const INT_FAST8_MAX: ::kernel::sys::raw::c_uint = 2147483647;
pub const INT_FAST16_MAX: ::kernel::sys::raw::c_uint = 2147483647;
pub const INT_FAST32_MAX: ::kernel::sys::raw::c_uint = 2147483647;
pub const INT_FAST64_MAX: ::kernel::sys::raw::c_ulonglong =
    9223372036854775807;
pub const UINT_FAST8_MAX: ::kernel::sys::raw::c_uint = 4294967295;
pub const UINT_FAST16_MAX: ::kernel::sys::raw::c_uint = 4294967295;
pub const UINT_FAST32_MAX: ::kernel::sys::raw::c_uint = 4294967295;
pub const UINT_FAST64_MAX: ::kernel::sys::raw::c_int = -1;
pub const INTPTR_MIN: ::kernel::sys::raw::c_longlong = -9223372036854775808;
pub const INTPTR_MAX: ::kernel::sys::raw::c_ulonglong = 9223372036854775807;
pub const UINTPTR_MAX: ::kernel::sys::raw::c_int = -1;
pub const INTMAX_MIN: ::kernel::sys::raw::c_longlong = -9223372036854775808;
pub const INTMAX_MAX: ::kernel::sys::raw::c_ulonglong = 9223372036854775807;
pub const UINTMAX_MAX: ::kernel::sys::raw::c_int = -1;
pub const PTRDIFF_MIN: ::kernel::sys::raw::c_longlong = -9223372036854775808;
pub const PTRDIFF_MAX: ::kernel::sys::raw::c_ulonglong = 9223372036854775807;
pub const SIG_ATOMIC_MIN: ::kernel::sys::raw::c_longlong =
    -9223372036854775808;
pub const SIG_ATOMIC_MAX: ::kernel::sys::raw::c_ulonglong =
    9223372036854775807;
pub const SIZE_MAX: ::kernel::sys::raw::c_int = -1;
pub const WINT_MIN: ::kernel::sys::raw::c_int = -2147483648;
pub const WINT_MAX: ::kernel::sys::raw::c_uint = 2147483647;
pub const __WORDSIZE: ::kernel::sys::raw::c_uint = 64;
pub const WCHAR_MIN: ::kernel::sys::raw::c_int = -2147483648;
pub const WCHAR_MAX: ::kernel::sys::raw::c_uint = 2147483647;
pub const RSIZE_MAX: ::kernel::sys::raw::c_int = -1;
pub const BSD: ::kernel::sys::raw::c_uint = 199506;
pub const BSD4_3: ::kernel::sys::raw::c_uint = 1;
pub const BSD4_4: ::kernel::sys::raw::c_uint = 1;
pub const __FreeBSD_version: ::kernel::sys::raw::c_uint = 1200074;
pub const P_OSREL_SIGWAIT: ::kernel::sys::raw::c_uint = 700000;
pub const P_OSREL_SIGSEGV: ::kernel::sys::raw::c_uint = 700004;
pub const P_OSREL_MAP_ANON: ::kernel::sys::raw::c_uint = 800104;
pub const P_OSREL_MAP_FSTRICT: ::kernel::sys::raw::c_uint = 1100036;
pub const P_OSREL_SHUTDOWN_ENOTCONN: ::kernel::sys::raw::c_uint = 1100077;
pub const P_OSREL_MAP_GUARD: ::kernel::sys::raw::c_uint = 1200035;
pub const P_OSREL_WRFSBASE: ::kernel::sys::raw::c_uint = 1200041;
pub const P_OSREL_CK_CYLGRP: ::kernel::sys::raw::c_uint = 1200046;
pub const P_OSREL_VMTOTAL64: ::kernel::sys::raw::c_uint = 1200054;
pub const ARG_MAX: ::kernel::sys::raw::c_uint = 262144;
pub const CHILD_MAX: ::kernel::sys::raw::c_uint = 40;
pub const MAX_CANON: ::kernel::sys::raw::c_uint = 255;
pub const MAX_INPUT: ::kernel::sys::raw::c_uint = 255;
pub const NAME_MAX: ::kernel::sys::raw::c_uint = 255;
pub const NGROUPS_MAX: ::kernel::sys::raw::c_uint = 1023;
pub const OPEN_MAX: ::kernel::sys::raw::c_uint = 64;
pub const PATH_MAX: ::kernel::sys::raw::c_uint = 1024;
pub const PIPE_BUF: ::kernel::sys::raw::c_uint = 512;
pub const IOV_MAX: ::kernel::sys::raw::c_uint = 1024;
pub const MAXCOMLEN: ::kernel::sys::raw::c_uint = 19;
pub const MAXINTERP: ::kernel::sys::raw::c_uint = 1024;
pub const MAXLOGNAME: ::kernel::sys::raw::c_uint = 33;
pub const MAXUPRC: ::kernel::sys::raw::c_uint = 40;
pub const NCARGS: ::kernel::sys::raw::c_uint = 262144;
pub const NGROUPS: ::kernel::sys::raw::c_uint = 1024;
pub const NOFILE: ::kernel::sys::raw::c_uint = 64;
pub const NOGROUP: ::kernel::sys::raw::c_uint = 65535;
pub const MAXHOSTNAMELEN: ::kernel::sys::raw::c_uint = 256;
pub const SPECNAMELEN: ::kernel::sys::raw::c_uint = 63;
pub const EPERM: ::kernel::sys::raw::c_uint = 1;
pub const ENOENT: ::kernel::sys::raw::c_uint = 2;
pub const ESRCH: ::kernel::sys::raw::c_uint = 3;
pub const EINTR: ::kernel::sys::raw::c_uint = 4;
pub const EIO: ::kernel::sys::raw::c_uint = 5;
pub const ENXIO: ::kernel::sys::raw::c_uint = 6;
pub const E2BIG: ::kernel::sys::raw::c_uint = 7;
pub const ENOEXEC: ::kernel::sys::raw::c_uint = 8;
pub const EBADF: ::kernel::sys::raw::c_uint = 9;
pub const ECHILD: ::kernel::sys::raw::c_uint = 10;
pub const EDEADLK: ::kernel::sys::raw::c_uint = 11;
pub const ENOMEM: ::kernel::sys::raw::c_uint = 12;
pub const EACCES: ::kernel::sys::raw::c_uint = 13;
pub const EFAULT: ::kernel::sys::raw::c_uint = 14;
pub const ENOTBLK: ::kernel::sys::raw::c_uint = 15;
pub const EBUSY: ::kernel::sys::raw::c_uint = 16;
pub const EEXIST: ::kernel::sys::raw::c_uint = 17;
pub const EXDEV: ::kernel::sys::raw::c_uint = 18;
pub const ENODEV: ::kernel::sys::raw::c_uint = 19;
pub const ENOTDIR: ::kernel::sys::raw::c_uint = 20;
pub const EISDIR: ::kernel::sys::raw::c_uint = 21;
pub const EINVAL: ::kernel::sys::raw::c_uint = 22;
pub const ENFILE: ::kernel::sys::raw::c_uint = 23;
pub const EMFILE: ::kernel::sys::raw::c_uint = 24;
pub const ENOTTY: ::kernel::sys::raw::c_uint = 25;
pub const ETXTBSY: ::kernel::sys::raw::c_uint = 26;
pub const EFBIG: ::kernel::sys::raw::c_uint = 27;
pub const ENOSPC: ::kernel::sys::raw::c_uint = 28;
pub const ESPIPE: ::kernel::sys::raw::c_uint = 29;
pub const EROFS: ::kernel::sys::raw::c_uint = 30;
pub const EMLINK: ::kernel::sys::raw::c_uint = 31;
pub const EPIPE: ::kernel::sys::raw::c_uint = 32;
pub const EDOM: ::kernel::sys::raw::c_uint = 33;
pub const ERANGE: ::kernel::sys::raw::c_uint = 34;
pub const EAGAIN: ::kernel::sys::raw::c_uint = 35;
pub const EWOULDBLOCK: ::kernel::sys::raw::c_uint = 35;
pub const EINPROGRESS: ::kernel::sys::raw::c_uint = 36;
pub const EALREADY: ::kernel::sys::raw::c_uint = 37;
pub const ENOTSOCK: ::kernel::sys::raw::c_uint = 38;
pub const EDESTADDRREQ: ::kernel::sys::raw::c_uint = 39;
pub const EMSGSIZE: ::kernel::sys::raw::c_uint = 40;
pub const EPROTOTYPE: ::kernel::sys::raw::c_uint = 41;
pub const ENOPROTOOPT: ::kernel::sys::raw::c_uint = 42;
pub const EPROTONOSUPPORT: ::kernel::sys::raw::c_uint = 43;
pub const ESOCKTNOSUPPORT: ::kernel::sys::raw::c_uint = 44;
pub const EOPNOTSUPP: ::kernel::sys::raw::c_uint = 45;
pub const ENOTSUP: ::kernel::sys::raw::c_uint = 45;
pub const EPFNOSUPPORT: ::kernel::sys::raw::c_uint = 46;
pub const EAFNOSUPPORT: ::kernel::sys::raw::c_uint = 47;
pub const EADDRINUSE: ::kernel::sys::raw::c_uint = 48;
pub const EADDRNOTAVAIL: ::kernel::sys::raw::c_uint = 49;
pub const ENETDOWN: ::kernel::sys::raw::c_uint = 50;
pub const ENETUNREACH: ::kernel::sys::raw::c_uint = 51;
pub const ENETRESET: ::kernel::sys::raw::c_uint = 52;
pub const ECONNABORTED: ::kernel::sys::raw::c_uint = 53;
pub const ECONNRESET: ::kernel::sys::raw::c_uint = 54;
pub const ENOBUFS: ::kernel::sys::raw::c_uint = 55;
pub const EISCONN: ::kernel::sys::raw::c_uint = 56;
pub const ENOTCONN: ::kernel::sys::raw::c_uint = 57;
pub const ESHUTDOWN: ::kernel::sys::raw::c_uint = 58;
pub const ETOOMANYREFS: ::kernel::sys::raw::c_uint = 59;
pub const ETIMEDOUT: ::kernel::sys::raw::c_uint = 60;
pub const ECONNREFUSED: ::kernel::sys::raw::c_uint = 61;
pub const ELOOP: ::kernel::sys::raw::c_uint = 62;
pub const ENAMETOOLONG: ::kernel::sys::raw::c_uint = 63;
pub const EHOSTDOWN: ::kernel::sys::raw::c_uint = 64;
pub const EHOSTUNREACH: ::kernel::sys::raw::c_uint = 65;
pub const ENOTEMPTY: ::kernel::sys::raw::c_uint = 66;
pub const EPROCLIM: ::kernel::sys::raw::c_uint = 67;
pub const EUSERS: ::kernel::sys::raw::c_uint = 68;
pub const EDQUOT: ::kernel::sys::raw::c_uint = 69;
pub const ESTALE: ::kernel::sys::raw::c_uint = 70;
pub const EREMOTE: ::kernel::sys::raw::c_uint = 71;
pub const EBADRPC: ::kernel::sys::raw::c_uint = 72;
pub const ERPCMISMATCH: ::kernel::sys::raw::c_uint = 73;
pub const EPROGUNAVAIL: ::kernel::sys::raw::c_uint = 74;
pub const EPROGMISMATCH: ::kernel::sys::raw::c_uint = 75;
pub const EPROCUNAVAIL: ::kernel::sys::raw::c_uint = 76;
pub const ENOLCK: ::kernel::sys::raw::c_uint = 77;
pub const ENOSYS: ::kernel::sys::raw::c_uint = 78;
pub const EFTYPE: ::kernel::sys::raw::c_uint = 79;
pub const EAUTH: ::kernel::sys::raw::c_uint = 80;
pub const ENEEDAUTH: ::kernel::sys::raw::c_uint = 81;
pub const EIDRM: ::kernel::sys::raw::c_uint = 82;
pub const ENOMSG: ::kernel::sys::raw::c_uint = 83;
pub const EOVERFLOW: ::kernel::sys::raw::c_uint = 84;
pub const ECANCELED: ::kernel::sys::raw::c_uint = 85;
pub const EILSEQ: ::kernel::sys::raw::c_uint = 86;
pub const ENOATTR: ::kernel::sys::raw::c_uint = 87;
pub const EDOOFUS: ::kernel::sys::raw::c_uint = 88;
pub const EBADMSG: ::kernel::sys::raw::c_uint = 89;
pub const EMULTIHOP: ::kernel::sys::raw::c_uint = 90;
pub const ENOLINK: ::kernel::sys::raw::c_uint = 91;
pub const EPROTO: ::kernel::sys::raw::c_uint = 92;
pub const ENOTCAPABLE: ::kernel::sys::raw::c_uint = 93;
pub const ECAPMODE: ::kernel::sys::raw::c_uint = 94;
pub const ENOTRECOVERABLE: ::kernel::sys::raw::c_uint = 95;
pub const EOWNERDEAD: ::kernel::sys::raw::c_uint = 96;
pub const ELAST: ::kernel::sys::raw::c_uint = 96;
pub const ERESTART: ::kernel::sys::raw::c_int = -1;
pub const EJUSTRETURN: ::kernel::sys::raw::c_int = -2;
pub const ENOIOCTL: ::kernel::sys::raw::c_int = -3;
pub const EDIRIOCTL: ::kernel::sys::raw::c_int = -4;
pub const ERELOOKUP: ::kernel::sys::raw::c_int = -5;
pub const DST_NONE: ::kernel::sys::raw::c_uint = 0;
pub const DST_USA: ::kernel::sys::raw::c_uint = 1;
pub const DST_AUST: ::kernel::sys::raw::c_uint = 2;
pub const DST_WET: ::kernel::sys::raw::c_uint = 3;
pub const DST_MET: ::kernel::sys::raw::c_uint = 4;
pub const DST_EET: ::kernel::sys::raw::c_uint = 5;
pub const DST_CAN: ::kernel::sys::raw::c_uint = 6;
pub const SBT_MAX: ::kernel::sys::raw::c_ulonglong = 9223372036854775807;
pub const ITIMER_REAL: ::kernel::sys::raw::c_uint = 0;
pub const ITIMER_VIRTUAL: ::kernel::sys::raw::c_uint = 1;
pub const ITIMER_PROF: ::kernel::sys::raw::c_uint = 2;
pub const CLOCK_REALTIME: ::kernel::sys::raw::c_uint = 0;
pub const CLOCK_VIRTUAL: ::kernel::sys::raw::c_uint = 1;
pub const CLOCK_PROF: ::kernel::sys::raw::c_uint = 2;
pub const CLOCK_MONOTONIC: ::kernel::sys::raw::c_uint = 4;
pub const CLOCK_UPTIME: ::kernel::sys::raw::c_uint = 5;
pub const CLOCK_UPTIME_PRECISE: ::kernel::sys::raw::c_uint = 7;
pub const CLOCK_UPTIME_FAST: ::kernel::sys::raw::c_uint = 8;
pub const CLOCK_REALTIME_PRECISE: ::kernel::sys::raw::c_uint = 9;
pub const CLOCK_REALTIME_FAST: ::kernel::sys::raw::c_uint = 10;
pub const CLOCK_MONOTONIC_PRECISE: ::kernel::sys::raw::c_uint = 11;
pub const CLOCK_MONOTONIC_FAST: ::kernel::sys::raw::c_uint = 12;
pub const CLOCK_SECOND: ::kernel::sys::raw::c_uint = 13;
pub const CLOCK_THREAD_CPUTIME_ID: ::kernel::sys::raw::c_uint = 14;
pub const CLOCK_PROCESS_CPUTIME_ID: ::kernel::sys::raw::c_uint = 15;
pub const TIMER_RELTIME: ::kernel::sys::raw::c_uint = 0;
pub const TIMER_ABSTIME: ::kernel::sys::raw::c_uint = 1;
pub const CPUCLOCK_WHICH_PID: ::kernel::sys::raw::c_uint = 0;
pub const CPUCLOCK_WHICH_TID: ::kernel::sys::raw::c_uint = 1;
pub const TC_DEFAULTPERC: ::kernel::sys::raw::c_uint = 5;
pub const PRI_ITHD: ::kernel::sys::raw::c_uint = 1;
pub const PRI_REALTIME: ::kernel::sys::raw::c_uint = 2;
pub const PRI_TIMESHARE: ::kernel::sys::raw::c_uint = 3;
pub const PRI_IDLE: ::kernel::sys::raw::c_uint = 4;
pub const PRI_FIFO_BIT: ::kernel::sys::raw::c_uint = 8;
pub const PRI_FIFO: ::kernel::sys::raw::c_uint = 10;
pub const PRI_MIN: ::kernel::sys::raw::c_uint = 0;
pub const PRI_MAX: ::kernel::sys::raw::c_uint = 255;
pub const PRI_MIN_ITHD: ::kernel::sys::raw::c_uint = 0;
pub const PI_REALTIME: ::kernel::sys::raw::c_uint = 0;
pub const PI_AV: ::kernel::sys::raw::c_uint = 4;
pub const PI_NET: ::kernel::sys::raw::c_uint = 8;
pub const PI_DISK: ::kernel::sys::raw::c_uint = 12;
pub const PI_TTY: ::kernel::sys::raw::c_uint = 16;
pub const PI_DULL: ::kernel::sys::raw::c_uint = 20;
pub const PI_SOFT: ::kernel::sys::raw::c_uint = 24;
pub const PRI_MIN_REALTIME: ::kernel::sys::raw::c_uint = 48;
pub const PRI_MIN_KERN: ::kernel::sys::raw::c_uint = 80;
pub const PSWP: ::kernel::sys::raw::c_uint = 80;
pub const PVM: ::kernel::sys::raw::c_uint = 84;
pub const PINOD: ::kernel::sys::raw::c_uint = 88;
pub const PRIBIO: ::kernel::sys::raw::c_uint = 92;
pub const PVFS: ::kernel::sys::raw::c_uint = 96;
pub const PZERO: ::kernel::sys::raw::c_uint = 100;
pub const PSOCK: ::kernel::sys::raw::c_uint = 104;
pub const PWAIT: ::kernel::sys::raw::c_uint = 108;
pub const PLOCK: ::kernel::sys::raw::c_uint = 112;
pub const PPAUSE: ::kernel::sys::raw::c_uint = 116;
pub const PRI_MIN_TIMESHARE: ::kernel::sys::raw::c_uint = 120;
pub const PUSER: ::kernel::sys::raw::c_uint = 120;
pub const PRI_MIN_IDLE: ::kernel::sys::raw::c_uint = 224;
pub const PRI_MAX_IDLE: ::kernel::sys::raw::c_uint = 255;
pub const PRI_USER: ::kernel::sys::raw::c_int = -2;
pub const PRI_UNCHANGED: ::kernel::sys::raw::c_int = -1;
pub const FALSE: ::kernel::sys::raw::c_uint = 0;
pub const TRUE: ::kernel::sys::raw::c_uint = 1;
pub const MACHINE: &'static [u8; 6usize] = b"amd64\x00";
pub const MACHINE_ARCH: &'static [u8; 6usize] = b"amd64\x00";
pub const MACHINE_ARCH32: &'static [u8; 5usize] = b"i386\x00";
pub const MAXCPU: ::kernel::sys::raw::c_uint = 256;
pub const MAXMEMDOM: ::kernel::sys::raw::c_uint = 8;
pub const CACHE_LINE_SHIFT: ::kernel::sys::raw::c_uint = 6;
pub const CACHE_LINE_SIZE: ::kernel::sys::raw::c_uint = 64;
pub const NPTEPGSHIFT: ::kernel::sys::raw::c_uint = 9;
pub const PAGE_SHIFT: ::kernel::sys::raw::c_uint = 12;
pub const PAGE_SIZE: ::kernel::sys::raw::c_uint = 4096;
pub const PAGE_MASK: ::kernel::sys::raw::c_uint = 4095;
pub const NPDEPGSHIFT: ::kernel::sys::raw::c_uint = 9;
pub const PDRSHIFT: ::kernel::sys::raw::c_uint = 21;
pub const NBPDR: ::kernel::sys::raw::c_uint = 2097152;
pub const PDRMASK: ::kernel::sys::raw::c_uint = 2097151;
pub const NPDPEPGSHIFT: ::kernel::sys::raw::c_uint = 9;
pub const PDPSHIFT: ::kernel::sys::raw::c_uint = 30;
pub const NBPDP: ::kernel::sys::raw::c_uint = 1073741824;
pub const PDPMASK: ::kernel::sys::raw::c_uint = 1073741823;
pub const NPML4EPGSHIFT: ::kernel::sys::raw::c_uint = 9;
pub const PML4SHIFT: ::kernel::sys::raw::c_uint = 39;
pub const NBPML4: ::kernel::sys::raw::c_ulonglong = 549755813888;
pub const PML4MASK: ::kernel::sys::raw::c_ulonglong = 549755813887;
pub const MAXPAGESIZES: ::kernel::sys::raw::c_uint = 3;
pub const IOPAGES: ::kernel::sys::raw::c_uint = 2;
pub const IOPERM_BITMAP_SIZE: ::kernel::sys::raw::c_uint = 8193;
pub const KSTACK_PAGES: ::kernel::sys::raw::c_uint = 4;
pub const KSTACK_GUARD_PAGES: ::kernel::sys::raw::c_uint = 1;
pub const DEV_BSHIFT: ::kernel::sys::raw::c_uint = 9;
pub const DEV_BSIZE: ::kernel::sys::raw::c_uint = 512;
pub const BLKDEV_IOSIZE: ::kernel::sys::raw::c_uint = 4096;
pub const DFLTPHYS: ::kernel::sys::raw::c_uint = 65536;
pub const MAXPHYS: ::kernel::sys::raw::c_uint = 131072;
pub const MAXDUMPPGS: ::kernel::sys::raw::c_uint = 16;
pub const MSIZE: ::kernel::sys::raw::c_uint = 256;
pub const MCLSHIFT: ::kernel::sys::raw::c_uint = 11;
pub const MCLBYTES: ::kernel::sys::raw::c_uint = 2048;
pub const MJUMPAGESIZE: ::kernel::sys::raw::c_uint = 4096;
pub const MJUM9BYTES: ::kernel::sys::raw::c_uint = 9216;
pub const MJUM16BYTES: ::kernel::sys::raw::c_uint = 16384;
pub const PRIMASK: ::kernel::sys::raw::c_uint = 255;
pub const PCATCH: ::kernel::sys::raw::c_uint = 256;
pub const PDROP: ::kernel::sys::raw::c_uint = 512;
pub const NZERO: ::kernel::sys::raw::c_uint = 0;
pub const NBBY: ::kernel::sys::raw::c_uint = 8;
pub const CMASK: ::kernel::sys::raw::c_uint = 18;
pub const MAXBSIZE: ::kernel::sys::raw::c_uint = 65536;
pub const MAXBCACHEBUF: ::kernel::sys::raw::c_uint = 65536;
pub const BKVASIZE: ::kernel::sys::raw::c_uint = 16384;
pub const BKVAMASK: ::kernel::sys::raw::c_uint = 16383;
pub const MAXPATHLEN: ::kernel::sys::raw::c_uint = 1024;
pub const MAXSYMLINKS: ::kernel::sys::raw::c_uint = 32;
pub const FSHIFT: ::kernel::sys::raw::c_uint = 11;
pub const FSCALE: ::kernel::sys::raw::c_uint = 2048;
pub const CPU_SETSIZE: ::kernel::sys::raw::c_uint = 256;
pub const CPU_MAXSIZE: ::kernel::sys::raw::c_uint = 256;
pub const PRIO_MIN: ::kernel::sys::raw::c_int = -20;
pub const PRIO_MAX: ::kernel::sys::raw::c_uint = 20;
pub const PRIO_PROCESS: ::kernel::sys::raw::c_uint = 0;
pub const PRIO_PGRP: ::kernel::sys::raw::c_uint = 1;
pub const PRIO_USER: ::kernel::sys::raw::c_uint = 2;
pub const RUSAGE_SELF: ::kernel::sys::raw::c_uint = 0;
pub const RUSAGE_CHILDREN: ::kernel::sys::raw::c_int = -1;
pub const RUSAGE_THREAD: ::kernel::sys::raw::c_uint = 1;
pub const RLIMIT_CPU: ::kernel::sys::raw::c_uint = 0;
pub const RLIMIT_FSIZE: ::kernel::sys::raw::c_uint = 1;
pub const RLIMIT_DATA: ::kernel::sys::raw::c_uint = 2;
pub const RLIMIT_STACK: ::kernel::sys::raw::c_uint = 3;
pub const RLIMIT_CORE: ::kernel::sys::raw::c_uint = 4;
pub const RLIMIT_RSS: ::kernel::sys::raw::c_uint = 5;
pub const RLIMIT_MEMLOCK: ::kernel::sys::raw::c_uint = 6;
pub const RLIMIT_NPROC: ::kernel::sys::raw::c_uint = 7;
pub const RLIMIT_NOFILE: ::kernel::sys::raw::c_uint = 8;
pub const RLIMIT_SBSIZE: ::kernel::sys::raw::c_uint = 9;
pub const RLIMIT_VMEM: ::kernel::sys::raw::c_uint = 10;
pub const RLIMIT_AS: ::kernel::sys::raw::c_uint = 10;
pub const RLIMIT_NPTS: ::kernel::sys::raw::c_uint = 11;
pub const RLIMIT_SWAP: ::kernel::sys::raw::c_uint = 12;
pub const RLIMIT_KQUEUES: ::kernel::sys::raw::c_uint = 13;
pub const RLIMIT_UMTXP: ::kernel::sys::raw::c_uint = 14;
pub const RLIM_NLIMITS: ::kernel::sys::raw::c_uint = 15;
pub const CP_USER: ::kernel::sys::raw::c_uint = 0;
pub const CP_NICE: ::kernel::sys::raw::c_uint = 1;
pub const CP_SYS: ::kernel::sys::raw::c_uint = 2;
pub const CP_INTR: ::kernel::sys::raw::c_uint = 3;
pub const CP_IDLE: ::kernel::sys::raw::c_uint = 4;
pub const CPUSTATES: ::kernel::sys::raw::c_uint = 5;
pub const PC_PTI_STACK_SZ: ::kernel::sys::raw::c_uint = 16;
pub const PC_DBREG_CMD_NONE: ::kernel::sys::raw::c_uint = 0;
pub const PC_DBREG_CMD_LOAD: ::kernel::sys::raw::c_uint = 1;
pub const OFFSETOF_CURTHREAD: ::kernel::sys::raw::c_uint = 0;
pub const OFFSETOF_CURPCB: ::kernel::sys::raw::c_uint = 32;
pub const DPCPU_SETNAME: &'static [u8; 9usize] = b"set_pcpu\x00";
pub const DPCPU_SYMPREFIX: &'static [u8; 12usize] = b"pcpu_entry_\x00";
pub const DPCPU_MODMIN: ::kernel::sys::raw::c_uint = 2048;
pub const UMA_PCPU_ALLOC_SIZE: ::kernel::sys::raw::c_uint = 4096;
pub const HASH_NOWAIT: ::kernel::sys::raw::c_uint = 1;
pub const HASH_WAITOK: ::kernel::sys::raw::c_uint = 2;
pub const HD_COLUMN_MASK: ::kernel::sys::raw::c_uint = 255;
pub const HD_DELIM_MASK: ::kernel::sys::raw::c_uint = 65280;
pub const HD_OMIT_COUNT: ::kernel::sys::raw::c_uint = 65536;
pub const HD_OMIT_HEX: ::kernel::sys::raw::c_uint = 131072;
pub const HD_OMIT_CHARS: ::kernel::sys::raw::c_uint = 262144;
pub const GETENV_UNSIGNED: ::kernel::sys::raw::c_uint = 0;
pub const GETENV_SIGNED: ::kernel::sys::raw::c_uint = 1;
pub const LIBKERN_LEN_BCD2BIN: ::kernel::sys::raw::c_uint = 154;
pub const LIBKERN_LEN_BIN2BCD: ::kernel::sys::raw::c_uint = 100;
pub const LIBKERN_LEN_HEX2ASCII: ::kernel::sys::raw::c_uint = 36;
pub const ARC4_ENTR_NONE: ::kernel::sys::raw::c_uint = 0;
pub const ARC4_ENTR_HAVE: ::kernel::sys::raw::c_uint = 1;
pub const ARC4_ENTR_SEED: ::kernel::sys::raw::c_uint = 2;
pub const FNM_NOMATCH: ::kernel::sys::raw::c_uint = 1;
pub const FNM_NOESCAPE: ::kernel::sys::raw::c_uint = 1;
pub const FNM_PATHNAME: ::kernel::sys::raw::c_uint = 2;
pub const FNM_PERIOD: ::kernel::sys::raw::c_uint = 4;
pub const FNM_LEADING_DIR: ::kernel::sys::raw::c_uint = 8;
pub const FNM_CASEFOLD: ::kernel::sys::raw::c_uint = 16;
pub const FNM_IGNORECASE: ::kernel::sys::raw::c_uint = 16;
pub const FNM_FILE_NAME: ::kernel::sys::raw::c_uint = 2;
pub const M_NOWAIT: ::kernel::sys::raw::c_uint = 1;
pub const M_WAITOK: ::kernel::sys::raw::c_uint = 2;
pub const M_ZERO: ::kernel::sys::raw::c_uint = 256;
pub const M_NOVM: ::kernel::sys::raw::c_uint = 512;
pub const M_USE_RESERVE: ::kernel::sys::raw::c_uint = 1024;
pub const M_NODUMP: ::kernel::sys::raw::c_uint = 2048;
pub const M_FIRSTFIT: ::kernel::sys::raw::c_uint = 4096;
pub const M_BESTFIT: ::kernel::sys::raw::c_uint = 8192;
pub const M_EXEC: ::kernel::sys::raw::c_uint = 16384;
pub const M_MAGIC: ::kernel::sys::raw::c_uint = 877983977;
pub const DTMALLOC_PROBE_MALLOC: ::kernel::sys::raw::c_uint = 0;
pub const DTMALLOC_PROBE_FREE: ::kernel::sys::raw::c_uint = 1;
pub const DTMALLOC_PROBE_MAX: ::kernel::sys::raw::c_uint = 2;
pub const MALLOC_TYPE_STREAM_VERSION: ::kernel::sys::raw::c_uint = 1;
pub const MALLOC_MAX_NAME: ::kernel::sys::raw::c_uint = 32;
pub const UMA_SMALLEST_UNIT: ::kernel::sys::raw::c_uint = 16;
pub const UMA_ZONE_PAGEABLE: ::kernel::sys::raw::c_uint = 1;
pub const UMA_ZONE_ZINIT: ::kernel::sys::raw::c_uint = 2;
pub const UMA_ZONE_STATIC: ::kernel::sys::raw::c_uint = 4;
pub const UMA_ZONE_OFFPAGE: ::kernel::sys::raw::c_uint = 8;
pub const UMA_ZONE_MALLOC: ::kernel::sys::raw::c_uint = 16;
pub const UMA_ZONE_NOFREE: ::kernel::sys::raw::c_uint = 32;
pub const UMA_ZONE_MTXCLASS: ::kernel::sys::raw::c_uint = 64;
pub const UMA_ZONE_VM: ::kernel::sys::raw::c_uint = 128;
pub const UMA_ZONE_HASH: ::kernel::sys::raw::c_uint = 256;
pub const UMA_ZONE_SECONDARY: ::kernel::sys::raw::c_uint = 512;
pub const UMA_ZONE_NOBUCKET: ::kernel::sys::raw::c_uint = 1024;
pub const UMA_ZONE_MAXBUCKET: ::kernel::sys::raw::c_uint = 2048;
pub const UMA_ZONE_CACHESPREAD: ::kernel::sys::raw::c_uint = 4096;
pub const UMA_ZONE_VTOSLAB: ::kernel::sys::raw::c_uint = 8192;
pub const UMA_ZONE_NODUMP: ::kernel::sys::raw::c_uint = 16384;
pub const UMA_ZONE_PCPU: ::kernel::sys::raw::c_uint = 32768;
pub const UMA_ZONE_NUMA: ::kernel::sys::raw::c_uint = 65536;
pub const UMA_ZONE_NOBUCKETCACHE: ::kernel::sys::raw::c_uint = 131072;
pub const UMA_ZONE_INHERIT: ::kernel::sys::raw::c_uint = 41272;
pub const UMA_ALIGN_CACHE: ::kernel::sys::raw::c_int = -1;
pub const UMA_SLAB_BOOT: ::kernel::sys::raw::c_uint = 1;
pub const UMA_SLAB_KRWX: ::kernel::sys::raw::c_uint = 2;
pub const UMA_SLAB_KERNEL: ::kernel::sys::raw::c_uint = 4;
pub const UMA_SLAB_PRIV: ::kernel::sys::raw::c_uint = 8;
pub const UMA_SLAB_OFFP: ::kernel::sys::raw::c_uint = 16;
pub const UMA_SLAB_MALLOC: ::kernel::sys::raw::c_uint = 32;
pub const UMA_STREAM_VERSION: ::kernel::sys::raw::c_uint = 1;
pub const UTH_MAX_NAME: ::kernel::sys::raw::c_uint = 32;
pub const UTH_ZONE_SECONDARY: ::kernel::sys::raw::c_uint = 1;
pub const M_EXT: ::kernel::sys::raw::c_uint = 1;
pub const M_PKTHDR: ::kernel::sys::raw::c_uint = 2;
pub const M_EOR: ::kernel::sys::raw::c_uint = 4;
pub const M_RDONLY: ::kernel::sys::raw::c_uint = 8;
pub const M_BCAST: ::kernel::sys::raw::c_uint = 16;
pub const M_MCAST: ::kernel::sys::raw::c_uint = 32;
pub const M_PROMISC: ::kernel::sys::raw::c_uint = 64;
pub const M_VLANTAG: ::kernel::sys::raw::c_uint = 128;
pub const M_NOMAP: ::kernel::sys::raw::c_uint = 256;
pub const M_NOFREE: ::kernel::sys::raw::c_uint = 512;
pub const M_TSTMP: ::kernel::sys::raw::c_uint = 1024;
pub const M_TSTMP_HPREC: ::kernel::sys::raw::c_uint = 2048;
pub const M_PROTO1: ::kernel::sys::raw::c_uint = 4096;
pub const M_PROTO2: ::kernel::sys::raw::c_uint = 8192;
pub const M_PROTO3: ::kernel::sys::raw::c_uint = 16384;
pub const M_PROTO4: ::kernel::sys::raw::c_uint = 32768;
pub const M_PROTO5: ::kernel::sys::raw::c_uint = 65536;
pub const M_PROTO6: ::kernel::sys::raw::c_uint = 131072;
pub const M_PROTO7: ::kernel::sys::raw::c_uint = 262144;
pub const M_PROTO8: ::kernel::sys::raw::c_uint = 524288;
pub const M_PROTO9: ::kernel::sys::raw::c_uint = 1048576;
pub const M_PROTO10: ::kernel::sys::raw::c_uint = 2097152;
pub const M_PROTO11: ::kernel::sys::raw::c_uint = 4194304;
pub const M_PROTO12: ::kernel::sys::raw::c_uint = 8388608;
pub const MB_DTOR_SKIP: ::kernel::sys::raw::c_uint = 1;
pub const M_PROTOFLAGS: ::kernel::sys::raw::c_uint = 16773120;
pub const M_COPYFLAGS: ::kernel::sys::raw::c_uint = 16776446;
pub const M_FLAG_BITS: &'static [u8; 101usize] =
    b"\x10\x01M_EXT\\2M_PKTHDR\\3M_EOR\\4M_RDONLY\\5M_BCAST\\6M_MCAST\x07M_PROMISC\\10M_VLANTAG\\13M_TSTMP\\14M_TSTMP_HPREC\x00";
pub const M_FLAG_PROTOBITS: &'static [u8; 130usize] =
    b"\rM_PROTO1\\16M_PROTO2\\17M_PROTO3\\20M_PROTO4\\21M_PROTO5\x12M_PROTO6\\23M_PROTO7\\24M_PROTO8\\25M_PROTO9\\26M_PROTO10\x17M_PROTO11\\30M_PROTO12\x00";
pub const M_FLAG_PRINTF: &'static [u8; 230usize] =
    b"\x10\x01M_EXT\\2M_PKTHDR\\3M_EOR\\4M_RDONLY\\5M_BCAST\\6M_MCAST\x07M_PROMISC\\10M_VLANTAG\\13M_TSTMP\\14M_TSTMP_HPREC\rM_PROTO1\\16M_PROTO2\\17M_PROTO3\\20M_PROTO4\\21M_PROTO5\x12M_PROTO6\\23M_PROTO7\\24M_PROTO8\\25M_PROTO9\\26M_PROTO10\x17M_PROTO11\\30M_PROTO12\x00";
pub const M_HASHTYPE_HASHPROP: ::kernel::sys::raw::c_uint = 128;
pub const M_HASHTYPE_NONE: ::kernel::sys::raw::c_uint = 0;
pub const M_HASHTYPE_OPAQUE: ::kernel::sys::raw::c_uint = 63;
pub const QOS_DSCP_CS0: ::kernel::sys::raw::c_uint = 0;
pub const QOS_DSCP_DEF: ::kernel::sys::raw::c_uint = 0;
pub const QOS_DSCP_CS1: ::kernel::sys::raw::c_uint = 32;
pub const QOS_DSCP_AF11: ::kernel::sys::raw::c_uint = 40;
pub const QOS_DSCP_AF12: ::kernel::sys::raw::c_uint = 48;
pub const QOS_DSCP_AF13: ::kernel::sys::raw::c_uint = 56;
pub const QOS_DSCP_CS2: ::kernel::sys::raw::c_uint = 64;
pub const QOS_DSCP_AF21: ::kernel::sys::raw::c_uint = 72;
pub const QOS_DSCP_AF22: ::kernel::sys::raw::c_uint = 80;
pub const QOS_DSCP_AF23: ::kernel::sys::raw::c_uint = 88;
pub const QOS_DSCP_CS3: ::kernel::sys::raw::c_uint = 96;
pub const QOS_DSCP_AF31: ::kernel::sys::raw::c_uint = 104;
pub const QOS_DSCP_AF32: ::kernel::sys::raw::c_uint = 112;
pub const QOS_DSCP_AF33: ::kernel::sys::raw::c_uint = 120;
pub const QOS_DSCP_CS4: ::kernel::sys::raw::c_uint = 128;
pub const QOS_DSCP_AF41: ::kernel::sys::raw::c_uint = 136;
pub const QOS_DSCP_AF42: ::kernel::sys::raw::c_uint = 144;
pub const QOS_DSCP_AF43: ::kernel::sys::raw::c_uint = 152;
pub const QOS_DSCP_CS5: ::kernel::sys::raw::c_uint = 160;
pub const QOS_DSCP_EF: ::kernel::sys::raw::c_uint = 184;
pub const QOS_DSCP_CS6: ::kernel::sys::raw::c_uint = 192;
pub const QOS_DSCP_CS7: ::kernel::sys::raw::c_uint = 224;
pub const EXT_CLUSTER: ::kernel::sys::raw::c_uint = 1;
pub const EXT_SFBUF: ::kernel::sys::raw::c_uint = 2;
pub const EXT_JUMBOP: ::kernel::sys::raw::c_uint = 3;
pub const EXT_JUMBO9: ::kernel::sys::raw::c_uint = 4;
pub const EXT_JUMBO16: ::kernel::sys::raw::c_uint = 5;
pub const EXT_PACKET: ::kernel::sys::raw::c_uint = 6;
pub const EXT_MBUF: ::kernel::sys::raw::c_uint = 7;
pub const EXT_VENDOR1: ::kernel::sys::raw::c_uint = 224;
pub const EXT_VENDOR2: ::kernel::sys::raw::c_uint = 225;
pub const EXT_VENDOR3: ::kernel::sys::raw::c_uint = 226;
pub const EXT_VENDOR4: ::kernel::sys::raw::c_uint = 227;
pub const EXT_EXP1: ::kernel::sys::raw::c_uint = 244;
pub const EXT_EXP2: ::kernel::sys::raw::c_uint = 245;
pub const EXT_EXP3: ::kernel::sys::raw::c_uint = 246;
pub const EXT_EXP4: ::kernel::sys::raw::c_uint = 247;
pub const EXT_NET_DRV: ::kernel::sys::raw::c_uint = 252;
pub const EXT_MOD_TYPE: ::kernel::sys::raw::c_uint = 253;
pub const EXT_DISPOSABLE: ::kernel::sys::raw::c_uint = 254;
pub const EXT_EXTREF: ::kernel::sys::raw::c_uint = 255;
pub const EXT_FLAG_EMBREF: ::kernel::sys::raw::c_uint = 1;
pub const EXT_FLAG_EXTREF: ::kernel::sys::raw::c_uint = 2;
pub const EXT_FLAG_NOFREE: ::kernel::sys::raw::c_uint = 16;
pub const EXT_FLAG_VENDOR1: ::kernel::sys::raw::c_uint = 65536;
pub const EXT_FLAG_VENDOR2: ::kernel::sys::raw::c_uint = 131072;
pub const EXT_FLAG_VENDOR3: ::kernel::sys::raw::c_uint = 262144;
pub const EXT_FLAG_VENDOR4: ::kernel::sys::raw::c_uint = 524288;
pub const EXT_FLAG_EXP1: ::kernel::sys::raw::c_uint = 1048576;
pub const EXT_FLAG_EXP2: ::kernel::sys::raw::c_uint = 2097152;
pub const EXT_FLAG_EXP3: ::kernel::sys::raw::c_uint = 4194304;
pub const EXT_FLAG_EXP4: ::kernel::sys::raw::c_uint = 8388608;
pub const EXT_FLAG_BITS: &'static [u8; 186usize] =
    b"\x10\x01EXT_FLAG_EMBREF\\2EXT_FLAG_EXTREF\\5EXT_FLAG_NOFREE\x11EXT_FLAG_VENDOR1\\22EXT_FLAG_VENDOR2\\23EXT_FLAG_VENDOR3\x14EXT_FLAG_VENDOR4\\25EXT_FLAG_EXP1\\26EXT_FLAG_EXP2\\27EXT_FLAG_EXP3\x18EXT_FLAG_EXP4\x00";
pub const CSUM_IP: ::kernel::sys::raw::c_uint = 1;
pub const CSUM_IP_UDP: ::kernel::sys::raw::c_uint = 2;
pub const CSUM_IP_TCP: ::kernel::sys::raw::c_uint = 4;
pub const CSUM_IP_SCTP: ::kernel::sys::raw::c_uint = 8;
pub const CSUM_IP_TSO: ::kernel::sys::raw::c_uint = 16;
pub const CSUM_IP_ISCSI: ::kernel::sys::raw::c_uint = 32;
pub const CSUM_IP6_UDP: ::kernel::sys::raw::c_uint = 512;
pub const CSUM_IP6_TCP: ::kernel::sys::raw::c_uint = 1024;
pub const CSUM_IP6_SCTP: ::kernel::sys::raw::c_uint = 2048;
pub const CSUM_IP6_TSO: ::kernel::sys::raw::c_uint = 4096;
pub const CSUM_IP6_ISCSI: ::kernel::sys::raw::c_uint = 8192;
pub const CSUM_L3_CALC: ::kernel::sys::raw::c_uint = 16777216;
pub const CSUM_L3_VALID: ::kernel::sys::raw::c_uint = 33554432;
pub const CSUM_L4_CALC: ::kernel::sys::raw::c_uint = 67108864;
pub const CSUM_L4_VALID: ::kernel::sys::raw::c_uint = 134217728;
pub const CSUM_L5_CALC: ::kernel::sys::raw::c_uint = 268435456;
pub const CSUM_L5_VALID: ::kernel::sys::raw::c_uint = 536870912;
pub const CSUM_COALESCED: ::kernel::sys::raw::c_uint = 1073741824;
pub const CSUM_BITS: &'static [u8; 257usize] =
    b"\x10\x01CSUM_IP\\2CSUM_IP_UDP\\3CSUM_IP_TCP\\4CSUM_IP_SCTP\\5CSUM_IP_TSO\x06CSUM_IP_ISCSI\nCSUM_IP6_UDP\\13CSUM_IP6_TCP\\14CSUM_IP6_SCTP\\15CSUM_IP6_TSO\x0eCSUM_IP6_ISCSI\x19CSUM_L3_CALC\\32CSUM_L3_VALID\\33CSUM_L4_CALC\\34CSUM_L4_VALID\x1dCSUM_L5_CALC\\36CSUM_L5_VALID\\37CSUM_COALESCED\x00";
pub const CSUM_IP_CHECKED: ::kernel::sys::raw::c_uint = 16777216;
pub const CSUM_IP_VALID: ::kernel::sys::raw::c_uint = 33554432;
pub const CSUM_DATA_VALID: ::kernel::sys::raw::c_uint = 134217728;
pub const CSUM_PSEUDO_HDR: ::kernel::sys::raw::c_uint = 67108864;
pub const CSUM_SCTP_VALID: ::kernel::sys::raw::c_uint = 134217728;
pub const CSUM_DELAY_IP: ::kernel::sys::raw::c_uint = 1;
pub const CSUM_DATA_VALID_IPV6: ::kernel::sys::raw::c_uint = 134217728;
pub const CSUM_TCP: ::kernel::sys::raw::c_uint = 4;
pub const CSUM_UDP: ::kernel::sys::raw::c_uint = 2;
pub const CSUM_SCTP: ::kernel::sys::raw::c_uint = 8;
pub const CSUM_TSO: ::kernel::sys::raw::c_uint = 4112;
pub const CSUM_UDP_IPV6: ::kernel::sys::raw::c_uint = 512;
pub const CSUM_TCP_IPV6: ::kernel::sys::raw::c_uint = 1024;
pub const CSUM_SCTP_IPV6: ::kernel::sys::raw::c_uint = 2048;
pub const MT_NOTMBUF: ::kernel::sys::raw::c_uint = 0;
pub const MT_DATA: ::kernel::sys::raw::c_uint = 1;
pub const MT_HEADER: ::kernel::sys::raw::c_uint = 1;
pub const MT_VENDOR1: ::kernel::sys::raw::c_uint = 4;
pub const MT_VENDOR2: ::kernel::sys::raw::c_uint = 5;
pub const MT_VENDOR3: ::kernel::sys::raw::c_uint = 6;
pub const MT_VENDOR4: ::kernel::sys::raw::c_uint = 7;
pub const MT_SONAME: ::kernel::sys::raw::c_uint = 8;
pub const MT_EXP1: ::kernel::sys::raw::c_uint = 9;
pub const MT_EXP2: ::kernel::sys::raw::c_uint = 10;
pub const MT_EXP3: ::kernel::sys::raw::c_uint = 11;
pub const MT_EXP4: ::kernel::sys::raw::c_uint = 12;
pub const MT_CONTROL: ::kernel::sys::raw::c_uint = 14;
pub const MT_OOBDATA: ::kernel::sys::raw::c_uint = 15;
pub const MT_NTYPES: ::kernel::sys::raw::c_uint = 16;
pub const MT_NOINIT: ::kernel::sys::raw::c_uint = 255;
pub const MBUF_MEM_NAME: &'static [u8; 5usize] = b"mbuf\x00";
pub const MBUF_CLUSTER_MEM_NAME: &'static [u8; 13usize] = b"mbuf_cluster\x00";
pub const MBUF_PACKET_MEM_NAME: &'static [u8; 12usize] = b"mbuf_packet\x00";
pub const MBUF_JUMBOP_MEM_NAME: &'static [u8; 16usize] =
    b"mbuf_jumbo_page\x00";
pub const MBUF_JUMBO9_MEM_NAME: &'static [u8; 14usize] = b"mbuf_jumbo_9k\x00";
pub const MBUF_JUMBO16_MEM_NAME: &'static [u8; 15usize] =
    b"mbuf_jumbo_16k\x00";
pub const MBUF_TAG_MEM_NAME: &'static [u8; 9usize] = b"mbuf_tag\x00";
pub const MBUF_EXTREFCNT_MEM_NAME: &'static [u8; 16usize] =
    b"mbuf_ext_refcnt\x00";
pub const M_COPYALL: ::kernel::sys::raw::c_uint = 1000000000;
pub const MTAG_PERSISTENT: ::kernel::sys::raw::c_uint = 2048;
pub const PACKET_TAG_NONE: ::kernel::sys::raw::c_uint = 0;
pub const PACKET_TAG_IPSEC_IN_DONE: ::kernel::sys::raw::c_uint = 1;
pub const PACKET_TAG_IPSEC_OUT_DONE: ::kernel::sys::raw::c_uint = 2;
pub const PACKET_TAG_IPSEC_IN_CRYPTO_DONE: ::kernel::sys::raw::c_uint = 3;
pub const PACKET_TAG_IPSEC_OUT_CRYPTO_NEEDED: ::kernel::sys::raw::c_uint = 4;
pub const PACKET_TAG_IPSEC_IN_COULD_DO_CRYPTO: ::kernel::sys::raw::c_uint = 5;
pub const PACKET_TAG_IPSEC_PENDING_TDB: ::kernel::sys::raw::c_uint = 6;
pub const PACKET_TAG_BRIDGE: ::kernel::sys::raw::c_uint = 7;
pub const PACKET_TAG_GIF: ::kernel::sys::raw::c_uint = 8;
pub const PACKET_TAG_GRE: ::kernel::sys::raw::c_uint = 9;
pub const PACKET_TAG_IN_PACKET_CHECKSUM: ::kernel::sys::raw::c_uint = 10;
pub const PACKET_TAG_ENCAP: ::kernel::sys::raw::c_uint = 11;
pub const PACKET_TAG_IPSEC_SOCKET: ::kernel::sys::raw::c_uint = 12;
pub const PACKET_TAG_IPSEC_HISTORY: ::kernel::sys::raw::c_uint = 13;
pub const PACKET_TAG_IPV6_INPUT: ::kernel::sys::raw::c_uint = 14;
pub const PACKET_TAG_DUMMYNET: ::kernel::sys::raw::c_uint = 15;
pub const PACKET_TAG_DIVERT: ::kernel::sys::raw::c_uint = 17;
pub const PACKET_TAG_IPFORWARD: ::kernel::sys::raw::c_uint = 18;
pub const PACKET_TAG_MACLABEL: ::kernel::sys::raw::c_uint = 2067;
pub const PACKET_TAG_PF: ::kernel::sys::raw::c_uint = 2069;
pub const PACKET_TAG_RTSOCKFAM: ::kernel::sys::raw::c_uint = 25;
pub const PACKET_TAG_IPOPTIONS: ::kernel::sys::raw::c_uint = 27;
pub const PACKET_TAG_CARP: ::kernel::sys::raw::c_uint = 28;
pub const PACKET_TAG_IPSEC_NAT_T_PORTS: ::kernel::sys::raw::c_uint = 29;
pub const PACKET_TAG_ND_OUTGOING: ::kernel::sys::raw::c_uint = 30;
pub const MTAG_ABI_COMPAT: ::kernel::sys::raw::c_uint = 0;
pub const MBUF_HASHFLAG_L2: ::kernel::sys::raw::c_uint = 4;
pub const MBUF_HASHFLAG_L3: ::kernel::sys::raw::c_uint = 8;
pub const MBUF_HASHFLAG_L4: ::kernel::sys::raw::c_uint = 16;
pub type __int8_t = ::kernel::sys::raw::c_schar;
pub type __uint8_t = ::kernel::sys::raw::c_uchar;
pub type __int16_t = ::kernel::sys::raw::c_short;
pub type __uint16_t = ::kernel::sys::raw::c_ushort;
pub type __int32_t = ::kernel::sys::raw::c_int;
pub type __uint32_t = ::kernel::sys::raw::c_uint;
pub type __int64_t = ::kernel::sys::raw::c_long;
pub type __uint64_t = ::kernel::sys::raw::c_ulong;
pub type __clock_t = __int32_t;
pub type __critical_t = __int64_t;
pub type __double_t = f64;
pub type __float_t = f32;
pub type __intfptr_t = __int64_t;
pub type __intptr_t = __int64_t;
pub type __intmax_t = __int64_t;
pub type __int_fast8_t = __int32_t;
pub type __int_fast16_t = __int32_t;
pub type __int_fast32_t = __int32_t;
pub type __int_fast64_t = __int64_t;
pub type __int_least8_t = __int8_t;
pub type __int_least16_t = __int16_t;
pub type __int_least32_t = __int32_t;
pub type __int_least64_t = __int64_t;
pub type __ptrdiff_t = __int64_t;
pub type __register_t = __int64_t;
pub type __segsz_t = __int64_t;
pub type __size_t = __uint64_t;
pub type __ssize_t = __int64_t;
pub type __time_t = __int64_t;
pub type __uintfptr_t = __uint64_t;
pub type __uintptr_t = __uint64_t;
pub type __uintmax_t = __uint64_t;
pub type __uint_fast8_t = __uint32_t;
pub type __uint_fast16_t = __uint32_t;
pub type __uint_fast32_t = __uint32_t;
pub type __uint_fast64_t = __uint64_t;
pub type __uint_least8_t = __uint8_t;
pub type __uint_least16_t = __uint16_t;
pub type __uint_least32_t = __uint32_t;
pub type __uint_least64_t = __uint64_t;
pub type __u_register_t = __uint64_t;
pub type __vm_offset_t = __uint64_t;
pub type __vm_paddr_t = __uint64_t;
pub type __vm_size_t = __uint64_t;
pub type ___wchar_t = ::kernel::sys::raw::c_int;
pub type __blksize_t = __int32_t;
pub type __blkcnt_t = __int64_t;
pub type __clockid_t = __int32_t;
pub type __fflags_t = __uint32_t;
pub type __fsblkcnt_t = __uint64_t;
pub type __fsfilcnt_t = __uint64_t;
pub type __gid_t = __uint32_t;
pub type __id_t = __int64_t;
pub type __ino_t = __uint64_t;
pub type __key_t = ::kernel::sys::raw::c_long;
pub type __lwpid_t = __int32_t;
pub type __mode_t = __uint16_t;
pub type __accmode_t = ::kernel::sys::raw::c_int;
pub type __nl_item = ::kernel::sys::raw::c_int;
pub type __nlink_t = __uint64_t;
pub type __off_t = __int64_t;
pub type __off64_t = __int64_t;
pub type __pid_t = __int32_t;
pub type __rlim_t = __int64_t;
pub type __sa_family_t = __uint8_t;
pub type __socklen_t = __uint32_t;
pub type __suseconds_t = ::kernel::sys::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __timer {
    _unused: [u8; 0],
}
pub type __timer_t = *mut __timer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __mq {
    _unused: [u8; 0],
}
pub type __mqd_t = *mut __mq;
pub type __uid_t = __uint32_t;
pub type __useconds_t = ::kernel::sys::raw::c_uint;
pub type __cpuwhich_t = ::kernel::sys::raw::c_int;
pub type __cpulevel_t = ::kernel::sys::raw::c_int;
pub type __cpusetid_t = ::kernel::sys::raw::c_int;
pub type __ct_rune_t = ::kernel::sys::raw::c_int;
pub type __rune_t = __ct_rune_t;
pub type __wint_t = __ct_rune_t;
pub type __char16_t = __uint_least16_t;
pub type __char32_t = __uint_least32_t;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct __max_align_t {
    pub __max_align1: ::kernel::sys::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __max_align2: f64,
}
#[test]
fn bindgen_test_layout___max_align_t() {
    assert_eq!(::core::mem::size_of::<__max_align_t>() , 32usize , concat ! (
               "Size of: " , stringify ! ( __max_align_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __max_align_t ) ) . __max_align1 as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __max_align_t ) , "::"
                , stringify ! ( __max_align1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __max_align_t ) ) . __max_align2 as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __max_align_t ) , "::"
                , stringify ! ( __max_align2 ) ));
}
impl Clone for __max_align_t {
    fn clone(&self) -> Self { *self }
}
pub type __dev_t = __uint64_t;
pub type __fixpt_t = __uint32_t;
#[repr(C)]
#[derive(Copy)]
pub union __mbstate_t {
    pub __mbstate8: [::kernel::sys::raw::c_char; 128usize],
    pub _mbstateL: __int64_t,
    _bindgen_union_align: [u64; 16usize],
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(::core::mem::size_of::<__mbstate_t>() , 128usize , concat ! (
               "Size of: " , stringify ! ( __mbstate_t ) ));
    assert_eq! (::core::mem::align_of::<__mbstate_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __mbstate_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . __mbstate8 as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( __mbstate8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . _mbstateL as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( _mbstateL ) ));
}
impl Clone for __mbstate_t {
    fn clone(&self) -> Self { *self }
}
impl Default for __mbstate_t {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for __mbstate_t {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "__mbstate_t {{ union }}")
    }
}
pub type __rman_res_t = __uintmax_t;
pub type __va_list = __builtin_va_list;
pub type __gnuc_va_list = __va_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_cond {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_cond_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutex {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutex_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_once {
    pub state: ::kernel::sys::raw::c_int,
    pub mutex: pthread_mutex_t,
}
#[test]
fn bindgen_test_layout_pthread_once() {
    assert_eq!(::core::mem::size_of::<pthread_once>() , 16usize , concat ! (
               "Size of: " , stringify ! ( pthread_once ) ));
    assert_eq! (::core::mem::align_of::<pthread_once>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_once ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_once ) ) . state as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_once ) , "::" ,
                stringify ! ( state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_once ) ) . mutex as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_once ) , "::" ,
                stringify ! ( mutex ) ));
}
impl Clone for pthread_once {
    fn clone(&self) -> Self { *self }
}
impl Default for pthread_once {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_rwlock {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_rwlockattr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_barrier {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_barrier_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_spinlock {
    _unused: [u8; 0],
}
pub type pthread_t = *mut pthread;
pub type pthread_attr_t = *mut pthread_attr;
pub type pthread_mutex_t = *mut pthread_mutex;
pub type pthread_mutexattr_t = *mut pthread_mutex_attr;
pub type pthread_cond_t = *mut pthread_cond;
pub type pthread_condattr_t = *mut pthread_cond_attr;
pub type pthread_key_t = ::kernel::sys::raw::c_int;
pub type pthread_once_t = pthread_once;
pub type pthread_rwlock_t = *mut pthread_rwlock;
pub type pthread_rwlockattr_t = *mut pthread_rwlockattr;
pub type pthread_barrier_t = *mut pthread_barrier;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_barrierattr {
    _unused: [u8; 0],
}
pub type pthread_barrierattr_t = *mut pthread_barrierattr;
pub type pthread_spinlock_t = *mut pthread_spinlock;
pub type pthread_addr_t = *mut ::kernel::sys::raw::c_void;
pub type pthread_startroutine_t =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void)
                               -> *mut ::kernel::sys::raw::c_void>;
pub type u_char = ::kernel::sys::raw::c_uchar;
pub type u_short = ::kernel::sys::raw::c_ushort;
pub type u_int = ::kernel::sys::raw::c_uint;
pub type u_long = ::kernel::sys::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type u_quad_t = __uint64_t;
pub type quad_t = __int64_t;
pub type qaddr_t = *mut quad_t;
pub type caddr_t = *mut ::kernel::sys::raw::c_char;
pub type c_caddr_t = *const ::kernel::sys::raw::c_char;
pub type blksize_t = __blksize_t;
pub type cpuwhich_t = __cpuwhich_t;
pub type cpulevel_t = __cpulevel_t;
pub type cpusetid_t = __cpusetid_t;
pub type blkcnt_t = __blkcnt_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type critical_t = __critical_t;
pub type daddr_t = __int64_t;
pub type dev_t = __dev_t;
pub type fflags_t = __fflags_t;
pub type fixpt_t = __fixpt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type gid_t = __gid_t;
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type id_t = __id_t;
pub type ino_t = __ino_t;
pub type key_t = __key_t;
pub type lwpid_t = __lwpid_t;
pub type mode_t = __mode_t;
pub type accmode_t = __accmode_t;
pub type nlink_t = __nlink_t;
pub type off_t = __off_t;
pub type off64_t = __off64_t;
pub type pid_t = __pid_t;
pub type register_t = __register_t;
pub type rlim_t = __rlim_t;
pub type sbintime_t = __int64_t;
pub type segsz_t = __segsz_t;
pub type suseconds_t = __suseconds_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type mqd_t = __mqd_t;
pub type u_register_t = __u_register_t;
pub type uid_t = __uid_t;
pub type useconds_t = __useconds_t;
pub type cap_ioctl_t = ::kernel::sys::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cap_rights {
    _unused: [u8; 0],
}
pub type cap_rights_t = cap_rights;
pub type kvaddr_t = __uint64_t;
pub type ksize_t = __uint64_t;
pub type vm_offset_t = __vm_offset_t;
pub type vm_ooffset_t = __int64_t;
pub type vm_paddr_t = __vm_paddr_t;
pub type vm_pindex_t = __uint64_t;
pub type vm_size_t = __vm_size_t;
pub type rman_res_t = __rman_res_t;
pub type boolean_t = ::kernel::sys::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct device {
    _unused: [u8; 0],
}
pub type device_t = *mut device;
pub type intfptr_t = __intfptr_t;
pub type intrmask_t = __uint32_t;
pub type uintfptr_t = __uintfptr_t;
pub type uoff_t = __uint64_t;
pub type vm_memattr_t = ::kernel::sys::raw::c_char;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_page {
    _unused: [u8; 0],
}
pub type vm_page_t = *mut vm_page;
pub type bool_ = bool;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct __sigset {
    pub __bits: [__uint32_t; 4usize],
}
#[test]
fn bindgen_test_layout___sigset() {
    assert_eq!(::core::mem::size_of::<__sigset>() , 16usize , concat ! (
               "Size of: " , stringify ! ( __sigset ) ));
    assert_eq! (::core::mem::align_of::<__sigset>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( __sigset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sigset ) ) . __bits as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sigset ) , "::" ,
                stringify ! ( __bits ) ));
}
impl Clone for __sigset {
    fn clone(&self) -> Self { *self }
}
pub type __sigset_t = __sigset;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct timeval {
    pub tv_sec: time_t,
    pub tv_usec: suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(::core::mem::size_of::<timeval>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timeval ) ));
    assert_eq! (::core::mem::align_of::<timeval>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timeval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_usec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_usec ) ));
}
impl Clone for timeval {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: ::kernel::sys::raw::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(::core::mem::size_of::<timespec>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timespec ) ));
    assert_eq! (::core::mem::align_of::<timespec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timespec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_nsec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_nsec ) ));
}
impl Clone for timespec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(::core::mem::size_of::<itimerspec>() , 32usize , concat ! (
               "Size of: " , stringify ! ( itimerspec ) ));
    assert_eq! (::core::mem::align_of::<itimerspec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( itimerspec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerspec ) ) . it_interval as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerspec ) , "::" ,
                stringify ! ( it_interval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerspec ) ) . it_value as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerspec ) , "::" ,
                stringify ! ( it_value ) ));
}
impl Clone for itimerspec {
    fn clone(&self) -> Self { *self }
}
pub type __fd_mask = ::kernel::sys::raw::c_ulong;
pub type fd_mask = __fd_mask;
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(::core::mem::size_of::<fd_set>() , 128usize , concat ! (
               "Size of: " , stringify ! ( fd_set ) ));
    assert_eq! (::core::mem::align_of::<fd_set>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( fd_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fd_set ) ) . __fds_bits as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( fd_set ) , "::" ,
                stringify ! ( __fds_bits ) ));
}
impl Clone for fd_set {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __hack {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct region_descriptor {
    _unused: [u8; 0],
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy)]
pub struct invpcid_descr {
    pub _bitfield_1: u64,
    pub addr: u64,
}
#[test]
fn bindgen_test_layout_invpcid_descr() {
    assert_eq!(::core::mem::size_of::<invpcid_descr>() , 16usize , concat ! (
               "Size of: " , stringify ! ( invpcid_descr ) ));
    assert_eq! (::core::mem::align_of::<invpcid_descr>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( invpcid_descr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const invpcid_descr ) ) . addr as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( invpcid_descr ) , "::"
                , stringify ! ( addr ) ));
}
impl Clone for invpcid_descr {
    fn clone(&self) -> Self { *self }
}
impl invpcid_descr {
    #[inline]
    pub fn pcid(&self) -> u64 {
        let mut unit_field_val: u64 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u64
                                                 as *mut u8,
                                             ::core::mem::size_of::<u64>())
        };
        let mask = 4095u64 as u64;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::core::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_pcid(&mut self, val: u64) {
        let mask = 4095u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u64
                                                 as *mut u8,
                                             ::core::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn pad(&self) -> u64 {
        let mut unit_field_val: u64 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u64
                                                 as *mut u8,
                                             ::core::mem::size_of::<u64>())
        };
        let mask = 18446744073709547520u64 as u64;
        let val = (unit_field_val & mask) >> 12usize;
        unsafe { ::core::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_pad(&mut self, val: u64) {
        let mask = 18446744073709547520u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u64
                                                 as *mut u8,
                                             ::core::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 12usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(pcid: u64, pad: u64) -> u64 {
        ({ ({ 0 } | ((pcid as u64 as u64) << 0usize) & (4095u64 as u64)) } |
             ((pad as u64 as u64) << 12usize) &
                 (18446744073709547520u64 as u64))
    }
}
pub const SGX_ECREATE: _bindgen_ty_1 = _bindgen_ty_1::SGX_ECREATE;
pub const SGX_EADD: _bindgen_ty_1 = _bindgen_ty_1::SGX_EADD;
pub const SGX_EINIT: _bindgen_ty_1 = _bindgen_ty_1::SGX_EINIT;
pub const SGX_EREMOVE: _bindgen_ty_1 = _bindgen_ty_1::SGX_EREMOVE;
pub const SGX_EDGBRD: _bindgen_ty_1 = _bindgen_ty_1::SGX_EDGBRD;
pub const SGX_EDGBWR: _bindgen_ty_1 = _bindgen_ty_1::SGX_EDGBWR;
pub const SGX_EEXTEND: _bindgen_ty_1 = _bindgen_ty_1::SGX_EEXTEND;
pub const SGX_ELDU: _bindgen_ty_1 = _bindgen_ty_1::SGX_ELDU;
pub const SGX_EBLOCK: _bindgen_ty_1 = _bindgen_ty_1::SGX_EBLOCK;
pub const SGX_EPA: _bindgen_ty_1 = _bindgen_ty_1::SGX_EPA;
pub const SGX_EWB: _bindgen_ty_1 = _bindgen_ty_1::SGX_EWB;
pub const SGX_ETRACK: _bindgen_ty_1 = _bindgen_ty_1::SGX_ETRACK;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_1 {
    SGX_ECREATE = 0,
    SGX_EADD = 1,
    SGX_EINIT = 2,
    SGX_EREMOVE = 3,
    SGX_EDGBRD = 4,
    SGX_EDGBWR = 5,
    SGX_EEXTEND = 6,
    SGX_ELDU = 8,
    SGX_EBLOCK = 9,
    SGX_EPA = 10,
    SGX_EWB = 11,
    SGX_ETRACK = 12,
}
pub const SGX_PT_SECS: _bindgen_ty_2 = _bindgen_ty_2::SGX_PT_SECS;
pub const SGX_PT_TCS: _bindgen_ty_2 = _bindgen_ty_2::SGX_PT_TCS;
pub const SGX_PT_REG: _bindgen_ty_2 = _bindgen_ty_2::SGX_PT_REG;
pub const SGX_PT_VA: _bindgen_ty_2 = _bindgen_ty_2::SGX_PT_VA;
pub const SGX_PT_TRIM: _bindgen_ty_2 = _bindgen_ty_2::SGX_PT_TRIM;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_2 {
    SGX_PT_SECS = 0,
    SGX_PT_TCS = 1,
    SGX_PT_REG = 2,
    SGX_PT_VA = 3,
    SGX_PT_TRIM = 4,
}
extern "C" {
    pub fn sgx_encls(eax: u32, rbx: u64, rcx: u64, rdx: u64)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn reset_dbregs();
}
extern "C" {
    pub fn rdmsr_safe(msr: u_int, val: *mut u64) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn wrmsr_safe(msr: u_int, newval: u64) -> ::kernel::sys::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lock_object {
    pub lo_name: *const ::kernel::sys::raw::c_char,
    pub lo_flags: u_int,
    pub lo_data: u_int,
    pub lo_witness: *mut witness,
}
#[test]
fn bindgen_test_layout_lock_object() {
    assert_eq!(::core::mem::size_of::<lock_object>() , 24usize , concat ! (
               "Size of: " , stringify ! ( lock_object ) ));
    assert_eq! (::core::mem::align_of::<lock_object>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lock_object ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_object ) ) . lo_name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_object ) , "::" ,
                stringify ! ( lo_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_object ) ) . lo_flags as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_object ) , "::" ,
                stringify ! ( lo_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_object ) ) . lo_data as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_object ) , "::" ,
                stringify ! ( lo_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_object ) ) . lo_witness as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_object ) , "::" ,
                stringify ! ( lo_witness ) ));
}
impl Clone for lock_object {
    fn clone(&self) -> Self { *self }
}
impl Default for lock_object {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct callout_list {
    pub lh_first: *mut callout,
}
#[test]
fn bindgen_test_layout_callout_list() {
    assert_eq!(::core::mem::size_of::<callout_list>() , 8usize , concat ! (
               "Size of: " , stringify ! ( callout_list ) ));
    assert_eq! (::core::mem::align_of::<callout_list>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( callout_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout_list ) ) . lh_first as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( callout_list ) , "::" ,
                stringify ! ( lh_first ) ));
}
impl Clone for callout_list {
    fn clone(&self) -> Self { *self }
}
impl Default for callout_list {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct callout_slist {
    pub slh_first: *mut callout,
}
#[test]
fn bindgen_test_layout_callout_slist() {
    assert_eq!(::core::mem::size_of::<callout_slist>() , 8usize , concat ! (
               "Size of: " , stringify ! ( callout_slist ) ));
    assert_eq! (::core::mem::align_of::<callout_slist>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( callout_slist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout_slist ) ) . slh_first as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( callout_slist ) , "::"
                , stringify ! ( slh_first ) ));
}
impl Clone for callout_slist {
    fn clone(&self) -> Self { *self }
}
impl Default for callout_slist {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct callout_tailq {
    pub tqh_first: *mut callout,
    pub tqh_last: *mut *mut callout,
}
#[test]
fn bindgen_test_layout_callout_tailq() {
    assert_eq!(::core::mem::size_of::<callout_tailq>() , 16usize , concat ! (
               "Size of: " , stringify ! ( callout_tailq ) ));
    assert_eq! (::core::mem::align_of::<callout_tailq>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( callout_tailq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout_tailq ) ) . tqh_first as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( callout_tailq ) , "::"
                , stringify ! ( tqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout_tailq ) ) . tqh_last as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( callout_tailq ) , "::"
                , stringify ! ( tqh_last ) ));
}
impl Clone for callout_tailq {
    fn clone(&self) -> Self { *self }
}
impl Default for callout_tailq {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct callout {
    pub c_links: callout__bindgen_ty_1,
    pub c_time: sbintime_t,
    pub c_precision: sbintime_t,
    pub c_arg: *mut ::kernel::sys::raw::c_void,
    pub c_func: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                *mut ::kernel::sys::raw::c_void)>,
    pub c_lock: *mut lock_object,
    pub c_flags: ::kernel::sys::raw::c_short,
    pub c_iflags: ::kernel::sys::raw::c_short,
    pub c_cpu: ::kernel::sys::raw::c_int,
}
#[repr(C)]
#[derive(Copy)]
pub union callout__bindgen_ty_1 {
    pub le: callout__bindgen_ty_1__bindgen_ty_1,
    pub sle: callout__bindgen_ty_1__bindgen_ty_2,
    pub tqe: callout__bindgen_ty_1__bindgen_ty_3,
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct callout__bindgen_ty_1__bindgen_ty_1 {
    pub le_next: *mut callout,
    pub le_prev: *mut *mut callout,
}
#[test]
fn bindgen_test_layout_callout__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<callout__bindgen_ty_1__bindgen_ty_1>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( callout__bindgen_ty_1__bindgen_ty_1
               ) ));
    assert_eq! (::core::mem::align_of::<callout__bindgen_ty_1__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                callout__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout__bindgen_ty_1__bindgen_ty_1 ) ) .
                le_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                callout__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! (
                le_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout__bindgen_ty_1__bindgen_ty_1 ) ) .
                le_prev as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                callout__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! (
                le_prev ) ));
}
impl Clone for callout__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for callout__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct callout__bindgen_ty_1__bindgen_ty_2 {
    pub sle_next: *mut callout,
}
#[test]
fn bindgen_test_layout_callout__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<callout__bindgen_ty_1__bindgen_ty_2>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( callout__bindgen_ty_1__bindgen_ty_2
               ) ));
    assert_eq! (::core::mem::align_of::<callout__bindgen_ty_1__bindgen_ty_2>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                callout__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout__bindgen_ty_1__bindgen_ty_2 ) ) .
                sle_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                callout__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify ! (
                sle_next ) ));
}
impl Clone for callout__bindgen_ty_1__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for callout__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct callout__bindgen_ty_1__bindgen_ty_3 {
    pub tqe_next: *mut callout,
    pub tqe_prev: *mut *mut callout,
}
#[test]
fn bindgen_test_layout_callout__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(::core::mem::size_of::<callout__bindgen_ty_1__bindgen_ty_3>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( callout__bindgen_ty_1__bindgen_ty_3
               ) ));
    assert_eq! (::core::mem::align_of::<callout__bindgen_ty_1__bindgen_ty_3>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                callout__bindgen_ty_1__bindgen_ty_3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout__bindgen_ty_1__bindgen_ty_3 ) ) .
                tqe_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                callout__bindgen_ty_1__bindgen_ty_3 ) , "::" , stringify ! (
                tqe_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout__bindgen_ty_1__bindgen_ty_3 ) ) .
                tqe_prev as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                callout__bindgen_ty_1__bindgen_ty_3 ) , "::" , stringify ! (
                tqe_prev ) ));
}
impl Clone for callout__bindgen_ty_1__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
impl Default for callout__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_callout__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<callout__bindgen_ty_1>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( callout__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<callout__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( callout__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout__bindgen_ty_1 ) ) . le as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( callout__bindgen_ty_1 )
                , "::" , stringify ! ( le ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout__bindgen_ty_1 ) ) . sle as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( callout__bindgen_ty_1 )
                , "::" , stringify ! ( sle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout__bindgen_ty_1 ) ) . tqe as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( callout__bindgen_ty_1 )
                , "::" , stringify ! ( tqe ) ));
}
impl Clone for callout__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for callout__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for callout__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "callout__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_callout() {
    assert_eq!(::core::mem::size_of::<callout>() , 64usize , concat ! (
               "Size of: " , stringify ! ( callout ) ));
    assert_eq! (::core::mem::align_of::<callout>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( callout ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout ) ) . c_links as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( callout ) , "::" ,
                stringify ! ( c_links ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout ) ) . c_time as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( callout ) , "::" ,
                stringify ! ( c_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout ) ) . c_precision as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( callout ) , "::" ,
                stringify ! ( c_precision ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout ) ) . c_arg as * const _ as usize
                } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( callout ) , "::" ,
                stringify ! ( c_arg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout ) ) . c_func as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( callout ) , "::" ,
                stringify ! ( c_func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout ) ) . c_lock as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( callout ) , "::" ,
                stringify ! ( c_lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout ) ) . c_flags as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( callout ) , "::" ,
                stringify ! ( c_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout ) ) . c_iflags as * const _ as
                usize } , 58usize , concat ! (
                "Alignment of field: " , stringify ! ( callout ) , "::" ,
                stringify ! ( c_iflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout ) ) . c_cpu as * const _ as usize
                } , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( callout ) , "::" ,
                stringify ! ( c_cpu ) ));
}
impl Clone for callout {
    fn clone(&self) -> Self { *self }
}
impl Default for callout {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for callout {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "callout {{ c_links: {:?}, c_time: {:?}, c_precision: {:?}, c_arg: {:?}, c_func: {:?}, c_lock: {:?}, c_flags: {:?}, c_iflags: {:?}, c_cpu: {:?} }}"
               , self . c_links , self . c_time , self . c_precision , self .
               c_arg , self . c_func , self . c_lock , self . c_flags , self .
               c_iflags , self . c_cpu)
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct callout_handle {
    pub callout: *mut callout,
}
#[test]
fn bindgen_test_layout_callout_handle() {
    assert_eq!(::core::mem::size_of::<callout_handle>() , 8usize , concat ! (
               "Size of: " , stringify ! ( callout_handle ) ));
    assert_eq! (::core::mem::align_of::<callout_handle>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( callout_handle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout_handle ) ) . callout as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( callout_handle ) , "::"
                , stringify ! ( callout ) ));
}
impl Clone for callout_handle {
    fn clone(&self) -> Self { *self }
}
impl Default for callout_handle {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    pub fn callout_init(arg1: *mut callout, arg2: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn _callout_init_lock(arg1: *mut callout, arg2: *mut lock_object,
                              arg3: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn callout_reset_sbt_on(arg1: *mut callout, arg2: sbintime_t,
                                arg3: sbintime_t,
                                arg4:
                                    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                                    *mut ::kernel::sys::raw::c_void)>,
                                arg5: *mut ::kernel::sys::raw::c_void,
                                arg6: ::kernel::sys::raw::c_int,
                                arg7: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn callout_schedule(arg1: *mut callout,
                            arg2: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn callout_schedule_on(arg1: *mut callout,
                               arg2: ::kernel::sys::raw::c_int,
                               arg3: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn _callout_stop_safe(arg1: *mut callout,
                              arg2: ::kernel::sys::raw::c_int,
                              arg3:
                                  ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                                  *mut ::kernel::sys::raw::c_void)>)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn callout_process(now: sbintime_t);
}
extern "C" {
    pub fn callout_when(sbt: sbintime_t, precision: sbintime_t,
                        flags: ::kernel::sys::raw::c_int,
                        sbt_res: *mut sbintime_t, prec_res: *mut sbintime_t);
}
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = __int_fast8_t;
pub type int_fast16_t = __int_fast16_t;
pub type int_fast32_t = __int_fast32_t;
pub type int_fast64_t = __int_fast64_t;
pub type uint_fast8_t = __uint_fast8_t;
pub type uint_fast16_t = __uint_fast16_t;
pub type uint_fast32_t = __uint_fast32_t;
pub type uint_fast64_t = __uint_fast64_t;
extern "C" {
    #[link_name = "cold"]
    pub static mut cold: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "suspend_blocked"]
    pub static mut suspend_blocked: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "rebooting"]
    pub static mut rebooting: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "panicstr"]
    pub static mut panicstr: *const ::kernel::sys::raw::c_char;
}
extern "C" {
    #[link_name = "version"]
    pub static mut version: [::kernel::sys::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "compiler_version"]
    pub static mut compiler_version: [::kernel::sys::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "copyright"]
    pub static mut copyright: [::kernel::sys::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "kstack_pages"]
    pub static mut kstack_pages: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "pagesizes"]
    pub static mut pagesizes: [u_long; 0usize];
}
extern "C" {
    #[link_name = "physmem"]
    pub static mut physmem: ::kernel::sys::raw::c_long;
}
extern "C" {
    #[link_name = "realmem"]
    pub static mut realmem: ::kernel::sys::raw::c_long;
}
extern "C" {
    #[link_name = "rootdevnames"]
    pub static mut rootdevnames: [*mut ::kernel::sys::raw::c_char; 2usize];
}
extern "C" {
    #[link_name = "boothowto"]
    pub static mut boothowto: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "bootverbose"]
    pub static mut bootverbose: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "maxusers"]
    pub static mut maxusers: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "ngroups_max"]
    pub static mut ngroups_max: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "vm_guest"]
    pub static mut vm_guest: ::kernel::sys::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VM_GUEST {
    VM_GUEST_NO = 0,
    VM_GUEST_VM = 1,
    VM_GUEST_XEN = 2,
    VM_GUEST_HV = 3,
    VM_GUEST_VMWARE = 4,
    VM_GUEST_KVM = 5,
    VM_GUEST_BHYVE = 6,
    VM_LAST = 7,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct timezone {
    pub tz_minuteswest: ::kernel::sys::raw::c_int,
    pub tz_dsttime: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_timezone() {
    assert_eq!(::core::mem::size_of::<timezone>() , 8usize , concat ! (
               "Size of: " , stringify ! ( timezone ) ));
    assert_eq! (::core::mem::align_of::<timezone>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( timezone ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timezone ) ) . tz_minuteswest as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timezone ) , "::" ,
                stringify ! ( tz_minuteswest ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timezone ) ) . tz_dsttime as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( timezone ) , "::" ,
                stringify ! ( tz_dsttime ) ));
}
impl Clone for timezone {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct bintime {
    pub sec: time_t,
    pub frac: u64,
}
#[test]
fn bindgen_test_layout_bintime() {
    assert_eq!(::core::mem::size_of::<bintime>() , 16usize , concat ! (
               "Size of: " , stringify ! ( bintime ) ));
    assert_eq! (::core::mem::align_of::<bintime>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( bintime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bintime ) ) . sec as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( bintime ) , "::" ,
                stringify ! ( sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bintime ) ) . frac as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( bintime ) , "::" ,
                stringify ! ( frac ) ));
}
impl Clone for bintime {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
#[test]
fn bindgen_test_layout_itimerval() {
    assert_eq!(::core::mem::size_of::<itimerval>() , 32usize , concat ! (
               "Size of: " , stringify ! ( itimerval ) ));
    assert_eq! (::core::mem::align_of::<itimerval>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( itimerval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerval ) ) . it_interval as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerval ) , "::" ,
                stringify ! ( it_interval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerval ) ) . it_value as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerval ) , "::" ,
                stringify ! ( it_value ) ));
}
impl Clone for itimerval {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct clockinfo {
    pub hz: ::kernel::sys::raw::c_int,
    pub tick: ::kernel::sys::raw::c_int,
    pub spare: ::kernel::sys::raw::c_int,
    pub stathz: ::kernel::sys::raw::c_int,
    pub profhz: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_clockinfo() {
    assert_eq!(::core::mem::size_of::<clockinfo>() , 20usize , concat ! (
               "Size of: " , stringify ! ( clockinfo ) ));
    assert_eq! (::core::mem::align_of::<clockinfo>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( clockinfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clockinfo ) ) . hz as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( clockinfo ) , "::" ,
                stringify ! ( hz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clockinfo ) ) . tick as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( clockinfo ) , "::" ,
                stringify ! ( tick ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clockinfo ) ) . spare as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( clockinfo ) , "::" ,
                stringify ! ( spare ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clockinfo ) ) . stathz as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( clockinfo ) , "::" ,
                stringify ! ( stathz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clockinfo ) ) . profhz as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( clockinfo ) , "::" ,
                stringify ! ( profhz ) ));
}
impl Clone for clockinfo {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn inittodr(base: time_t);
}
extern "C" {
    pub fn resettodr();
}
extern "C" {
    #[link_name = "time_second"]
    pub static mut time_second: time_t;
}
extern "C" {
    #[link_name = "time_uptime"]
    pub static mut time_uptime: time_t;
}
extern "C" {
    #[link_name = "tc_tick_bt"]
    pub static mut tc_tick_bt: bintime;
}
extern "C" {
    #[link_name = "tc_tick_sbt"]
    pub static mut tc_tick_sbt: sbintime_t;
}
extern "C" {
    #[link_name = "tick_bt"]
    pub static mut tick_bt: bintime;
}
extern "C" {
    #[link_name = "tick_sbt"]
    pub static mut tick_sbt: sbintime_t;
}
extern "C" {
    #[link_name = "tc_precexp"]
    pub static mut tc_precexp: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "tc_timepercentage"]
    pub static mut tc_timepercentage: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "bt_timethreshold"]
    pub static mut bt_timethreshold: bintime;
}
extern "C" {
    #[link_name = "bt_tickthreshold"]
    pub static mut bt_tickthreshold: bintime;
}
extern "C" {
    #[link_name = "sbt_timethreshold"]
    pub static mut sbt_timethreshold: sbintime_t;
}
extern "C" {
    #[link_name = "sbt_tickthreshold"]
    pub static mut sbt_tickthreshold: sbintime_t;
}
extern "C" {
    #[link_name = "rtc_generation"]
    pub static mut rtc_generation: ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn binuptime(bt: *mut bintime);
}
extern "C" {
    pub fn nanouptime(tsp: *mut timespec);
}
extern "C" {
    pub fn microuptime(tvp: *mut timeval);
}
extern "C" {
    pub fn bintime(bt: *mut bintime);
}
extern "C" {
    pub fn nanotime(tsp: *mut timespec);
}
extern "C" {
    pub fn microtime(tvp: *mut timeval);
}
extern "C" {
    pub fn getbinuptime(bt: *mut bintime);
}
extern "C" {
    pub fn getnanouptime(tsp: *mut timespec);
}
extern "C" {
    pub fn getmicrouptime(tvp: *mut timeval);
}
extern "C" {
    pub fn getbintime(bt: *mut bintime);
}
extern "C" {
    pub fn getnanotime(tsp: *mut timespec);
}
extern "C" {
    pub fn getmicrotime(tvp: *mut timeval);
}
extern "C" {
    pub fn getboottime(boottime: *mut timeval);
}
extern "C" {
    pub fn getboottimebin(boottimebin: *mut bintime);
}
extern "C" {
    pub fn itimerdecr(itp: *mut itimerval, usec: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn itimerfix(tv: *mut timeval) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn ppsratecheck(arg1: *mut timeval,
                        arg2: *mut ::kernel::sys::raw::c_int,
                        arg3: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn ratecheck(arg1: *mut timeval, arg2: *const timeval)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn timevaladd(t1: *mut timeval, t2: *const timeval);
}
extern "C" {
    pub fn timevalsub(t1: *mut timeval, t2: *const timeval);
}
extern "C" {
    pub fn tvtohz(tv: *mut timeval) -> ::kernel::sys::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct priority {
    pub pri_class: u_char,
    pub pri_level: u_char,
    pub pri_native: u_char,
    pub pri_user: u_char,
}
#[test]
fn bindgen_test_layout_priority() {
    assert_eq!(::core::mem::size_of::<priority>() , 4usize , concat ! (
               "Size of: " , stringify ! ( priority ) ));
    assert_eq! (::core::mem::align_of::<priority>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( priority ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const priority ) ) . pri_class as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( priority ) , "::" ,
                stringify ! ( pri_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const priority ) ) . pri_level as * const _ as
                usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( priority ) , "::" ,
                stringify ! ( pri_level ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const priority ) ) . pri_native as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( priority ) , "::" ,
                stringify ! ( pri_native ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const priority ) ) . pri_user as * const _ as
                usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( priority ) , "::" ,
                stringify ! ( pri_user ) ));
}
impl Clone for priority {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn htonl(arg1: __uint32_t) -> __uint32_t;
}
extern "C" {
    pub fn htons(arg1: __uint16_t) -> __uint16_t;
}
extern "C" {
    pub fn ntohl(arg1: __uint32_t) -> __uint32_t;
}
extern "C" {
    pub fn ntohs(arg1: __uint16_t) -> __uint16_t;
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct bitset {
    pub __bits: [::kernel::sys::raw::c_long; 1usize],
}
#[test]
fn bindgen_test_layout_bitset() {
    assert_eq!(::core::mem::size_of::<bitset>() , 8usize , concat ! (
               "Size of: " , stringify ! ( bitset ) ));
    assert_eq! (::core::mem::align_of::<bitset>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( bitset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bitset ) ) . __bits as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( bitset ) , "::" ,
                stringify ! ( __bits ) ));
}
impl Clone for bitset {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct _cpuset {
    pub __bits: [::kernel::sys::raw::c_long; 4usize],
}
#[test]
fn bindgen_test_layout__cpuset() {
    assert_eq!(::core::mem::size_of::<_cpuset>() , 32usize , concat ! (
               "Size of: " , stringify ! ( _cpuset ) ));
    assert_eq! (::core::mem::align_of::<_cpuset>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _cpuset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _cpuset ) ) . __bits as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _cpuset ) , "::" ,
                stringify ! ( __bits ) ));
}
impl Clone for _cpuset {
    fn clone(&self) -> Self { *self }
}
pub type cpuset_t = _cpuset;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mtx {
    pub lock_object: lock_object,
    pub mtx_lock: usize,
}
#[test]
fn bindgen_test_layout_mtx() {
    assert_eq!(::core::mem::size_of::<mtx>() , 32usize , concat ! (
               "Size of: " , stringify ! ( mtx ) ));
    assert_eq! (::core::mem::align_of::<mtx>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( mtx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mtx ) ) . lock_object as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mtx ) , "::" ,
                stringify ! ( lock_object ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mtx ) ) . mtx_lock as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( mtx ) , "::" ,
                stringify ! ( mtx_lock ) ));
}
impl Clone for mtx {
    fn clone(&self) -> Self { *self }
}
impl Default for mtx {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct mtx_padalign {
    pub lock_object: lock_object,
    pub mtx_lock: usize,
    pub __bindgen_padding_0: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_mtx_padalign() {
    assert_eq!(::core::mem::size_of::<mtx_padalign>() , 64usize , concat ! (
               "Size of: " , stringify ! ( mtx_padalign ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mtx_padalign ) ) . lock_object as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mtx_padalign ) , "::" ,
                stringify ! ( lock_object ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mtx_padalign ) ) . mtx_lock as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( mtx_padalign ) , "::" ,
                stringify ! ( mtx_lock ) ));
}
impl Clone for mtx_padalign {
    fn clone(&self) -> Self { *self }
}
impl Default for mtx_padalign {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for mtx_padalign {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "mtx_padalign {{ lock_object: {:?}, mtx_lock: {:?} }}" ,
               self . lock_object , self . mtx_lock)
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sx {
    pub lock_object: lock_object,
    pub sx_lock: usize,
}
#[test]
fn bindgen_test_layout_sx() {
    assert_eq!(::core::mem::size_of::<sx>() , 32usize , concat ! (
               "Size of: " , stringify ! ( sx ) ));
    assert_eq! (::core::mem::align_of::<sx>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sx ) ) . lock_object as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sx ) , "::" , stringify
                ! ( lock_object ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sx ) ) . sx_lock as * const _ as usize }
                , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( sx ) , "::" , stringify
                ! ( sx_lock ) ));
}
impl Clone for sx {
    fn clone(&self) -> Self { *self }
}
impl Default for sx {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rmpriolist {
    pub lh_first: *mut rm_priotracker,
}
#[test]
fn bindgen_test_layout_rmpriolist() {
    assert_eq!(::core::mem::size_of::<rmpriolist>() , 8usize , concat ! (
               "Size of: " , stringify ! ( rmpriolist ) ));
    assert_eq! (::core::mem::align_of::<rmpriolist>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rmpriolist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmpriolist ) ) . lh_first as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rmpriolist ) , "::" ,
                stringify ! ( lh_first ) ));
}
impl Clone for rmpriolist {
    fn clone(&self) -> Self { *self }
}
impl Default for rmpriolist {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rm_queue {
    pub rmq_next: *mut rm_queue,
    pub rmq_prev: *mut rm_queue,
}
#[test]
fn bindgen_test_layout_rm_queue() {
    assert_eq!(::core::mem::size_of::<rm_queue>() , 16usize , concat ! (
               "Size of: " , stringify ! ( rm_queue ) ));
    assert_eq! (::core::mem::align_of::<rm_queue>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rm_queue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rm_queue ) ) . rmq_next as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rm_queue ) , "::" ,
                stringify ! ( rmq_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rm_queue ) ) . rmq_prev as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rm_queue ) , "::" ,
                stringify ! ( rmq_prev ) ));
}
impl Clone for rm_queue {
    fn clone(&self) -> Self { *self }
}
impl Default for rm_queue {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct rmlock {
    pub lock_object: lock_object,
    pub rm_writecpus: cpuset_t,
    pub rm_activeReaders: rmlock__bindgen_ty_1,
    pub _rm_lock: rmlock__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rmlock__bindgen_ty_1 {
    pub lh_first: *mut rm_priotracker,
}
#[test]
fn bindgen_test_layout_rmlock__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<rmlock__bindgen_ty_1>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( rmlock__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<rmlock__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rmlock__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmlock__bindgen_ty_1 ) ) . lh_first as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rmlock__bindgen_ty_1 )
                , "::" , stringify ! ( lh_first ) ));
}
impl Clone for rmlock__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for rmlock__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub union rmlock__bindgen_ty_2 {
    pub _rm_wlock_object: lock_object,
    pub _rm_lock_mtx: mtx,
    pub _rm_lock_sx: sx,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_rmlock__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<rmlock__bindgen_ty_2>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( rmlock__bindgen_ty_2 )
               ));
    assert_eq! (::core::mem::align_of::<rmlock__bindgen_ty_2>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rmlock__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmlock__bindgen_ty_2 ) ) .
                _rm_wlock_object as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rmlock__bindgen_ty_2 )
                , "::" , stringify ! ( _rm_wlock_object ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmlock__bindgen_ty_2 ) ) . _rm_lock_mtx
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rmlock__bindgen_ty_2 )
                , "::" , stringify ! ( _rm_lock_mtx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmlock__bindgen_ty_2 ) ) . _rm_lock_sx as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rmlock__bindgen_ty_2 )
                , "::" , stringify ! ( _rm_lock_sx ) ));
}
impl Clone for rmlock__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for rmlock__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for rmlock__bindgen_ty_2 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "rmlock__bindgen_ty_2 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_rmlock() {
    assert_eq!(::core::mem::size_of::<rmlock>() , 96usize , concat ! (
               "Size of: " , stringify ! ( rmlock ) ));
    assert_eq! (::core::mem::align_of::<rmlock>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rmlock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmlock ) ) . lock_object as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rmlock ) , "::" ,
                stringify ! ( lock_object ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmlock ) ) . rm_writecpus as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rmlock ) , "::" ,
                stringify ! ( rm_writecpus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmlock ) ) . rm_activeReaders as * const
                _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( rmlock ) , "::" ,
                stringify ! ( rm_activeReaders ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmlock ) ) . _rm_lock as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( rmlock ) , "::" ,
                stringify ! ( _rm_lock ) ));
}
impl Clone for rmlock {
    fn clone(&self) -> Self { *self }
}
impl Default for rmlock {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for rmlock {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "rmlock {{ lock_object: {:?}, rm_writecpus: {:?}, rm_activeReaders: {:?}, _rm_lock: {:?} }}"
               , self . lock_object , self . rm_writecpus , self .
               rm_activeReaders , self . _rm_lock)
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rm_priotracker {
    pub rmp_cpuQueue: rm_queue,
    pub rmp_rmlock: *mut rmlock,
    pub rmp_thread: *mut thread,
    pub rmp_flags: ::kernel::sys::raw::c_int,
    pub rmp_qentry: rm_priotracker__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rm_priotracker__bindgen_ty_1 {
    pub le_next: *mut rm_priotracker,
    pub le_prev: *mut *mut rm_priotracker,
}
#[test]
fn bindgen_test_layout_rm_priotracker__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<rm_priotracker__bindgen_ty_1>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( rm_priotracker__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<rm_priotracker__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( rm_priotracker__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rm_priotracker__bindgen_ty_1 ) ) .
                le_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rm_priotracker__bindgen_ty_1 ) , "::" , stringify ! ( le_next
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rm_priotracker__bindgen_ty_1 ) ) .
                le_prev as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                rm_priotracker__bindgen_ty_1 ) , "::" , stringify ! ( le_prev
                ) ));
}
impl Clone for rm_priotracker__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for rm_priotracker__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_rm_priotracker() {
    assert_eq!(::core::mem::size_of::<rm_priotracker>() , 56usize , concat ! (
               "Size of: " , stringify ! ( rm_priotracker ) ));
    assert_eq! (::core::mem::align_of::<rm_priotracker>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( rm_priotracker ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rm_priotracker ) ) . rmp_cpuQueue as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rm_priotracker ) , "::"
                , stringify ! ( rmp_cpuQueue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rm_priotracker ) ) . rmp_rmlock as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rm_priotracker ) , "::"
                , stringify ! ( rmp_rmlock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rm_priotracker ) ) . rmp_thread as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rm_priotracker ) , "::"
                , stringify ! ( rmp_thread ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rm_priotracker ) ) . rmp_flags as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rm_priotracker ) , "::"
                , stringify ! ( rmp_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rm_priotracker ) ) . rmp_qentry as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rm_priotracker ) , "::"
                , stringify ! ( rmp_qentry ) ));
}
impl Clone for rm_priotracker {
    fn clone(&self) -> Self { *self }
}
impl Default for rm_priotracker {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct rusage {
    pub ru_utime: timeval,
    pub ru_stime: timeval,
    pub ru_maxrss: ::kernel::sys::raw::c_long,
    pub ru_ixrss: ::kernel::sys::raw::c_long,
    pub ru_idrss: ::kernel::sys::raw::c_long,
    pub ru_isrss: ::kernel::sys::raw::c_long,
    pub ru_minflt: ::kernel::sys::raw::c_long,
    pub ru_majflt: ::kernel::sys::raw::c_long,
    pub ru_nswap: ::kernel::sys::raw::c_long,
    pub ru_inblock: ::kernel::sys::raw::c_long,
    pub ru_oublock: ::kernel::sys::raw::c_long,
    pub ru_msgsnd: ::kernel::sys::raw::c_long,
    pub ru_msgrcv: ::kernel::sys::raw::c_long,
    pub ru_nsignals: ::kernel::sys::raw::c_long,
    pub ru_nvcsw: ::kernel::sys::raw::c_long,
    pub ru_nivcsw: ::kernel::sys::raw::c_long,
}
#[test]
fn bindgen_test_layout_rusage() {
    assert_eq!(::core::mem::size_of::<rusage>() , 144usize , concat ! (
               "Size of: " , stringify ! ( rusage ) ));
    assert_eq! (::core::mem::align_of::<rusage>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rusage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_utime as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_utime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_stime as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_stime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_maxrss as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_maxrss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_ixrss as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_ixrss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_idrss as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_idrss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_isrss as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_isrss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_minflt as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_minflt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_majflt as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_majflt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_nswap as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_nswap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_inblock as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_inblock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_oublock as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_oublock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_msgsnd as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_msgsnd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_msgrcv as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_msgrcv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_nsignals as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_nsignals ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_nvcsw as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_nvcsw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_nivcsw as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_nivcsw ) ));
}
impl Clone for rusage {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct __wrusage {
    pub wru_self: rusage,
    pub wru_children: rusage,
}
#[test]
fn bindgen_test_layout___wrusage() {
    assert_eq!(::core::mem::size_of::<__wrusage>() , 288usize , concat ! (
               "Size of: " , stringify ! ( __wrusage ) ));
    assert_eq! (::core::mem::align_of::<__wrusage>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __wrusage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __wrusage ) ) . wru_self as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __wrusage ) , "::" ,
                stringify ! ( wru_self ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __wrusage ) ) . wru_children as * const _
                as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( __wrusage ) , "::" ,
                stringify ! ( wru_children ) ));
}
impl Clone for __wrusage {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct rlimit {
    pub rlim_cur: rlim_t,
    pub rlim_max: rlim_t,
}
#[test]
fn bindgen_test_layout_rlimit() {
    assert_eq!(::core::mem::size_of::<rlimit>() , 16usize , concat ! (
               "Size of: " , stringify ! ( rlimit ) ));
    assert_eq! (::core::mem::align_of::<rlimit>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rlimit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rlimit ) ) . rlim_cur as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rlimit ) , "::" ,
                stringify ! ( rlim_cur ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rlimit ) ) . rlim_max as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rlimit ) , "::" ,
                stringify ! ( rlim_max ) ));
}
impl Clone for rlimit {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct orlimit {
    pub rlim_cur: __int32_t,
    pub rlim_max: __int32_t,
}
#[test]
fn bindgen_test_layout_orlimit() {
    assert_eq!(::core::mem::size_of::<orlimit>() , 8usize , concat ! (
               "Size of: " , stringify ! ( orlimit ) ));
    assert_eq! (::core::mem::align_of::<orlimit>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( orlimit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const orlimit ) ) . rlim_cur as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( orlimit ) , "::" ,
                stringify ! ( rlim_cur ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const orlimit ) ) . rlim_max as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( orlimit ) , "::" ,
                stringify ! ( rlim_max ) ));
}
impl Clone for orlimit {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct loadavg {
    pub ldavg: [__fixpt_t; 3usize],
    pub fscale: ::kernel::sys::raw::c_long,
}
#[test]
fn bindgen_test_layout_loadavg() {
    assert_eq!(::core::mem::size_of::<loadavg>() , 24usize , concat ! (
               "Size of: " , stringify ! ( loadavg ) ));
    assert_eq! (::core::mem::align_of::<loadavg>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( loadavg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const loadavg ) ) . ldavg as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( loadavg ) , "::" ,
                stringify ! ( ldavg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const loadavg ) ) . fscale as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( loadavg ) , "::" ,
                stringify ! ( fscale ) ));
}
impl Clone for loadavg {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "averunnable"]
    pub static mut averunnable: loadavg;
}
extern "C" {
    pub fn read_cpu_time(cp_time: *mut ::kernel::sys::raw::c_long);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcb {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "__start_set_pcpu"]
    pub static mut __start_set_pcpu: *mut usize;
}
extern "C" {
    #[link_name = "__stop_set_pcpu"]
    pub static mut __stop_set_pcpu: *mut usize;
}
extern "C" {
    #[link_name = "dpcpu_off"]
    pub static mut dpcpu_off: [usize; 0usize];
}
#[repr(C)]
#[derive(Copy)]
pub struct pcpu {
    pub pc_curthread: *mut thread,
    pub pc_idlethread: *mut thread,
    pub pc_fpcurthread: *mut thread,
    pub pc_deadthread: *mut thread,
    pub pc_curpcb: *mut pcb,
    pub pc_switchtime: u64,
    pub pc_switchticks: ::kernel::sys::raw::c_int,
    pub pc_cpuid: u_int,
    pub pc_allcpu: pcpu__bindgen_ty_1,
    pub pc_spinlocks: *mut lock_list_entry,
    pub pc_cp_time: [::kernel::sys::raw::c_long; 5usize],
    pub pc_device: *mut device,
    pub pc_netisr: *mut ::kernel::sys::raw::c_void,
    pub pc_unused1: ::kernel::sys::raw::c_int,
    pub pc_domain: ::kernel::sys::raw::c_int,
    pub pc_rm_queue: rm_queue,
    pub pc_dynamic: usize,
    pub pc_early_dummy_counter: u64,
    pub __bindgen_padding_0: [u8; 88usize],
    pub pc_monitorbuf: [::kernel::sys::raw::c_char; 128usize],
    pub pc_prvspace: *mut pcpu,
    pub pc_curpmap: *mut pmap,
    pub pc_tssp: *mut amd64tss,
    pub pc_commontssp: *mut amd64tss,
    pub pc_kcr3: u64,
    pub pc_ucr3: u64,
    pub pc_saved_ucr3: u64,
    pub pc_rsp0: register_t,
    pub pc_scratch_rsp: register_t,
    pub pc_scratch_rax: register_t,
    pub pc_apic_id: u_int,
    pub pc_acpi_id: u_int,
    pub pc_fs32p: *mut user_segment_descriptor,
    pub pc_gs32p: *mut user_segment_descriptor,
    pub pc_ldt: *mut system_segment_descriptor,
    pub pc_tss: *mut system_segment_descriptor,
    pub pc_pm_save_cnt: u64,
    pub pc_cmci_mask: u_int,
    pub pc_dbreg: [u64; 16usize],
    pub pc_pti_stack: [u64; 16usize],
    pub pc_pti_rsp0: register_t,
    pub pc_dbreg_cmd: ::kernel::sys::raw::c_int,
    pub pc_vcpu_id: u_int,
    pub pc_pcid_next: u32,
    pub pc_pcid_gen: u32,
    pub pc_smp_tlb_done: u32,
    pub pc_ibpb_set: u32,
    pub __pad: [::kernel::sys::raw::c_char; 3288usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pcpu__bindgen_ty_1 {
    pub stqe_next: *mut pcpu,
}
#[test]
fn bindgen_test_layout_pcpu__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<pcpu__bindgen_ty_1>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( pcpu__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<pcpu__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( pcpu__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu__bindgen_ty_1 ) ) . stqe_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu__bindgen_ty_1 ) ,
                "::" , stringify ! ( stqe_next ) ));
}
impl Clone for pcpu__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for pcpu__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_pcpu() {
    assert_eq!(::core::mem::size_of::<pcpu>() , 4096usize , concat ! (
               "Size of: " , stringify ! ( pcpu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_curthread as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_curthread ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_idlethread as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_idlethread ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_fpcurthread as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_fpcurthread ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_deadthread as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_deadthread ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_curpcb as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_curpcb ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_switchtime as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_switchtime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_switchticks as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_switchticks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_cpuid as * const _ as usize
                } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_cpuid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_allcpu as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_allcpu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_spinlocks as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_spinlocks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_cp_time as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_cp_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_device as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_device ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_netisr as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_netisr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_unused1 as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_unused1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_domain as * const _ as
                usize } , 132usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_domain ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_rm_queue as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_rm_queue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_dynamic as * const _ as
                usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_dynamic ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_early_dummy_counter as *
                const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_early_dummy_counter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_monitorbuf as * const _ as
                usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_monitorbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_prvspace as * const _ as
                usize } , 384usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_prvspace ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_curpmap as * const _ as
                usize } , 392usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_curpmap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_tssp as * const _ as usize
                } , 400usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_tssp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_commontssp as * const _ as
                usize } , 408usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_commontssp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_kcr3 as * const _ as usize
                } , 416usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_kcr3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_ucr3 as * const _ as usize
                } , 424usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_ucr3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_saved_ucr3 as * const _ as
                usize } , 432usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_saved_ucr3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_rsp0 as * const _ as usize
                } , 440usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_rsp0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_scratch_rsp as * const _ as
                usize } , 448usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_scratch_rsp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_scratch_rax as * const _ as
                usize } , 456usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_scratch_rax ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_apic_id as * const _ as
                usize } , 464usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_apic_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_acpi_id as * const _ as
                usize } , 468usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_acpi_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_fs32p as * const _ as usize
                } , 472usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_fs32p ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_gs32p as * const _ as usize
                } , 480usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_gs32p ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_ldt as * const _ as usize }
                , 488usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_ldt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_tss as * const _ as usize }
                , 496usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_tss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_pm_save_cnt as * const _ as
                usize } , 504usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_pm_save_cnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_cmci_mask as * const _ as
                usize } , 512usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_cmci_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_dbreg as * const _ as usize
                } , 520usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_dbreg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_pti_stack as * const _ as
                usize } , 648usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_pti_stack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_pti_rsp0 as * const _ as
                usize } , 776usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_pti_rsp0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_dbreg_cmd as * const _ as
                usize } , 784usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_dbreg_cmd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_vcpu_id as * const _ as
                usize } , 788usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_vcpu_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_pcid_next as * const _ as
                usize } , 792usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_pcid_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_pcid_gen as * const _ as
                usize } , 796usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_pcid_gen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_smp_tlb_done as * const _
                as usize } , 800usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_smp_tlb_done ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_ibpb_set as * const _ as
                usize } , 804usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_ibpb_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . __pad as * const _ as usize }
                , 808usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( __pad ) ));
}
impl Clone for pcpu {
    fn clone(&self) -> Self { *self }
}
impl Default for pcpu {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for pcpu {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "pcpu {{ pc_curthread: {:?}, pc_idlethread: {:?}, pc_fpcurthread: {:?}, pc_deadthread: {:?}, pc_curpcb: {:?}, pc_switchtime: {:?}, pc_switchticks: {:?}, pc_cpuid: {:?}, pc_allcpu: {:?}, pc_spinlocks: {:?}, pc_cp_time: {:?}, pc_device: {:?}, pc_netisr: {:?}, pc_unused1: {:?}, pc_domain: {:?}, pc_rm_queue: {:?}, pc_dynamic: {:?}, pc_early_dummy_counter: {:?}, pc_monitorbuf: [{}], pc_prvspace: {:?}, pc_curpmap: {:?}, pc_tssp: {:?}, pc_commontssp: {:?}, pc_kcr3: {:?}, pc_ucr3: {:?}, pc_saved_ucr3: {:?}, pc_rsp0: {:?}, pc_scratch_rsp: {:?}, pc_scratch_rax: {:?}, pc_apic_id: {:?}, pc_acpi_id: {:?}, pc_fs32p: {:?}, pc_gs32p: {:?}, pc_ldt: {:?}, pc_tss: {:?}, pc_pm_save_cnt: {:?}, pc_cmci_mask: {:?}, pc_dbreg: {:?}, pc_pti_stack: {:?}, pc_pti_rsp0: {:?}, pc_dbreg_cmd: {:?}, pc_vcpu_id: {:?}, pc_pcid_next: {:?}, pc_pcid_gen: {:?}, pc_smp_tlb_done: {:?}, pc_ibpb_set: {:?}, __pad: [{}] }}"
               , self . pc_curthread , self . pc_idlethread , self .
               pc_fpcurthread , self . pc_deadthread , self . pc_curpcb , self
               . pc_switchtime , self . pc_switchticks , self . pc_cpuid ,
               self . pc_allcpu , self . pc_spinlocks , self . pc_cp_time ,
               self . pc_device , self . pc_netisr , self . pc_unused1 , self
               . pc_domain , self . pc_rm_queue , self . pc_dynamic , self .
               pc_early_dummy_counter , self . pc_monitorbuf . iter (  ) .
               enumerate (  ) . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ) , self . pc_prvspace , self . pc_curpmap , self .
               pc_tssp , self . pc_commontssp , self . pc_kcr3 , self .
               pc_ucr3 , self . pc_saved_ucr3 , self . pc_rsp0 , self .
               pc_scratch_rsp , self . pc_scratch_rax , self . pc_apic_id ,
               self . pc_acpi_id , self . pc_fs32p , self . pc_gs32p , self .
               pc_ldt , self . pc_tss , self . pc_pm_save_cnt , self .
               pc_cmci_mask , self . pc_dbreg , self . pc_pti_stack , self .
               pc_pti_rsp0 , self . pc_dbreg_cmd , self . pc_vcpu_id , self .
               pc_pcid_next , self . pc_pcid_gen , self . pc_smp_tlb_done ,
               self . pc_ibpb_set , self . __pad . iter (  ) . enumerate (  )
               . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ))
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cpuhead {
    pub stqh_first: *mut pcpu,
    pub stqh_last: *mut *mut pcpu,
}
#[test]
fn bindgen_test_layout_cpuhead() {
    assert_eq!(::core::mem::size_of::<cpuhead>() , 16usize , concat ! (
               "Size of: " , stringify ! ( cpuhead ) ));
    assert_eq! (::core::mem::align_of::<cpuhead>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( cpuhead ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuhead ) ) . stqh_first as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuhead ) , "::" ,
                stringify ! ( stqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuhead ) ) . stqh_last as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuhead ) , "::" ,
                stringify ! ( stqh_last ) ));
}
impl Clone for cpuhead {
    fn clone(&self) -> Self { *self }
}
impl Default for cpuhead {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    #[link_name = "cpuhead"]
    pub static mut cpuhead: cpuhead;
}
extern "C" {
    #[link_name = "cpuid_to_pcpu"]
    pub static mut cpuid_to_pcpu: [*mut pcpu; 0usize];
}
extern "C" {
    pub fn cpu_pcpu_init(pcpu: *mut pcpu, cpuid: ::kernel::sys::raw::c_int,
                         size: usize);
}
extern "C" {
    pub fn db_show_mdpcpu(pcpu: *mut pcpu);
}
extern "C" {
    pub fn dpcpu_alloc(size: ::kernel::sys::raw::c_int)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn dpcpu_copy(s: *mut ::kernel::sys::raw::c_void,
                      size: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn dpcpu_free(s: *mut ::kernel::sys::raw::c_void,
                      size: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn dpcpu_init(dpcpu: *mut ::kernel::sys::raw::c_void,
                      cpuid: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn pcpu_destroy(pcpu: *mut pcpu);
}
extern "C" {
    pub fn pcpu_find(cpuid: u_int) -> *mut pcpu;
}
extern "C" {
    pub fn pcpu_init(pcpu: *mut pcpu, cpuid: ::kernel::sys::raw::c_int,
                     size: usize);
}
extern "C" {
    #[link_name = "osreldate"]
    pub static mut osreldate: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "dynamic_kenv"]
    pub static mut dynamic_kenv: bool_;
}
extern "C" {
    #[link_name = "kenv_lock"]
    pub static mut kenv_lock: mtx;
}
extern "C" {
    #[link_name = "kern_envp"]
    pub static mut kern_envp: *mut ::kernel::sys::raw::c_char;
}
extern "C" {
    #[link_name = "md_envp"]
    pub static mut md_envp: *mut ::kernel::sys::raw::c_char;
}
extern "C" {
    #[link_name = "static_env"]
    pub static mut static_env: [::kernel::sys::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "static_hints"]
    pub static mut static_hints: [::kernel::sys::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "kenvp"]
    pub static mut kenvp: *mut *mut ::kernel::sys::raw::c_char;
}
extern "C" {
    #[link_name = "zero_region"]
    pub static mut zero_region: *const ::kernel::sys::raw::c_void;
}
extern "C" {
    #[link_name = "unmapped_buf_allowed"]
    pub static mut unmapped_buf_allowed: ::kernel::sys::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct inpcb {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct malloc_type {
    pub ks_next: *mut malloc_type,
    pub ks_magic: u_long,
    pub ks_shortdesc: *const ::kernel::sys::raw::c_char,
    pub ks_handle: *mut ::kernel::sys::raw::c_void,
}
#[test]
fn bindgen_test_layout_malloc_type() {
    assert_eq!(::core::mem::size_of::<malloc_type>() , 32usize , concat ! (
               "Size of: " , stringify ! ( malloc_type ) ));
    assert_eq! (::core::mem::align_of::<malloc_type>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( malloc_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type ) ) . ks_next as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_type ) , "::" ,
                stringify ! ( ks_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type ) ) . ks_magic as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_type ) , "::" ,
                stringify ! ( ks_magic ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type ) ) . ks_shortdesc as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_type ) , "::" ,
                stringify ! ( ks_shortdesc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type ) ) . ks_handle as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_type ) , "::" ,
                stringify ! ( ks_handle ) ));
}
impl Clone for malloc_type {
    fn clone(&self) -> Self { *self }
}
impl Default for malloc_type {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct proc_ {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct socket {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct thread {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tty {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucred {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uio {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _jmp_buf {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct trapframe {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eventtimer {
    _unused: [u8; 0],
}
extern "C" {
    pub fn setjmp(arg1: *mut _jmp_buf) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn longjmp(arg1: *mut _jmp_buf, arg2: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn dumpstatus(addr: vm_offset_t, count: off_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn nullop() -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn eopnotsupp() -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn ureadc(arg1: ::kernel::sys::raw::c_int, arg2: *mut uio)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn hashdestroy(arg1: *mut ::kernel::sys::raw::c_void,
                       arg2: *mut malloc_type, arg3: u_long);
}
extern "C" {
    pub fn hashinit(count: ::kernel::sys::raw::c_int, type_: *mut malloc_type,
                    hashmask: *mut u_long) -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn hashinit_flags(count: ::kernel::sys::raw::c_int,
                          type_: *mut malloc_type, hashmask: *mut u_long,
                          flags: ::kernel::sys::raw::c_int)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn phashinit(count: ::kernel::sys::raw::c_int,
                     type_: *mut malloc_type, nentries: *mut u_long)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn phashinit_flags(count: ::kernel::sys::raw::c_int,
                           type_: *mut malloc_type, nentries: *mut u_long,
                           flags: ::kernel::sys::raw::c_int)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn g_waitidle();
}
extern "C" {
    pub fn panic(arg1: *const ::kernel::sys::raw::c_char, ...);
}
extern "C" {
    pub fn vpanic(arg1: *const ::kernel::sys::raw::c_char,
                  arg2: *mut __va_list_tag);
}
extern "C" {
    pub fn cpu_boot(arg1: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn cpu_flush_dcache(arg1: *mut ::kernel::sys::raw::c_void,
                            arg2: usize);
}
extern "C" {
    pub fn cpu_rootconf();
}
extern "C" {
    pub fn critical_enter_KBI();
}
extern "C" {
    pub fn critical_exit_KBI();
}
extern "C" {
    pub fn critical_exit_preempt();
}
extern "C" {
    pub fn init_param1();
}
extern "C" {
    pub fn init_param2(physpages: ::kernel::sys::raw::c_long);
}
extern "C" {
    pub fn init_static_kenv(arg1: *mut ::kernel::sys::raw::c_char,
                            arg2: usize);
}
extern "C" {
    pub fn tablefull(arg1: *const ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn kvprintf(arg1: *const ::kernel::sys::raw::c_char,
                    arg2:
                        ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                        ::kernel::sys::raw::c_int,
                                                                    arg2:
                                                                        *mut ::kernel::sys::raw::c_void)>,
                    arg3: *mut ::kernel::sys::raw::c_void,
                    arg4: ::kernel::sys::raw::c_int, arg5: *mut __va_list_tag)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn log(arg1: ::kernel::sys::raw::c_int,
               arg2: *const ::kernel::sys::raw::c_char, ...);
}
extern "C" {
    pub fn log_console(arg1: *mut uio);
}
extern "C" {
    pub fn vlog(arg1: ::kernel::sys::raw::c_int,
                arg2: *const ::kernel::sys::raw::c_char,
                arg3: *mut __va_list_tag);
}
extern "C" {
    pub fn asprintf(ret: *mut *mut ::kernel::sys::raw::c_char,
                    mtp: *mut malloc_type,
                    format: *const ::kernel::sys::raw::c_char, ...)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn printf(arg1: *const ::kernel::sys::raw::c_char, ...)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn snprintf(arg1: *mut ::kernel::sys::raw::c_char, arg2: usize,
                    arg3: *const ::kernel::sys::raw::c_char, ...)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sprintf(buf: *mut ::kernel::sys::raw::c_char,
                   arg1: *const ::kernel::sys::raw::c_char, ...)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn uprintf(arg1: *const ::kernel::sys::raw::c_char, ...)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn vprintf(arg1: *const ::kernel::sys::raw::c_char,
                   arg2: *mut __va_list_tag) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn vasprintf(ret: *mut *mut ::kernel::sys::raw::c_char,
                     mtp: *mut malloc_type,
                     format: *const ::kernel::sys::raw::c_char,
                     ap: *mut __va_list_tag) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(arg1: *mut ::kernel::sys::raw::c_char, arg2: usize,
                     arg3: *const ::kernel::sys::raw::c_char,
                     arg4: *mut __va_list_tag) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn vsnrprintf(arg1: *mut ::kernel::sys::raw::c_char, arg2: usize,
                      arg3: ::kernel::sys::raw::c_int,
                      arg4: *const ::kernel::sys::raw::c_char,
                      arg5: *mut __va_list_tag) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn vsprintf(buf: *mut ::kernel::sys::raw::c_char,
                    arg1: *const ::kernel::sys::raw::c_char,
                    arg2: *mut __va_list_tag) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn ttyprintf(arg1: *mut tty,
                     arg2: *const ::kernel::sys::raw::c_char, ...)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sscanf(arg1: *const ::kernel::sys::raw::c_char,
                  arg2: *const ::kernel::sys::raw::c_char, ...)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn vsscanf(arg1: *const ::kernel::sys::raw::c_char,
                   arg2: *const ::kernel::sys::raw::c_char,
                   arg3: *mut __va_list_tag) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn strtol(arg1: *const ::kernel::sys::raw::c_char,
                  arg2: *mut *mut ::kernel::sys::raw::c_char,
                  arg3: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_long;
}
extern "C" {
    pub fn strtoul(arg1: *const ::kernel::sys::raw::c_char,
                   arg2: *mut *mut ::kernel::sys::raw::c_char,
                   arg3: ::kernel::sys::raw::c_int) -> u_long;
}
extern "C" {
    pub fn strtoq(arg1: *const ::kernel::sys::raw::c_char,
                  arg2: *mut *mut ::kernel::sys::raw::c_char,
                  arg3: ::kernel::sys::raw::c_int) -> quad_t;
}
extern "C" {
    pub fn strtouq(arg1: *const ::kernel::sys::raw::c_char,
                   arg2: *mut *mut ::kernel::sys::raw::c_char,
                   arg3: ::kernel::sys::raw::c_int) -> u_quad_t;
}
extern "C" {
    pub fn tprintf(p: *mut proc_, pri: ::kernel::sys::raw::c_int,
                   arg1: *const ::kernel::sys::raw::c_char, ...);
}
extern "C" {
    pub fn vtprintf(arg1: *mut proc_, arg2: ::kernel::sys::raw::c_int,
                    arg3: *const ::kernel::sys::raw::c_char,
                    arg4: *mut __va_list_tag);
}
extern "C" {
    pub fn hexdump(ptr: *const ::kernel::sys::raw::c_void,
                   length: ::kernel::sys::raw::c_int,
                   hdr: *const ::kernel::sys::raw::c_char,
                   flags: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn bcopy(from: *const ::kernel::sys::raw::c_void,
                 to: *mut ::kernel::sys::raw::c_void, len: usize);
}
extern "C" {
    pub fn bzero(buf: *mut ::kernel::sys::raw::c_void, len: usize);
}
extern "C" {
    pub fn explicit_bzero(arg1: *mut ::kernel::sys::raw::c_void, arg2: usize);
}
extern "C" {
    pub fn bcmp(b1: *const ::kernel::sys::raw::c_void,
                b2: *const ::kernel::sys::raw::c_void, len: usize)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn memset(buf: *mut ::kernel::sys::raw::c_void,
                  c: ::kernel::sys::raw::c_int, len: usize)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn memcpy(to: *mut ::kernel::sys::raw::c_void,
                  from: *const ::kernel::sys::raw::c_void, len: usize)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn memmove(dest: *mut ::kernel::sys::raw::c_void,
                   src: *const ::kernel::sys::raw::c_void, n: usize)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn memcmp(b1: *const ::kernel::sys::raw::c_void,
                  b2: *const ::kernel::sys::raw::c_void, len: usize)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn copystr(kfaddr: *const ::kernel::sys::raw::c_void,
                   kdaddr: *mut ::kernel::sys::raw::c_void, len: usize,
                   lencopied: *mut usize) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn copyinstr(udaddr: *const ::kernel::sys::raw::c_void,
                     kaddr: *mut ::kernel::sys::raw::c_void, len: usize,
                     lencopied: *mut usize) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn copyin(udaddr: *const ::kernel::sys::raw::c_void,
                  kaddr: *mut ::kernel::sys::raw::c_void, len: usize)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn copyin_nofault(udaddr: *const ::kernel::sys::raw::c_void,
                          kaddr: *mut ::kernel::sys::raw::c_void, len: usize)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn copyout(kaddr: *const ::kernel::sys::raw::c_void,
                   udaddr: *mut ::kernel::sys::raw::c_void, len: usize)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn copyout_nofault(kaddr: *const ::kernel::sys::raw::c_void,
                           udaddr: *mut ::kernel::sys::raw::c_void,
                           len: usize) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn fubyte(base: *const ::kernel::sys::raw::c_void)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn fuword(base: *const ::kernel::sys::raw::c_void)
     -> ::kernel::sys::raw::c_long;
}
extern "C" {
    pub fn fuword16(base: *const ::kernel::sys::raw::c_void)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn fuword32(base: *const ::kernel::sys::raw::c_void) -> i32;
}
extern "C" {
    pub fn fuword64(base: *const ::kernel::sys::raw::c_void) -> i64;
}
extern "C" {
    pub fn fueword(base: *const ::kernel::sys::raw::c_void,
                   val: *mut ::kernel::sys::raw::c_long)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn fueword32(base: *const ::kernel::sys::raw::c_void, val: *mut i32)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn fueword64(base: *const ::kernel::sys::raw::c_void, val: *mut i64)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn subyte(base: *mut ::kernel::sys::raw::c_void,
                  byte: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn suword(base: *mut ::kernel::sys::raw::c_void,
                  word: ::kernel::sys::raw::c_long)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn suword16(base: *mut ::kernel::sys::raw::c_void,
                    word: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn suword32(base: *mut ::kernel::sys::raw::c_void, word: i32)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn suword64(base: *mut ::kernel::sys::raw::c_void, word: i64)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn casuword32(base: *mut u32, oldval: u32, newval: u32) -> u32;
}
extern "C" {
    pub fn casuword(p: *mut u_long, oldval: u_long, newval: u_long) -> u_long;
}
extern "C" {
    pub fn casueword32(base: *mut u32, oldval: u32, oldvalp: *mut u32,
                       newval: u32) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn casueword(p: *mut u_long, oldval: u_long, oldvalp: *mut u_long,
                     newval: u_long) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn realitexpire(arg1: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn sysbeep(hertz: ::kernel::sys::raw::c_int,
                   period: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn hardclock(usermode: ::kernel::sys::raw::c_int, pc: uintfptr_t);
}
extern "C" {
    pub fn hardclock_cnt(cnt: ::kernel::sys::raw::c_int,
                         usermode: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn hardclock_cpu(usermode: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn hardclock_sync(cpu: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn softclock(arg1: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn statclock(usermode: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn statclock_cnt(cnt: ::kernel::sys::raw::c_int,
                         usermode: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn profclock(usermode: ::kernel::sys::raw::c_int, pc: uintfptr_t);
}
extern "C" {
    pub fn profclock_cnt(cnt: ::kernel::sys::raw::c_int,
                         usermode: ::kernel::sys::raw::c_int, pc: uintfptr_t);
}
extern "C" {
    pub fn hardclockintr() -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn startprofclock(arg1: *mut proc_);
}
extern "C" {
    pub fn stopprofclock(arg1: *mut proc_);
}
extern "C" {
    pub fn cpu_startprofclock();
}
extern "C" {
    pub fn cpu_stopprofclock();
}
extern "C" {
    pub fn suspendclock();
}
extern "C" {
    pub fn resumeclock();
}
extern "C" {
    pub fn cpu_idleclock() -> sbintime_t;
}
extern "C" {
    pub fn cpu_activeclock();
}
extern "C" {
    pub fn cpu_new_callout(cpu: ::kernel::sys::raw::c_int, bt: sbintime_t,
                           bt_opt: sbintime_t);
}
extern "C" {
    pub fn cpu_et_frequency(et: *mut eventtimer, newfreq: u64);
}
extern "C" {
    #[link_name = "cpu_disable_c2_sleep"]
    pub static mut cpu_disable_c2_sleep: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "cpu_disable_c3_sleep"]
    pub static mut cpu_disable_c3_sleep: ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn kern_getenv(name: *const ::kernel::sys::raw::c_char)
     -> *mut ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn freeenv(env: *mut ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn getenv_int(name: *const ::kernel::sys::raw::c_char,
                      data: *mut ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn getenv_uint(name: *const ::kernel::sys::raw::c_char,
                       data: *mut ::kernel::sys::raw::c_uint)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn getenv_long(name: *const ::kernel::sys::raw::c_char,
                       data: *mut ::kernel::sys::raw::c_long)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn getenv_ulong(name: *const ::kernel::sys::raw::c_char,
                        data: *mut ::kernel::sys::raw::c_ulong)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn getenv_string(name: *const ::kernel::sys::raw::c_char,
                         data: *mut ::kernel::sys::raw::c_char,
                         size: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn getenv_int64(name: *const ::kernel::sys::raw::c_char,
                        data: *mut i64) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn getenv_uint64(name: *const ::kernel::sys::raw::c_char,
                         data: *mut u64) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn getenv_quad(name: *const ::kernel::sys::raw::c_char,
                       data: *mut quad_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn kern_setenv(name: *const ::kernel::sys::raw::c_char,
                       value: *const ::kernel::sys::raw::c_char)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn kern_unsetenv(name: *const ::kernel::sys::raw::c_char)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn testenv(name: *const ::kernel::sys::raw::c_char)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn getenv_array(name: *const ::kernel::sys::raw::c_char,
                        data: *mut ::kernel::sys::raw::c_void,
                        size: ::kernel::sys::raw::c_int,
                        psize: *mut ::kernel::sys::raw::c_int,
                        type_size: ::kernel::sys::raw::c_int,
                        allow_signed: bool_) -> ::kernel::sys::raw::c_int;
}
pub type cpu_tick_f = ::core::option::Option<unsafe extern "C" fn() -> u64>;
extern "C" {
    pub fn set_cputicker(func: cpu_tick_f, freq: u64,
                         var: ::kernel::sys::raw::c_uint);
}
extern "C" {
    #[link_name = "cpu_ticks"]
    pub static mut cpu_ticks: cpu_tick_f;
}
extern "C" {
    pub fn cpu_tickrate() -> u64;
}
extern "C" {
    pub fn cputick2usec(tick: u64) -> u64;
}
extern "C" {
    #[link_name = "bcd2bin_data"]
    pub static mut bcd2bin_data: [u_char; 0usize];
}
extern "C" {
    #[link_name = "bin2bcd_data"]
    pub static mut bin2bcd_data: [u_char; 0usize];
}
extern "C" {
    #[link_name = "hex2ascii_data"]
    pub static mut hex2ascii_data: [::kernel::sys::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "arc4rand_iniseed_state"]
    pub static mut arc4rand_iniseed_state: ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn arc4random() -> u32;
}
extern "C" {
    pub fn arc4random_buf(arg1: *mut ::kernel::sys::raw::c_void, arg2: usize);
}
extern "C" {
    pub fn arc4rand(arg1: *mut ::kernel::sys::raw::c_void, arg2: u_int,
                    arg3: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn timingsafe_bcmp(arg1: *const ::kernel::sys::raw::c_void,
                           arg2: *const ::kernel::sys::raw::c_void,
                           arg3: usize) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bsearch(arg1: *const ::kernel::sys::raw::c_void,
                   arg2: *const ::kernel::sys::raw::c_void, arg3: usize,
                   arg4: usize,
                   arg5:
                       ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                       *const ::kernel::sys::raw::c_void,
                                                                   arg2:
                                                                       *const ::kernel::sys::raw::c_void)
                                                  ->
                                                      ::kernel::sys::raw::c_int>)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn fnmatch(arg1: *const ::kernel::sys::raw::c_char,
                   arg2: *const ::kernel::sys::raw::c_char,
                   arg3: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn locc(arg1: ::kernel::sys::raw::c_int,
                arg2: *mut ::kernel::sys::raw::c_char, arg3: u_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn memchr(s: *const ::kernel::sys::raw::c_void,
                  c: ::kernel::sys::raw::c_int, n: usize)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn memcchr(s: *const ::kernel::sys::raw::c_void,
                   c: ::kernel::sys::raw::c_int, n: usize)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn memmem(l: *const ::kernel::sys::raw::c_void, l_len: usize,
                  s: *const ::kernel::sys::raw::c_void, s_len: usize)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn qsort(base: *mut ::kernel::sys::raw::c_void, nmemb: usize,
                 size: usize,
                 compar:
                     ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                     *const ::kernel::sys::raw::c_void,
                                                                 arg2:
                                                                     *const ::kernel::sys::raw::c_void)
                                                ->
                                                    ::kernel::sys::raw::c_int>);
}
extern "C" {
    pub fn qsort_r(base: *mut ::kernel::sys::raw::c_void, nmemb: usize,
                   size: usize, thunk: *mut ::kernel::sys::raw::c_void,
                   compar:
                       ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                       *mut ::kernel::sys::raw::c_void,
                                                                   arg2:
                                                                       *const ::kernel::sys::raw::c_void,
                                                                   arg3:
                                                                       *const ::kernel::sys::raw::c_void)
                                                  ->
                                                      ::kernel::sys::raw::c_int>);
}
extern "C" {
    pub fn random() -> u_long;
}
extern "C" {
    pub fn scanc(arg1: u_int, arg2: *const u_char, arg3: *const u_char,
                 arg4: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn srandom(arg1: u_long);
}
extern "C" {
    pub fn strcasecmp(arg1: *const ::kernel::sys::raw::c_char,
                      arg2: *const ::kernel::sys::raw::c_char)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn strcat(arg1: *mut ::kernel::sys::raw::c_char,
                  arg2: *const ::kernel::sys::raw::c_char)
     -> *mut ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn strchr(arg1: *const ::kernel::sys::raw::c_char,
                  arg2: ::kernel::sys::raw::c_int)
     -> *mut ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn strcmp(arg1: *const ::kernel::sys::raw::c_char,
                  arg2: *const ::kernel::sys::raw::c_char)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn strcpy(arg1: *mut ::kernel::sys::raw::c_char,
                  arg2: *const ::kernel::sys::raw::c_char)
     -> *mut ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn strcspn(arg1: *const ::kernel::sys::raw::c_char,
                   arg2: *const ::kernel::sys::raw::c_char) -> usize;
}
extern "C" {
    pub fn strdup(arg1: *const ::kernel::sys::raw::c_char,
                  arg2: *mut malloc_type) -> *mut ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn strncat(arg1: *mut ::kernel::sys::raw::c_char,
                   arg2: *const ::kernel::sys::raw::c_char, arg3: usize)
     -> *mut ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn strndup(arg1: *const ::kernel::sys::raw::c_char, arg2: usize,
                   arg3: *mut malloc_type) -> *mut ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn strlcat(arg1: *mut ::kernel::sys::raw::c_char,
                   arg2: *const ::kernel::sys::raw::c_char, arg3: usize)
     -> usize;
}
extern "C" {
    pub fn strlcpy(arg1: *mut ::kernel::sys::raw::c_char,
                   arg2: *const ::kernel::sys::raw::c_char, arg3: usize)
     -> usize;
}
extern "C" {
    pub fn strlen(arg1: *const ::kernel::sys::raw::c_char) -> usize;
}
extern "C" {
    pub fn strncasecmp(arg1: *const ::kernel::sys::raw::c_char,
                       arg2: *const ::kernel::sys::raw::c_char, arg3: usize)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn strncmp(arg1: *const ::kernel::sys::raw::c_char,
                   arg2: *const ::kernel::sys::raw::c_char, arg3: usize)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn strncpy(arg1: *mut ::kernel::sys::raw::c_char,
                   arg2: *const ::kernel::sys::raw::c_char, arg3: usize)
     -> *mut ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn strnlen(arg1: *const ::kernel::sys::raw::c_char, arg2: usize)
     -> usize;
}
extern "C" {
    pub fn strrchr(arg1: *const ::kernel::sys::raw::c_char,
                   arg2: ::kernel::sys::raw::c_int)
     -> *mut ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn strsep(arg1: *mut *mut ::kernel::sys::raw::c_char,
                  delim: *const ::kernel::sys::raw::c_char)
     -> *mut ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn strspn(arg1: *const ::kernel::sys::raw::c_char,
                  arg2: *const ::kernel::sys::raw::c_char) -> usize;
}
extern "C" {
    pub fn strstr(arg1: *const ::kernel::sys::raw::c_char,
                  arg2: *const ::kernel::sys::raw::c_char)
     -> *mut ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn strvalid(arg1: *const ::kernel::sys::raw::c_char, arg2: usize)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "crc32_tab"]
    pub static mut crc32_tab: [u32; 0usize];
}
extern "C" {
    pub fn calculate_crc32c(crc32c: u32,
                            buffer: *const ::kernel::sys::raw::c_uchar,
                            length: ::kernel::sys::raw::c_uint) -> u32;
}
extern "C" {
    pub fn sse42_crc32c(arg1: u32, arg2: *const ::kernel::sys::raw::c_uchar,
                        arg3: ::kernel::sys::raw::c_uint) -> u32;
}
extern "C" {
    pub fn consinit();
}
extern "C" {
    pub fn cpu_initclocks();
}
extern "C" {
    pub fn cpu_initclocks_bsp();
}
extern "C" {
    pub fn cpu_initclocks_ap();
}
extern "C" {
    pub fn usrinfoinit();
}
extern "C" {
    pub fn kern_reboot(arg1: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn shutdown_nice(arg1: ::kernel::sys::raw::c_int);
}
pub type timeout_t =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void)>;
extern "C" {
    pub fn callout_handle_init(arg1: *mut callout_handle);
}
extern "C" {
    pub fn timeout(arg1: timeout_t, arg2: *mut ::kernel::sys::raw::c_void,
                   arg3: ::kernel::sys::raw::c_int) -> callout_handle;
}
extern "C" {
    pub fn untimeout(arg1: timeout_t, arg2: *mut ::kernel::sys::raw::c_void,
                     arg3: callout_handle);
}
extern "C" {
    pub fn _sleep(chan: *mut ::kernel::sys::raw::c_void,
                  lock: *mut lock_object, pri: ::kernel::sys::raw::c_int,
                  wmesg: *const ::kernel::sys::raw::c_char, sbt: sbintime_t,
                  pr: sbintime_t, flags: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn msleep_spin_sbt(chan: *mut ::kernel::sys::raw::c_void,
                           mtx: *mut mtx,
                           wmesg: *const ::kernel::sys::raw::c_char,
                           sbt: sbintime_t, pr: sbintime_t,
                           flags: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn pause_sbt(wmesg: *const ::kernel::sys::raw::c_char,
                     sbt: sbintime_t, pr: sbintime_t,
                     flags: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn wakeup(chan: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn wakeup_one(chan: *mut ::kernel::sys::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cdev {
    _unused: [u8; 0],
}
extern "C" {
    pub fn dev2udev(x: *mut cdev) -> dev_t;
}
extern "C" {
    pub fn devtoname(cdev: *mut cdev) -> *const ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn devfs_iosize_max() -> usize;
}
extern "C" {
    pub fn iosize_max() -> usize;
}
extern "C" {
    pub fn poll_no_poll(events: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn DELAY(usec: ::kernel::sys::raw::c_int);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct root_hold_token {
    _unused: [u8; 0],
}
extern "C" {
    pub fn root_mount_hold(identifier: *const ::kernel::sys::raw::c_char)
     -> *mut root_hold_token;
}
extern "C" {
    pub fn root_mount_rel(h: *mut root_hold_token);
}
extern "C" {
    pub fn root_mounted() -> ::kernel::sys::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct unrhdr {
    _unused: [u8; 0],
}
extern "C" {
    pub fn new_unrhdr(low: ::kernel::sys::raw::c_int,
                      high: ::kernel::sys::raw::c_int, mutex: *mut mtx)
     -> *mut unrhdr;
}
extern "C" {
    pub fn init_unrhdr(uh: *mut unrhdr, low: ::kernel::sys::raw::c_int,
                       high: ::kernel::sys::raw::c_int, mutex: *mut mtx);
}
extern "C" {
    pub fn delete_unrhdr(uh: *mut unrhdr);
}
extern "C" {
    pub fn clear_unrhdr(uh: *mut unrhdr);
}
extern "C" {
    pub fn clean_unrhdr(uh: *mut unrhdr);
}
extern "C" {
    pub fn clean_unrhdrl(uh: *mut unrhdr);
}
extern "C" {
    pub fn alloc_unr(uh: *mut unrhdr) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn alloc_unr_specific(uh: *mut unrhdr, item: u_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn alloc_unrl(uh: *mut unrhdr) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn free_unr(uh: *mut unrhdr, item: u_int);
}
extern "C" {
    pub fn intr_prof_stack_use(td: *mut thread, frame: *mut trapframe);
}
extern "C" {
    pub fn counted_warning(counter: *mut ::kernel::sys::raw::c_uint,
                           msg: *const ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn _gone_in(major: ::kernel::sys::raw::c_int,
                    msg: *const ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn _gone_in_dev(dev: *mut device, major: ::kernel::sys::raw::c_int,
                        msg: *const ::kernel::sys::raw::c_char);
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct malloc_type_stats {
    pub mts_memalloced: u64,
    pub mts_memfreed: u64,
    pub mts_numallocs: u64,
    pub mts_numfrees: u64,
    pub mts_size: u64,
    pub _mts_reserved1: u64,
    pub _mts_reserved2: u64,
    pub _mts_reserved3: u64,
}
#[test]
fn bindgen_test_layout_malloc_type_stats() {
    assert_eq!(::core::mem::size_of::<malloc_type_stats>() , 64usize , concat
               ! ( "Size of: " , stringify ! ( malloc_type_stats ) ));
    assert_eq! (::core::mem::align_of::<malloc_type_stats>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( malloc_type_stats ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type_stats ) ) . mts_memalloced as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_type_stats ) ,
                "::" , stringify ! ( mts_memalloced ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type_stats ) ) . mts_memfreed as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_type_stats ) ,
                "::" , stringify ! ( mts_memfreed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type_stats ) ) . mts_numallocs as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_type_stats ) ,
                "::" , stringify ! ( mts_numallocs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type_stats ) ) . mts_numfrees as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_type_stats ) ,
                "::" , stringify ! ( mts_numfrees ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type_stats ) ) . mts_size as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_type_stats ) ,
                "::" , stringify ! ( mts_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type_stats ) ) . _mts_reserved1 as
                * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_type_stats ) ,
                "::" , stringify ! ( _mts_reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type_stats ) ) . _mts_reserved2 as
                * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_type_stats ) ,
                "::" , stringify ! ( _mts_reserved2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type_stats ) ) . _mts_reserved3 as
                * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_type_stats ) ,
                "::" , stringify ! ( _mts_reserved3 ) ));
}
impl Clone for malloc_type_stats {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct malloc_type_internal {
    pub mti_probes: [u32; 2usize],
    pub mti_zone: u_char,
    pub mti_stats: [malloc_type_stats; 256usize],
}
#[test]
fn bindgen_test_layout_malloc_type_internal() {
    assert_eq!(::core::mem::size_of::<malloc_type_internal>() , 16400usize ,
               concat ! ( "Size of: " , stringify ! ( malloc_type_internal )
               ));
    assert_eq! (::core::mem::align_of::<malloc_type_internal>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( malloc_type_internal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type_internal ) ) . mti_probes as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_type_internal )
                , "::" , stringify ! ( mti_probes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type_internal ) ) . mti_zone as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_type_internal )
                , "::" , stringify ! ( mti_zone ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type_internal ) ) . mti_stats as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_type_internal )
                , "::" , stringify ! ( mti_stats ) ));
}
impl Clone for malloc_type_internal {
    fn clone(&self) -> Self { *self }
}
impl Default for malloc_type_internal {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for malloc_type_internal {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "malloc_type_internal {{ mti_probes: {:?}, mti_zone: {:?}, mti_stats: [{}] }}"
               , self . mti_probes , self . mti_zone , self . mti_stats . iter
               (  ) . enumerate (  ) . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ))
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct malloc_type_stream_header {
    pub mtsh_version: u32,
    pub mtsh_maxcpus: u32,
    pub mtsh_count: u32,
    pub _mtsh_pad: u32,
}
#[test]
fn bindgen_test_layout_malloc_type_stream_header() {
    assert_eq!(::core::mem::size_of::<malloc_type_stream_header>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( malloc_type_stream_header ) ));
    assert_eq! (::core::mem::align_of::<malloc_type_stream_header>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( malloc_type_stream_header )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type_stream_header ) ) .
                mtsh_version as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                malloc_type_stream_header ) , "::" , stringify ! (
                mtsh_version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type_stream_header ) ) .
                mtsh_maxcpus as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                malloc_type_stream_header ) , "::" , stringify ! (
                mtsh_maxcpus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type_stream_header ) ) .
                mtsh_count as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                malloc_type_stream_header ) , "::" , stringify ! ( mtsh_count
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type_stream_header ) ) . _mtsh_pad
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                malloc_type_stream_header ) , "::" , stringify ! ( _mtsh_pad )
                ));
}
impl Clone for malloc_type_stream_header {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct malloc_type_header {
    pub mth_name: [::kernel::sys::raw::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_malloc_type_header() {
    assert_eq!(::core::mem::size_of::<malloc_type_header>() , 32usize , concat
               ! ( "Size of: " , stringify ! ( malloc_type_header ) ));
    assert_eq! (::core::mem::align_of::<malloc_type_header>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( malloc_type_header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type_header ) ) . mth_name as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_type_header ) ,
                "::" , stringify ! ( mth_name ) ));
}
impl Clone for malloc_type_header {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "M_CACHE"]
    pub static mut M_CACHE: [malloc_type; 1usize];
}
extern "C" {
    #[link_name = "M_DEVBUF"]
    pub static mut M_DEVBUF: [malloc_type; 1usize];
}
extern "C" {
    #[link_name = "M_TEMP"]
    pub static mut M_TEMP: [malloc_type; 1usize];
}
extern "C" {
    #[link_name = "M_IOV"]
    pub static mut M_IOV: [malloc_type; 1usize];
}
extern "C" {
    #[link_name = "malloc_mtx"]
    pub static mut malloc_mtx: mtx;
}
pub type malloc_type_list_func_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut malloc_type,
                                                arg2:
                                                    *mut ::kernel::sys::raw::c_void)>;
extern "C" {
    pub fn contigfree(addr: *mut ::kernel::sys::raw::c_void,
                      size: ::kernel::sys::raw::c_ulong,
                      type_: *mut malloc_type);
}
extern "C" {
    pub fn contigmalloc(size: ::kernel::sys::raw::c_ulong,
                        type_: *mut malloc_type,
                        flags: ::kernel::sys::raw::c_int, low: vm_paddr_t,
                        high: vm_paddr_t,
                        alignment: ::kernel::sys::raw::c_ulong,
                        boundary: vm_paddr_t)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn contigmalloc_domain(size: ::kernel::sys::raw::c_ulong,
                               type_: *mut malloc_type,
                               domain: ::kernel::sys::raw::c_int,
                               flags: ::kernel::sys::raw::c_int,
                               low: vm_paddr_t, high: vm_paddr_t,
                               alignment: ::kernel::sys::raw::c_ulong,
                               boundary: vm_paddr_t)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn free(addr: *mut ::kernel::sys::raw::c_void,
                type_: *mut malloc_type);
}
extern "C" {
    pub fn free_domain(addr: *mut ::kernel::sys::raw::c_void,
                       type_: *mut malloc_type);
}
extern "C" {
    pub fn malloc(size: usize, type_: *mut malloc_type,
                  flags: ::kernel::sys::raw::c_int)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn malloc_domain(size: usize, type_: *mut malloc_type,
                         domain: ::kernel::sys::raw::c_int,
                         flags: ::kernel::sys::raw::c_int)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn mallocarray(nmemb: usize, size: usize, type_: *mut malloc_type,
                       flags: ::kernel::sys::raw::c_int)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn malloc_init(arg1: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn malloc_last_fail() -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn malloc_type_allocated(type_: *mut malloc_type,
                                 size: ::kernel::sys::raw::c_ulong);
}
extern "C" {
    pub fn malloc_type_freed(type_: *mut malloc_type,
                             size: ::kernel::sys::raw::c_ulong);
}
extern "C" {
    pub fn malloc_type_list(arg1: malloc_type_list_func_t,
                            arg2: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn malloc_uninit(arg1: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn realloc(addr: *mut ::kernel::sys::raw::c_void, size: usize,
                   type_: *mut malloc_type, flags: ::kernel::sys::raw::c_int)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn reallocf(addr: *mut ::kernel::sys::raw::c_void, size: usize,
                    type_: *mut malloc_type, flags: ::kernel::sys::raw::c_int)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn malloc_desc2type(desc: *const ::kernel::sys::raw::c_char)
     -> *mut malloc_type;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uma_zone {
    _unused: [u8; 0],
}
pub type uma_zone_t = *mut uma_zone;
extern "C" {
    pub fn zone_drain(arg1: uma_zone_t);
}
pub type uma_ctor =
    ::core::option::Option<unsafe extern "C" fn(mem:
                                                    *mut ::kernel::sys::raw::c_void,
                                                size:
                                                    ::kernel::sys::raw::c_int,
                                                arg:
                                                    *mut ::kernel::sys::raw::c_void,
                                                flags:
                                                    ::kernel::sys::raw::c_int)
                               -> ::kernel::sys::raw::c_int>;
pub type uma_dtor =
    ::core::option::Option<unsafe extern "C" fn(mem:
                                                    *mut ::kernel::sys::raw::c_void,
                                                size:
                                                    ::kernel::sys::raw::c_int,
                                                arg:
                                                    *mut ::kernel::sys::raw::c_void)>;
pub type uma_init =
    ::core::option::Option<unsafe extern "C" fn(mem:
                                                    *mut ::kernel::sys::raw::c_void,
                                                size:
                                                    ::kernel::sys::raw::c_int,
                                                flags:
                                                    ::kernel::sys::raw::c_int)
                               -> ::kernel::sys::raw::c_int>;
pub type uma_fini =
    ::core::option::Option<unsafe extern "C" fn(mem:
                                                    *mut ::kernel::sys::raw::c_void,
                                                size:
                                                    ::kernel::sys::raw::c_int)>;
pub type uma_import =
    ::core::option::Option<unsafe extern "C" fn(arg:
                                                    *mut ::kernel::sys::raw::c_void,
                                                store:
                                                    *mut *mut ::kernel::sys::raw::c_void,
                                                count:
                                                    ::kernel::sys::raw::c_int,
                                                domain:
                                                    ::kernel::sys::raw::c_int,
                                                flags:
                                                    ::kernel::sys::raw::c_int)
                               -> ::kernel::sys::raw::c_int>;
pub type uma_release =
    ::core::option::Option<unsafe extern "C" fn(arg:
                                                    *mut ::kernel::sys::raw::c_void,
                                                store:
                                                    *mut *mut ::kernel::sys::raw::c_void,
                                                count:
                                                    ::kernel::sys::raw::c_int)>;
extern "C" {
    pub fn uma_zcreate(name: *const ::kernel::sys::raw::c_char, size: usize,
                       ctor: uma_ctor, dtor: uma_dtor, uminit: uma_init,
                       fini: uma_fini, align: ::kernel::sys::raw::c_int,
                       flags: u32) -> uma_zone_t;
}
extern "C" {
    pub fn uma_zsecond_create(name: *mut ::kernel::sys::raw::c_char,
                              ctor: uma_ctor, dtor: uma_dtor, zinit: uma_init,
                              zfini: uma_fini, master: uma_zone_t)
     -> uma_zone_t;
}
extern "C" {
    pub fn uma_zsecond_add(zone: uma_zone_t, master: uma_zone_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn uma_zcache_create(name: *mut ::kernel::sys::raw::c_char,
                             size: ::kernel::sys::raw::c_int, ctor: uma_ctor,
                             dtor: uma_dtor, zinit: uma_init, zfini: uma_fini,
                             zimport: uma_import, zrelease: uma_release,
                             arg: *mut ::kernel::sys::raw::c_void,
                             flags: ::kernel::sys::raw::c_int) -> uma_zone_t;
}
extern "C" {
    pub fn uma_zdestroy(zone: uma_zone_t);
}
extern "C" {
    pub fn uma_zalloc_arg(zone: uma_zone_t,
                          arg: *mut ::kernel::sys::raw::c_void,
                          flags: ::kernel::sys::raw::c_int)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn uma_zalloc_pcpu_arg(zone: uma_zone_t,
                               arg: *mut ::kernel::sys::raw::c_void,
                               flags: ::kernel::sys::raw::c_int)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn uma_zalloc_domain(zone: uma_zone_t,
                             arg: *mut ::kernel::sys::raw::c_void,
                             domain: ::kernel::sys::raw::c_int,
                             flags: ::kernel::sys::raw::c_int)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn uma_zfree_arg(zone: uma_zone_t,
                         item: *mut ::kernel::sys::raw::c_void,
                         arg: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn uma_zfree_pcpu_arg(zone: uma_zone_t,
                              item: *mut ::kernel::sys::raw::c_void,
                              arg: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn uma_zfree_domain(zone: uma_zone_t,
                            item: *mut ::kernel::sys::raw::c_void,
                            arg: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn uma_zwait(zone: uma_zone_t);
}
pub type uma_alloc =
    ::core::option::Option<unsafe extern "C" fn(zone: uma_zone_t,
                                                size: vm_size_t,
                                                domain:
                                                    ::kernel::sys::raw::c_int,
                                                pflag: *mut u8,
                                                wait:
                                                    ::kernel::sys::raw::c_int)
                               -> *mut ::kernel::sys::raw::c_void>;
pub type uma_free =
    ::core::option::Option<unsafe extern "C" fn(item:
                                                    *mut ::kernel::sys::raw::c_void,
                                                size: vm_size_t, pflag: u8)>;
extern "C" {
    pub fn uma_reclaim();
}
extern "C" {
    pub fn uma_set_align(align: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn uma_zone_reserve(zone: uma_zone_t,
                            nitems: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn uma_zone_reserve_kva(zone: uma_zone_t,
                                nitems: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn uma_zone_set_max(zone: uma_zone_t,
                            nitems: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn uma_zone_get_max(zone: uma_zone_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn uma_zone_set_warning(zone: uma_zone_t,
                                warning: *const ::kernel::sys::raw::c_char);
}
pub type uma_maxaction_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: uma_zone_t,
                                                arg2:
                                                    ::kernel::sys::raw::c_int)>;
extern "C" {
    pub fn uma_zone_set_maxaction(zone: uma_zone_t, arg1: uma_maxaction_t);
}
extern "C" {
    pub fn uma_zone_get_cur(zone: uma_zone_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn uma_zone_set_init(zone: uma_zone_t, uminit: uma_init);
}
extern "C" {
    pub fn uma_zone_set_fini(zone: uma_zone_t, fini: uma_fini);
}
extern "C" {
    pub fn uma_zone_set_zinit(zone: uma_zone_t, zinit: uma_init);
}
extern "C" {
    pub fn uma_zone_set_zfini(zone: uma_zone_t, zfini: uma_fini);
}
extern "C" {
    pub fn uma_zone_set_allocf(zone: uma_zone_t, allocf: uma_alloc);
}
extern "C" {
    pub fn uma_zone_set_freef(zone: uma_zone_t, freef: uma_free);
}
extern "C" {
    pub fn uma_prealloc(zone: uma_zone_t, itemcnt: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn uma_zone_exhausted(zone: uma_zone_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn uma_zone_exhausted_nolock(zone: uma_zone_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "pcpu_zone_64"]
    pub static mut pcpu_zone_64: uma_zone_t;
}
extern "C" {
    #[link_name = "pcpu_zone_ptr"]
    pub static mut pcpu_zone_ptr: uma_zone_t;
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct uma_stream_header {
    pub ush_version: u32,
    pub ush_maxcpus: u32,
    pub ush_count: u32,
    pub _ush_pad: u32,
}
#[test]
fn bindgen_test_layout_uma_stream_header() {
    assert_eq!(::core::mem::size_of::<uma_stream_header>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( uma_stream_header ) ));
    assert_eq! (::core::mem::align_of::<uma_stream_header>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( uma_stream_header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_stream_header ) ) . ush_version as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_stream_header ) ,
                "::" , stringify ! ( ush_version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_stream_header ) ) . ush_maxcpus as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_stream_header ) ,
                "::" , stringify ! ( ush_maxcpus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_stream_header ) ) . ush_count as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_stream_header ) ,
                "::" , stringify ! ( ush_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_stream_header ) ) . _ush_pad as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_stream_header ) ,
                "::" , stringify ! ( _ush_pad ) ));
}
impl Clone for uma_stream_header {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct uma_type_header {
    pub uth_name: [::kernel::sys::raw::c_char; 32usize],
    pub uth_align: u32,
    pub uth_size: u32,
    pub uth_rsize: u32,
    pub uth_maxpages: u32,
    pub uth_limit: u32,
    pub uth_pages: u32,
    pub uth_keg_free: u32,
    pub uth_zone_free: u32,
    pub uth_bucketsize: u32,
    pub uth_zone_flags: u32,
    pub uth_allocs: u64,
    pub uth_frees: u64,
    pub uth_fails: u64,
    pub uth_sleeps: u64,
    pub _uth_reserved1: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_uma_type_header() {
    assert_eq!(::core::mem::size_of::<uma_type_header>() , 120usize , concat !
               ( "Size of: " , stringify ! ( uma_type_header ) ));
    assert_eq! (::core::mem::align_of::<uma_type_header>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( uma_type_header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_type_header ) ) . uth_name as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_type_header ) ,
                "::" , stringify ! ( uth_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_type_header ) ) . uth_align as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_type_header ) ,
                "::" , stringify ! ( uth_align ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_type_header ) ) . uth_size as * const
                _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_type_header ) ,
                "::" , stringify ! ( uth_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_type_header ) ) . uth_rsize as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_type_header ) ,
                "::" , stringify ! ( uth_rsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_type_header ) ) . uth_maxpages as *
                const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_type_header ) ,
                "::" , stringify ! ( uth_maxpages ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_type_header ) ) . uth_limit as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_type_header ) ,
                "::" , stringify ! ( uth_limit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_type_header ) ) . uth_pages as *
                const _ as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_type_header ) ,
                "::" , stringify ! ( uth_pages ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_type_header ) ) . uth_keg_free as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_type_header ) ,
                "::" , stringify ! ( uth_keg_free ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_type_header ) ) . uth_zone_free as *
                const _ as usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_type_header ) ,
                "::" , stringify ! ( uth_zone_free ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_type_header ) ) . uth_bucketsize as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_type_header ) ,
                "::" , stringify ! ( uth_bucketsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_type_header ) ) . uth_zone_flags as *
                const _ as usize } , 68usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_type_header ) ,
                "::" , stringify ! ( uth_zone_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_type_header ) ) . uth_allocs as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_type_header ) ,
                "::" , stringify ! ( uth_allocs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_type_header ) ) . uth_frees as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_type_header ) ,
                "::" , stringify ! ( uth_frees ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_type_header ) ) . uth_fails as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_type_header ) ,
                "::" , stringify ! ( uth_fails ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_type_header ) ) . uth_sleeps as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_type_header ) ,
                "::" , stringify ! ( uth_sleeps ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_type_header ) ) . _uth_reserved1 as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_type_header ) ,
                "::" , stringify ! ( _uth_reserved1 ) ));
}
impl Clone for uma_type_header {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct uma_percpu_stat {
    pub ups_allocs: u64,
    pub ups_frees: u64,
    pub ups_cache_free: u64,
    pub _ups_reserved: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_uma_percpu_stat() {
    assert_eq!(::core::mem::size_of::<uma_percpu_stat>() , 64usize , concat !
               ( "Size of: " , stringify ! ( uma_percpu_stat ) ));
    assert_eq! (::core::mem::align_of::<uma_percpu_stat>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( uma_percpu_stat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_percpu_stat ) ) . ups_allocs as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_percpu_stat ) ,
                "::" , stringify ! ( ups_allocs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_percpu_stat ) ) . ups_frees as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_percpu_stat ) ,
                "::" , stringify ! ( ups_frees ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_percpu_stat ) ) . ups_cache_free as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_percpu_stat ) ,
                "::" , stringify ! ( ups_cache_free ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_percpu_stat ) ) . _ups_reserved as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_percpu_stat ) ,
                "::" , stringify ! ( _ups_reserved ) ));
}
impl Clone for uma_percpu_stat {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn uma_reclaim_wakeup();
}
extern "C" {
    pub fn uma_reclaim_worker(arg1: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn uma_limit() -> ::kernel::sys::raw::c_ulong;
}
extern "C" {
    pub fn uma_size() -> ::kernel::sys::raw::c_ulong;
}
extern "C" {
    pub fn uma_avail() -> ::kernel::sys::raw::c_long;
}
extern "C" {
    #[link_name = "sdt_probes_enabled"]
    pub static mut sdt_probes_enabled: bool_;
}
pub type sdt_probe_func_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: u32, arg0: usize,
                                                arg1: usize, arg2: usize,
                                                arg3: usize, arg4: usize)>;
extern "C" {
    #[link_name = "sdt_probe_func"]
    pub static mut sdt_probe_func: sdt_probe_func_t;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sdt_probe {
    pub version: ::kernel::sys::raw::c_int,
    pub prov: *mut sdt_provider,
    pub probe_entry: sdt_probe__bindgen_ty_1,
    pub argtype_list: sdt_probe__bindgen_ty_2,
    pub mod_: *const ::kernel::sys::raw::c_char,
    pub func: *const ::kernel::sys::raw::c_char,
    pub name: *const ::kernel::sys::raw::c_char,
    pub id: id_t,
    pub n_args: ::kernel::sys::raw::c_int,
    pub sdtp_lf: *mut linker_file,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sdt_probe__bindgen_ty_1 {
    pub tqe_next: *mut sdt_probe,
    pub tqe_prev: *mut *mut sdt_probe,
}
#[test]
fn bindgen_test_layout_sdt_probe__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<sdt_probe__bindgen_ty_1>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( sdt_probe__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<sdt_probe__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( sdt_probe__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe__bindgen_ty_1 ) ) . tqe_next as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe__bindgen_ty_1
                ) , "::" , stringify ! ( tqe_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe__bindgen_ty_1 ) ) . tqe_prev as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe__bindgen_ty_1
                ) , "::" , stringify ! ( tqe_prev ) ));
}
impl Clone for sdt_probe__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for sdt_probe__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sdt_probe__bindgen_ty_2 {
    pub tqh_first: *mut sdt_argtype,
    pub tqh_last: *mut *mut sdt_argtype,
}
#[test]
fn bindgen_test_layout_sdt_probe__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<sdt_probe__bindgen_ty_2>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( sdt_probe__bindgen_ty_2 ) ));
    assert_eq! (::core::mem::align_of::<sdt_probe__bindgen_ty_2>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( sdt_probe__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe__bindgen_ty_2 ) ) . tqh_first
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe__bindgen_ty_2
                ) , "::" , stringify ! ( tqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe__bindgen_ty_2 ) ) . tqh_last as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe__bindgen_ty_2
                ) , "::" , stringify ! ( tqh_last ) ));
}
impl Clone for sdt_probe__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for sdt_probe__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_sdt_probe() {
    assert_eq!(::core::mem::size_of::<sdt_probe>() , 96usize , concat ! (
               "Size of: " , stringify ! ( sdt_probe ) ));
    assert_eq! (::core::mem::align_of::<sdt_probe>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sdt_probe ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . version as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . prov as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( prov ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . probe_entry as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( probe_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . argtype_list as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( argtype_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . mod_ as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( mod_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . func as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . name as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . id as * const _ as usize
                } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . n_args as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( n_args ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . sdtp_lf as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( sdtp_lf ) ));
}
impl Clone for sdt_probe {
    fn clone(&self) -> Self { *self }
}
impl Default for sdt_probe {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sdt_provider {
    pub name: *mut ::kernel::sys::raw::c_char,
    pub prov_entry: sdt_provider__bindgen_ty_1,
    pub id: usize,
    pub sdt_refs: ::kernel::sys::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sdt_provider__bindgen_ty_1 {
    pub tqe_next: *mut sdt_provider,
    pub tqe_prev: *mut *mut sdt_provider,
}
#[test]
fn bindgen_test_layout_sdt_provider__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<sdt_provider__bindgen_ty_1>() , 16usize
               , concat ! (
               "Size of: " , stringify ! ( sdt_provider__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<sdt_provider__bindgen_ty_1>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( sdt_provider__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_provider__bindgen_ty_1 ) ) . tqe_next
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                sdt_provider__bindgen_ty_1 ) , "::" , stringify ! ( tqe_next )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_provider__bindgen_ty_1 ) ) . tqe_prev
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                sdt_provider__bindgen_ty_1 ) , "::" , stringify ! ( tqe_prev )
                ));
}
impl Clone for sdt_provider__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for sdt_provider__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_sdt_provider() {
    assert_eq!(::core::mem::size_of::<sdt_provider>() , 40usize , concat ! (
               "Size of: " , stringify ! ( sdt_provider ) ));
    assert_eq! (::core::mem::align_of::<sdt_provider>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sdt_provider ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_provider ) ) . name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_provider ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_provider ) ) . prov_entry as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_provider ) , "::" ,
                stringify ! ( prov_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_provider ) ) . id as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_provider ) , "::" ,
                stringify ! ( id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_provider ) ) . sdt_refs as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_provider ) , "::" ,
                stringify ! ( sdt_refs ) ));
}
impl Clone for sdt_provider {
    fn clone(&self) -> Self { *self }
}
impl Default for sdt_provider {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct linker_file {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sdt_argtype {
    pub ndx: ::kernel::sys::raw::c_int,
    pub type_: *const ::kernel::sys::raw::c_char,
    pub xtype: *const ::kernel::sys::raw::c_char,
    pub argtype_entry: sdt_argtype__bindgen_ty_1,
    pub probe: *mut sdt_probe,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sdt_argtype__bindgen_ty_1 {
    pub tqe_next: *mut sdt_argtype,
    pub tqe_prev: *mut *mut sdt_argtype,
}
#[test]
fn bindgen_test_layout_sdt_argtype__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<sdt_argtype__bindgen_ty_1>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( sdt_argtype__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<sdt_argtype__bindgen_ty_1>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( sdt_argtype__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_argtype__bindgen_ty_1 ) ) . tqe_next
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                sdt_argtype__bindgen_ty_1 ) , "::" , stringify ! ( tqe_next )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_argtype__bindgen_ty_1 ) ) . tqe_prev
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                sdt_argtype__bindgen_ty_1 ) , "::" , stringify ! ( tqe_prev )
                ));
}
impl Clone for sdt_argtype__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for sdt_argtype__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_sdt_argtype() {
    assert_eq!(::core::mem::size_of::<sdt_argtype>() , 48usize , concat ! (
               "Size of: " , stringify ! ( sdt_argtype ) ));
    assert_eq! (::core::mem::align_of::<sdt_argtype>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sdt_argtype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_argtype ) ) . ndx as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_argtype ) , "::" ,
                stringify ! ( ndx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_argtype ) ) . type_ as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_argtype ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_argtype ) ) . xtype as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_argtype ) , "::" ,
                stringify ! ( xtype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_argtype ) ) . argtype_entry as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_argtype ) , "::" ,
                stringify ! ( argtype_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_argtype ) ) . probe as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_argtype ) , "::" ,
                stringify ! ( probe ) ));
}
impl Clone for sdt_argtype {
    fn clone(&self) -> Self { *self }
}
impl Default for sdt_argtype {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    pub fn sdt_probe_stub(arg1: u32, arg2: usize, arg3: usize, arg4: usize,
                          arg5: usize, arg6: usize);
}
#[repr(C)]
pub struct mbuf {
    pub __bindgen_anon_1: mbuf__bindgen_ty_1,
    pub __bindgen_anon_2: mbuf__bindgen_ty_2,
    pub m_data: caddr_t,
    pub m_len: i32,
    pub _bitfield_1: u32,
    pub __bindgen_anon_3: mbuf__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy)]
pub union mbuf__bindgen_ty_1 {
    pub m_next: *mut mbuf,
    pub m_slist: mbuf__bindgen_ty_1__bindgen_ty_1,
    pub m_stailq: mbuf__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mbuf__bindgen_ty_1__bindgen_ty_1 {
    pub sle_next: *mut mbuf,
}
#[test]
fn bindgen_test_layout_mbuf__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<mbuf__bindgen_ty_1__bindgen_ty_1>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( mbuf__bindgen_ty_1__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<mbuf__bindgen_ty_1__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                mbuf__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbuf__bindgen_ty_1__bindgen_ty_1 ) ) .
                sle_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                mbuf__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! (
                sle_next ) ));
}
impl Clone for mbuf__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for mbuf__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mbuf__bindgen_ty_1__bindgen_ty_2 {
    pub stqe_next: *mut mbuf,
}
#[test]
fn bindgen_test_layout_mbuf__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<mbuf__bindgen_ty_1__bindgen_ty_2>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( mbuf__bindgen_ty_1__bindgen_ty_2 )
               ));
    assert_eq! (::core::mem::align_of::<mbuf__bindgen_ty_1__bindgen_ty_2>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                mbuf__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbuf__bindgen_ty_1__bindgen_ty_2 ) ) .
                stqe_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                mbuf__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify ! (
                stqe_next ) ));
}
impl Clone for mbuf__bindgen_ty_1__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for mbuf__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_mbuf__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<mbuf__bindgen_ty_1>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( mbuf__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<mbuf__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( mbuf__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbuf__bindgen_ty_1 ) ) . m_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mbuf__bindgen_ty_1 ) ,
                "::" , stringify ! ( m_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbuf__bindgen_ty_1 ) ) . m_slist as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mbuf__bindgen_ty_1 ) ,
                "::" , stringify ! ( m_slist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbuf__bindgen_ty_1 ) ) . m_stailq as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mbuf__bindgen_ty_1 ) ,
                "::" , stringify ! ( m_stailq ) ));
}
impl Clone for mbuf__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for mbuf__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for mbuf__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "mbuf__bindgen_ty_1 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy)]
pub union mbuf__bindgen_ty_2 {
    pub m_nextpkt: *mut mbuf,
    pub m_slistpkt: mbuf__bindgen_ty_2__bindgen_ty_1,
    pub m_stailqpkt: mbuf__bindgen_ty_2__bindgen_ty_2,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mbuf__bindgen_ty_2__bindgen_ty_1 {
    pub sle_next: *mut mbuf,
}
#[test]
fn bindgen_test_layout_mbuf__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<mbuf__bindgen_ty_2__bindgen_ty_1>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( mbuf__bindgen_ty_2__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<mbuf__bindgen_ty_2__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                mbuf__bindgen_ty_2__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbuf__bindgen_ty_2__bindgen_ty_1 ) ) .
                sle_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                mbuf__bindgen_ty_2__bindgen_ty_1 ) , "::" , stringify ! (
                sle_next ) ));
}
impl Clone for mbuf__bindgen_ty_2__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for mbuf__bindgen_ty_2__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mbuf__bindgen_ty_2__bindgen_ty_2 {
    pub stqe_next: *mut mbuf,
}
#[test]
fn bindgen_test_layout_mbuf__bindgen_ty_2__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<mbuf__bindgen_ty_2__bindgen_ty_2>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( mbuf__bindgen_ty_2__bindgen_ty_2 )
               ));
    assert_eq! (::core::mem::align_of::<mbuf__bindgen_ty_2__bindgen_ty_2>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                mbuf__bindgen_ty_2__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbuf__bindgen_ty_2__bindgen_ty_2 ) ) .
                stqe_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                mbuf__bindgen_ty_2__bindgen_ty_2 ) , "::" , stringify ! (
                stqe_next ) ));
}
impl Clone for mbuf__bindgen_ty_2__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for mbuf__bindgen_ty_2__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_mbuf__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<mbuf__bindgen_ty_2>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( mbuf__bindgen_ty_2 ) ));
    assert_eq! (::core::mem::align_of::<mbuf__bindgen_ty_2>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( mbuf__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbuf__bindgen_ty_2 ) ) . m_nextpkt as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mbuf__bindgen_ty_2 ) ,
                "::" , stringify ! ( m_nextpkt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbuf__bindgen_ty_2 ) ) . m_slistpkt as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mbuf__bindgen_ty_2 ) ,
                "::" , stringify ! ( m_slistpkt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbuf__bindgen_ty_2 ) ) . m_stailqpkt as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mbuf__bindgen_ty_2 ) ,
                "::" , stringify ! ( m_stailqpkt ) ));
}
impl Clone for mbuf__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for mbuf__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for mbuf__bindgen_ty_2 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "mbuf__bindgen_ty_2 {{ union }}")
    }
}
#[repr(C)]
pub struct mbuf__bindgen_ty_3 {
    pub __bindgen_anon_1: __BindgenUnionField<mbuf__bindgen_ty_3__bindgen_ty_1>,
    pub m_dat: __BindgenUnionField<[::kernel::sys::raw::c_char; 0usize]>,
    pub bindgen_union_field: [u64; 13usize],
}
#[repr(C)]
pub struct mbuf__bindgen_ty_3__bindgen_ty_1 {
    pub m_pkthdr: pkthdr,
    pub __bindgen_anon_1: mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
pub struct mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {
    pub m_ext: __BindgenUnionField<m_ext>,
    pub m_pktdat: __BindgenUnionField<[::kernel::sys::raw::c_char; 0usize]>,
    pub bindgen_union_field: [u64; 6usize],
}
#[test]
fn bindgen_test_layout_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1>()
               , 48usize , concat ! (
               "Size of: " , stringify ! (
               mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 )
                ) . m_ext as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( m_ext ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 )
                ) . m_pktdat as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( m_pktdat ) ));
}
impl Default for mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_mbuf__bindgen_ty_3__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<mbuf__bindgen_ty_3__bindgen_ty_1>() ,
               104usize , concat ! (
               "Size of: " , stringify ! ( mbuf__bindgen_ty_3__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<mbuf__bindgen_ty_3__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                mbuf__bindgen_ty_3__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbuf__bindgen_ty_3__bindgen_ty_1 ) ) .
                m_pkthdr as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                mbuf__bindgen_ty_3__bindgen_ty_1 ) , "::" , stringify ! (
                m_pkthdr ) ));
}
impl Default for mbuf__bindgen_ty_3__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for mbuf__bindgen_ty_3__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "mbuf__bindgen_ty_3__bindgen_ty_1 {{ m_pkthdr: {:?} }}" ,
               self . m_pkthdr)
    }
}
#[test]
fn bindgen_test_layout_mbuf__bindgen_ty_3() {
    assert_eq!(::core::mem::size_of::<mbuf__bindgen_ty_3>() , 104usize ,
               concat ! ( "Size of: " , stringify ! ( mbuf__bindgen_ty_3 ) ));
    assert_eq! (::core::mem::align_of::<mbuf__bindgen_ty_3>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( mbuf__bindgen_ty_3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbuf__bindgen_ty_3 ) ) . m_dat as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mbuf__bindgen_ty_3 ) ,
                "::" , stringify ! ( m_dat ) ));
}
impl Default for mbuf__bindgen_ty_3 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for mbuf__bindgen_ty_3 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "mbuf__bindgen_ty_3 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_mbuf() {
    assert_eq!(::core::mem::size_of::<mbuf>() , 136usize , concat ! (
               "Size of: " , stringify ! ( mbuf ) ));
    assert_eq! (::core::mem::align_of::<mbuf>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( mbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbuf ) ) . m_data as * const _ as usize }
                , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mbuf ) , "::" ,
                stringify ! ( m_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbuf ) ) . m_len as * const _ as usize }
                , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( mbuf ) , "::" ,
                stringify ! ( m_len ) ));
}
impl Default for mbuf {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for mbuf {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "mbuf {{ m_data: {:?}, m_len: {:?}, m_type : {:?}, m_flags : {:?} }}"
               , self . m_data , self . m_len , self . m_type (  ) , self .
               m_flags (  ))
    }
}
impl mbuf {
    #[inline]
    pub fn m_type(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u32
                                                 as *mut u8,
                                             ::core::mem::size_of::<u32>())
        };
        let mask = 255u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::core::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_m_type(&mut self, val: u32) {
        let mask = 255u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u32
                                                 as *mut u8,
                                             ::core::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn m_flags(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u32
                                                 as *mut u8,
                                             ::core::mem::size_of::<u32>())
        };
        let mask = 4294967040u64 as u32;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::core::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_m_flags(&mut self, val: u32) {
        let mask = 4294967040u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u32
                                                 as *mut u8,
                                             ::core::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(m_type: u32, m_flags: u32) -> u32 {
        ({ ({ 0 } | ((m_type as u32 as u32) << 0usize) & (255u64 as u32)) } |
             ((m_flags as u32 as u32) << 8usize) & (4294967040u64 as u32))
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct mb_args {
    pub flags: ::kernel::sys::raw::c_int,
    pub type_: ::kernel::sys::raw::c_short,
}
#[test]
fn bindgen_test_layout_mb_args() {
    assert_eq!(::core::mem::size_of::<mb_args>() , 8usize , concat ! (
               "Size of: " , stringify ! ( mb_args ) ));
    assert_eq! (::core::mem::align_of::<mb_args>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( mb_args ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mb_args ) ) . flags as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mb_args ) , "::" ,
                stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mb_args ) ) . type_ as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( mb_args ) , "::" ,
                stringify ! ( type_ ) ));
}
impl Clone for mb_args {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct m_tag {
    pub m_tag_link: m_tag__bindgen_ty_1,
    pub m_tag_id: u_int16_t,
    pub m_tag_len: u_int16_t,
    pub m_tag_cookie: u_int32_t,
    pub m_tag_free: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                    *mut m_tag)>,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct m_tag__bindgen_ty_1 {
    pub sle_next: *mut m_tag,
}
#[test]
fn bindgen_test_layout_m_tag__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<m_tag__bindgen_ty_1>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( m_tag__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<m_tag__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( m_tag__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const m_tag__bindgen_ty_1 ) ) . sle_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( m_tag__bindgen_ty_1 ) ,
                "::" , stringify ! ( sle_next ) ));
}
impl Clone for m_tag__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for m_tag__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_m_tag() {
    assert_eq!(::core::mem::size_of::<m_tag>() , 24usize , concat ! (
               "Size of: " , stringify ! ( m_tag ) ));
    assert_eq! (::core::mem::align_of::<m_tag>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( m_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const m_tag ) ) . m_tag_link as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( m_tag ) , "::" ,
                stringify ! ( m_tag_link ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const m_tag ) ) . m_tag_id as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( m_tag ) , "::" ,
                stringify ! ( m_tag_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const m_tag ) ) . m_tag_len as * const _ as
                usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( m_tag ) , "::" ,
                stringify ! ( m_tag_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const m_tag ) ) . m_tag_cookie as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( m_tag ) , "::" ,
                stringify ! ( m_tag_cookie ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const m_tag ) ) . m_tag_free as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( m_tag ) , "::" ,
                stringify ! ( m_tag_free ) ));
}
impl Clone for m_tag {
    fn clone(&self) -> Self { *self }
}
impl Default for m_tag {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct m_snd_tag {
    pub ifp: *mut ifnet,
}
#[test]
fn bindgen_test_layout_m_snd_tag() {
    assert_eq!(::core::mem::size_of::<m_snd_tag>() , 8usize , concat ! (
               "Size of: " , stringify ! ( m_snd_tag ) ));
    assert_eq! (::core::mem::align_of::<m_snd_tag>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( m_snd_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const m_snd_tag ) ) . ifp as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( m_snd_tag ) , "::" ,
                stringify ! ( ifp ) ));
}
impl Clone for m_snd_tag {
    fn clone(&self) -> Self { *self }
}
impl Default for m_snd_tag {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct pkthdr {
    pub __bindgen_anon_1: pkthdr__bindgen_ty_1,
    pub tags: pkthdr_packet_tags,
    pub len: i32,
    pub flowid: u32,
    pub csum_flags: u32,
    pub fibnum: u16,
    pub cosqos: u8,
    pub rsstype: u8,
    pub __bindgen_anon_2: pkthdr__bindgen_ty_2,
    pub PH_per: pkthdr__bindgen_ty_3,
    pub PH_loc: pkthdr__bindgen_ty_4,
}
#[repr(C)]
#[derive(Copy)]
pub union pkthdr__bindgen_ty_1 {
    pub snd_tag: *mut m_snd_tag,
    pub rcvif: *mut ifnet,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_pkthdr__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<pkthdr__bindgen_ty_1>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( pkthdr__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<pkthdr__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( pkthdr__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_1 ) ) . snd_tag as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr__bindgen_ty_1 )
                , "::" , stringify ! ( snd_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_1 ) ) . rcvif as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr__bindgen_ty_1 )
                , "::" , stringify ! ( rcvif ) ));
}
impl Clone for pkthdr__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for pkthdr__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for pkthdr__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "pkthdr__bindgen_ty_1 {{ union }}")
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pkthdr_packet_tags {
    pub slh_first: *mut m_tag,
}
#[test]
fn bindgen_test_layout_pkthdr_packet_tags() {
    assert_eq!(::core::mem::size_of::<pkthdr_packet_tags>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( pkthdr_packet_tags ) ));
    assert_eq! (::core::mem::align_of::<pkthdr_packet_tags>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( pkthdr_packet_tags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr_packet_tags ) ) . slh_first as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr_packet_tags ) ,
                "::" , stringify ! ( slh_first ) ));
}
impl Clone for pkthdr_packet_tags {
    fn clone(&self) -> Self { *self }
}
impl Default for pkthdr_packet_tags {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub union pkthdr__bindgen_ty_2 {
    pub rcv_tstmp: u64,
    pub __bindgen_anon_1: pkthdr__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct pkthdr__bindgen_ty_2__bindgen_ty_1 {
    pub l2hlen: u8,
    pub l3hlen: u8,
    pub l4hlen: u8,
    pub l5hlen: u8,
    pub spare: u32,
}
#[test]
fn bindgen_test_layout_pkthdr__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<pkthdr__bindgen_ty_2__bindgen_ty_1>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( pkthdr__bindgen_ty_2__bindgen_ty_1
               ) ));
    assert_eq! (::core::mem::align_of::<pkthdr__bindgen_ty_2__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                pkthdr__bindgen_ty_2__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_2__bindgen_ty_1 ) ) .
                l2hlen as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pkthdr__bindgen_ty_2__bindgen_ty_1 ) , "::" , stringify ! (
                l2hlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_2__bindgen_ty_1 ) ) .
                l3hlen as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                pkthdr__bindgen_ty_2__bindgen_ty_1 ) , "::" , stringify ! (
                l3hlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_2__bindgen_ty_1 ) ) .
                l4hlen as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                pkthdr__bindgen_ty_2__bindgen_ty_1 ) , "::" , stringify ! (
                l4hlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_2__bindgen_ty_1 ) ) .
                l5hlen as * const _ as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! (
                pkthdr__bindgen_ty_2__bindgen_ty_1 ) , "::" , stringify ! (
                l5hlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_2__bindgen_ty_1 ) ) .
                spare as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                pkthdr__bindgen_ty_2__bindgen_ty_1 ) , "::" , stringify ! (
                spare ) ));
}
impl Clone for pkthdr__bindgen_ty_2__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_pkthdr__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<pkthdr__bindgen_ty_2>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( pkthdr__bindgen_ty_2 )
               ));
    assert_eq! (::core::mem::align_of::<pkthdr__bindgen_ty_2>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( pkthdr__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_2 ) ) . rcv_tstmp as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr__bindgen_ty_2 )
                , "::" , stringify ! ( rcv_tstmp ) ));
}
impl Clone for pkthdr__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for pkthdr__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for pkthdr__bindgen_ty_2 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "pkthdr__bindgen_ty_2 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy)]
pub union pkthdr__bindgen_ty_3 {
    pub eight: [u8; 8usize],
    pub sixteen: [u16; 4usize],
    pub thirtytwo: [u32; 2usize],
    pub sixtyfour: [u64; 1usize],
    pub unintptr: [usize; 1usize],
    pub ptr: *mut ::kernel::sys::raw::c_void,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_pkthdr__bindgen_ty_3() {
    assert_eq!(::core::mem::size_of::<pkthdr__bindgen_ty_3>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( pkthdr__bindgen_ty_3 )
               ));
    assert_eq! (::core::mem::align_of::<pkthdr__bindgen_ty_3>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( pkthdr__bindgen_ty_3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_3 ) ) . eight as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr__bindgen_ty_3 )
                , "::" , stringify ! ( eight ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_3 ) ) . sixteen as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr__bindgen_ty_3 )
                , "::" , stringify ! ( sixteen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_3 ) ) . thirtytwo as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr__bindgen_ty_3 )
                , "::" , stringify ! ( thirtytwo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_3 ) ) . sixtyfour as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr__bindgen_ty_3 )
                , "::" , stringify ! ( sixtyfour ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_3 ) ) . unintptr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr__bindgen_ty_3 )
                , "::" , stringify ! ( unintptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_3 ) ) . ptr as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr__bindgen_ty_3 )
                , "::" , stringify ! ( ptr ) ));
}
impl Clone for pkthdr__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
impl Default for pkthdr__bindgen_ty_3 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for pkthdr__bindgen_ty_3 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "pkthdr__bindgen_ty_3 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy)]
pub union pkthdr__bindgen_ty_4 {
    pub eight: [u8; 8usize],
    pub sixteen: [u16; 4usize],
    pub thirtytwo: [u32; 2usize],
    pub sixtyfour: [u64; 1usize],
    pub unintptr: [usize; 1usize],
    pub ptr: *mut ::kernel::sys::raw::c_void,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_pkthdr__bindgen_ty_4() {
    assert_eq!(::core::mem::size_of::<pkthdr__bindgen_ty_4>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( pkthdr__bindgen_ty_4 )
               ));
    assert_eq! (::core::mem::align_of::<pkthdr__bindgen_ty_4>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( pkthdr__bindgen_ty_4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_4 ) ) . eight as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr__bindgen_ty_4 )
                , "::" , stringify ! ( eight ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_4 ) ) . sixteen as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr__bindgen_ty_4 )
                , "::" , stringify ! ( sixteen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_4 ) ) . thirtytwo as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr__bindgen_ty_4 )
                , "::" , stringify ! ( thirtytwo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_4 ) ) . sixtyfour as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr__bindgen_ty_4 )
                , "::" , stringify ! ( sixtyfour ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_4 ) ) . unintptr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr__bindgen_ty_4 )
                , "::" , stringify ! ( unintptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_4 ) ) . ptr as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr__bindgen_ty_4 )
                , "::" , stringify ! ( ptr ) ));
}
impl Clone for pkthdr__bindgen_ty_4 {
    fn clone(&self) -> Self { *self }
}
impl Default for pkthdr__bindgen_ty_4 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for pkthdr__bindgen_ty_4 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "pkthdr__bindgen_ty_4 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_pkthdr() {
    assert_eq!(::core::mem::size_of::<pkthdr>() , 56usize , concat ! (
               "Size of: " , stringify ! ( pkthdr ) ));
    assert_eq! (::core::mem::align_of::<pkthdr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pkthdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr ) ) . tags as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr ) , "::" ,
                stringify ! ( tags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr ) ) . len as * const _ as usize }
                , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr ) , "::" ,
                stringify ! ( len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr ) ) . flowid as * const _ as usize
                } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr ) , "::" ,
                stringify ! ( flowid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr ) ) . csum_flags as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr ) , "::" ,
                stringify ! ( csum_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr ) ) . fibnum as * const _ as usize
                } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr ) , "::" ,
                stringify ! ( fibnum ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr ) ) . cosqos as * const _ as usize
                } , 30usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr ) , "::" ,
                stringify ! ( cosqos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr ) ) . rsstype as * const _ as
                usize } , 31usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr ) , "::" ,
                stringify ! ( rsstype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr ) ) . PH_per as * const _ as usize
                } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr ) , "::" ,
                stringify ! ( PH_per ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr ) ) . PH_loc as * const _ as usize
                } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr ) , "::" ,
                stringify ! ( PH_loc ) ));
}
impl Clone for pkthdr {
    fn clone(&self) -> Self { *self }
}
impl Default for pkthdr {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for pkthdr {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "pkthdr {{ tags: {:?}, len: {:?}, flowid: {:?}, csum_flags: {:?}, fibnum: {:?}, cosqos: {:?}, rsstype: {:?}, PH_per: {:?}, PH_loc: {:?} }}"
               , self . tags , self . len , self . flowid , self . csum_flags
               , self . fibnum , self . cosqos , self . rsstype , self .
               PH_per , self . PH_loc)
    }
}
pub type m_ext_free_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut mbuf)>;
#[repr(C)]
#[derive(Copy)]
pub struct m_ext {
    pub __bindgen_anon_1: m_ext__bindgen_ty_1,
    pub ext_buf: *mut ::kernel::sys::raw::c_char,
    pub ext_size: u32,
    pub _bitfield_1: u32,
    pub ext_free: m_ext_free_t,
    pub ext_arg1: *mut ::kernel::sys::raw::c_void,
    pub ext_arg2: *mut ::kernel::sys::raw::c_void,
}
#[repr(C)]
#[derive(Copy)]
pub union m_ext__bindgen_ty_1 {
    pub ext_count: u_int,
    pub ext_cnt: *mut u_int,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_m_ext__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<m_ext__bindgen_ty_1>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( m_ext__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<m_ext__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( m_ext__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const m_ext__bindgen_ty_1 ) ) . ext_count as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( m_ext__bindgen_ty_1 ) ,
                "::" , stringify ! ( ext_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const m_ext__bindgen_ty_1 ) ) . ext_cnt as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( m_ext__bindgen_ty_1 ) ,
                "::" , stringify ! ( ext_cnt ) ));
}
impl Clone for m_ext__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for m_ext__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for m_ext__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "m_ext__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_m_ext() {
    assert_eq!(::core::mem::size_of::<m_ext>() , 48usize , concat ! (
               "Size of: " , stringify ! ( m_ext ) ));
    assert_eq! (::core::mem::align_of::<m_ext>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( m_ext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const m_ext ) ) . ext_buf as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( m_ext ) , "::" ,
                stringify ! ( ext_buf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const m_ext ) ) . ext_size as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( m_ext ) , "::" ,
                stringify ! ( ext_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const m_ext ) ) . ext_free as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( m_ext ) , "::" ,
                stringify ! ( ext_free ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const m_ext ) ) . ext_arg1 as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( m_ext ) , "::" ,
                stringify ! ( ext_arg1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const m_ext ) ) . ext_arg2 as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( m_ext ) , "::" ,
                stringify ! ( ext_arg2 ) ));
}
impl Clone for m_ext {
    fn clone(&self) -> Self { *self }
}
impl Default for m_ext {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for m_ext {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "m_ext {{ ext_buf: {:?}, ext_size: {:?}, ext_type : {:?}, ext_flags : {:?}, ext_free: {:?}, ext_arg1: {:?}, ext_arg2: {:?} }}"
               , self . ext_buf , self . ext_size , self . ext_type (  ) ,
               self . ext_flags (  ) , self . ext_free , self . ext_arg1 ,
               self . ext_arg2)
    }
}
impl m_ext {
    #[inline]
    pub fn ext_type(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u32
                                                 as *mut u8,
                                             ::core::mem::size_of::<u32>())
        };
        let mask = 255u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::core::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_ext_type(&mut self, val: u32) {
        let mask = 255u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u32
                                                 as *mut u8,
                                             ::core::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn ext_flags(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u32
                                                 as *mut u8,
                                             ::core::mem::size_of::<u32>())
        };
        let mask = 4294967040u64 as u32;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::core::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_ext_flags(&mut self, val: u32) {
        let mask = 4294967040u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u32
                                                 as *mut u8,
                                             ::core::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(ext_type: u32, ext_flags: u32) -> u32 {
        ({ ({ 0 } | ((ext_type as u32 as u32) << 0usize) & (255u64 as u32)) }
             | ((ext_flags as u32 as u32) << 8usize) & (4294967040u64 as u32))
    }
}
extern "C" {
    #[link_name = "zone_mbuf"]
    pub static mut zone_mbuf: uma_zone_t;
}
extern "C" {
    #[link_name = "zone_clust"]
    pub static mut zone_clust: uma_zone_t;
}
extern "C" {
    #[link_name = "zone_pack"]
    pub static mut zone_pack: uma_zone_t;
}
extern "C" {
    #[link_name = "zone_jumbop"]
    pub static mut zone_jumbop: uma_zone_t;
}
extern "C" {
    #[link_name = "zone_jumbo9"]
    pub static mut zone_jumbo9: uma_zone_t;
}
extern "C" {
    #[link_name = "zone_jumbo16"]
    pub static mut zone_jumbo16: uma_zone_t;
}
extern "C" {
    pub fn mb_dupcl(arg1: *mut mbuf, arg2: *mut mbuf);
}
extern "C" {
    pub fn mb_free_ext(arg1: *mut mbuf);
}
extern "C" {
    pub fn m_adj(arg1: *mut mbuf, arg2: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn m_apply(arg1: *mut mbuf, arg2: ::kernel::sys::raw::c_int,
                   arg3: ::kernel::sys::raw::c_int,
                   arg4:
                       ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                       *mut ::kernel::sys::raw::c_void,
                                                                   arg2:
                                                                       *mut ::kernel::sys::raw::c_void,
                                                                   arg3:
                                                                       u_int)
                                                  ->
                                                      ::kernel::sys::raw::c_int>,
                   arg5: *mut ::kernel::sys::raw::c_void)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn m_append(arg1: *mut mbuf, arg2: ::kernel::sys::raw::c_int,
                    arg3: c_caddr_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn m_cat(arg1: *mut mbuf, arg2: *mut mbuf);
}
extern "C" {
    pub fn m_catpkt(arg1: *mut mbuf, arg2: *mut mbuf);
}
extern "C" {
    pub fn m_clget(m: *mut mbuf, how: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn m_cljget(m: *mut mbuf, how: ::kernel::sys::raw::c_int,
                    size: ::kernel::sys::raw::c_int)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn m_collapse(arg1: *mut mbuf, arg2: ::kernel::sys::raw::c_int,
                      arg3: ::kernel::sys::raw::c_int) -> *mut mbuf;
}
extern "C" {
    pub fn m_copyback(arg1: *mut mbuf, arg2: ::kernel::sys::raw::c_int,
                      arg3: ::kernel::sys::raw::c_int, arg4: c_caddr_t);
}
extern "C" {
    pub fn m_copydata(arg1: *const mbuf, arg2: ::kernel::sys::raw::c_int,
                      arg3: ::kernel::sys::raw::c_int, arg4: caddr_t);
}
extern "C" {
    pub fn m_copym(arg1: *mut mbuf, arg2: ::kernel::sys::raw::c_int,
                   arg3: ::kernel::sys::raw::c_int,
                   arg4: ::kernel::sys::raw::c_int) -> *mut mbuf;
}
extern "C" {
    pub fn m_copypacket(arg1: *mut mbuf, arg2: ::kernel::sys::raw::c_int)
     -> *mut mbuf;
}
extern "C" {
    pub fn m_copy_pkthdr(arg1: *mut mbuf, arg2: *mut mbuf);
}
extern "C" {
    pub fn m_copyup(arg1: *mut mbuf, arg2: ::kernel::sys::raw::c_int,
                    arg3: ::kernel::sys::raw::c_int) -> *mut mbuf;
}
extern "C" {
    pub fn m_defrag(arg1: *mut mbuf, arg2: ::kernel::sys::raw::c_int)
     -> *mut mbuf;
}
extern "C" {
    pub fn m_demote_pkthdr(arg1: *mut mbuf);
}
extern "C" {
    pub fn m_demote(arg1: *mut mbuf, arg2: ::kernel::sys::raw::c_int,
                    arg3: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn m_devget(arg1: *mut ::kernel::sys::raw::c_char,
                    arg2: ::kernel::sys::raw::c_int,
                    arg3: ::kernel::sys::raw::c_int, arg4: *mut ifnet,
                    arg5:
                        ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                        *mut ::kernel::sys::raw::c_char,
                                                                    arg2:
                                                                        caddr_t,
                                                                    arg3:
                                                                        u_int)>)
     -> *mut mbuf;
}
extern "C" {
    pub fn m_dup(arg1: *const mbuf, arg2: ::kernel::sys::raw::c_int)
     -> *mut mbuf;
}
extern "C" {
    pub fn m_dup_pkthdr(arg1: *mut mbuf, arg2: *const mbuf,
                        arg3: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn m_extadd(arg1: *mut mbuf, arg2: *mut ::kernel::sys::raw::c_char,
                    arg3: u_int, arg4: m_ext_free_t,
                    arg5: *mut ::kernel::sys::raw::c_void,
                    arg6: *mut ::kernel::sys::raw::c_void,
                    arg7: ::kernel::sys::raw::c_int,
                    arg8: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn m_fixhdr(arg1: *mut mbuf) -> u_int;
}
extern "C" {
    pub fn m_fragment(arg1: *mut mbuf, arg2: ::kernel::sys::raw::c_int,
                      arg3: ::kernel::sys::raw::c_int) -> *mut mbuf;
}
extern "C" {
    pub fn m_freem(arg1: *mut mbuf);
}
extern "C" {
    pub fn m_get2(arg1: ::kernel::sys::raw::c_int,
                  arg2: ::kernel::sys::raw::c_int,
                  arg3: ::kernel::sys::raw::c_short,
                  arg4: ::kernel::sys::raw::c_int) -> *mut mbuf;
}
extern "C" {
    pub fn m_getjcl(arg1: ::kernel::sys::raw::c_int,
                    arg2: ::kernel::sys::raw::c_short,
                    arg3: ::kernel::sys::raw::c_int,
                    arg4: ::kernel::sys::raw::c_int) -> *mut mbuf;
}
extern "C" {
    pub fn m_getm2(arg1: *mut mbuf, arg2: ::kernel::sys::raw::c_int,
                   arg3: ::kernel::sys::raw::c_int,
                   arg4: ::kernel::sys::raw::c_short,
                   arg5: ::kernel::sys::raw::c_int) -> *mut mbuf;
}
extern "C" {
    pub fn m_getptr(arg1: *mut mbuf, arg2: ::kernel::sys::raw::c_int,
                    arg3: *mut ::kernel::sys::raw::c_int) -> *mut mbuf;
}
extern "C" {
    pub fn m_length(arg1: *mut mbuf, arg2: *mut *mut mbuf) -> u_int;
}
extern "C" {
    pub fn m_mbuftouio(arg1: *mut uio, arg2: *const mbuf,
                       arg3: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn m_move_pkthdr(arg1: *mut mbuf, arg2: *mut mbuf);
}
extern "C" {
    pub fn m_pkthdr_init(arg1: *mut mbuf, arg2: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn m_prepend(arg1: *mut mbuf, arg2: ::kernel::sys::raw::c_int,
                     arg3: ::kernel::sys::raw::c_int) -> *mut mbuf;
}
extern "C" {
    pub fn m_print(arg1: *const mbuf, arg2: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn m_pulldown(arg1: *mut mbuf, arg2: ::kernel::sys::raw::c_int,
                      arg3: ::kernel::sys::raw::c_int,
                      arg4: *mut ::kernel::sys::raw::c_int) -> *mut mbuf;
}
extern "C" {
    pub fn m_pullup(arg1: *mut mbuf, arg2: ::kernel::sys::raw::c_int)
     -> *mut mbuf;
}
extern "C" {
    pub fn m_sanity(arg1: *mut mbuf, arg2: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn m_split(arg1: *mut mbuf, arg2: ::kernel::sys::raw::c_int,
                   arg3: ::kernel::sys::raw::c_int) -> *mut mbuf;
}
extern "C" {
    pub fn m_uiotombuf(arg1: *mut uio, arg2: ::kernel::sys::raw::c_int,
                       arg3: ::kernel::sys::raw::c_int,
                       arg4: ::kernel::sys::raw::c_int,
                       arg5: ::kernel::sys::raw::c_int) -> *mut mbuf;
}
extern "C" {
    pub fn m_unshare(arg1: *mut mbuf, arg2: ::kernel::sys::raw::c_int)
     -> *mut mbuf;
}
extern "C" {
    #[link_name = "max_datalen"]
    pub static mut max_datalen: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "max_hdr"]
    pub static mut max_hdr: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "max_linkhdr"]
    pub static mut max_linkhdr: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "max_protohdr"]
    pub static mut max_protohdr: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "nmbclusters"]
    pub static mut nmbclusters: ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn m_tag_alloc(arg1: u_int32_t, arg2: ::kernel::sys::raw::c_int,
                       arg3: ::kernel::sys::raw::c_int,
                       arg4: ::kernel::sys::raw::c_int) -> *mut m_tag;
}
extern "C" {
    pub fn m_tag_delete(arg1: *mut mbuf, arg2: *mut m_tag);
}
extern "C" {
    pub fn m_tag_delete_chain(arg1: *mut mbuf, arg2: *mut m_tag);
}
extern "C" {
    pub fn m_tag_free_default(arg1: *mut m_tag);
}
extern "C" {
    pub fn m_tag_locate(arg1: *mut mbuf, arg2: u_int32_t,
                        arg3: ::kernel::sys::raw::c_int, arg4: *mut m_tag)
     -> *mut m_tag;
}
extern "C" {
    pub fn m_tag_copy(arg1: *mut m_tag, arg2: ::kernel::sys::raw::c_int)
     -> *mut m_tag;
}
extern "C" {
    pub fn m_tag_copy_chain(arg1: *mut mbuf, arg2: *const mbuf,
                            arg3: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn m_tag_delete_nonpersistent(arg1: *mut mbuf);
}
extern "C" {
    pub fn m_ether_tcpip_hash_init() -> u32;
}
extern "C" {
    pub fn m_ether_tcpip_hash(arg1: u32, arg2: *const mbuf, arg3: u32) -> u32;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mbufq {
    pub mq_head: mbufq__bindgen_ty_1,
    pub mq_len: ::kernel::sys::raw::c_int,
    pub mq_maxlen: ::kernel::sys::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mbufq__bindgen_ty_1 {
    pub stqh_first: *mut mbuf,
    pub stqh_last: *mut *mut mbuf,
}
#[test]
fn bindgen_test_layout_mbufq__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<mbufq__bindgen_ty_1>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( mbufq__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<mbufq__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( mbufq__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbufq__bindgen_ty_1 ) ) . stqh_first as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mbufq__bindgen_ty_1 ) ,
                "::" , stringify ! ( stqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbufq__bindgen_ty_1 ) ) . stqh_last as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mbufq__bindgen_ty_1 ) ,
                "::" , stringify ! ( stqh_last ) ));
}
impl Clone for mbufq__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for mbufq__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_mbufq() {
    assert_eq!(::core::mem::size_of::<mbufq>() , 24usize , concat ! (
               "Size of: " , stringify ! ( mbufq ) ));
    assert_eq! (::core::mem::align_of::<mbufq>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( mbufq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbufq ) ) . mq_head as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mbufq ) , "::" ,
                stringify ! ( mq_head ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbufq ) ) . mq_len as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mbufq ) , "::" ,
                stringify ! ( mq_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbufq ) ) . mq_maxlen as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( mbufq ) , "::" ,
                stringify ! ( mq_maxlen ) ));
}
impl Clone for mbufq {
    fn clone(&self) -> Self { *self }
}
impl Default for mbufq {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __va_list_tag {
    pub gp_offset: ::kernel::sys::raw::c_uint,
    pub fp_offset: ::kernel::sys::raw::c_uint,
    pub overflow_arg_area: *mut ::kernel::sys::raw::c_void,
    pub reg_save_area: *mut ::kernel::sys::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(::core::mem::size_of::<__va_list_tag>() , 24usize , concat ! (
               "Size of: " , stringify ! ( __va_list_tag ) ));
    assert_eq! (::core::mem::align_of::<__va_list_tag>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __va_list_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . gp_offset as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( gp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . fp_offset as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( fp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . overflow_arg_area as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( overflow_arg_area ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . reg_save_area as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( reg_save_area ) ));
}
impl Clone for __va_list_tag {
    fn clone(&self) -> Self { *self }
}
impl Default for __va_list_tag {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct witness {
    pub _address: u8,
}
impl Clone for witness {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct lock_list_entry {
    pub _address: u8,
}
impl Clone for lock_list_entry {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct pmap {
    pub _address: u8,
}
impl Clone for pmap {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct amd64tss {
    pub _address: u8,
}
impl Clone for amd64tss {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct user_segment_descriptor {
    pub _address: u8,
}
impl Clone for user_segment_descriptor {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct system_segment_descriptor {
    pub _address: u8,
}
impl Clone for system_segment_descriptor {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct ifnet {
    pub _address: u8,
}
impl Clone for ifnet {
    fn clone(&self) -> Self { *self }
}
