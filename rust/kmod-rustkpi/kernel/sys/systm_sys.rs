/* automatically generated by rust-bindgen */

pub const __GNUCLIKE_ASM: ::kernel::sys::raw::c_uint = 3;
pub const __GNUCLIKE___TYPEOF: ::kernel::sys::raw::c_uint = 1;
pub const __GNUCLIKE___OFFSETOF: ::kernel::sys::raw::c_uint = 1;
pub const __GNUCLIKE___SECTION: ::kernel::sys::raw::c_uint = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: ::kernel::sys::raw::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: ::kernel::sys::raw::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: ::kernel::sys::raw::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: ::kernel::sys::raw::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: ::kernel::sys::raw::c_uint = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: ::kernel::sys::raw::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: ::kernel::sys::raw::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: ::kernel::sys::raw::c_uint = 1;
pub const __CC_SUPPORTS_INLINE: ::kernel::sys::raw::c_uint = 1;
pub const __CC_SUPPORTS___INLINE: ::kernel::sys::raw::c_uint = 1;
pub const __CC_SUPPORTS___INLINE__: ::kernel::sys::raw::c_uint = 1;
pub const __CC_SUPPORTS___FUNC__: ::kernel::sys::raw::c_uint = 1;
pub const __CC_SUPPORTS_WARNING: ::kernel::sys::raw::c_uint = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: ::kernel::sys::raw::c_uint = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: ::kernel::sys::raw::c_uint = 1;
pub const __POSIX_VISIBLE: ::kernel::sys::raw::c_uint = 200809;
pub const __XSI_VISIBLE: ::kernel::sys::raw::c_uint = 700;
pub const __BSD_VISIBLE: ::kernel::sys::raw::c_uint = 1;
pub const __ISO_C_VISIBLE: ::kernel::sys::raw::c_uint = 2011;
pub const __EXT1_VISIBLE: ::kernel::sys::raw::c_uint = 1;
pub const __CHAR_BIT: ::kernel::sys::raw::c_uint = 8;
pub const __SCHAR_MAX: ::kernel::sys::raw::c_uint = 127;
pub const __SCHAR_MIN: ::kernel::sys::raw::c_int = -128;
pub const __UCHAR_MAX: ::kernel::sys::raw::c_uint = 255;
pub const __USHRT_MAX: ::kernel::sys::raw::c_uint = 65535;
pub const __SHRT_MAX: ::kernel::sys::raw::c_uint = 32767;
pub const __SHRT_MIN: ::kernel::sys::raw::c_int = -32768;
pub const __UINT_MAX: ::kernel::sys::raw::c_uint = 4294967295;
pub const __INT_MAX: ::kernel::sys::raw::c_uint = 2147483647;
pub const __INT_MIN: ::kernel::sys::raw::c_int = -2147483648;
pub const __ULONG_MAX: ::kernel::sys::raw::c_int = -1;
pub const __LONG_MAX: ::kernel::sys::raw::c_ulonglong = 9223372036854775807;
pub const __LONG_MIN: ::kernel::sys::raw::c_longlong = -9223372036854775808;
pub const __ULLONG_MAX: ::kernel::sys::raw::c_int = -1;
pub const __LLONG_MAX: ::kernel::sys::raw::c_ulonglong = 9223372036854775807;
pub const __LLONG_MIN: ::kernel::sys::raw::c_longlong = -9223372036854775808;
pub const __SSIZE_MAX: ::kernel::sys::raw::c_ulonglong = 9223372036854775807;
pub const __SIZE_T_MAX: ::kernel::sys::raw::c_int = -1;
pub const __OFF_MAX: ::kernel::sys::raw::c_ulonglong = 9223372036854775807;
pub const __OFF_MIN: ::kernel::sys::raw::c_longlong = -9223372036854775808;
pub const __UQUAD_MAX: ::kernel::sys::raw::c_int = -1;
pub const __QUAD_MAX: ::kernel::sys::raw::c_ulonglong = 9223372036854775807;
pub const __QUAD_MIN: ::kernel::sys::raw::c_longlong = -9223372036854775808;
pub const __LONG_BIT: ::kernel::sys::raw::c_uint = 64;
pub const __WORD_BIT: ::kernel::sys::raw::c_uint = 32;
pub const __MINSIGSTKSZ: ::kernel::sys::raw::c_uint = 2048;
pub const __WCHAR_MIN: ::kernel::sys::raw::c_int = -2147483648;
pub const __WCHAR_MAX: ::kernel::sys::raw::c_uint = 2147483647;
pub const _QUAD_HIGHWORD: ::kernel::sys::raw::c_uint = 1;
pub const _QUAD_LOWWORD: ::kernel::sys::raw::c_uint = 0;
pub const _LITTLE_ENDIAN: ::kernel::sys::raw::c_uint = 1234;
pub const _BIG_ENDIAN: ::kernel::sys::raw::c_uint = 4321;
pub const _PDP_ENDIAN: ::kernel::sys::raw::c_uint = 3412;
pub const _BYTE_ORDER: ::kernel::sys::raw::c_uint = 1234;
pub const LITTLE_ENDIAN: ::kernel::sys::raw::c_uint = 1234;
pub const BIG_ENDIAN: ::kernel::sys::raw::c_uint = 4321;
pub const PDP_ENDIAN: ::kernel::sys::raw::c_uint = 3412;
pub const BYTE_ORDER: ::kernel::sys::raw::c_uint = 1234;
pub const __bool_true_false_are_defined: ::kernel::sys::raw::c_uint = 1;
pub const false_: ::kernel::sys::raw::c_uint = 0;
pub const true_: ::kernel::sys::raw::c_uint = 1;
pub const _SIG_WORDS: ::kernel::sys::raw::c_uint = 4;
pub const _SIG_MAXSIG: ::kernel::sys::raw::c_uint = 128;
pub const FD_SETSIZE: ::kernel::sys::raw::c_uint = 1024;
pub const CR4_PGE: ::kernel::sys::raw::c_uint = 128;
pub const INVPCID_ADDR: ::kernel::sys::raw::c_uint = 0;
pub const INVPCID_CTX: ::kernel::sys::raw::c_uint = 1;
pub const INVPCID_CTXGLOB: ::kernel::sys::raw::c_uint = 2;
pub const INVPCID_ALLCTX: ::kernel::sys::raw::c_uint = 3;
pub const MSR_FSBASE: ::kernel::sys::raw::c_uint = 3221225728;
pub const MSR_GSBASE: ::kernel::sys::raw::c_uint = 3221225729;
pub const CALLOUT_LOCAL_ALLOC: ::kernel::sys::raw::c_uint = 1;
pub const CALLOUT_ACTIVE: ::kernel::sys::raw::c_uint = 2;
pub const CALLOUT_PENDING: ::kernel::sys::raw::c_uint = 4;
pub const CALLOUT_MPSAFE: ::kernel::sys::raw::c_uint = 8;
pub const CALLOUT_RETURNUNLOCKED: ::kernel::sys::raw::c_uint = 16;
pub const CALLOUT_SHAREDLOCK: ::kernel::sys::raw::c_uint = 32;
pub const CALLOUT_DFRMIGRATION: ::kernel::sys::raw::c_uint = 64;
pub const CALLOUT_PROCESSED: ::kernel::sys::raw::c_uint = 128;
pub const CALLOUT_DIRECT: ::kernel::sys::raw::c_uint = 256;
pub const C_DIRECT_EXEC: ::kernel::sys::raw::c_uint = 1;
pub const C_PRELBITS: ::kernel::sys::raw::c_uint = 7;
pub const C_PRELRANGE: ::kernel::sys::raw::c_uint = 127;
pub const C_HARDCLOCK: ::kernel::sys::raw::c_uint = 256;
pub const C_ABSOLUTE: ::kernel::sys::raw::c_uint = 512;
pub const C_PRECALC: ::kernel::sys::raw::c_uint = 1024;
pub const C_CATCH: ::kernel::sys::raw::c_uint = 2048;
pub const CS_DRAIN: ::kernel::sys::raw::c_uint = 1;
pub const CS_EXECUTING: ::kernel::sys::raw::c_uint = 2;
pub const INT8_MIN: ::kernel::sys::raw::c_int = -128;
pub const INT16_MIN: ::kernel::sys::raw::c_int = -32768;
pub const INT32_MIN: ::kernel::sys::raw::c_int = -2147483648;
pub const INT8_MAX: ::kernel::sys::raw::c_uint = 127;
pub const INT16_MAX: ::kernel::sys::raw::c_uint = 32767;
pub const INT32_MAX: ::kernel::sys::raw::c_uint = 2147483647;
pub const UINT8_MAX: ::kernel::sys::raw::c_uint = 255;
pub const UINT16_MAX: ::kernel::sys::raw::c_uint = 65535;
pub const UINT32_MAX: ::kernel::sys::raw::c_uint = 4294967295;
pub const INT64_MIN: ::kernel::sys::raw::c_longlong = -9223372036854775808;
pub const INT64_MAX: ::kernel::sys::raw::c_ulonglong = 9223372036854775807;
pub const UINT64_MAX: ::kernel::sys::raw::c_int = -1;
pub const INT_LEAST8_MIN: ::kernel::sys::raw::c_int = -128;
pub const INT_LEAST16_MIN: ::kernel::sys::raw::c_int = -32768;
pub const INT_LEAST32_MIN: ::kernel::sys::raw::c_int = -2147483648;
pub const INT_LEAST64_MIN: ::kernel::sys::raw::c_longlong =
    -9223372036854775808;
pub const INT_LEAST8_MAX: ::kernel::sys::raw::c_uint = 127;
pub const INT_LEAST16_MAX: ::kernel::sys::raw::c_uint = 32767;
pub const INT_LEAST32_MAX: ::kernel::sys::raw::c_uint = 2147483647;
pub const INT_LEAST64_MAX: ::kernel::sys::raw::c_ulonglong =
    9223372036854775807;
pub const UINT_LEAST8_MAX: ::kernel::sys::raw::c_uint = 255;
pub const UINT_LEAST16_MAX: ::kernel::sys::raw::c_uint = 65535;
pub const UINT_LEAST32_MAX: ::kernel::sys::raw::c_uint = 4294967295;
pub const UINT_LEAST64_MAX: ::kernel::sys::raw::c_int = -1;
pub const INT_FAST8_MIN: ::kernel::sys::raw::c_int = -2147483648;
pub const INT_FAST16_MIN: ::kernel::sys::raw::c_int = -2147483648;
pub const INT_FAST32_MIN: ::kernel::sys::raw::c_int = -2147483648;
pub const INT_FAST64_MIN: ::kernel::sys::raw::c_longlong =
    -9223372036854775808;
pub const INT_FAST8_MAX: ::kernel::sys::raw::c_uint = 2147483647;
pub const INT_FAST16_MAX: ::kernel::sys::raw::c_uint = 2147483647;
pub const INT_FAST32_MAX: ::kernel::sys::raw::c_uint = 2147483647;
pub const INT_FAST64_MAX: ::kernel::sys::raw::c_ulonglong =
    9223372036854775807;
pub const UINT_FAST8_MAX: ::kernel::sys::raw::c_uint = 4294967295;
pub const UINT_FAST16_MAX: ::kernel::sys::raw::c_uint = 4294967295;
pub const UINT_FAST32_MAX: ::kernel::sys::raw::c_uint = 4294967295;
pub const UINT_FAST64_MAX: ::kernel::sys::raw::c_int = -1;
pub const INTPTR_MIN: ::kernel::sys::raw::c_longlong = -9223372036854775808;
pub const INTPTR_MAX: ::kernel::sys::raw::c_ulonglong = 9223372036854775807;
pub const UINTPTR_MAX: ::kernel::sys::raw::c_int = -1;
pub const INTMAX_MIN: ::kernel::sys::raw::c_longlong = -9223372036854775808;
pub const INTMAX_MAX: ::kernel::sys::raw::c_ulonglong = 9223372036854775807;
pub const UINTMAX_MAX: ::kernel::sys::raw::c_int = -1;
pub const PTRDIFF_MIN: ::kernel::sys::raw::c_longlong = -9223372036854775808;
pub const PTRDIFF_MAX: ::kernel::sys::raw::c_ulonglong = 9223372036854775807;
pub const SIG_ATOMIC_MIN: ::kernel::sys::raw::c_longlong =
    -9223372036854775808;
pub const SIG_ATOMIC_MAX: ::kernel::sys::raw::c_ulonglong =
    9223372036854775807;
pub const SIZE_MAX: ::kernel::sys::raw::c_int = -1;
pub const WINT_MIN: ::kernel::sys::raw::c_int = -2147483648;
pub const WINT_MAX: ::kernel::sys::raw::c_uint = 2147483647;
pub const __WORDSIZE: ::kernel::sys::raw::c_uint = 64;
pub const WCHAR_MIN: ::kernel::sys::raw::c_int = -2147483648;
pub const WCHAR_MAX: ::kernel::sys::raw::c_uint = 2147483647;
pub const RSIZE_MAX: ::kernel::sys::raw::c_int = -1;
pub const HASH_NOWAIT: ::kernel::sys::raw::c_uint = 1;
pub const HASH_WAITOK: ::kernel::sys::raw::c_uint = 2;
pub const HD_COLUMN_MASK: ::kernel::sys::raw::c_uint = 255;
pub const HD_DELIM_MASK: ::kernel::sys::raw::c_uint = 65280;
pub const HD_OMIT_COUNT: ::kernel::sys::raw::c_uint = 65536;
pub const HD_OMIT_HEX: ::kernel::sys::raw::c_uint = 131072;
pub const HD_OMIT_CHARS: ::kernel::sys::raw::c_uint = 262144;
pub const LIBKERN_LEN_BCD2BIN: ::kernel::sys::raw::c_uint = 154;
pub const LIBKERN_LEN_BIN2BCD: ::kernel::sys::raw::c_uint = 100;
pub const LIBKERN_LEN_HEX2ASCII: ::kernel::sys::raw::c_uint = 36;
pub const ARC4_ENTR_NONE: ::kernel::sys::raw::c_uint = 0;
pub const ARC4_ENTR_HAVE: ::kernel::sys::raw::c_uint = 1;
pub const ARC4_ENTR_SEED: ::kernel::sys::raw::c_uint = 2;
pub const FNM_NOMATCH: ::kernel::sys::raw::c_uint = 1;
pub const FNM_NOESCAPE: ::kernel::sys::raw::c_uint = 1;
pub const FNM_PATHNAME: ::kernel::sys::raw::c_uint = 2;
pub const FNM_PERIOD: ::kernel::sys::raw::c_uint = 4;
pub const FNM_LEADING_DIR: ::kernel::sys::raw::c_uint = 8;
pub const FNM_CASEFOLD: ::kernel::sys::raw::c_uint = 16;
pub const FNM_IGNORECASE: ::kernel::sys::raw::c_uint = 16;
pub const FNM_FILE_NAME: ::kernel::sys::raw::c_uint = 2;
pub type __int8_t = ::kernel::sys::raw::c_schar;
pub type __uint8_t = ::kernel::sys::raw::c_uchar;
pub type __int16_t = ::kernel::sys::raw::c_short;
pub type __uint16_t = ::kernel::sys::raw::c_ushort;
pub type __int32_t = ::kernel::sys::raw::c_int;
pub type __uint32_t = ::kernel::sys::raw::c_uint;
pub type __int64_t = ::kernel::sys::raw::c_long;
pub type __uint64_t = ::kernel::sys::raw::c_ulong;
pub type __clock_t = __int32_t;
pub type __critical_t = __int64_t;
pub type __double_t = f64;
pub type __float_t = f32;
pub type __intfptr_t = __int64_t;
pub type __intptr_t = __int64_t;
pub type __intmax_t = __int64_t;
pub type __int_fast8_t = __int32_t;
pub type __int_fast16_t = __int32_t;
pub type __int_fast32_t = __int32_t;
pub type __int_fast64_t = __int64_t;
pub type __int_least8_t = __int8_t;
pub type __int_least16_t = __int16_t;
pub type __int_least32_t = __int32_t;
pub type __int_least64_t = __int64_t;
pub type __ptrdiff_t = __int64_t;
pub type __register_t = __int64_t;
pub type __segsz_t = __int64_t;
pub type __size_t = __uint64_t;
pub type __ssize_t = __int64_t;
pub type __time_t = __int64_t;
pub type __uintfptr_t = __uint64_t;
pub type __uintptr_t = __uint64_t;
pub type __uintmax_t = __uint64_t;
pub type __uint_fast8_t = __uint32_t;
pub type __uint_fast16_t = __uint32_t;
pub type __uint_fast32_t = __uint32_t;
pub type __uint_fast64_t = __uint64_t;
pub type __uint_least8_t = __uint8_t;
pub type __uint_least16_t = __uint16_t;
pub type __uint_least32_t = __uint32_t;
pub type __uint_least64_t = __uint64_t;
pub type __u_register_t = __uint64_t;
pub type __vm_offset_t = __uint64_t;
pub type __vm_paddr_t = __uint64_t;
pub type __vm_size_t = __uint64_t;
pub type ___wchar_t = ::kernel::sys::raw::c_int;
pub type __blksize_t = __int32_t;
pub type __blkcnt_t = __int64_t;
pub type __clockid_t = __int32_t;
pub type __fflags_t = __uint32_t;
pub type __fsblkcnt_t = __uint64_t;
pub type __fsfilcnt_t = __uint64_t;
pub type __gid_t = __uint32_t;
pub type __id_t = __int64_t;
pub type __ino_t = __uint64_t;
pub type __key_t = ::kernel::sys::raw::c_long;
pub type __lwpid_t = __int32_t;
pub type __mode_t = __uint16_t;
pub type __accmode_t = ::kernel::sys::raw::c_int;
pub type __nl_item = ::kernel::sys::raw::c_int;
pub type __nlink_t = __uint64_t;
pub type __off_t = __int64_t;
pub type __off64_t = __int64_t;
pub type __pid_t = __int32_t;
pub type __rlim_t = __int64_t;
pub type __sa_family_t = __uint8_t;
pub type __socklen_t = __uint32_t;
pub type __suseconds_t = ::kernel::sys::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __timer {
    _unused: [u8; 0],
}
pub type __timer_t = *mut __timer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __mq {
    _unused: [u8; 0],
}
pub type __mqd_t = *mut __mq;
pub type __uid_t = __uint32_t;
pub type __useconds_t = ::kernel::sys::raw::c_uint;
pub type __cpuwhich_t = ::kernel::sys::raw::c_int;
pub type __cpulevel_t = ::kernel::sys::raw::c_int;
pub type __cpusetid_t = ::kernel::sys::raw::c_int;
pub type __ct_rune_t = ::kernel::sys::raw::c_int;
pub type __rune_t = __ct_rune_t;
pub type __wint_t = __ct_rune_t;
pub type __char16_t = __uint_least16_t;
pub type __char32_t = __uint_least32_t;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct __max_align_t {
    pub __max_align1: ::kernel::sys::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __max_align2: f64,
}
#[test]
fn bindgen_test_layout___max_align_t() {
    assert_eq!(::core::mem::size_of::<__max_align_t>() , 32usize , concat ! (
               "Size of: " , stringify ! ( __max_align_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __max_align_t ) ) . __max_align1 as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __max_align_t ) , "::"
                , stringify ! ( __max_align1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __max_align_t ) ) . __max_align2 as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __max_align_t ) , "::"
                , stringify ! ( __max_align2 ) ));
}
impl Clone for __max_align_t {
    fn clone(&self) -> Self { *self }
}
pub type __dev_t = __uint64_t;
pub type __fixpt_t = __uint32_t;
#[repr(C)]
#[derive(Copy)]
pub union __mbstate_t {
    pub __mbstate8: [::kernel::sys::raw::c_char; 128usize],
    pub _mbstateL: __int64_t,
    _bindgen_union_align: [u64; 16usize],
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(::core::mem::size_of::<__mbstate_t>() , 128usize , concat ! (
               "Size of: " , stringify ! ( __mbstate_t ) ));
    assert_eq! (::core::mem::align_of::<__mbstate_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __mbstate_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . __mbstate8 as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( __mbstate8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . _mbstateL as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( _mbstateL ) ));
}
impl Clone for __mbstate_t {
    fn clone(&self) -> Self { *self }
}
impl Default for __mbstate_t {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for __mbstate_t {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "__mbstate_t {{ union }}")
    }
}
pub type __rman_res_t = __uintmax_t;
pub type __va_list = __builtin_va_list;
pub type __gnuc_va_list = __va_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_cond {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_cond_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutex {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutex_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_once {
    pub state: ::kernel::sys::raw::c_int,
    pub mutex: pthread_mutex_t,
}
#[test]
fn bindgen_test_layout_pthread_once() {
    assert_eq!(::core::mem::size_of::<pthread_once>() , 16usize , concat ! (
               "Size of: " , stringify ! ( pthread_once ) ));
    assert_eq! (::core::mem::align_of::<pthread_once>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_once ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_once ) ) . state as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_once ) , "::" ,
                stringify ! ( state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_once ) ) . mutex as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_once ) , "::" ,
                stringify ! ( mutex ) ));
}
impl Clone for pthread_once {
    fn clone(&self) -> Self { *self }
}
impl Default for pthread_once {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_rwlock {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_rwlockattr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_barrier {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_barrier_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_spinlock {
    _unused: [u8; 0],
}
pub type pthread_t = *mut pthread;
pub type pthread_attr_t = *mut pthread_attr;
pub type pthread_mutex_t = *mut pthread_mutex;
pub type pthread_mutexattr_t = *mut pthread_mutex_attr;
pub type pthread_cond_t = *mut pthread_cond;
pub type pthread_condattr_t = *mut pthread_cond_attr;
pub type pthread_key_t = ::kernel::sys::raw::c_int;
pub type pthread_once_t = pthread_once;
pub type pthread_rwlock_t = *mut pthread_rwlock;
pub type pthread_rwlockattr_t = *mut pthread_rwlockattr;
pub type pthread_barrier_t = *mut pthread_barrier;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_barrierattr {
    _unused: [u8; 0],
}
pub type pthread_barrierattr_t = *mut pthread_barrierattr;
pub type pthread_spinlock_t = *mut pthread_spinlock;
pub type pthread_addr_t = *mut ::kernel::sys::raw::c_void;
pub type pthread_startroutine_t =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void)
                               -> *mut ::kernel::sys::raw::c_void>;
pub type u_char = ::kernel::sys::raw::c_uchar;
pub type u_short = ::kernel::sys::raw::c_ushort;
pub type u_int = ::kernel::sys::raw::c_uint;
pub type u_long = ::kernel::sys::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type u_quad_t = __uint64_t;
pub type quad_t = __int64_t;
pub type qaddr_t = *mut quad_t;
pub type caddr_t = *mut ::kernel::sys::raw::c_char;
pub type c_caddr_t = *const ::kernel::sys::raw::c_char;
pub type blksize_t = __blksize_t;
pub type cpuwhich_t = __cpuwhich_t;
pub type cpulevel_t = __cpulevel_t;
pub type cpusetid_t = __cpusetid_t;
pub type blkcnt_t = __blkcnt_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type critical_t = __critical_t;
pub type daddr_t = __int64_t;
pub type dev_t = __dev_t;
pub type fflags_t = __fflags_t;
pub type fixpt_t = __fixpt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type gid_t = __gid_t;
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type id_t = __id_t;
pub type ino_t = __ino_t;
pub type key_t = __key_t;
pub type lwpid_t = __lwpid_t;
pub type mode_t = __mode_t;
pub type accmode_t = __accmode_t;
pub type nlink_t = __nlink_t;
pub type off_t = __off_t;
pub type off64_t = __off64_t;
pub type pid_t = __pid_t;
pub type register_t = __register_t;
pub type rlim_t = __rlim_t;
pub type sbintime_t = __int64_t;
pub type segsz_t = __segsz_t;
pub type suseconds_t = __suseconds_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type mqd_t = __mqd_t;
pub type u_register_t = __u_register_t;
pub type uid_t = __uid_t;
pub type useconds_t = __useconds_t;
pub type cap_ioctl_t = ::kernel::sys::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cap_rights {
    _unused: [u8; 0],
}
pub type cap_rights_t = cap_rights;
pub type vm_offset_t = __vm_offset_t;
pub type vm_ooffset_t = __int64_t;
pub type vm_paddr_t = __vm_paddr_t;
pub type vm_pindex_t = __uint64_t;
pub type vm_size_t = __vm_size_t;
pub type rman_res_t = __rman_res_t;
pub type boolean_t = ::kernel::sys::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct device {
    _unused: [u8; 0],
}
pub type device_t = *mut device;
pub type intfptr_t = __intfptr_t;
pub type intrmask_t = __uint32_t;
pub type uintfptr_t = __uintfptr_t;
pub type uoff_t = __uint64_t;
pub type vm_memattr_t = ::kernel::sys::raw::c_char;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_page {
    _unused: [u8; 0],
}
pub type vm_page_t = *mut vm_page;
pub type bool_ = bool;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct __sigset {
    pub __bits: [__uint32_t; 4usize],
}
#[test]
fn bindgen_test_layout___sigset() {
    assert_eq!(::core::mem::size_of::<__sigset>() , 16usize , concat ! (
               "Size of: " , stringify ! ( __sigset ) ));
    assert_eq! (::core::mem::align_of::<__sigset>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( __sigset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sigset ) ) . __bits as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sigset ) , "::" ,
                stringify ! ( __bits ) ));
}
impl Clone for __sigset {
    fn clone(&self) -> Self { *self }
}
pub type __sigset_t = __sigset;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct timeval {
    pub tv_sec: time_t,
    pub tv_usec: suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(::core::mem::size_of::<timeval>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timeval ) ));
    assert_eq! (::core::mem::align_of::<timeval>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timeval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_usec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_usec ) ));
}
impl Clone for timeval {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: ::kernel::sys::raw::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(::core::mem::size_of::<timespec>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timespec ) ));
    assert_eq! (::core::mem::align_of::<timespec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timespec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_nsec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_nsec ) ));
}
impl Clone for timespec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(::core::mem::size_of::<itimerspec>() , 32usize , concat ! (
               "Size of: " , stringify ! ( itimerspec ) ));
    assert_eq! (::core::mem::align_of::<itimerspec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( itimerspec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerspec ) ) . it_interval as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerspec ) , "::" ,
                stringify ! ( it_interval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerspec ) ) . it_value as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerspec ) , "::" ,
                stringify ! ( it_value ) ));
}
impl Clone for itimerspec {
    fn clone(&self) -> Self { *self }
}
pub type __fd_mask = ::kernel::sys::raw::c_ulong;
pub type fd_mask = __fd_mask;
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(::core::mem::size_of::<fd_set>() , 128usize , concat ! (
               "Size of: " , stringify ! ( fd_set ) ));
    assert_eq! (::core::mem::align_of::<fd_set>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( fd_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fd_set ) ) . __fds_bits as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( fd_set ) , "::" ,
                stringify ! ( __fds_bits ) ));
}
impl Clone for fd_set {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn atomic_cmpset_char(dst: *mut u_char, expect: u_char, src: u_char)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn atomic_cmpset_short(dst: *mut u_short, expect: u_short,
                               src: u_short) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn atomic_cmpset_int(dst: *mut u_int, expect: u_int, src: u_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn atomic_cmpset_long(dst: *mut u_long, expect: u_long, src: u_long)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn atomic_fcmpset_char(dst: *mut u_char, expect: *mut u_char,
                               src: u_char) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn atomic_fcmpset_short(dst: *mut u_short, expect: *mut u_short,
                                src: u_short) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn atomic_fcmpset_int(dst: *mut u_int, expect: *mut u_int, src: u_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn atomic_fcmpset_long(dst: *mut u_long, expect: *mut u_long,
                               src: u_long) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn atomic_fetchadd_int(p: *mut u_int, v: u_int) -> u_int;
}
extern "C" {
    pub fn atomic_fetchadd_long(p: *mut u_long, v: u_long) -> u_long;
}
extern "C" {
    pub fn atomic_testandset_int(p: *mut u_int, v: u_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn atomic_testandset_long(p: *mut u_long, v: u_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn atomic_testandclear_int(p: *mut u_int, v: u_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn atomic_testandclear_long(p: *mut u_long, v: u_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn atomic_thread_fence_acq();
}
extern "C" {
    pub fn atomic_thread_fence_acq_rel();
}
extern "C" {
    pub fn atomic_thread_fence_rel();
}
extern "C" {
    pub fn atomic_thread_fence_seq_cst();
}
extern "C" {
    pub fn atomic_set_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_set_barr_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_clear_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_clear_barr_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_add_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_add_barr_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_subtract_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_subtract_barr_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_set_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_set_barr_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_clear_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_clear_barr_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_add_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_add_barr_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_subtract_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_subtract_barr_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_set_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_set_barr_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_clear_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_clear_barr_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_add_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_add_barr_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_subtract_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_subtract_barr_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_set_long(p: *mut u_long, v: u_long);
}
extern "C" {
    pub fn atomic_set_barr_long(p: *mut u_long, v: u_long);
}
extern "C" {
    pub fn atomic_clear_long(p: *mut u_long, v: u_long);
}
extern "C" {
    pub fn atomic_clear_barr_long(p: *mut u_long, v: u_long);
}
extern "C" {
    pub fn atomic_add_long(p: *mut u_long, v: u_long);
}
extern "C" {
    pub fn atomic_add_barr_long(p: *mut u_long, v: u_long);
}
extern "C" {
    pub fn atomic_subtract_long(p: *mut u_long, v: u_long);
}
extern "C" {
    pub fn atomic_subtract_barr_long(p: *mut u_long, v: u_long);
}
extern "C" {
    pub fn atomic_load_acq_char(p: *mut u_char) -> u_char;
}
extern "C" {
    pub fn atomic_store_rel_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_load_acq_short(p: *mut u_short) -> u_short;
}
extern "C" {
    pub fn atomic_store_rel_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_load_acq_int(p: *mut u_int) -> u_int;
}
extern "C" {
    pub fn atomic_store_rel_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_load_acq_long(p: *mut u_long) -> u_long;
}
extern "C" {
    pub fn atomic_store_rel_long(p: *mut u_long, v: u_long);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct region_descriptor {
    _unused: [u8; 0],
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy)]
pub struct invpcid_descr {
    pub _bitfield_1: u64,
    pub addr: u64,
}
#[test]
fn bindgen_test_layout_invpcid_descr() {
    assert_eq!(::core::mem::size_of::<invpcid_descr>() , 16usize , concat ! (
               "Size of: " , stringify ! ( invpcid_descr ) ));
    assert_eq! (::core::mem::align_of::<invpcid_descr>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( invpcid_descr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const invpcid_descr ) ) . addr as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( invpcid_descr ) , "::"
                , stringify ! ( addr ) ));
}
impl Clone for invpcid_descr {
    fn clone(&self) -> Self { *self }
}
impl invpcid_descr {
    #[inline]
    pub fn pcid(&self) -> u64 {
        let mut unit_field_val: u64 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u64
                                                 as *mut u8,
                                             ::core::mem::size_of::<u64>())
        };
        let mask = 4095u64 as u64;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::core::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_pcid(&mut self, val: u64) {
        let mask = 4095u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u64
                                                 as *mut u8,
                                             ::core::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn pad(&self) -> u64 {
        let mut unit_field_val: u64 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u64
                                                 as *mut u8,
                                             ::core::mem::size_of::<u64>())
        };
        let mask = 18446744073709547520u64 as u64;
        let val = (unit_field_val & mask) >> 12usize;
        unsafe { ::core::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_pad(&mut self, val: u64) {
        let mask = 18446744073709547520u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u64
                                                 as *mut u8,
                                             ::core::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 12usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(pcid: u64, pad: u64) -> u64 {
        ({ ({ 0 } | ((pcid as u64 as u64) << 0usize) & (4095u64 as u64)) } |
             ((pad as u64 as u64) << 12usize) &
                 (18446744073709547520u64 as u64))
    }
}
pub const SGX_ECREATE: _bindgen_ty_1 = _bindgen_ty_1::SGX_ECREATE;
pub const SGX_EADD: _bindgen_ty_1 = _bindgen_ty_1::SGX_EADD;
pub const SGX_EINIT: _bindgen_ty_1 = _bindgen_ty_1::SGX_EINIT;
pub const SGX_EREMOVE: _bindgen_ty_1 = _bindgen_ty_1::SGX_EREMOVE;
pub const SGX_EDGBRD: _bindgen_ty_1 = _bindgen_ty_1::SGX_EDGBRD;
pub const SGX_EDGBWR: _bindgen_ty_1 = _bindgen_ty_1::SGX_EDGBWR;
pub const SGX_EEXTEND: _bindgen_ty_1 = _bindgen_ty_1::SGX_EEXTEND;
pub const SGX_ELDU: _bindgen_ty_1 = _bindgen_ty_1::SGX_ELDU;
pub const SGX_EBLOCK: _bindgen_ty_1 = _bindgen_ty_1::SGX_EBLOCK;
pub const SGX_EPA: _bindgen_ty_1 = _bindgen_ty_1::SGX_EPA;
pub const SGX_EWB: _bindgen_ty_1 = _bindgen_ty_1::SGX_EWB;
pub const SGX_ETRACK: _bindgen_ty_1 = _bindgen_ty_1::SGX_ETRACK;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_1 {
    SGX_ECREATE = 0,
    SGX_EADD = 1,
    SGX_EINIT = 2,
    SGX_EREMOVE = 3,
    SGX_EDGBRD = 4,
    SGX_EDGBWR = 5,
    SGX_EEXTEND = 6,
    SGX_ELDU = 8,
    SGX_EBLOCK = 9,
    SGX_EPA = 10,
    SGX_EWB = 11,
    SGX_ETRACK = 12,
}
pub const SGX_PT_SECS: _bindgen_ty_2 = _bindgen_ty_2::SGX_PT_SECS;
pub const SGX_PT_TCS: _bindgen_ty_2 = _bindgen_ty_2::SGX_PT_TCS;
pub const SGX_PT_REG: _bindgen_ty_2 = _bindgen_ty_2::SGX_PT_REG;
pub const SGX_PT_VA: _bindgen_ty_2 = _bindgen_ty_2::SGX_PT_VA;
pub const SGX_PT_TRIM: _bindgen_ty_2 = _bindgen_ty_2::SGX_PT_TRIM;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_2 {
    SGX_PT_SECS = 0,
    SGX_PT_TCS = 1,
    SGX_PT_REG = 2,
    SGX_PT_VA = 3,
    SGX_PT_TRIM = 4,
}
extern "C" {
    pub fn sgx_encls(eax: u32, rbx: u64, rcx: u64, rdx: u64)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn reset_dbregs();
}
extern "C" {
    pub fn rdmsr_safe(msr: u_int, val: *mut u64) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn wrmsr_safe(msr: u_int, newval: u64) -> ::kernel::sys::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lock_object {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct callout_list {
    pub lh_first: *mut callout,
}
#[test]
fn bindgen_test_layout_callout_list() {
    assert_eq!(::core::mem::size_of::<callout_list>() , 8usize , concat ! (
               "Size of: " , stringify ! ( callout_list ) ));
    assert_eq! (::core::mem::align_of::<callout_list>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( callout_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout_list ) ) . lh_first as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( callout_list ) , "::" ,
                stringify ! ( lh_first ) ));
}
impl Clone for callout_list {
    fn clone(&self) -> Self { *self }
}
impl Default for callout_list {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct callout_slist {
    pub slh_first: *mut callout,
}
#[test]
fn bindgen_test_layout_callout_slist() {
    assert_eq!(::core::mem::size_of::<callout_slist>() , 8usize , concat ! (
               "Size of: " , stringify ! ( callout_slist ) ));
    assert_eq! (::core::mem::align_of::<callout_slist>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( callout_slist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout_slist ) ) . slh_first as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( callout_slist ) , "::"
                , stringify ! ( slh_first ) ));
}
impl Clone for callout_slist {
    fn clone(&self) -> Self { *self }
}
impl Default for callout_slist {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct callout_tailq {
    pub tqh_first: *mut callout,
    pub tqh_last: *mut *mut callout,
}
#[test]
fn bindgen_test_layout_callout_tailq() {
    assert_eq!(::core::mem::size_of::<callout_tailq>() , 16usize , concat ! (
               "Size of: " , stringify ! ( callout_tailq ) ));
    assert_eq! (::core::mem::align_of::<callout_tailq>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( callout_tailq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout_tailq ) ) . tqh_first as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( callout_tailq ) , "::"
                , stringify ! ( tqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout_tailq ) ) . tqh_last as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( callout_tailq ) , "::"
                , stringify ! ( tqh_last ) ));
}
impl Clone for callout_tailq {
    fn clone(&self) -> Self { *self }
}
impl Default for callout_tailq {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct callout {
    pub c_links: callout__bindgen_ty_1,
    pub c_time: sbintime_t,
    pub c_precision: sbintime_t,
    pub c_arg: *mut ::kernel::sys::raw::c_void,
    pub c_func: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                *mut ::kernel::sys::raw::c_void)>,
    pub c_lock: *mut lock_object,
    pub c_flags: ::kernel::sys::raw::c_short,
    pub c_iflags: ::kernel::sys::raw::c_short,
    pub c_cpu: ::kernel::sys::raw::c_int,
}
#[repr(C)]
#[derive(Copy)]
pub union callout__bindgen_ty_1 {
    pub le: callout__bindgen_ty_1__bindgen_ty_1,
    pub sle: callout__bindgen_ty_1__bindgen_ty_2,
    pub tqe: callout__bindgen_ty_1__bindgen_ty_3,
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct callout__bindgen_ty_1__bindgen_ty_1 {
    pub le_next: *mut callout,
    pub le_prev: *mut *mut callout,
}
#[test]
fn bindgen_test_layout_callout__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<callout__bindgen_ty_1__bindgen_ty_1>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( callout__bindgen_ty_1__bindgen_ty_1
               ) ));
    assert_eq! (::core::mem::align_of::<callout__bindgen_ty_1__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                callout__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout__bindgen_ty_1__bindgen_ty_1 ) ) .
                le_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                callout__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! (
                le_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout__bindgen_ty_1__bindgen_ty_1 ) ) .
                le_prev as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                callout__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! (
                le_prev ) ));
}
impl Clone for callout__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for callout__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct callout__bindgen_ty_1__bindgen_ty_2 {
    pub sle_next: *mut callout,
}
#[test]
fn bindgen_test_layout_callout__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<callout__bindgen_ty_1__bindgen_ty_2>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( callout__bindgen_ty_1__bindgen_ty_2
               ) ));
    assert_eq! (::core::mem::align_of::<callout__bindgen_ty_1__bindgen_ty_2>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                callout__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout__bindgen_ty_1__bindgen_ty_2 ) ) .
                sle_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                callout__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify ! (
                sle_next ) ));
}
impl Clone for callout__bindgen_ty_1__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for callout__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct callout__bindgen_ty_1__bindgen_ty_3 {
    pub tqe_next: *mut callout,
    pub tqe_prev: *mut *mut callout,
}
#[test]
fn bindgen_test_layout_callout__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(::core::mem::size_of::<callout__bindgen_ty_1__bindgen_ty_3>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( callout__bindgen_ty_1__bindgen_ty_3
               ) ));
    assert_eq! (::core::mem::align_of::<callout__bindgen_ty_1__bindgen_ty_3>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                callout__bindgen_ty_1__bindgen_ty_3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout__bindgen_ty_1__bindgen_ty_3 ) ) .
                tqe_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                callout__bindgen_ty_1__bindgen_ty_3 ) , "::" , stringify ! (
                tqe_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout__bindgen_ty_1__bindgen_ty_3 ) ) .
                tqe_prev as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                callout__bindgen_ty_1__bindgen_ty_3 ) , "::" , stringify ! (
                tqe_prev ) ));
}
impl Clone for callout__bindgen_ty_1__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
impl Default for callout__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_callout__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<callout__bindgen_ty_1>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( callout__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<callout__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( callout__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout__bindgen_ty_1 ) ) . le as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( callout__bindgen_ty_1 )
                , "::" , stringify ! ( le ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout__bindgen_ty_1 ) ) . sle as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( callout__bindgen_ty_1 )
                , "::" , stringify ! ( sle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout__bindgen_ty_1 ) ) . tqe as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( callout__bindgen_ty_1 )
                , "::" , stringify ! ( tqe ) ));
}
impl Clone for callout__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for callout__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for callout__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "callout__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_callout() {
    assert_eq!(::core::mem::size_of::<callout>() , 64usize , concat ! (
               "Size of: " , stringify ! ( callout ) ));
    assert_eq! (::core::mem::align_of::<callout>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( callout ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout ) ) . c_links as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( callout ) , "::" ,
                stringify ! ( c_links ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout ) ) . c_time as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( callout ) , "::" ,
                stringify ! ( c_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout ) ) . c_precision as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( callout ) , "::" ,
                stringify ! ( c_precision ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout ) ) . c_arg as * const _ as usize
                } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( callout ) , "::" ,
                stringify ! ( c_arg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout ) ) . c_func as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( callout ) , "::" ,
                stringify ! ( c_func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout ) ) . c_lock as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( callout ) , "::" ,
                stringify ! ( c_lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout ) ) . c_flags as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( callout ) , "::" ,
                stringify ! ( c_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout ) ) . c_iflags as * const _ as
                usize } , 58usize , concat ! (
                "Alignment of field: " , stringify ! ( callout ) , "::" ,
                stringify ! ( c_iflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout ) ) . c_cpu as * const _ as usize
                } , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( callout ) , "::" ,
                stringify ! ( c_cpu ) ));
}
impl Clone for callout {
    fn clone(&self) -> Self { *self }
}
impl Default for callout {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for callout {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "callout {{ c_links: {:?}, c_time: {:?}, c_precision: {:?}, c_arg: {:?}, c_func: {:?}, c_lock: {:?}, c_flags: {:?}, c_iflags: {:?}, c_cpu: {:?} }}"
               , self . c_links , self . c_time , self . c_precision , self .
               c_arg , self . c_func , self . c_lock , self . c_flags , self .
               c_iflags , self . c_cpu)
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct callout_handle {
    pub callout: *mut callout,
}
#[test]
fn bindgen_test_layout_callout_handle() {
    assert_eq!(::core::mem::size_of::<callout_handle>() , 8usize , concat ! (
               "Size of: " , stringify ! ( callout_handle ) ));
    assert_eq! (::core::mem::align_of::<callout_handle>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( callout_handle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout_handle ) ) . callout as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( callout_handle ) , "::"
                , stringify ! ( callout ) ));
}
impl Clone for callout_handle {
    fn clone(&self) -> Self { *self }
}
impl Default for callout_handle {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    pub fn callout_init(arg1: *mut callout, arg2: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn _callout_init_lock(arg1: *mut callout, arg2: *mut lock_object,
                              arg3: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn callout_reset_sbt_on(arg1: *mut callout, arg2: sbintime_t,
                                arg3: sbintime_t,
                                arg4:
                                    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                                    *mut ::kernel::sys::raw::c_void)>,
                                arg5: *mut ::kernel::sys::raw::c_void,
                                arg6: ::kernel::sys::raw::c_int,
                                arg7: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn callout_schedule(arg1: *mut callout,
                            arg2: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn callout_schedule_on(arg1: *mut callout,
                               arg2: ::kernel::sys::raw::c_int,
                               arg3: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn _callout_stop_safe(arg1: *mut callout,
                              arg2: ::kernel::sys::raw::c_int,
                              arg3:
                                  ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                                  *mut ::kernel::sys::raw::c_void)>)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn callout_process(now: sbintime_t);
}
extern "C" {
    pub fn callout_when(sbt: sbintime_t, precision: sbintime_t,
                        flags: ::kernel::sys::raw::c_int,
                        sbt_res: *mut sbintime_t, prec_res: *mut sbintime_t);
}
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = __int_fast8_t;
pub type int_fast16_t = __int_fast16_t;
pub type int_fast32_t = __int_fast32_t;
pub type int_fast64_t = __int_fast64_t;
pub type uint_fast8_t = __uint_fast8_t;
pub type uint_fast16_t = __uint_fast16_t;
pub type uint_fast32_t = __uint_fast32_t;
pub type uint_fast64_t = __uint_fast64_t;
extern "C" {
    #[link_name = "cold"]
    pub static mut cold: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "suspend_blocked"]
    pub static mut suspend_blocked: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "rebooting"]
    pub static mut rebooting: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "panicstr"]
    pub static mut panicstr: *const ::kernel::sys::raw::c_char;
}
extern "C" {
    #[link_name = "version"]
    pub static mut version: [::kernel::sys::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "compiler_version"]
    pub static mut compiler_version: [::kernel::sys::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "copyright"]
    pub static mut copyright: [::kernel::sys::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "kstack_pages"]
    pub static mut kstack_pages: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "pagesizes"]
    pub static mut pagesizes: [u_long; 0usize];
}
extern "C" {
    #[link_name = "physmem"]
    pub static mut physmem: ::kernel::sys::raw::c_long;
}
extern "C" {
    #[link_name = "realmem"]
    pub static mut realmem: ::kernel::sys::raw::c_long;
}
extern "C" {
    #[link_name = "rootdevnames"]
    pub static mut rootdevnames: [*mut ::kernel::sys::raw::c_char; 2usize];
}
extern "C" {
    #[link_name = "boothowto"]
    pub static mut boothowto: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "bootverbose"]
    pub static mut bootverbose: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "maxusers"]
    pub static mut maxusers: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "ngroups_max"]
    pub static mut ngroups_max: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "vm_guest"]
    pub static mut vm_guest: ::kernel::sys::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VM_GUEST {
    VM_GUEST_NO = 0,
    VM_GUEST_VM = 1,
    VM_GUEST_XEN = 2,
    VM_GUEST_HV = 3,
    VM_GUEST_VMWARE = 4,
    VM_GUEST_KVM = 5,
    VM_GUEST_BHYVE = 6,
    VM_LAST = 7,
}
extern "C" {
    #[link_name = "osreldate"]
    pub static mut osreldate: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "envmode"]
    pub static mut envmode: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "hintmode"]
    pub static mut hintmode: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "dynamic_kenv"]
    pub static mut dynamic_kenv: ::kernel::sys::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mtx {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "kenv_lock"]
    pub static mut kenv_lock: mtx;
}
extern "C" {
    #[link_name = "kern_envp"]
    pub static mut kern_envp: *mut ::kernel::sys::raw::c_char;
}
extern "C" {
    #[link_name = "static_env"]
    pub static mut static_env: [::kernel::sys::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "static_hints"]
    pub static mut static_hints: [::kernel::sys::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "kenvp"]
    pub static mut kenvp: *mut *mut ::kernel::sys::raw::c_char;
}
extern "C" {
    #[link_name = "zero_region"]
    pub static mut zero_region: *const ::kernel::sys::raw::c_void;
}
extern "C" {
    #[link_name = "unmapped_buf_allowed"]
    pub static mut unmapped_buf_allowed: ::kernel::sys::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct inpcb {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct malloc_type {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct proc_ {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct socket {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct thread {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tty {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucred {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uio {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _jmp_buf {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct trapframe {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eventtimer {
    _unused: [u8; 0],
}
extern "C" {
    pub fn setjmp(arg1: *mut _jmp_buf) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn longjmp(arg1: *mut _jmp_buf, arg2: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn dumpstatus(addr: vm_offset_t, count: off_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn nullop() -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn eopnotsupp() -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn ureadc(arg1: ::kernel::sys::raw::c_int, arg2: *mut uio)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn hashdestroy(arg1: *mut ::kernel::sys::raw::c_void,
                       arg2: *mut malloc_type, arg3: u_long);
}
extern "C" {
    pub fn hashinit(count: ::kernel::sys::raw::c_int, type_: *mut malloc_type,
                    hashmask: *mut u_long) -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn hashinit_flags(count: ::kernel::sys::raw::c_int,
                          type_: *mut malloc_type, hashmask: *mut u_long,
                          flags: ::kernel::sys::raw::c_int)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn phashinit(count: ::kernel::sys::raw::c_int,
                     type_: *mut malloc_type, nentries: *mut u_long)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn phashinit_flags(count: ::kernel::sys::raw::c_int,
                           type_: *mut malloc_type, nentries: *mut u_long,
                           flags: ::kernel::sys::raw::c_int)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn g_waitidle();
}
extern "C" {
    pub fn panic(arg1: *const ::kernel::sys::raw::c_char, ...);
}
extern "C" {
    pub fn vpanic(arg1: *const ::kernel::sys::raw::c_char,
                  arg2: *mut __va_list_tag);
}
extern "C" {
    pub fn cpu_boot(arg1: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn cpu_flush_dcache(arg1: *mut ::kernel::sys::raw::c_void,
                            arg2: usize);
}
extern "C" {
    pub fn cpu_rootconf();
}
extern "C" {
    pub fn critical_enter();
}
extern "C" {
    pub fn critical_exit();
}
extern "C" {
    pub fn init_param1();
}
extern "C" {
    pub fn init_param2(physpages: ::kernel::sys::raw::c_long);
}
extern "C" {
    pub fn init_static_kenv(arg1: *mut ::kernel::sys::raw::c_char,
                            arg2: usize);
}
extern "C" {
    pub fn tablefull(arg1: *const ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn kvprintf(arg1: *const ::kernel::sys::raw::c_char,
                    arg2:
                        ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                        ::kernel::sys::raw::c_int,
                                                                    arg2:
                                                                        *mut ::kernel::sys::raw::c_void)>,
                    arg3: *mut ::kernel::sys::raw::c_void,
                    arg4: ::kernel::sys::raw::c_int, arg5: *mut __va_list_tag)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn log(arg1: ::kernel::sys::raw::c_int,
               arg2: *const ::kernel::sys::raw::c_char, ...);
}
extern "C" {
    pub fn log_console(arg1: *mut uio);
}
extern "C" {
    pub fn vlog(arg1: ::kernel::sys::raw::c_int,
                arg2: *const ::kernel::sys::raw::c_char,
                arg3: *mut __va_list_tag);
}
extern "C" {
    pub fn asprintf(ret: *mut *mut ::kernel::sys::raw::c_char,
                    mtp: *mut malloc_type,
                    format: *const ::kernel::sys::raw::c_char, ...)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn printf(arg1: *const ::kernel::sys::raw::c_char, ...)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn snprintf(arg1: *mut ::kernel::sys::raw::c_char, arg2: usize,
                    arg3: *const ::kernel::sys::raw::c_char, ...)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sprintf(buf: *mut ::kernel::sys::raw::c_char,
                   arg1: *const ::kernel::sys::raw::c_char, ...)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn uprintf(arg1: *const ::kernel::sys::raw::c_char, ...)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn vprintf(arg1: *const ::kernel::sys::raw::c_char,
                   arg2: *mut __va_list_tag) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn vasprintf(ret: *mut *mut ::kernel::sys::raw::c_char,
                     mtp: *mut malloc_type,
                     format: *const ::kernel::sys::raw::c_char,
                     ap: *mut __va_list_tag) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(arg1: *mut ::kernel::sys::raw::c_char, arg2: usize,
                     arg3: *const ::kernel::sys::raw::c_char,
                     arg4: *mut __va_list_tag) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn vsnrprintf(arg1: *mut ::kernel::sys::raw::c_char, arg2: usize,
                      arg3: ::kernel::sys::raw::c_int,
                      arg4: *const ::kernel::sys::raw::c_char,
                      arg5: *mut __va_list_tag) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn vsprintf(buf: *mut ::kernel::sys::raw::c_char,
                    arg1: *const ::kernel::sys::raw::c_char,
                    arg2: *mut __va_list_tag) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn ttyprintf(arg1: *mut tty,
                     arg2: *const ::kernel::sys::raw::c_char, ...)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sscanf(arg1: *const ::kernel::sys::raw::c_char,
                  arg2: *const ::kernel::sys::raw::c_char, ...)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn vsscanf(arg1: *const ::kernel::sys::raw::c_char,
                   arg2: *const ::kernel::sys::raw::c_char,
                   arg3: *mut __va_list_tag) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn strtol(arg1: *const ::kernel::sys::raw::c_char,
                  arg2: *mut *mut ::kernel::sys::raw::c_char,
                  arg3: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_long;
}
extern "C" {
    pub fn strtoul(arg1: *const ::kernel::sys::raw::c_char,
                   arg2: *mut *mut ::kernel::sys::raw::c_char,
                   arg3: ::kernel::sys::raw::c_int) -> u_long;
}
extern "C" {
    pub fn strtoq(arg1: *const ::kernel::sys::raw::c_char,
                  arg2: *mut *mut ::kernel::sys::raw::c_char,
                  arg3: ::kernel::sys::raw::c_int) -> quad_t;
}
extern "C" {
    pub fn strtouq(arg1: *const ::kernel::sys::raw::c_char,
                   arg2: *mut *mut ::kernel::sys::raw::c_char,
                   arg3: ::kernel::sys::raw::c_int) -> u_quad_t;
}
extern "C" {
    pub fn tprintf(p: *mut proc_, pri: ::kernel::sys::raw::c_int,
                   arg1: *const ::kernel::sys::raw::c_char, ...);
}
extern "C" {
    pub fn vtprintf(arg1: *mut proc_, arg2: ::kernel::sys::raw::c_int,
                    arg3: *const ::kernel::sys::raw::c_char,
                    arg4: *mut __va_list_tag);
}
extern "C" {
    pub fn hexdump(ptr: *const ::kernel::sys::raw::c_void,
                   length: ::kernel::sys::raw::c_int,
                   hdr: *const ::kernel::sys::raw::c_char,
                   flags: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn bcopy(from: *const ::kernel::sys::raw::c_void,
                 to: *mut ::kernel::sys::raw::c_void, len: usize);
}
extern "C" {
    pub fn bzero(buf: *mut ::kernel::sys::raw::c_void, len: usize);
}
extern "C" {
    pub fn explicit_bzero(arg1: *mut ::kernel::sys::raw::c_void, arg2: usize);
}
extern "C" {
    pub fn memcpy(to: *mut ::kernel::sys::raw::c_void,
                  from: *const ::kernel::sys::raw::c_void, len: usize)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn memmove(dest: *mut ::kernel::sys::raw::c_void,
                   src: *const ::kernel::sys::raw::c_void, n: usize)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn copystr(kfaddr: *const ::kernel::sys::raw::c_void,
                   kdaddr: *mut ::kernel::sys::raw::c_void, len: usize,
                   lencopied: *mut usize) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn copyinstr(udaddr: *const ::kernel::sys::raw::c_void,
                     kaddr: *mut ::kernel::sys::raw::c_void, len: usize,
                     lencopied: *mut usize) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn copyin(udaddr: *const ::kernel::sys::raw::c_void,
                  kaddr: *mut ::kernel::sys::raw::c_void, len: usize)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn copyin_nofault(udaddr: *const ::kernel::sys::raw::c_void,
                          kaddr: *mut ::kernel::sys::raw::c_void, len: usize)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn copyout(kaddr: *const ::kernel::sys::raw::c_void,
                   udaddr: *mut ::kernel::sys::raw::c_void, len: usize)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn copyout_nofault(kaddr: *const ::kernel::sys::raw::c_void,
                           udaddr: *mut ::kernel::sys::raw::c_void,
                           len: usize) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn fubyte(base: *const ::kernel::sys::raw::c_void)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn fuword(base: *const ::kernel::sys::raw::c_void)
     -> ::kernel::sys::raw::c_long;
}
extern "C" {
    pub fn fuword16(base: *const ::kernel::sys::raw::c_void)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn fuword32(base: *const ::kernel::sys::raw::c_void) -> i32;
}
extern "C" {
    pub fn fuword64(base: *const ::kernel::sys::raw::c_void) -> i64;
}
extern "C" {
    pub fn fueword(base: *const ::kernel::sys::raw::c_void,
                   val: *mut ::kernel::sys::raw::c_long)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn fueword32(base: *const ::kernel::sys::raw::c_void, val: *mut i32)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn fueword64(base: *const ::kernel::sys::raw::c_void, val: *mut i64)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn subyte(base: *mut ::kernel::sys::raw::c_void,
                  byte: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn suword(base: *mut ::kernel::sys::raw::c_void,
                  word: ::kernel::sys::raw::c_long)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn suword16(base: *mut ::kernel::sys::raw::c_void,
                    word: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn suword32(base: *mut ::kernel::sys::raw::c_void, word: i32)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn suword64(base: *mut ::kernel::sys::raw::c_void, word: i64)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn casuword32(base: *mut u32, oldval: u32, newval: u32) -> u32;
}
extern "C" {
    pub fn casuword(p: *mut u_long, oldval: u_long, newval: u_long) -> u_long;
}
extern "C" {
    pub fn casueword32(base: *mut u32, oldval: u32, oldvalp: *mut u32,
                       newval: u32) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn casueword(p: *mut u_long, oldval: u_long, oldvalp: *mut u_long,
                     newval: u_long) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn realitexpire(arg1: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn sysbeep(hertz: ::kernel::sys::raw::c_int,
                   period: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn hardclock(usermode: ::kernel::sys::raw::c_int, pc: uintfptr_t);
}
extern "C" {
    pub fn hardclock_cnt(cnt: ::kernel::sys::raw::c_int,
                         usermode: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn hardclock_cpu(usermode: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn hardclock_sync(cpu: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn softclock(arg1: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn statclock(usermode: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn statclock_cnt(cnt: ::kernel::sys::raw::c_int,
                         usermode: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn profclock(usermode: ::kernel::sys::raw::c_int, pc: uintfptr_t);
}
extern "C" {
    pub fn profclock_cnt(cnt: ::kernel::sys::raw::c_int,
                         usermode: ::kernel::sys::raw::c_int, pc: uintfptr_t);
}
extern "C" {
    pub fn hardclockintr() -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn startprofclock(arg1: *mut proc_);
}
extern "C" {
    pub fn stopprofclock(arg1: *mut proc_);
}
extern "C" {
    pub fn cpu_startprofclock();
}
extern "C" {
    pub fn cpu_stopprofclock();
}
extern "C" {
    pub fn suspendclock();
}
extern "C" {
    pub fn resumeclock();
}
extern "C" {
    pub fn cpu_idleclock() -> sbintime_t;
}
extern "C" {
    pub fn cpu_activeclock();
}
extern "C" {
    pub fn cpu_new_callout(cpu: ::kernel::sys::raw::c_int, bt: sbintime_t,
                           bt_opt: sbintime_t);
}
extern "C" {
    pub fn cpu_et_frequency(et: *mut eventtimer, newfreq: u64);
}
extern "C" {
    #[link_name = "cpu_disable_c2_sleep"]
    pub static mut cpu_disable_c2_sleep: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "cpu_disable_c3_sleep"]
    pub static mut cpu_disable_c3_sleep: ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn kern_getenv(name: *const ::kernel::sys::raw::c_char)
     -> *mut ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn freeenv(env: *mut ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn getenv_int(name: *const ::kernel::sys::raw::c_char,
                      data: *mut ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn getenv_uint(name: *const ::kernel::sys::raw::c_char,
                       data: *mut ::kernel::sys::raw::c_uint)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn getenv_long(name: *const ::kernel::sys::raw::c_char,
                       data: *mut ::kernel::sys::raw::c_long)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn getenv_ulong(name: *const ::kernel::sys::raw::c_char,
                        data: *mut ::kernel::sys::raw::c_ulong)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn getenv_string(name: *const ::kernel::sys::raw::c_char,
                         data: *mut ::kernel::sys::raw::c_char,
                         size: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn getenv_int64(name: *const ::kernel::sys::raw::c_char,
                        data: *mut i64) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn getenv_uint64(name: *const ::kernel::sys::raw::c_char,
                         data: *mut u64) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn getenv_quad(name: *const ::kernel::sys::raw::c_char,
                       data: *mut quad_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn kern_setenv(name: *const ::kernel::sys::raw::c_char,
                       value: *const ::kernel::sys::raw::c_char)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn kern_unsetenv(name: *const ::kernel::sys::raw::c_char)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn testenv(name: *const ::kernel::sys::raw::c_char)
     -> ::kernel::sys::raw::c_int;
}
pub type cpu_tick_f = ::core::option::Option<unsafe extern "C" fn() -> u64>;
extern "C" {
    pub fn set_cputicker(func: cpu_tick_f, freq: u64,
                         var: ::kernel::sys::raw::c_uint);
}
extern "C" {
    #[link_name = "cpu_ticks"]
    pub static mut cpu_ticks: cpu_tick_f;
}
extern "C" {
    pub fn cpu_tickrate() -> u64;
}
extern "C" {
    pub fn cputick2usec(tick: u64) -> u64;
}
extern "C" {
    #[link_name = "bcd2bin_data"]
    pub static mut bcd2bin_data: [u_char; 0usize];
}
extern "C" {
    #[link_name = "bin2bcd_data"]
    pub static mut bin2bcd_data: [u_char; 0usize];
}
extern "C" {
    #[link_name = "hex2ascii_data"]
    pub static mut hex2ascii_data: [::kernel::sys::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "arc4rand_iniseed_state"]
    pub static mut arc4rand_iniseed_state: ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn arc4random() -> u32;
}
extern "C" {
    pub fn arc4random_buf(arg1: *mut ::kernel::sys::raw::c_void, arg2: usize);
}
extern "C" {
    pub fn arc4rand(arg1: *mut ::kernel::sys::raw::c_void, arg2: u_int,
                    arg3: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn bcmp(arg1: *const ::kernel::sys::raw::c_void,
                arg2: *const ::kernel::sys::raw::c_void, arg3: usize)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn timingsafe_bcmp(arg1: *const ::kernel::sys::raw::c_void,
                           arg2: *const ::kernel::sys::raw::c_void,
                           arg3: usize) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bsearch(arg1: *const ::kernel::sys::raw::c_void,
                   arg2: *const ::kernel::sys::raw::c_void, arg3: usize,
                   arg4: usize,
                   arg5:
                       ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                       *const ::kernel::sys::raw::c_void,
                                                                   arg2:
                                                                       *const ::kernel::sys::raw::c_void)
                                                  ->
                                                      ::kernel::sys::raw::c_int>)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn fnmatch(arg1: *const ::kernel::sys::raw::c_char,
                   arg2: *const ::kernel::sys::raw::c_char,
                   arg3: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn locc(arg1: ::kernel::sys::raw::c_int,
                arg2: *mut ::kernel::sys::raw::c_char, arg3: u_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn memchr(s: *const ::kernel::sys::raw::c_void,
                  c: ::kernel::sys::raw::c_int, n: usize)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn memcchr(s: *const ::kernel::sys::raw::c_void,
                   c: ::kernel::sys::raw::c_int, n: usize)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn memcmp(b1: *const ::kernel::sys::raw::c_void,
                  b2: *const ::kernel::sys::raw::c_void, len: usize)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn memmem(l: *const ::kernel::sys::raw::c_void, l_len: usize,
                  s: *const ::kernel::sys::raw::c_void, s_len: usize)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn qsort(base: *mut ::kernel::sys::raw::c_void, nmemb: usize,
                 size: usize,
                 compar:
                     ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                     *const ::kernel::sys::raw::c_void,
                                                                 arg2:
                                                                     *const ::kernel::sys::raw::c_void)
                                                ->
                                                    ::kernel::sys::raw::c_int>);
}
extern "C" {
    pub fn qsort_r(base: *mut ::kernel::sys::raw::c_void, nmemb: usize,
                   size: usize, thunk: *mut ::kernel::sys::raw::c_void,
                   compar:
                       ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                       *mut ::kernel::sys::raw::c_void,
                                                                   arg2:
                                                                       *const ::kernel::sys::raw::c_void,
                                                                   arg3:
                                                                       *const ::kernel::sys::raw::c_void)
                                                  ->
                                                      ::kernel::sys::raw::c_int>);
}
extern "C" {
    pub fn random() -> u_long;
}
extern "C" {
    pub fn scanc(arg1: u_int, arg2: *const u_char, arg3: *const u_char,
                 arg4: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn srandom(arg1: u_long);
}
extern "C" {
    pub fn strcasecmp(arg1: *const ::kernel::sys::raw::c_char,
                      arg2: *const ::kernel::sys::raw::c_char)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn strcat(arg1: *mut ::kernel::sys::raw::c_char,
                  arg2: *const ::kernel::sys::raw::c_char)
     -> *mut ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn strchr(arg1: *const ::kernel::sys::raw::c_char,
                  arg2: ::kernel::sys::raw::c_int)
     -> *mut ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn strcmp(arg1: *const ::kernel::sys::raw::c_char,
                  arg2: *const ::kernel::sys::raw::c_char)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn strcpy(arg1: *mut ::kernel::sys::raw::c_char,
                  arg2: *const ::kernel::sys::raw::c_char)
     -> *mut ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn strcspn(arg1: *const ::kernel::sys::raw::c_char,
                   arg2: *const ::kernel::sys::raw::c_char) -> usize;
}
extern "C" {
    pub fn strdup(arg1: *const ::kernel::sys::raw::c_char,
                  arg2: *mut malloc_type) -> *mut ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn strncat(arg1: *mut ::kernel::sys::raw::c_char,
                   arg2: *const ::kernel::sys::raw::c_char, arg3: usize)
     -> *mut ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn strndup(arg1: *const ::kernel::sys::raw::c_char, arg2: usize,
                   arg3: *mut malloc_type) -> *mut ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn strlcat(arg1: *mut ::kernel::sys::raw::c_char,
                   arg2: *const ::kernel::sys::raw::c_char, arg3: usize)
     -> usize;
}
extern "C" {
    pub fn strlcpy(arg1: *mut ::kernel::sys::raw::c_char,
                   arg2: *const ::kernel::sys::raw::c_char, arg3: usize)
     -> usize;
}
extern "C" {
    pub fn strlen(arg1: *const ::kernel::sys::raw::c_char) -> usize;
}
extern "C" {
    pub fn strncasecmp(arg1: *const ::kernel::sys::raw::c_char,
                       arg2: *const ::kernel::sys::raw::c_char, arg3: usize)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn strncmp(arg1: *const ::kernel::sys::raw::c_char,
                   arg2: *const ::kernel::sys::raw::c_char, arg3: usize)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn strncpy(arg1: *mut ::kernel::sys::raw::c_char,
                   arg2: *const ::kernel::sys::raw::c_char, arg3: usize)
     -> *mut ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn strnlen(arg1: *const ::kernel::sys::raw::c_char, arg2: usize)
     -> usize;
}
extern "C" {
    pub fn strrchr(arg1: *const ::kernel::sys::raw::c_char,
                   arg2: ::kernel::sys::raw::c_int)
     -> *mut ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn strsep(arg1: *mut *mut ::kernel::sys::raw::c_char,
                  delim: *const ::kernel::sys::raw::c_char)
     -> *mut ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn strspn(arg1: *const ::kernel::sys::raw::c_char,
                  arg2: *const ::kernel::sys::raw::c_char) -> usize;
}
extern "C" {
    pub fn strstr(arg1: *const ::kernel::sys::raw::c_char,
                  arg2: *const ::kernel::sys::raw::c_char)
     -> *mut ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn strvalid(arg1: *const ::kernel::sys::raw::c_char, arg2: usize)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "crc32_tab"]
    pub static mut crc32_tab: [u32; 0usize];
}
extern "C" {
    pub fn calculate_crc32c(crc32c: u32,
                            buffer: *const ::kernel::sys::raw::c_uchar,
                            length: ::kernel::sys::raw::c_uint) -> u32;
}
extern "C" {
    pub fn sse42_crc32c(arg1: u32, arg2: *const ::kernel::sys::raw::c_uchar,
                        arg3: ::kernel::sys::raw::c_uint) -> u32;
}
extern "C" {
    pub fn consinit();
}
extern "C" {
    pub fn cpu_initclocks();
}
extern "C" {
    pub fn cpu_initclocks_bsp();
}
extern "C" {
    pub fn cpu_initclocks_ap();
}
extern "C" {
    pub fn usrinfoinit();
}
extern "C" {
    pub fn kern_reboot(arg1: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn shutdown_nice(arg1: ::kernel::sys::raw::c_int);
}
pub type timeout_t =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void)>;
extern "C" {
    pub fn callout_handle_init(arg1: *mut callout_handle);
}
extern "C" {
    pub fn timeout(arg1: timeout_t, arg2: *mut ::kernel::sys::raw::c_void,
                   arg3: ::kernel::sys::raw::c_int) -> callout_handle;
}
extern "C" {
    pub fn untimeout(arg1: timeout_t, arg2: *mut ::kernel::sys::raw::c_void,
                     arg3: callout_handle);
}
extern "C" {
    pub fn _sleep(chan: *mut ::kernel::sys::raw::c_void,
                  lock: *mut lock_object, pri: ::kernel::sys::raw::c_int,
                  wmesg: *const ::kernel::sys::raw::c_char, sbt: sbintime_t,
                  pr: sbintime_t, flags: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn msleep_spin_sbt(chan: *mut ::kernel::sys::raw::c_void,
                           mtx: *mut mtx,
                           wmesg: *const ::kernel::sys::raw::c_char,
                           sbt: sbintime_t, pr: sbintime_t,
                           flags: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn pause_sbt(wmesg: *const ::kernel::sys::raw::c_char,
                     sbt: sbintime_t, pr: sbintime_t,
                     flags: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn wakeup(chan: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn wakeup_one(chan: *mut ::kernel::sys::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cdev {
    _unused: [u8; 0],
}
extern "C" {
    pub fn dev2udev(x: *mut cdev) -> dev_t;
}
extern "C" {
    pub fn devtoname(cdev: *mut cdev) -> *const ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn devfs_iosize_max() -> usize;
}
extern "C" {
    pub fn iosize_max() -> usize;
}
extern "C" {
    pub fn poll_no_poll(events: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn DELAY(usec: ::kernel::sys::raw::c_int);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct root_hold_token {
    _unused: [u8; 0],
}
extern "C" {
    pub fn root_mount_hold(identifier: *const ::kernel::sys::raw::c_char)
     -> *mut root_hold_token;
}
extern "C" {
    pub fn root_mount_rel(h: *mut root_hold_token);
}
extern "C" {
    pub fn root_mounted() -> ::kernel::sys::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct unrhdr {
    _unused: [u8; 0],
}
extern "C" {
    pub fn new_unrhdr(low: ::kernel::sys::raw::c_int,
                      high: ::kernel::sys::raw::c_int, mutex: *mut mtx)
     -> *mut unrhdr;
}
extern "C" {
    pub fn init_unrhdr(uh: *mut unrhdr, low: ::kernel::sys::raw::c_int,
                       high: ::kernel::sys::raw::c_int, mutex: *mut mtx);
}
extern "C" {
    pub fn delete_unrhdr(uh: *mut unrhdr);
}
extern "C" {
    pub fn clear_unrhdr(uh: *mut unrhdr);
}
extern "C" {
    pub fn clean_unrhdr(uh: *mut unrhdr);
}
extern "C" {
    pub fn clean_unrhdrl(uh: *mut unrhdr);
}
extern "C" {
    pub fn alloc_unr(uh: *mut unrhdr) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn alloc_unr_specific(uh: *mut unrhdr, item: u_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn alloc_unrl(uh: *mut unrhdr) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn free_unr(uh: *mut unrhdr, item: u_int);
}
extern "C" {
    pub fn intr_prof_stack_use(td: *mut thread, frame: *mut trapframe);
}
extern "C" {
    pub fn counted_warning(counter: *mut ::kernel::sys::raw::c_uint,
                           msg: *const ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn _gone_in(major: ::kernel::sys::raw::c_int,
                    msg: *const ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn _gone_in_dev(dev: *mut device, major: ::kernel::sys::raw::c_int,
                        msg: *const ::kernel::sys::raw::c_char);
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __va_list_tag {
    pub gp_offset: ::kernel::sys::raw::c_uint,
    pub fp_offset: ::kernel::sys::raw::c_uint,
    pub overflow_arg_area: *mut ::kernel::sys::raw::c_void,
    pub reg_save_area: *mut ::kernel::sys::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(::core::mem::size_of::<__va_list_tag>() , 24usize , concat ! (
               "Size of: " , stringify ! ( __va_list_tag ) ));
    assert_eq! (::core::mem::align_of::<__va_list_tag>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __va_list_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . gp_offset as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( gp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . fp_offset as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( fp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . overflow_arg_area as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( overflow_arg_area ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . reg_save_area as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( reg_save_area ) ));
}
impl Clone for __va_list_tag {
    fn clone(&self) -> Self { *self }
}
impl Default for __va_list_tag {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
