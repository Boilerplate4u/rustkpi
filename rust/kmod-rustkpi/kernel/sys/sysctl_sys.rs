/* automatically generated by rust-bindgen */

pub const __GNUCLIKE_ASM: ::kernel::sys::raw::c_uint = 3;
pub const __GNUCLIKE___TYPEOF: ::kernel::sys::raw::c_uint = 1;
pub const __GNUCLIKE___OFFSETOF: ::kernel::sys::raw::c_uint = 1;
pub const __GNUCLIKE___SECTION: ::kernel::sys::raw::c_uint = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: ::kernel::sys::raw::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: ::kernel::sys::raw::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: ::kernel::sys::raw::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: ::kernel::sys::raw::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: ::kernel::sys::raw::c_uint = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: ::kernel::sys::raw::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: ::kernel::sys::raw::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: ::kernel::sys::raw::c_uint = 1;
pub const __CC_SUPPORTS_INLINE: ::kernel::sys::raw::c_uint = 1;
pub const __CC_SUPPORTS___INLINE: ::kernel::sys::raw::c_uint = 1;
pub const __CC_SUPPORTS___INLINE__: ::kernel::sys::raw::c_uint = 1;
pub const __CC_SUPPORTS___FUNC__: ::kernel::sys::raw::c_uint = 1;
pub const __CC_SUPPORTS_WARNING: ::kernel::sys::raw::c_uint = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: ::kernel::sys::raw::c_uint = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: ::kernel::sys::raw::c_uint = 1;
pub const __POSIX_VISIBLE: ::kernel::sys::raw::c_uint = 200809;
pub const __XSI_VISIBLE: ::kernel::sys::raw::c_uint = 700;
pub const __BSD_VISIBLE: ::kernel::sys::raw::c_uint = 1;
pub const __ISO_C_VISIBLE: ::kernel::sys::raw::c_uint = 2011;
pub const __EXT1_VISIBLE: ::kernel::sys::raw::c_uint = 1;
pub const __CHAR_BIT: ::kernel::sys::raw::c_uint = 8;
pub const __SCHAR_MAX: ::kernel::sys::raw::c_uint = 127;
pub const __SCHAR_MIN: ::kernel::sys::raw::c_int = -128;
pub const __UCHAR_MAX: ::kernel::sys::raw::c_uint = 255;
pub const __USHRT_MAX: ::kernel::sys::raw::c_uint = 65535;
pub const __SHRT_MAX: ::kernel::sys::raw::c_uint = 32767;
pub const __SHRT_MIN: ::kernel::sys::raw::c_int = -32768;
pub const __UINT_MAX: ::kernel::sys::raw::c_uint = 4294967295;
pub const __INT_MAX: ::kernel::sys::raw::c_uint = 2147483647;
pub const __INT_MIN: ::kernel::sys::raw::c_int = -2147483648;
pub const __ULONG_MAX: ::kernel::sys::raw::c_int = -1;
pub const __LONG_MAX: ::kernel::sys::raw::c_ulonglong = 9223372036854775807;
pub const __LONG_MIN: ::kernel::sys::raw::c_longlong = -9223372036854775808;
pub const __ULLONG_MAX: ::kernel::sys::raw::c_int = -1;
pub const __LLONG_MAX: ::kernel::sys::raw::c_ulonglong = 9223372036854775807;
pub const __LLONG_MIN: ::kernel::sys::raw::c_longlong = -9223372036854775808;
pub const __SSIZE_MAX: ::kernel::sys::raw::c_ulonglong = 9223372036854775807;
pub const __SIZE_T_MAX: ::kernel::sys::raw::c_int = -1;
pub const __OFF_MAX: ::kernel::sys::raw::c_ulonglong = 9223372036854775807;
pub const __OFF_MIN: ::kernel::sys::raw::c_longlong = -9223372036854775808;
pub const __UQUAD_MAX: ::kernel::sys::raw::c_int = -1;
pub const __QUAD_MAX: ::kernel::sys::raw::c_ulonglong = 9223372036854775807;
pub const __QUAD_MIN: ::kernel::sys::raw::c_longlong = -9223372036854775808;
pub const __LONG_BIT: ::kernel::sys::raw::c_uint = 64;
pub const __WORD_BIT: ::kernel::sys::raw::c_uint = 32;
pub const __MINSIGSTKSZ: ::kernel::sys::raw::c_uint = 2048;
pub const __WCHAR_MIN: ::kernel::sys::raw::c_int = -2147483648;
pub const __WCHAR_MAX: ::kernel::sys::raw::c_uint = 2147483647;
pub const _QUAD_HIGHWORD: ::kernel::sys::raw::c_uint = 1;
pub const _QUAD_LOWWORD: ::kernel::sys::raw::c_uint = 0;
pub const _LITTLE_ENDIAN: ::kernel::sys::raw::c_uint = 1234;
pub const _BIG_ENDIAN: ::kernel::sys::raw::c_uint = 4321;
pub const _PDP_ENDIAN: ::kernel::sys::raw::c_uint = 3412;
pub const _BYTE_ORDER: ::kernel::sys::raw::c_uint = 1234;
pub const LITTLE_ENDIAN: ::kernel::sys::raw::c_uint = 1234;
pub const BIG_ENDIAN: ::kernel::sys::raw::c_uint = 4321;
pub const PDP_ENDIAN: ::kernel::sys::raw::c_uint = 3412;
pub const BYTE_ORDER: ::kernel::sys::raw::c_uint = 1234;
pub const __bool_true_false_are_defined: ::kernel::sys::raw::c_uint = 1;
pub const false_: ::kernel::sys::raw::c_uint = 0;
pub const true_: ::kernel::sys::raw::c_uint = 1;
pub const _SIG_WORDS: ::kernel::sys::raw::c_uint = 4;
pub const _SIG_MAXSIG: ::kernel::sys::raw::c_uint = 128;
pub const FD_SETSIZE: ::kernel::sys::raw::c_uint = 1024;
pub const CTL_MAXNAME: ::kernel::sys::raw::c_uint = 24;
pub const CTLTYPE: ::kernel::sys::raw::c_uint = 15;
pub const CTLTYPE_NODE: ::kernel::sys::raw::c_uint = 1;
pub const CTLTYPE_INT: ::kernel::sys::raw::c_uint = 2;
pub const CTLTYPE_STRING: ::kernel::sys::raw::c_uint = 3;
pub const CTLTYPE_S64: ::kernel::sys::raw::c_uint = 4;
pub const CTLTYPE_OPAQUE: ::kernel::sys::raw::c_uint = 5;
pub const CTLTYPE_STRUCT: ::kernel::sys::raw::c_uint = 5;
pub const CTLTYPE_UINT: ::kernel::sys::raw::c_uint = 6;
pub const CTLTYPE_LONG: ::kernel::sys::raw::c_uint = 7;
pub const CTLTYPE_ULONG: ::kernel::sys::raw::c_uint = 8;
pub const CTLTYPE_U64: ::kernel::sys::raw::c_uint = 9;
pub const CTLTYPE_U8: ::kernel::sys::raw::c_uint = 10;
pub const CTLTYPE_U16: ::kernel::sys::raw::c_uint = 11;
pub const CTLTYPE_S8: ::kernel::sys::raw::c_uint = 12;
pub const CTLTYPE_S16: ::kernel::sys::raw::c_uint = 13;
pub const CTLTYPE_S32: ::kernel::sys::raw::c_uint = 14;
pub const CTLTYPE_U32: ::kernel::sys::raw::c_uint = 15;
pub const CTLFLAG_RD: ::kernel::sys::raw::c_uint = 2147483648;
pub const CTLFLAG_WR: ::kernel::sys::raw::c_uint = 1073741824;
pub const CTLFLAG_RW: ::kernel::sys::raw::c_uint = 3221225472;
pub const CTLFLAG_DORMANT: ::kernel::sys::raw::c_uint = 536870912;
pub const CTLFLAG_ANYBODY: ::kernel::sys::raw::c_uint = 268435456;
pub const CTLFLAG_SECURE: ::kernel::sys::raw::c_uint = 134217728;
pub const CTLFLAG_PRISON: ::kernel::sys::raw::c_uint = 67108864;
pub const CTLFLAG_DYN: ::kernel::sys::raw::c_uint = 33554432;
pub const CTLFLAG_SKIP: ::kernel::sys::raw::c_uint = 16777216;
pub const CTLMASK_SECURE: ::kernel::sys::raw::c_uint = 15728640;
pub const CTLFLAG_TUN: ::kernel::sys::raw::c_uint = 524288;
pub const CTLFLAG_RDTUN: ::kernel::sys::raw::c_uint = 2148007936;
pub const CTLFLAG_RWTUN: ::kernel::sys::raw::c_uint = 3221749760;
pub const CTLFLAG_MPSAFE: ::kernel::sys::raw::c_uint = 262144;
pub const CTLFLAG_VNET: ::kernel::sys::raw::c_uint = 131072;
pub const CTLFLAG_DYING: ::kernel::sys::raw::c_uint = 65536;
pub const CTLFLAG_CAPRD: ::kernel::sys::raw::c_uint = 32768;
pub const CTLFLAG_CAPWR: ::kernel::sys::raw::c_uint = 16384;
pub const CTLFLAG_STATS: ::kernel::sys::raw::c_uint = 8192;
pub const CTLFLAG_NOFETCH: ::kernel::sys::raw::c_uint = 4096;
pub const CTLFLAG_CAPRW: ::kernel::sys::raw::c_uint = 49152;
pub const CTLSHIFT_SECURE: ::kernel::sys::raw::c_uint = 20;
pub const CTLFLAG_SECURE1: ::kernel::sys::raw::c_uint = 134217728;
pub const CTLFLAG_SECURE2: ::kernel::sys::raw::c_uint = 135266304;
pub const CTLFLAG_SECURE3: ::kernel::sys::raw::c_uint = 136314880;
pub const OID_AUTO: ::kernel::sys::raw::c_int = -1;
pub const CTL_AUTO_START: ::kernel::sys::raw::c_uint = 256;
pub const SYSCTL_CT_ASSERT_MASK: ::kernel::sys::raw::c_uint = 15;
pub const REQ_UNWIRED: ::kernel::sys::raw::c_uint = 1;
pub const REQ_WIRED: ::kernel::sys::raw::c_uint = 2;
pub const SCTL_MASK32: ::kernel::sys::raw::c_uint = 1;
pub const CTL_UNSPEC: ::kernel::sys::raw::c_uint = 0;
pub const CTL_KERN: ::kernel::sys::raw::c_uint = 1;
pub const CTL_VM: ::kernel::sys::raw::c_uint = 2;
pub const CTL_VFS: ::kernel::sys::raw::c_uint = 3;
pub const CTL_NET: ::kernel::sys::raw::c_uint = 4;
pub const CTL_DEBUG: ::kernel::sys::raw::c_uint = 5;
pub const CTL_HW: ::kernel::sys::raw::c_uint = 6;
pub const CTL_MACHDEP: ::kernel::sys::raw::c_uint = 7;
pub const CTL_USER: ::kernel::sys::raw::c_uint = 8;
pub const CTL_P1003_1B: ::kernel::sys::raw::c_uint = 9;
pub const KERN_OSTYPE: ::kernel::sys::raw::c_uint = 1;
pub const KERN_OSRELEASE: ::kernel::sys::raw::c_uint = 2;
pub const KERN_OSREV: ::kernel::sys::raw::c_uint = 3;
pub const KERN_VERSION: ::kernel::sys::raw::c_uint = 4;
pub const KERN_MAXVNODES: ::kernel::sys::raw::c_uint = 5;
pub const KERN_MAXPROC: ::kernel::sys::raw::c_uint = 6;
pub const KERN_MAXFILES: ::kernel::sys::raw::c_uint = 7;
pub const KERN_ARGMAX: ::kernel::sys::raw::c_uint = 8;
pub const KERN_SECURELVL: ::kernel::sys::raw::c_uint = 9;
pub const KERN_HOSTNAME: ::kernel::sys::raw::c_uint = 10;
pub const KERN_HOSTID: ::kernel::sys::raw::c_uint = 11;
pub const KERN_CLOCKRATE: ::kernel::sys::raw::c_uint = 12;
pub const KERN_VNODE: ::kernel::sys::raw::c_uint = 13;
pub const KERN_PROC: ::kernel::sys::raw::c_uint = 14;
pub const KERN_FILE: ::kernel::sys::raw::c_uint = 15;
pub const KERN_PROF: ::kernel::sys::raw::c_uint = 16;
pub const KERN_POSIX1: ::kernel::sys::raw::c_uint = 17;
pub const KERN_NGROUPS: ::kernel::sys::raw::c_uint = 18;
pub const KERN_JOB_CONTROL: ::kernel::sys::raw::c_uint = 19;
pub const KERN_SAVED_IDS: ::kernel::sys::raw::c_uint = 20;
pub const KERN_BOOTTIME: ::kernel::sys::raw::c_uint = 21;
pub const KERN_NISDOMAINNAME: ::kernel::sys::raw::c_uint = 22;
pub const KERN_UPDATEINTERVAL: ::kernel::sys::raw::c_uint = 23;
pub const KERN_OSRELDATE: ::kernel::sys::raw::c_uint = 24;
pub const KERN_NTP_PLL: ::kernel::sys::raw::c_uint = 25;
pub const KERN_BOOTFILE: ::kernel::sys::raw::c_uint = 26;
pub const KERN_MAXFILESPERPROC: ::kernel::sys::raw::c_uint = 27;
pub const KERN_MAXPROCPERUID: ::kernel::sys::raw::c_uint = 28;
pub const KERN_DUMPDEV: ::kernel::sys::raw::c_uint = 29;
pub const KERN_IPC: ::kernel::sys::raw::c_uint = 30;
pub const KERN_DUMMY: ::kernel::sys::raw::c_uint = 31;
pub const KERN_PS_STRINGS: ::kernel::sys::raw::c_uint = 32;
pub const KERN_USRSTACK: ::kernel::sys::raw::c_uint = 33;
pub const KERN_LOGSIGEXIT: ::kernel::sys::raw::c_uint = 34;
pub const KERN_IOV_MAX: ::kernel::sys::raw::c_uint = 35;
pub const KERN_HOSTUUID: ::kernel::sys::raw::c_uint = 36;
pub const KERN_ARND: ::kernel::sys::raw::c_uint = 37;
pub const KERN_MAXPHYS: ::kernel::sys::raw::c_uint = 38;
pub const KERN_PROC_ALL: ::kernel::sys::raw::c_uint = 0;
pub const KERN_PROC_PID: ::kernel::sys::raw::c_uint = 1;
pub const KERN_PROC_PGRP: ::kernel::sys::raw::c_uint = 2;
pub const KERN_PROC_SESSION: ::kernel::sys::raw::c_uint = 3;
pub const KERN_PROC_TTY: ::kernel::sys::raw::c_uint = 4;
pub const KERN_PROC_UID: ::kernel::sys::raw::c_uint = 5;
pub const KERN_PROC_RUID: ::kernel::sys::raw::c_uint = 6;
pub const KERN_PROC_ARGS: ::kernel::sys::raw::c_uint = 7;
pub const KERN_PROC_PROC: ::kernel::sys::raw::c_uint = 8;
pub const KERN_PROC_SV_NAME: ::kernel::sys::raw::c_uint = 9;
pub const KERN_PROC_RGID: ::kernel::sys::raw::c_uint = 10;
pub const KERN_PROC_GID: ::kernel::sys::raw::c_uint = 11;
pub const KERN_PROC_PATHNAME: ::kernel::sys::raw::c_uint = 12;
pub const KERN_PROC_OVMMAP: ::kernel::sys::raw::c_uint = 13;
pub const KERN_PROC_OFILEDESC: ::kernel::sys::raw::c_uint = 14;
pub const KERN_PROC_KSTACK: ::kernel::sys::raw::c_uint = 15;
pub const KERN_PROC_INC_THREAD: ::kernel::sys::raw::c_uint = 16;
pub const KERN_PROC_VMMAP: ::kernel::sys::raw::c_uint = 32;
pub const KERN_PROC_FILEDESC: ::kernel::sys::raw::c_uint = 33;
pub const KERN_PROC_GROUPS: ::kernel::sys::raw::c_uint = 34;
pub const KERN_PROC_ENV: ::kernel::sys::raw::c_uint = 35;
pub const KERN_PROC_AUXV: ::kernel::sys::raw::c_uint = 36;
pub const KERN_PROC_RLIMIT: ::kernel::sys::raw::c_uint = 37;
pub const KERN_PROC_PS_STRINGS: ::kernel::sys::raw::c_uint = 38;
pub const KERN_PROC_UMASK: ::kernel::sys::raw::c_uint = 39;
pub const KERN_PROC_OSREL: ::kernel::sys::raw::c_uint = 40;
pub const KERN_PROC_SIGTRAMP: ::kernel::sys::raw::c_uint = 41;
pub const KERN_PROC_CWD: ::kernel::sys::raw::c_uint = 42;
pub const KERN_PROC_NFDS: ::kernel::sys::raw::c_uint = 43;
pub const KIPC_MAXSOCKBUF: ::kernel::sys::raw::c_uint = 1;
pub const KIPC_SOCKBUF_WASTE: ::kernel::sys::raw::c_uint = 2;
pub const KIPC_SOMAXCONN: ::kernel::sys::raw::c_uint = 3;
pub const KIPC_MAX_LINKHDR: ::kernel::sys::raw::c_uint = 4;
pub const KIPC_MAX_PROTOHDR: ::kernel::sys::raw::c_uint = 5;
pub const KIPC_MAX_HDR: ::kernel::sys::raw::c_uint = 6;
pub const KIPC_MAX_DATALEN: ::kernel::sys::raw::c_uint = 7;
pub const HW_MACHINE: ::kernel::sys::raw::c_uint = 1;
pub const HW_MODEL: ::kernel::sys::raw::c_uint = 2;
pub const HW_NCPU: ::kernel::sys::raw::c_uint = 3;
pub const HW_BYTEORDER: ::kernel::sys::raw::c_uint = 4;
pub const HW_PHYSMEM: ::kernel::sys::raw::c_uint = 5;
pub const HW_USERMEM: ::kernel::sys::raw::c_uint = 6;
pub const HW_PAGESIZE: ::kernel::sys::raw::c_uint = 7;
pub const HW_DISKNAMES: ::kernel::sys::raw::c_uint = 8;
pub const HW_DISKSTATS: ::kernel::sys::raw::c_uint = 9;
pub const HW_FLOATINGPT: ::kernel::sys::raw::c_uint = 10;
pub const HW_MACHINE_ARCH: ::kernel::sys::raw::c_uint = 11;
pub const HW_REALMEM: ::kernel::sys::raw::c_uint = 12;
pub const USER_CS_PATH: ::kernel::sys::raw::c_uint = 1;
pub const USER_BC_BASE_MAX: ::kernel::sys::raw::c_uint = 2;
pub const USER_BC_DIM_MAX: ::kernel::sys::raw::c_uint = 3;
pub const USER_BC_SCALE_MAX: ::kernel::sys::raw::c_uint = 4;
pub const USER_BC_STRING_MAX: ::kernel::sys::raw::c_uint = 5;
pub const USER_COLL_WEIGHTS_MAX: ::kernel::sys::raw::c_uint = 6;
pub const USER_EXPR_NEST_MAX: ::kernel::sys::raw::c_uint = 7;
pub const USER_LINE_MAX: ::kernel::sys::raw::c_uint = 8;
pub const USER_RE_DUP_MAX: ::kernel::sys::raw::c_uint = 9;
pub const USER_POSIX2_VERSION: ::kernel::sys::raw::c_uint = 10;
pub const USER_POSIX2_C_BIND: ::kernel::sys::raw::c_uint = 11;
pub const USER_POSIX2_C_DEV: ::kernel::sys::raw::c_uint = 12;
pub const USER_POSIX2_CHAR_TERM: ::kernel::sys::raw::c_uint = 13;
pub const USER_POSIX2_FORT_DEV: ::kernel::sys::raw::c_uint = 14;
pub const USER_POSIX2_FORT_RUN: ::kernel::sys::raw::c_uint = 15;
pub const USER_POSIX2_LOCALEDEF: ::kernel::sys::raw::c_uint = 16;
pub const USER_POSIX2_SW_DEV: ::kernel::sys::raw::c_uint = 17;
pub const USER_POSIX2_UPE: ::kernel::sys::raw::c_uint = 18;
pub const USER_STREAM_MAX: ::kernel::sys::raw::c_uint = 19;
pub const USER_TZNAME_MAX: ::kernel::sys::raw::c_uint = 20;
pub const CTL_P1003_1B_ASYNCHRONOUS_IO: ::kernel::sys::raw::c_uint = 1;
pub const CTL_P1003_1B_MAPPED_FILES: ::kernel::sys::raw::c_uint = 2;
pub const CTL_P1003_1B_MEMLOCK: ::kernel::sys::raw::c_uint = 3;
pub const CTL_P1003_1B_MEMLOCK_RANGE: ::kernel::sys::raw::c_uint = 4;
pub const CTL_P1003_1B_MEMORY_PROTECTION: ::kernel::sys::raw::c_uint = 5;
pub const CTL_P1003_1B_MESSAGE_PASSING: ::kernel::sys::raw::c_uint = 6;
pub const CTL_P1003_1B_PRIORITIZED_IO: ::kernel::sys::raw::c_uint = 7;
pub const CTL_P1003_1B_PRIORITY_SCHEDULING: ::kernel::sys::raw::c_uint = 8;
pub const CTL_P1003_1B_REALTIME_SIGNALS: ::kernel::sys::raw::c_uint = 9;
pub const CTL_P1003_1B_SEMAPHORES: ::kernel::sys::raw::c_uint = 10;
pub const CTL_P1003_1B_FSYNC: ::kernel::sys::raw::c_uint = 11;
pub const CTL_P1003_1B_SHARED_MEMORY_OBJECTS: ::kernel::sys::raw::c_uint = 12;
pub const CTL_P1003_1B_SYNCHRONIZED_IO: ::kernel::sys::raw::c_uint = 13;
pub const CTL_P1003_1B_TIMERS: ::kernel::sys::raw::c_uint = 14;
pub const CTL_P1003_1B_AIO_LISTIO_MAX: ::kernel::sys::raw::c_uint = 15;
pub const CTL_P1003_1B_AIO_MAX: ::kernel::sys::raw::c_uint = 16;
pub const CTL_P1003_1B_AIO_PRIO_DELTA_MAX: ::kernel::sys::raw::c_uint = 17;
pub const CTL_P1003_1B_DELAYTIMER_MAX: ::kernel::sys::raw::c_uint = 18;
pub const CTL_P1003_1B_MQ_OPEN_MAX: ::kernel::sys::raw::c_uint = 19;
pub const CTL_P1003_1B_PAGESIZE: ::kernel::sys::raw::c_uint = 20;
pub const CTL_P1003_1B_RTSIG_MAX: ::kernel::sys::raw::c_uint = 21;
pub const CTL_P1003_1B_SEM_NSEMS_MAX: ::kernel::sys::raw::c_uint = 22;
pub const CTL_P1003_1B_SEM_VALUE_MAX: ::kernel::sys::raw::c_uint = 23;
pub const CTL_P1003_1B_SIGQUEUE_MAX: ::kernel::sys::raw::c_uint = 24;
pub const CTL_P1003_1B_TIMER_MAX: ::kernel::sys::raw::c_uint = 25;
pub const CTL_P1003_1B_MAXID: ::kernel::sys::raw::c_uint = 26;
pub type __int8_t = ::kernel::sys::raw::c_schar;
pub type __uint8_t = ::kernel::sys::raw::c_uchar;
pub type __int16_t = ::kernel::sys::raw::c_short;
pub type __uint16_t = ::kernel::sys::raw::c_ushort;
pub type __int32_t = ::kernel::sys::raw::c_int;
pub type __uint32_t = ::kernel::sys::raw::c_uint;
pub type __int64_t = ::kernel::sys::raw::c_long;
pub type __uint64_t = ::kernel::sys::raw::c_ulong;
pub type __clock_t = __int32_t;
pub type __critical_t = __int64_t;
pub type __double_t = f64;
pub type __float_t = f32;
pub type __intfptr_t = __int64_t;
pub type __intptr_t = __int64_t;
pub type __intmax_t = __int64_t;
pub type __int_fast8_t = __int32_t;
pub type __int_fast16_t = __int32_t;
pub type __int_fast32_t = __int32_t;
pub type __int_fast64_t = __int64_t;
pub type __int_least8_t = __int8_t;
pub type __int_least16_t = __int16_t;
pub type __int_least32_t = __int32_t;
pub type __int_least64_t = __int64_t;
pub type __ptrdiff_t = __int64_t;
pub type __register_t = __int64_t;
pub type __segsz_t = __int64_t;
pub type __size_t = __uint64_t;
pub type __ssize_t = __int64_t;
pub type __time_t = __int64_t;
pub type __uintfptr_t = __uint64_t;
pub type __uintptr_t = __uint64_t;
pub type __uintmax_t = __uint64_t;
pub type __uint_fast8_t = __uint32_t;
pub type __uint_fast16_t = __uint32_t;
pub type __uint_fast32_t = __uint32_t;
pub type __uint_fast64_t = __uint64_t;
pub type __uint_least8_t = __uint8_t;
pub type __uint_least16_t = __uint16_t;
pub type __uint_least32_t = __uint32_t;
pub type __uint_least64_t = __uint64_t;
pub type __u_register_t = __uint64_t;
pub type __vm_offset_t = __uint64_t;
pub type __vm_paddr_t = __uint64_t;
pub type __vm_size_t = __uint64_t;
pub type ___wchar_t = ::kernel::sys::raw::c_int;
pub type __blksize_t = __int32_t;
pub type __blkcnt_t = __int64_t;
pub type __clockid_t = __int32_t;
pub type __fflags_t = __uint32_t;
pub type __fsblkcnt_t = __uint64_t;
pub type __fsfilcnt_t = __uint64_t;
pub type __gid_t = __uint32_t;
pub type __id_t = __int64_t;
pub type __ino_t = __uint64_t;
pub type __key_t = ::kernel::sys::raw::c_long;
pub type __lwpid_t = __int32_t;
pub type __mode_t = __uint16_t;
pub type __accmode_t = ::kernel::sys::raw::c_int;
pub type __nl_item = ::kernel::sys::raw::c_int;
pub type __nlink_t = __uint64_t;
pub type __off_t = __int64_t;
pub type __off64_t = __int64_t;
pub type __pid_t = __int32_t;
pub type __rlim_t = __int64_t;
pub type __sa_family_t = __uint8_t;
pub type __socklen_t = __uint32_t;
pub type __suseconds_t = ::kernel::sys::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __timer {
    _unused: [u8; 0],
}
pub type __timer_t = *mut __timer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __mq {
    _unused: [u8; 0],
}
pub type __mqd_t = *mut __mq;
pub type __uid_t = __uint32_t;
pub type __useconds_t = ::kernel::sys::raw::c_uint;
pub type __cpuwhich_t = ::kernel::sys::raw::c_int;
pub type __cpulevel_t = ::kernel::sys::raw::c_int;
pub type __cpusetid_t = ::kernel::sys::raw::c_int;
pub type __ct_rune_t = ::kernel::sys::raw::c_int;
pub type __rune_t = __ct_rune_t;
pub type __wint_t = __ct_rune_t;
pub type __char16_t = __uint_least16_t;
pub type __char32_t = __uint_least32_t;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct __max_align_t {
    pub __max_align1: ::kernel::sys::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __max_align2: f64,
}
#[test]
fn bindgen_test_layout___max_align_t() {
    assert_eq!(::core::mem::size_of::<__max_align_t>() , 32usize , concat ! (
               "Size of: " , stringify ! ( __max_align_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __max_align_t ) ) . __max_align1 as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __max_align_t ) , "::"
                , stringify ! ( __max_align1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __max_align_t ) ) . __max_align2 as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __max_align_t ) , "::"
                , stringify ! ( __max_align2 ) ));
}
impl Clone for __max_align_t {
    fn clone(&self) -> Self { *self }
}
pub type __dev_t = __uint64_t;
pub type __fixpt_t = __uint32_t;
#[repr(C)]
#[derive(Copy)]
pub union __mbstate_t {
    pub __mbstate8: [::kernel::sys::raw::c_char; 128usize],
    pub _mbstateL: __int64_t,
    _bindgen_union_align: [u64; 16usize],
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(::core::mem::size_of::<__mbstate_t>() , 128usize , concat ! (
               "Size of: " , stringify ! ( __mbstate_t ) ));
    assert_eq! (::core::mem::align_of::<__mbstate_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __mbstate_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . __mbstate8 as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( __mbstate8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . _mbstateL as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( _mbstateL ) ));
}
impl Clone for __mbstate_t {
    fn clone(&self) -> Self { *self }
}
impl Default for __mbstate_t {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for __mbstate_t {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "__mbstate_t {{ union }}")
    }
}
pub type __rman_res_t = __uintmax_t;
pub type __va_list = __builtin_va_list;
pub type __gnuc_va_list = __va_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_cond {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_cond_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutex {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutex_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_once {
    pub state: ::kernel::sys::raw::c_int,
    pub mutex: pthread_mutex_t,
}
#[test]
fn bindgen_test_layout_pthread_once() {
    assert_eq!(::core::mem::size_of::<pthread_once>() , 16usize , concat ! (
               "Size of: " , stringify ! ( pthread_once ) ));
    assert_eq! (::core::mem::align_of::<pthread_once>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_once ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_once ) ) . state as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_once ) , "::" ,
                stringify ! ( state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_once ) ) . mutex as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_once ) , "::" ,
                stringify ! ( mutex ) ));
}
impl Clone for pthread_once {
    fn clone(&self) -> Self { *self }
}
impl Default for pthread_once {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_rwlock {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_rwlockattr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_barrier {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_barrier_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_spinlock {
    _unused: [u8; 0],
}
pub type pthread_t = *mut pthread;
pub type pthread_attr_t = *mut pthread_attr;
pub type pthread_mutex_t = *mut pthread_mutex;
pub type pthread_mutexattr_t = *mut pthread_mutex_attr;
pub type pthread_cond_t = *mut pthread_cond;
pub type pthread_condattr_t = *mut pthread_cond_attr;
pub type pthread_key_t = ::kernel::sys::raw::c_int;
pub type pthread_once_t = pthread_once;
pub type pthread_rwlock_t = *mut pthread_rwlock;
pub type pthread_rwlockattr_t = *mut pthread_rwlockattr;
pub type pthread_barrier_t = *mut pthread_barrier;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_barrierattr {
    _unused: [u8; 0],
}
pub type pthread_barrierattr_t = *mut pthread_barrierattr;
pub type pthread_spinlock_t = *mut pthread_spinlock;
pub type pthread_addr_t = *mut ::kernel::sys::raw::c_void;
pub type pthread_startroutine_t =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void)
                               -> *mut ::kernel::sys::raw::c_void>;
pub type u_char = ::kernel::sys::raw::c_uchar;
pub type u_short = ::kernel::sys::raw::c_ushort;
pub type u_int = ::kernel::sys::raw::c_uint;
pub type u_long = ::kernel::sys::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type u_quad_t = __uint64_t;
pub type quad_t = __int64_t;
pub type qaddr_t = *mut quad_t;
pub type caddr_t = *mut ::kernel::sys::raw::c_char;
pub type c_caddr_t = *const ::kernel::sys::raw::c_char;
pub type blksize_t = __blksize_t;
pub type cpuwhich_t = __cpuwhich_t;
pub type cpulevel_t = __cpulevel_t;
pub type cpusetid_t = __cpusetid_t;
pub type blkcnt_t = __blkcnt_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type critical_t = __critical_t;
pub type daddr_t = __int64_t;
pub type dev_t = __dev_t;
pub type fflags_t = __fflags_t;
pub type fixpt_t = __fixpt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type gid_t = __gid_t;
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type id_t = __id_t;
pub type ino_t = __ino_t;
pub type key_t = __key_t;
pub type lwpid_t = __lwpid_t;
pub type mode_t = __mode_t;
pub type accmode_t = __accmode_t;
pub type nlink_t = __nlink_t;
pub type off_t = __off_t;
pub type off64_t = __off64_t;
pub type pid_t = __pid_t;
pub type register_t = __register_t;
pub type rlim_t = __rlim_t;
pub type sbintime_t = __int64_t;
pub type segsz_t = __segsz_t;
pub type suseconds_t = __suseconds_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type mqd_t = __mqd_t;
pub type u_register_t = __u_register_t;
pub type uid_t = __uid_t;
pub type useconds_t = __useconds_t;
pub type cap_ioctl_t = ::kernel::sys::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cap_rights {
    _unused: [u8; 0],
}
pub type cap_rights_t = cap_rights;
pub type kvaddr_t = __uint64_t;
pub type ksize_t = __uint64_t;
pub type vm_offset_t = __vm_offset_t;
pub type vm_ooffset_t = __int64_t;
pub type vm_paddr_t = __vm_paddr_t;
pub type vm_pindex_t = __uint64_t;
pub type vm_size_t = __vm_size_t;
pub type rman_res_t = __rman_res_t;
pub type boolean_t = ::kernel::sys::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct device {
    _unused: [u8; 0],
}
pub type device_t = *mut device;
pub type intfptr_t = __intfptr_t;
pub type intrmask_t = __uint32_t;
pub type uintfptr_t = __uintfptr_t;
pub type uoff_t = __uint64_t;
pub type vm_memattr_t = ::kernel::sys::raw::c_char;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_page {
    _unused: [u8; 0],
}
pub type vm_page_t = *mut vm_page;
pub type bool_ = bool;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct __sigset {
    pub __bits: [__uint32_t; 4usize],
}
#[test]
fn bindgen_test_layout___sigset() {
    assert_eq!(::core::mem::size_of::<__sigset>() , 16usize , concat ! (
               "Size of: " , stringify ! ( __sigset ) ));
    assert_eq! (::core::mem::align_of::<__sigset>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( __sigset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sigset ) ) . __bits as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sigset ) , "::" ,
                stringify ! ( __bits ) ));
}
impl Clone for __sigset {
    fn clone(&self) -> Self { *self }
}
pub type __sigset_t = __sigset;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct timeval {
    pub tv_sec: time_t,
    pub tv_usec: suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(::core::mem::size_of::<timeval>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timeval ) ));
    assert_eq! (::core::mem::align_of::<timeval>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timeval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_usec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_usec ) ));
}
impl Clone for timeval {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: ::kernel::sys::raw::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(::core::mem::size_of::<timespec>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timespec ) ));
    assert_eq! (::core::mem::align_of::<timespec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timespec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_nsec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_nsec ) ));
}
impl Clone for timespec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(::core::mem::size_of::<itimerspec>() , 32usize , concat ! (
               "Size of: " , stringify ! ( itimerspec ) ));
    assert_eq! (::core::mem::align_of::<itimerspec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( itimerspec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerspec ) ) . it_interval as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerspec ) , "::" ,
                stringify ! ( it_interval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerspec ) ) . it_value as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerspec ) , "::" ,
                stringify ! ( it_value ) ));
}
impl Clone for itimerspec {
    fn clone(&self) -> Self { *self }
}
pub type __fd_mask = ::kernel::sys::raw::c_ulong;
pub type fd_mask = __fd_mask;
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(::core::mem::size_of::<fd_set>() , 128usize , concat ! (
               "Size of: " , stringify ! ( fd_set ) ));
    assert_eq! (::core::mem::align_of::<fd_set>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( fd_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fd_set ) ) . __fds_bits as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( fd_set ) , "::" ,
                stringify ! ( __fds_bits ) ));
}
impl Clone for fd_set {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct thread {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ctlname {
    pub ctl_name: *mut ::kernel::sys::raw::c_char,
    pub ctl_type: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_ctlname() {
    assert_eq!(::core::mem::size_of::<ctlname>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ctlname ) ));
    assert_eq! (::core::mem::align_of::<ctlname>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ctlname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ctlname ) ) . ctl_name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ctlname ) , "::" ,
                stringify ! ( ctl_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ctlname ) ) . ctl_type as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ctlname ) , "::" ,
                stringify ! ( ctl_type ) ));
}
impl Clone for ctlname {
    fn clone(&self) -> Self { *self }
}
impl Default for ctlname {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sysctl_req {
    pub td: *mut thread,
    pub lock: ::kernel::sys::raw::c_int,
    pub oldptr: *mut ::kernel::sys::raw::c_void,
    pub oldlen: usize,
    pub oldidx: usize,
    pub oldfunc: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                 *mut sysctl_req,
                                                             arg2:
                                                                 *const ::kernel::sys::raw::c_void,
                                                             arg3: usize)
                                            -> ::kernel::sys::raw::c_int>,
    pub newptr: *mut ::kernel::sys::raw::c_void,
    pub newlen: usize,
    pub newidx: usize,
    pub newfunc: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                 *mut sysctl_req,
                                                             arg2:
                                                                 *mut ::kernel::sys::raw::c_void,
                                                             arg3: usize)
                                            -> ::kernel::sys::raw::c_int>,
    pub validlen: usize,
    pub flags: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_sysctl_req() {
    assert_eq!(::core::mem::size_of::<sysctl_req>() , 96usize , concat ! (
               "Size of: " , stringify ! ( sysctl_req ) ));
    assert_eq! (::core::mem::align_of::<sysctl_req>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sysctl_req ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_req ) ) . td as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sysctl_req ) , "::" ,
                stringify ! ( td ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_req ) ) . lock as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sysctl_req ) , "::" ,
                stringify ! ( lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_req ) ) . oldptr as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( sysctl_req ) , "::" ,
                stringify ! ( oldptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_req ) ) . oldlen as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( sysctl_req ) , "::" ,
                stringify ! ( oldlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_req ) ) . oldidx as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( sysctl_req ) , "::" ,
                stringify ! ( oldidx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_req ) ) . oldfunc as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( sysctl_req ) , "::" ,
                stringify ! ( oldfunc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_req ) ) . newptr as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( sysctl_req ) , "::" ,
                stringify ! ( newptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_req ) ) . newlen as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( sysctl_req ) , "::" ,
                stringify ! ( newlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_req ) ) . newidx as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( sysctl_req ) , "::" ,
                stringify ! ( newidx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_req ) ) . newfunc as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( sysctl_req ) , "::" ,
                stringify ! ( newfunc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_req ) ) . validlen as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( sysctl_req ) , "::" ,
                stringify ! ( validlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_req ) ) . flags as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( sysctl_req ) , "::" ,
                stringify ! ( flags ) ));
}
impl Clone for sysctl_req {
    fn clone(&self) -> Self { *self }
}
impl Default for sysctl_req {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sysctl_oid_list {
    pub slh_first: *mut sysctl_oid,
}
#[test]
fn bindgen_test_layout_sysctl_oid_list() {
    assert_eq!(::core::mem::size_of::<sysctl_oid_list>() , 8usize , concat ! (
               "Size of: " , stringify ! ( sysctl_oid_list ) ));
    assert_eq! (::core::mem::align_of::<sysctl_oid_list>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( sysctl_oid_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_oid_list ) ) . slh_first as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sysctl_oid_list ) ,
                "::" , stringify ! ( slh_first ) ));
}
impl Clone for sysctl_oid_list {
    fn clone(&self) -> Self { *self }
}
impl Default for sysctl_oid_list {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sysctl_oid {
    pub oid_children: sysctl_oid_list,
    pub oid_parent: *mut sysctl_oid_list,
    pub oid_link: sysctl_oid__bindgen_ty_1,
    pub oid_number: ::kernel::sys::raw::c_int,
    pub oid_kind: u_int,
    pub oid_arg1: *mut ::kernel::sys::raw::c_void,
    pub oid_arg2: intmax_t,
    pub oid_name: *const ::kernel::sys::raw::c_char,
    pub oid_handler: ::core::option::Option<unsafe extern "C" fn(oidp:
                                                                     *mut sysctl_oid,
                                                                 arg1:
                                                                     *mut ::kernel::sys::raw::c_void,
                                                                 arg2:
                                                                     intmax_t,
                                                                 req:
                                                                     *mut sysctl_req)
                                                -> ::kernel::sys::raw::c_int>,
    pub oid_fmt: *const ::kernel::sys::raw::c_char,
    pub oid_refcnt: ::kernel::sys::raw::c_int,
    pub oid_running: u_int,
    pub oid_descr: *const ::kernel::sys::raw::c_char,
    pub oid_label: *const ::kernel::sys::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sysctl_oid__bindgen_ty_1 {
    pub sle_next: *mut sysctl_oid,
}
#[test]
fn bindgen_test_layout_sysctl_oid__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<sysctl_oid__bindgen_ty_1>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( sysctl_oid__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<sysctl_oid__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( sysctl_oid__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_oid__bindgen_ty_1 ) ) . sle_next
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                sysctl_oid__bindgen_ty_1 ) , "::" , stringify ! ( sle_next )
                ));
}
impl Clone for sysctl_oid__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for sysctl_oid__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_sysctl_oid() {
    assert_eq!(::core::mem::size_of::<sysctl_oid>() , 96usize , concat ! (
               "Size of: " , stringify ! ( sysctl_oid ) ));
    assert_eq! (::core::mem::align_of::<sysctl_oid>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sysctl_oid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_oid ) ) . oid_children as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sysctl_oid ) , "::" ,
                stringify ! ( oid_children ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_oid ) ) . oid_parent as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sysctl_oid ) , "::" ,
                stringify ! ( oid_parent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_oid ) ) . oid_link as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( sysctl_oid ) , "::" ,
                stringify ! ( oid_link ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_oid ) ) . oid_number as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( sysctl_oid ) , "::" ,
                stringify ! ( oid_number ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_oid ) ) . oid_kind as * const _ as
                usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( sysctl_oid ) , "::" ,
                stringify ! ( oid_kind ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_oid ) ) . oid_arg1 as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( sysctl_oid ) , "::" ,
                stringify ! ( oid_arg1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_oid ) ) . oid_arg2 as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( sysctl_oid ) , "::" ,
                stringify ! ( oid_arg2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_oid ) ) . oid_name as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( sysctl_oid ) , "::" ,
                stringify ! ( oid_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_oid ) ) . oid_handler as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( sysctl_oid ) , "::" ,
                stringify ! ( oid_handler ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_oid ) ) . oid_fmt as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( sysctl_oid ) , "::" ,
                stringify ! ( oid_fmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_oid ) ) . oid_refcnt as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( sysctl_oid ) , "::" ,
                stringify ! ( oid_refcnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_oid ) ) . oid_running as * const _
                as usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( sysctl_oid ) , "::" ,
                stringify ! ( oid_running ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_oid ) ) . oid_descr as * const _
                as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( sysctl_oid ) , "::" ,
                stringify ! ( oid_descr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_oid ) ) . oid_label as * const _
                as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( sysctl_oid ) , "::" ,
                stringify ! ( oid_label ) ));
}
impl Clone for sysctl_oid {
    fn clone(&self) -> Self { *self }
}
impl Default for sysctl_oid {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    pub fn sysctl_handle_bool(oidp: *mut sysctl_oid,
                              arg1: *mut ::kernel::sys::raw::c_void,
                              arg2: intmax_t, req: *mut sysctl_req)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sysctl_handle_8(oidp: *mut sysctl_oid,
                           arg1: *mut ::kernel::sys::raw::c_void,
                           arg2: intmax_t, req: *mut sysctl_req)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sysctl_handle_16(oidp: *mut sysctl_oid,
                            arg1: *mut ::kernel::sys::raw::c_void,
                            arg2: intmax_t, req: *mut sysctl_req)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sysctl_handle_32(oidp: *mut sysctl_oid,
                            arg1: *mut ::kernel::sys::raw::c_void,
                            arg2: intmax_t, req: *mut sysctl_req)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sysctl_handle_64(oidp: *mut sysctl_oid,
                            arg1: *mut ::kernel::sys::raw::c_void,
                            arg2: intmax_t, req: *mut sysctl_req)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sysctl_handle_int(oidp: *mut sysctl_oid,
                             arg1: *mut ::kernel::sys::raw::c_void,
                             arg2: intmax_t, req: *mut sysctl_req)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sysctl_msec_to_ticks(oidp: *mut sysctl_oid,
                                arg1: *mut ::kernel::sys::raw::c_void,
                                arg2: intmax_t, req: *mut sysctl_req)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sysctl_handle_long(oidp: *mut sysctl_oid,
                              arg1: *mut ::kernel::sys::raw::c_void,
                              arg2: intmax_t, req: *mut sysctl_req)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sysctl_handle_string(oidp: *mut sysctl_oid,
                                arg1: *mut ::kernel::sys::raw::c_void,
                                arg2: intmax_t, req: *mut sysctl_req)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sysctl_handle_opaque(oidp: *mut sysctl_oid,
                                arg1: *mut ::kernel::sys::raw::c_void,
                                arg2: intmax_t, req: *mut sysctl_req)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sysctl_handle_counter_u64(oidp: *mut sysctl_oid,
                                     arg1: *mut ::kernel::sys::raw::c_void,
                                     arg2: intmax_t, req: *mut sysctl_req)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sysctl_handle_counter_u64_array(oidp: *mut sysctl_oid,
                                           arg1:
                                               *mut ::kernel::sys::raw::c_void,
                                           arg2: intmax_t,
                                           req: *mut sysctl_req)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sysctl_handle_uma_zone_max(oidp: *mut sysctl_oid,
                                      arg1: *mut ::kernel::sys::raw::c_void,
                                      arg2: intmax_t, req: *mut sysctl_req)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sysctl_handle_uma_zone_cur(oidp: *mut sysctl_oid,
                                      arg1: *mut ::kernel::sys::raw::c_void,
                                      arg2: intmax_t, req: *mut sysctl_req)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sysctl_dpcpu_int(oidp: *mut sysctl_oid,
                            arg1: *mut ::kernel::sys::raw::c_void,
                            arg2: intmax_t, req: *mut sysctl_req)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sysctl_dpcpu_long(oidp: *mut sysctl_oid,
                             arg1: *mut ::kernel::sys::raw::c_void,
                             arg2: intmax_t, req: *mut sysctl_req)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sysctl_dpcpu_quad(oidp: *mut sysctl_oid,
                             arg1: *mut ::kernel::sys::raw::c_void,
                             arg2: intmax_t, req: *mut sysctl_req)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sysctl_register_oid(oidp: *mut sysctl_oid);
}
extern "C" {
    pub fn sysctl_register_disabled_oid(oidp: *mut sysctl_oid);
}
extern "C" {
    pub fn sysctl_enable_oid(oidp: *mut sysctl_oid);
}
extern "C" {
    pub fn sysctl_unregister_oid(oidp: *mut sysctl_oid);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sysctl_ctx_entry {
    pub entry: *mut sysctl_oid,
    pub link: sysctl_ctx_entry__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sysctl_ctx_entry__bindgen_ty_1 {
    pub tqe_next: *mut sysctl_ctx_entry,
    pub tqe_prev: *mut *mut sysctl_ctx_entry,
}
#[test]
fn bindgen_test_layout_sysctl_ctx_entry__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<sysctl_ctx_entry__bindgen_ty_1>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( sysctl_ctx_entry__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<sysctl_ctx_entry__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( sysctl_ctx_entry__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_ctx_entry__bindgen_ty_1 ) ) .
                tqe_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                sysctl_ctx_entry__bindgen_ty_1 ) , "::" , stringify ! (
                tqe_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_ctx_entry__bindgen_ty_1 ) ) .
                tqe_prev as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                sysctl_ctx_entry__bindgen_ty_1 ) , "::" , stringify ! (
                tqe_prev ) ));
}
impl Clone for sysctl_ctx_entry__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for sysctl_ctx_entry__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_sysctl_ctx_entry() {
    assert_eq!(::core::mem::size_of::<sysctl_ctx_entry>() , 24usize , concat !
               ( "Size of: " , stringify ! ( sysctl_ctx_entry ) ));
    assert_eq! (::core::mem::align_of::<sysctl_ctx_entry>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( sysctl_ctx_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_ctx_entry ) ) . entry as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sysctl_ctx_entry ) ,
                "::" , stringify ! ( entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_ctx_entry ) ) . link as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sysctl_ctx_entry ) ,
                "::" , stringify ! ( link ) ));
}
impl Clone for sysctl_ctx_entry {
    fn clone(&self) -> Self { *self }
}
impl Default for sysctl_ctx_entry {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sysctl_ctx_list {
    pub tqh_first: *mut sysctl_ctx_entry,
    pub tqh_last: *mut *mut sysctl_ctx_entry,
}
#[test]
fn bindgen_test_layout_sysctl_ctx_list() {
    assert_eq!(::core::mem::size_of::<sysctl_ctx_list>() , 16usize , concat !
               ( "Size of: " , stringify ! ( sysctl_ctx_list ) ));
    assert_eq! (::core::mem::align_of::<sysctl_ctx_list>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( sysctl_ctx_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_ctx_list ) ) . tqh_first as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sysctl_ctx_list ) ,
                "::" , stringify ! ( tqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_ctx_list ) ) . tqh_last as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sysctl_ctx_list ) ,
                "::" , stringify ! ( tqh_last ) ));
}
impl Clone for sysctl_ctx_list {
    fn clone(&self) -> Self { *self }
}
impl Default for sysctl_ctx_list {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    #[link_name = "sysctl__children"]
    pub static mut sysctl__children: sysctl_oid_list;
}
extern "C" {
    #[link_name = "sysctl___kern"]
    pub static mut sysctl___kern: sysctl_oid;
}
extern "C" {
    #[link_name = "sysctl___kern_features"]
    pub static mut sysctl___kern_features: sysctl_oid;
}
extern "C" {
    #[link_name = "sysctl___kern_ipc"]
    pub static mut sysctl___kern_ipc: sysctl_oid;
}
extern "C" {
    #[link_name = "sysctl___kern_proc"]
    pub static mut sysctl___kern_proc: sysctl_oid;
}
extern "C" {
    #[link_name = "sysctl___kern_sched"]
    pub static mut sysctl___kern_sched: sysctl_oid;
}
extern "C" {
    #[link_name = "sysctl___kern_sched_stats"]
    pub static mut sysctl___kern_sched_stats: sysctl_oid;
}
extern "C" {
    #[link_name = "sysctl___sysctl"]
    pub static mut sysctl___sysctl: sysctl_oid;
}
extern "C" {
    #[link_name = "sysctl___vm"]
    pub static mut sysctl___vm: sysctl_oid;
}
extern "C" {
    #[link_name = "sysctl___vm_stats"]
    pub static mut sysctl___vm_stats: sysctl_oid;
}
extern "C" {
    #[link_name = "sysctl___vm_stats_misc"]
    pub static mut sysctl___vm_stats_misc: sysctl_oid;
}
extern "C" {
    #[link_name = "sysctl___vfs"]
    pub static mut sysctl___vfs: sysctl_oid;
}
extern "C" {
    #[link_name = "sysctl___net"]
    pub static mut sysctl___net: sysctl_oid;
}
extern "C" {
    #[link_name = "sysctl___debug"]
    pub static mut sysctl___debug: sysctl_oid;
}
extern "C" {
    #[link_name = "sysctl___debug_sizeof"]
    pub static mut sysctl___debug_sizeof: sysctl_oid;
}
extern "C" {
    #[link_name = "sysctl___dev"]
    pub static mut sysctl___dev: sysctl_oid;
}
extern "C" {
    #[link_name = "sysctl___hw"]
    pub static mut sysctl___hw: sysctl_oid;
}
extern "C" {
    #[link_name = "sysctl___hw_bus"]
    pub static mut sysctl___hw_bus: sysctl_oid;
}
extern "C" {
    #[link_name = "sysctl___hw_bus_devices"]
    pub static mut sysctl___hw_bus_devices: sysctl_oid;
}
extern "C" {
    #[link_name = "sysctl___hw_bus_info"]
    pub static mut sysctl___hw_bus_info: sysctl_oid;
}
extern "C" {
    #[link_name = "sysctl___machdep"]
    pub static mut sysctl___machdep: sysctl_oid;
}
extern "C" {
    #[link_name = "sysctl___user"]
    pub static mut sysctl___user: sysctl_oid;
}
extern "C" {
    #[link_name = "sysctl___compat"]
    pub static mut sysctl___compat: sysctl_oid;
}
extern "C" {
    #[link_name = "sysctl___regression"]
    pub static mut sysctl___regression: sysctl_oid;
}
extern "C" {
    #[link_name = "sysctl___security"]
    pub static mut sysctl___security: sysctl_oid;
}
extern "C" {
    #[link_name = "sysctl___security_bsd"]
    pub static mut sysctl___security_bsd: sysctl_oid;
}
extern "C" {
    #[link_name = "machine"]
    pub static mut machine: [::kernel::sys::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "osrelease"]
    pub static mut osrelease: [::kernel::sys::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "ostype"]
    pub static mut ostype: [::kernel::sys::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "kern_ident"]
    pub static mut kern_ident: [::kernel::sys::raw::c_char; 0usize];
}
extern "C" {
    pub fn sysctl_add_oid(clist: *mut sysctl_ctx_list,
                          parent: *mut sysctl_oid_list,
                          nbr: ::kernel::sys::raw::c_int,
                          name: *const ::kernel::sys::raw::c_char,
                          kind: ::kernel::sys::raw::c_int,
                          arg1: *mut ::kernel::sys::raw::c_void,
                          arg2: intmax_t,
                          handler:
                              ::core::option::Option<unsafe extern "C" fn(oidp:
                                                                              *mut sysctl_oid,
                                                                          arg1:
                                                                              *mut ::kernel::sys::raw::c_void,
                                                                          arg2:
                                                                              intmax_t,
                                                                          req:
                                                                              *mut sysctl_req)
                                                         ->
                                                             ::kernel::sys::raw::c_int>,
                          fmt: *const ::kernel::sys::raw::c_char,
                          descr: *const ::kernel::sys::raw::c_char,
                          label: *const ::kernel::sys::raw::c_char)
     -> *mut sysctl_oid;
}
extern "C" {
    pub fn sysctl_remove_name(parent: *mut sysctl_oid,
                              name: *const ::kernel::sys::raw::c_char,
                              del: ::kernel::sys::raw::c_int,
                              recurse: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sysctl_rename_oid(oidp: *mut sysctl_oid,
                             name: *const ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn sysctl_move_oid(oidp: *mut sysctl_oid,
                           parent: *mut sysctl_oid_list)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sysctl_remove_oid(oidp: *mut sysctl_oid,
                             del: ::kernel::sys::raw::c_int,
                             recurse: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sysctl_ctx_init(clist: *mut sysctl_ctx_list)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sysctl_ctx_free(clist: *mut sysctl_ctx_list)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sysctl_ctx_entry_add(clist: *mut sysctl_ctx_list,
                                oidp: *mut sysctl_oid)
     -> *mut sysctl_ctx_entry;
}
extern "C" {
    pub fn sysctl_ctx_entry_find(clist: *mut sysctl_ctx_list,
                                 oidp: *mut sysctl_oid)
     -> *mut sysctl_ctx_entry;
}
extern "C" {
    pub fn sysctl_ctx_entry_del(clist: *mut sysctl_ctx_list,
                                oidp: *mut sysctl_oid)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn kernel_sysctl(td: *mut thread,
                         name: *mut ::kernel::sys::raw::c_int, namelen: u_int,
                         old: *mut ::kernel::sys::raw::c_void,
                         oldlenp: *mut usize,
                         new: *mut ::kernel::sys::raw::c_void, newlen: usize,
                         retval: *mut usize, flags: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn kernel_sysctlbyname(td: *mut thread,
                               name: *mut ::kernel::sys::raw::c_char,
                               old: *mut ::kernel::sys::raw::c_void,
                               oldlenp: *mut usize,
                               new: *mut ::kernel::sys::raw::c_void,
                               newlen: usize, retval: *mut usize,
                               flags: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn userland_sysctl(td: *mut thread,
                           name: *mut ::kernel::sys::raw::c_int,
                           namelen: u_int,
                           old: *mut ::kernel::sys::raw::c_void,
                           oldlenp: *mut usize,
                           inkernel: ::kernel::sys::raw::c_int,
                           new: *mut ::kernel::sys::raw::c_void,
                           newlen: usize, retval: *mut usize,
                           flags: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sysctl_find_oid(name: *mut ::kernel::sys::raw::c_int,
                           namelen: u_int, noid: *mut *mut sysctl_oid,
                           nindx: *mut ::kernel::sys::raw::c_int,
                           req: *mut sysctl_req) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sysctl_wlock();
}
extern "C" {
    pub fn sysctl_wunlock();
}
extern "C" {
    pub fn sysctl_wire_old_buffer(req: *mut sysctl_req, len: usize)
     -> ::kernel::sys::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sbuf {
    _unused: [u8; 0],
}
extern "C" {
    pub fn sbuf_new_for_sysctl(arg1: *mut sbuf,
                               arg2: *mut ::kernel::sys::raw::c_char,
                               arg3: ::kernel::sys::raw::c_int,
                               arg4: *mut sysctl_req) -> *mut sbuf;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __va_list_tag {
    pub gp_offset: ::kernel::sys::raw::c_uint,
    pub fp_offset: ::kernel::sys::raw::c_uint,
    pub overflow_arg_area: *mut ::kernel::sys::raw::c_void,
    pub reg_save_area: *mut ::kernel::sys::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(::core::mem::size_of::<__va_list_tag>() , 24usize , concat ! (
               "Size of: " , stringify ! ( __va_list_tag ) ));
    assert_eq! (::core::mem::align_of::<__va_list_tag>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __va_list_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . gp_offset as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( gp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . fp_offset as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( fp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . overflow_arg_area as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( overflow_arg_area ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . reg_save_area as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( reg_save_area ) ));
}
impl Clone for __va_list_tag {
    fn clone(&self) -> Self { *self }
}
impl Default for __va_list_tag {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
