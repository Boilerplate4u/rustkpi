/* automatically generated by rust-bindgen */

pub const __GNUCLIKE_ASM: ::kernel::sys::raw::c_uint = 3;
pub const __GNUCLIKE___TYPEOF: ::kernel::sys::raw::c_uint = 1;
pub const __GNUCLIKE___OFFSETOF: ::kernel::sys::raw::c_uint = 1;
pub const __GNUCLIKE___SECTION: ::kernel::sys::raw::c_uint = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: ::kernel::sys::raw::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: ::kernel::sys::raw::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: ::kernel::sys::raw::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: ::kernel::sys::raw::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: ::kernel::sys::raw::c_uint = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: ::kernel::sys::raw::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: ::kernel::sys::raw::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: ::kernel::sys::raw::c_uint = 1;
pub const __CC_SUPPORTS_INLINE: ::kernel::sys::raw::c_uint = 1;
pub const __CC_SUPPORTS___INLINE: ::kernel::sys::raw::c_uint = 1;
pub const __CC_SUPPORTS___INLINE__: ::kernel::sys::raw::c_uint = 1;
pub const __CC_SUPPORTS___FUNC__: ::kernel::sys::raw::c_uint = 1;
pub const __CC_SUPPORTS_WARNING: ::kernel::sys::raw::c_uint = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: ::kernel::sys::raw::c_uint = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: ::kernel::sys::raw::c_uint = 1;
pub const __POSIX_VISIBLE: ::kernel::sys::raw::c_uint = 200809;
pub const __XSI_VISIBLE: ::kernel::sys::raw::c_uint = 700;
pub const __BSD_VISIBLE: ::kernel::sys::raw::c_uint = 1;
pub const __ISO_C_VISIBLE: ::kernel::sys::raw::c_uint = 2011;
pub const __EXT1_VISIBLE: ::kernel::sys::raw::c_uint = 1;
pub const __CHAR_BIT: ::kernel::sys::raw::c_uint = 8;
pub const __SCHAR_MAX: ::kernel::sys::raw::c_uint = 127;
pub const __SCHAR_MIN: ::kernel::sys::raw::c_int = -128;
pub const __UCHAR_MAX: ::kernel::sys::raw::c_uint = 255;
pub const __USHRT_MAX: ::kernel::sys::raw::c_uint = 65535;
pub const __SHRT_MAX: ::kernel::sys::raw::c_uint = 32767;
pub const __SHRT_MIN: ::kernel::sys::raw::c_int = -32768;
pub const __UINT_MAX: ::kernel::sys::raw::c_uint = 4294967295;
pub const __INT_MAX: ::kernel::sys::raw::c_uint = 2147483647;
pub const __INT_MIN: ::kernel::sys::raw::c_int = -2147483648;
pub const __ULONG_MAX: ::kernel::sys::raw::c_int = -1;
pub const __LONG_MAX: ::kernel::sys::raw::c_ulonglong = 9223372036854775807;
pub const __LONG_MIN: ::kernel::sys::raw::c_longlong = -9223372036854775808;
pub const __ULLONG_MAX: ::kernel::sys::raw::c_int = -1;
pub const __LLONG_MAX: ::kernel::sys::raw::c_ulonglong = 9223372036854775807;
pub const __LLONG_MIN: ::kernel::sys::raw::c_longlong = -9223372036854775808;
pub const __SSIZE_MAX: ::kernel::sys::raw::c_ulonglong = 9223372036854775807;
pub const __SIZE_T_MAX: ::kernel::sys::raw::c_int = -1;
pub const __OFF_MAX: ::kernel::sys::raw::c_ulonglong = 9223372036854775807;
pub const __OFF_MIN: ::kernel::sys::raw::c_longlong = -9223372036854775808;
pub const __UQUAD_MAX: ::kernel::sys::raw::c_int = -1;
pub const __QUAD_MAX: ::kernel::sys::raw::c_ulonglong = 9223372036854775807;
pub const __QUAD_MIN: ::kernel::sys::raw::c_longlong = -9223372036854775808;
pub const __LONG_BIT: ::kernel::sys::raw::c_uint = 64;
pub const __WORD_BIT: ::kernel::sys::raw::c_uint = 32;
pub const __MINSIGSTKSZ: ::kernel::sys::raw::c_uint = 2048;
pub const __WCHAR_MIN: ::kernel::sys::raw::c_int = -2147483648;
pub const __WCHAR_MAX: ::kernel::sys::raw::c_uint = 2147483647;
pub const _QUAD_HIGHWORD: ::kernel::sys::raw::c_uint = 1;
pub const _QUAD_LOWWORD: ::kernel::sys::raw::c_uint = 0;
pub const _LITTLE_ENDIAN: ::kernel::sys::raw::c_uint = 1234;
pub const _BIG_ENDIAN: ::kernel::sys::raw::c_uint = 4321;
pub const _PDP_ENDIAN: ::kernel::sys::raw::c_uint = 3412;
pub const _BYTE_ORDER: ::kernel::sys::raw::c_uint = 1234;
pub const LITTLE_ENDIAN: ::kernel::sys::raw::c_uint = 1234;
pub const BIG_ENDIAN: ::kernel::sys::raw::c_uint = 4321;
pub const PDP_ENDIAN: ::kernel::sys::raw::c_uint = 3412;
pub const BYTE_ORDER: ::kernel::sys::raw::c_uint = 1234;
pub const __bool_true_false_are_defined: ::kernel::sys::raw::c_uint = 1;
pub const false_: ::kernel::sys::raw::c_uint = 0;
pub const true_: ::kernel::sys::raw::c_uint = 1;
pub const _SIG_WORDS: ::kernel::sys::raw::c_uint = 4;
pub const _SIG_MAXSIG: ::kernel::sys::raw::c_uint = 128;
pub const FD_SETSIZE: ::kernel::sys::raw::c_uint = 1024;
pub const KTR_GEN: ::kernel::sys::raw::c_uint = 1;
pub const KTR_NET: ::kernel::sys::raw::c_uint = 2;
pub const KTR_DEV: ::kernel::sys::raw::c_uint = 4;
pub const KTR_LOCK: ::kernel::sys::raw::c_uint = 8;
pub const KTR_SMP: ::kernel::sys::raw::c_uint = 16;
pub const KTR_SUBSYS: ::kernel::sys::raw::c_uint = 32;
pub const KTR_PMAP: ::kernel::sys::raw::c_uint = 64;
pub const KTR_MALLOC: ::kernel::sys::raw::c_uint = 128;
pub const KTR_TRAP: ::kernel::sys::raw::c_uint = 256;
pub const KTR_INTR: ::kernel::sys::raw::c_uint = 512;
pub const KTR_SIG: ::kernel::sys::raw::c_uint = 1024;
pub const KTR_SPARE2: ::kernel::sys::raw::c_uint = 2048;
pub const KTR_PROC: ::kernel::sys::raw::c_uint = 4096;
pub const KTR_SYSC: ::kernel::sys::raw::c_uint = 8192;
pub const KTR_INIT: ::kernel::sys::raw::c_uint = 16384;
pub const KTR_SPARE3: ::kernel::sys::raw::c_uint = 32768;
pub const KTR_SPARE4: ::kernel::sys::raw::c_uint = 65536;
pub const KTR_EVH: ::kernel::sys::raw::c_uint = 131072;
pub const KTR_VFS: ::kernel::sys::raw::c_uint = 262144;
pub const KTR_VOP: ::kernel::sys::raw::c_uint = 524288;
pub const KTR_VM: ::kernel::sys::raw::c_uint = 1048576;
pub const KTR_INET: ::kernel::sys::raw::c_uint = 2097152;
pub const KTR_RUNQ: ::kernel::sys::raw::c_uint = 4194304;
pub const KTR_SPARE5: ::kernel::sys::raw::c_uint = 8388608;
pub const KTR_UMA: ::kernel::sys::raw::c_uint = 16777216;
pub const KTR_CALLOUT: ::kernel::sys::raw::c_uint = 33554432;
pub const KTR_GEOM: ::kernel::sys::raw::c_uint = 67108864;
pub const KTR_BUSDMA: ::kernel::sys::raw::c_uint = 134217728;
pub const KTR_INET6: ::kernel::sys::raw::c_uint = 268435456;
pub const KTR_SCHED: ::kernel::sys::raw::c_uint = 536870912;
pub const KTR_BUF: ::kernel::sys::raw::c_uint = 1073741824;
pub const KTR_PTRACE: ::kernel::sys::raw::c_uint = 2147483648;
pub const KTR_ALL: ::kernel::sys::raw::c_uint = 4294967295;
pub const KTR_COMPILE: ::kernel::sys::raw::c_uint = 0;
pub const LC_SLEEPLOCK: ::kernel::sys::raw::c_uint = 1;
pub const LC_SPINLOCK: ::kernel::sys::raw::c_uint = 2;
pub const LC_SLEEPABLE: ::kernel::sys::raw::c_uint = 4;
pub const LC_RECURSABLE: ::kernel::sys::raw::c_uint = 8;
pub const LC_UPGRADABLE: ::kernel::sys::raw::c_uint = 16;
pub const LO_CLASSFLAGS: ::kernel::sys::raw::c_uint = 65535;
pub const LO_INITIALIZED: ::kernel::sys::raw::c_uint = 65536;
pub const LO_WITNESS: ::kernel::sys::raw::c_uint = 131072;
pub const LO_QUIET: ::kernel::sys::raw::c_uint = 262144;
pub const LO_RECURSABLE: ::kernel::sys::raw::c_uint = 524288;
pub const LO_SLEEPABLE: ::kernel::sys::raw::c_uint = 1048576;
pub const LO_UPGRADABLE: ::kernel::sys::raw::c_uint = 2097152;
pub const LO_DUPOK: ::kernel::sys::raw::c_uint = 4194304;
pub const LO_IS_VNODE: ::kernel::sys::raw::c_uint = 8388608;
pub const LO_CLASSMASK: ::kernel::sys::raw::c_uint = 251658240;
pub const LO_NOPROFILE: ::kernel::sys::raw::c_uint = 268435456;
pub const LO_NEW: ::kernel::sys::raw::c_uint = 536870912;
pub const LO_CLASSSHIFT: ::kernel::sys::raw::c_uint = 24;
pub const LOCK_CLASS_MAX: ::kernel::sys::raw::c_uint = 15;
pub const LOP_NEWORDER: ::kernel::sys::raw::c_uint = 1;
pub const LOP_QUIET: ::kernel::sys::raw::c_uint = 2;
pub const LOP_TRYLOCK: ::kernel::sys::raw::c_uint = 4;
pub const LOP_EXCLUSIVE: ::kernel::sys::raw::c_uint = 8;
pub const LOP_DUPOK: ::kernel::sys::raw::c_uint = 16;
pub const LA_MASKASSERT: ::kernel::sys::raw::c_uint = 255;
pub const LA_UNLOCKED: ::kernel::sys::raw::c_uint = 0;
pub const LA_LOCKED: ::kernel::sys::raw::c_uint = 1;
pub const LA_SLOCKED: ::kernel::sys::raw::c_uint = 2;
pub const LA_XLOCKED: ::kernel::sys::raw::c_uint = 4;
pub const LA_RECURSED: ::kernel::sys::raw::c_uint = 8;
pub const LA_NOTRECURSED: ::kernel::sys::raw::c_uint = 16;
pub const LOCK_DEBUG: ::kernel::sys::raw::c_uint = 1;
pub const KTR_VERSION: ::kernel::sys::raw::c_uint = 2;
pub const KTR_PARMS: ::kernel::sys::raw::c_uint = 6;
pub const BSD: ::kernel::sys::raw::c_uint = 199506;
pub const BSD4_3: ::kernel::sys::raw::c_uint = 1;
pub const BSD4_4: ::kernel::sys::raw::c_uint = 1;
pub const __FreeBSD_version: ::kernel::sys::raw::c_uint = 1200064;
pub const P_OSREL_SIGWAIT: ::kernel::sys::raw::c_uint = 700000;
pub const P_OSREL_SIGSEGV: ::kernel::sys::raw::c_uint = 700004;
pub const P_OSREL_MAP_ANON: ::kernel::sys::raw::c_uint = 800104;
pub const P_OSREL_MAP_FSTRICT: ::kernel::sys::raw::c_uint = 1100036;
pub const P_OSREL_SHUTDOWN_ENOTCONN: ::kernel::sys::raw::c_uint = 1100077;
pub const P_OSREL_MAP_GUARD: ::kernel::sys::raw::c_uint = 1200035;
pub const P_OSREL_WRFSBASE: ::kernel::sys::raw::c_uint = 1200041;
pub const P_OSREL_CK_CYLGRP: ::kernel::sys::raw::c_uint = 1200046;
pub const P_OSREL_VMTOTAL64: ::kernel::sys::raw::c_uint = 1200054;
pub const ARG_MAX: ::kernel::sys::raw::c_uint = 262144;
pub const CHILD_MAX: ::kernel::sys::raw::c_uint = 40;
pub const MAX_CANON: ::kernel::sys::raw::c_uint = 255;
pub const MAX_INPUT: ::kernel::sys::raw::c_uint = 255;
pub const NAME_MAX: ::kernel::sys::raw::c_uint = 255;
pub const NGROUPS_MAX: ::kernel::sys::raw::c_uint = 1023;
pub const OPEN_MAX: ::kernel::sys::raw::c_uint = 64;
pub const PATH_MAX: ::kernel::sys::raw::c_uint = 1024;
pub const PIPE_BUF: ::kernel::sys::raw::c_uint = 512;
pub const IOV_MAX: ::kernel::sys::raw::c_uint = 1024;
pub const MAXCOMLEN: ::kernel::sys::raw::c_uint = 19;
pub const MAXINTERP: ::kernel::sys::raw::c_uint = 1024;
pub const MAXLOGNAME: ::kernel::sys::raw::c_uint = 33;
pub const MAXUPRC: ::kernel::sys::raw::c_uint = 40;
pub const NCARGS: ::kernel::sys::raw::c_uint = 262144;
pub const NGROUPS: ::kernel::sys::raw::c_uint = 1024;
pub const NOFILE: ::kernel::sys::raw::c_uint = 64;
pub const NOGROUP: ::kernel::sys::raw::c_uint = 65535;
pub const MAXHOSTNAMELEN: ::kernel::sys::raw::c_uint = 256;
pub const SPECNAMELEN: ::kernel::sys::raw::c_uint = 63;
pub const EPERM: ::kernel::sys::raw::c_uint = 1;
pub const ENOENT: ::kernel::sys::raw::c_uint = 2;
pub const ESRCH: ::kernel::sys::raw::c_uint = 3;
pub const EINTR: ::kernel::sys::raw::c_uint = 4;
pub const EIO: ::kernel::sys::raw::c_uint = 5;
pub const ENXIO: ::kernel::sys::raw::c_uint = 6;
pub const E2BIG: ::kernel::sys::raw::c_uint = 7;
pub const ENOEXEC: ::kernel::sys::raw::c_uint = 8;
pub const EBADF: ::kernel::sys::raw::c_uint = 9;
pub const ECHILD: ::kernel::sys::raw::c_uint = 10;
pub const EDEADLK: ::kernel::sys::raw::c_uint = 11;
pub const ENOMEM: ::kernel::sys::raw::c_uint = 12;
pub const EACCES: ::kernel::sys::raw::c_uint = 13;
pub const EFAULT: ::kernel::sys::raw::c_uint = 14;
pub const ENOTBLK: ::kernel::sys::raw::c_uint = 15;
pub const EBUSY: ::kernel::sys::raw::c_uint = 16;
pub const EEXIST: ::kernel::sys::raw::c_uint = 17;
pub const EXDEV: ::kernel::sys::raw::c_uint = 18;
pub const ENODEV: ::kernel::sys::raw::c_uint = 19;
pub const ENOTDIR: ::kernel::sys::raw::c_uint = 20;
pub const EISDIR: ::kernel::sys::raw::c_uint = 21;
pub const EINVAL: ::kernel::sys::raw::c_uint = 22;
pub const ENFILE: ::kernel::sys::raw::c_uint = 23;
pub const EMFILE: ::kernel::sys::raw::c_uint = 24;
pub const ENOTTY: ::kernel::sys::raw::c_uint = 25;
pub const ETXTBSY: ::kernel::sys::raw::c_uint = 26;
pub const EFBIG: ::kernel::sys::raw::c_uint = 27;
pub const ENOSPC: ::kernel::sys::raw::c_uint = 28;
pub const ESPIPE: ::kernel::sys::raw::c_uint = 29;
pub const EROFS: ::kernel::sys::raw::c_uint = 30;
pub const EMLINK: ::kernel::sys::raw::c_uint = 31;
pub const EPIPE: ::kernel::sys::raw::c_uint = 32;
pub const EDOM: ::kernel::sys::raw::c_uint = 33;
pub const ERANGE: ::kernel::sys::raw::c_uint = 34;
pub const EAGAIN: ::kernel::sys::raw::c_uint = 35;
pub const EWOULDBLOCK: ::kernel::sys::raw::c_uint = 35;
pub const EINPROGRESS: ::kernel::sys::raw::c_uint = 36;
pub const EALREADY: ::kernel::sys::raw::c_uint = 37;
pub const ENOTSOCK: ::kernel::sys::raw::c_uint = 38;
pub const EDESTADDRREQ: ::kernel::sys::raw::c_uint = 39;
pub const EMSGSIZE: ::kernel::sys::raw::c_uint = 40;
pub const EPROTOTYPE: ::kernel::sys::raw::c_uint = 41;
pub const ENOPROTOOPT: ::kernel::sys::raw::c_uint = 42;
pub const EPROTONOSUPPORT: ::kernel::sys::raw::c_uint = 43;
pub const ESOCKTNOSUPPORT: ::kernel::sys::raw::c_uint = 44;
pub const EOPNOTSUPP: ::kernel::sys::raw::c_uint = 45;
pub const ENOTSUP: ::kernel::sys::raw::c_uint = 45;
pub const EPFNOSUPPORT: ::kernel::sys::raw::c_uint = 46;
pub const EAFNOSUPPORT: ::kernel::sys::raw::c_uint = 47;
pub const EADDRINUSE: ::kernel::sys::raw::c_uint = 48;
pub const EADDRNOTAVAIL: ::kernel::sys::raw::c_uint = 49;
pub const ENETDOWN: ::kernel::sys::raw::c_uint = 50;
pub const ENETUNREACH: ::kernel::sys::raw::c_uint = 51;
pub const ENETRESET: ::kernel::sys::raw::c_uint = 52;
pub const ECONNABORTED: ::kernel::sys::raw::c_uint = 53;
pub const ECONNRESET: ::kernel::sys::raw::c_uint = 54;
pub const ENOBUFS: ::kernel::sys::raw::c_uint = 55;
pub const EISCONN: ::kernel::sys::raw::c_uint = 56;
pub const ENOTCONN: ::kernel::sys::raw::c_uint = 57;
pub const ESHUTDOWN: ::kernel::sys::raw::c_uint = 58;
pub const ETOOMANYREFS: ::kernel::sys::raw::c_uint = 59;
pub const ETIMEDOUT: ::kernel::sys::raw::c_uint = 60;
pub const ECONNREFUSED: ::kernel::sys::raw::c_uint = 61;
pub const ELOOP: ::kernel::sys::raw::c_uint = 62;
pub const ENAMETOOLONG: ::kernel::sys::raw::c_uint = 63;
pub const EHOSTDOWN: ::kernel::sys::raw::c_uint = 64;
pub const EHOSTUNREACH: ::kernel::sys::raw::c_uint = 65;
pub const ENOTEMPTY: ::kernel::sys::raw::c_uint = 66;
pub const EPROCLIM: ::kernel::sys::raw::c_uint = 67;
pub const EUSERS: ::kernel::sys::raw::c_uint = 68;
pub const EDQUOT: ::kernel::sys::raw::c_uint = 69;
pub const ESTALE: ::kernel::sys::raw::c_uint = 70;
pub const EREMOTE: ::kernel::sys::raw::c_uint = 71;
pub const EBADRPC: ::kernel::sys::raw::c_uint = 72;
pub const ERPCMISMATCH: ::kernel::sys::raw::c_uint = 73;
pub const EPROGUNAVAIL: ::kernel::sys::raw::c_uint = 74;
pub const EPROGMISMATCH: ::kernel::sys::raw::c_uint = 75;
pub const EPROCUNAVAIL: ::kernel::sys::raw::c_uint = 76;
pub const ENOLCK: ::kernel::sys::raw::c_uint = 77;
pub const ENOSYS: ::kernel::sys::raw::c_uint = 78;
pub const EFTYPE: ::kernel::sys::raw::c_uint = 79;
pub const EAUTH: ::kernel::sys::raw::c_uint = 80;
pub const ENEEDAUTH: ::kernel::sys::raw::c_uint = 81;
pub const EIDRM: ::kernel::sys::raw::c_uint = 82;
pub const ENOMSG: ::kernel::sys::raw::c_uint = 83;
pub const EOVERFLOW: ::kernel::sys::raw::c_uint = 84;
pub const ECANCELED: ::kernel::sys::raw::c_uint = 85;
pub const EILSEQ: ::kernel::sys::raw::c_uint = 86;
pub const ENOATTR: ::kernel::sys::raw::c_uint = 87;
pub const EDOOFUS: ::kernel::sys::raw::c_uint = 88;
pub const EBADMSG: ::kernel::sys::raw::c_uint = 89;
pub const EMULTIHOP: ::kernel::sys::raw::c_uint = 90;
pub const ENOLINK: ::kernel::sys::raw::c_uint = 91;
pub const EPROTO: ::kernel::sys::raw::c_uint = 92;
pub const ENOTCAPABLE: ::kernel::sys::raw::c_uint = 93;
pub const ECAPMODE: ::kernel::sys::raw::c_uint = 94;
pub const ENOTRECOVERABLE: ::kernel::sys::raw::c_uint = 95;
pub const EOWNERDEAD: ::kernel::sys::raw::c_uint = 96;
pub const ELAST: ::kernel::sys::raw::c_uint = 96;
pub const ERESTART: ::kernel::sys::raw::c_int = -1;
pub const EJUSTRETURN: ::kernel::sys::raw::c_int = -2;
pub const ENOIOCTL: ::kernel::sys::raw::c_int = -3;
pub const EDIRIOCTL: ::kernel::sys::raw::c_int = -4;
pub const ERELOOKUP: ::kernel::sys::raw::c_int = -5;
pub const DST_NONE: ::kernel::sys::raw::c_uint = 0;
pub const DST_USA: ::kernel::sys::raw::c_uint = 1;
pub const DST_AUST: ::kernel::sys::raw::c_uint = 2;
pub const DST_WET: ::kernel::sys::raw::c_uint = 3;
pub const DST_MET: ::kernel::sys::raw::c_uint = 4;
pub const DST_EET: ::kernel::sys::raw::c_uint = 5;
pub const DST_CAN: ::kernel::sys::raw::c_uint = 6;
pub const SBT_MAX: ::kernel::sys::raw::c_ulonglong = 9223372036854775807;
pub const ITIMER_REAL: ::kernel::sys::raw::c_uint = 0;
pub const ITIMER_VIRTUAL: ::kernel::sys::raw::c_uint = 1;
pub const ITIMER_PROF: ::kernel::sys::raw::c_uint = 2;
pub const CLOCK_REALTIME: ::kernel::sys::raw::c_uint = 0;
pub const CLOCK_VIRTUAL: ::kernel::sys::raw::c_uint = 1;
pub const CLOCK_PROF: ::kernel::sys::raw::c_uint = 2;
pub const CLOCK_MONOTONIC: ::kernel::sys::raw::c_uint = 4;
pub const CLOCK_UPTIME: ::kernel::sys::raw::c_uint = 5;
pub const CLOCK_UPTIME_PRECISE: ::kernel::sys::raw::c_uint = 7;
pub const CLOCK_UPTIME_FAST: ::kernel::sys::raw::c_uint = 8;
pub const CLOCK_REALTIME_PRECISE: ::kernel::sys::raw::c_uint = 9;
pub const CLOCK_REALTIME_FAST: ::kernel::sys::raw::c_uint = 10;
pub const CLOCK_MONOTONIC_PRECISE: ::kernel::sys::raw::c_uint = 11;
pub const CLOCK_MONOTONIC_FAST: ::kernel::sys::raw::c_uint = 12;
pub const CLOCK_SECOND: ::kernel::sys::raw::c_uint = 13;
pub const CLOCK_THREAD_CPUTIME_ID: ::kernel::sys::raw::c_uint = 14;
pub const CLOCK_PROCESS_CPUTIME_ID: ::kernel::sys::raw::c_uint = 15;
pub const TIMER_RELTIME: ::kernel::sys::raw::c_uint = 0;
pub const TIMER_ABSTIME: ::kernel::sys::raw::c_uint = 1;
pub const CPUCLOCK_WHICH_PID: ::kernel::sys::raw::c_uint = 0;
pub const CPUCLOCK_WHICH_TID: ::kernel::sys::raw::c_uint = 1;
pub const TC_DEFAULTPERC: ::kernel::sys::raw::c_uint = 5;
pub const PRI_ITHD: ::kernel::sys::raw::c_uint = 1;
pub const PRI_REALTIME: ::kernel::sys::raw::c_uint = 2;
pub const PRI_TIMESHARE: ::kernel::sys::raw::c_uint = 3;
pub const PRI_IDLE: ::kernel::sys::raw::c_uint = 4;
pub const PRI_FIFO_BIT: ::kernel::sys::raw::c_uint = 8;
pub const PRI_FIFO: ::kernel::sys::raw::c_uint = 10;
pub const PRI_MIN: ::kernel::sys::raw::c_uint = 0;
pub const PRI_MAX: ::kernel::sys::raw::c_uint = 255;
pub const PRI_MIN_ITHD: ::kernel::sys::raw::c_uint = 0;
pub const PI_REALTIME: ::kernel::sys::raw::c_uint = 0;
pub const PI_AV: ::kernel::sys::raw::c_uint = 4;
pub const PI_NET: ::kernel::sys::raw::c_uint = 8;
pub const PI_DISK: ::kernel::sys::raw::c_uint = 12;
pub const PI_TTY: ::kernel::sys::raw::c_uint = 16;
pub const PI_DULL: ::kernel::sys::raw::c_uint = 20;
pub const PI_SOFT: ::kernel::sys::raw::c_uint = 24;
pub const PRI_MIN_REALTIME: ::kernel::sys::raw::c_uint = 48;
pub const PRI_MIN_KERN: ::kernel::sys::raw::c_uint = 80;
pub const PSWP: ::kernel::sys::raw::c_uint = 80;
pub const PVM: ::kernel::sys::raw::c_uint = 84;
pub const PINOD: ::kernel::sys::raw::c_uint = 88;
pub const PRIBIO: ::kernel::sys::raw::c_uint = 92;
pub const PVFS: ::kernel::sys::raw::c_uint = 96;
pub const PZERO: ::kernel::sys::raw::c_uint = 100;
pub const PSOCK: ::kernel::sys::raw::c_uint = 104;
pub const PWAIT: ::kernel::sys::raw::c_uint = 108;
pub const PLOCK: ::kernel::sys::raw::c_uint = 112;
pub const PPAUSE: ::kernel::sys::raw::c_uint = 116;
pub const PRI_MIN_TIMESHARE: ::kernel::sys::raw::c_uint = 120;
pub const PUSER: ::kernel::sys::raw::c_uint = 120;
pub const PRI_MIN_IDLE: ::kernel::sys::raw::c_uint = 224;
pub const PRI_MAX_IDLE: ::kernel::sys::raw::c_uint = 255;
pub const PRI_USER: ::kernel::sys::raw::c_int = -2;
pub const PRI_UNCHANGED: ::kernel::sys::raw::c_int = -1;
pub const FALSE: ::kernel::sys::raw::c_uint = 0;
pub const TRUE: ::kernel::sys::raw::c_uint = 1;
pub const MACHINE: &'static [u8; 6usize] = b"amd64\x00";
pub const MACHINE_ARCH: &'static [u8; 6usize] = b"amd64\x00";
pub const MACHINE_ARCH32: &'static [u8; 5usize] = b"i386\x00";
pub const MAXCPU: ::kernel::sys::raw::c_uint = 256;
pub const MAXMEMDOM: ::kernel::sys::raw::c_uint = 8;
pub const CACHE_LINE_SHIFT: ::kernel::sys::raw::c_uint = 6;
pub const CACHE_LINE_SIZE: ::kernel::sys::raw::c_uint = 64;
pub const NPTEPGSHIFT: ::kernel::sys::raw::c_uint = 9;
pub const PAGE_SHIFT: ::kernel::sys::raw::c_uint = 12;
pub const PAGE_SIZE: ::kernel::sys::raw::c_uint = 4096;
pub const PAGE_MASK: ::kernel::sys::raw::c_uint = 4095;
pub const NPDEPGSHIFT: ::kernel::sys::raw::c_uint = 9;
pub const PDRSHIFT: ::kernel::sys::raw::c_uint = 21;
pub const NBPDR: ::kernel::sys::raw::c_uint = 2097152;
pub const PDRMASK: ::kernel::sys::raw::c_uint = 2097151;
pub const NPDPEPGSHIFT: ::kernel::sys::raw::c_uint = 9;
pub const PDPSHIFT: ::kernel::sys::raw::c_uint = 30;
pub const NBPDP: ::kernel::sys::raw::c_uint = 1073741824;
pub const PDPMASK: ::kernel::sys::raw::c_uint = 1073741823;
pub const NPML4EPGSHIFT: ::kernel::sys::raw::c_uint = 9;
pub const PML4SHIFT: ::kernel::sys::raw::c_uint = 39;
pub const NBPML4: ::kernel::sys::raw::c_ulonglong = 549755813888;
pub const PML4MASK: ::kernel::sys::raw::c_ulonglong = 549755813887;
pub const MAXPAGESIZES: ::kernel::sys::raw::c_uint = 3;
pub const IOPAGES: ::kernel::sys::raw::c_uint = 2;
pub const IOPERM_BITMAP_SIZE: ::kernel::sys::raw::c_uint = 8193;
pub const KSTACK_PAGES: ::kernel::sys::raw::c_uint = 4;
pub const KSTACK_GUARD_PAGES: ::kernel::sys::raw::c_uint = 1;
pub const DEV_BSHIFT: ::kernel::sys::raw::c_uint = 9;
pub const DEV_BSIZE: ::kernel::sys::raw::c_uint = 512;
pub const BLKDEV_IOSIZE: ::kernel::sys::raw::c_uint = 4096;
pub const DFLTPHYS: ::kernel::sys::raw::c_uint = 65536;
pub const MAXPHYS: ::kernel::sys::raw::c_uint = 131072;
pub const MAXDUMPPGS: ::kernel::sys::raw::c_uint = 16;
pub const MSIZE: ::kernel::sys::raw::c_uint = 256;
pub const MCLSHIFT: ::kernel::sys::raw::c_uint = 11;
pub const MCLBYTES: ::kernel::sys::raw::c_uint = 2048;
pub const MJUMPAGESIZE: ::kernel::sys::raw::c_uint = 4096;
pub const MJUM9BYTES: ::kernel::sys::raw::c_uint = 9216;
pub const MJUM16BYTES: ::kernel::sys::raw::c_uint = 16384;
pub const PRIMASK: ::kernel::sys::raw::c_uint = 255;
pub const PCATCH: ::kernel::sys::raw::c_uint = 256;
pub const PDROP: ::kernel::sys::raw::c_uint = 512;
pub const NZERO: ::kernel::sys::raw::c_uint = 0;
pub const NBBY: ::kernel::sys::raw::c_uint = 8;
pub const CMASK: ::kernel::sys::raw::c_uint = 18;
pub const MAXBSIZE: ::kernel::sys::raw::c_uint = 65536;
pub const MAXBCACHEBUF: ::kernel::sys::raw::c_uint = 65536;
pub const BKVASIZE: ::kernel::sys::raw::c_uint = 16384;
pub const BKVAMASK: ::kernel::sys::raw::c_uint = 16383;
pub const MAXPATHLEN: ::kernel::sys::raw::c_uint = 1024;
pub const MAXSYMLINKS: ::kernel::sys::raw::c_uint = 32;
pub const FSHIFT: ::kernel::sys::raw::c_uint = 11;
pub const FSCALE: ::kernel::sys::raw::c_uint = 2048;
pub const CPU_SETSIZE: ::kernel::sys::raw::c_uint = 256;
pub const CPU_MAXSIZE: ::kernel::sys::raw::c_uint = 256;
pub const PRIO_MIN: ::kernel::sys::raw::c_int = -20;
pub const PRIO_MAX: ::kernel::sys::raw::c_uint = 20;
pub const PRIO_PROCESS: ::kernel::sys::raw::c_uint = 0;
pub const PRIO_PGRP: ::kernel::sys::raw::c_uint = 1;
pub const PRIO_USER: ::kernel::sys::raw::c_uint = 2;
pub const RUSAGE_SELF: ::kernel::sys::raw::c_uint = 0;
pub const RUSAGE_CHILDREN: ::kernel::sys::raw::c_int = -1;
pub const RUSAGE_THREAD: ::kernel::sys::raw::c_uint = 1;
pub const RLIMIT_CPU: ::kernel::sys::raw::c_uint = 0;
pub const RLIMIT_FSIZE: ::kernel::sys::raw::c_uint = 1;
pub const RLIMIT_DATA: ::kernel::sys::raw::c_uint = 2;
pub const RLIMIT_STACK: ::kernel::sys::raw::c_uint = 3;
pub const RLIMIT_CORE: ::kernel::sys::raw::c_uint = 4;
pub const RLIMIT_RSS: ::kernel::sys::raw::c_uint = 5;
pub const RLIMIT_MEMLOCK: ::kernel::sys::raw::c_uint = 6;
pub const RLIMIT_NPROC: ::kernel::sys::raw::c_uint = 7;
pub const RLIMIT_NOFILE: ::kernel::sys::raw::c_uint = 8;
pub const RLIMIT_SBSIZE: ::kernel::sys::raw::c_uint = 9;
pub const RLIMIT_VMEM: ::kernel::sys::raw::c_uint = 10;
pub const RLIMIT_AS: ::kernel::sys::raw::c_uint = 10;
pub const RLIMIT_NPTS: ::kernel::sys::raw::c_uint = 11;
pub const RLIMIT_SWAP: ::kernel::sys::raw::c_uint = 12;
pub const RLIMIT_KQUEUES: ::kernel::sys::raw::c_uint = 13;
pub const RLIMIT_UMTXP: ::kernel::sys::raw::c_uint = 14;
pub const RLIM_NLIMITS: ::kernel::sys::raw::c_uint = 15;
pub const CP_USER: ::kernel::sys::raw::c_uint = 0;
pub const CP_NICE: ::kernel::sys::raw::c_uint = 1;
pub const CP_SYS: ::kernel::sys::raw::c_uint = 2;
pub const CP_INTR: ::kernel::sys::raw::c_uint = 3;
pub const CP_IDLE: ::kernel::sys::raw::c_uint = 4;
pub const CPUSTATES: ::kernel::sys::raw::c_uint = 5;
pub const PC_PTI_STACK_SZ: ::kernel::sys::raw::c_uint = 16;
pub const PC_DBREG_CMD_NONE: ::kernel::sys::raw::c_uint = 0;
pub const PC_DBREG_CMD_LOAD: ::kernel::sys::raw::c_uint = 1;
pub const OFFSETOF_CURTHREAD: ::kernel::sys::raw::c_uint = 0;
pub const OFFSETOF_CURPCB: ::kernel::sys::raw::c_uint = 32;
pub const DPCPU_SETNAME: &'static [u8; 9usize] = b"set_pcpu\x00";
pub const DPCPU_SYMPREFIX: &'static [u8; 12usize] = b"pcpu_entry_\x00";
pub const DPCPU_MODMIN: ::kernel::sys::raw::c_uint = 2048;
pub const LOCKSTAT_WRITER: ::kernel::sys::raw::c_uint = 0;
pub const LOCKSTAT_READER: ::kernel::sys::raw::c_uint = 1;
pub const CR4_PGE: ::kernel::sys::raw::c_uint = 128;
pub const INVPCID_ADDR: ::kernel::sys::raw::c_uint = 0;
pub const INVPCID_CTX: ::kernel::sys::raw::c_uint = 1;
pub const INVPCID_CTXGLOB: ::kernel::sys::raw::c_uint = 2;
pub const INVPCID_ALLCTX: ::kernel::sys::raw::c_uint = 3;
pub const MSR_FSBASE: ::kernel::sys::raw::c_uint = 3221225728;
pub const MSR_GSBASE: ::kernel::sys::raw::c_uint = 3221225729;
pub const MTX_DEF: ::kernel::sys::raw::c_uint = 0;
pub const MTX_SPIN: ::kernel::sys::raw::c_uint = 1;
pub const MTX_RECURSE: ::kernel::sys::raw::c_uint = 4;
pub const MTX_NOWITNESS: ::kernel::sys::raw::c_uint = 8;
pub const MTX_NOPROFILE: ::kernel::sys::raw::c_uint = 32;
pub const MTX_NEW: ::kernel::sys::raw::c_uint = 64;
pub const MTX_QUIET: ::kernel::sys::raw::c_uint = 2;
pub const MTX_DUPOK: ::kernel::sys::raw::c_uint = 16;
pub const MTX_UNOWNED: ::kernel::sys::raw::c_uint = 0;
pub const MTX_RECURSED: ::kernel::sys::raw::c_uint = 1;
pub const MTX_CONTESTED: ::kernel::sys::raw::c_uint = 2;
pub const MTX_DESTROYED: ::kernel::sys::raw::c_uint = 4;
pub const MTX_FLAGMASK: ::kernel::sys::raw::c_uint = 7;
pub const MTX_NETWORK_LOCK: &'static [u8; 15usize] = b"network driver\x00";
pub const EHE_DEAD_PRIORITY: ::kernel::sys::raw::c_int = -1;
pub const EVENTHANDLER_PRI_FIRST: ::kernel::sys::raw::c_uint = 0;
pub const EVENTHANDLER_PRI_ANY: ::kernel::sys::raw::c_uint = 10000;
pub const EVENTHANDLER_PRI_LAST: ::kernel::sys::raw::c_uint = 20000;
pub const SHUTDOWN_PRI_FIRST: ::kernel::sys::raw::c_uint = 0;
pub const SHUTDOWN_PRI_DEFAULT: ::kernel::sys::raw::c_uint = 10000;
pub const SHUTDOWN_PRI_LAST: ::kernel::sys::raw::c_uint = 20000;
pub const LOWMEM_PRI_DEFAULT: ::kernel::sys::raw::c_uint = 0;
pub const PCI_MAXMAPS_0: ::kernel::sys::raw::c_uint = 6;
pub const PCI_MAXMAPS_1: ::kernel::sys::raw::c_uint = 2;
pub const PCI_MAXMAPS_2: ::kernel::sys::raw::c_uint = 1;
pub const PCICFG_VF: ::kernel::sys::raw::c_uint = 1;
pub const VGA_PCI_BIOS_SHADOW_ADDR: ::kernel::sys::raw::c_uint = 786432;
pub const VGA_PCI_BIOS_SHADOW_SIZE: ::kernel::sys::raw::c_uint = 131072;
pub const PCI_DOMAINMAX: ::kernel::sys::raw::c_uint = 65535;
pub const PCI_BUSMAX: ::kernel::sys::raw::c_uint = 255;
pub const PCI_SLOTMAX: ::kernel::sys::raw::c_uint = 31;
pub const PCI_FUNCMAX: ::kernel::sys::raw::c_uint = 7;
pub const PCI_REGMAX: ::kernel::sys::raw::c_uint = 255;
pub const PCIE_REGMAX: ::kernel::sys::raw::c_uint = 4095;
pub const PCI_MAXHDRTYPE: ::kernel::sys::raw::c_uint = 2;
pub const PCIE_ARI_SLOTMAX: ::kernel::sys::raw::c_uint = 0;
pub const PCIE_ARI_FUNCMAX: ::kernel::sys::raw::c_uint = 255;
pub const PCI_RID_DOMAIN_SHIFT: ::kernel::sys::raw::c_uint = 16;
pub const PCI_RID_BUS_SHIFT: ::kernel::sys::raw::c_uint = 8;
pub const PCI_RID_SLOT_SHIFT: ::kernel::sys::raw::c_uint = 3;
pub const PCI_RID_FUNC_SHIFT: ::kernel::sys::raw::c_uint = 0;
pub const PCIR_DEVVENDOR: ::kernel::sys::raw::c_uint = 0;
pub const PCIR_VENDOR: ::kernel::sys::raw::c_uint = 0;
pub const PCIR_DEVICE: ::kernel::sys::raw::c_uint = 2;
pub const PCIR_COMMAND: ::kernel::sys::raw::c_uint = 4;
pub const PCIM_CMD_PORTEN: ::kernel::sys::raw::c_uint = 1;
pub const PCIM_CMD_MEMEN: ::kernel::sys::raw::c_uint = 2;
pub const PCIM_CMD_BUSMASTEREN: ::kernel::sys::raw::c_uint = 4;
pub const PCIM_CMD_SPECIALEN: ::kernel::sys::raw::c_uint = 8;
pub const PCIM_CMD_MWRICEN: ::kernel::sys::raw::c_uint = 16;
pub const PCIM_CMD_PERRESPEN: ::kernel::sys::raw::c_uint = 64;
pub const PCIM_CMD_SERRESPEN: ::kernel::sys::raw::c_uint = 256;
pub const PCIM_CMD_BACKTOBACK: ::kernel::sys::raw::c_uint = 512;
pub const PCIM_CMD_INTxDIS: ::kernel::sys::raw::c_uint = 1024;
pub const PCIR_STATUS: ::kernel::sys::raw::c_uint = 6;
pub const PCIM_STATUS_INTxSTATE: ::kernel::sys::raw::c_uint = 8;
pub const PCIM_STATUS_CAPPRESENT: ::kernel::sys::raw::c_uint = 16;
pub const PCIM_STATUS_66CAPABLE: ::kernel::sys::raw::c_uint = 32;
pub const PCIM_STATUS_BACKTOBACK: ::kernel::sys::raw::c_uint = 128;
pub const PCIM_STATUS_MDPERR: ::kernel::sys::raw::c_uint = 256;
pub const PCIM_STATUS_SEL_FAST: ::kernel::sys::raw::c_uint = 0;
pub const PCIM_STATUS_SEL_MEDIMUM: ::kernel::sys::raw::c_uint = 512;
pub const PCIM_STATUS_SEL_SLOW: ::kernel::sys::raw::c_uint = 1024;
pub const PCIM_STATUS_SEL_MASK: ::kernel::sys::raw::c_uint = 1536;
pub const PCIM_STATUS_STABORT: ::kernel::sys::raw::c_uint = 2048;
pub const PCIM_STATUS_RTABORT: ::kernel::sys::raw::c_uint = 4096;
pub const PCIM_STATUS_RMABORT: ::kernel::sys::raw::c_uint = 8192;
pub const PCIM_STATUS_SERR: ::kernel::sys::raw::c_uint = 16384;
pub const PCIM_STATUS_PERR: ::kernel::sys::raw::c_uint = 32768;
pub const PCIR_REVID: ::kernel::sys::raw::c_uint = 8;
pub const PCIR_PROGIF: ::kernel::sys::raw::c_uint = 9;
pub const PCIR_SUBCLASS: ::kernel::sys::raw::c_uint = 10;
pub const PCIR_CLASS: ::kernel::sys::raw::c_uint = 11;
pub const PCIR_CACHELNSZ: ::kernel::sys::raw::c_uint = 12;
pub const PCIR_LATTIMER: ::kernel::sys::raw::c_uint = 13;
pub const PCIR_HDRTYPE: ::kernel::sys::raw::c_uint = 14;
pub const PCIM_HDRTYPE: ::kernel::sys::raw::c_uint = 127;
pub const PCIM_HDRTYPE_NORMAL: ::kernel::sys::raw::c_uint = 0;
pub const PCIM_HDRTYPE_BRIDGE: ::kernel::sys::raw::c_uint = 1;
pub const PCIM_HDRTYPE_CARDBUS: ::kernel::sys::raw::c_uint = 2;
pub const PCIM_MFDEV: ::kernel::sys::raw::c_uint = 128;
pub const PCIR_BIST: ::kernel::sys::raw::c_uint = 15;
pub const PCICAP_ID: ::kernel::sys::raw::c_uint = 0;
pub const PCICAP_NEXTPTR: ::kernel::sys::raw::c_uint = 1;
pub const PCIY_PMG: ::kernel::sys::raw::c_uint = 1;
pub const PCIY_AGP: ::kernel::sys::raw::c_uint = 2;
pub const PCIY_VPD: ::kernel::sys::raw::c_uint = 3;
pub const PCIY_SLOTID: ::kernel::sys::raw::c_uint = 4;
pub const PCIY_MSI: ::kernel::sys::raw::c_uint = 5;
pub const PCIY_CHSWP: ::kernel::sys::raw::c_uint = 6;
pub const PCIY_PCIX: ::kernel::sys::raw::c_uint = 7;
pub const PCIY_HT: ::kernel::sys::raw::c_uint = 8;
pub const PCIY_VENDOR: ::kernel::sys::raw::c_uint = 9;
pub const PCIY_DEBUG: ::kernel::sys::raw::c_uint = 10;
pub const PCIY_CRES: ::kernel::sys::raw::c_uint = 11;
pub const PCIY_HOTPLUG: ::kernel::sys::raw::c_uint = 12;
pub const PCIY_SUBVENDOR: ::kernel::sys::raw::c_uint = 13;
pub const PCIY_AGP8X: ::kernel::sys::raw::c_uint = 14;
pub const PCIY_SECDEV: ::kernel::sys::raw::c_uint = 15;
pub const PCIY_EXPRESS: ::kernel::sys::raw::c_uint = 16;
pub const PCIY_MSIX: ::kernel::sys::raw::c_uint = 17;
pub const PCIY_SATA: ::kernel::sys::raw::c_uint = 18;
pub const PCIY_PCIAF: ::kernel::sys::raw::c_uint = 19;
pub const PCIY_EA: ::kernel::sys::raw::c_uint = 20;
pub const PCIR_EXTCAP: ::kernel::sys::raw::c_uint = 256;
pub const PCIM_EXTCAP_ID: ::kernel::sys::raw::c_uint = 65535;
pub const PCIM_EXTCAP_VER: ::kernel::sys::raw::c_uint = 983040;
pub const PCIM_EXTCAP_NEXTPTR: ::kernel::sys::raw::c_uint = 4293918720;
pub const PCIZ_AER: ::kernel::sys::raw::c_uint = 1;
pub const PCIZ_VC: ::kernel::sys::raw::c_uint = 2;
pub const PCIZ_SERNUM: ::kernel::sys::raw::c_uint = 3;
pub const PCIZ_PWRBDGT: ::kernel::sys::raw::c_uint = 4;
pub const PCIZ_RCLINK_DCL: ::kernel::sys::raw::c_uint = 5;
pub const PCIZ_RCLINK_CTL: ::kernel::sys::raw::c_uint = 6;
pub const PCIZ_RCEC_ASSOC: ::kernel::sys::raw::c_uint = 7;
pub const PCIZ_MFVC: ::kernel::sys::raw::c_uint = 8;
pub const PCIZ_VC2: ::kernel::sys::raw::c_uint = 9;
pub const PCIZ_RCRB: ::kernel::sys::raw::c_uint = 10;
pub const PCIZ_VENDOR: ::kernel::sys::raw::c_uint = 11;
pub const PCIZ_CAC: ::kernel::sys::raw::c_uint = 12;
pub const PCIZ_ACS: ::kernel::sys::raw::c_uint = 13;
pub const PCIZ_ARI: ::kernel::sys::raw::c_uint = 14;
pub const PCIZ_ATS: ::kernel::sys::raw::c_uint = 15;
pub const PCIZ_SRIOV: ::kernel::sys::raw::c_uint = 16;
pub const PCIZ_MRIOV: ::kernel::sys::raw::c_uint = 17;
pub const PCIZ_MULTICAST: ::kernel::sys::raw::c_uint = 18;
pub const PCIZ_PAGE_REQ: ::kernel::sys::raw::c_uint = 19;
pub const PCIZ_AMD: ::kernel::sys::raw::c_uint = 20;
pub const PCIZ_RESIZE_BAR: ::kernel::sys::raw::c_uint = 21;
pub const PCIZ_DPA: ::kernel::sys::raw::c_uint = 22;
pub const PCIZ_TPH_REQ: ::kernel::sys::raw::c_uint = 23;
pub const PCIZ_LTR: ::kernel::sys::raw::c_uint = 24;
pub const PCIZ_SEC_PCIE: ::kernel::sys::raw::c_uint = 25;
pub const PCIZ_PMUX: ::kernel::sys::raw::c_uint = 26;
pub const PCIZ_PASID: ::kernel::sys::raw::c_uint = 27;
pub const PCIZ_LN_REQ: ::kernel::sys::raw::c_uint = 28;
pub const PCIZ_DPC: ::kernel::sys::raw::c_uint = 29;
pub const PCIZ_L1PM: ::kernel::sys::raw::c_uint = 30;
pub const PCIR_BARS: ::kernel::sys::raw::c_uint = 16;
pub const PCIR_MAX_BAR_0: ::kernel::sys::raw::c_uint = 5;
pub const PCIM_BAR_SPACE: ::kernel::sys::raw::c_uint = 1;
pub const PCIM_BAR_MEM_SPACE: ::kernel::sys::raw::c_uint = 0;
pub const PCIM_BAR_IO_SPACE: ::kernel::sys::raw::c_uint = 1;
pub const PCIM_BAR_MEM_TYPE: ::kernel::sys::raw::c_uint = 6;
pub const PCIM_BAR_MEM_32: ::kernel::sys::raw::c_uint = 0;
pub const PCIM_BAR_MEM_1MB: ::kernel::sys::raw::c_uint = 2;
pub const PCIM_BAR_MEM_64: ::kernel::sys::raw::c_uint = 4;
pub const PCIM_BAR_MEM_PREFETCH: ::kernel::sys::raw::c_uint = 8;
pub const PCIM_BAR_MEM_BASE: ::kernel::sys::raw::c_int = -16;
pub const PCIM_BAR_IO_RESERVED: ::kernel::sys::raw::c_uint = 2;
pub const PCIM_BAR_IO_BASE: ::kernel::sys::raw::c_uint = 4294967292;
pub const PCIR_CIS: ::kernel::sys::raw::c_uint = 40;
pub const PCIM_CIS_ASI_MASK: ::kernel::sys::raw::c_uint = 7;
pub const PCIM_CIS_ASI_CONFIG: ::kernel::sys::raw::c_uint = 0;
pub const PCIM_CIS_ASI_BAR0: ::kernel::sys::raw::c_uint = 1;
pub const PCIM_CIS_ASI_BAR1: ::kernel::sys::raw::c_uint = 2;
pub const PCIM_CIS_ASI_BAR2: ::kernel::sys::raw::c_uint = 3;
pub const PCIM_CIS_ASI_BAR3: ::kernel::sys::raw::c_uint = 4;
pub const PCIM_CIS_ASI_BAR4: ::kernel::sys::raw::c_uint = 5;
pub const PCIM_CIS_ASI_BAR5: ::kernel::sys::raw::c_uint = 6;
pub const PCIM_CIS_ASI_ROM: ::kernel::sys::raw::c_uint = 7;
pub const PCIM_CIS_ADDR_MASK: ::kernel::sys::raw::c_uint = 268435448;
pub const PCIM_CIS_ROM_MASK: ::kernel::sys::raw::c_uint = 4026531840;
pub const PCIM_CIS_CONFIG_MASK: ::kernel::sys::raw::c_uint = 255;
pub const PCIR_SUBVEND_0: ::kernel::sys::raw::c_uint = 44;
pub const PCIR_SUBDEV_0: ::kernel::sys::raw::c_uint = 46;
pub const PCIR_BIOS: ::kernel::sys::raw::c_uint = 48;
pub const PCIM_BIOS_ENABLE: ::kernel::sys::raw::c_uint = 1;
pub const PCIM_BIOS_ADDR_MASK: ::kernel::sys::raw::c_uint = 4294965248;
pub const PCIR_CAP_PTR: ::kernel::sys::raw::c_uint = 52;
pub const PCIR_INTLINE: ::kernel::sys::raw::c_uint = 60;
pub const PCIR_INTPIN: ::kernel::sys::raw::c_uint = 61;
pub const PCIR_MINGNT: ::kernel::sys::raw::c_uint = 62;
pub const PCIR_MAXLAT: ::kernel::sys::raw::c_uint = 63;
pub const PCIR_MAX_BAR_1: ::kernel::sys::raw::c_uint = 1;
pub const PCIR_SECSTAT_1: ::kernel::sys::raw::c_uint = 30;
pub const PCIR_PRIBUS_1: ::kernel::sys::raw::c_uint = 24;
pub const PCIR_SECBUS_1: ::kernel::sys::raw::c_uint = 25;
pub const PCIR_SUBBUS_1: ::kernel::sys::raw::c_uint = 26;
pub const PCIR_SECLAT_1: ::kernel::sys::raw::c_uint = 27;
pub const PCIR_IOBASEL_1: ::kernel::sys::raw::c_uint = 28;
pub const PCIR_IOLIMITL_1: ::kernel::sys::raw::c_uint = 29;
pub const PCIR_IOBASEH_1: ::kernel::sys::raw::c_uint = 48;
pub const PCIR_IOLIMITH_1: ::kernel::sys::raw::c_uint = 50;
pub const PCIM_BRIO_16: ::kernel::sys::raw::c_uint = 0;
pub const PCIM_BRIO_32: ::kernel::sys::raw::c_uint = 1;
pub const PCIM_BRIO_MASK: ::kernel::sys::raw::c_uint = 15;
pub const PCIR_MEMBASE_1: ::kernel::sys::raw::c_uint = 32;
pub const PCIR_MEMLIMIT_1: ::kernel::sys::raw::c_uint = 34;
pub const PCIR_PMBASEL_1: ::kernel::sys::raw::c_uint = 36;
pub const PCIR_PMLIMITL_1: ::kernel::sys::raw::c_uint = 38;
pub const PCIR_PMBASEH_1: ::kernel::sys::raw::c_uint = 40;
pub const PCIR_PMLIMITH_1: ::kernel::sys::raw::c_uint = 44;
pub const PCIM_BRPM_32: ::kernel::sys::raw::c_uint = 0;
pub const PCIM_BRPM_64: ::kernel::sys::raw::c_uint = 1;
pub const PCIM_BRPM_MASK: ::kernel::sys::raw::c_uint = 15;
pub const PCIR_BIOS_1: ::kernel::sys::raw::c_uint = 56;
pub const PCIR_BRIDGECTL_1: ::kernel::sys::raw::c_uint = 62;
pub const PCIR_MAX_BAR_2: ::kernel::sys::raw::c_uint = 0;
pub const PCIR_CAP_PTR_2: ::kernel::sys::raw::c_uint = 20;
pub const PCIR_SECSTAT_2: ::kernel::sys::raw::c_uint = 22;
pub const PCIR_PRIBUS_2: ::kernel::sys::raw::c_uint = 24;
pub const PCIR_SECBUS_2: ::kernel::sys::raw::c_uint = 25;
pub const PCIR_SUBBUS_2: ::kernel::sys::raw::c_uint = 26;
pub const PCIR_SECLAT_2: ::kernel::sys::raw::c_uint = 27;
pub const PCIR_MEMBASE0_2: ::kernel::sys::raw::c_uint = 28;
pub const PCIR_MEMLIMIT0_2: ::kernel::sys::raw::c_uint = 32;
pub const PCIR_MEMBASE1_2: ::kernel::sys::raw::c_uint = 36;
pub const PCIR_MEMLIMIT1_2: ::kernel::sys::raw::c_uint = 40;
pub const PCIR_IOBASE0_2: ::kernel::sys::raw::c_uint = 44;
pub const PCIR_IOLIMIT0_2: ::kernel::sys::raw::c_uint = 48;
pub const PCIR_IOBASE1_2: ::kernel::sys::raw::c_uint = 52;
pub const PCIR_IOLIMIT1_2: ::kernel::sys::raw::c_uint = 56;
pub const PCIM_CBBIO_16: ::kernel::sys::raw::c_uint = 0;
pub const PCIM_CBBIO_32: ::kernel::sys::raw::c_uint = 1;
pub const PCIM_CBBIO_MASK: ::kernel::sys::raw::c_uint = 3;
pub const PCIR_BRIDGECTL_2: ::kernel::sys::raw::c_uint = 62;
pub const PCIR_SUBVEND_2: ::kernel::sys::raw::c_uint = 64;
pub const PCIR_SUBDEV_2: ::kernel::sys::raw::c_uint = 66;
pub const PCIR_PCCARDIF_2: ::kernel::sys::raw::c_uint = 68;
pub const PCIC_OLD: ::kernel::sys::raw::c_uint = 0;
pub const PCIS_OLD_NONVGA: ::kernel::sys::raw::c_uint = 0;
pub const PCIS_OLD_VGA: ::kernel::sys::raw::c_uint = 1;
pub const PCIC_STORAGE: ::kernel::sys::raw::c_uint = 1;
pub const PCIS_STORAGE_SCSI: ::kernel::sys::raw::c_uint = 0;
pub const PCIS_STORAGE_IDE: ::kernel::sys::raw::c_uint = 1;
pub const PCIP_STORAGE_IDE_MODEPRIM: ::kernel::sys::raw::c_uint = 1;
pub const PCIP_STORAGE_IDE_PROGINDPRIM: ::kernel::sys::raw::c_uint = 2;
pub const PCIP_STORAGE_IDE_MODESEC: ::kernel::sys::raw::c_uint = 4;
pub const PCIP_STORAGE_IDE_PROGINDSEC: ::kernel::sys::raw::c_uint = 8;
pub const PCIP_STORAGE_IDE_MASTERDEV: ::kernel::sys::raw::c_uint = 128;
pub const PCIS_STORAGE_FLOPPY: ::kernel::sys::raw::c_uint = 2;
pub const PCIS_STORAGE_IPI: ::kernel::sys::raw::c_uint = 3;
pub const PCIS_STORAGE_RAID: ::kernel::sys::raw::c_uint = 4;
pub const PCIS_STORAGE_ATA_ADMA: ::kernel::sys::raw::c_uint = 5;
pub const PCIS_STORAGE_SATA: ::kernel::sys::raw::c_uint = 6;
pub const PCIP_STORAGE_SATA_AHCI_1_0: ::kernel::sys::raw::c_uint = 1;
pub const PCIS_STORAGE_SAS: ::kernel::sys::raw::c_uint = 7;
pub const PCIS_STORAGE_NVM: ::kernel::sys::raw::c_uint = 8;
pub const PCIP_STORAGE_NVM_NVMHCI_1_0: ::kernel::sys::raw::c_uint = 1;
pub const PCIP_STORAGE_NVM_ENTERPRISE_NVMHCI_1_0: ::kernel::sys::raw::c_uint =
    2;
pub const PCIS_STORAGE_OTHER: ::kernel::sys::raw::c_uint = 128;
pub const PCIC_NETWORK: ::kernel::sys::raw::c_uint = 2;
pub const PCIS_NETWORK_ETHERNET: ::kernel::sys::raw::c_uint = 0;
pub const PCIS_NETWORK_TOKENRING: ::kernel::sys::raw::c_uint = 1;
pub const PCIS_NETWORK_FDDI: ::kernel::sys::raw::c_uint = 2;
pub const PCIS_NETWORK_ATM: ::kernel::sys::raw::c_uint = 3;
pub const PCIS_NETWORK_ISDN: ::kernel::sys::raw::c_uint = 4;
pub const PCIS_NETWORK_WORLDFIP: ::kernel::sys::raw::c_uint = 5;
pub const PCIS_NETWORK_PICMG: ::kernel::sys::raw::c_uint = 6;
pub const PCIS_NETWORK_OTHER: ::kernel::sys::raw::c_uint = 128;
pub const PCIC_DISPLAY: ::kernel::sys::raw::c_uint = 3;
pub const PCIS_DISPLAY_VGA: ::kernel::sys::raw::c_uint = 0;
pub const PCIS_DISPLAY_XGA: ::kernel::sys::raw::c_uint = 1;
pub const PCIS_DISPLAY_3D: ::kernel::sys::raw::c_uint = 2;
pub const PCIS_DISPLAY_OTHER: ::kernel::sys::raw::c_uint = 128;
pub const PCIC_MULTIMEDIA: ::kernel::sys::raw::c_uint = 4;
pub const PCIS_MULTIMEDIA_VIDEO: ::kernel::sys::raw::c_uint = 0;
pub const PCIS_MULTIMEDIA_AUDIO: ::kernel::sys::raw::c_uint = 1;
pub const PCIS_MULTIMEDIA_TELE: ::kernel::sys::raw::c_uint = 2;
pub const PCIS_MULTIMEDIA_HDA: ::kernel::sys::raw::c_uint = 3;
pub const PCIS_MULTIMEDIA_OTHER: ::kernel::sys::raw::c_uint = 128;
pub const PCIC_MEMORY: ::kernel::sys::raw::c_uint = 5;
pub const PCIS_MEMORY_RAM: ::kernel::sys::raw::c_uint = 0;
pub const PCIS_MEMORY_FLASH: ::kernel::sys::raw::c_uint = 1;
pub const PCIS_MEMORY_OTHER: ::kernel::sys::raw::c_uint = 128;
pub const PCIC_BRIDGE: ::kernel::sys::raw::c_uint = 6;
pub const PCIS_BRIDGE_HOST: ::kernel::sys::raw::c_uint = 0;
pub const PCIS_BRIDGE_ISA: ::kernel::sys::raw::c_uint = 1;
pub const PCIS_BRIDGE_EISA: ::kernel::sys::raw::c_uint = 2;
pub const PCIS_BRIDGE_MCA: ::kernel::sys::raw::c_uint = 3;
pub const PCIS_BRIDGE_PCI: ::kernel::sys::raw::c_uint = 4;
pub const PCIP_BRIDGE_PCI_SUBTRACTIVE: ::kernel::sys::raw::c_uint = 1;
pub const PCIS_BRIDGE_PCMCIA: ::kernel::sys::raw::c_uint = 5;
pub const PCIS_BRIDGE_NUBUS: ::kernel::sys::raw::c_uint = 6;
pub const PCIS_BRIDGE_CARDBUS: ::kernel::sys::raw::c_uint = 7;
pub const PCIS_BRIDGE_RACEWAY: ::kernel::sys::raw::c_uint = 8;
pub const PCIS_BRIDGE_PCI_TRANSPARENT: ::kernel::sys::raw::c_uint = 9;
pub const PCIS_BRIDGE_INFINIBAND: ::kernel::sys::raw::c_uint = 10;
pub const PCIS_BRIDGE_OTHER: ::kernel::sys::raw::c_uint = 128;
pub const PCIC_SIMPLECOMM: ::kernel::sys::raw::c_uint = 7;
pub const PCIS_SIMPLECOMM_UART: ::kernel::sys::raw::c_uint = 0;
pub const PCIP_SIMPLECOMM_UART_8250: ::kernel::sys::raw::c_uint = 0;
pub const PCIP_SIMPLECOMM_UART_16450A: ::kernel::sys::raw::c_uint = 1;
pub const PCIP_SIMPLECOMM_UART_16550A: ::kernel::sys::raw::c_uint = 2;
pub const PCIP_SIMPLECOMM_UART_16650A: ::kernel::sys::raw::c_uint = 3;
pub const PCIP_SIMPLECOMM_UART_16750A: ::kernel::sys::raw::c_uint = 4;
pub const PCIP_SIMPLECOMM_UART_16850A: ::kernel::sys::raw::c_uint = 5;
pub const PCIP_SIMPLECOMM_UART_16950A: ::kernel::sys::raw::c_uint = 6;
pub const PCIS_SIMPLECOMM_PAR: ::kernel::sys::raw::c_uint = 1;
pub const PCIS_SIMPLECOMM_MULSER: ::kernel::sys::raw::c_uint = 2;
pub const PCIS_SIMPLECOMM_MODEM: ::kernel::sys::raw::c_uint = 3;
pub const PCIS_SIMPLECOMM_GPIB: ::kernel::sys::raw::c_uint = 4;
pub const PCIS_SIMPLECOMM_SMART_CARD: ::kernel::sys::raw::c_uint = 5;
pub const PCIS_SIMPLECOMM_OTHER: ::kernel::sys::raw::c_uint = 128;
pub const PCIC_BASEPERIPH: ::kernel::sys::raw::c_uint = 8;
pub const PCIS_BASEPERIPH_PIC: ::kernel::sys::raw::c_uint = 0;
pub const PCIP_BASEPERIPH_PIC_8259A: ::kernel::sys::raw::c_uint = 0;
pub const PCIP_BASEPERIPH_PIC_ISA: ::kernel::sys::raw::c_uint = 1;
pub const PCIP_BASEPERIPH_PIC_EISA: ::kernel::sys::raw::c_uint = 2;
pub const PCIP_BASEPERIPH_PIC_IO_APIC: ::kernel::sys::raw::c_uint = 16;
pub const PCIP_BASEPERIPH_PIC_IOX_APIC: ::kernel::sys::raw::c_uint = 32;
pub const PCIS_BASEPERIPH_DMA: ::kernel::sys::raw::c_uint = 1;
pub const PCIS_BASEPERIPH_TIMER: ::kernel::sys::raw::c_uint = 2;
pub const PCIS_BASEPERIPH_RTC: ::kernel::sys::raw::c_uint = 3;
pub const PCIS_BASEPERIPH_PCIHOT: ::kernel::sys::raw::c_uint = 4;
pub const PCIS_BASEPERIPH_SDHC: ::kernel::sys::raw::c_uint = 5;
pub const PCIS_BASEPERIPH_IOMMU: ::kernel::sys::raw::c_uint = 6;
pub const PCIS_BASEPERIPH_OTHER: ::kernel::sys::raw::c_uint = 128;
pub const PCIC_INPUTDEV: ::kernel::sys::raw::c_uint = 9;
pub const PCIS_INPUTDEV_KEYBOARD: ::kernel::sys::raw::c_uint = 0;
pub const PCIS_INPUTDEV_DIGITIZER: ::kernel::sys::raw::c_uint = 1;
pub const PCIS_INPUTDEV_MOUSE: ::kernel::sys::raw::c_uint = 2;
pub const PCIS_INPUTDEV_SCANNER: ::kernel::sys::raw::c_uint = 3;
pub const PCIS_INPUTDEV_GAMEPORT: ::kernel::sys::raw::c_uint = 4;
pub const PCIS_INPUTDEV_OTHER: ::kernel::sys::raw::c_uint = 128;
pub const PCIC_DOCKING: ::kernel::sys::raw::c_uint = 10;
pub const PCIS_DOCKING_GENERIC: ::kernel::sys::raw::c_uint = 0;
pub const PCIS_DOCKING_OTHER: ::kernel::sys::raw::c_uint = 128;
pub const PCIC_PROCESSOR: ::kernel::sys::raw::c_uint = 11;
pub const PCIS_PROCESSOR_386: ::kernel::sys::raw::c_uint = 0;
pub const PCIS_PROCESSOR_486: ::kernel::sys::raw::c_uint = 1;
pub const PCIS_PROCESSOR_PENTIUM: ::kernel::sys::raw::c_uint = 2;
pub const PCIS_PROCESSOR_ALPHA: ::kernel::sys::raw::c_uint = 16;
pub const PCIS_PROCESSOR_POWERPC: ::kernel::sys::raw::c_uint = 32;
pub const PCIS_PROCESSOR_MIPS: ::kernel::sys::raw::c_uint = 48;
pub const PCIS_PROCESSOR_COPROC: ::kernel::sys::raw::c_uint = 64;
pub const PCIC_SERIALBUS: ::kernel::sys::raw::c_uint = 12;
pub const PCIS_SERIALBUS_FW: ::kernel::sys::raw::c_uint = 0;
pub const PCIS_SERIALBUS_ACCESS: ::kernel::sys::raw::c_uint = 1;
pub const PCIS_SERIALBUS_SSA: ::kernel::sys::raw::c_uint = 2;
pub const PCIS_SERIALBUS_USB: ::kernel::sys::raw::c_uint = 3;
pub const PCIP_SERIALBUS_USB_UHCI: ::kernel::sys::raw::c_uint = 0;
pub const PCIP_SERIALBUS_USB_OHCI: ::kernel::sys::raw::c_uint = 16;
pub const PCIP_SERIALBUS_USB_EHCI: ::kernel::sys::raw::c_uint = 32;
pub const PCIP_SERIALBUS_USB_XHCI: ::kernel::sys::raw::c_uint = 48;
pub const PCIP_SERIALBUS_USB_DEVICE: ::kernel::sys::raw::c_uint = 254;
pub const PCIS_SERIALBUS_FC: ::kernel::sys::raw::c_uint = 4;
pub const PCIS_SERIALBUS_SMBUS: ::kernel::sys::raw::c_uint = 5;
pub const PCIS_SERIALBUS_INFINIBAND: ::kernel::sys::raw::c_uint = 6;
pub const PCIS_SERIALBUS_IPMI: ::kernel::sys::raw::c_uint = 7;
pub const PCIP_SERIALBUS_IPMI_SMIC: ::kernel::sys::raw::c_uint = 0;
pub const PCIP_SERIALBUS_IPMI_KCS: ::kernel::sys::raw::c_uint = 1;
pub const PCIP_SERIALBUS_IPMI_BT: ::kernel::sys::raw::c_uint = 2;
pub const PCIS_SERIALBUS_SERCOS: ::kernel::sys::raw::c_uint = 8;
pub const PCIS_SERIALBUS_CANBUS: ::kernel::sys::raw::c_uint = 9;
pub const PCIC_WIRELESS: ::kernel::sys::raw::c_uint = 13;
pub const PCIS_WIRELESS_IRDA: ::kernel::sys::raw::c_uint = 0;
pub const PCIS_WIRELESS_IR: ::kernel::sys::raw::c_uint = 1;
pub const PCIS_WIRELESS_RF: ::kernel::sys::raw::c_uint = 16;
pub const PCIS_WIRELESS_BLUETOOTH: ::kernel::sys::raw::c_uint = 17;
pub const PCIS_WIRELESS_BROADBAND: ::kernel::sys::raw::c_uint = 18;
pub const PCIS_WIRELESS_80211A: ::kernel::sys::raw::c_uint = 32;
pub const PCIS_WIRELESS_80211B: ::kernel::sys::raw::c_uint = 33;
pub const PCIS_WIRELESS_OTHER: ::kernel::sys::raw::c_uint = 128;
pub const PCIC_INTELLIIO: ::kernel::sys::raw::c_uint = 14;
pub const PCIS_INTELLIIO_I2O: ::kernel::sys::raw::c_uint = 0;
pub const PCIC_SATCOM: ::kernel::sys::raw::c_uint = 15;
pub const PCIS_SATCOM_TV: ::kernel::sys::raw::c_uint = 1;
pub const PCIS_SATCOM_AUDIO: ::kernel::sys::raw::c_uint = 2;
pub const PCIS_SATCOM_VOICE: ::kernel::sys::raw::c_uint = 3;
pub const PCIS_SATCOM_DATA: ::kernel::sys::raw::c_uint = 4;
pub const PCIC_CRYPTO: ::kernel::sys::raw::c_uint = 16;
pub const PCIS_CRYPTO_NETCOMP: ::kernel::sys::raw::c_uint = 0;
pub const PCIS_CRYPTO_ENTERTAIN: ::kernel::sys::raw::c_uint = 16;
pub const PCIS_CRYPTO_OTHER: ::kernel::sys::raw::c_uint = 128;
pub const PCIC_DASP: ::kernel::sys::raw::c_uint = 17;
pub const PCIS_DASP_DPIO: ::kernel::sys::raw::c_uint = 0;
pub const PCIS_DASP_PERFCNTRS: ::kernel::sys::raw::c_uint = 1;
pub const PCIS_DASP_COMM_SYNC: ::kernel::sys::raw::c_uint = 16;
pub const PCIS_DASP_MGMT_CARD: ::kernel::sys::raw::c_uint = 32;
pub const PCIS_DASP_OTHER: ::kernel::sys::raw::c_uint = 128;
pub const PCIC_ACCEL: ::kernel::sys::raw::c_uint = 18;
pub const PCIS_ACCEL_PROCESSING: ::kernel::sys::raw::c_uint = 0;
pub const PCIC_INSTRUMENT: ::kernel::sys::raw::c_uint = 19;
pub const PCIC_OTHER: ::kernel::sys::raw::c_uint = 255;
pub const PCIB_BCR_PERR_ENABLE: ::kernel::sys::raw::c_uint = 1;
pub const PCIB_BCR_SERR_ENABLE: ::kernel::sys::raw::c_uint = 2;
pub const PCIB_BCR_ISA_ENABLE: ::kernel::sys::raw::c_uint = 4;
pub const PCIB_BCR_VGA_ENABLE: ::kernel::sys::raw::c_uint = 8;
pub const PCIB_BCR_MASTER_ABORT_MODE: ::kernel::sys::raw::c_uint = 32;
pub const PCIB_BCR_SECBUS_RESET: ::kernel::sys::raw::c_uint = 64;
pub const PCIB_BCR_SECBUS_BACKTOBACK: ::kernel::sys::raw::c_uint = 128;
pub const PCIB_BCR_PRI_DISCARD_TIMEOUT: ::kernel::sys::raw::c_uint = 256;
pub const PCIB_BCR_SEC_DISCARD_TIMEOUT: ::kernel::sys::raw::c_uint = 512;
pub const PCIB_BCR_DISCARD_TIMER_STATUS: ::kernel::sys::raw::c_uint = 1024;
pub const PCIB_BCR_DISCARD_TIMER_SERREN: ::kernel::sys::raw::c_uint = 2048;
pub const CBB_BCR_PERR_ENABLE: ::kernel::sys::raw::c_uint = 1;
pub const CBB_BCR_SERR_ENABLE: ::kernel::sys::raw::c_uint = 2;
pub const CBB_BCR_ISA_ENABLE: ::kernel::sys::raw::c_uint = 4;
pub const CBB_BCR_VGA_ENABLE: ::kernel::sys::raw::c_uint = 8;
pub const CBB_BCR_MASTER_ABORT_MODE: ::kernel::sys::raw::c_uint = 32;
pub const CBB_BCR_CARDBUS_RESET: ::kernel::sys::raw::c_uint = 64;
pub const CBB_BCR_IREQ_INT_ENABLE: ::kernel::sys::raw::c_uint = 128;
pub const CBB_BCR_PREFETCH_0_ENABLE: ::kernel::sys::raw::c_uint = 256;
pub const CBB_BCR_PREFETCH_1_ENABLE: ::kernel::sys::raw::c_uint = 512;
pub const CBB_BCR_WRITE_POSTING_ENABLE: ::kernel::sys::raw::c_uint = 1024;
pub const PCIR_POWER_CAP: ::kernel::sys::raw::c_uint = 2;
pub const PCIM_PCAP_SPEC: ::kernel::sys::raw::c_uint = 7;
pub const PCIM_PCAP_PMEREQCLK: ::kernel::sys::raw::c_uint = 8;
pub const PCIM_PCAP_DEVSPECINIT: ::kernel::sys::raw::c_uint = 32;
pub const PCIM_PCAP_AUXPWR_0: ::kernel::sys::raw::c_uint = 0;
pub const PCIM_PCAP_AUXPWR_55: ::kernel::sys::raw::c_uint = 64;
pub const PCIM_PCAP_AUXPWR_100: ::kernel::sys::raw::c_uint = 128;
pub const PCIM_PCAP_AUXPWR_160: ::kernel::sys::raw::c_uint = 192;
pub const PCIM_PCAP_AUXPWR_220: ::kernel::sys::raw::c_uint = 256;
pub const PCIM_PCAP_AUXPWR_270: ::kernel::sys::raw::c_uint = 320;
pub const PCIM_PCAP_AUXPWR_320: ::kernel::sys::raw::c_uint = 384;
pub const PCIM_PCAP_AUXPWR_375: ::kernel::sys::raw::c_uint = 448;
pub const PCIM_PCAP_AUXPWRMASK: ::kernel::sys::raw::c_uint = 448;
pub const PCIM_PCAP_D1SUPP: ::kernel::sys::raw::c_uint = 512;
pub const PCIM_PCAP_D2SUPP: ::kernel::sys::raw::c_uint = 1024;
pub const PCIM_PCAP_D0PME: ::kernel::sys::raw::c_uint = 2048;
pub const PCIM_PCAP_D1PME: ::kernel::sys::raw::c_uint = 4096;
pub const PCIM_PCAP_D2PME: ::kernel::sys::raw::c_uint = 8192;
pub const PCIM_PCAP_D3PME_HOT: ::kernel::sys::raw::c_uint = 16384;
pub const PCIM_PCAP_D3PME_COLD: ::kernel::sys::raw::c_uint = 32768;
pub const PCIR_POWER_STATUS: ::kernel::sys::raw::c_uint = 4;
pub const PCIM_PSTAT_D0: ::kernel::sys::raw::c_uint = 0;
pub const PCIM_PSTAT_D1: ::kernel::sys::raw::c_uint = 1;
pub const PCIM_PSTAT_D2: ::kernel::sys::raw::c_uint = 2;
pub const PCIM_PSTAT_D3: ::kernel::sys::raw::c_uint = 3;
pub const PCIM_PSTAT_DMASK: ::kernel::sys::raw::c_uint = 3;
pub const PCIM_PSTAT_NOSOFTRESET: ::kernel::sys::raw::c_uint = 8;
pub const PCIM_PSTAT_PMEENABLE: ::kernel::sys::raw::c_uint = 256;
pub const PCIM_PSTAT_D0POWER: ::kernel::sys::raw::c_uint = 0;
pub const PCIM_PSTAT_D1POWER: ::kernel::sys::raw::c_uint = 512;
pub const PCIM_PSTAT_D2POWER: ::kernel::sys::raw::c_uint = 1024;
pub const PCIM_PSTAT_D3POWER: ::kernel::sys::raw::c_uint = 1536;
pub const PCIM_PSTAT_D0HEAT: ::kernel::sys::raw::c_uint = 2048;
pub const PCIM_PSTAT_D1HEAT: ::kernel::sys::raw::c_uint = 2560;
pub const PCIM_PSTAT_D2HEAT: ::kernel::sys::raw::c_uint = 3072;
pub const PCIM_PSTAT_D3HEAT: ::kernel::sys::raw::c_uint = 3584;
pub const PCIM_PSTAT_DATASELMASK: ::kernel::sys::raw::c_uint = 7680;
pub const PCIM_PSTAT_DATAUNKN: ::kernel::sys::raw::c_uint = 0;
pub const PCIM_PSTAT_DATADIV10: ::kernel::sys::raw::c_uint = 8192;
pub const PCIM_PSTAT_DATADIV100: ::kernel::sys::raw::c_uint = 16384;
pub const PCIM_PSTAT_DATADIV1000: ::kernel::sys::raw::c_uint = 24576;
pub const PCIM_PSTAT_DATADIVMASK: ::kernel::sys::raw::c_uint = 24576;
pub const PCIM_PSTAT_PME: ::kernel::sys::raw::c_uint = 32768;
pub const PCIR_POWER_BSE: ::kernel::sys::raw::c_uint = 6;
pub const PCIM_PMCSR_BSE_D3B3: ::kernel::sys::raw::c_uint = 0;
pub const PCIM_PMCSR_BSE_D3B2: ::kernel::sys::raw::c_uint = 64;
pub const PCIM_PMCSR_BSE_BPCCE: ::kernel::sys::raw::c_uint = 128;
pub const PCIR_POWER_DATA: ::kernel::sys::raw::c_uint = 7;
pub const PCIR_VPD_ADDR: ::kernel::sys::raw::c_uint = 2;
pub const PCIR_VPD_DATA: ::kernel::sys::raw::c_uint = 4;
pub const PCIR_MSI_CTRL: ::kernel::sys::raw::c_uint = 2;
pub const PCIM_MSICTRL_VECTOR: ::kernel::sys::raw::c_uint = 256;
pub const PCIM_MSICTRL_64BIT: ::kernel::sys::raw::c_uint = 128;
pub const PCIM_MSICTRL_MME_MASK: ::kernel::sys::raw::c_uint = 112;
pub const PCIM_MSICTRL_MME_1: ::kernel::sys::raw::c_uint = 0;
pub const PCIM_MSICTRL_MME_2: ::kernel::sys::raw::c_uint = 16;
pub const PCIM_MSICTRL_MME_4: ::kernel::sys::raw::c_uint = 32;
pub const PCIM_MSICTRL_MME_8: ::kernel::sys::raw::c_uint = 48;
pub const PCIM_MSICTRL_MME_16: ::kernel::sys::raw::c_uint = 64;
pub const PCIM_MSICTRL_MME_32: ::kernel::sys::raw::c_uint = 80;
pub const PCIM_MSICTRL_MMC_MASK: ::kernel::sys::raw::c_uint = 14;
pub const PCIM_MSICTRL_MMC_1: ::kernel::sys::raw::c_uint = 0;
pub const PCIM_MSICTRL_MMC_2: ::kernel::sys::raw::c_uint = 2;
pub const PCIM_MSICTRL_MMC_4: ::kernel::sys::raw::c_uint = 4;
pub const PCIM_MSICTRL_MMC_8: ::kernel::sys::raw::c_uint = 6;
pub const PCIM_MSICTRL_MMC_16: ::kernel::sys::raw::c_uint = 8;
pub const PCIM_MSICTRL_MMC_32: ::kernel::sys::raw::c_uint = 10;
pub const PCIM_MSICTRL_MSI_ENABLE: ::kernel::sys::raw::c_uint = 1;
pub const PCIR_MSI_ADDR: ::kernel::sys::raw::c_uint = 4;
pub const PCIR_MSI_ADDR_HIGH: ::kernel::sys::raw::c_uint = 8;
pub const PCIR_MSI_DATA: ::kernel::sys::raw::c_uint = 8;
pub const PCIR_MSI_DATA_64BIT: ::kernel::sys::raw::c_uint = 12;
pub const PCIR_MSI_MASK: ::kernel::sys::raw::c_uint = 16;
pub const PCIR_MSI_PENDING: ::kernel::sys::raw::c_uint = 20;
pub const PCIR_EA_NUM_ENT: ::kernel::sys::raw::c_uint = 2;
pub const PCIM_EA_NUM_ENT_MASK: ::kernel::sys::raw::c_uint = 63;
pub const PCIR_EA_FIRST_ENT: ::kernel::sys::raw::c_uint = 4;
pub const PCIR_EA_FIRST_ENT_BRIDGE: ::kernel::sys::raw::c_uint = 8;
pub const PCIM_EA_ES: ::kernel::sys::raw::c_uint = 7;
pub const PCIM_EA_BEI: ::kernel::sys::raw::c_uint = 240;
pub const PCIM_EA_BEI_OFFSET: ::kernel::sys::raw::c_uint = 4;
pub const PCIM_EA_BEI_BAR_0: ::kernel::sys::raw::c_uint = 0;
pub const PCIM_EA_BEI_BAR_5: ::kernel::sys::raw::c_uint = 5;
pub const PCIM_EA_BEI_BRIDGE: ::kernel::sys::raw::c_uint = 6;
pub const PCIM_EA_BEI_ENI: ::kernel::sys::raw::c_uint = 7;
pub const PCIM_EA_BEI_ROM: ::kernel::sys::raw::c_uint = 8;
pub const PCIM_EA_BEI_VF_BAR_0: ::kernel::sys::raw::c_uint = 9;
pub const PCIM_EA_BEI_VF_BAR_5: ::kernel::sys::raw::c_uint = 14;
pub const PCIM_EA_BEI_RESERVED: ::kernel::sys::raw::c_uint = 15;
pub const PCIM_EA_PP: ::kernel::sys::raw::c_uint = 65280;
pub const PCIM_EA_PP_OFFSET: ::kernel::sys::raw::c_uint = 8;
pub const PCIM_EA_SP_OFFSET: ::kernel::sys::raw::c_uint = 16;
pub const PCIM_EA_SP: ::kernel::sys::raw::c_uint = 16711680;
pub const PCIM_EA_P_MEM: ::kernel::sys::raw::c_uint = 0;
pub const PCIM_EA_P_MEM_PREFETCH: ::kernel::sys::raw::c_uint = 1;
pub const PCIM_EA_P_IO: ::kernel::sys::raw::c_uint = 2;
pub const PCIM_EA_P_VF_MEM_PREFETCH: ::kernel::sys::raw::c_uint = 3;
pub const PCIM_EA_P_VF_MEM: ::kernel::sys::raw::c_uint = 4;
pub const PCIM_EA_P_BRIDGE_MEM: ::kernel::sys::raw::c_uint = 5;
pub const PCIM_EA_P_BRIDGE_MEM_PREFETCH: ::kernel::sys::raw::c_uint = 6;
pub const PCIM_EA_P_BRIDGE_IO: ::kernel::sys::raw::c_uint = 7;
pub const PCIM_EA_P_MEM_RESERVED: ::kernel::sys::raw::c_uint = 253;
pub const PCIM_EA_P_IO_RESERVED: ::kernel::sys::raw::c_uint = 254;
pub const PCIM_EA_P_UNAVAILABLE: ::kernel::sys::raw::c_uint = 255;
pub const PCIM_EA_WRITABLE: ::kernel::sys::raw::c_uint = 1073741824;
pub const PCIM_EA_ENABLE: ::kernel::sys::raw::c_uint = 2147483648;
pub const PCIM_EA_BASE: ::kernel::sys::raw::c_uint = 4;
pub const PCIM_EA_MAX_OFFSET: ::kernel::sys::raw::c_uint = 8;
pub const PCIM_EA_IS_64: ::kernel::sys::raw::c_uint = 2;
pub const PCIM_EA_FIELD_MASK: ::kernel::sys::raw::c_uint = 4294967292;
pub const PCIXR_COMMAND: ::kernel::sys::raw::c_uint = 2;
pub const PCIXM_COMMAND_DPERR_E: ::kernel::sys::raw::c_uint = 1;
pub const PCIXM_COMMAND_ERO: ::kernel::sys::raw::c_uint = 2;
pub const PCIXM_COMMAND_MAX_READ: ::kernel::sys::raw::c_uint = 12;
pub const PCIXM_COMMAND_MAX_READ_512: ::kernel::sys::raw::c_uint = 0;
pub const PCIXM_COMMAND_MAX_READ_1024: ::kernel::sys::raw::c_uint = 4;
pub const PCIXM_COMMAND_MAX_READ_2048: ::kernel::sys::raw::c_uint = 8;
pub const PCIXM_COMMAND_MAX_READ_4096: ::kernel::sys::raw::c_uint = 12;
pub const PCIXM_COMMAND_MAX_SPLITS: ::kernel::sys::raw::c_uint = 112;
pub const PCIXM_COMMAND_MAX_SPLITS_1: ::kernel::sys::raw::c_uint = 0;
pub const PCIXM_COMMAND_MAX_SPLITS_2: ::kernel::sys::raw::c_uint = 16;
pub const PCIXM_COMMAND_MAX_SPLITS_3: ::kernel::sys::raw::c_uint = 32;
pub const PCIXM_COMMAND_MAX_SPLITS_4: ::kernel::sys::raw::c_uint = 48;
pub const PCIXM_COMMAND_MAX_SPLITS_8: ::kernel::sys::raw::c_uint = 64;
pub const PCIXM_COMMAND_MAX_SPLITS_12: ::kernel::sys::raw::c_uint = 80;
pub const PCIXM_COMMAND_MAX_SPLITS_16: ::kernel::sys::raw::c_uint = 96;
pub const PCIXM_COMMAND_MAX_SPLITS_32: ::kernel::sys::raw::c_uint = 112;
pub const PCIXM_COMMAND_VERSION: ::kernel::sys::raw::c_uint = 12288;
pub const PCIXR_STATUS: ::kernel::sys::raw::c_uint = 4;
pub const PCIXM_STATUS_DEVFN: ::kernel::sys::raw::c_uint = 255;
pub const PCIXM_STATUS_BUS: ::kernel::sys::raw::c_uint = 65280;
pub const PCIXM_STATUS_64BIT: ::kernel::sys::raw::c_uint = 65536;
pub const PCIXM_STATUS_133CAP: ::kernel::sys::raw::c_uint = 131072;
pub const PCIXM_STATUS_SC_DISCARDED: ::kernel::sys::raw::c_uint = 262144;
pub const PCIXM_STATUS_UNEXP_SC: ::kernel::sys::raw::c_uint = 524288;
pub const PCIXM_STATUS_COMPLEX_DEV: ::kernel::sys::raw::c_uint = 1048576;
pub const PCIXM_STATUS_MAX_READ: ::kernel::sys::raw::c_uint = 6291456;
pub const PCIXM_STATUS_MAX_READ_512: ::kernel::sys::raw::c_uint = 0;
pub const PCIXM_STATUS_MAX_READ_1024: ::kernel::sys::raw::c_uint = 2097152;
pub const PCIXM_STATUS_MAX_READ_2048: ::kernel::sys::raw::c_uint = 4194304;
pub const PCIXM_STATUS_MAX_READ_4096: ::kernel::sys::raw::c_uint = 6291456;
pub const PCIXM_STATUS_MAX_SPLITS: ::kernel::sys::raw::c_uint = 58720256;
pub const PCIXM_STATUS_MAX_SPLITS_1: ::kernel::sys::raw::c_uint = 0;
pub const PCIXM_STATUS_MAX_SPLITS_2: ::kernel::sys::raw::c_uint = 8388608;
pub const PCIXM_STATUS_MAX_SPLITS_3: ::kernel::sys::raw::c_uint = 16777216;
pub const PCIXM_STATUS_MAX_SPLITS_4: ::kernel::sys::raw::c_uint = 25165824;
pub const PCIXM_STATUS_MAX_SPLITS_8: ::kernel::sys::raw::c_uint = 33554432;
pub const PCIXM_STATUS_MAX_SPLITS_12: ::kernel::sys::raw::c_uint = 41943040;
pub const PCIXM_STATUS_MAX_SPLITS_16: ::kernel::sys::raw::c_uint = 50331648;
pub const PCIXM_STATUS_MAX_SPLITS_32: ::kernel::sys::raw::c_uint = 58720256;
pub const PCIXM_STATUS_MAX_CUM_READ: ::kernel::sys::raw::c_uint = 469762048;
pub const PCIXM_STATUS_RCVD_SC_ERR: ::kernel::sys::raw::c_uint = 536870912;
pub const PCIXM_STATUS_266CAP: ::kernel::sys::raw::c_uint = 1073741824;
pub const PCIXM_STATUS_533CAP: ::kernel::sys::raw::c_uint = 2147483648;
pub const PCIXR_SEC_STATUS: ::kernel::sys::raw::c_uint = 2;
pub const PCIXM_SEC_STATUS_64BIT: ::kernel::sys::raw::c_uint = 1;
pub const PCIXM_SEC_STATUS_133CAP: ::kernel::sys::raw::c_uint = 2;
pub const PCIXM_SEC_STATUS_SC_DISC: ::kernel::sys::raw::c_uint = 4;
pub const PCIXM_SEC_STATUS_UNEXP_SC: ::kernel::sys::raw::c_uint = 8;
pub const PCIXM_SEC_STATUS_SC_OVERRUN: ::kernel::sys::raw::c_uint = 16;
pub const PCIXM_SEC_STATUS_SR_DELAYED: ::kernel::sys::raw::c_uint = 32;
pub const PCIXM_SEC_STATUS_BUS_MODE: ::kernel::sys::raw::c_uint = 960;
pub const PCIXM_SEC_STATUS_VERSION: ::kernel::sys::raw::c_uint = 12288;
pub const PCIXM_SEC_STATUS_266CAP: ::kernel::sys::raw::c_uint = 16384;
pub const PCIXM_SEC_STATUS_533CAP: ::kernel::sys::raw::c_uint = 32768;
pub const PCIXR_BRIDGE_STATUS: ::kernel::sys::raw::c_uint = 4;
pub const PCIXM_BRIDGE_STATUS_DEVFN: ::kernel::sys::raw::c_uint = 255;
pub const PCIXM_BRIDGE_STATUS_BUS: ::kernel::sys::raw::c_uint = 65280;
pub const PCIXM_BRIDGE_STATUS_64BIT: ::kernel::sys::raw::c_uint = 65536;
pub const PCIXM_BRIDGE_STATUS_133CAP: ::kernel::sys::raw::c_uint = 131072;
pub const PCIXM_BRIDGE_STATUS_SC_DISCARDED: ::kernel::sys::raw::c_uint =
    262144;
pub const PCIXM_BRIDGE_STATUS_UNEXP_SC: ::kernel::sys::raw::c_uint = 524288;
pub const PCIXM_BRIDGE_STATUS_SC_OVERRUN: ::kernel::sys::raw::c_uint =
    1048576;
pub const PCIXM_BRIDGE_STATUS_SR_DELAYED: ::kernel::sys::raw::c_uint =
    2097152;
pub const PCIXM_BRIDGE_STATUS_DEVID_MSGCAP: ::kernel::sys::raw::c_uint =
    536870912;
pub const PCIXM_BRIDGE_STATUS_266CAP: ::kernel::sys::raw::c_uint = 1073741824;
pub const PCIXM_BRIDGE_STATUS_533CAP: ::kernel::sys::raw::c_uint = 2147483648;
pub const PCIR_HT_COMMAND: ::kernel::sys::raw::c_uint = 2;
pub const PCIM_HTCMD_CAP_MASK: ::kernel::sys::raw::c_uint = 63488;
pub const PCIM_HTCAP_SLAVE: ::kernel::sys::raw::c_uint = 0;
pub const PCIM_HTCAP_HOST: ::kernel::sys::raw::c_uint = 8192;
pub const PCIM_HTCAP_SWITCH: ::kernel::sys::raw::c_uint = 16384;
pub const PCIM_HTCAP_INTERRUPT: ::kernel::sys::raw::c_uint = 32768;
pub const PCIM_HTCAP_REVISION_ID: ::kernel::sys::raw::c_uint = 34816;
pub const PCIM_HTCAP_UNITID_CLUMPING: ::kernel::sys::raw::c_uint = 36864;
pub const PCIM_HTCAP_EXT_CONFIG_SPACE: ::kernel::sys::raw::c_uint = 38912;
pub const PCIM_HTCAP_ADDRESS_MAPPING: ::kernel::sys::raw::c_uint = 40960;
pub const PCIM_HTCAP_MSI_MAPPING: ::kernel::sys::raw::c_uint = 43008;
pub const PCIM_HTCAP_DIRECT_ROUTE: ::kernel::sys::raw::c_uint = 45056;
pub const PCIM_HTCAP_VCSET: ::kernel::sys::raw::c_uint = 47104;
pub const PCIM_HTCAP_RETRY_MODE: ::kernel::sys::raw::c_uint = 49152;
pub const PCIM_HTCAP_X86_ENCODING: ::kernel::sys::raw::c_uint = 51200;
pub const PCIM_HTCAP_GEN3: ::kernel::sys::raw::c_uint = 53248;
pub const PCIM_HTCAP_FLE: ::kernel::sys::raw::c_uint = 55296;
pub const PCIM_HTCAP_PM: ::kernel::sys::raw::c_uint = 57344;
pub const PCIM_HTCAP_HIGH_NODE_COUNT: ::kernel::sys::raw::c_uint = 59392;
pub const PCIM_HTCMD_MSI_ENABLE: ::kernel::sys::raw::c_uint = 1;
pub const PCIM_HTCMD_MSI_FIXED: ::kernel::sys::raw::c_uint = 2;
pub const PCIR_HTMSI_ADDRESS_LO: ::kernel::sys::raw::c_uint = 4;
pub const PCIR_HTMSI_ADDRESS_HI: ::kernel::sys::raw::c_uint = 8;
pub const PCIR_VENDOR_LENGTH: ::kernel::sys::raw::c_uint = 2;
pub const PCIR_VENDOR_DATA: ::kernel::sys::raw::c_uint = 3;
pub const PCIR_DEVICE_LENGTH: ::kernel::sys::raw::c_uint = 2;
pub const PCIR_DEBUG_PORT: ::kernel::sys::raw::c_uint = 2;
pub const PCIM_DEBUG_PORT_OFFSET: ::kernel::sys::raw::c_uint = 8191;
pub const PCIM_DEBUG_PORT_BAR: ::kernel::sys::raw::c_uint = 57344;
pub const PCIR_SUBVENDCAP_ID: ::kernel::sys::raw::c_uint = 4;
pub const PCIER_FLAGS: ::kernel::sys::raw::c_uint = 2;
pub const PCIEM_FLAGS_VERSION: ::kernel::sys::raw::c_uint = 15;
pub const PCIEM_FLAGS_TYPE: ::kernel::sys::raw::c_uint = 240;
pub const PCIEM_TYPE_ENDPOINT: ::kernel::sys::raw::c_uint = 0;
pub const PCIEM_TYPE_LEGACY_ENDPOINT: ::kernel::sys::raw::c_uint = 16;
pub const PCIEM_TYPE_ROOT_PORT: ::kernel::sys::raw::c_uint = 64;
pub const PCIEM_TYPE_UPSTREAM_PORT: ::kernel::sys::raw::c_uint = 80;
pub const PCIEM_TYPE_DOWNSTREAM_PORT: ::kernel::sys::raw::c_uint = 96;
pub const PCIEM_TYPE_PCI_BRIDGE: ::kernel::sys::raw::c_uint = 112;
pub const PCIEM_TYPE_PCIE_BRIDGE: ::kernel::sys::raw::c_uint = 128;
pub const PCIEM_TYPE_ROOT_INT_EP: ::kernel::sys::raw::c_uint = 144;
pub const PCIEM_TYPE_ROOT_EC: ::kernel::sys::raw::c_uint = 160;
pub const PCIEM_FLAGS_SLOT: ::kernel::sys::raw::c_uint = 256;
pub const PCIEM_FLAGS_IRQ: ::kernel::sys::raw::c_uint = 15872;
pub const PCIER_DEVICE_CAP: ::kernel::sys::raw::c_uint = 4;
pub const PCIEM_CAP_MAX_PAYLOAD: ::kernel::sys::raw::c_uint = 7;
pub const PCIEM_CAP_PHANTHOM_FUNCS: ::kernel::sys::raw::c_uint = 24;
pub const PCIEM_CAP_EXT_TAG_FIELD: ::kernel::sys::raw::c_uint = 32;
pub const PCIEM_CAP_L0S_LATENCY: ::kernel::sys::raw::c_uint = 448;
pub const PCIEM_CAP_L1_LATENCY: ::kernel::sys::raw::c_uint = 3584;
pub const PCIEM_CAP_ROLE_ERR_RPT: ::kernel::sys::raw::c_uint = 32768;
pub const PCIEM_CAP_SLOT_PWR_LIM_VAL: ::kernel::sys::raw::c_uint = 66846720;
pub const PCIEM_CAP_SLOT_PWR_LIM_SCALE: ::kernel::sys::raw::c_uint =
    201326592;
pub const PCIEM_CAP_FLR: ::kernel::sys::raw::c_uint = 268435456;
pub const PCIER_DEVICE_CTL: ::kernel::sys::raw::c_uint = 8;
pub const PCIEM_CTL_COR_ENABLE: ::kernel::sys::raw::c_uint = 1;
pub const PCIEM_CTL_NFER_ENABLE: ::kernel::sys::raw::c_uint = 2;
pub const PCIEM_CTL_FER_ENABLE: ::kernel::sys::raw::c_uint = 4;
pub const PCIEM_CTL_URR_ENABLE: ::kernel::sys::raw::c_uint = 8;
pub const PCIEM_CTL_RELAXED_ORD_ENABLE: ::kernel::sys::raw::c_uint = 16;
pub const PCIEM_CTL_MAX_PAYLOAD: ::kernel::sys::raw::c_uint = 224;
pub const PCIEM_CTL_EXT_TAG_FIELD: ::kernel::sys::raw::c_uint = 256;
pub const PCIEM_CTL_PHANTHOM_FUNCS: ::kernel::sys::raw::c_uint = 512;
pub const PCIEM_CTL_AUX_POWER_PM: ::kernel::sys::raw::c_uint = 1024;
pub const PCIEM_CTL_NOSNOOP_ENABLE: ::kernel::sys::raw::c_uint = 2048;
pub const PCIEM_CTL_MAX_READ_REQUEST: ::kernel::sys::raw::c_uint = 28672;
pub const PCIEM_CTL_BRDG_CFG_RETRY: ::kernel::sys::raw::c_uint = 32768;
pub const PCIEM_CTL_INITIATE_FLR: ::kernel::sys::raw::c_uint = 32768;
pub const PCIER_DEVICE_STA: ::kernel::sys::raw::c_uint = 10;
pub const PCIEM_STA_CORRECTABLE_ERROR: ::kernel::sys::raw::c_uint = 1;
pub const PCIEM_STA_NON_FATAL_ERROR: ::kernel::sys::raw::c_uint = 2;
pub const PCIEM_STA_FATAL_ERROR: ::kernel::sys::raw::c_uint = 4;
pub const PCIEM_STA_UNSUPPORTED_REQ: ::kernel::sys::raw::c_uint = 8;
pub const PCIEM_STA_AUX_POWER: ::kernel::sys::raw::c_uint = 16;
pub const PCIEM_STA_TRANSACTION_PND: ::kernel::sys::raw::c_uint = 32;
pub const PCIER_LINK_CAP: ::kernel::sys::raw::c_uint = 12;
pub const PCIEM_LINK_CAP_MAX_SPEED: ::kernel::sys::raw::c_uint = 15;
pub const PCIEM_LINK_CAP_MAX_WIDTH: ::kernel::sys::raw::c_uint = 1008;
pub const PCIEM_LINK_CAP_ASPM: ::kernel::sys::raw::c_uint = 3072;
pub const PCIEM_LINK_CAP_L0S_EXIT: ::kernel::sys::raw::c_uint = 28672;
pub const PCIEM_LINK_CAP_L1_EXIT: ::kernel::sys::raw::c_uint = 229376;
pub const PCIEM_LINK_CAP_CLOCK_PM: ::kernel::sys::raw::c_uint = 262144;
pub const PCIEM_LINK_CAP_SURPRISE_DOWN: ::kernel::sys::raw::c_uint = 524288;
pub const PCIEM_LINK_CAP_DL_ACTIVE: ::kernel::sys::raw::c_uint = 1048576;
pub const PCIEM_LINK_CAP_LINK_BW_NOTIFY: ::kernel::sys::raw::c_uint = 2097152;
pub const PCIEM_LINK_CAP_ASPM_COMPLIANCE: ::kernel::sys::raw::c_uint =
    4194304;
pub const PCIEM_LINK_CAP_PORT: ::kernel::sys::raw::c_uint = 4278190080;
pub const PCIER_LINK_CTL: ::kernel::sys::raw::c_uint = 16;
pub const PCIEM_LINK_CTL_ASPMC_DIS: ::kernel::sys::raw::c_uint = 0;
pub const PCIEM_LINK_CTL_ASPMC_L0S: ::kernel::sys::raw::c_uint = 1;
pub const PCIEM_LINK_CTL_ASPMC_L1: ::kernel::sys::raw::c_uint = 2;
pub const PCIEM_LINK_CTL_ASPMC: ::kernel::sys::raw::c_uint = 3;
pub const PCIEM_LINK_CTL_RCB: ::kernel::sys::raw::c_uint = 8;
pub const PCIEM_LINK_CTL_LINK_DIS: ::kernel::sys::raw::c_uint = 16;
pub const PCIEM_LINK_CTL_RETRAIN_LINK: ::kernel::sys::raw::c_uint = 32;
pub const PCIEM_LINK_CTL_COMMON_CLOCK: ::kernel::sys::raw::c_uint = 64;
pub const PCIEM_LINK_CTL_EXTENDED_SYNC: ::kernel::sys::raw::c_uint = 128;
pub const PCIEM_LINK_CTL_ECPM: ::kernel::sys::raw::c_uint = 256;
pub const PCIEM_LINK_CTL_HAWD: ::kernel::sys::raw::c_uint = 512;
pub const PCIEM_LINK_CTL_LBMIE: ::kernel::sys::raw::c_uint = 1024;
pub const PCIEM_LINK_CTL_LABIE: ::kernel::sys::raw::c_uint = 2048;
pub const PCIER_LINK_STA: ::kernel::sys::raw::c_uint = 18;
pub const PCIEM_LINK_STA_SPEED: ::kernel::sys::raw::c_uint = 15;
pub const PCIEM_LINK_STA_WIDTH: ::kernel::sys::raw::c_uint = 1008;
pub const PCIEM_LINK_STA_TRAINING_ERROR: ::kernel::sys::raw::c_uint = 1024;
pub const PCIEM_LINK_STA_TRAINING: ::kernel::sys::raw::c_uint = 2048;
pub const PCIEM_LINK_STA_SLOT_CLOCK: ::kernel::sys::raw::c_uint = 4096;
pub const PCIEM_LINK_STA_DL_ACTIVE: ::kernel::sys::raw::c_uint = 8192;
pub const PCIEM_LINK_STA_LINK_BW_MGMT: ::kernel::sys::raw::c_uint = 16384;
pub const PCIEM_LINK_STA_LINK_AUTO_BW: ::kernel::sys::raw::c_uint = 32768;
pub const PCIER_SLOT_CAP: ::kernel::sys::raw::c_uint = 20;
pub const PCIEM_SLOT_CAP_APB: ::kernel::sys::raw::c_uint = 1;
pub const PCIEM_SLOT_CAP_PCP: ::kernel::sys::raw::c_uint = 2;
pub const PCIEM_SLOT_CAP_MRLSP: ::kernel::sys::raw::c_uint = 4;
pub const PCIEM_SLOT_CAP_AIP: ::kernel::sys::raw::c_uint = 8;
pub const PCIEM_SLOT_CAP_PIP: ::kernel::sys::raw::c_uint = 16;
pub const PCIEM_SLOT_CAP_HPS: ::kernel::sys::raw::c_uint = 32;
pub const PCIEM_SLOT_CAP_HPC: ::kernel::sys::raw::c_uint = 64;
pub const PCIEM_SLOT_CAP_SPLV: ::kernel::sys::raw::c_uint = 32640;
pub const PCIEM_SLOT_CAP_SPLS: ::kernel::sys::raw::c_uint = 98304;
pub const PCIEM_SLOT_CAP_EIP: ::kernel::sys::raw::c_uint = 131072;
pub const PCIEM_SLOT_CAP_NCCS: ::kernel::sys::raw::c_uint = 262144;
pub const PCIEM_SLOT_CAP_PSN: ::kernel::sys::raw::c_uint = 4294443008;
pub const PCIER_SLOT_CTL: ::kernel::sys::raw::c_uint = 24;
pub const PCIEM_SLOT_CTL_ABPE: ::kernel::sys::raw::c_uint = 1;
pub const PCIEM_SLOT_CTL_PFDE: ::kernel::sys::raw::c_uint = 2;
pub const PCIEM_SLOT_CTL_MRLSCE: ::kernel::sys::raw::c_uint = 4;
pub const PCIEM_SLOT_CTL_PDCE: ::kernel::sys::raw::c_uint = 8;
pub const PCIEM_SLOT_CTL_CCIE: ::kernel::sys::raw::c_uint = 16;
pub const PCIEM_SLOT_CTL_HPIE: ::kernel::sys::raw::c_uint = 32;
pub const PCIEM_SLOT_CTL_AIC: ::kernel::sys::raw::c_uint = 192;
pub const PCIEM_SLOT_CTL_AI_ON: ::kernel::sys::raw::c_uint = 64;
pub const PCIEM_SLOT_CTL_AI_BLINK: ::kernel::sys::raw::c_uint = 128;
pub const PCIEM_SLOT_CTL_AI_OFF: ::kernel::sys::raw::c_uint = 192;
pub const PCIEM_SLOT_CTL_PIC: ::kernel::sys::raw::c_uint = 768;
pub const PCIEM_SLOT_CTL_PI_ON: ::kernel::sys::raw::c_uint = 256;
pub const PCIEM_SLOT_CTL_PI_BLINK: ::kernel::sys::raw::c_uint = 512;
pub const PCIEM_SLOT_CTL_PI_OFF: ::kernel::sys::raw::c_uint = 768;
pub const PCIEM_SLOT_CTL_PCC: ::kernel::sys::raw::c_uint = 1024;
pub const PCIEM_SLOT_CTL_PC_ON: ::kernel::sys::raw::c_uint = 0;
pub const PCIEM_SLOT_CTL_PC_OFF: ::kernel::sys::raw::c_uint = 1024;
pub const PCIEM_SLOT_CTL_EIC: ::kernel::sys::raw::c_uint = 2048;
pub const PCIEM_SLOT_CTL_DLLSCE: ::kernel::sys::raw::c_uint = 4096;
pub const PCIER_SLOT_STA: ::kernel::sys::raw::c_uint = 26;
pub const PCIEM_SLOT_STA_ABP: ::kernel::sys::raw::c_uint = 1;
pub const PCIEM_SLOT_STA_PFD: ::kernel::sys::raw::c_uint = 2;
pub const PCIEM_SLOT_STA_MRLSC: ::kernel::sys::raw::c_uint = 4;
pub const PCIEM_SLOT_STA_PDC: ::kernel::sys::raw::c_uint = 8;
pub const PCIEM_SLOT_STA_CC: ::kernel::sys::raw::c_uint = 16;
pub const PCIEM_SLOT_STA_MRLSS: ::kernel::sys::raw::c_uint = 32;
pub const PCIEM_SLOT_STA_PDS: ::kernel::sys::raw::c_uint = 64;
pub const PCIEM_SLOT_STA_EIS: ::kernel::sys::raw::c_uint = 128;
pub const PCIEM_SLOT_STA_DLLSC: ::kernel::sys::raw::c_uint = 256;
pub const PCIER_ROOT_CTL: ::kernel::sys::raw::c_uint = 28;
pub const PCIEM_ROOT_CTL_SERR_CORR: ::kernel::sys::raw::c_uint = 1;
pub const PCIEM_ROOT_CTL_SERR_NONFATAL: ::kernel::sys::raw::c_uint = 2;
pub const PCIEM_ROOT_CTL_SERR_FATAL: ::kernel::sys::raw::c_uint = 4;
pub const PCIEM_ROOT_CTL_PME: ::kernel::sys::raw::c_uint = 8;
pub const PCIEM_ROOT_CTL_CRS_VIS: ::kernel::sys::raw::c_uint = 16;
pub const PCIER_ROOT_CAP: ::kernel::sys::raw::c_uint = 30;
pub const PCIEM_ROOT_CAP_CRS_VIS: ::kernel::sys::raw::c_uint = 1;
pub const PCIER_ROOT_STA: ::kernel::sys::raw::c_uint = 32;
pub const PCIEM_ROOT_STA_PME_REQID_MASK: ::kernel::sys::raw::c_uint = 65535;
pub const PCIEM_ROOT_STA_PME_STATUS: ::kernel::sys::raw::c_uint = 65536;
pub const PCIEM_ROOT_STA_PME_PEND: ::kernel::sys::raw::c_uint = 131072;
pub const PCIER_DEVICE_CAP2: ::kernel::sys::raw::c_uint = 36;
pub const PCIEM_CAP2_COMP_TIMO_RANGES: ::kernel::sys::raw::c_uint = 15;
pub const PCIEM_CAP2_COMP_TIMO_RANGE_A: ::kernel::sys::raw::c_uint = 1;
pub const PCIEM_CAP2_COMP_TIMO_RANGE_B: ::kernel::sys::raw::c_uint = 2;
pub const PCIEM_CAP2_COMP_TIMO_RANGE_C: ::kernel::sys::raw::c_uint = 4;
pub const PCIEM_CAP2_COMP_TIMO_RANGE_D: ::kernel::sys::raw::c_uint = 8;
pub const PCIEM_CAP2_COMP_TIMO_DISABLE: ::kernel::sys::raw::c_uint = 16;
pub const PCIEM_CAP2_ARI: ::kernel::sys::raw::c_uint = 32;
pub const PCIER_DEVICE_CTL2: ::kernel::sys::raw::c_uint = 40;
pub const PCIEM_CTL2_COMP_TIMO_VAL: ::kernel::sys::raw::c_uint = 15;
pub const PCIEM_CTL2_COMP_TIMO_50MS: ::kernel::sys::raw::c_uint = 0;
pub const PCIEM_CTL2_COMP_TIMO_100US: ::kernel::sys::raw::c_uint = 1;
pub const PCIEM_CTL2_COMP_TIMO_10MS: ::kernel::sys::raw::c_uint = 2;
pub const PCIEM_CTL2_COMP_TIMO_55MS: ::kernel::sys::raw::c_uint = 5;
pub const PCIEM_CTL2_COMP_TIMO_210MS: ::kernel::sys::raw::c_uint = 6;
pub const PCIEM_CTL2_COMP_TIMO_900MS: ::kernel::sys::raw::c_uint = 9;
pub const PCIEM_CTL2_COMP_TIMO_3500MS: ::kernel::sys::raw::c_uint = 10;
pub const PCIEM_CTL2_COMP_TIMO_13S: ::kernel::sys::raw::c_uint = 13;
pub const PCIEM_CTL2_COMP_TIMO_64S: ::kernel::sys::raw::c_uint = 14;
pub const PCIEM_CTL2_COMP_TIMO_DISABLE: ::kernel::sys::raw::c_uint = 16;
pub const PCIEM_CTL2_ARI: ::kernel::sys::raw::c_uint = 32;
pub const PCIEM_CTL2_ATOMIC_REQ_ENABLE: ::kernel::sys::raw::c_uint = 64;
pub const PCIEM_CTL2_ATOMIC_EGR_BLOCK: ::kernel::sys::raw::c_uint = 128;
pub const PCIEM_CTL2_ID_ORDERED_REQ_EN: ::kernel::sys::raw::c_uint = 256;
pub const PCIEM_CTL2_ID_ORDERED_CMP_EN: ::kernel::sys::raw::c_uint = 512;
pub const PCIEM_CTL2_LTR_ENABLE: ::kernel::sys::raw::c_uint = 1024;
pub const PCIEM_CTL2_OBFF: ::kernel::sys::raw::c_uint = 24576;
pub const PCIEM_OBFF_DISABLE: ::kernel::sys::raw::c_uint = 0;
pub const PCIEM_OBFF_MSGA_ENABLE: ::kernel::sys::raw::c_uint = 8192;
pub const PCIEM_OBFF_MSGB_ENABLE: ::kernel::sys::raw::c_uint = 16384;
pub const PCIEM_OBFF_WAKE_ENABLE: ::kernel::sys::raw::c_uint = 24576;
pub const PCIEM_CTL2_END2END_TLP: ::kernel::sys::raw::c_uint = 32768;
pub const PCIER_DEVICE_STA2: ::kernel::sys::raw::c_uint = 42;
pub const PCIER_LINK_CAP2: ::kernel::sys::raw::c_uint = 44;
pub const PCIER_LINK_CTL2: ::kernel::sys::raw::c_uint = 48;
pub const PCIER_LINK_STA2: ::kernel::sys::raw::c_uint = 50;
pub const PCIER_SLOT_CAP2: ::kernel::sys::raw::c_uint = 52;
pub const PCIER_SLOT_CTL2: ::kernel::sys::raw::c_uint = 56;
pub const PCIER_SLOT_STA2: ::kernel::sys::raw::c_uint = 58;
pub const PCIR_MSIX_CTRL: ::kernel::sys::raw::c_uint = 2;
pub const PCIM_MSIXCTRL_MSIX_ENABLE: ::kernel::sys::raw::c_uint = 32768;
pub const PCIM_MSIXCTRL_FUNCTION_MASK: ::kernel::sys::raw::c_uint = 16384;
pub const PCIM_MSIXCTRL_TABLE_SIZE: ::kernel::sys::raw::c_uint = 2047;
pub const PCIR_MSIX_TABLE: ::kernel::sys::raw::c_uint = 4;
pub const PCIR_MSIX_PBA: ::kernel::sys::raw::c_uint = 8;
pub const PCIM_MSIX_BIR_MASK: ::kernel::sys::raw::c_uint = 7;
pub const PCIM_MSIX_BIR_BAR_10: ::kernel::sys::raw::c_uint = 0;
pub const PCIM_MSIX_BIR_BAR_14: ::kernel::sys::raw::c_uint = 1;
pub const PCIM_MSIX_BIR_BAR_18: ::kernel::sys::raw::c_uint = 2;
pub const PCIM_MSIX_BIR_BAR_1C: ::kernel::sys::raw::c_uint = 3;
pub const PCIM_MSIX_BIR_BAR_20: ::kernel::sys::raw::c_uint = 4;
pub const PCIM_MSIX_BIR_BAR_24: ::kernel::sys::raw::c_uint = 5;
pub const PCIM_MSIX_VCTRL_MASK: ::kernel::sys::raw::c_uint = 1;
pub const PCIR_PCIAF_CAP: ::kernel::sys::raw::c_uint = 3;
pub const PCIM_PCIAFCAP_TP: ::kernel::sys::raw::c_uint = 1;
pub const PCIM_PCIAFCAP_FLR: ::kernel::sys::raw::c_uint = 2;
pub const PCIR_PCIAF_CTRL: ::kernel::sys::raw::c_uint = 4;
pub const PCIR_PCIAFCTRL_FLR: ::kernel::sys::raw::c_uint = 1;
pub const PCIR_PCIAF_STATUS: ::kernel::sys::raw::c_uint = 5;
pub const PCIR_PCIAFSTATUS_TP: ::kernel::sys::raw::c_uint = 1;
pub const PCIR_AER_UC_STATUS: ::kernel::sys::raw::c_uint = 4;
pub const PCIM_AER_UC_TRAINING_ERROR: ::kernel::sys::raw::c_uint = 1;
pub const PCIM_AER_UC_DL_PROTOCOL_ERROR: ::kernel::sys::raw::c_uint = 16;
pub const PCIM_AER_UC_SURPRISE_LINK_DOWN: ::kernel::sys::raw::c_uint = 32;
pub const PCIM_AER_UC_POISONED_TLP: ::kernel::sys::raw::c_uint = 4096;
pub const PCIM_AER_UC_FC_PROTOCOL_ERROR: ::kernel::sys::raw::c_uint = 8192;
pub const PCIM_AER_UC_COMPLETION_TIMEOUT: ::kernel::sys::raw::c_uint = 16384;
pub const PCIM_AER_UC_COMPLETER_ABORT: ::kernel::sys::raw::c_uint = 32768;
pub const PCIM_AER_UC_UNEXPECTED_COMPLETION: ::kernel::sys::raw::c_uint =
    65536;
pub const PCIM_AER_UC_RECEIVER_OVERFLOW: ::kernel::sys::raw::c_uint = 131072;
pub const PCIM_AER_UC_MALFORMED_TLP: ::kernel::sys::raw::c_uint = 262144;
pub const PCIM_AER_UC_ECRC_ERROR: ::kernel::sys::raw::c_uint = 524288;
pub const PCIM_AER_UC_UNSUPPORTED_REQUEST: ::kernel::sys::raw::c_uint =
    1048576;
pub const PCIM_AER_UC_ACS_VIOLATION: ::kernel::sys::raw::c_uint = 2097152;
pub const PCIM_AER_UC_INTERNAL_ERROR: ::kernel::sys::raw::c_uint = 4194304;
pub const PCIM_AER_UC_MC_BLOCKED_TLP: ::kernel::sys::raw::c_uint = 8388608;
pub const PCIM_AER_UC_ATOMIC_EGRESS_BLK: ::kernel::sys::raw::c_uint =
    16777216;
pub const PCIM_AER_UC_TLP_PREFIX_BLOCKED: ::kernel::sys::raw::c_uint =
    33554432;
pub const PCIR_AER_UC_MASK: ::kernel::sys::raw::c_uint = 8;
pub const PCIR_AER_UC_SEVERITY: ::kernel::sys::raw::c_uint = 12;
pub const PCIR_AER_COR_STATUS: ::kernel::sys::raw::c_uint = 16;
pub const PCIM_AER_COR_RECEIVER_ERROR: ::kernel::sys::raw::c_uint = 1;
pub const PCIM_AER_COR_BAD_TLP: ::kernel::sys::raw::c_uint = 64;
pub const PCIM_AER_COR_BAD_DLLP: ::kernel::sys::raw::c_uint = 128;
pub const PCIM_AER_COR_REPLAY_ROLLOVER: ::kernel::sys::raw::c_uint = 256;
pub const PCIM_AER_COR_REPLAY_TIMEOUT: ::kernel::sys::raw::c_uint = 4096;
pub const PCIM_AER_COR_ADVISORY_NF_ERROR: ::kernel::sys::raw::c_uint = 8192;
pub const PCIM_AER_COR_INTERNAL_ERROR: ::kernel::sys::raw::c_uint = 16384;
pub const PCIM_AER_COR_HEADER_LOG_OVFLOW: ::kernel::sys::raw::c_uint = 32768;
pub const PCIR_AER_COR_MASK: ::kernel::sys::raw::c_uint = 20;
pub const PCIR_AER_CAP_CONTROL: ::kernel::sys::raw::c_uint = 24;
pub const PCIM_AER_FIRST_ERROR_PTR: ::kernel::sys::raw::c_uint = 31;
pub const PCIM_AER_ECRC_GEN_CAPABLE: ::kernel::sys::raw::c_uint = 32;
pub const PCIM_AER_ECRC_GEN_ENABLE: ::kernel::sys::raw::c_uint = 64;
pub const PCIM_AER_ECRC_CHECK_CAPABLE: ::kernel::sys::raw::c_uint = 128;
pub const PCIM_AER_ECRC_CHECK_ENABLE: ::kernel::sys::raw::c_uint = 256;
pub const PCIM_AER_MULT_HDR_CAPABLE: ::kernel::sys::raw::c_uint = 512;
pub const PCIM_AER_MULT_HDR_ENABLE: ::kernel::sys::raw::c_uint = 1024;
pub const PCIM_AER_TLP_PREFIX_LOG_PRESENT: ::kernel::sys::raw::c_uint = 2048;
pub const PCIR_AER_HEADER_LOG: ::kernel::sys::raw::c_uint = 28;
pub const PCIR_AER_ROOTERR_CMD: ::kernel::sys::raw::c_uint = 44;
pub const PCIM_AER_ROOTERR_COR_ENABLE: ::kernel::sys::raw::c_uint = 1;
pub const PCIM_AER_ROOTERR_NF_ENABLE: ::kernel::sys::raw::c_uint = 2;
pub const PCIM_AER_ROOTERR_F_ENABLE: ::kernel::sys::raw::c_uint = 4;
pub const PCIR_AER_ROOTERR_STATUS: ::kernel::sys::raw::c_uint = 48;
pub const PCIM_AER_ROOTERR_COR_ERR: ::kernel::sys::raw::c_uint = 1;
pub const PCIM_AER_ROOTERR_MULTI_COR_ERR: ::kernel::sys::raw::c_uint = 2;
pub const PCIM_AER_ROOTERR_UC_ERR: ::kernel::sys::raw::c_uint = 4;
pub const PCIM_AER_ROOTERR_MULTI_UC_ERR: ::kernel::sys::raw::c_uint = 8;
pub const PCIM_AER_ROOTERR_FIRST_UC_FATAL: ::kernel::sys::raw::c_uint = 16;
pub const PCIM_AER_ROOTERR_NF_ERR: ::kernel::sys::raw::c_uint = 32;
pub const PCIM_AER_ROOTERR_F_ERR: ::kernel::sys::raw::c_uint = 64;
pub const PCIM_AER_ROOTERR_INT_MESSAGE: ::kernel::sys::raw::c_uint =
    4160749568;
pub const PCIR_AER_COR_SOURCE_ID: ::kernel::sys::raw::c_uint = 52;
pub const PCIR_AER_ERR_SOURCE_ID: ::kernel::sys::raw::c_uint = 54;
pub const PCIR_AER_TLP_PREFIX_LOG: ::kernel::sys::raw::c_uint = 56;
pub const PCIR_VC_CAP1: ::kernel::sys::raw::c_uint = 4;
pub const PCIM_VC_CAP1_EXT_COUNT: ::kernel::sys::raw::c_uint = 7;
pub const PCIM_VC_CAP1_LOWPRI_EXT_COUNT: ::kernel::sys::raw::c_uint = 112;
pub const PCIR_VC_CAP2: ::kernel::sys::raw::c_uint = 8;
pub const PCIR_VC_CONTROL: ::kernel::sys::raw::c_uint = 12;
pub const PCIR_VC_STATUS: ::kernel::sys::raw::c_uint = 14;
pub const PCIR_SERIAL_LOW: ::kernel::sys::raw::c_uint = 4;
pub const PCIR_SERIAL_HIGH: ::kernel::sys::raw::c_uint = 8;
pub const PCIR_SRIOV_CTL: ::kernel::sys::raw::c_uint = 8;
pub const PCIM_SRIOV_VF_EN: ::kernel::sys::raw::c_uint = 1;
pub const PCIM_SRIOV_VF_MSE: ::kernel::sys::raw::c_uint = 8;
pub const PCIM_SRIOV_ARI_EN: ::kernel::sys::raw::c_uint = 16;
pub const PCIR_SRIOV_TOTAL_VFS: ::kernel::sys::raw::c_uint = 14;
pub const PCIR_SRIOV_NUM_VFS: ::kernel::sys::raw::c_uint = 16;
pub const PCIR_SRIOV_VF_OFF: ::kernel::sys::raw::c_uint = 20;
pub const PCIR_SRIOV_VF_STRIDE: ::kernel::sys::raw::c_uint = 22;
pub const PCIR_SRIOV_VF_DID: ::kernel::sys::raw::c_uint = 26;
pub const PCIR_SRIOV_PAGE_CAP: ::kernel::sys::raw::c_uint = 28;
pub const PCIR_SRIOV_PAGE_SIZE: ::kernel::sys::raw::c_uint = 32;
pub const PCI_SRIOV_BASE_PAGE_SHIFT: ::kernel::sys::raw::c_uint = 12;
pub const PCIR_SRIOV_BARS: ::kernel::sys::raw::c_uint = 36;
pub const PCI_OSC_STATUS: ::kernel::sys::raw::c_uint = 0;
pub const PCI_OSC_SUPPORT: ::kernel::sys::raw::c_uint = 1;
pub const PCIM_OSC_SUPPORT_EXT_PCI_CONF: ::kernel::sys::raw::c_uint = 1;
pub const PCIM_OSC_SUPPORT_ASPM: ::kernel::sys::raw::c_uint = 2;
pub const PCIM_OSC_SUPPORT_CPMC: ::kernel::sys::raw::c_uint = 4;
pub const PCIM_OSC_SUPPORT_SEG_GROUP: ::kernel::sys::raw::c_uint = 8;
pub const PCIM_OSC_SUPPORT_MSI: ::kernel::sys::raw::c_uint = 16;
pub const PCI_OSC_CTL: ::kernel::sys::raw::c_uint = 2;
pub const PCIM_OSC_CTL_PCIE_HP: ::kernel::sys::raw::c_uint = 1;
pub const PCIM_OSC_CTL_SHPC_HP: ::kernel::sys::raw::c_uint = 2;
pub const PCIM_OSC_CTL_PCIE_PME: ::kernel::sys::raw::c_uint = 4;
pub const PCIM_OSC_CTL_PCIE_AER: ::kernel::sys::raw::c_uint = 8;
pub const PCIM_OSC_CTL_PCIE_CAP_STRUCT: ::kernel::sys::raw::c_uint = 16;
pub type __int8_t = ::kernel::sys::raw::c_schar;
pub type __uint8_t = ::kernel::sys::raw::c_uchar;
pub type __int16_t = ::kernel::sys::raw::c_short;
pub type __uint16_t = ::kernel::sys::raw::c_ushort;
pub type __int32_t = ::kernel::sys::raw::c_int;
pub type __uint32_t = ::kernel::sys::raw::c_uint;
pub type __int64_t = ::kernel::sys::raw::c_long;
pub type __uint64_t = ::kernel::sys::raw::c_ulong;
pub type __clock_t = __int32_t;
pub type __critical_t = __int64_t;
pub type __double_t = f64;
pub type __float_t = f32;
pub type __intfptr_t = __int64_t;
pub type __intptr_t = __int64_t;
pub type __intmax_t = __int64_t;
pub type __int_fast8_t = __int32_t;
pub type __int_fast16_t = __int32_t;
pub type __int_fast32_t = __int32_t;
pub type __int_fast64_t = __int64_t;
pub type __int_least8_t = __int8_t;
pub type __int_least16_t = __int16_t;
pub type __int_least32_t = __int32_t;
pub type __int_least64_t = __int64_t;
pub type __ptrdiff_t = __int64_t;
pub type __register_t = __int64_t;
pub type __segsz_t = __int64_t;
pub type __size_t = __uint64_t;
pub type __ssize_t = __int64_t;
pub type __time_t = __int64_t;
pub type __uintfptr_t = __uint64_t;
pub type __uintptr_t = __uint64_t;
pub type __uintmax_t = __uint64_t;
pub type __uint_fast8_t = __uint32_t;
pub type __uint_fast16_t = __uint32_t;
pub type __uint_fast32_t = __uint32_t;
pub type __uint_fast64_t = __uint64_t;
pub type __uint_least8_t = __uint8_t;
pub type __uint_least16_t = __uint16_t;
pub type __uint_least32_t = __uint32_t;
pub type __uint_least64_t = __uint64_t;
pub type __u_register_t = __uint64_t;
pub type __vm_offset_t = __uint64_t;
pub type __vm_paddr_t = __uint64_t;
pub type __vm_size_t = __uint64_t;
pub type ___wchar_t = ::kernel::sys::raw::c_int;
pub type __blksize_t = __int32_t;
pub type __blkcnt_t = __int64_t;
pub type __clockid_t = __int32_t;
pub type __fflags_t = __uint32_t;
pub type __fsblkcnt_t = __uint64_t;
pub type __fsfilcnt_t = __uint64_t;
pub type __gid_t = __uint32_t;
pub type __id_t = __int64_t;
pub type __ino_t = __uint64_t;
pub type __key_t = ::kernel::sys::raw::c_long;
pub type __lwpid_t = __int32_t;
pub type __mode_t = __uint16_t;
pub type __accmode_t = ::kernel::sys::raw::c_int;
pub type __nl_item = ::kernel::sys::raw::c_int;
pub type __nlink_t = __uint64_t;
pub type __off_t = __int64_t;
pub type __off64_t = __int64_t;
pub type __pid_t = __int32_t;
pub type __rlim_t = __int64_t;
pub type __sa_family_t = __uint8_t;
pub type __socklen_t = __uint32_t;
pub type __suseconds_t = ::kernel::sys::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __timer {
    _unused: [u8; 0],
}
pub type __timer_t = *mut __timer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __mq {
    _unused: [u8; 0],
}
pub type __mqd_t = *mut __mq;
pub type __uid_t = __uint32_t;
pub type __useconds_t = ::kernel::sys::raw::c_uint;
pub type __cpuwhich_t = ::kernel::sys::raw::c_int;
pub type __cpulevel_t = ::kernel::sys::raw::c_int;
pub type __cpusetid_t = ::kernel::sys::raw::c_int;
pub type __ct_rune_t = ::kernel::sys::raw::c_int;
pub type __rune_t = __ct_rune_t;
pub type __wint_t = __ct_rune_t;
pub type __char16_t = __uint_least16_t;
pub type __char32_t = __uint_least32_t;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct __max_align_t {
    pub __max_align1: ::kernel::sys::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __max_align2: f64,
}
#[test]
fn bindgen_test_layout___max_align_t() {
    assert_eq!(::core::mem::size_of::<__max_align_t>() , 32usize , concat ! (
               "Size of: " , stringify ! ( __max_align_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __max_align_t ) ) . __max_align1 as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __max_align_t ) , "::"
                , stringify ! ( __max_align1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __max_align_t ) ) . __max_align2 as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __max_align_t ) , "::"
                , stringify ! ( __max_align2 ) ));
}
impl Clone for __max_align_t {
    fn clone(&self) -> Self { *self }
}
pub type __dev_t = __uint64_t;
pub type __fixpt_t = __uint32_t;
#[repr(C)]
#[derive(Copy)]
pub union __mbstate_t {
    pub __mbstate8: [::kernel::sys::raw::c_char; 128usize],
    pub _mbstateL: __int64_t,
    _bindgen_union_align: [u64; 16usize],
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(::core::mem::size_of::<__mbstate_t>() , 128usize , concat ! (
               "Size of: " , stringify ! ( __mbstate_t ) ));
    assert_eq! (::core::mem::align_of::<__mbstate_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __mbstate_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . __mbstate8 as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( __mbstate8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . _mbstateL as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( _mbstateL ) ));
}
impl Clone for __mbstate_t {
    fn clone(&self) -> Self { *self }
}
impl Default for __mbstate_t {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for __mbstate_t {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "__mbstate_t {{ union }}")
    }
}
pub type __rman_res_t = __uintmax_t;
pub type __va_list = __builtin_va_list;
pub type __gnuc_va_list = __va_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_cond {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_cond_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutex {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutex_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_once {
    pub state: ::kernel::sys::raw::c_int,
    pub mutex: pthread_mutex_t,
}
#[test]
fn bindgen_test_layout_pthread_once() {
    assert_eq!(::core::mem::size_of::<pthread_once>() , 16usize , concat ! (
               "Size of: " , stringify ! ( pthread_once ) ));
    assert_eq! (::core::mem::align_of::<pthread_once>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_once ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_once ) ) . state as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_once ) , "::" ,
                stringify ! ( state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_once ) ) . mutex as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_once ) , "::" ,
                stringify ! ( mutex ) ));
}
impl Clone for pthread_once {
    fn clone(&self) -> Self { *self }
}
impl Default for pthread_once {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_rwlock {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_rwlockattr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_barrier {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_barrier_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_spinlock {
    _unused: [u8; 0],
}
pub type pthread_t = *mut pthread;
pub type pthread_attr_t = *mut pthread_attr;
pub type pthread_mutex_t = *mut pthread_mutex;
pub type pthread_mutexattr_t = *mut pthread_mutex_attr;
pub type pthread_cond_t = *mut pthread_cond;
pub type pthread_condattr_t = *mut pthread_cond_attr;
pub type pthread_key_t = ::kernel::sys::raw::c_int;
pub type pthread_once_t = pthread_once;
pub type pthread_rwlock_t = *mut pthread_rwlock;
pub type pthread_rwlockattr_t = *mut pthread_rwlockattr;
pub type pthread_barrier_t = *mut pthread_barrier;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_barrierattr {
    _unused: [u8; 0],
}
pub type pthread_barrierattr_t = *mut pthread_barrierattr;
pub type pthread_spinlock_t = *mut pthread_spinlock;
pub type pthread_addr_t = *mut ::kernel::sys::raw::c_void;
pub type pthread_startroutine_t =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void)
                               -> *mut ::kernel::sys::raw::c_void>;
pub type u_char = ::kernel::sys::raw::c_uchar;
pub type u_short = ::kernel::sys::raw::c_ushort;
pub type u_int = ::kernel::sys::raw::c_uint;
pub type u_long = ::kernel::sys::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type u_quad_t = __uint64_t;
pub type quad_t = __int64_t;
pub type qaddr_t = *mut quad_t;
pub type caddr_t = *mut ::kernel::sys::raw::c_char;
pub type c_caddr_t = *const ::kernel::sys::raw::c_char;
pub type blksize_t = __blksize_t;
pub type cpuwhich_t = __cpuwhich_t;
pub type cpulevel_t = __cpulevel_t;
pub type cpusetid_t = __cpusetid_t;
pub type blkcnt_t = __blkcnt_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type critical_t = __critical_t;
pub type daddr_t = __int64_t;
pub type dev_t = __dev_t;
pub type fflags_t = __fflags_t;
pub type fixpt_t = __fixpt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type gid_t = __gid_t;
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type id_t = __id_t;
pub type ino_t = __ino_t;
pub type key_t = __key_t;
pub type lwpid_t = __lwpid_t;
pub type mode_t = __mode_t;
pub type accmode_t = __accmode_t;
pub type nlink_t = __nlink_t;
pub type off_t = __off_t;
pub type off64_t = __off64_t;
pub type pid_t = __pid_t;
pub type register_t = __register_t;
pub type rlim_t = __rlim_t;
pub type sbintime_t = __int64_t;
pub type segsz_t = __segsz_t;
pub type suseconds_t = __suseconds_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type mqd_t = __mqd_t;
pub type u_register_t = __u_register_t;
pub type uid_t = __uid_t;
pub type useconds_t = __useconds_t;
pub type cap_ioctl_t = ::kernel::sys::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cap_rights {
    _unused: [u8; 0],
}
pub type cap_rights_t = cap_rights;
pub type vm_offset_t = __vm_offset_t;
pub type vm_ooffset_t = __int64_t;
pub type vm_paddr_t = __vm_paddr_t;
pub type vm_pindex_t = __uint64_t;
pub type vm_size_t = __vm_size_t;
pub type rman_res_t = __rman_res_t;
pub type boolean_t = ::kernel::sys::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct device {
    _unused: [u8; 0],
}
pub type device_t = *mut device;
pub type intfptr_t = __intfptr_t;
pub type intrmask_t = __uint32_t;
pub type uintfptr_t = __uintfptr_t;
pub type uoff_t = __uint64_t;
pub type vm_memattr_t = ::kernel::sys::raw::c_char;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_page {
    _unused: [u8; 0],
}
pub type vm_page_t = *mut vm_page;
pub type bool_ = bool;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct __sigset {
    pub __bits: [__uint32_t; 4usize],
}
#[test]
fn bindgen_test_layout___sigset() {
    assert_eq!(::core::mem::size_of::<__sigset>() , 16usize , concat ! (
               "Size of: " , stringify ! ( __sigset ) ));
    assert_eq! (::core::mem::align_of::<__sigset>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( __sigset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sigset ) ) . __bits as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sigset ) , "::" ,
                stringify ! ( __bits ) ));
}
impl Clone for __sigset {
    fn clone(&self) -> Self { *self }
}
pub type __sigset_t = __sigset;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct timeval {
    pub tv_sec: time_t,
    pub tv_usec: suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(::core::mem::size_of::<timeval>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timeval ) ));
    assert_eq! (::core::mem::align_of::<timeval>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timeval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_usec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_usec ) ));
}
impl Clone for timeval {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: ::kernel::sys::raw::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(::core::mem::size_of::<timespec>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timespec ) ));
    assert_eq! (::core::mem::align_of::<timespec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timespec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_nsec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_nsec ) ));
}
impl Clone for timespec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(::core::mem::size_of::<itimerspec>() , 32usize , concat ! (
               "Size of: " , stringify ! ( itimerspec ) ));
    assert_eq! (::core::mem::align_of::<itimerspec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( itimerspec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerspec ) ) . it_interval as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerspec ) , "::" ,
                stringify ! ( it_interval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerspec ) ) . it_value as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerspec ) , "::" ,
                stringify ! ( it_value ) ));
}
impl Clone for itimerspec {
    fn clone(&self) -> Self { *self }
}
pub type __fd_mask = ::kernel::sys::raw::c_ulong;
pub type fd_mask = __fd_mask;
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(::core::mem::size_of::<fd_set>() , 128usize , concat ! (
               "Size of: " , stringify ! ( fd_set ) ));
    assert_eq! (::core::mem::align_of::<fd_set>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( fd_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fd_set ) ) . __fds_bits as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( fd_set ) , "::" ,
                stringify ! ( __fds_bits ) ));
}
impl Clone for fd_set {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lock_object {
    pub lo_name: *const ::kernel::sys::raw::c_char,
    pub lo_flags: u_int,
    pub lo_data: u_int,
    pub lo_witness: *mut witness,
}
#[test]
fn bindgen_test_layout_lock_object() {
    assert_eq!(::core::mem::size_of::<lock_object>() , 24usize , concat ! (
               "Size of: " , stringify ! ( lock_object ) ));
    assert_eq! (::core::mem::align_of::<lock_object>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lock_object ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_object ) ) . lo_name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_object ) , "::" ,
                stringify ! ( lo_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_object ) ) . lo_flags as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_object ) , "::" ,
                stringify ! ( lo_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_object ) ) . lo_data as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_object ) , "::" ,
                stringify ! ( lo_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_object ) ) . lo_witness as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_object ) , "::" ,
                stringify ! ( lo_witness ) ));
}
impl Clone for lock_object {
    fn clone(&self) -> Self { *self }
}
impl Default for lock_object {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lock_list_entry {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct thread {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lock_class {
    pub lc_name: *const ::kernel::sys::raw::c_char,
    pub lc_flags: u_int,
    pub lc_assert: ::core::option::Option<unsafe extern "C" fn(lock:
                                                                   *const lock_object,
                                                               what:
                                                                   ::kernel::sys::raw::c_int)>,
    pub lc_ddb_show: ::core::option::Option<unsafe extern "C" fn(lock:
                                                                     *const lock_object)>,
    pub lc_lock: ::core::option::Option<unsafe extern "C" fn(lock:
                                                                 *mut lock_object,
                                                             how: usize)>,
    pub lc_owner: ::core::option::Option<unsafe extern "C" fn(lock:
                                                                  *const lock_object,
                                                              owner:
                                                                  *mut *mut thread)
                                             -> ::kernel::sys::raw::c_int>,
    pub lc_unlock: ::core::option::Option<unsafe extern "C" fn(lock:
                                                                   *mut lock_object)
                                              -> usize>,
}
#[test]
fn bindgen_test_layout_lock_class() {
    assert_eq!(::core::mem::size_of::<lock_class>() , 56usize , concat ! (
               "Size of: " , stringify ! ( lock_class ) ));
    assert_eq! (::core::mem::align_of::<lock_class>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lock_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_class ) ) . lc_name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_class ) , "::" ,
                stringify ! ( lc_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_class ) ) . lc_flags as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_class ) , "::" ,
                stringify ! ( lc_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_class ) ) . lc_assert as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_class ) , "::" ,
                stringify ! ( lc_assert ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_class ) ) . lc_ddb_show as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_class ) , "::" ,
                stringify ! ( lc_ddb_show ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_class ) ) . lc_lock as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_class ) , "::" ,
                stringify ! ( lc_lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_class ) ) . lc_owner as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_class ) , "::" ,
                stringify ! ( lc_owner ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_class ) ) . lc_unlock as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_class ) , "::" ,
                stringify ! ( lc_unlock ) ));
}
impl Clone for lock_class {
    fn clone(&self) -> Self { *self }
}
impl Default for lock_class {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    #[link_name = "lock_class_mtx_sleep"]
    pub static mut lock_class_mtx_sleep: lock_class;
}
extern "C" {
    #[link_name = "lock_class_mtx_spin"]
    pub static mut lock_class_mtx_spin: lock_class;
}
extern "C" {
    #[link_name = "lock_class_sx"]
    pub static mut lock_class_sx: lock_class;
}
extern "C" {
    #[link_name = "lock_class_rw"]
    pub static mut lock_class_rw: lock_class;
}
extern "C" {
    #[link_name = "lock_class_rm"]
    pub static mut lock_class_rm: lock_class;
}
extern "C" {
    #[link_name = "lock_class_rm_sleepable"]
    pub static mut lock_class_rm_sleepable: lock_class;
}
extern "C" {
    #[link_name = "lock_class_lockmgr"]
    pub static mut lock_class_lockmgr: lock_class;
}
extern "C" {
    #[link_name = "lock_classes"]
    pub static mut lock_classes: [*mut lock_class; 0usize];
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct lock_delay_config {
    pub base: u_int,
    pub max: u_int,
}
#[test]
fn bindgen_test_layout_lock_delay_config() {
    assert_eq!(::core::mem::size_of::<lock_delay_config>() , 8usize , concat !
               ( "Size of: " , stringify ! ( lock_delay_config ) ));
    assert_eq! (::core::mem::align_of::<lock_delay_config>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( lock_delay_config ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_delay_config ) ) . base as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_delay_config ) ,
                "::" , stringify ! ( base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_delay_config ) ) . max as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_delay_config ) ,
                "::" , stringify ! ( max ) ));
}
impl Clone for lock_delay_config {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lock_delay_arg {
    pub config: *mut lock_delay_config,
    pub delay: u_int,
    pub spin_cnt: u_int,
}
#[test]
fn bindgen_test_layout_lock_delay_arg() {
    assert_eq!(::core::mem::size_of::<lock_delay_arg>() , 16usize , concat ! (
               "Size of: " , stringify ! ( lock_delay_arg ) ));
    assert_eq! (::core::mem::align_of::<lock_delay_arg>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( lock_delay_arg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_delay_arg ) ) . config as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_delay_arg ) , "::"
                , stringify ! ( config ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_delay_arg ) ) . delay as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_delay_arg ) , "::"
                , stringify ! ( delay ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_delay_arg ) ) . spin_cnt as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_delay_arg ) , "::"
                , stringify ! ( spin_cnt ) ));
}
impl Clone for lock_delay_arg {
    fn clone(&self) -> Self { *self }
}
impl Default for lock_delay_arg {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    pub fn lock_init(arg1: *mut lock_object, arg2: *mut lock_class,
                     arg3: *const ::kernel::sys::raw::c_char,
                     arg4: *const ::kernel::sys::raw::c_char,
                     arg5: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn lock_destroy(arg1: *mut lock_object);
}
extern "C" {
    pub fn lock_delay(arg1: *mut lock_delay_arg);
}
extern "C" {
    pub fn lock_delay_default_init(arg1: *mut lock_delay_config);
}
extern "C" {
    pub fn spinlock_enter();
}
extern "C" {
    pub fn spinlock_exit();
}
extern "C" {
    pub fn witness_init(arg1: *mut lock_object,
                        arg2: *const ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn witness_destroy(arg1: *mut lock_object);
}
extern "C" {
    pub fn witness_defineorder(arg1: *mut lock_object, arg2: *mut lock_object)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn witness_checkorder(arg1: *mut lock_object,
                              arg2: ::kernel::sys::raw::c_int,
                              arg3: *const ::kernel::sys::raw::c_char,
                              arg4: ::kernel::sys::raw::c_int,
                              arg5: *mut lock_object);
}
extern "C" {
    pub fn witness_lock(arg1: *mut lock_object,
                        arg2: ::kernel::sys::raw::c_int,
                        arg3: *const ::kernel::sys::raw::c_char,
                        arg4: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn witness_upgrade(arg1: *mut lock_object,
                           arg2: ::kernel::sys::raw::c_int,
                           arg3: *const ::kernel::sys::raw::c_char,
                           arg4: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn witness_downgrade(arg1: *mut lock_object,
                             arg2: ::kernel::sys::raw::c_int,
                             arg3: *const ::kernel::sys::raw::c_char,
                             arg4: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn witness_unlock(arg1: *mut lock_object,
                          arg2: ::kernel::sys::raw::c_int,
                          arg3: *const ::kernel::sys::raw::c_char,
                          arg4: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn witness_save(arg1: *mut lock_object,
                        arg2: *mut *const ::kernel::sys::raw::c_char,
                        arg3: *mut ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn witness_restore(arg1: *mut lock_object,
                           arg2: *const ::kernel::sys::raw::c_char,
                           arg3: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn witness_list_locks(arg1: *mut *mut lock_list_entry,
                              arg2:
                                  ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                                  *const ::kernel::sys::raw::c_char, ...)
                                                             ->
                                                                 ::kernel::sys::raw::c_int>)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn witness_warn(arg1: ::kernel::sys::raw::c_int,
                        arg2: *mut lock_object,
                        arg3: *const ::kernel::sys::raw::c_char, ...)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn witness_assert(arg1: *const lock_object,
                          arg2: ::kernel::sys::raw::c_int,
                          arg3: *const ::kernel::sys::raw::c_char,
                          arg4: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn witness_display_spinlock(arg1: *mut lock_object, arg2: *mut thread,
                                    arg3:
                                        ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                                        *const ::kernel::sys::raw::c_char, ...)
                                                                   ->
                                                                       ::kernel::sys::raw::c_int>);
}
extern "C" {
    pub fn witness_line(arg1: *mut lock_object) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn witness_norelease(arg1: *mut lock_object);
}
extern "C" {
    pub fn witness_releaseok(arg1: *mut lock_object);
}
extern "C" {
    pub fn witness_file(arg1: *mut lock_object)
     -> *const ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn witness_thread_exit(arg1: *mut thread);
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct timezone {
    pub tz_minuteswest: ::kernel::sys::raw::c_int,
    pub tz_dsttime: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_timezone() {
    assert_eq!(::core::mem::size_of::<timezone>() , 8usize , concat ! (
               "Size of: " , stringify ! ( timezone ) ));
    assert_eq! (::core::mem::align_of::<timezone>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( timezone ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timezone ) ) . tz_minuteswest as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timezone ) , "::" ,
                stringify ! ( tz_minuteswest ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timezone ) ) . tz_dsttime as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( timezone ) , "::" ,
                stringify ! ( tz_dsttime ) ));
}
impl Clone for timezone {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct bintime {
    pub sec: time_t,
    pub frac: u64,
}
#[test]
fn bindgen_test_layout_bintime() {
    assert_eq!(::core::mem::size_of::<bintime>() , 16usize , concat ! (
               "Size of: " , stringify ! ( bintime ) ));
    assert_eq! (::core::mem::align_of::<bintime>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( bintime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bintime ) ) . sec as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( bintime ) , "::" ,
                stringify ! ( sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bintime ) ) . frac as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( bintime ) , "::" ,
                stringify ! ( frac ) ));
}
impl Clone for bintime {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
#[test]
fn bindgen_test_layout_itimerval() {
    assert_eq!(::core::mem::size_of::<itimerval>() , 32usize , concat ! (
               "Size of: " , stringify ! ( itimerval ) ));
    assert_eq! (::core::mem::align_of::<itimerval>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( itimerval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerval ) ) . it_interval as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerval ) , "::" ,
                stringify ! ( it_interval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerval ) ) . it_value as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerval ) , "::" ,
                stringify ! ( it_value ) ));
}
impl Clone for itimerval {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct clockinfo {
    pub hz: ::kernel::sys::raw::c_int,
    pub tick: ::kernel::sys::raw::c_int,
    pub spare: ::kernel::sys::raw::c_int,
    pub stathz: ::kernel::sys::raw::c_int,
    pub profhz: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_clockinfo() {
    assert_eq!(::core::mem::size_of::<clockinfo>() , 20usize , concat ! (
               "Size of: " , stringify ! ( clockinfo ) ));
    assert_eq! (::core::mem::align_of::<clockinfo>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( clockinfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clockinfo ) ) . hz as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( clockinfo ) , "::" ,
                stringify ! ( hz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clockinfo ) ) . tick as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( clockinfo ) , "::" ,
                stringify ! ( tick ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clockinfo ) ) . spare as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( clockinfo ) , "::" ,
                stringify ! ( spare ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clockinfo ) ) . stathz as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( clockinfo ) , "::" ,
                stringify ! ( stathz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clockinfo ) ) . profhz as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( clockinfo ) , "::" ,
                stringify ! ( profhz ) ));
}
impl Clone for clockinfo {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn inittodr(base: time_t);
}
extern "C" {
    pub fn resettodr();
}
extern "C" {
    #[link_name = "time_second"]
    pub static mut time_second: time_t;
}
extern "C" {
    #[link_name = "time_uptime"]
    pub static mut time_uptime: time_t;
}
extern "C" {
    #[link_name = "tc_tick_bt"]
    pub static mut tc_tick_bt: bintime;
}
extern "C" {
    #[link_name = "tc_tick_sbt"]
    pub static mut tc_tick_sbt: sbintime_t;
}
extern "C" {
    #[link_name = "tick_bt"]
    pub static mut tick_bt: bintime;
}
extern "C" {
    #[link_name = "tick_sbt"]
    pub static mut tick_sbt: sbintime_t;
}
extern "C" {
    #[link_name = "tc_precexp"]
    pub static mut tc_precexp: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "tc_timepercentage"]
    pub static mut tc_timepercentage: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "bt_timethreshold"]
    pub static mut bt_timethreshold: bintime;
}
extern "C" {
    #[link_name = "bt_tickthreshold"]
    pub static mut bt_tickthreshold: bintime;
}
extern "C" {
    #[link_name = "sbt_timethreshold"]
    pub static mut sbt_timethreshold: sbintime_t;
}
extern "C" {
    #[link_name = "sbt_tickthreshold"]
    pub static mut sbt_tickthreshold: sbintime_t;
}
extern "C" {
    #[link_name = "rtc_generation"]
    pub static mut rtc_generation: ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn binuptime(bt: *mut bintime);
}
extern "C" {
    pub fn nanouptime(tsp: *mut timespec);
}
extern "C" {
    pub fn microuptime(tvp: *mut timeval);
}
extern "C" {
    pub fn bintime(bt: *mut bintime);
}
extern "C" {
    pub fn nanotime(tsp: *mut timespec);
}
extern "C" {
    pub fn microtime(tvp: *mut timeval);
}
extern "C" {
    pub fn getbinuptime(bt: *mut bintime);
}
extern "C" {
    pub fn getnanouptime(tsp: *mut timespec);
}
extern "C" {
    pub fn getmicrouptime(tvp: *mut timeval);
}
extern "C" {
    pub fn getbintime(bt: *mut bintime);
}
extern "C" {
    pub fn getnanotime(tsp: *mut timespec);
}
extern "C" {
    pub fn getmicrotime(tvp: *mut timeval);
}
extern "C" {
    pub fn getboottime(boottime: *mut timeval);
}
extern "C" {
    pub fn getboottimebin(boottimebin: *mut bintime);
}
extern "C" {
    pub fn itimerdecr(itp: *mut itimerval, usec: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn itimerfix(tv: *mut timeval) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn ppsratecheck(arg1: *mut timeval,
                        arg2: *mut ::kernel::sys::raw::c_int,
                        arg3: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn ratecheck(arg1: *mut timeval, arg2: *const timeval)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn timevaladd(t1: *mut timeval, t2: *const timeval);
}
extern "C" {
    pub fn timevalsub(t1: *mut timeval, t2: *const timeval);
}
extern "C" {
    pub fn tvtohz(tv: *mut timeval) -> ::kernel::sys::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct priority {
    pub pri_class: u_char,
    pub pri_level: u_char,
    pub pri_native: u_char,
    pub pri_user: u_char,
}
#[test]
fn bindgen_test_layout_priority() {
    assert_eq!(::core::mem::size_of::<priority>() , 4usize , concat ! (
               "Size of: " , stringify ! ( priority ) ));
    assert_eq! (::core::mem::align_of::<priority>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( priority ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const priority ) ) . pri_class as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( priority ) , "::" ,
                stringify ! ( pri_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const priority ) ) . pri_level as * const _ as
                usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( priority ) , "::" ,
                stringify ! ( pri_level ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const priority ) ) . pri_native as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( priority ) , "::" ,
                stringify ! ( pri_native ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const priority ) ) . pri_user as * const _ as
                usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( priority ) , "::" ,
                stringify ! ( pri_user ) ));
}
impl Clone for priority {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn htonl(arg1: __uint32_t) -> __uint32_t;
}
extern "C" {
    pub fn htons(arg1: __uint16_t) -> __uint16_t;
}
extern "C" {
    pub fn ntohl(arg1: __uint32_t) -> __uint32_t;
}
extern "C" {
    pub fn ntohs(arg1: __uint16_t) -> __uint16_t;
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct bitset {
    pub __bits: [::kernel::sys::raw::c_long; 1usize],
}
#[test]
fn bindgen_test_layout_bitset() {
    assert_eq!(::core::mem::size_of::<bitset>() , 8usize , concat ! (
               "Size of: " , stringify ! ( bitset ) ));
    assert_eq! (::core::mem::align_of::<bitset>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( bitset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bitset ) ) . __bits as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( bitset ) , "::" ,
                stringify ! ( __bits ) ));
}
impl Clone for bitset {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct _cpuset {
    pub __bits: [::kernel::sys::raw::c_long; 4usize],
}
#[test]
fn bindgen_test_layout__cpuset() {
    assert_eq!(::core::mem::size_of::<_cpuset>() , 32usize , concat ! (
               "Size of: " , stringify ! ( _cpuset ) ));
    assert_eq! (::core::mem::align_of::<_cpuset>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _cpuset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _cpuset ) ) . __bits as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _cpuset ) , "::" ,
                stringify ! ( __bits ) ));
}
impl Clone for _cpuset {
    fn clone(&self) -> Self { *self }
}
pub type cpuset_t = _cpuset;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ktr_entry {
    pub ktr_timestamp: u_int64_t,
    pub ktr_cpu: ::kernel::sys::raw::c_int,
    pub ktr_line: ::kernel::sys::raw::c_int,
    pub ktr_file: *const ::kernel::sys::raw::c_char,
    pub ktr_desc: *const ::kernel::sys::raw::c_char,
    pub ktr_thread: *mut thread,
    pub ktr_parms: [u_long; 6usize],
}
#[test]
fn bindgen_test_layout_ktr_entry() {
    assert_eq!(::core::mem::size_of::<ktr_entry>() , 88usize , concat ! (
               "Size of: " , stringify ! ( ktr_entry ) ));
    assert_eq! (::core::mem::align_of::<ktr_entry>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ktr_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ktr_entry ) ) . ktr_timestamp as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ktr_entry ) , "::" ,
                stringify ! ( ktr_timestamp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ktr_entry ) ) . ktr_cpu as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ktr_entry ) , "::" ,
                stringify ! ( ktr_cpu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ktr_entry ) ) . ktr_line as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( ktr_entry ) , "::" ,
                stringify ! ( ktr_line ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ktr_entry ) ) . ktr_file as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ktr_entry ) , "::" ,
                stringify ! ( ktr_file ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ktr_entry ) ) . ktr_desc as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ktr_entry ) , "::" ,
                stringify ! ( ktr_desc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ktr_entry ) ) . ktr_thread as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( ktr_entry ) , "::" ,
                stringify ! ( ktr_thread ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ktr_entry ) ) . ktr_parms as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( ktr_entry ) , "::" ,
                stringify ! ( ktr_parms ) ));
}
impl Clone for ktr_entry {
    fn clone(&self) -> Self { *self }
}
impl Default for ktr_entry {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    #[link_name = "ktr_cpumask"]
    pub static mut ktr_cpumask: cpuset_t;
}
extern "C" {
    #[link_name = "ktr_mask"]
    pub static mut ktr_mask: u64;
}
extern "C" {
    #[link_name = "ktr_entries"]
    pub static mut ktr_entries: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "ktr_verbose"]
    pub static mut ktr_verbose: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "ktr_idx"]
    pub static mut ktr_idx: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "ktr_buf"]
    pub static mut ktr_buf: *mut ktr_entry;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mtx {
    pub lock_object: lock_object,
    pub mtx_lock: usize,
}
#[test]
fn bindgen_test_layout_mtx() {
    assert_eq!(::core::mem::size_of::<mtx>() , 32usize , concat ! (
               "Size of: " , stringify ! ( mtx ) ));
    assert_eq! (::core::mem::align_of::<mtx>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( mtx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mtx ) ) . lock_object as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mtx ) , "::" ,
                stringify ! ( lock_object ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mtx ) ) . mtx_lock as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( mtx ) , "::" ,
                stringify ! ( mtx_lock ) ));
}
impl Clone for mtx {
    fn clone(&self) -> Self { *self }
}
impl Default for mtx {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct mtx_padalign {
    pub lock_object: lock_object,
    pub mtx_lock: usize,
    pub __bindgen_padding_0: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_mtx_padalign() {
    assert_eq!(::core::mem::size_of::<mtx_padalign>() , 64usize , concat ! (
               "Size of: " , stringify ! ( mtx_padalign ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mtx_padalign ) ) . lock_object as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mtx_padalign ) , "::" ,
                stringify ! ( lock_object ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mtx_padalign ) ) . mtx_lock as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( mtx_padalign ) , "::" ,
                stringify ! ( mtx_lock ) ));
}
impl Clone for mtx_padalign {
    fn clone(&self) -> Self { *self }
}
impl Default for mtx_padalign {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for mtx_padalign {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "mtx_padalign {{ lock_object: {:?}, mtx_lock: {:?} }}" ,
               self . lock_object , self . mtx_lock)
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sx {
    pub lock_object: lock_object,
    pub sx_lock: usize,
}
#[test]
fn bindgen_test_layout_sx() {
    assert_eq!(::core::mem::size_of::<sx>() , 32usize , concat ! (
               "Size of: " , stringify ! ( sx ) ));
    assert_eq! (::core::mem::align_of::<sx>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sx ) ) . lock_object as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sx ) , "::" , stringify
                ! ( lock_object ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sx ) ) . sx_lock as * const _ as usize }
                , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( sx ) , "::" , stringify
                ! ( sx_lock ) ));
}
impl Clone for sx {
    fn clone(&self) -> Self { *self }
}
impl Default for sx {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rmpriolist {
    pub lh_first: *mut rm_priotracker,
}
#[test]
fn bindgen_test_layout_rmpriolist() {
    assert_eq!(::core::mem::size_of::<rmpriolist>() , 8usize , concat ! (
               "Size of: " , stringify ! ( rmpriolist ) ));
    assert_eq! (::core::mem::align_of::<rmpriolist>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rmpriolist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmpriolist ) ) . lh_first as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rmpriolist ) , "::" ,
                stringify ! ( lh_first ) ));
}
impl Clone for rmpriolist {
    fn clone(&self) -> Self { *self }
}
impl Default for rmpriolist {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rm_queue {
    pub rmq_next: *mut rm_queue,
    pub rmq_prev: *mut rm_queue,
}
#[test]
fn bindgen_test_layout_rm_queue() {
    assert_eq!(::core::mem::size_of::<rm_queue>() , 16usize , concat ! (
               "Size of: " , stringify ! ( rm_queue ) ));
    assert_eq! (::core::mem::align_of::<rm_queue>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rm_queue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rm_queue ) ) . rmq_next as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rm_queue ) , "::" ,
                stringify ! ( rmq_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rm_queue ) ) . rmq_prev as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rm_queue ) , "::" ,
                stringify ! ( rmq_prev ) ));
}
impl Clone for rm_queue {
    fn clone(&self) -> Self { *self }
}
impl Default for rm_queue {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct rmlock {
    pub lock_object: lock_object,
    pub rm_writecpus: cpuset_t,
    pub rm_activeReaders: rmlock__bindgen_ty_1,
    pub _rm_lock: rmlock__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rmlock__bindgen_ty_1 {
    pub lh_first: *mut rm_priotracker,
}
#[test]
fn bindgen_test_layout_rmlock__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<rmlock__bindgen_ty_1>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( rmlock__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<rmlock__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rmlock__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmlock__bindgen_ty_1 ) ) . lh_first as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rmlock__bindgen_ty_1 )
                , "::" , stringify ! ( lh_first ) ));
}
impl Clone for rmlock__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for rmlock__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub union rmlock__bindgen_ty_2 {
    pub _rm_wlock_object: lock_object,
    pub _rm_lock_mtx: mtx,
    pub _rm_lock_sx: sx,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_rmlock__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<rmlock__bindgen_ty_2>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( rmlock__bindgen_ty_2 )
               ));
    assert_eq! (::core::mem::align_of::<rmlock__bindgen_ty_2>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rmlock__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmlock__bindgen_ty_2 ) ) .
                _rm_wlock_object as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rmlock__bindgen_ty_2 )
                , "::" , stringify ! ( _rm_wlock_object ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmlock__bindgen_ty_2 ) ) . _rm_lock_mtx
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rmlock__bindgen_ty_2 )
                , "::" , stringify ! ( _rm_lock_mtx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmlock__bindgen_ty_2 ) ) . _rm_lock_sx as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rmlock__bindgen_ty_2 )
                , "::" , stringify ! ( _rm_lock_sx ) ));
}
impl Clone for rmlock__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for rmlock__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for rmlock__bindgen_ty_2 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "rmlock__bindgen_ty_2 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_rmlock() {
    assert_eq!(::core::mem::size_of::<rmlock>() , 96usize , concat ! (
               "Size of: " , stringify ! ( rmlock ) ));
    assert_eq! (::core::mem::align_of::<rmlock>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rmlock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmlock ) ) . lock_object as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rmlock ) , "::" ,
                stringify ! ( lock_object ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmlock ) ) . rm_writecpus as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rmlock ) , "::" ,
                stringify ! ( rm_writecpus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmlock ) ) . rm_activeReaders as * const
                _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( rmlock ) , "::" ,
                stringify ! ( rm_activeReaders ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmlock ) ) . _rm_lock as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( rmlock ) , "::" ,
                stringify ! ( _rm_lock ) ));
}
impl Clone for rmlock {
    fn clone(&self) -> Self { *self }
}
impl Default for rmlock {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for rmlock {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "rmlock {{ lock_object: {:?}, rm_writecpus: {:?}, rm_activeReaders: {:?}, _rm_lock: {:?} }}"
               , self . lock_object , self . rm_writecpus , self .
               rm_activeReaders , self . _rm_lock)
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rm_priotracker {
    pub rmp_cpuQueue: rm_queue,
    pub rmp_rmlock: *mut rmlock,
    pub rmp_thread: *mut thread,
    pub rmp_flags: ::kernel::sys::raw::c_int,
    pub rmp_qentry: rm_priotracker__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rm_priotracker__bindgen_ty_1 {
    pub le_next: *mut rm_priotracker,
    pub le_prev: *mut *mut rm_priotracker,
}
#[test]
fn bindgen_test_layout_rm_priotracker__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<rm_priotracker__bindgen_ty_1>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( rm_priotracker__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<rm_priotracker__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( rm_priotracker__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rm_priotracker__bindgen_ty_1 ) ) .
                le_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rm_priotracker__bindgen_ty_1 ) , "::" , stringify ! ( le_next
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rm_priotracker__bindgen_ty_1 ) ) .
                le_prev as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                rm_priotracker__bindgen_ty_1 ) , "::" , stringify ! ( le_prev
                ) ));
}
impl Clone for rm_priotracker__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for rm_priotracker__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_rm_priotracker() {
    assert_eq!(::core::mem::size_of::<rm_priotracker>() , 56usize , concat ! (
               "Size of: " , stringify ! ( rm_priotracker ) ));
    assert_eq! (::core::mem::align_of::<rm_priotracker>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( rm_priotracker ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rm_priotracker ) ) . rmp_cpuQueue as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rm_priotracker ) , "::"
                , stringify ! ( rmp_cpuQueue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rm_priotracker ) ) . rmp_rmlock as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rm_priotracker ) , "::"
                , stringify ! ( rmp_rmlock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rm_priotracker ) ) . rmp_thread as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rm_priotracker ) , "::"
                , stringify ! ( rmp_thread ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rm_priotracker ) ) . rmp_flags as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rm_priotracker ) , "::"
                , stringify ! ( rmp_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rm_priotracker ) ) . rmp_qentry as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rm_priotracker ) , "::"
                , stringify ! ( rmp_qentry ) ));
}
impl Clone for rm_priotracker {
    fn clone(&self) -> Self { *self }
}
impl Default for rm_priotracker {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct rusage {
    pub ru_utime: timeval,
    pub ru_stime: timeval,
    pub ru_maxrss: ::kernel::sys::raw::c_long,
    pub ru_ixrss: ::kernel::sys::raw::c_long,
    pub ru_idrss: ::kernel::sys::raw::c_long,
    pub ru_isrss: ::kernel::sys::raw::c_long,
    pub ru_minflt: ::kernel::sys::raw::c_long,
    pub ru_majflt: ::kernel::sys::raw::c_long,
    pub ru_nswap: ::kernel::sys::raw::c_long,
    pub ru_inblock: ::kernel::sys::raw::c_long,
    pub ru_oublock: ::kernel::sys::raw::c_long,
    pub ru_msgsnd: ::kernel::sys::raw::c_long,
    pub ru_msgrcv: ::kernel::sys::raw::c_long,
    pub ru_nsignals: ::kernel::sys::raw::c_long,
    pub ru_nvcsw: ::kernel::sys::raw::c_long,
    pub ru_nivcsw: ::kernel::sys::raw::c_long,
}
#[test]
fn bindgen_test_layout_rusage() {
    assert_eq!(::core::mem::size_of::<rusage>() , 144usize , concat ! (
               "Size of: " , stringify ! ( rusage ) ));
    assert_eq! (::core::mem::align_of::<rusage>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rusage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_utime as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_utime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_stime as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_stime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_maxrss as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_maxrss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_ixrss as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_ixrss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_idrss as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_idrss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_isrss as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_isrss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_minflt as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_minflt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_majflt as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_majflt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_nswap as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_nswap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_inblock as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_inblock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_oublock as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_oublock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_msgsnd as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_msgsnd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_msgrcv as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_msgrcv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_nsignals as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_nsignals ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_nvcsw as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_nvcsw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_nivcsw as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_nivcsw ) ));
}
impl Clone for rusage {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct __wrusage {
    pub wru_self: rusage,
    pub wru_children: rusage,
}
#[test]
fn bindgen_test_layout___wrusage() {
    assert_eq!(::core::mem::size_of::<__wrusage>() , 288usize , concat ! (
               "Size of: " , stringify ! ( __wrusage ) ));
    assert_eq! (::core::mem::align_of::<__wrusage>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __wrusage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __wrusage ) ) . wru_self as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __wrusage ) , "::" ,
                stringify ! ( wru_self ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __wrusage ) ) . wru_children as * const _
                as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( __wrusage ) , "::" ,
                stringify ! ( wru_children ) ));
}
impl Clone for __wrusage {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct rlimit {
    pub rlim_cur: rlim_t,
    pub rlim_max: rlim_t,
}
#[test]
fn bindgen_test_layout_rlimit() {
    assert_eq!(::core::mem::size_of::<rlimit>() , 16usize , concat ! (
               "Size of: " , stringify ! ( rlimit ) ));
    assert_eq! (::core::mem::align_of::<rlimit>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rlimit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rlimit ) ) . rlim_cur as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rlimit ) , "::" ,
                stringify ! ( rlim_cur ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rlimit ) ) . rlim_max as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rlimit ) , "::" ,
                stringify ! ( rlim_max ) ));
}
impl Clone for rlimit {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct orlimit {
    pub rlim_cur: __int32_t,
    pub rlim_max: __int32_t,
}
#[test]
fn bindgen_test_layout_orlimit() {
    assert_eq!(::core::mem::size_of::<orlimit>() , 8usize , concat ! (
               "Size of: " , stringify ! ( orlimit ) ));
    assert_eq! (::core::mem::align_of::<orlimit>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( orlimit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const orlimit ) ) . rlim_cur as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( orlimit ) , "::" ,
                stringify ! ( rlim_cur ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const orlimit ) ) . rlim_max as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( orlimit ) , "::" ,
                stringify ! ( rlim_max ) ));
}
impl Clone for orlimit {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct loadavg {
    pub ldavg: [__fixpt_t; 3usize],
    pub fscale: ::kernel::sys::raw::c_long,
}
#[test]
fn bindgen_test_layout_loadavg() {
    assert_eq!(::core::mem::size_of::<loadavg>() , 24usize , concat ! (
               "Size of: " , stringify ! ( loadavg ) ));
    assert_eq! (::core::mem::align_of::<loadavg>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( loadavg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const loadavg ) ) . ldavg as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( loadavg ) , "::" ,
                stringify ! ( ldavg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const loadavg ) ) . fscale as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( loadavg ) , "::" ,
                stringify ! ( fscale ) ));
}
impl Clone for loadavg {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "averunnable"]
    pub static mut averunnable: loadavg;
}
extern "C" {
    pub fn read_cpu_time(cp_time: *mut ::kernel::sys::raw::c_long);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcb {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "__start_set_pcpu"]
    pub static mut __start_set_pcpu: *mut usize;
}
extern "C" {
    #[link_name = "__stop_set_pcpu"]
    pub static mut __stop_set_pcpu: *mut usize;
}
extern "C" {
    #[link_name = "dpcpu_off"]
    pub static mut dpcpu_off: [usize; 0usize];
}
#[repr(C)]
#[derive(Copy)]
pub struct pcpu {
    pub pc_curthread: *mut thread,
    pub pc_idlethread: *mut thread,
    pub pc_fpcurthread: *mut thread,
    pub pc_deadthread: *mut thread,
    pub pc_curpcb: *mut pcb,
    pub pc_switchtime: u64,
    pub pc_switchticks: ::kernel::sys::raw::c_int,
    pub pc_cpuid: u_int,
    pub pc_allcpu: pcpu__bindgen_ty_1,
    pub pc_spinlocks: *mut lock_list_entry,
    pub pc_cp_time: [::kernel::sys::raw::c_long; 5usize],
    pub pc_device: *mut device,
    pub pc_netisr: *mut ::kernel::sys::raw::c_void,
    pub pc_unused1: ::kernel::sys::raw::c_int,
    pub pc_domain: ::kernel::sys::raw::c_int,
    pub pc_rm_queue: rm_queue,
    pub pc_dynamic: usize,
    pub pc_early_dummy_counter: u64,
    pub __bindgen_padding_0: [u8; 88usize],
    pub pc_monitorbuf: [::kernel::sys::raw::c_char; 128usize],
    pub pc_prvspace: *mut pcpu,
    pub pc_curpmap: *mut pmap,
    pub pc_tssp: *mut amd64tss,
    pub pc_commontssp: *mut amd64tss,
    pub pc_kcr3: u64,
    pub pc_ucr3: u64,
    pub pc_saved_ucr3: u64,
    pub pc_rsp0: register_t,
    pub pc_scratch_rsp: register_t,
    pub pc_scratch_rax: register_t,
    pub pc_apic_id: u_int,
    pub pc_acpi_id: u_int,
    pub pc_fs32p: *mut user_segment_descriptor,
    pub pc_gs32p: *mut user_segment_descriptor,
    pub pc_ldt: *mut system_segment_descriptor,
    pub pc_tss: *mut system_segment_descriptor,
    pub pc_pm_save_cnt: u64,
    pub pc_cmci_mask: u_int,
    pub pc_dbreg: [u64; 16usize],
    pub pc_pti_stack: [u64; 16usize],
    pub pc_pti_rsp0: register_t,
    pub pc_dbreg_cmd: ::kernel::sys::raw::c_int,
    pub pc_vcpu_id: u_int,
    pub pc_pcid_next: u32,
    pub pc_pcid_gen: u32,
    pub pc_smp_tlb_done: u32,
    pub pc_ibpb_set: u32,
    pub __pad: [::kernel::sys::raw::c_char; 216usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pcpu__bindgen_ty_1 {
    pub stqe_next: *mut pcpu,
}
#[test]
fn bindgen_test_layout_pcpu__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<pcpu__bindgen_ty_1>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( pcpu__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<pcpu__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( pcpu__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu__bindgen_ty_1 ) ) . stqe_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu__bindgen_ty_1 ) ,
                "::" , stringify ! ( stqe_next ) ));
}
impl Clone for pcpu__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for pcpu__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_pcpu() {
    assert_eq!(::core::mem::size_of::<pcpu>() , 1024usize , concat ! (
               "Size of: " , stringify ! ( pcpu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_curthread as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_curthread ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_idlethread as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_idlethread ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_fpcurthread as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_fpcurthread ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_deadthread as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_deadthread ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_curpcb as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_curpcb ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_switchtime as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_switchtime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_switchticks as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_switchticks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_cpuid as * const _ as usize
                } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_cpuid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_allcpu as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_allcpu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_spinlocks as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_spinlocks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_cp_time as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_cp_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_device as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_device ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_netisr as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_netisr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_unused1 as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_unused1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_domain as * const _ as
                usize } , 132usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_domain ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_rm_queue as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_rm_queue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_dynamic as * const _ as
                usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_dynamic ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_early_dummy_counter as *
                const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_early_dummy_counter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_monitorbuf as * const _ as
                usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_monitorbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_prvspace as * const _ as
                usize } , 384usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_prvspace ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_curpmap as * const _ as
                usize } , 392usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_curpmap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_tssp as * const _ as usize
                } , 400usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_tssp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_commontssp as * const _ as
                usize } , 408usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_commontssp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_kcr3 as * const _ as usize
                } , 416usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_kcr3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_ucr3 as * const _ as usize
                } , 424usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_ucr3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_saved_ucr3 as * const _ as
                usize } , 432usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_saved_ucr3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_rsp0 as * const _ as usize
                } , 440usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_rsp0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_scratch_rsp as * const _ as
                usize } , 448usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_scratch_rsp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_scratch_rax as * const _ as
                usize } , 456usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_scratch_rax ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_apic_id as * const _ as
                usize } , 464usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_apic_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_acpi_id as * const _ as
                usize } , 468usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_acpi_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_fs32p as * const _ as usize
                } , 472usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_fs32p ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_gs32p as * const _ as usize
                } , 480usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_gs32p ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_ldt as * const _ as usize }
                , 488usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_ldt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_tss as * const _ as usize }
                , 496usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_tss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_pm_save_cnt as * const _ as
                usize } , 504usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_pm_save_cnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_cmci_mask as * const _ as
                usize } , 512usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_cmci_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_dbreg as * const _ as usize
                } , 520usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_dbreg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_pti_stack as * const _ as
                usize } , 648usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_pti_stack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_pti_rsp0 as * const _ as
                usize } , 776usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_pti_rsp0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_dbreg_cmd as * const _ as
                usize } , 784usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_dbreg_cmd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_vcpu_id as * const _ as
                usize } , 788usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_vcpu_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_pcid_next as * const _ as
                usize } , 792usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_pcid_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_pcid_gen as * const _ as
                usize } , 796usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_pcid_gen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_smp_tlb_done as * const _
                as usize } , 800usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_smp_tlb_done ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_ibpb_set as * const _ as
                usize } , 804usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_ibpb_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . __pad as * const _ as usize }
                , 808usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( __pad ) ));
}
impl Clone for pcpu {
    fn clone(&self) -> Self { *self }
}
impl Default for pcpu {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for pcpu {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "pcpu {{ pc_curthread: {:?}, pc_idlethread: {:?}, pc_fpcurthread: {:?}, pc_deadthread: {:?}, pc_curpcb: {:?}, pc_switchtime: {:?}, pc_switchticks: {:?}, pc_cpuid: {:?}, pc_allcpu: {:?}, pc_spinlocks: {:?}, pc_cp_time: {:?}, pc_device: {:?}, pc_netisr: {:?}, pc_unused1: {:?}, pc_domain: {:?}, pc_rm_queue: {:?}, pc_dynamic: {:?}, pc_early_dummy_counter: {:?}, pc_monitorbuf: [{}], pc_prvspace: {:?}, pc_curpmap: {:?}, pc_tssp: {:?}, pc_commontssp: {:?}, pc_kcr3: {:?}, pc_ucr3: {:?}, pc_saved_ucr3: {:?}, pc_rsp0: {:?}, pc_scratch_rsp: {:?}, pc_scratch_rax: {:?}, pc_apic_id: {:?}, pc_acpi_id: {:?}, pc_fs32p: {:?}, pc_gs32p: {:?}, pc_ldt: {:?}, pc_tss: {:?}, pc_pm_save_cnt: {:?}, pc_cmci_mask: {:?}, pc_dbreg: {:?}, pc_pti_stack: {:?}, pc_pti_rsp0: {:?}, pc_dbreg_cmd: {:?}, pc_vcpu_id: {:?}, pc_pcid_next: {:?}, pc_pcid_gen: {:?}, pc_smp_tlb_done: {:?}, pc_ibpb_set: {:?}, __pad: [{}] }}"
               , self . pc_curthread , self . pc_idlethread , self .
               pc_fpcurthread , self . pc_deadthread , self . pc_curpcb , self
               . pc_switchtime , self . pc_switchticks , self . pc_cpuid ,
               self . pc_allcpu , self . pc_spinlocks , self . pc_cp_time ,
               self . pc_device , self . pc_netisr , self . pc_unused1 , self
               . pc_domain , self . pc_rm_queue , self . pc_dynamic , self .
               pc_early_dummy_counter , self . pc_monitorbuf . iter (  ) .
               enumerate (  ) . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ) , self . pc_prvspace , self . pc_curpmap , self .
               pc_tssp , self . pc_commontssp , self . pc_kcr3 , self .
               pc_ucr3 , self . pc_saved_ucr3 , self . pc_rsp0 , self .
               pc_scratch_rsp , self . pc_scratch_rax , self . pc_apic_id ,
               self . pc_acpi_id , self . pc_fs32p , self . pc_gs32p , self .
               pc_ldt , self . pc_tss , self . pc_pm_save_cnt , self .
               pc_cmci_mask , self . pc_dbreg , self . pc_pti_stack , self .
               pc_pti_rsp0 , self . pc_dbreg_cmd , self . pc_vcpu_id , self .
               pc_pcid_next , self . pc_pcid_gen , self . pc_smp_tlb_done ,
               self . pc_ibpb_set , self . __pad . iter (  ) . enumerate (  )
               . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ))
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cpuhead {
    pub stqh_first: *mut pcpu,
    pub stqh_last: *mut *mut pcpu,
}
#[test]
fn bindgen_test_layout_cpuhead() {
    assert_eq!(::core::mem::size_of::<cpuhead>() , 16usize , concat ! (
               "Size of: " , stringify ! ( cpuhead ) ));
    assert_eq! (::core::mem::align_of::<cpuhead>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( cpuhead ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuhead ) ) . stqh_first as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuhead ) , "::" ,
                stringify ! ( stqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuhead ) ) . stqh_last as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuhead ) , "::" ,
                stringify ! ( stqh_last ) ));
}
impl Clone for cpuhead {
    fn clone(&self) -> Self { *self }
}
impl Default for cpuhead {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    #[link_name = "cpuhead"]
    pub static mut cpuhead: cpuhead;
}
extern "C" {
    #[link_name = "cpuid_to_pcpu"]
    pub static mut cpuid_to_pcpu: [*mut pcpu; 0usize];
}
extern "C" {
    pub fn cpu_pcpu_init(pcpu: *mut pcpu, cpuid: ::kernel::sys::raw::c_int,
                         size: usize);
}
extern "C" {
    pub fn db_show_mdpcpu(pcpu: *mut pcpu);
}
extern "C" {
    pub fn dpcpu_alloc(size: ::kernel::sys::raw::c_int)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn dpcpu_copy(s: *mut ::kernel::sys::raw::c_void,
                      size: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn dpcpu_free(s: *mut ::kernel::sys::raw::c_void,
                      size: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn dpcpu_init(dpcpu: *mut ::kernel::sys::raw::c_void,
                      cpuid: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn pcpu_destroy(pcpu: *mut pcpu);
}
extern "C" {
    pub fn pcpu_find(cpuid: u_int) -> *mut pcpu;
}
extern "C" {
    pub fn pcpu_init(pcpu: *mut pcpu, cpuid: ::kernel::sys::raw::c_int,
                     size: usize);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lock_profile_object {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lpohead {
    pub lh_first: *mut lock_profile_object,
}
#[test]
fn bindgen_test_layout_lpohead() {
    assert_eq!(::core::mem::size_of::<lpohead>() , 8usize , concat ! (
               "Size of: " , stringify ! ( lpohead ) ));
    assert_eq! (::core::mem::align_of::<lpohead>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lpohead ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lpohead ) ) . lh_first as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lpohead ) , "::" ,
                stringify ! ( lh_first ) ));
}
impl Clone for lpohead {
    fn clone(&self) -> Self { *self }
}
impl Default for lpohead {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    #[link_name = "sdt_probes_enabled"]
    pub static mut sdt_probes_enabled: bool_;
}
pub type sdt_probe_func_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: u32, arg0: usize,
                                                arg1: usize, arg2: usize,
                                                arg3: usize, arg4: usize)>;
extern "C" {
    #[link_name = "sdt_probe_func"]
    pub static mut sdt_probe_func: sdt_probe_func_t;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sdt_probe {
    pub version: ::kernel::sys::raw::c_int,
    pub prov: *mut sdt_provider,
    pub probe_entry: sdt_probe__bindgen_ty_1,
    pub argtype_list: sdt_probe__bindgen_ty_2,
    pub mod_: *const ::kernel::sys::raw::c_char,
    pub func: *const ::kernel::sys::raw::c_char,
    pub name: *const ::kernel::sys::raw::c_char,
    pub id: id_t,
    pub n_args: ::kernel::sys::raw::c_int,
    pub sdtp_lf: *mut linker_file,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sdt_probe__bindgen_ty_1 {
    pub tqe_next: *mut sdt_probe,
    pub tqe_prev: *mut *mut sdt_probe,
}
#[test]
fn bindgen_test_layout_sdt_probe__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<sdt_probe__bindgen_ty_1>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( sdt_probe__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<sdt_probe__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( sdt_probe__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe__bindgen_ty_1 ) ) . tqe_next as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe__bindgen_ty_1
                ) , "::" , stringify ! ( tqe_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe__bindgen_ty_1 ) ) . tqe_prev as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe__bindgen_ty_1
                ) , "::" , stringify ! ( tqe_prev ) ));
}
impl Clone for sdt_probe__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for sdt_probe__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sdt_probe__bindgen_ty_2 {
    pub tqh_first: *mut sdt_argtype,
    pub tqh_last: *mut *mut sdt_argtype,
}
#[test]
fn bindgen_test_layout_sdt_probe__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<sdt_probe__bindgen_ty_2>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( sdt_probe__bindgen_ty_2 ) ));
    assert_eq! (::core::mem::align_of::<sdt_probe__bindgen_ty_2>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( sdt_probe__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe__bindgen_ty_2 ) ) . tqh_first
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe__bindgen_ty_2
                ) , "::" , stringify ! ( tqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe__bindgen_ty_2 ) ) . tqh_last as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe__bindgen_ty_2
                ) , "::" , stringify ! ( tqh_last ) ));
}
impl Clone for sdt_probe__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for sdt_probe__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_sdt_probe() {
    assert_eq!(::core::mem::size_of::<sdt_probe>() , 96usize , concat ! (
               "Size of: " , stringify ! ( sdt_probe ) ));
    assert_eq! (::core::mem::align_of::<sdt_probe>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sdt_probe ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . version as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . prov as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( prov ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . probe_entry as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( probe_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . argtype_list as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( argtype_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . mod_ as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( mod_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . func as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . name as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . id as * const _ as usize
                } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . n_args as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( n_args ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . sdtp_lf as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( sdtp_lf ) ));
}
impl Clone for sdt_probe {
    fn clone(&self) -> Self { *self }
}
impl Default for sdt_probe {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sdt_provider {
    pub name: *mut ::kernel::sys::raw::c_char,
    pub prov_entry: sdt_provider__bindgen_ty_1,
    pub id: usize,
    pub sdt_refs: ::kernel::sys::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sdt_provider__bindgen_ty_1 {
    pub tqe_next: *mut sdt_provider,
    pub tqe_prev: *mut *mut sdt_provider,
}
#[test]
fn bindgen_test_layout_sdt_provider__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<sdt_provider__bindgen_ty_1>() , 16usize
               , concat ! (
               "Size of: " , stringify ! ( sdt_provider__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<sdt_provider__bindgen_ty_1>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( sdt_provider__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_provider__bindgen_ty_1 ) ) . tqe_next
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                sdt_provider__bindgen_ty_1 ) , "::" , stringify ! ( tqe_next )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_provider__bindgen_ty_1 ) ) . tqe_prev
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                sdt_provider__bindgen_ty_1 ) , "::" , stringify ! ( tqe_prev )
                ));
}
impl Clone for sdt_provider__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for sdt_provider__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_sdt_provider() {
    assert_eq!(::core::mem::size_of::<sdt_provider>() , 40usize , concat ! (
               "Size of: " , stringify ! ( sdt_provider ) ));
    assert_eq! (::core::mem::align_of::<sdt_provider>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sdt_provider ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_provider ) ) . name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_provider ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_provider ) ) . prov_entry as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_provider ) , "::" ,
                stringify ! ( prov_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_provider ) ) . id as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_provider ) , "::" ,
                stringify ! ( id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_provider ) ) . sdt_refs as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_provider ) , "::" ,
                stringify ! ( sdt_refs ) ));
}
impl Clone for sdt_provider {
    fn clone(&self) -> Self { *self }
}
impl Default for sdt_provider {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct linker_file {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sdt_argtype {
    pub ndx: ::kernel::sys::raw::c_int,
    pub type_: *const ::kernel::sys::raw::c_char,
    pub xtype: *const ::kernel::sys::raw::c_char,
    pub argtype_entry: sdt_argtype__bindgen_ty_1,
    pub probe: *mut sdt_probe,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sdt_argtype__bindgen_ty_1 {
    pub tqe_next: *mut sdt_argtype,
    pub tqe_prev: *mut *mut sdt_argtype,
}
#[test]
fn bindgen_test_layout_sdt_argtype__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<sdt_argtype__bindgen_ty_1>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( sdt_argtype__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<sdt_argtype__bindgen_ty_1>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( sdt_argtype__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_argtype__bindgen_ty_1 ) ) . tqe_next
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                sdt_argtype__bindgen_ty_1 ) , "::" , stringify ! ( tqe_next )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_argtype__bindgen_ty_1 ) ) . tqe_prev
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                sdt_argtype__bindgen_ty_1 ) , "::" , stringify ! ( tqe_prev )
                ));
}
impl Clone for sdt_argtype__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for sdt_argtype__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_sdt_argtype() {
    assert_eq!(::core::mem::size_of::<sdt_argtype>() , 48usize , concat ! (
               "Size of: " , stringify ! ( sdt_argtype ) ));
    assert_eq! (::core::mem::align_of::<sdt_argtype>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sdt_argtype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_argtype ) ) . ndx as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_argtype ) , "::" ,
                stringify ! ( ndx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_argtype ) ) . type_ as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_argtype ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_argtype ) ) . xtype as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_argtype ) , "::" ,
                stringify ! ( xtype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_argtype ) ) . argtype_entry as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_argtype ) , "::" ,
                stringify ! ( argtype_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_argtype ) ) . probe as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_argtype ) , "::" ,
                stringify ! ( probe ) ));
}
impl Clone for sdt_argtype {
    fn clone(&self) -> Self { *self }
}
impl Default for sdt_argtype {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    pub fn sdt_probe_stub(arg1: u32, arg2: usize, arg3: usize, arg4: usize,
                          arg5: usize, arg6: usize);
}
extern "C" {
    #[link_name = "lockstat_enabled"]
    pub static mut lockstat_enabled: bool_;
}
extern "C" {
    pub fn atomic_cmpset_char(dst: *mut u_char, expect: u_char, src: u_char)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn atomic_cmpset_short(dst: *mut u_short, expect: u_short,
                               src: u_short) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn atomic_cmpset_int(dst: *mut u_int, expect: u_int, src: u_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn atomic_cmpset_long(dst: *mut u_long, expect: u_long, src: u_long)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn atomic_fcmpset_char(dst: *mut u_char, expect: *mut u_char,
                               src: u_char) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn atomic_fcmpset_short(dst: *mut u_short, expect: *mut u_short,
                                src: u_short) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn atomic_fcmpset_int(dst: *mut u_int, expect: *mut u_int, src: u_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn atomic_fcmpset_long(dst: *mut u_long, expect: *mut u_long,
                               src: u_long) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn atomic_fetchadd_int(p: *mut u_int, v: u_int) -> u_int;
}
extern "C" {
    pub fn atomic_fetchadd_long(p: *mut u_long, v: u_long) -> u_long;
}
extern "C" {
    pub fn atomic_testandset_int(p: *mut u_int, v: u_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn atomic_testandset_long(p: *mut u_long, v: u_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn atomic_testandclear_int(p: *mut u_int, v: u_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn atomic_testandclear_long(p: *mut u_long, v: u_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn atomic_thread_fence_acq();
}
extern "C" {
    pub fn atomic_thread_fence_acq_rel();
}
extern "C" {
    pub fn atomic_thread_fence_rel();
}
extern "C" {
    pub fn atomic_thread_fence_seq_cst();
}
extern "C" {
    pub fn atomic_set_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_set_barr_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_clear_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_clear_barr_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_add_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_add_barr_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_subtract_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_subtract_barr_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_set_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_set_barr_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_clear_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_clear_barr_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_add_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_add_barr_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_subtract_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_subtract_barr_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_set_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_set_barr_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_clear_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_clear_barr_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_add_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_add_barr_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_subtract_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_subtract_barr_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_set_long(p: *mut u_long, v: u_long);
}
extern "C" {
    pub fn atomic_set_barr_long(p: *mut u_long, v: u_long);
}
extern "C" {
    pub fn atomic_clear_long(p: *mut u_long, v: u_long);
}
extern "C" {
    pub fn atomic_clear_barr_long(p: *mut u_long, v: u_long);
}
extern "C" {
    pub fn atomic_add_long(p: *mut u_long, v: u_long);
}
extern "C" {
    pub fn atomic_add_barr_long(p: *mut u_long, v: u_long);
}
extern "C" {
    pub fn atomic_subtract_long(p: *mut u_long, v: u_long);
}
extern "C" {
    pub fn atomic_subtract_barr_long(p: *mut u_long, v: u_long);
}
extern "C" {
    pub fn atomic_load_acq_char(p: *mut u_char) -> u_char;
}
extern "C" {
    pub fn atomic_store_rel_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_load_acq_short(p: *mut u_short) -> u_short;
}
extern "C" {
    pub fn atomic_store_rel_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_load_acq_int(p: *mut u_int) -> u_int;
}
extern "C" {
    pub fn atomic_store_rel_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_load_acq_long(p: *mut u_long) -> u_long;
}
extern "C" {
    pub fn atomic_store_rel_long(p: *mut u_long, v: u_long);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct region_descriptor {
    _unused: [u8; 0],
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy)]
pub struct invpcid_descr {
    pub _bitfield_1: u64,
    pub addr: u64,
}
#[test]
fn bindgen_test_layout_invpcid_descr() {
    assert_eq!(::core::mem::size_of::<invpcid_descr>() , 16usize , concat ! (
               "Size of: " , stringify ! ( invpcid_descr ) ));
    assert_eq! (::core::mem::align_of::<invpcid_descr>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( invpcid_descr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const invpcid_descr ) ) . addr as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( invpcid_descr ) , "::"
                , stringify ! ( addr ) ));
}
impl Clone for invpcid_descr {
    fn clone(&self) -> Self { *self }
}
impl invpcid_descr {
    #[inline]
    pub fn pcid(&self) -> u64 {
        let mut unit_field_val: u64 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u64
                                                 as *mut u8,
                                             ::core::mem::size_of::<u64>())
        };
        let mask = 4095u64 as u64;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::core::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_pcid(&mut self, val: u64) {
        let mask = 4095u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u64
                                                 as *mut u8,
                                             ::core::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn pad(&self) -> u64 {
        let mut unit_field_val: u64 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u64
                                                 as *mut u8,
                                             ::core::mem::size_of::<u64>())
        };
        let mask = 18446744073709547520u64 as u64;
        let val = (unit_field_val & mask) >> 12usize;
        unsafe { ::core::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_pad(&mut self, val: u64) {
        let mask = 18446744073709547520u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u64
                                                 as *mut u8,
                                             ::core::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 12usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(pcid: u64, pad: u64) -> u64 {
        ({ ({ 0 } | ((pcid as u64 as u64) << 0usize) & (4095u64 as u64)) } |
             ((pad as u64 as u64) << 12usize) &
                 (18446744073709547520u64 as u64))
    }
}
pub const SGX_ECREATE: _bindgen_ty_1 = _bindgen_ty_1::SGX_ECREATE;
pub const SGX_EADD: _bindgen_ty_1 = _bindgen_ty_1::SGX_EADD;
pub const SGX_EINIT: _bindgen_ty_1 = _bindgen_ty_1::SGX_EINIT;
pub const SGX_EREMOVE: _bindgen_ty_1 = _bindgen_ty_1::SGX_EREMOVE;
pub const SGX_EDGBRD: _bindgen_ty_1 = _bindgen_ty_1::SGX_EDGBRD;
pub const SGX_EDGBWR: _bindgen_ty_1 = _bindgen_ty_1::SGX_EDGBWR;
pub const SGX_EEXTEND: _bindgen_ty_1 = _bindgen_ty_1::SGX_EEXTEND;
pub const SGX_ELDU: _bindgen_ty_1 = _bindgen_ty_1::SGX_ELDU;
pub const SGX_EBLOCK: _bindgen_ty_1 = _bindgen_ty_1::SGX_EBLOCK;
pub const SGX_EPA: _bindgen_ty_1 = _bindgen_ty_1::SGX_EPA;
pub const SGX_EWB: _bindgen_ty_1 = _bindgen_ty_1::SGX_EWB;
pub const SGX_ETRACK: _bindgen_ty_1 = _bindgen_ty_1::SGX_ETRACK;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_1 {
    SGX_ECREATE = 0,
    SGX_EADD = 1,
    SGX_EINIT = 2,
    SGX_EREMOVE = 3,
    SGX_EDGBRD = 4,
    SGX_EDGBWR = 5,
    SGX_EEXTEND = 6,
    SGX_ELDU = 8,
    SGX_EBLOCK = 9,
    SGX_EPA = 10,
    SGX_EWB = 11,
    SGX_ETRACK = 12,
}
pub const SGX_PT_SECS: _bindgen_ty_2 = _bindgen_ty_2::SGX_PT_SECS;
pub const SGX_PT_TCS: _bindgen_ty_2 = _bindgen_ty_2::SGX_PT_TCS;
pub const SGX_PT_REG: _bindgen_ty_2 = _bindgen_ty_2::SGX_PT_REG;
pub const SGX_PT_VA: _bindgen_ty_2 = _bindgen_ty_2::SGX_PT_VA;
pub const SGX_PT_TRIM: _bindgen_ty_2 = _bindgen_ty_2::SGX_PT_TRIM;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_2 {
    SGX_PT_SECS = 0,
    SGX_PT_TCS = 1,
    SGX_PT_REG = 2,
    SGX_PT_VA = 3,
    SGX_PT_TRIM = 4,
}
extern "C" {
    pub fn sgx_encls(eax: u32, rbx: u64, rcx: u64, rdx: u64)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn reset_dbregs();
}
extern "C" {
    pub fn rdmsr_safe(msr: u_int, val: *mut u64) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn wrmsr_safe(msr: u_int, newval: u64) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn _mtx_init(c: *mut usize, name: *const ::kernel::sys::raw::c_char,
                     type_: *const ::kernel::sys::raw::c_char,
                     opts: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn _mtx_destroy(c: *mut usize);
}
extern "C" {
    pub fn mtx_sysinit(arg: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn _mtx_trylock_flags_int(m: *mut mtx,
                                  opts: ::kernel::sys::raw::c_int,
                                  file: *const ::kernel::sys::raw::c_char,
                                  line: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn _mtx_trylock_flags_(c: *mut usize, opts: ::kernel::sys::raw::c_int,
                               file: *const ::kernel::sys::raw::c_char,
                               line: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn mutex_init();
}
extern "C" {
    pub fn __mtx_lock_sleep(c: *mut usize, v: usize,
                            opts: ::kernel::sys::raw::c_int,
                            file: *const ::kernel::sys::raw::c_char,
                            line: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn __mtx_unlock_sleep(c: *mut usize, v: usize,
                              opts: ::kernel::sys::raw::c_int,
                              file: *const ::kernel::sys::raw::c_char,
                              line: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn __mtx_lock_flags(c: *mut usize, opts: ::kernel::sys::raw::c_int,
                            file: *const ::kernel::sys::raw::c_char,
                            line: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn __mtx_unlock_flags(c: *mut usize, opts: ::kernel::sys::raw::c_int,
                              file: *const ::kernel::sys::raw::c_char,
                              line: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn __mtx_lock_spin_flags(c: *mut usize,
                                 opts: ::kernel::sys::raw::c_int,
                                 file: *const ::kernel::sys::raw::c_char,
                                 line: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn __mtx_trylock_spin_flags(c: *mut usize,
                                    opts: ::kernel::sys::raw::c_int,
                                    file: *const ::kernel::sys::raw::c_char,
                                    line: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn __mtx_unlock_spin_flags(c: *mut usize,
                                   opts: ::kernel::sys::raw::c_int,
                                   file: *const ::kernel::sys::raw::c_char,
                                   line: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn mtx_spin_wait_unlocked(m: *mut mtx);
}
extern "C" {
    pub fn thread_lock_flags_(arg1: *mut thread,
                              arg2: ::kernel::sys::raw::c_int,
                              arg3: *const ::kernel::sys::raw::c_char,
                              arg4: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn _thread_lock(td: *mut thread, opts: ::kernel::sys::raw::c_int,
                        file: *const ::kernel::sys::raw::c_char,
                        line: ::kernel::sys::raw::c_int);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mtx_pool {
    _unused: [u8; 0],
}
extern "C" {
    pub fn mtx_pool_create(mtx_name: *const ::kernel::sys::raw::c_char,
                           pool_size: ::kernel::sys::raw::c_int,
                           opts: ::kernel::sys::raw::c_int) -> *mut mtx_pool;
}
extern "C" {
    pub fn mtx_pool_destroy(poolp: *mut *mut mtx_pool);
}
extern "C" {
    pub fn mtx_pool_find(pool: *mut mtx_pool,
                         ptr: *mut ::kernel::sys::raw::c_void) -> *mut mtx;
}
extern "C" {
    pub fn mtx_pool_alloc(pool: *mut mtx_pool) -> *mut mtx;
}
extern "C" {
    #[link_name = "mtxpool_sleep"]
    pub static mut mtxpool_sleep: *mut mtx_pool;
}
extern "C" {
    #[link_name = "Giant"]
    pub static mut Giant: mtx;
}
extern "C" {
    #[link_name = "blocked_lock"]
    pub static mut blocked_lock: mtx;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mtx_args {
    pub ma_mtx: *mut ::kernel::sys::raw::c_void,
    pub ma_desc: *const ::kernel::sys::raw::c_char,
    pub ma_opts: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_mtx_args() {
    assert_eq!(::core::mem::size_of::<mtx_args>() , 24usize , concat ! (
               "Size of: " , stringify ! ( mtx_args ) ));
    assert_eq! (::core::mem::align_of::<mtx_args>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( mtx_args ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mtx_args ) ) . ma_mtx as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mtx_args ) , "::" ,
                stringify ! ( ma_mtx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mtx_args ) ) . ma_desc as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mtx_args ) , "::" ,
                stringify ! ( ma_desc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mtx_args ) ) . ma_opts as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mtx_args ) , "::" ,
                stringify ! ( ma_opts ) ));
}
impl Clone for mtx_args {
    fn clone(&self) -> Self { *self }
}
impl Default for mtx_args {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry {
    pub ee_link: eventhandler_entry__bindgen_ty_1,
    pub ee_priority: ::kernel::sys::raw::c_int,
    pub ee_arg: *mut ::kernel::sys::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry__bindgen_ty_1 {
    pub tqe_next: *mut eventhandler_entry,
    pub tqe_prev: *mut *mut eventhandler_entry,
}
#[test]
fn bindgen_test_layout_eventhandler_entry__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry__bindgen_ty_1>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry__bindgen_ty_1 ) ) .
                tqe_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry__bindgen_ty_1 ) , "::" , stringify ! (
                tqe_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry__bindgen_ty_1 ) ) .
                tqe_prev as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry__bindgen_ty_1 ) , "::" , stringify ! (
                tqe_prev ) ));
}
impl Clone for eventhandler_entry__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_eventhandler_entry() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry>() , 32usize , concat
               ! ( "Size of: " , stringify ! ( eventhandler_entry ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry ) ) . ee_link as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( eventhandler_entry ) ,
                "::" , stringify ! ( ee_link ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry ) ) . ee_priority as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( eventhandler_entry ) ,
                "::" , stringify ! ( ee_priority ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry ) ) . ee_arg as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( eventhandler_entry ) ,
                "::" , stringify ! ( ee_arg ) ));
}
impl Clone for eventhandler_entry {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_list {
    pub el_name: *mut ::kernel::sys::raw::c_char,
    pub el_flags: ::kernel::sys::raw::c_int,
    pub el_runcount: u_int,
    pub el_lock: mtx,
    pub el_link: eventhandler_list__bindgen_ty_1,
    pub el_entries: eventhandler_list__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_list__bindgen_ty_1 {
    pub tqe_next: *mut eventhandler_list,
    pub tqe_prev: *mut *mut eventhandler_list,
}
#[test]
fn bindgen_test_layout_eventhandler_list__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<eventhandler_list__bindgen_ty_1>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_list__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_list__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_list__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_list__bindgen_ty_1 ) ) .
                tqe_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_list__bindgen_ty_1 ) , "::" , stringify ! (
                tqe_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_list__bindgen_ty_1 ) ) .
                tqe_prev as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_list__bindgen_ty_1 ) , "::" , stringify ! (
                tqe_prev ) ));
}
impl Clone for eventhandler_list__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_list__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_list__bindgen_ty_2 {
    pub tqh_first: *mut eventhandler_entry,
    pub tqh_last: *mut *mut eventhandler_entry,
}
#[test]
fn bindgen_test_layout_eventhandler_list__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<eventhandler_list__bindgen_ty_2>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_list__bindgen_ty_2 )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_list__bindgen_ty_2>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_list__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_list__bindgen_ty_2 ) ) .
                tqh_first as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_list__bindgen_ty_2 ) , "::" , stringify ! (
                tqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_list__bindgen_ty_2 ) ) .
                tqh_last as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_list__bindgen_ty_2 ) , "::" , stringify ! (
                tqh_last ) ));
}
impl Clone for eventhandler_list__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_list__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_eventhandler_list() {
    assert_eq!(::core::mem::size_of::<eventhandler_list>() , 80usize , concat
               ! ( "Size of: " , stringify ! ( eventhandler_list ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_list>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( eventhandler_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_list ) ) . el_name as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( eventhandler_list ) ,
                "::" , stringify ! ( el_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_list ) ) . el_flags as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( eventhandler_list ) ,
                "::" , stringify ! ( el_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_list ) ) . el_runcount as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( eventhandler_list ) ,
                "::" , stringify ! ( el_runcount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_list ) ) . el_lock as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( eventhandler_list ) ,
                "::" , stringify ! ( el_lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_list ) ) . el_link as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( eventhandler_list ) ,
                "::" , stringify ! ( el_link ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_list ) ) . el_entries as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( eventhandler_list ) ,
                "::" , stringify ! ( el_entries ) ));
}
impl Clone for eventhandler_list {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_list {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type eventhandler_tag = *mut eventhandler_entry;
extern "C" {
    pub fn eventhandler_register(list: *mut eventhandler_list,
                                 name: *const ::kernel::sys::raw::c_char,
                                 func: *mut ::kernel::sys::raw::c_void,
                                 arg: *mut ::kernel::sys::raw::c_void,
                                 priority: ::kernel::sys::raw::c_int)
     -> eventhandler_tag;
}
extern "C" {
    pub fn eventhandler_deregister(list: *mut eventhandler_list,
                                   tag: eventhandler_tag);
}
extern "C" {
    pub fn eventhandler_deregister_nowait(list: *mut eventhandler_list,
                                          tag: eventhandler_tag);
}
extern "C" {
    pub fn eventhandler_find_list(name: *const ::kernel::sys::raw::c_char)
     -> *mut eventhandler_list;
}
extern "C" {
    pub fn eventhandler_prune_list(list: *mut eventhandler_list);
}
extern "C" {
    pub fn eventhandler_create_list(name: *const ::kernel::sys::raw::c_char)
     -> *mut eventhandler_list;
}
pub type shutdown_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2:
                                                    ::kernel::sys::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_shutdown_pre_sync {
    pub ee: eventhandler_entry,
    pub eh_func: shutdown_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_shutdown_pre_sync() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_shutdown_pre_sync>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_shutdown_pre_sync ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_shutdown_pre_sync>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_shutdown_pre_sync ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_shutdown_pre_sync ) )
                . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_shutdown_pre_sync ) , "::" , stringify ! (
                ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_shutdown_pre_sync ) )
                . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_shutdown_pre_sync ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_shutdown_pre_sync {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_shutdown_pre_sync {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __hack {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_shutdown_post_sync {
    pub ee: eventhandler_entry,
    pub eh_func: shutdown_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_shutdown_post_sync() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_shutdown_post_sync>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_shutdown_post_sync ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_shutdown_post_sync>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_shutdown_post_sync ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_shutdown_post_sync ) )
                . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_shutdown_post_sync ) , "::" , stringify ! (
                ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_shutdown_post_sync ) )
                . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_shutdown_post_sync ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_shutdown_post_sync {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_shutdown_post_sync {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_shutdown_final {
    pub ee: eventhandler_entry,
    pub eh_func: shutdown_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_shutdown_final() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_shutdown_final>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_shutdown_final )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_shutdown_final>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_shutdown_final ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_shutdown_final ) ) .
                ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_shutdown_final ) , "::" , stringify ! ( ee
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_shutdown_final ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_shutdown_final ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_shutdown_final {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_shutdown_final {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type power_change_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_power_resume {
    pub ee: eventhandler_entry,
    pub eh_func: power_change_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_power_resume() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_power_resume>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_power_resume )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_power_resume>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_power_resume ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_power_resume ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_power_resume ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_power_resume ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_power_resume ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_power_resume {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_power_resume {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_power_suspend {
    pub ee: eventhandler_entry,
    pub eh_func: power_change_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_power_suspend() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_power_suspend>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_power_suspend )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_power_suspend>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_power_suspend ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_power_suspend ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_power_suspend ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_power_suspend ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_power_suspend ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_power_suspend {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_power_suspend {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_power_suspend_early {
    pub ee: eventhandler_entry,
    pub eh_func: power_change_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_power_suspend_early() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_power_suspend_early>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_power_suspend_early ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_power_suspend_early>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_power_suspend_early ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_power_suspend_early )
                ) . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_power_suspend_early ) , "::" , stringify !
                ( ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_power_suspend_early )
                ) . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_power_suspend_early ) , "::" , stringify !
                ( eh_func ) ));
}
impl Clone for eventhandler_entry_power_suspend_early {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_power_suspend_early {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type vm_lowmem_handler_t =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2:
                                                    ::kernel::sys::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_vm_lowmem {
    pub ee: eventhandler_entry,
    pub eh_func: vm_lowmem_handler_t,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_vm_lowmem() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_vm_lowmem>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_vm_lowmem ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_vm_lowmem>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_vm_lowmem )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_vm_lowmem ) ) . ee as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_vm_lowmem ) , "::" , stringify ! ( ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_vm_lowmem ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_vm_lowmem ) , "::" , stringify ! ( eh_func
                ) ));
}
impl Clone for eventhandler_entry_vm_lowmem {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_vm_lowmem {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type mountroot_handler_t =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_mountroot {
    pub ee: eventhandler_entry,
    pub eh_func: mountroot_handler_t,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_mountroot() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_mountroot>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_mountroot ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_mountroot>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_mountroot )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_mountroot ) ) . ee as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_mountroot ) , "::" , stringify ! ( ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_mountroot ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_mountroot ) , "::" , stringify ! ( eh_func
                ) ));
}
impl Clone for eventhandler_entry_mountroot {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_mountroot {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mount {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnode {
    _unused: [u8; 0],
}
pub type vfs_mounted_notify_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut mount,
                                                arg3: *mut vnode,
                                                arg4: *mut thread)>;
pub type vfs_unmounted_notify_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut mount,
                                                arg3: *mut thread)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_vfs_mounted {
    pub ee: eventhandler_entry,
    pub eh_func: vfs_mounted_notify_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_vfs_mounted() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_vfs_mounted>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_vfs_mounted )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_vfs_mounted>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_vfs_mounted
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_vfs_mounted ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_vfs_mounted ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_vfs_mounted ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_vfs_mounted ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_vfs_mounted {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_vfs_mounted {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_vfs_unmounted {
    pub ee: eventhandler_entry,
    pub eh_func: vfs_unmounted_notify_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_vfs_unmounted() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_vfs_unmounted>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_vfs_unmounted )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_vfs_unmounted>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_vfs_unmounted ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_vfs_unmounted ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_vfs_unmounted ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_vfs_unmounted ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_vfs_unmounted ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_vfs_unmounted {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_vfs_unmounted {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct proc_ {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct image_params {
    _unused: [u8; 0],
}
pub type exitlist_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut proc_)>;
pub type forklist_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut proc_,
                                                arg3: *mut proc_,
                                                arg4:
                                                    ::kernel::sys::raw::c_int)>;
pub type execlist_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut proc_,
                                                arg3: *mut image_params)>;
pub type proc_ctor_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut proc_)>;
pub type proc_dtor_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut proc_)>;
pub type proc_init_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut proc_)>;
pub type proc_fini_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut proc_)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_process_ctor {
    pub ee: eventhandler_entry,
    pub eh_func: proc_ctor_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_process_ctor() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_process_ctor>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_process_ctor )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_process_ctor>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_process_ctor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_ctor ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_ctor ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_ctor ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_ctor ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_process_ctor {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_process_ctor {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_process_dtor {
    pub ee: eventhandler_entry,
    pub eh_func: proc_dtor_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_process_dtor() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_process_dtor>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_process_dtor )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_process_dtor>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_process_dtor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_dtor ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_dtor ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_dtor ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_dtor ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_process_dtor {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_process_dtor {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_process_init {
    pub ee: eventhandler_entry,
    pub eh_func: proc_init_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_process_init() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_process_init>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_process_init )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_process_init>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_process_init ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_init ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_init ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_init ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_init ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_process_init {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_process_init {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_process_fini {
    pub ee: eventhandler_entry,
    pub eh_func: proc_fini_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_process_fini() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_process_fini>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_process_fini )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_process_fini>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_process_fini ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_fini ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_fini ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_fini ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_fini ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_process_fini {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_process_fini {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_process_exit {
    pub ee: eventhandler_entry,
    pub eh_func: exitlist_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_process_exit() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_process_exit>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_process_exit )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_process_exit>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_process_exit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_exit ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_exit ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_exit ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_exit ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_process_exit {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_process_exit {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_process_fork {
    pub ee: eventhandler_entry,
    pub eh_func: forklist_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_process_fork() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_process_fork>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_process_fork )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_process_fork>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_process_fork ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_fork ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_fork ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_fork ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_fork ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_process_fork {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_process_fork {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_process_exec {
    pub ee: eventhandler_entry,
    pub eh_func: execlist_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_process_exec() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_process_exec>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_process_exec )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_process_exec>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_process_exec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_exec ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_exec ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_exec ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_exec ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_process_exec {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_process_exec {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type app_coredump_start_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut thread,
                                                name:
                                                    *mut ::kernel::sys::raw::c_char)>;
pub type app_coredump_progress_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                td: *mut thread,
                                                byte_count:
                                                    ::kernel::sys::raw::c_int)>;
pub type app_coredump_finish_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                td: *mut thread)>;
pub type app_coredump_error_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                td: *mut thread,
                                                msg:
                                                    *mut ::kernel::sys::raw::c_char, ...)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_app_coredump_start {
    pub ee: eventhandler_entry,
    pub eh_func: app_coredump_start_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_app_coredump_start() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_app_coredump_start>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_app_coredump_start ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_app_coredump_start>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_app_coredump_start ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_app_coredump_start ) )
                . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_app_coredump_start ) , "::" , stringify ! (
                ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_app_coredump_start ) )
                . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_app_coredump_start ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_app_coredump_start {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_app_coredump_start {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_app_coredump_progress {
    pub ee: eventhandler_entry,
    pub eh_func: app_coredump_progress_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_app_coredump_progress() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_app_coredump_progress>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_app_coredump_progress ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_app_coredump_progress>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_app_coredump_progress ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const eventhandler_entry_app_coredump_progress ) )
                . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_app_coredump_progress ) , "::" , stringify
                ! ( ee ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const eventhandler_entry_app_coredump_progress ) )
                . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_app_coredump_progress ) , "::" , stringify
                ! ( eh_func ) ));
}
impl Clone for eventhandler_entry_app_coredump_progress {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_app_coredump_progress {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_app_coredump_finish {
    pub ee: eventhandler_entry,
    pub eh_func: app_coredump_finish_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_app_coredump_finish() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_app_coredump_finish>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_app_coredump_finish ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_app_coredump_finish>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_app_coredump_finish ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_app_coredump_finish )
                ) . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_app_coredump_finish ) , "::" , stringify !
                ( ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_app_coredump_finish )
                ) . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_app_coredump_finish ) , "::" , stringify !
                ( eh_func ) ));
}
impl Clone for eventhandler_entry_app_coredump_finish {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_app_coredump_finish {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_app_coredump_error {
    pub ee: eventhandler_entry,
    pub eh_func: app_coredump_error_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_app_coredump_error() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_app_coredump_error>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_app_coredump_error ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_app_coredump_error>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_app_coredump_error ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_app_coredump_error ) )
                . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_app_coredump_error ) , "::" , stringify ! (
                ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_app_coredump_error ) )
                . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_app_coredump_error ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_app_coredump_error {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_app_coredump_error {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type thread_ctor_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut thread)>;
pub type thread_dtor_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut thread)>;
pub type thread_fini_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut thread)>;
pub type thread_init_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut thread)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_thread_ctor {
    pub ee: eventhandler_entry,
    pub eh_func: thread_ctor_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_thread_ctor() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_thread_ctor>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_thread_ctor )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_thread_ctor>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_thread_ctor
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_thread_ctor ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_thread_ctor ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_thread_ctor ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_thread_ctor ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_thread_ctor {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_thread_ctor {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_thread_dtor {
    pub ee: eventhandler_entry,
    pub eh_func: thread_dtor_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_thread_dtor() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_thread_dtor>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_thread_dtor )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_thread_dtor>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_thread_dtor
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_thread_dtor ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_thread_dtor ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_thread_dtor ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_thread_dtor ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_thread_dtor {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_thread_dtor {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_thread_init {
    pub ee: eventhandler_entry,
    pub eh_func: thread_init_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_thread_init() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_thread_init>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_thread_init )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_thread_init>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_thread_init
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_thread_init ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_thread_init ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_thread_init ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_thread_init ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_thread_init {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_thread_init {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_thread_fini {
    pub ee: eventhandler_entry,
    pub eh_func: thread_fini_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_thread_fini() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_thread_fini>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_thread_fini )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_thread_fini>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_thread_fini
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_thread_fini ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_thread_fini ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_thread_fini ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_thread_fini ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_thread_fini {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_thread_fini {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type uma_zone_chfn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_nmbclusters_change {
    pub ee: eventhandler_entry,
    pub eh_func: uma_zone_chfn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_nmbclusters_change() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_nmbclusters_change>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_nmbclusters_change ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_nmbclusters_change>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_nmbclusters_change ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_nmbclusters_change ) )
                . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_nmbclusters_change ) , "::" , stringify ! (
                ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_nmbclusters_change ) )
                . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_nmbclusters_change ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_nmbclusters_change {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_nmbclusters_change {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_nmbufs_change {
    pub ee: eventhandler_entry,
    pub eh_func: uma_zone_chfn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_nmbufs_change() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_nmbufs_change>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_nmbufs_change )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_nmbufs_change>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_nmbufs_change ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_nmbufs_change ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_nmbufs_change ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_nmbufs_change ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_nmbufs_change ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_nmbufs_change {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_nmbufs_change {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_maxsockets_change {
    pub ee: eventhandler_entry,
    pub eh_func: uma_zone_chfn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_maxsockets_change() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_maxsockets_change>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_maxsockets_change ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_maxsockets_change>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_maxsockets_change ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_maxsockets_change ) )
                . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_maxsockets_change ) , "::" , stringify ! (
                ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_maxsockets_change ) )
                . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_maxsockets_change ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_maxsockets_change {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_maxsockets_change {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type kld_load_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut linker_file)>;
pub type kld_unload_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2:
                                                    *const ::kernel::sys::raw::c_char,
                                                arg3: caddr_t, arg4: usize)>;
pub type kld_unload_try_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut linker_file,
                                                arg3:
                                                    *mut ::kernel::sys::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_kld_load {
    pub ee: eventhandler_entry,
    pub eh_func: kld_load_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_kld_load() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_kld_load>() , 40usize
               , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_kld_load ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_kld_load>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_kld_load )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_kld_load ) ) . ee as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_kld_load ) , "::" , stringify ! ( ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_kld_load ) ) . eh_func
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_kld_load ) , "::" , stringify ! ( eh_func )
                ));
}
impl Clone for eventhandler_entry_kld_load {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_kld_load {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_kld_unload {
    pub ee: eventhandler_entry,
    pub eh_func: kld_unload_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_kld_unload() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_kld_unload>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_kld_unload ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_kld_unload>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_kld_unload
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_kld_unload ) ) . ee as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_kld_unload ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_kld_unload ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_kld_unload ) , "::" , stringify ! ( eh_func
                ) ));
}
impl Clone for eventhandler_entry_kld_unload {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_kld_unload {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_kld_unload_try {
    pub ee: eventhandler_entry,
    pub eh_func: kld_unload_try_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_kld_unload_try() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_kld_unload_try>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_kld_unload_try )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_kld_unload_try>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_kld_unload_try ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_kld_unload_try ) ) .
                ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_kld_unload_try ) , "::" , stringify ! ( ee
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_kld_unload_try ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_kld_unload_try ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_kld_unload_try {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_kld_unload_try {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fb_info {
    _unused: [u8; 0],
}
pub type register_framebuffer_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut fb_info)>;
pub type unregister_framebuffer_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut fb_info)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_register_framebuffer {
    pub ee: eventhandler_entry,
    pub eh_func: register_framebuffer_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_register_framebuffer() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_register_framebuffer>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_register_framebuffer ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_register_framebuffer>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_register_framebuffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_register_framebuffer )
                ) . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_register_framebuffer ) , "::" , stringify !
                ( ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_register_framebuffer )
                ) . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_register_framebuffer ) , "::" , stringify !
                ( eh_func ) ));
}
impl Clone for eventhandler_entry_register_framebuffer {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_register_framebuffer {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_unregister_framebuffer {
    pub ee: eventhandler_entry,
    pub eh_func: unregister_framebuffer_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_unregister_framebuffer() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_unregister_framebuffer>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_unregister_framebuffer ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_unregister_framebuffer>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_unregister_framebuffer ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const eventhandler_entry_unregister_framebuffer ) )
                . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_unregister_framebuffer ) , "::" , stringify
                ! ( ee ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const eventhandler_entry_unregister_framebuffer ) )
                . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_unregister_framebuffer ) , "::" , stringify
                ! ( eh_func ) ));
}
impl Clone for eventhandler_entry_unregister_framebuffer {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_unregister_framebuffer {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cam_path {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ata_params {
    _unused: [u8; 0],
}
pub type ada_probe_veto_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut cam_path,
                                                arg3: *mut ata_params,
                                                arg4:
                                                    *mut ::kernel::sys::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_ada_probe_veto {
    pub ee: eventhandler_entry,
    pub eh_func: ada_probe_veto_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_ada_probe_veto() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_ada_probe_veto>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_ada_probe_veto )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_ada_probe_veto>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_ada_probe_veto ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_ada_probe_veto ) ) .
                ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_ada_probe_veto ) , "::" , stringify ! ( ee
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_ada_probe_veto ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_ada_probe_veto ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_ada_probe_veto {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_ada_probe_veto {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct swdevt {
    _unused: [u8; 0],
}
pub type swapon_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut swdevt)>;
pub type swapoff_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut swdevt)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_swapon {
    pub ee: eventhandler_entry,
    pub eh_func: swapon_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_swapon() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_swapon>() , 40usize ,
               concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_swapon ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_swapon>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_swapon )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_swapon ) ) . ee as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_swapon ) , "::" , stringify ! ( ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_swapon ) ) . eh_func
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_swapon ) , "::" , stringify ! ( eh_func )
                ));
}
impl Clone for eventhandler_entry_swapon {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_swapon {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_swapoff {
    pub ee: eventhandler_entry,
    pub eh_func: swapoff_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_swapoff() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_swapoff>() , 40usize
               , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_swapoff ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_swapoff>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_swapoff )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_swapoff ) ) . ee as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_swapoff ) , "::" , stringify ! ( ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_swapoff ) ) . eh_func
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_swapoff ) , "::" , stringify ! ( eh_func )
                ));
}
impl Clone for eventhandler_entry_swapoff {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_swapoff {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum evhdev_detach {
    EVHDEV_DETACH_BEGIN = 0,
    EVHDEV_DETACH_COMPLETE = 1,
    EVHDEV_DETACH_FAILED = 2,
}
pub type device_attach_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: device_t)>;
pub type device_detach_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: device_t,
                                                arg3: evhdev_detach)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_device_attach {
    pub ee: eventhandler_entry,
    pub eh_func: device_attach_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_device_attach() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_device_attach>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_device_attach )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_device_attach>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_device_attach ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_device_attach ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_device_attach ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_device_attach ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_device_attach ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_device_attach {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_device_attach {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_device_detach {
    pub ee: eventhandler_entry,
    pub eh_func: device_detach_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_device_detach() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_device_detach>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_device_detach )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_device_detach>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_device_detach ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_device_detach ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_device_detach ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_device_detach ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_device_detach ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_device_detach {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_device_detach {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type pci_addr_t = u64;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct pcicfg_bridge {
    pub br_seclat: u8,
    pub br_subbus: u8,
    pub br_secbus: u8,
    pub br_pribus: u8,
    pub br_control: u16,
}
#[test]
fn bindgen_test_layout_pcicfg_bridge() {
    assert_eq!(::core::mem::size_of::<pcicfg_bridge>() , 6usize , concat ! (
               "Size of: " , stringify ! ( pcicfg_bridge ) ));
    assert_eq! (::core::mem::align_of::<pcicfg_bridge>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( pcicfg_bridge ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_bridge ) ) . br_seclat as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_bridge ) , "::"
                , stringify ! ( br_seclat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_bridge ) ) . br_subbus as * const
                _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_bridge ) , "::"
                , stringify ! ( br_subbus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_bridge ) ) . br_secbus as * const
                _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_bridge ) , "::"
                , stringify ! ( br_secbus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_bridge ) ) . br_pribus as * const
                _ as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_bridge ) , "::"
                , stringify ! ( br_pribus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_bridge ) ) . br_control as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_bridge ) , "::"
                , stringify ! ( br_control ) ));
}
impl Clone for pcicfg_bridge {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct pcicfg_pp {
    pub pp_cap: u16,
    pub pp_status: u8,
    pub pp_bse: u8,
    pub pp_data: u8,
}
#[test]
fn bindgen_test_layout_pcicfg_pp() {
    assert_eq!(::core::mem::size_of::<pcicfg_pp>() , 6usize , concat ! (
               "Size of: " , stringify ! ( pcicfg_pp ) ));
    assert_eq! (::core::mem::align_of::<pcicfg_pp>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( pcicfg_pp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_pp ) ) . pp_cap as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_pp ) , "::" ,
                stringify ! ( pp_cap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_pp ) ) . pp_status as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_pp ) , "::" ,
                stringify ! ( pp_status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_pp ) ) . pp_bse as * const _ as
                usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_pp ) , "::" ,
                stringify ! ( pp_bse ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_pp ) ) . pp_data as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_pp ) , "::" ,
                stringify ! ( pp_data ) ));
}
impl Clone for pcicfg_pp {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pci_map {
    pub pm_value: pci_addr_t,
    pub pm_size: pci_addr_t,
    pub pm_reg: u16,
    pub pm_link: pci_map__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pci_map__bindgen_ty_1 {
    pub stqe_next: *mut pci_map,
}
#[test]
fn bindgen_test_layout_pci_map__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<pci_map__bindgen_ty_1>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( pci_map__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<pci_map__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( pci_map__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_map__bindgen_ty_1 ) ) . stqe_next as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pci_map__bindgen_ty_1 )
                , "::" , stringify ! ( stqe_next ) ));
}
impl Clone for pci_map__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for pci_map__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_pci_map() {
    assert_eq!(::core::mem::size_of::<pci_map>() , 32usize , concat ! (
               "Size of: " , stringify ! ( pci_map ) ));
    assert_eq! (::core::mem::align_of::<pci_map>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pci_map ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_map ) ) . pm_value as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pci_map ) , "::" ,
                stringify ! ( pm_value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_map ) ) . pm_size as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pci_map ) , "::" ,
                stringify ! ( pm_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_map ) ) . pm_reg as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( pci_map ) , "::" ,
                stringify ! ( pm_reg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_map ) ) . pm_link as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( pci_map ) , "::" ,
                stringify ! ( pm_link ) ));
}
impl Clone for pci_map {
    fn clone(&self) -> Self { *self }
}
impl Default for pci_map {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct vpd_readonly {
    pub keyword: [::kernel::sys::raw::c_char; 2usize],
    pub value: *mut ::kernel::sys::raw::c_char,
    pub len: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_vpd_readonly() {
    assert_eq!(::core::mem::size_of::<vpd_readonly>() , 24usize , concat ! (
               "Size of: " , stringify ! ( vpd_readonly ) ));
    assert_eq! (::core::mem::align_of::<vpd_readonly>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( vpd_readonly ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vpd_readonly ) ) . keyword as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( vpd_readonly ) , "::" ,
                stringify ! ( keyword ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vpd_readonly ) ) . value as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( vpd_readonly ) , "::" ,
                stringify ! ( value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vpd_readonly ) ) . len as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( vpd_readonly ) , "::" ,
                stringify ! ( len ) ));
}
impl Clone for vpd_readonly {
    fn clone(&self) -> Self { *self }
}
impl Default for vpd_readonly {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct vpd_write {
    pub keyword: [::kernel::sys::raw::c_char; 2usize],
    pub value: *mut ::kernel::sys::raw::c_char,
    pub start: ::kernel::sys::raw::c_int,
    pub len: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_vpd_write() {
    assert_eq!(::core::mem::size_of::<vpd_write>() , 24usize , concat ! (
               "Size of: " , stringify ! ( vpd_write ) ));
    assert_eq! (::core::mem::align_of::<vpd_write>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( vpd_write ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vpd_write ) ) . keyword as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( vpd_write ) , "::" ,
                stringify ! ( keyword ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vpd_write ) ) . value as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( vpd_write ) , "::" ,
                stringify ! ( value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vpd_write ) ) . start as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( vpd_write ) , "::" ,
                stringify ! ( start ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vpd_write ) ) . len as * const _ as usize
                } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( vpd_write ) , "::" ,
                stringify ! ( len ) ));
}
impl Clone for vpd_write {
    fn clone(&self) -> Self { *self }
}
impl Default for vpd_write {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pcicfg_vpd {
    pub vpd_reg: u8,
    pub vpd_cached: ::kernel::sys::raw::c_char,
    pub vpd_ident: *mut ::kernel::sys::raw::c_char,
    pub vpd_rocnt: ::kernel::sys::raw::c_int,
    pub vpd_ros: *mut vpd_readonly,
    pub vpd_wcnt: ::kernel::sys::raw::c_int,
    pub vpd_w: *mut vpd_write,
}
#[test]
fn bindgen_test_layout_pcicfg_vpd() {
    assert_eq!(::core::mem::size_of::<pcicfg_vpd>() , 48usize , concat ! (
               "Size of: " , stringify ! ( pcicfg_vpd ) ));
    assert_eq! (::core::mem::align_of::<pcicfg_vpd>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pcicfg_vpd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_vpd ) ) . vpd_reg as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_vpd ) , "::" ,
                stringify ! ( vpd_reg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_vpd ) ) . vpd_cached as * const _
                as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_vpd ) , "::" ,
                stringify ! ( vpd_cached ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_vpd ) ) . vpd_ident as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_vpd ) , "::" ,
                stringify ! ( vpd_ident ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_vpd ) ) . vpd_rocnt as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_vpd ) , "::" ,
                stringify ! ( vpd_rocnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_vpd ) ) . vpd_ros as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_vpd ) , "::" ,
                stringify ! ( vpd_ros ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_vpd ) ) . vpd_wcnt as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_vpd ) , "::" ,
                stringify ! ( vpd_wcnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_vpd ) ) . vpd_w as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_vpd ) , "::" ,
                stringify ! ( vpd_w ) ));
}
impl Clone for pcicfg_vpd {
    fn clone(&self) -> Self { *self }
}
impl Default for pcicfg_vpd {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct pcicfg_msi {
    pub msi_ctrl: u16,
    pub msi_location: u8,
    pub msi_msgnum: u8,
    pub msi_alloc: ::kernel::sys::raw::c_int,
    pub msi_addr: u64,
    pub msi_data: u16,
    pub msi_handlers: u_int,
}
#[test]
fn bindgen_test_layout_pcicfg_msi() {
    assert_eq!(::core::mem::size_of::<pcicfg_msi>() , 24usize , concat ! (
               "Size of: " , stringify ! ( pcicfg_msi ) ));
    assert_eq! (::core::mem::align_of::<pcicfg_msi>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pcicfg_msi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_msi ) ) . msi_ctrl as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_msi ) , "::" ,
                stringify ! ( msi_ctrl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_msi ) ) . msi_location as * const
                _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_msi ) , "::" ,
                stringify ! ( msi_location ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_msi ) ) . msi_msgnum as * const _
                as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_msi ) , "::" ,
                stringify ! ( msi_msgnum ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_msi ) ) . msi_alloc as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_msi ) , "::" ,
                stringify ! ( msi_alloc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_msi ) ) . msi_addr as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_msi ) , "::" ,
                stringify ! ( msi_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_msi ) ) . msi_data as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_msi ) , "::" ,
                stringify ! ( msi_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_msi ) ) . msi_handlers as * const
                _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_msi ) , "::" ,
                stringify ! ( msi_handlers ) ));
}
impl Clone for pcicfg_msi {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct msix_vector {
    pub mv_address: u64,
    pub mv_data: u32,
    pub mv_irq: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_msix_vector() {
    assert_eq!(::core::mem::size_of::<msix_vector>() , 16usize , concat ! (
               "Size of: " , stringify ! ( msix_vector ) ));
    assert_eq! (::core::mem::align_of::<msix_vector>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( msix_vector ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msix_vector ) ) . mv_address as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( msix_vector ) , "::" ,
                stringify ! ( mv_address ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msix_vector ) ) . mv_data as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( msix_vector ) , "::" ,
                stringify ! ( mv_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msix_vector ) ) . mv_irq as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( msix_vector ) , "::" ,
                stringify ! ( mv_irq ) ));
}
impl Clone for msix_vector {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct msix_table_entry {
    pub mte_vector: u_int,
    pub mte_handlers: u_int,
}
#[test]
fn bindgen_test_layout_msix_table_entry() {
    assert_eq!(::core::mem::size_of::<msix_table_entry>() , 8usize , concat !
               ( "Size of: " , stringify ! ( msix_table_entry ) ));
    assert_eq! (::core::mem::align_of::<msix_table_entry>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( msix_table_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msix_table_entry ) ) . mte_vector as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( msix_table_entry ) ,
                "::" , stringify ! ( mte_vector ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msix_table_entry ) ) . mte_handlers as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( msix_table_entry ) ,
                "::" , stringify ! ( mte_handlers ) ));
}
impl Clone for msix_table_entry {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pcicfg_msix {
    pub msix_ctrl: u16,
    pub msix_msgnum: u16,
    pub msix_location: u8,
    pub msix_table_bar: u8,
    pub msix_pba_bar: u8,
    pub msix_table_offset: u32,
    pub msix_pba_offset: u32,
    pub msix_alloc: ::kernel::sys::raw::c_int,
    pub msix_table_len: ::kernel::sys::raw::c_int,
    pub msix_table: *mut msix_table_entry,
    pub msix_vectors: *mut msix_vector,
    pub msix_table_res: *mut resource,
    pub msix_pba_res: *mut resource,
}
#[test]
fn bindgen_test_layout_pcicfg_msix() {
    assert_eq!(::core::mem::size_of::<pcicfg_msix>() , 56usize , concat ! (
               "Size of: " , stringify ! ( pcicfg_msix ) ));
    assert_eq! (::core::mem::align_of::<pcicfg_msix>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pcicfg_msix ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_msix ) ) . msix_ctrl as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_msix ) , "::" ,
                stringify ! ( msix_ctrl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_msix ) ) . msix_msgnum as * const
                _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_msix ) , "::" ,
                stringify ! ( msix_msgnum ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_msix ) ) . msix_location as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_msix ) , "::" ,
                stringify ! ( msix_location ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_msix ) ) . msix_table_bar as *
                const _ as usize } , 5usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_msix ) , "::" ,
                stringify ! ( msix_table_bar ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_msix ) ) . msix_pba_bar as * const
                _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_msix ) , "::" ,
                stringify ! ( msix_pba_bar ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_msix ) ) . msix_table_offset as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_msix ) , "::" ,
                stringify ! ( msix_table_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_msix ) ) . msix_pba_offset as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_msix ) , "::" ,
                stringify ! ( msix_pba_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_msix ) ) . msix_alloc as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_msix ) , "::" ,
                stringify ! ( msix_alloc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_msix ) ) . msix_table_len as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_msix ) , "::" ,
                stringify ! ( msix_table_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_msix ) ) . msix_table as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_msix ) , "::" ,
                stringify ! ( msix_table ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_msix ) ) . msix_vectors as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_msix ) , "::" ,
                stringify ! ( msix_vectors ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_msix ) ) . msix_table_res as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_msix ) , "::" ,
                stringify ! ( msix_table_res ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_msix ) ) . msix_pba_res as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_msix ) , "::" ,
                stringify ! ( msix_pba_res ) ));
}
impl Clone for pcicfg_msix {
    fn clone(&self) -> Self { *self }
}
impl Default for pcicfg_msix {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct pcicfg_ht {
    pub ht_slave: u8,
    pub ht_msimap: u8,
    pub ht_msictrl: u16,
    pub ht_msiaddr: u64,
}
#[test]
fn bindgen_test_layout_pcicfg_ht() {
    assert_eq!(::core::mem::size_of::<pcicfg_ht>() , 16usize , concat ! (
               "Size of: " , stringify ! ( pcicfg_ht ) ));
    assert_eq! (::core::mem::align_of::<pcicfg_ht>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pcicfg_ht ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_ht ) ) . ht_slave as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_ht ) , "::" ,
                stringify ! ( ht_slave ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_ht ) ) . ht_msimap as * const _ as
                usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_ht ) , "::" ,
                stringify ! ( ht_msimap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_ht ) ) . ht_msictrl as * const _
                as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_ht ) , "::" ,
                stringify ! ( ht_msictrl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_ht ) ) . ht_msiaddr as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_ht ) , "::" ,
                stringify ! ( ht_msiaddr ) ));
}
impl Clone for pcicfg_ht {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct pcicfg_pcie {
    pub pcie_location: u8,
    pub pcie_type: u8,
    pub pcie_flags: u16,
    pub pcie_device_ctl: u16,
    pub pcie_link_ctl: u16,
    pub pcie_slot_ctl: u16,
    pub pcie_root_ctl: u16,
    pub pcie_device_ctl2: u16,
    pub pcie_link_ctl2: u16,
    pub pcie_slot_ctl2: u16,
}
#[test]
fn bindgen_test_layout_pcicfg_pcie() {
    assert_eq!(::core::mem::size_of::<pcicfg_pcie>() , 18usize , concat ! (
               "Size of: " , stringify ! ( pcicfg_pcie ) ));
    assert_eq! (::core::mem::align_of::<pcicfg_pcie>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( pcicfg_pcie ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_pcie ) ) . pcie_location as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_pcie ) , "::" ,
                stringify ! ( pcie_location ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_pcie ) ) . pcie_type as * const _
                as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_pcie ) , "::" ,
                stringify ! ( pcie_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_pcie ) ) . pcie_flags as * const _
                as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_pcie ) , "::" ,
                stringify ! ( pcie_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_pcie ) ) . pcie_device_ctl as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_pcie ) , "::" ,
                stringify ! ( pcie_device_ctl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_pcie ) ) . pcie_link_ctl as *
                const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_pcie ) , "::" ,
                stringify ! ( pcie_link_ctl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_pcie ) ) . pcie_slot_ctl as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_pcie ) , "::" ,
                stringify ! ( pcie_slot_ctl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_pcie ) ) . pcie_root_ctl as *
                const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_pcie ) , "::" ,
                stringify ! ( pcie_root_ctl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_pcie ) ) . pcie_device_ctl2 as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_pcie ) , "::" ,
                stringify ! ( pcie_device_ctl2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_pcie ) ) . pcie_link_ctl2 as *
                const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_pcie ) , "::" ,
                stringify ! ( pcie_link_ctl2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_pcie ) ) . pcie_slot_ctl2 as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_pcie ) , "::" ,
                stringify ! ( pcie_slot_ctl2 ) ));
}
impl Clone for pcicfg_pcie {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct pcicfg_pcix {
    pub pcix_command: u16,
    pub pcix_location: u8,
}
#[test]
fn bindgen_test_layout_pcicfg_pcix() {
    assert_eq!(::core::mem::size_of::<pcicfg_pcix>() , 4usize , concat ! (
               "Size of: " , stringify ! ( pcicfg_pcix ) ));
    assert_eq! (::core::mem::align_of::<pcicfg_pcix>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( pcicfg_pcix ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_pcix ) ) . pcix_command as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_pcix ) , "::" ,
                stringify ! ( pcix_command ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_pcix ) ) . pcix_location as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_pcix ) , "::" ,
                stringify ! ( pcix_location ) ));
}
impl Clone for pcicfg_pcix {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct pcicfg_vf {
    pub index: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_pcicfg_vf() {
    assert_eq!(::core::mem::size_of::<pcicfg_vf>() , 4usize , concat ! (
               "Size of: " , stringify ! ( pcicfg_vf ) ));
    assert_eq! (::core::mem::align_of::<pcicfg_vf>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( pcicfg_vf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_vf ) ) . index as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_vf ) , "::" ,
                stringify ! ( index ) ));
}
impl Clone for pcicfg_vf {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pci_ea_entry {
    pub eae_bei: ::kernel::sys::raw::c_int,
    pub eae_flags: u32,
    pub eae_base: u64,
    pub eae_max_offset: u64,
    pub eae_cfg_offset: u32,
    pub eae_link: pci_ea_entry__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pci_ea_entry__bindgen_ty_1 {
    pub stqe_next: *mut pci_ea_entry,
}
#[test]
fn bindgen_test_layout_pci_ea_entry__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<pci_ea_entry__bindgen_ty_1>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( pci_ea_entry__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<pci_ea_entry__bindgen_ty_1>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( pci_ea_entry__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_ea_entry__bindgen_ty_1 ) ) .
                stqe_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pci_ea_entry__bindgen_ty_1 ) , "::" , stringify ! ( stqe_next
                ) ));
}
impl Clone for pci_ea_entry__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for pci_ea_entry__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_pci_ea_entry() {
    assert_eq!(::core::mem::size_of::<pci_ea_entry>() , 40usize , concat ! (
               "Size of: " , stringify ! ( pci_ea_entry ) ));
    assert_eq! (::core::mem::align_of::<pci_ea_entry>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pci_ea_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_ea_entry ) ) . eae_bei as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pci_ea_entry ) , "::" ,
                stringify ! ( eae_bei ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_ea_entry ) ) . eae_flags as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( pci_ea_entry ) , "::" ,
                stringify ! ( eae_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_ea_entry ) ) . eae_base as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pci_ea_entry ) , "::" ,
                stringify ! ( eae_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_ea_entry ) ) . eae_max_offset as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( pci_ea_entry ) , "::" ,
                stringify ! ( eae_max_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_ea_entry ) ) . eae_cfg_offset as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( pci_ea_entry ) , "::" ,
                stringify ! ( eae_cfg_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_ea_entry ) ) . eae_link as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( pci_ea_entry ) , "::" ,
                stringify ! ( eae_link ) ));
}
impl Clone for pci_ea_entry {
    fn clone(&self) -> Self { *self }
}
impl Default for pci_ea_entry {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pcicfg_ea {
    pub ea_location: ::kernel::sys::raw::c_int,
    pub ea_entries: pcicfg_ea__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pcicfg_ea__bindgen_ty_1 {
    pub stqh_first: *mut pci_ea_entry,
    pub stqh_last: *mut *mut pci_ea_entry,
}
#[test]
fn bindgen_test_layout_pcicfg_ea__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<pcicfg_ea__bindgen_ty_1>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( pcicfg_ea__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<pcicfg_ea__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( pcicfg_ea__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_ea__bindgen_ty_1 ) ) . stqh_first
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_ea__bindgen_ty_1
                ) , "::" , stringify ! ( stqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_ea__bindgen_ty_1 ) ) . stqh_last
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_ea__bindgen_ty_1
                ) , "::" , stringify ! ( stqh_last ) ));
}
impl Clone for pcicfg_ea__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for pcicfg_ea__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_pcicfg_ea() {
    assert_eq!(::core::mem::size_of::<pcicfg_ea>() , 24usize , concat ! (
               "Size of: " , stringify ! ( pcicfg_ea ) ));
    assert_eq! (::core::mem::align_of::<pcicfg_ea>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pcicfg_ea ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_ea ) ) . ea_location as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_ea ) , "::" ,
                stringify ! ( ea_location ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_ea ) ) . ea_entries as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_ea ) , "::" ,
                stringify ! ( ea_entries ) ));
}
impl Clone for pcicfg_ea {
    fn clone(&self) -> Self { *self }
}
impl Default for pcicfg_ea {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pcicfg {
    pub dev: device_t,
    pub maps: pcicfg__bindgen_ty_1,
    pub subvendor: u16,
    pub subdevice: u16,
    pub vendor: u16,
    pub device: u16,
    pub cmdreg: u16,
    pub statreg: u16,
    pub baseclass: u8,
    pub subclass: u8,
    pub progif: u8,
    pub revid: u8,
    pub hdrtype: u8,
    pub cachelnsz: u8,
    pub intpin: u8,
    pub intline: u8,
    pub mingnt: u8,
    pub maxlat: u8,
    pub lattimer: u8,
    pub mfdev: u8,
    pub nummaps: u8,
    pub domain: u32,
    pub bus: u8,
    pub slot: u8,
    pub func: u8,
    pub flags: u32,
    pub bridge: pcicfg_bridge,
    pub pp: pcicfg_pp,
    pub vpd: pcicfg_vpd,
    pub msi: pcicfg_msi,
    pub msix: pcicfg_msix,
    pub ht: pcicfg_ht,
    pub pcie: pcicfg_pcie,
    pub pcix: pcicfg_pcix,
    pub iov: *mut pcicfg_iov,
    pub vf: pcicfg_vf,
    pub ea: pcicfg_ea,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pcicfg__bindgen_ty_1 {
    pub stqh_first: *mut pci_map,
    pub stqh_last: *mut *mut pci_map,
}
#[test]
fn bindgen_test_layout_pcicfg__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<pcicfg__bindgen_ty_1>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( pcicfg__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<pcicfg__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( pcicfg__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg__bindgen_ty_1 ) ) . stqh_first as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg__bindgen_ty_1 )
                , "::" , stringify ! ( stqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg__bindgen_ty_1 ) ) . stqh_last as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg__bindgen_ty_1 )
                , "::" , stringify ! ( stqh_last ) ));
}
impl Clone for pcicfg__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for pcicfg__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_pcicfg() {
    assert_eq!(::core::mem::size_of::<pcicfg>() , 288usize , concat ! (
               "Size of: " , stringify ! ( pcicfg ) ));
    assert_eq! (::core::mem::align_of::<pcicfg>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pcicfg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . dev as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( dev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . maps as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( maps ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . subvendor as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( subvendor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . subdevice as * const _ as
                usize } , 26usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( subdevice ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . vendor as * const _ as usize
                } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( vendor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . device as * const _ as usize
                } , 30usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( device ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . cmdreg as * const _ as usize
                } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( cmdreg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . statreg as * const _ as
                usize } , 34usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( statreg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . baseclass as * const _ as
                usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( baseclass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . subclass as * const _ as
                usize } , 37usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( subclass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . progif as * const _ as usize
                } , 38usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( progif ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . revid as * const _ as usize
                } , 39usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( revid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . hdrtype as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( hdrtype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . cachelnsz as * const _ as
                usize } , 41usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( cachelnsz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . intpin as * const _ as usize
                } , 42usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( intpin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . intline as * const _ as
                usize } , 43usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( intline ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . mingnt as * const _ as usize
                } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( mingnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . maxlat as * const _ as usize
                } , 45usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( maxlat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . lattimer as * const _ as
                usize } , 46usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( lattimer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . mfdev as * const _ as usize
                } , 47usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( mfdev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . nummaps as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( nummaps ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . domain as * const _ as usize
                } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( domain ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . bus as * const _ as usize }
                , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( bus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . slot as * const _ as usize }
                , 57usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( slot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . func as * const _ as usize }
                , 58usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . flags as * const _ as usize
                } , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . bridge as * const _ as usize
                } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( bridge ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . pp as * const _ as usize } ,
                70usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( pp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . vpd as * const _ as usize }
                , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( vpd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . msi as * const _ as usize }
                , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( msi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . msix as * const _ as usize }
                , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( msix ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . ht as * const _ as usize } ,
                208usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( ht ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . pcie as * const _ as usize }
                , 224usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( pcie ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . pcix as * const _ as usize }
                , 242usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( pcix ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . iov as * const _ as usize }
                , 248usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( iov ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . vf as * const _ as usize } ,
                256usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( vf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . ea as * const _ as usize } ,
                264usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( ea ) ));
}
impl Clone for pcicfg {
    fn clone(&self) -> Self { *self }
}
impl Default for pcicfg {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type pcicfgregs = pcicfg;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct pcih1cfgregs {
    pub pmembase: pci_addr_t,
    pub pmemlimit: pci_addr_t,
    pub membase: u32,
    pub memlimit: u32,
    pub iobase: u32,
    pub iolimit: u32,
    pub secstat: u16,
    pub bridgectl: u16,
    pub seclat: u8,
}
#[test]
fn bindgen_test_layout_pcih1cfgregs() {
    assert_eq!(::core::mem::size_of::<pcih1cfgregs>() , 40usize , concat ! (
               "Size of: " , stringify ! ( pcih1cfgregs ) ));
    assert_eq! (::core::mem::align_of::<pcih1cfgregs>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pcih1cfgregs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcih1cfgregs ) ) . pmembase as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pcih1cfgregs ) , "::" ,
                stringify ! ( pmembase ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcih1cfgregs ) ) . pmemlimit as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pcih1cfgregs ) , "::" ,
                stringify ! ( pmemlimit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcih1cfgregs ) ) . membase as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( pcih1cfgregs ) , "::" ,
                stringify ! ( membase ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcih1cfgregs ) ) . memlimit as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( pcih1cfgregs ) , "::" ,
                stringify ! ( memlimit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcih1cfgregs ) ) . iobase as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( pcih1cfgregs ) , "::" ,
                stringify ! ( iobase ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcih1cfgregs ) ) . iolimit as * const _
                as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( pcih1cfgregs ) , "::" ,
                stringify ! ( iolimit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcih1cfgregs ) ) . secstat as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( pcih1cfgregs ) , "::" ,
                stringify ! ( secstat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcih1cfgregs ) ) . bridgectl as * const _
                as usize } , 34usize , concat ! (
                "Alignment of field: " , stringify ! ( pcih1cfgregs ) , "::" ,
                stringify ! ( bridgectl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcih1cfgregs ) ) . seclat as * const _ as
                usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( pcih1cfgregs ) , "::" ,
                stringify ! ( seclat ) ));
}
impl Clone for pcih1cfgregs {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct pcih2cfgregs {
    pub membase0: u32,
    pub memlimit0: u32,
    pub membase1: u32,
    pub memlimit1: u32,
    pub iobase0: u32,
    pub iolimit0: u32,
    pub iobase1: u32,
    pub iolimit1: u32,
    pub pccardif: u32,
    pub secstat: u16,
    pub bridgectl: u16,
    pub seclat: u8,
}
#[test]
fn bindgen_test_layout_pcih2cfgregs() {
    assert_eq!(::core::mem::size_of::<pcih2cfgregs>() , 44usize , concat ! (
               "Size of: " , stringify ! ( pcih2cfgregs ) ));
    assert_eq! (::core::mem::align_of::<pcih2cfgregs>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( pcih2cfgregs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcih2cfgregs ) ) . membase0 as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pcih2cfgregs ) , "::" ,
                stringify ! ( membase0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcih2cfgregs ) ) . memlimit0 as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( pcih2cfgregs ) , "::" ,
                stringify ! ( memlimit0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcih2cfgregs ) ) . membase1 as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pcih2cfgregs ) , "::" ,
                stringify ! ( membase1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcih2cfgregs ) ) . memlimit1 as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( pcih2cfgregs ) , "::" ,
                stringify ! ( memlimit1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcih2cfgregs ) ) . iobase0 as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( pcih2cfgregs ) , "::" ,
                stringify ! ( iobase0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcih2cfgregs ) ) . iolimit0 as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( pcih2cfgregs ) , "::" ,
                stringify ! ( iolimit0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcih2cfgregs ) ) . iobase1 as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( pcih2cfgregs ) , "::" ,
                stringify ! ( iobase1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcih2cfgregs ) ) . iolimit1 as * const _
                as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( pcih2cfgregs ) , "::" ,
                stringify ! ( iolimit1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcih2cfgregs ) ) . pccardif as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( pcih2cfgregs ) , "::" ,
                stringify ! ( pccardif ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcih2cfgregs ) ) . secstat as * const _
                as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( pcih2cfgregs ) , "::" ,
                stringify ! ( secstat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcih2cfgregs ) ) . bridgectl as * const _
                as usize } , 38usize , concat ! (
                "Alignment of field: " , stringify ! ( pcih2cfgregs ) , "::" ,
                stringify ! ( bridgectl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcih2cfgregs ) ) . seclat as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( pcih2cfgregs ) , "::" ,
                stringify ! ( seclat ) ));
}
impl Clone for pcih2cfgregs {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "pci_numdevs"]
    pub static mut pci_numdevs: u32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cdevsw {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "pcicdev"]
    pub static mut pcicdev: cdevsw;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct devlist {
    pub stqh_first: *mut pci_devinfo,
    pub stqh_last: *mut *mut pci_devinfo,
}
#[test]
fn bindgen_test_layout_devlist() {
    assert_eq!(::core::mem::size_of::<devlist>() , 16usize , concat ! (
               "Size of: " , stringify ! ( devlist ) ));
    assert_eq! (::core::mem::align_of::<devlist>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( devlist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const devlist ) ) . stqh_first as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( devlist ) , "::" ,
                stringify ! ( stqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const devlist ) ) . stqh_last as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( devlist ) , "::" ,
                stringify ! ( stqh_last ) ));
}
impl Clone for devlist {
    fn clone(&self) -> Self { *self }
}
impl Default for devlist {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    #[link_name = "pci_devq"]
    pub static mut pci_devq: devlist;
}
extern "C" {
    #[link_name = "pci_generation"]
    pub static mut pci_generation: u32;
}
extern "C" {
    pub fn pci_find_bar(dev: device_t, reg: ::kernel::sys::raw::c_int)
     -> *mut pci_map;
}
extern "C" {
    pub fn pci_bar_enabled(dev: device_t, pm: *mut pci_map)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn pci_fetch_vpd_list(dev: device_t) -> *mut pcicfg_vpd;
}
extern "C" {
    pub fn vga_pci_is_boot_display(dev: device_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn vga_pci_map_bios(dev: device_t, size: *mut usize)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn vga_pci_unmap_bios(dev: device_t,
                              bios: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn vga_pci_repost(dev: device_t) -> ::kernel::sys::raw::c_int;
}
/// Global eventhandlers invoked when PCI devices are added or removed
/// from the system.
pub type pci_event_fn =
    ::core::option::Option<unsafe extern "C" fn(arg:
                                                    *mut ::kernel::sys::raw::c_void,
                                                dev: device_t)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_pci_add_device {
    pub ee: eventhandler_entry,
    pub eh_func: pci_event_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_pci_add_device() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_pci_add_device>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_pci_add_device )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_pci_add_device>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_pci_add_device ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_pci_add_device ) ) .
                ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_pci_add_device ) , "::" , stringify ! ( ee
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_pci_add_device ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_pci_add_device ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_pci_add_device {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_pci_add_device {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_pci_delete_device {
    pub ee: eventhandler_entry,
    pub eh_func: pci_event_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_pci_delete_device() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_pci_delete_device>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_pci_delete_device ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_pci_delete_device>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_pci_delete_device ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_pci_delete_device ) )
                . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_pci_delete_device ) , "::" , stringify ! (
                ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_pci_delete_device ) )
                . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_pci_delete_device ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_pci_delete_device {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_pci_delete_device {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __va_list_tag {
    pub gp_offset: ::kernel::sys::raw::c_uint,
    pub fp_offset: ::kernel::sys::raw::c_uint,
    pub overflow_arg_area: *mut ::kernel::sys::raw::c_void,
    pub reg_save_area: *mut ::kernel::sys::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(::core::mem::size_of::<__va_list_tag>() , 24usize , concat ! (
               "Size of: " , stringify ! ( __va_list_tag ) ));
    assert_eq! (::core::mem::align_of::<__va_list_tag>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __va_list_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . gp_offset as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( gp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . fp_offset as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( fp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . overflow_arg_area as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( overflow_arg_area ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . reg_save_area as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( reg_save_area ) ));
}
impl Clone for __va_list_tag {
    fn clone(&self) -> Self { *self }
}
impl Default for __va_list_tag {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct witness {
    pub _address: u8,
}
impl Clone for witness {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct pmap {
    pub _address: u8,
}
impl Clone for pmap {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct amd64tss {
    pub _address: u8,
}
impl Clone for amd64tss {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct user_segment_descriptor {
    pub _address: u8,
}
impl Clone for user_segment_descriptor {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct system_segment_descriptor {
    pub _address: u8,
}
impl Clone for system_segment_descriptor {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct resource {
    pub _address: u8,
}
impl Clone for resource {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct pcicfg_iov {
    pub _address: u8,
}
impl Clone for pcicfg_iov {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct pci_devinfo {
    pub _address: u8,
}
impl Clone for pci_devinfo {
    fn clone(&self) -> Self { *self }
}
