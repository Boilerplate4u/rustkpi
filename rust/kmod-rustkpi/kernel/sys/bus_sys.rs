/* automatically generated by rust-bindgen */

pub const __GNUCLIKE_ASM: ::kernel::sys::raw::c_uint = 3;
pub const __GNUCLIKE___TYPEOF: ::kernel::sys::raw::c_uint = 1;
pub const __GNUCLIKE___OFFSETOF: ::kernel::sys::raw::c_uint = 1;
pub const __GNUCLIKE___SECTION: ::kernel::sys::raw::c_uint = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: ::kernel::sys::raw::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: ::kernel::sys::raw::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: ::kernel::sys::raw::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: ::kernel::sys::raw::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: ::kernel::sys::raw::c_uint = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: ::kernel::sys::raw::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: ::kernel::sys::raw::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: ::kernel::sys::raw::c_uint = 1;
pub const __CC_SUPPORTS_INLINE: ::kernel::sys::raw::c_uint = 1;
pub const __CC_SUPPORTS___INLINE: ::kernel::sys::raw::c_uint = 1;
pub const __CC_SUPPORTS___INLINE__: ::kernel::sys::raw::c_uint = 1;
pub const __CC_SUPPORTS___FUNC__: ::kernel::sys::raw::c_uint = 1;
pub const __CC_SUPPORTS_WARNING: ::kernel::sys::raw::c_uint = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: ::kernel::sys::raw::c_uint = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: ::kernel::sys::raw::c_uint = 1;
pub const __POSIX_VISIBLE: ::kernel::sys::raw::c_uint = 200809;
pub const __XSI_VISIBLE: ::kernel::sys::raw::c_uint = 700;
pub const __BSD_VISIBLE: ::kernel::sys::raw::c_uint = 1;
pub const __ISO_C_VISIBLE: ::kernel::sys::raw::c_uint = 2011;
pub const __EXT1_VISIBLE: ::kernel::sys::raw::c_uint = 1;
pub const __CHAR_BIT: ::kernel::sys::raw::c_uint = 8;
pub const __SCHAR_MAX: ::kernel::sys::raw::c_uint = 127;
pub const __SCHAR_MIN: ::kernel::sys::raw::c_int = -128;
pub const __UCHAR_MAX: ::kernel::sys::raw::c_uint = 255;
pub const __USHRT_MAX: ::kernel::sys::raw::c_uint = 65535;
pub const __SHRT_MAX: ::kernel::sys::raw::c_uint = 32767;
pub const __SHRT_MIN: ::kernel::sys::raw::c_int = -32768;
pub const __UINT_MAX: ::kernel::sys::raw::c_uint = 4294967295;
pub const __INT_MAX: ::kernel::sys::raw::c_uint = 2147483647;
pub const __INT_MIN: ::kernel::sys::raw::c_int = -2147483648;
pub const __ULONG_MAX: ::kernel::sys::raw::c_int = -1;
pub const __LONG_MAX: ::kernel::sys::raw::c_ulonglong = 9223372036854775807;
pub const __LONG_MIN: ::kernel::sys::raw::c_longlong = -9223372036854775808;
pub const __ULLONG_MAX: ::kernel::sys::raw::c_int = -1;
pub const __LLONG_MAX: ::kernel::sys::raw::c_ulonglong = 9223372036854775807;
pub const __LLONG_MIN: ::kernel::sys::raw::c_longlong = -9223372036854775808;
pub const __SSIZE_MAX: ::kernel::sys::raw::c_ulonglong = 9223372036854775807;
pub const __SIZE_T_MAX: ::kernel::sys::raw::c_int = -1;
pub const __OFF_MAX: ::kernel::sys::raw::c_ulonglong = 9223372036854775807;
pub const __OFF_MIN: ::kernel::sys::raw::c_longlong = -9223372036854775808;
pub const __UQUAD_MAX: ::kernel::sys::raw::c_int = -1;
pub const __QUAD_MAX: ::kernel::sys::raw::c_ulonglong = 9223372036854775807;
pub const __QUAD_MIN: ::kernel::sys::raw::c_longlong = -9223372036854775808;
pub const __LONG_BIT: ::kernel::sys::raw::c_uint = 64;
pub const __WORD_BIT: ::kernel::sys::raw::c_uint = 32;
pub const __MINSIGSTKSZ: ::kernel::sys::raw::c_uint = 2048;
pub const __WCHAR_MIN: ::kernel::sys::raw::c_int = -2147483648;
pub const __WCHAR_MAX: ::kernel::sys::raw::c_uint = 2147483647;
pub const _QUAD_HIGHWORD: ::kernel::sys::raw::c_uint = 1;
pub const _QUAD_LOWWORD: ::kernel::sys::raw::c_uint = 0;
pub const _LITTLE_ENDIAN: ::kernel::sys::raw::c_uint = 1234;
pub const _BIG_ENDIAN: ::kernel::sys::raw::c_uint = 4321;
pub const _PDP_ENDIAN: ::kernel::sys::raw::c_uint = 3412;
pub const _BYTE_ORDER: ::kernel::sys::raw::c_uint = 1234;
pub const LITTLE_ENDIAN: ::kernel::sys::raw::c_uint = 1234;
pub const BIG_ENDIAN: ::kernel::sys::raw::c_uint = 4321;
pub const PDP_ENDIAN: ::kernel::sys::raw::c_uint = 3412;
pub const BYTE_ORDER: ::kernel::sys::raw::c_uint = 1234;
pub const __bool_true_false_are_defined: ::kernel::sys::raw::c_uint = 1;
pub const false_: ::kernel::sys::raw::c_uint = 0;
pub const true_: ::kernel::sys::raw::c_uint = 1;
pub const _SIG_WORDS: ::kernel::sys::raw::c_uint = 4;
pub const _SIG_MAXSIG: ::kernel::sys::raw::c_uint = 128;
pub const FD_SETSIZE: ::kernel::sys::raw::c_uint = 1024;
pub const IOCPARM_SHIFT: ::kernel::sys::raw::c_uint = 13;
pub const IOCPARM_MASK: ::kernel::sys::raw::c_uint = 8191;
pub const IOCPARM_MAX: ::kernel::sys::raw::c_uint = 8192;
pub const IOC_VOID: ::kernel::sys::raw::c_uint = 536870912;
pub const IOC_OUT: ::kernel::sys::raw::c_uint = 1073741824;
pub const IOC_IN: ::kernel::sys::raw::c_uint = 2147483648;
pub const IOC_INOUT: ::kernel::sys::raw::c_uint = 3221225472;
pub const IOC_DIRMASK: ::kernel::sys::raw::c_uint = 3758096384;
pub const BUS_USER_VERSION: ::kernel::sys::raw::c_uint = 1;
pub const DF_ENABLED: ::kernel::sys::raw::c_uint = 1;
pub const DF_FIXEDCLASS: ::kernel::sys::raw::c_uint = 2;
pub const DF_WILDCARD: ::kernel::sys::raw::c_uint = 4;
pub const DF_DESCMALLOCED: ::kernel::sys::raw::c_uint = 8;
pub const DF_QUIET: ::kernel::sys::raw::c_uint = 16;
pub const DF_DONENOMATCH: ::kernel::sys::raw::c_uint = 32;
pub const DF_EXTERNALSOFTC: ::kernel::sys::raw::c_uint = 64;
pub const DF_REBID: ::kernel::sys::raw::c_uint = 128;
pub const DF_SUSPENDED: ::kernel::sys::raw::c_uint = 256;
pub const DF_QUIET_CHILDREN: ::kernel::sys::raw::c_uint = 512;
pub const DEVF_FORCE_DETACH: ::kernel::sys::raw::c_uint = 1;
pub const DEVF_SET_DRIVER_DETACH: ::kernel::sys::raw::c_uint = 1;
pub const DEVF_CLEAR_DRIVER_DETACH: ::kernel::sys::raw::c_uint = 1;
pub const DEVF_FORCE_DELETE: ::kernel::sys::raw::c_uint = 1;
pub const KTR_GEN: ::kernel::sys::raw::c_uint = 1;
pub const KTR_NET: ::kernel::sys::raw::c_uint = 2;
pub const KTR_DEV: ::kernel::sys::raw::c_uint = 4;
pub const KTR_LOCK: ::kernel::sys::raw::c_uint = 8;
pub const KTR_SMP: ::kernel::sys::raw::c_uint = 16;
pub const KTR_SUBSYS: ::kernel::sys::raw::c_uint = 32;
pub const KTR_PMAP: ::kernel::sys::raw::c_uint = 64;
pub const KTR_MALLOC: ::kernel::sys::raw::c_uint = 128;
pub const KTR_TRAP: ::kernel::sys::raw::c_uint = 256;
pub const KTR_INTR: ::kernel::sys::raw::c_uint = 512;
pub const KTR_SIG: ::kernel::sys::raw::c_uint = 1024;
pub const KTR_SPARE2: ::kernel::sys::raw::c_uint = 2048;
pub const KTR_PROC: ::kernel::sys::raw::c_uint = 4096;
pub const KTR_SYSC: ::kernel::sys::raw::c_uint = 8192;
pub const KTR_INIT: ::kernel::sys::raw::c_uint = 16384;
pub const KTR_SPARE3: ::kernel::sys::raw::c_uint = 32768;
pub const KTR_SPARE4: ::kernel::sys::raw::c_uint = 65536;
pub const KTR_EVH: ::kernel::sys::raw::c_uint = 131072;
pub const KTR_VFS: ::kernel::sys::raw::c_uint = 262144;
pub const KTR_VOP: ::kernel::sys::raw::c_uint = 524288;
pub const KTR_VM: ::kernel::sys::raw::c_uint = 1048576;
pub const KTR_INET: ::kernel::sys::raw::c_uint = 2097152;
pub const KTR_RUNQ: ::kernel::sys::raw::c_uint = 4194304;
pub const KTR_SPARE5: ::kernel::sys::raw::c_uint = 8388608;
pub const KTR_UMA: ::kernel::sys::raw::c_uint = 16777216;
pub const KTR_CALLOUT: ::kernel::sys::raw::c_uint = 33554432;
pub const KTR_GEOM: ::kernel::sys::raw::c_uint = 67108864;
pub const KTR_BUSDMA: ::kernel::sys::raw::c_uint = 134217728;
pub const KTR_INET6: ::kernel::sys::raw::c_uint = 268435456;
pub const KTR_SCHED: ::kernel::sys::raw::c_uint = 536870912;
pub const KTR_BUF: ::kernel::sys::raw::c_uint = 1073741824;
pub const KTR_PTRACE: ::kernel::sys::raw::c_uint = 2147483648;
pub const KTR_ALL: ::kernel::sys::raw::c_uint = 4294967295;
pub const KTR_COMPILE: ::kernel::sys::raw::c_uint = 0;
pub const LC_SLEEPLOCK: ::kernel::sys::raw::c_uint = 1;
pub const LC_SPINLOCK: ::kernel::sys::raw::c_uint = 2;
pub const LC_SLEEPABLE: ::kernel::sys::raw::c_uint = 4;
pub const LC_RECURSABLE: ::kernel::sys::raw::c_uint = 8;
pub const LC_UPGRADABLE: ::kernel::sys::raw::c_uint = 16;
pub const LO_CLASSFLAGS: ::kernel::sys::raw::c_uint = 65535;
pub const LO_INITIALIZED: ::kernel::sys::raw::c_uint = 65536;
pub const LO_WITNESS: ::kernel::sys::raw::c_uint = 131072;
pub const LO_QUIET: ::kernel::sys::raw::c_uint = 262144;
pub const LO_RECURSABLE: ::kernel::sys::raw::c_uint = 524288;
pub const LO_SLEEPABLE: ::kernel::sys::raw::c_uint = 1048576;
pub const LO_UPGRADABLE: ::kernel::sys::raw::c_uint = 2097152;
pub const LO_DUPOK: ::kernel::sys::raw::c_uint = 4194304;
pub const LO_IS_VNODE: ::kernel::sys::raw::c_uint = 8388608;
pub const LO_CLASSMASK: ::kernel::sys::raw::c_uint = 251658240;
pub const LO_NOPROFILE: ::kernel::sys::raw::c_uint = 268435456;
pub const LO_NEW: ::kernel::sys::raw::c_uint = 536870912;
pub const LO_CLASSSHIFT: ::kernel::sys::raw::c_uint = 24;
pub const LOCK_CLASS_MAX: ::kernel::sys::raw::c_uint = 15;
pub const LOP_NEWORDER: ::kernel::sys::raw::c_uint = 1;
pub const LOP_QUIET: ::kernel::sys::raw::c_uint = 2;
pub const LOP_TRYLOCK: ::kernel::sys::raw::c_uint = 4;
pub const LOP_EXCLUSIVE: ::kernel::sys::raw::c_uint = 8;
pub const LOP_DUPOK: ::kernel::sys::raw::c_uint = 16;
pub const LA_MASKASSERT: ::kernel::sys::raw::c_uint = 255;
pub const LA_UNLOCKED: ::kernel::sys::raw::c_uint = 0;
pub const LA_LOCKED: ::kernel::sys::raw::c_uint = 1;
pub const LA_SLOCKED: ::kernel::sys::raw::c_uint = 2;
pub const LA_XLOCKED: ::kernel::sys::raw::c_uint = 4;
pub const LA_RECURSED: ::kernel::sys::raw::c_uint = 8;
pub const LA_NOTRECURSED: ::kernel::sys::raw::c_uint = 16;
pub const LOCK_DEBUG: ::kernel::sys::raw::c_uint = 1;
pub const KTR_VERSION: ::kernel::sys::raw::c_uint = 2;
pub const KTR_PARMS: ::kernel::sys::raw::c_uint = 6;
pub const BSD: ::kernel::sys::raw::c_uint = 199506;
pub const BSD4_3: ::kernel::sys::raw::c_uint = 1;
pub const BSD4_4: ::kernel::sys::raw::c_uint = 1;
pub const __FreeBSD_version: ::kernel::sys::raw::c_uint = 1200064;
pub const P_OSREL_SIGWAIT: ::kernel::sys::raw::c_uint = 700000;
pub const P_OSREL_SIGSEGV: ::kernel::sys::raw::c_uint = 700004;
pub const P_OSREL_MAP_ANON: ::kernel::sys::raw::c_uint = 800104;
pub const P_OSREL_MAP_FSTRICT: ::kernel::sys::raw::c_uint = 1100036;
pub const P_OSREL_SHUTDOWN_ENOTCONN: ::kernel::sys::raw::c_uint = 1100077;
pub const P_OSREL_MAP_GUARD: ::kernel::sys::raw::c_uint = 1200035;
pub const P_OSREL_WRFSBASE: ::kernel::sys::raw::c_uint = 1200041;
pub const P_OSREL_CK_CYLGRP: ::kernel::sys::raw::c_uint = 1200046;
pub const P_OSREL_VMTOTAL64: ::kernel::sys::raw::c_uint = 1200054;
pub const ARG_MAX: ::kernel::sys::raw::c_uint = 262144;
pub const CHILD_MAX: ::kernel::sys::raw::c_uint = 40;
pub const MAX_CANON: ::kernel::sys::raw::c_uint = 255;
pub const MAX_INPUT: ::kernel::sys::raw::c_uint = 255;
pub const NAME_MAX: ::kernel::sys::raw::c_uint = 255;
pub const NGROUPS_MAX: ::kernel::sys::raw::c_uint = 1023;
pub const OPEN_MAX: ::kernel::sys::raw::c_uint = 64;
pub const PATH_MAX: ::kernel::sys::raw::c_uint = 1024;
pub const PIPE_BUF: ::kernel::sys::raw::c_uint = 512;
pub const IOV_MAX: ::kernel::sys::raw::c_uint = 1024;
pub const MAXCOMLEN: ::kernel::sys::raw::c_uint = 19;
pub const MAXINTERP: ::kernel::sys::raw::c_uint = 1024;
pub const MAXLOGNAME: ::kernel::sys::raw::c_uint = 33;
pub const MAXUPRC: ::kernel::sys::raw::c_uint = 40;
pub const NCARGS: ::kernel::sys::raw::c_uint = 262144;
pub const NGROUPS: ::kernel::sys::raw::c_uint = 1024;
pub const NOFILE: ::kernel::sys::raw::c_uint = 64;
pub const NOGROUP: ::kernel::sys::raw::c_uint = 65535;
pub const MAXHOSTNAMELEN: ::kernel::sys::raw::c_uint = 256;
pub const SPECNAMELEN: ::kernel::sys::raw::c_uint = 63;
pub const EPERM: ::kernel::sys::raw::c_uint = 1;
pub const ENOENT: ::kernel::sys::raw::c_uint = 2;
pub const ESRCH: ::kernel::sys::raw::c_uint = 3;
pub const EINTR: ::kernel::sys::raw::c_uint = 4;
pub const EIO: ::kernel::sys::raw::c_uint = 5;
pub const ENXIO: ::kernel::sys::raw::c_uint = 6;
pub const E2BIG: ::kernel::sys::raw::c_uint = 7;
pub const ENOEXEC: ::kernel::sys::raw::c_uint = 8;
pub const EBADF: ::kernel::sys::raw::c_uint = 9;
pub const ECHILD: ::kernel::sys::raw::c_uint = 10;
pub const EDEADLK: ::kernel::sys::raw::c_uint = 11;
pub const ENOMEM: ::kernel::sys::raw::c_uint = 12;
pub const EACCES: ::kernel::sys::raw::c_uint = 13;
pub const EFAULT: ::kernel::sys::raw::c_uint = 14;
pub const ENOTBLK: ::kernel::sys::raw::c_uint = 15;
pub const EBUSY: ::kernel::sys::raw::c_uint = 16;
pub const EEXIST: ::kernel::sys::raw::c_uint = 17;
pub const EXDEV: ::kernel::sys::raw::c_uint = 18;
pub const ENODEV: ::kernel::sys::raw::c_uint = 19;
pub const ENOTDIR: ::kernel::sys::raw::c_uint = 20;
pub const EISDIR: ::kernel::sys::raw::c_uint = 21;
pub const EINVAL: ::kernel::sys::raw::c_uint = 22;
pub const ENFILE: ::kernel::sys::raw::c_uint = 23;
pub const EMFILE: ::kernel::sys::raw::c_uint = 24;
pub const ENOTTY: ::kernel::sys::raw::c_uint = 25;
pub const ETXTBSY: ::kernel::sys::raw::c_uint = 26;
pub const EFBIG: ::kernel::sys::raw::c_uint = 27;
pub const ENOSPC: ::kernel::sys::raw::c_uint = 28;
pub const ESPIPE: ::kernel::sys::raw::c_uint = 29;
pub const EROFS: ::kernel::sys::raw::c_uint = 30;
pub const EMLINK: ::kernel::sys::raw::c_uint = 31;
pub const EPIPE: ::kernel::sys::raw::c_uint = 32;
pub const EDOM: ::kernel::sys::raw::c_uint = 33;
pub const ERANGE: ::kernel::sys::raw::c_uint = 34;
pub const EAGAIN: ::kernel::sys::raw::c_uint = 35;
pub const EWOULDBLOCK: ::kernel::sys::raw::c_uint = 35;
pub const EINPROGRESS: ::kernel::sys::raw::c_uint = 36;
pub const EALREADY: ::kernel::sys::raw::c_uint = 37;
pub const ENOTSOCK: ::kernel::sys::raw::c_uint = 38;
pub const EDESTADDRREQ: ::kernel::sys::raw::c_uint = 39;
pub const EMSGSIZE: ::kernel::sys::raw::c_uint = 40;
pub const EPROTOTYPE: ::kernel::sys::raw::c_uint = 41;
pub const ENOPROTOOPT: ::kernel::sys::raw::c_uint = 42;
pub const EPROTONOSUPPORT: ::kernel::sys::raw::c_uint = 43;
pub const ESOCKTNOSUPPORT: ::kernel::sys::raw::c_uint = 44;
pub const EOPNOTSUPP: ::kernel::sys::raw::c_uint = 45;
pub const ENOTSUP: ::kernel::sys::raw::c_uint = 45;
pub const EPFNOSUPPORT: ::kernel::sys::raw::c_uint = 46;
pub const EAFNOSUPPORT: ::kernel::sys::raw::c_uint = 47;
pub const EADDRINUSE: ::kernel::sys::raw::c_uint = 48;
pub const EADDRNOTAVAIL: ::kernel::sys::raw::c_uint = 49;
pub const ENETDOWN: ::kernel::sys::raw::c_uint = 50;
pub const ENETUNREACH: ::kernel::sys::raw::c_uint = 51;
pub const ENETRESET: ::kernel::sys::raw::c_uint = 52;
pub const ECONNABORTED: ::kernel::sys::raw::c_uint = 53;
pub const ECONNRESET: ::kernel::sys::raw::c_uint = 54;
pub const ENOBUFS: ::kernel::sys::raw::c_uint = 55;
pub const EISCONN: ::kernel::sys::raw::c_uint = 56;
pub const ENOTCONN: ::kernel::sys::raw::c_uint = 57;
pub const ESHUTDOWN: ::kernel::sys::raw::c_uint = 58;
pub const ETOOMANYREFS: ::kernel::sys::raw::c_uint = 59;
pub const ETIMEDOUT: ::kernel::sys::raw::c_uint = 60;
pub const ECONNREFUSED: ::kernel::sys::raw::c_uint = 61;
pub const ELOOP: ::kernel::sys::raw::c_uint = 62;
pub const ENAMETOOLONG: ::kernel::sys::raw::c_uint = 63;
pub const EHOSTDOWN: ::kernel::sys::raw::c_uint = 64;
pub const EHOSTUNREACH: ::kernel::sys::raw::c_uint = 65;
pub const ENOTEMPTY: ::kernel::sys::raw::c_uint = 66;
pub const EPROCLIM: ::kernel::sys::raw::c_uint = 67;
pub const EUSERS: ::kernel::sys::raw::c_uint = 68;
pub const EDQUOT: ::kernel::sys::raw::c_uint = 69;
pub const ESTALE: ::kernel::sys::raw::c_uint = 70;
pub const EREMOTE: ::kernel::sys::raw::c_uint = 71;
pub const EBADRPC: ::kernel::sys::raw::c_uint = 72;
pub const ERPCMISMATCH: ::kernel::sys::raw::c_uint = 73;
pub const EPROGUNAVAIL: ::kernel::sys::raw::c_uint = 74;
pub const EPROGMISMATCH: ::kernel::sys::raw::c_uint = 75;
pub const EPROCUNAVAIL: ::kernel::sys::raw::c_uint = 76;
pub const ENOLCK: ::kernel::sys::raw::c_uint = 77;
pub const ENOSYS: ::kernel::sys::raw::c_uint = 78;
pub const EFTYPE: ::kernel::sys::raw::c_uint = 79;
pub const EAUTH: ::kernel::sys::raw::c_uint = 80;
pub const ENEEDAUTH: ::kernel::sys::raw::c_uint = 81;
pub const EIDRM: ::kernel::sys::raw::c_uint = 82;
pub const ENOMSG: ::kernel::sys::raw::c_uint = 83;
pub const EOVERFLOW: ::kernel::sys::raw::c_uint = 84;
pub const ECANCELED: ::kernel::sys::raw::c_uint = 85;
pub const EILSEQ: ::kernel::sys::raw::c_uint = 86;
pub const ENOATTR: ::kernel::sys::raw::c_uint = 87;
pub const EDOOFUS: ::kernel::sys::raw::c_uint = 88;
pub const EBADMSG: ::kernel::sys::raw::c_uint = 89;
pub const EMULTIHOP: ::kernel::sys::raw::c_uint = 90;
pub const ENOLINK: ::kernel::sys::raw::c_uint = 91;
pub const EPROTO: ::kernel::sys::raw::c_uint = 92;
pub const ENOTCAPABLE: ::kernel::sys::raw::c_uint = 93;
pub const ECAPMODE: ::kernel::sys::raw::c_uint = 94;
pub const ENOTRECOVERABLE: ::kernel::sys::raw::c_uint = 95;
pub const EOWNERDEAD: ::kernel::sys::raw::c_uint = 96;
pub const ELAST: ::kernel::sys::raw::c_uint = 96;
pub const ERESTART: ::kernel::sys::raw::c_int = -1;
pub const EJUSTRETURN: ::kernel::sys::raw::c_int = -2;
pub const ENOIOCTL: ::kernel::sys::raw::c_int = -3;
pub const EDIRIOCTL: ::kernel::sys::raw::c_int = -4;
pub const ERELOOKUP: ::kernel::sys::raw::c_int = -5;
pub const DST_NONE: ::kernel::sys::raw::c_uint = 0;
pub const DST_USA: ::kernel::sys::raw::c_uint = 1;
pub const DST_AUST: ::kernel::sys::raw::c_uint = 2;
pub const DST_WET: ::kernel::sys::raw::c_uint = 3;
pub const DST_MET: ::kernel::sys::raw::c_uint = 4;
pub const DST_EET: ::kernel::sys::raw::c_uint = 5;
pub const DST_CAN: ::kernel::sys::raw::c_uint = 6;
pub const SBT_MAX: ::kernel::sys::raw::c_ulonglong = 9223372036854775807;
pub const ITIMER_REAL: ::kernel::sys::raw::c_uint = 0;
pub const ITIMER_VIRTUAL: ::kernel::sys::raw::c_uint = 1;
pub const ITIMER_PROF: ::kernel::sys::raw::c_uint = 2;
pub const CLOCK_REALTIME: ::kernel::sys::raw::c_uint = 0;
pub const CLOCK_VIRTUAL: ::kernel::sys::raw::c_uint = 1;
pub const CLOCK_PROF: ::kernel::sys::raw::c_uint = 2;
pub const CLOCK_MONOTONIC: ::kernel::sys::raw::c_uint = 4;
pub const CLOCK_UPTIME: ::kernel::sys::raw::c_uint = 5;
pub const CLOCK_UPTIME_PRECISE: ::kernel::sys::raw::c_uint = 7;
pub const CLOCK_UPTIME_FAST: ::kernel::sys::raw::c_uint = 8;
pub const CLOCK_REALTIME_PRECISE: ::kernel::sys::raw::c_uint = 9;
pub const CLOCK_REALTIME_FAST: ::kernel::sys::raw::c_uint = 10;
pub const CLOCK_MONOTONIC_PRECISE: ::kernel::sys::raw::c_uint = 11;
pub const CLOCK_MONOTONIC_FAST: ::kernel::sys::raw::c_uint = 12;
pub const CLOCK_SECOND: ::kernel::sys::raw::c_uint = 13;
pub const CLOCK_THREAD_CPUTIME_ID: ::kernel::sys::raw::c_uint = 14;
pub const CLOCK_PROCESS_CPUTIME_ID: ::kernel::sys::raw::c_uint = 15;
pub const TIMER_RELTIME: ::kernel::sys::raw::c_uint = 0;
pub const TIMER_ABSTIME: ::kernel::sys::raw::c_uint = 1;
pub const CPUCLOCK_WHICH_PID: ::kernel::sys::raw::c_uint = 0;
pub const CPUCLOCK_WHICH_TID: ::kernel::sys::raw::c_uint = 1;
pub const TC_DEFAULTPERC: ::kernel::sys::raw::c_uint = 5;
pub const PRI_ITHD: ::kernel::sys::raw::c_uint = 1;
pub const PRI_REALTIME: ::kernel::sys::raw::c_uint = 2;
pub const PRI_TIMESHARE: ::kernel::sys::raw::c_uint = 3;
pub const PRI_IDLE: ::kernel::sys::raw::c_uint = 4;
pub const PRI_FIFO_BIT: ::kernel::sys::raw::c_uint = 8;
pub const PRI_FIFO: ::kernel::sys::raw::c_uint = 10;
pub const PRI_MIN: ::kernel::sys::raw::c_uint = 0;
pub const PRI_MAX: ::kernel::sys::raw::c_uint = 255;
pub const PRI_MIN_ITHD: ::kernel::sys::raw::c_uint = 0;
pub const PI_REALTIME: ::kernel::sys::raw::c_uint = 0;
pub const PI_AV: ::kernel::sys::raw::c_uint = 4;
pub const PI_NET: ::kernel::sys::raw::c_uint = 8;
pub const PI_DISK: ::kernel::sys::raw::c_uint = 12;
pub const PI_TTY: ::kernel::sys::raw::c_uint = 16;
pub const PI_DULL: ::kernel::sys::raw::c_uint = 20;
pub const PI_SOFT: ::kernel::sys::raw::c_uint = 24;
pub const PRI_MIN_REALTIME: ::kernel::sys::raw::c_uint = 48;
pub const PRI_MIN_KERN: ::kernel::sys::raw::c_uint = 80;
pub const PSWP: ::kernel::sys::raw::c_uint = 80;
pub const PVM: ::kernel::sys::raw::c_uint = 84;
pub const PINOD: ::kernel::sys::raw::c_uint = 88;
pub const PRIBIO: ::kernel::sys::raw::c_uint = 92;
pub const PVFS: ::kernel::sys::raw::c_uint = 96;
pub const PZERO: ::kernel::sys::raw::c_uint = 100;
pub const PSOCK: ::kernel::sys::raw::c_uint = 104;
pub const PWAIT: ::kernel::sys::raw::c_uint = 108;
pub const PLOCK: ::kernel::sys::raw::c_uint = 112;
pub const PPAUSE: ::kernel::sys::raw::c_uint = 116;
pub const PRI_MIN_TIMESHARE: ::kernel::sys::raw::c_uint = 120;
pub const PUSER: ::kernel::sys::raw::c_uint = 120;
pub const PRI_MIN_IDLE: ::kernel::sys::raw::c_uint = 224;
pub const PRI_MAX_IDLE: ::kernel::sys::raw::c_uint = 255;
pub const PRI_USER: ::kernel::sys::raw::c_int = -2;
pub const PRI_UNCHANGED: ::kernel::sys::raw::c_int = -1;
pub const FALSE: ::kernel::sys::raw::c_uint = 0;
pub const TRUE: ::kernel::sys::raw::c_uint = 1;
pub const MACHINE: &'static [u8; 6usize] = b"amd64\x00";
pub const MACHINE_ARCH: &'static [u8; 6usize] = b"amd64\x00";
pub const MACHINE_ARCH32: &'static [u8; 5usize] = b"i386\x00";
pub const MAXCPU: ::kernel::sys::raw::c_uint = 256;
pub const MAXMEMDOM: ::kernel::sys::raw::c_uint = 8;
pub const CACHE_LINE_SHIFT: ::kernel::sys::raw::c_uint = 6;
pub const CACHE_LINE_SIZE: ::kernel::sys::raw::c_uint = 64;
pub const NPTEPGSHIFT: ::kernel::sys::raw::c_uint = 9;
pub const PAGE_SHIFT: ::kernel::sys::raw::c_uint = 12;
pub const PAGE_SIZE: ::kernel::sys::raw::c_uint = 4096;
pub const PAGE_MASK: ::kernel::sys::raw::c_uint = 4095;
pub const NPDEPGSHIFT: ::kernel::sys::raw::c_uint = 9;
pub const PDRSHIFT: ::kernel::sys::raw::c_uint = 21;
pub const NBPDR: ::kernel::sys::raw::c_uint = 2097152;
pub const PDRMASK: ::kernel::sys::raw::c_uint = 2097151;
pub const NPDPEPGSHIFT: ::kernel::sys::raw::c_uint = 9;
pub const PDPSHIFT: ::kernel::sys::raw::c_uint = 30;
pub const NBPDP: ::kernel::sys::raw::c_uint = 1073741824;
pub const PDPMASK: ::kernel::sys::raw::c_uint = 1073741823;
pub const NPML4EPGSHIFT: ::kernel::sys::raw::c_uint = 9;
pub const PML4SHIFT: ::kernel::sys::raw::c_uint = 39;
pub const NBPML4: ::kernel::sys::raw::c_ulonglong = 549755813888;
pub const PML4MASK: ::kernel::sys::raw::c_ulonglong = 549755813887;
pub const MAXPAGESIZES: ::kernel::sys::raw::c_uint = 3;
pub const IOPAGES: ::kernel::sys::raw::c_uint = 2;
pub const IOPERM_BITMAP_SIZE: ::kernel::sys::raw::c_uint = 8193;
pub const KSTACK_PAGES: ::kernel::sys::raw::c_uint = 4;
pub const KSTACK_GUARD_PAGES: ::kernel::sys::raw::c_uint = 1;
pub const DEV_BSHIFT: ::kernel::sys::raw::c_uint = 9;
pub const DEV_BSIZE: ::kernel::sys::raw::c_uint = 512;
pub const BLKDEV_IOSIZE: ::kernel::sys::raw::c_uint = 4096;
pub const DFLTPHYS: ::kernel::sys::raw::c_uint = 65536;
pub const MAXPHYS: ::kernel::sys::raw::c_uint = 131072;
pub const MAXDUMPPGS: ::kernel::sys::raw::c_uint = 16;
pub const MSIZE: ::kernel::sys::raw::c_uint = 256;
pub const MCLSHIFT: ::kernel::sys::raw::c_uint = 11;
pub const MCLBYTES: ::kernel::sys::raw::c_uint = 2048;
pub const MJUMPAGESIZE: ::kernel::sys::raw::c_uint = 4096;
pub const MJUM9BYTES: ::kernel::sys::raw::c_uint = 9216;
pub const MJUM16BYTES: ::kernel::sys::raw::c_uint = 16384;
pub const PRIMASK: ::kernel::sys::raw::c_uint = 255;
pub const PCATCH: ::kernel::sys::raw::c_uint = 256;
pub const PDROP: ::kernel::sys::raw::c_uint = 512;
pub const NZERO: ::kernel::sys::raw::c_uint = 0;
pub const NBBY: ::kernel::sys::raw::c_uint = 8;
pub const CMASK: ::kernel::sys::raw::c_uint = 18;
pub const MAXBSIZE: ::kernel::sys::raw::c_uint = 65536;
pub const MAXBCACHEBUF: ::kernel::sys::raw::c_uint = 65536;
pub const BKVASIZE: ::kernel::sys::raw::c_uint = 16384;
pub const BKVAMASK: ::kernel::sys::raw::c_uint = 16383;
pub const MAXPATHLEN: ::kernel::sys::raw::c_uint = 1024;
pub const MAXSYMLINKS: ::kernel::sys::raw::c_uint = 32;
pub const FSHIFT: ::kernel::sys::raw::c_uint = 11;
pub const FSCALE: ::kernel::sys::raw::c_uint = 2048;
pub const CPU_SETSIZE: ::kernel::sys::raw::c_uint = 256;
pub const CPU_MAXSIZE: ::kernel::sys::raw::c_uint = 256;
pub const PRIO_MIN: ::kernel::sys::raw::c_int = -20;
pub const PRIO_MAX: ::kernel::sys::raw::c_uint = 20;
pub const PRIO_PROCESS: ::kernel::sys::raw::c_uint = 0;
pub const PRIO_PGRP: ::kernel::sys::raw::c_uint = 1;
pub const PRIO_USER: ::kernel::sys::raw::c_uint = 2;
pub const RUSAGE_SELF: ::kernel::sys::raw::c_uint = 0;
pub const RUSAGE_CHILDREN: ::kernel::sys::raw::c_int = -1;
pub const RUSAGE_THREAD: ::kernel::sys::raw::c_uint = 1;
pub const RLIMIT_CPU: ::kernel::sys::raw::c_uint = 0;
pub const RLIMIT_FSIZE: ::kernel::sys::raw::c_uint = 1;
pub const RLIMIT_DATA: ::kernel::sys::raw::c_uint = 2;
pub const RLIMIT_STACK: ::kernel::sys::raw::c_uint = 3;
pub const RLIMIT_CORE: ::kernel::sys::raw::c_uint = 4;
pub const RLIMIT_RSS: ::kernel::sys::raw::c_uint = 5;
pub const RLIMIT_MEMLOCK: ::kernel::sys::raw::c_uint = 6;
pub const RLIMIT_NPROC: ::kernel::sys::raw::c_uint = 7;
pub const RLIMIT_NOFILE: ::kernel::sys::raw::c_uint = 8;
pub const RLIMIT_SBSIZE: ::kernel::sys::raw::c_uint = 9;
pub const RLIMIT_VMEM: ::kernel::sys::raw::c_uint = 10;
pub const RLIMIT_AS: ::kernel::sys::raw::c_uint = 10;
pub const RLIMIT_NPTS: ::kernel::sys::raw::c_uint = 11;
pub const RLIMIT_SWAP: ::kernel::sys::raw::c_uint = 12;
pub const RLIMIT_KQUEUES: ::kernel::sys::raw::c_uint = 13;
pub const RLIMIT_UMTXP: ::kernel::sys::raw::c_uint = 14;
pub const RLIM_NLIMITS: ::kernel::sys::raw::c_uint = 15;
pub const CP_USER: ::kernel::sys::raw::c_uint = 0;
pub const CP_NICE: ::kernel::sys::raw::c_uint = 1;
pub const CP_SYS: ::kernel::sys::raw::c_uint = 2;
pub const CP_INTR: ::kernel::sys::raw::c_uint = 3;
pub const CP_IDLE: ::kernel::sys::raw::c_uint = 4;
pub const CPUSTATES: ::kernel::sys::raw::c_uint = 5;
pub const PC_PTI_STACK_SZ: ::kernel::sys::raw::c_uint = 16;
pub const PC_DBREG_CMD_NONE: ::kernel::sys::raw::c_uint = 0;
pub const PC_DBREG_CMD_LOAD: ::kernel::sys::raw::c_uint = 1;
pub const OFFSETOF_CURTHREAD: ::kernel::sys::raw::c_uint = 0;
pub const OFFSETOF_CURPCB: ::kernel::sys::raw::c_uint = 32;
pub const DPCPU_SETNAME: &'static [u8; 9usize] = b"set_pcpu\x00";
pub const DPCPU_SYMPREFIX: &'static [u8; 12usize] = b"pcpu_entry_\x00";
pub const DPCPU_MODMIN: ::kernel::sys::raw::c_uint = 2048;
pub const LOCKSTAT_WRITER: ::kernel::sys::raw::c_uint = 0;
pub const LOCKSTAT_READER: ::kernel::sys::raw::c_uint = 1;
pub const CR4_PGE: ::kernel::sys::raw::c_uint = 128;
pub const INVPCID_ADDR: ::kernel::sys::raw::c_uint = 0;
pub const INVPCID_CTX: ::kernel::sys::raw::c_uint = 1;
pub const INVPCID_CTXGLOB: ::kernel::sys::raw::c_uint = 2;
pub const INVPCID_ALLCTX: ::kernel::sys::raw::c_uint = 3;
pub const MSR_FSBASE: ::kernel::sys::raw::c_uint = 3221225728;
pub const MSR_GSBASE: ::kernel::sys::raw::c_uint = 3221225729;
pub const MTX_DEF: ::kernel::sys::raw::c_uint = 0;
pub const MTX_SPIN: ::kernel::sys::raw::c_uint = 1;
pub const MTX_RECURSE: ::kernel::sys::raw::c_uint = 4;
pub const MTX_NOWITNESS: ::kernel::sys::raw::c_uint = 8;
pub const MTX_NOPROFILE: ::kernel::sys::raw::c_uint = 32;
pub const MTX_NEW: ::kernel::sys::raw::c_uint = 64;
pub const MTX_QUIET: ::kernel::sys::raw::c_uint = 2;
pub const MTX_DUPOK: ::kernel::sys::raw::c_uint = 16;
pub const MTX_UNOWNED: ::kernel::sys::raw::c_uint = 0;
pub const MTX_RECURSED: ::kernel::sys::raw::c_uint = 1;
pub const MTX_CONTESTED: ::kernel::sys::raw::c_uint = 2;
pub const MTX_DESTROYED: ::kernel::sys::raw::c_uint = 4;
pub const MTX_FLAGMASK: ::kernel::sys::raw::c_uint = 7;
pub const MTX_NETWORK_LOCK: &'static [u8; 15usize] = b"network driver\x00";
pub const EHE_DEAD_PRIORITY: ::kernel::sys::raw::c_int = -1;
pub const EVENTHANDLER_PRI_FIRST: ::kernel::sys::raw::c_uint = 0;
pub const EVENTHANDLER_PRI_ANY: ::kernel::sys::raw::c_uint = 10000;
pub const EVENTHANDLER_PRI_LAST: ::kernel::sys::raw::c_uint = 20000;
pub const SHUTDOWN_PRI_FIRST: ::kernel::sys::raw::c_uint = 0;
pub const SHUTDOWN_PRI_DEFAULT: ::kernel::sys::raw::c_uint = 10000;
pub const SHUTDOWN_PRI_LAST: ::kernel::sys::raw::c_uint = 20000;
pub const LOWMEM_PRI_DEFAULT: ::kernel::sys::raw::c_uint = 0;
pub const KOBJ_CACHE_SIZE: ::kernel::sys::raw::c_uint = 256;
pub const FILTER_STRAY: ::kernel::sys::raw::c_uint = 1;
pub const FILTER_HANDLED: ::kernel::sys::raw::c_uint = 2;
pub const FILTER_SCHEDULE_THREAD: ::kernel::sys::raw::c_uint = 4;
pub const RLE_RESERVED: ::kernel::sys::raw::c_uint = 1;
pub const RLE_ALLOCATED: ::kernel::sys::raw::c_uint = 2;
pub const RLE_PREFETCH: ::kernel::sys::raw::c_uint = 4;
pub const BUS_PROBE_SPECIFIC: ::kernel::sys::raw::c_uint = 0;
pub const BUS_PROBE_VENDOR: ::kernel::sys::raw::c_int = -10;
pub const BUS_PROBE_DEFAULT: ::kernel::sys::raw::c_int = -20;
pub const BUS_PROBE_LOW_PRIORITY: ::kernel::sys::raw::c_int = -40;
pub const BUS_PROBE_GENERIC: ::kernel::sys::raw::c_int = -100;
pub const BUS_PROBE_HOOVER: ::kernel::sys::raw::c_int = -1000000;
pub const BUS_PROBE_NOWILDCARD: ::kernel::sys::raw::c_int = -2000000000;
pub const BUS_PASS_ROOT: ::kernel::sys::raw::c_uint = 0;
pub const BUS_PASS_BUS: ::kernel::sys::raw::c_uint = 10;
pub const BUS_PASS_CPU: ::kernel::sys::raw::c_uint = 20;
pub const BUS_PASS_RESOURCE: ::kernel::sys::raw::c_uint = 30;
pub const BUS_PASS_INTERRUPT: ::kernel::sys::raw::c_uint = 40;
pub const BUS_PASS_TIMER: ::kernel::sys::raw::c_uint = 50;
pub const BUS_PASS_SCHEDULER: ::kernel::sys::raw::c_uint = 60;
pub const BUS_PASS_SUPPORTDEV: ::kernel::sys::raw::c_uint = 100000;
pub const BUS_PASS_DEFAULT: ::kernel::sys::raw::c_uint = 2147483647;
pub const BUS_PASS_ORDER_FIRST: ::kernel::sys::raw::c_uint = 0;
pub const BUS_PASS_ORDER_EARLY: ::kernel::sys::raw::c_uint = 2;
pub const BUS_PASS_ORDER_MIDDLE: ::kernel::sys::raw::c_uint = 5;
pub const BUS_PASS_ORDER_LATE: ::kernel::sys::raw::c_uint = 7;
pub const BUS_PASS_ORDER_LAST: ::kernel::sys::raw::c_uint = 9;
pub const TS_ENTER: ::kernel::sys::raw::c_uint = 0;
pub const TS_EXIT: ::kernel::sys::raw::c_uint = 1;
pub const TS_THREAD: ::kernel::sys::raw::c_uint = 2;
pub const TS_EVENT: ::kernel::sys::raw::c_uint = 3;
pub const _SYS_RMAN_H_: ::kernel::sys::raw::c_uint = 1;
pub const _MACHINE_RESOURCE_H_: ::kernel::sys::raw::c_uint = 1;
pub const SYS_RES_IRQ: ::kernel::sys::raw::c_uint = 1;
pub const SYS_RES_DRQ: ::kernel::sys::raw::c_uint = 2;
pub const SYS_RES_MEMORY: ::kernel::sys::raw::c_uint = 3;
pub const SYS_RES_IOPORT: ::kernel::sys::raw::c_uint = 4;
pub const RF_ALLOCATED: ::kernel::sys::raw::c_uint = 1;
pub const RF_ACTIVE: ::kernel::sys::raw::c_uint = 2;
pub const RF_SHAREABLE: ::kernel::sys::raw::c_uint = 4;
pub const RF_SPARE1: ::kernel::sys::raw::c_uint = 8;
pub const RF_SPARE2: ::kernel::sys::raw::c_uint = 16;
pub const RF_FIRSTSHARE: ::kernel::sys::raw::c_uint = 32;
pub const RF_PREFETCHABLE: ::kernel::sys::raw::c_uint = 64;
pub const RF_OPTIONAL: ::kernel::sys::raw::c_uint = 128;
pub const RF_UNMAPPED: ::kernel::sys::raw::c_uint = 256;
pub const RF_ALIGNMENT_SHIFT: ::kernel::sys::raw::c_uint = 10;
pub const RF_ALIGNMENT_MASK: ::kernel::sys::raw::c_uint = 64512;
pub const RM_TEXTLEN: ::kernel::sys::raw::c_uint = 32;
pub type __int8_t = ::kernel::sys::raw::c_schar;
pub type __uint8_t = ::kernel::sys::raw::c_uchar;
pub type __int16_t = ::kernel::sys::raw::c_short;
pub type __uint16_t = ::kernel::sys::raw::c_ushort;
pub type __int32_t = ::kernel::sys::raw::c_int;
pub type __uint32_t = ::kernel::sys::raw::c_uint;
pub type __int64_t = ::kernel::sys::raw::c_long;
pub type __uint64_t = ::kernel::sys::raw::c_ulong;
pub type __clock_t = __int32_t;
pub type __critical_t = __int64_t;
pub type __double_t = f64;
pub type __float_t = f32;
pub type __intfptr_t = __int64_t;
pub type __intptr_t = __int64_t;
pub type __intmax_t = __int64_t;
pub type __int_fast8_t = __int32_t;
pub type __int_fast16_t = __int32_t;
pub type __int_fast32_t = __int32_t;
pub type __int_fast64_t = __int64_t;
pub type __int_least8_t = __int8_t;
pub type __int_least16_t = __int16_t;
pub type __int_least32_t = __int32_t;
pub type __int_least64_t = __int64_t;
pub type __ptrdiff_t = __int64_t;
pub type __register_t = __int64_t;
pub type __segsz_t = __int64_t;
pub type __size_t = __uint64_t;
pub type __ssize_t = __int64_t;
pub type __time_t = __int64_t;
pub type __uintfptr_t = __uint64_t;
pub type __uintptr_t = __uint64_t;
pub type __uintmax_t = __uint64_t;
pub type __uint_fast8_t = __uint32_t;
pub type __uint_fast16_t = __uint32_t;
pub type __uint_fast32_t = __uint32_t;
pub type __uint_fast64_t = __uint64_t;
pub type __uint_least8_t = __uint8_t;
pub type __uint_least16_t = __uint16_t;
pub type __uint_least32_t = __uint32_t;
pub type __uint_least64_t = __uint64_t;
pub type __u_register_t = __uint64_t;
pub type __vm_offset_t = __uint64_t;
pub type __vm_paddr_t = __uint64_t;
pub type __vm_size_t = __uint64_t;
pub type ___wchar_t = ::kernel::sys::raw::c_int;
pub type __blksize_t = __int32_t;
pub type __blkcnt_t = __int64_t;
pub type __clockid_t = __int32_t;
pub type __fflags_t = __uint32_t;
pub type __fsblkcnt_t = __uint64_t;
pub type __fsfilcnt_t = __uint64_t;
pub type __gid_t = __uint32_t;
pub type __id_t = __int64_t;
pub type __ino_t = __uint64_t;
pub type __key_t = ::kernel::sys::raw::c_long;
pub type __lwpid_t = __int32_t;
pub type __mode_t = __uint16_t;
pub type __accmode_t = ::kernel::sys::raw::c_int;
pub type __nl_item = ::kernel::sys::raw::c_int;
pub type __nlink_t = __uint64_t;
pub type __off_t = __int64_t;
pub type __off64_t = __int64_t;
pub type __pid_t = __int32_t;
pub type __rlim_t = __int64_t;
pub type __sa_family_t = __uint8_t;
pub type __socklen_t = __uint32_t;
pub type __suseconds_t = ::kernel::sys::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __timer {
    _unused: [u8; 0],
}
pub type __timer_t = *mut __timer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __mq {
    _unused: [u8; 0],
}
pub type __mqd_t = *mut __mq;
pub type __uid_t = __uint32_t;
pub type __useconds_t = ::kernel::sys::raw::c_uint;
pub type __cpuwhich_t = ::kernel::sys::raw::c_int;
pub type __cpulevel_t = ::kernel::sys::raw::c_int;
pub type __cpusetid_t = ::kernel::sys::raw::c_int;
pub type __ct_rune_t = ::kernel::sys::raw::c_int;
pub type __rune_t = __ct_rune_t;
pub type __wint_t = __ct_rune_t;
pub type __char16_t = __uint_least16_t;
pub type __char32_t = __uint_least32_t;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct __max_align_t {
    pub __max_align1: ::kernel::sys::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __max_align2: f64,
}
#[test]
fn bindgen_test_layout___max_align_t() {
    assert_eq!(::core::mem::size_of::<__max_align_t>() , 32usize , concat ! (
               "Size of: " , stringify ! ( __max_align_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __max_align_t ) ) . __max_align1 as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __max_align_t ) , "::"
                , stringify ! ( __max_align1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __max_align_t ) ) . __max_align2 as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __max_align_t ) , "::"
                , stringify ! ( __max_align2 ) ));
}
impl Clone for __max_align_t {
    fn clone(&self) -> Self { *self }
}
pub type __dev_t = __uint64_t;
pub type __fixpt_t = __uint32_t;
#[repr(C)]
#[derive(Copy)]
pub union __mbstate_t {
    pub __mbstate8: [::kernel::sys::raw::c_char; 128usize],
    pub _mbstateL: __int64_t,
    _bindgen_union_align: [u64; 16usize],
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(::core::mem::size_of::<__mbstate_t>() , 128usize , concat ! (
               "Size of: " , stringify ! ( __mbstate_t ) ));
    assert_eq! (::core::mem::align_of::<__mbstate_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __mbstate_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . __mbstate8 as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( __mbstate8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . _mbstateL as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( _mbstateL ) ));
}
impl Clone for __mbstate_t {
    fn clone(&self) -> Self { *self }
}
impl Default for __mbstate_t {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for __mbstate_t {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "__mbstate_t {{ union }}")
    }
}
pub type __rman_res_t = __uintmax_t;
pub type __va_list = __builtin_va_list;
pub type __gnuc_va_list = __va_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_cond {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_cond_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutex {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutex_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_once {
    pub state: ::kernel::sys::raw::c_int,
    pub mutex: pthread_mutex_t,
}
#[test]
fn bindgen_test_layout_pthread_once() {
    assert_eq!(::core::mem::size_of::<pthread_once>() , 16usize , concat ! (
               "Size of: " , stringify ! ( pthread_once ) ));
    assert_eq! (::core::mem::align_of::<pthread_once>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_once ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_once ) ) . state as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_once ) , "::" ,
                stringify ! ( state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_once ) ) . mutex as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_once ) , "::" ,
                stringify ! ( mutex ) ));
}
impl Clone for pthread_once {
    fn clone(&self) -> Self { *self }
}
impl Default for pthread_once {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_rwlock {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_rwlockattr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_barrier {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_barrier_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_spinlock {
    _unused: [u8; 0],
}
pub type pthread_t = *mut pthread;
pub type pthread_attr_t = *mut pthread_attr;
pub type pthread_mutex_t = *mut pthread_mutex;
pub type pthread_mutexattr_t = *mut pthread_mutex_attr;
pub type pthread_cond_t = *mut pthread_cond;
pub type pthread_condattr_t = *mut pthread_cond_attr;
pub type pthread_key_t = ::kernel::sys::raw::c_int;
pub type pthread_once_t = pthread_once;
pub type pthread_rwlock_t = *mut pthread_rwlock;
pub type pthread_rwlockattr_t = *mut pthread_rwlockattr;
pub type pthread_barrier_t = *mut pthread_barrier;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_barrierattr {
    _unused: [u8; 0],
}
pub type pthread_barrierattr_t = *mut pthread_barrierattr;
pub type pthread_spinlock_t = *mut pthread_spinlock;
pub type pthread_addr_t = *mut ::kernel::sys::raw::c_void;
pub type pthread_startroutine_t =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void)
                               -> *mut ::kernel::sys::raw::c_void>;
pub type u_char = ::kernel::sys::raw::c_uchar;
pub type u_short = ::kernel::sys::raw::c_ushort;
pub type u_int = ::kernel::sys::raw::c_uint;
pub type u_long = ::kernel::sys::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type u_quad_t = __uint64_t;
pub type quad_t = __int64_t;
pub type qaddr_t = *mut quad_t;
pub type caddr_t = *mut ::kernel::sys::raw::c_char;
pub type c_caddr_t = *const ::kernel::sys::raw::c_char;
pub type blksize_t = __blksize_t;
pub type cpuwhich_t = __cpuwhich_t;
pub type cpulevel_t = __cpulevel_t;
pub type cpusetid_t = __cpusetid_t;
pub type blkcnt_t = __blkcnt_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type critical_t = __critical_t;
pub type daddr_t = __int64_t;
pub type dev_t = __dev_t;
pub type fflags_t = __fflags_t;
pub type fixpt_t = __fixpt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type gid_t = __gid_t;
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type id_t = __id_t;
pub type ino_t = __ino_t;
pub type key_t = __key_t;
pub type lwpid_t = __lwpid_t;
pub type mode_t = __mode_t;
pub type accmode_t = __accmode_t;
pub type nlink_t = __nlink_t;
pub type off_t = __off_t;
pub type off64_t = __off64_t;
pub type pid_t = __pid_t;
pub type register_t = __register_t;
pub type rlim_t = __rlim_t;
pub type sbintime_t = __int64_t;
pub type segsz_t = __segsz_t;
pub type suseconds_t = __suseconds_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type mqd_t = __mqd_t;
pub type u_register_t = __u_register_t;
pub type uid_t = __uid_t;
pub type useconds_t = __useconds_t;
pub type cap_ioctl_t = ::kernel::sys::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cap_rights {
    _unused: [u8; 0],
}
pub type cap_rights_t = cap_rights;
pub type vm_offset_t = __vm_offset_t;
pub type vm_ooffset_t = __int64_t;
pub type vm_paddr_t = __vm_paddr_t;
pub type vm_pindex_t = __uint64_t;
pub type vm_size_t = __vm_size_t;
pub type rman_res_t = __rman_res_t;
pub type boolean_t = ::kernel::sys::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct device {
    _unused: [u8; 0],
}
pub type device_t = *mut device;
pub type intfptr_t = __intfptr_t;
pub type intrmask_t = __uint32_t;
pub type uintfptr_t = __uintfptr_t;
pub type uoff_t = __uint64_t;
pub type vm_memattr_t = ::kernel::sys::raw::c_char;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_page {
    _unused: [u8; 0],
}
pub type vm_page_t = *mut vm_page;
pub type bool_ = bool;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct __sigset {
    pub __bits: [__uint32_t; 4usize],
}
#[test]
fn bindgen_test_layout___sigset() {
    assert_eq!(::core::mem::size_of::<__sigset>() , 16usize , concat ! (
               "Size of: " , stringify ! ( __sigset ) ));
    assert_eq! (::core::mem::align_of::<__sigset>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( __sigset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sigset ) ) . __bits as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sigset ) , "::" ,
                stringify ! ( __bits ) ));
}
impl Clone for __sigset {
    fn clone(&self) -> Self { *self }
}
pub type __sigset_t = __sigset;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct timeval {
    pub tv_sec: time_t,
    pub tv_usec: suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(::core::mem::size_of::<timeval>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timeval ) ));
    assert_eq! (::core::mem::align_of::<timeval>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timeval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_usec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_usec ) ));
}
impl Clone for timeval {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: ::kernel::sys::raw::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(::core::mem::size_of::<timespec>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timespec ) ));
    assert_eq! (::core::mem::align_of::<timespec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timespec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_nsec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_nsec ) ));
}
impl Clone for timespec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(::core::mem::size_of::<itimerspec>() , 32usize , concat ! (
               "Size of: " , stringify ! ( itimerspec ) ));
    assert_eq! (::core::mem::align_of::<itimerspec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( itimerspec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerspec ) ) . it_interval as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerspec ) , "::" ,
                stringify ! ( it_interval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerspec ) ) . it_value as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerspec ) , "::" ,
                stringify ! ( it_value ) ));
}
impl Clone for itimerspec {
    fn clone(&self) -> Self { *self }
}
pub type __fd_mask = ::kernel::sys::raw::c_ulong;
pub type fd_mask = __fd_mask;
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(::core::mem::size_of::<fd_set>() , 128usize , concat ! (
               "Size of: " , stringify ! ( fd_set ) ));
    assert_eq! (::core::mem::align_of::<fd_set>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( fd_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fd_set ) ) . __fds_bits as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( fd_set ) , "::" ,
                stringify ! ( __fds_bits ) ));
}
impl Clone for fd_set {
    fn clone(&self) -> Self { *self }
}
pub type bus_addr_t = u64;
pub type bus_size_t = u64;
pub type bus_space_tag_t = u64;
pub type bus_space_handle_t = u64;
pub type bus_dmasync_op_t = ::kernel::sys::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bus_dma_tag {
    _unused: [u8; 0],
}
pub type bus_dma_tag_t = *mut bus_dma_tag;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bus_dmamap {
    _unused: [u8; 0],
}
pub type bus_dmamap_t = *mut bus_dmamap;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum bus_dma_lock_op_t { BUS_DMA_LOCK = 1, BUS_DMA_UNLOCK = 2, }
pub type bus_dma_lock_t =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: bus_dma_lock_op_t)>;
/// @brief Interface information structure.
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct u_businfo {
    /// < @brief interface version
    pub ub_version: ::kernel::sys::raw::c_int,
    /// < @brief generation count
    pub ub_generation: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_u_businfo() {
    assert_eq!(::core::mem::size_of::<u_businfo>() , 8usize , concat ! (
               "Size of: " , stringify ! ( u_businfo ) ));
    assert_eq! (::core::mem::align_of::<u_businfo>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( u_businfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_businfo ) ) . ub_version as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( u_businfo ) , "::" ,
                stringify ! ( ub_version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_businfo ) ) . ub_generation as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( u_businfo ) , "::" ,
                stringify ! ( ub_generation ) ));
}
impl Clone for u_businfo {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
/// @brief State of the device.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum device_state {
    DS_NOTPRESENT = 10,
    DS_ALIVE = 20,
    DS_ATTACHING = 25,
    DS_ATTACHED = 30,
    DS_BUSY = 40,
}
pub use self::device_state as device_state_t;
/// @brief Device information exported to userspace.
#[repr(C)]
#[derive(Copy)]
pub struct u_device {
    pub dv_handle: usize,
    pub dv_parent: usize,
    /// < @brief Name of device in tree.
    pub dv_name: [::kernel::sys::raw::c_char; 32usize],
    /// < @brief Driver description
    pub dv_desc: [::kernel::sys::raw::c_char; 32usize],
    /// < @brief Driver name
    pub dv_drivername: [::kernel::sys::raw::c_char; 32usize],
    /// < @brief Plug and play info
    pub dv_pnpinfo: [::kernel::sys::raw::c_char; 128usize],
    /// < @brief Where is the device?
    pub dv_location: [::kernel::sys::raw::c_char; 128usize],
    /// < @brief API Flags for device
    pub dv_devflags: u32,
    /// < @brief flags for dev state
    pub dv_flags: u16,
    /// < @brief State of attachment
    pub dv_state: device_state_t,
}
#[test]
fn bindgen_test_layout_u_device() {
    assert_eq!(::core::mem::size_of::<u_device>() , 384usize , concat ! (
               "Size of: " , stringify ! ( u_device ) ));
    assert_eq! (::core::mem::align_of::<u_device>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( u_device ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_device ) ) . dv_handle as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( u_device ) , "::" ,
                stringify ! ( dv_handle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_device ) ) . dv_parent as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( u_device ) , "::" ,
                stringify ! ( dv_parent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_device ) ) . dv_name as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( u_device ) , "::" ,
                stringify ! ( dv_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_device ) ) . dv_desc as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( u_device ) , "::" ,
                stringify ! ( dv_desc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_device ) ) . dv_drivername as * const _
                as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( u_device ) , "::" ,
                stringify ! ( dv_drivername ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_device ) ) . dv_pnpinfo as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( u_device ) , "::" ,
                stringify ! ( dv_pnpinfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_device ) ) . dv_location as * const _
                as usize } , 240usize , concat ! (
                "Alignment of field: " , stringify ! ( u_device ) , "::" ,
                stringify ! ( dv_location ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_device ) ) . dv_devflags as * const _
                as usize } , 368usize , concat ! (
                "Alignment of field: " , stringify ! ( u_device ) , "::" ,
                stringify ! ( dv_devflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_device ) ) . dv_flags as * const _ as
                usize } , 372usize , concat ! (
                "Alignment of field: " , stringify ! ( u_device ) , "::" ,
                stringify ! ( dv_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_device ) ) . dv_state as * const _ as
                usize } , 376usize , concat ! (
                "Alignment of field: " , stringify ! ( u_device ) , "::" ,
                stringify ! ( dv_state ) ));
}
impl Clone for u_device {
    fn clone(&self) -> Self { *self }
}
impl Default for u_device {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for u_device {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "u_device {{ dv_handle: {:?}, dv_parent: {:?}, dv_name: [{}], dv_desc: [{}], dv_drivername: [{}], dv_pnpinfo: [{}], dv_location: [{}], dv_devflags: {:?}, dv_flags: {:?}, dv_state: {:?} }}"
               , self . dv_handle , self . dv_parent , self . dv_name . iter (
                ) . enumerate (  ) . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ) , self . dv_desc . iter (  ) . enumerate (  ) .
               map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ) , self . dv_drivername . iter (  ) . enumerate (
               ) . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ) , self . dv_pnpinfo . iter (  ) . enumerate (  )
               . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ) , self . dv_location . iter (  ) . enumerate (  )
               . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ) , self . dv_devflags , self . dv_flags , self .
               dv_state)
    }
}
/// @brief Device request structure used for ioctl's.
///
/// Used for ioctl's on /dev/devctl2.  All device ioctl's
/// must have parameter definitions which begin with dr_name.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct devreq_buffer {
    pub buffer: *mut ::kernel::sys::raw::c_void,
    pub length: usize,
}
#[test]
fn bindgen_test_layout_devreq_buffer() {
    assert_eq!(::core::mem::size_of::<devreq_buffer>() , 16usize , concat ! (
               "Size of: " , stringify ! ( devreq_buffer ) ));
    assert_eq! (::core::mem::align_of::<devreq_buffer>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( devreq_buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const devreq_buffer ) ) . buffer as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( devreq_buffer ) , "::"
                , stringify ! ( buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const devreq_buffer ) ) . length as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( devreq_buffer ) , "::"
                , stringify ! ( length ) ));
}
impl Clone for devreq_buffer {
    fn clone(&self) -> Self { *self }
}
impl Default for devreq_buffer {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct devreq {
    pub dr_name: [::kernel::sys::raw::c_char; 128usize],
    pub dr_flags: ::kernel::sys::raw::c_int,
    pub dr_dru: devreq__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub union devreq__bindgen_ty_1 {
    pub dru_buffer: devreq_buffer,
    pub dru_data: *mut ::kernel::sys::raw::c_void,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_devreq__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<devreq__bindgen_ty_1>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( devreq__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<devreq__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( devreq__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const devreq__bindgen_ty_1 ) ) . dru_buffer as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( devreq__bindgen_ty_1 )
                , "::" , stringify ! ( dru_buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const devreq__bindgen_ty_1 ) ) . dru_data as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( devreq__bindgen_ty_1 )
                , "::" , stringify ! ( dru_data ) ));
}
impl Clone for devreq__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for devreq__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for devreq__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "devreq__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_devreq() {
    assert_eq!(::core::mem::size_of::<devreq>() , 152usize , concat ! (
               "Size of: " , stringify ! ( devreq ) ));
    assert_eq! (::core::mem::align_of::<devreq>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( devreq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const devreq ) ) . dr_name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( devreq ) , "::" ,
                stringify ! ( dr_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const devreq ) ) . dr_flags as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( devreq ) , "::" ,
                stringify ! ( dr_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const devreq ) ) . dr_dru as * const _ as usize
                } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( devreq ) , "::" ,
                stringify ! ( dr_dru ) ));
}
impl Clone for devreq {
    fn clone(&self) -> Self { *self }
}
impl Default for devreq {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for devreq {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "devreq {{ dr_name: [{}], dr_flags: {:?}, dr_dru: {:?} }}"
               , self . dr_name . iter (  ) . enumerate (  ) . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ) , self . dr_flags , self . dr_dru)
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lock_object {
    pub lo_name: *const ::kernel::sys::raw::c_char,
    pub lo_flags: u_int,
    pub lo_data: u_int,
    pub lo_witness: *mut witness,
}
#[test]
fn bindgen_test_layout_lock_object() {
    assert_eq!(::core::mem::size_of::<lock_object>() , 24usize , concat ! (
               "Size of: " , stringify ! ( lock_object ) ));
    assert_eq! (::core::mem::align_of::<lock_object>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lock_object ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_object ) ) . lo_name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_object ) , "::" ,
                stringify ! ( lo_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_object ) ) . lo_flags as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_object ) , "::" ,
                stringify ! ( lo_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_object ) ) . lo_data as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_object ) , "::" ,
                stringify ! ( lo_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_object ) ) . lo_witness as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_object ) , "::" ,
                stringify ! ( lo_witness ) ));
}
impl Clone for lock_object {
    fn clone(&self) -> Self { *self }
}
impl Default for lock_object {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lock_list_entry {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct thread {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lock_class {
    pub lc_name: *const ::kernel::sys::raw::c_char,
    pub lc_flags: u_int,
    pub lc_assert: ::core::option::Option<unsafe extern "C" fn(lock:
                                                                   *const lock_object,
                                                               what:
                                                                   ::kernel::sys::raw::c_int)>,
    pub lc_ddb_show: ::core::option::Option<unsafe extern "C" fn(lock:
                                                                     *const lock_object)>,
    pub lc_lock: ::core::option::Option<unsafe extern "C" fn(lock:
                                                                 *mut lock_object,
                                                             how: usize)>,
    pub lc_owner: ::core::option::Option<unsafe extern "C" fn(lock:
                                                                  *const lock_object,
                                                              owner:
                                                                  *mut *mut thread)
                                             -> ::kernel::sys::raw::c_int>,
    pub lc_unlock: ::core::option::Option<unsafe extern "C" fn(lock:
                                                                   *mut lock_object)
                                              -> usize>,
}
#[test]
fn bindgen_test_layout_lock_class() {
    assert_eq!(::core::mem::size_of::<lock_class>() , 56usize , concat ! (
               "Size of: " , stringify ! ( lock_class ) ));
    assert_eq! (::core::mem::align_of::<lock_class>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lock_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_class ) ) . lc_name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_class ) , "::" ,
                stringify ! ( lc_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_class ) ) . lc_flags as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_class ) , "::" ,
                stringify ! ( lc_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_class ) ) . lc_assert as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_class ) , "::" ,
                stringify ! ( lc_assert ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_class ) ) . lc_ddb_show as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_class ) , "::" ,
                stringify ! ( lc_ddb_show ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_class ) ) . lc_lock as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_class ) , "::" ,
                stringify ! ( lc_lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_class ) ) . lc_owner as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_class ) , "::" ,
                stringify ! ( lc_owner ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_class ) ) . lc_unlock as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_class ) , "::" ,
                stringify ! ( lc_unlock ) ));
}
impl Clone for lock_class {
    fn clone(&self) -> Self { *self }
}
impl Default for lock_class {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    #[link_name = "lock_class_mtx_sleep"]
    pub static mut lock_class_mtx_sleep: lock_class;
}
extern "C" {
    #[link_name = "lock_class_mtx_spin"]
    pub static mut lock_class_mtx_spin: lock_class;
}
extern "C" {
    #[link_name = "lock_class_sx"]
    pub static mut lock_class_sx: lock_class;
}
extern "C" {
    #[link_name = "lock_class_rw"]
    pub static mut lock_class_rw: lock_class;
}
extern "C" {
    #[link_name = "lock_class_rm"]
    pub static mut lock_class_rm: lock_class;
}
extern "C" {
    #[link_name = "lock_class_rm_sleepable"]
    pub static mut lock_class_rm_sleepable: lock_class;
}
extern "C" {
    #[link_name = "lock_class_lockmgr"]
    pub static mut lock_class_lockmgr: lock_class;
}
extern "C" {
    #[link_name = "lock_classes"]
    pub static mut lock_classes: [*mut lock_class; 0usize];
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct lock_delay_config {
    pub base: u_int,
    pub max: u_int,
}
#[test]
fn bindgen_test_layout_lock_delay_config() {
    assert_eq!(::core::mem::size_of::<lock_delay_config>() , 8usize , concat !
               ( "Size of: " , stringify ! ( lock_delay_config ) ));
    assert_eq! (::core::mem::align_of::<lock_delay_config>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( lock_delay_config ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_delay_config ) ) . base as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_delay_config ) ,
                "::" , stringify ! ( base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_delay_config ) ) . max as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_delay_config ) ,
                "::" , stringify ! ( max ) ));
}
impl Clone for lock_delay_config {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lock_delay_arg {
    pub config: *mut lock_delay_config,
    pub delay: u_int,
    pub spin_cnt: u_int,
}
#[test]
fn bindgen_test_layout_lock_delay_arg() {
    assert_eq!(::core::mem::size_of::<lock_delay_arg>() , 16usize , concat ! (
               "Size of: " , stringify ! ( lock_delay_arg ) ));
    assert_eq! (::core::mem::align_of::<lock_delay_arg>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( lock_delay_arg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_delay_arg ) ) . config as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_delay_arg ) , "::"
                , stringify ! ( config ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_delay_arg ) ) . delay as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_delay_arg ) , "::"
                , stringify ! ( delay ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_delay_arg ) ) . spin_cnt as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_delay_arg ) , "::"
                , stringify ! ( spin_cnt ) ));
}
impl Clone for lock_delay_arg {
    fn clone(&self) -> Self { *self }
}
impl Default for lock_delay_arg {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    pub fn lock_init(arg1: *mut lock_object, arg2: *mut lock_class,
                     arg3: *const ::kernel::sys::raw::c_char,
                     arg4: *const ::kernel::sys::raw::c_char,
                     arg5: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn lock_destroy(arg1: *mut lock_object);
}
extern "C" {
    pub fn lock_delay(arg1: *mut lock_delay_arg);
}
extern "C" {
    pub fn lock_delay_default_init(arg1: *mut lock_delay_config);
}
extern "C" {
    pub fn spinlock_enter();
}
extern "C" {
    pub fn spinlock_exit();
}
extern "C" {
    pub fn witness_init(arg1: *mut lock_object,
                        arg2: *const ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn witness_destroy(arg1: *mut lock_object);
}
extern "C" {
    pub fn witness_defineorder(arg1: *mut lock_object, arg2: *mut lock_object)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn witness_checkorder(arg1: *mut lock_object,
                              arg2: ::kernel::sys::raw::c_int,
                              arg3: *const ::kernel::sys::raw::c_char,
                              arg4: ::kernel::sys::raw::c_int,
                              arg5: *mut lock_object);
}
extern "C" {
    pub fn witness_lock(arg1: *mut lock_object,
                        arg2: ::kernel::sys::raw::c_int,
                        arg3: *const ::kernel::sys::raw::c_char,
                        arg4: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn witness_upgrade(arg1: *mut lock_object,
                           arg2: ::kernel::sys::raw::c_int,
                           arg3: *const ::kernel::sys::raw::c_char,
                           arg4: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn witness_downgrade(arg1: *mut lock_object,
                             arg2: ::kernel::sys::raw::c_int,
                             arg3: *const ::kernel::sys::raw::c_char,
                             arg4: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn witness_unlock(arg1: *mut lock_object,
                          arg2: ::kernel::sys::raw::c_int,
                          arg3: *const ::kernel::sys::raw::c_char,
                          arg4: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn witness_save(arg1: *mut lock_object,
                        arg2: *mut *const ::kernel::sys::raw::c_char,
                        arg3: *mut ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn witness_restore(arg1: *mut lock_object,
                           arg2: *const ::kernel::sys::raw::c_char,
                           arg3: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn witness_list_locks(arg1: *mut *mut lock_list_entry,
                              arg2:
                                  ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                                  *const ::kernel::sys::raw::c_char, ...)
                                                             ->
                                                                 ::kernel::sys::raw::c_int>)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn witness_warn(arg1: ::kernel::sys::raw::c_int,
                        arg2: *mut lock_object,
                        arg3: *const ::kernel::sys::raw::c_char, ...)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn witness_assert(arg1: *const lock_object,
                          arg2: ::kernel::sys::raw::c_int,
                          arg3: *const ::kernel::sys::raw::c_char,
                          arg4: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn witness_display_spinlock(arg1: *mut lock_object, arg2: *mut thread,
                                    arg3:
                                        ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                                        *const ::kernel::sys::raw::c_char, ...)
                                                                   ->
                                                                       ::kernel::sys::raw::c_int>);
}
extern "C" {
    pub fn witness_line(arg1: *mut lock_object) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn witness_norelease(arg1: *mut lock_object);
}
extern "C" {
    pub fn witness_releaseok(arg1: *mut lock_object);
}
extern "C" {
    pub fn witness_file(arg1: *mut lock_object)
     -> *const ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn witness_thread_exit(arg1: *mut thread);
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct timezone {
    pub tz_minuteswest: ::kernel::sys::raw::c_int,
    pub tz_dsttime: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_timezone() {
    assert_eq!(::core::mem::size_of::<timezone>() , 8usize , concat ! (
               "Size of: " , stringify ! ( timezone ) ));
    assert_eq! (::core::mem::align_of::<timezone>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( timezone ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timezone ) ) . tz_minuteswest as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timezone ) , "::" ,
                stringify ! ( tz_minuteswest ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timezone ) ) . tz_dsttime as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( timezone ) , "::" ,
                stringify ! ( tz_dsttime ) ));
}
impl Clone for timezone {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct bintime {
    pub sec: time_t,
    pub frac: u64,
}
#[test]
fn bindgen_test_layout_bintime() {
    assert_eq!(::core::mem::size_of::<bintime>() , 16usize , concat ! (
               "Size of: " , stringify ! ( bintime ) ));
    assert_eq! (::core::mem::align_of::<bintime>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( bintime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bintime ) ) . sec as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( bintime ) , "::" ,
                stringify ! ( sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bintime ) ) . frac as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( bintime ) , "::" ,
                stringify ! ( frac ) ));
}
impl Clone for bintime {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
#[test]
fn bindgen_test_layout_itimerval() {
    assert_eq!(::core::mem::size_of::<itimerval>() , 32usize , concat ! (
               "Size of: " , stringify ! ( itimerval ) ));
    assert_eq! (::core::mem::align_of::<itimerval>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( itimerval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerval ) ) . it_interval as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerval ) , "::" ,
                stringify ! ( it_interval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerval ) ) . it_value as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerval ) , "::" ,
                stringify ! ( it_value ) ));
}
impl Clone for itimerval {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct clockinfo {
    pub hz: ::kernel::sys::raw::c_int,
    pub tick: ::kernel::sys::raw::c_int,
    pub spare: ::kernel::sys::raw::c_int,
    pub stathz: ::kernel::sys::raw::c_int,
    pub profhz: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_clockinfo() {
    assert_eq!(::core::mem::size_of::<clockinfo>() , 20usize , concat ! (
               "Size of: " , stringify ! ( clockinfo ) ));
    assert_eq! (::core::mem::align_of::<clockinfo>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( clockinfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clockinfo ) ) . hz as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( clockinfo ) , "::" ,
                stringify ! ( hz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clockinfo ) ) . tick as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( clockinfo ) , "::" ,
                stringify ! ( tick ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clockinfo ) ) . spare as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( clockinfo ) , "::" ,
                stringify ! ( spare ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clockinfo ) ) . stathz as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( clockinfo ) , "::" ,
                stringify ! ( stathz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clockinfo ) ) . profhz as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( clockinfo ) , "::" ,
                stringify ! ( profhz ) ));
}
impl Clone for clockinfo {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn inittodr(base: time_t);
}
extern "C" {
    pub fn resettodr();
}
extern "C" {
    #[link_name = "time_second"]
    pub static mut time_second: time_t;
}
extern "C" {
    #[link_name = "time_uptime"]
    pub static mut time_uptime: time_t;
}
extern "C" {
    #[link_name = "tc_tick_bt"]
    pub static mut tc_tick_bt: bintime;
}
extern "C" {
    #[link_name = "tc_tick_sbt"]
    pub static mut tc_tick_sbt: sbintime_t;
}
extern "C" {
    #[link_name = "tick_bt"]
    pub static mut tick_bt: bintime;
}
extern "C" {
    #[link_name = "tick_sbt"]
    pub static mut tick_sbt: sbintime_t;
}
extern "C" {
    #[link_name = "tc_precexp"]
    pub static mut tc_precexp: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "tc_timepercentage"]
    pub static mut tc_timepercentage: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "bt_timethreshold"]
    pub static mut bt_timethreshold: bintime;
}
extern "C" {
    #[link_name = "bt_tickthreshold"]
    pub static mut bt_tickthreshold: bintime;
}
extern "C" {
    #[link_name = "sbt_timethreshold"]
    pub static mut sbt_timethreshold: sbintime_t;
}
extern "C" {
    #[link_name = "sbt_tickthreshold"]
    pub static mut sbt_tickthreshold: sbintime_t;
}
extern "C" {
    #[link_name = "rtc_generation"]
    pub static mut rtc_generation: ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn binuptime(bt: *mut bintime);
}
extern "C" {
    pub fn nanouptime(tsp: *mut timespec);
}
extern "C" {
    pub fn microuptime(tvp: *mut timeval);
}
extern "C" {
    pub fn bintime(bt: *mut bintime);
}
extern "C" {
    pub fn nanotime(tsp: *mut timespec);
}
extern "C" {
    pub fn microtime(tvp: *mut timeval);
}
extern "C" {
    pub fn getbinuptime(bt: *mut bintime);
}
extern "C" {
    pub fn getnanouptime(tsp: *mut timespec);
}
extern "C" {
    pub fn getmicrouptime(tvp: *mut timeval);
}
extern "C" {
    pub fn getbintime(bt: *mut bintime);
}
extern "C" {
    pub fn getnanotime(tsp: *mut timespec);
}
extern "C" {
    pub fn getmicrotime(tvp: *mut timeval);
}
extern "C" {
    pub fn getboottime(boottime: *mut timeval);
}
extern "C" {
    pub fn getboottimebin(boottimebin: *mut bintime);
}
extern "C" {
    pub fn itimerdecr(itp: *mut itimerval, usec: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn itimerfix(tv: *mut timeval) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn ppsratecheck(arg1: *mut timeval,
                        arg2: *mut ::kernel::sys::raw::c_int,
                        arg3: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn ratecheck(arg1: *mut timeval, arg2: *const timeval)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn timevaladd(t1: *mut timeval, t2: *const timeval);
}
extern "C" {
    pub fn timevalsub(t1: *mut timeval, t2: *const timeval);
}
extern "C" {
    pub fn tvtohz(tv: *mut timeval) -> ::kernel::sys::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct priority {
    pub pri_class: u_char,
    pub pri_level: u_char,
    pub pri_native: u_char,
    pub pri_user: u_char,
}
#[test]
fn bindgen_test_layout_priority() {
    assert_eq!(::core::mem::size_of::<priority>() , 4usize , concat ! (
               "Size of: " , stringify ! ( priority ) ));
    assert_eq! (::core::mem::align_of::<priority>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( priority ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const priority ) ) . pri_class as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( priority ) , "::" ,
                stringify ! ( pri_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const priority ) ) . pri_level as * const _ as
                usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( priority ) , "::" ,
                stringify ! ( pri_level ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const priority ) ) . pri_native as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( priority ) , "::" ,
                stringify ! ( pri_native ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const priority ) ) . pri_user as * const _ as
                usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( priority ) , "::" ,
                stringify ! ( pri_user ) ));
}
impl Clone for priority {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn htonl(arg1: __uint32_t) -> __uint32_t;
}
extern "C" {
    pub fn htons(arg1: __uint16_t) -> __uint16_t;
}
extern "C" {
    pub fn ntohl(arg1: __uint32_t) -> __uint32_t;
}
extern "C" {
    pub fn ntohs(arg1: __uint16_t) -> __uint16_t;
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct bitset {
    pub __bits: [::kernel::sys::raw::c_long; 1usize],
}
#[test]
fn bindgen_test_layout_bitset() {
    assert_eq!(::core::mem::size_of::<bitset>() , 8usize , concat ! (
               "Size of: " , stringify ! ( bitset ) ));
    assert_eq! (::core::mem::align_of::<bitset>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( bitset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bitset ) ) . __bits as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( bitset ) , "::" ,
                stringify ! ( __bits ) ));
}
impl Clone for bitset {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct _cpuset {
    pub __bits: [::kernel::sys::raw::c_long; 4usize],
}
#[test]
fn bindgen_test_layout__cpuset() {
    assert_eq!(::core::mem::size_of::<_cpuset>() , 32usize , concat ! (
               "Size of: " , stringify ! ( _cpuset ) ));
    assert_eq! (::core::mem::align_of::<_cpuset>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _cpuset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _cpuset ) ) . __bits as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _cpuset ) , "::" ,
                stringify ! ( __bits ) ));
}
impl Clone for _cpuset {
    fn clone(&self) -> Self { *self }
}
pub type cpuset_t = _cpuset;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ktr_entry {
    pub ktr_timestamp: u_int64_t,
    pub ktr_cpu: ::kernel::sys::raw::c_int,
    pub ktr_line: ::kernel::sys::raw::c_int,
    pub ktr_file: *const ::kernel::sys::raw::c_char,
    pub ktr_desc: *const ::kernel::sys::raw::c_char,
    pub ktr_thread: *mut thread,
    pub ktr_parms: [u_long; 6usize],
}
#[test]
fn bindgen_test_layout_ktr_entry() {
    assert_eq!(::core::mem::size_of::<ktr_entry>() , 88usize , concat ! (
               "Size of: " , stringify ! ( ktr_entry ) ));
    assert_eq! (::core::mem::align_of::<ktr_entry>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ktr_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ktr_entry ) ) . ktr_timestamp as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ktr_entry ) , "::" ,
                stringify ! ( ktr_timestamp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ktr_entry ) ) . ktr_cpu as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ktr_entry ) , "::" ,
                stringify ! ( ktr_cpu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ktr_entry ) ) . ktr_line as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( ktr_entry ) , "::" ,
                stringify ! ( ktr_line ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ktr_entry ) ) . ktr_file as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ktr_entry ) , "::" ,
                stringify ! ( ktr_file ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ktr_entry ) ) . ktr_desc as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ktr_entry ) , "::" ,
                stringify ! ( ktr_desc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ktr_entry ) ) . ktr_thread as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( ktr_entry ) , "::" ,
                stringify ! ( ktr_thread ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ktr_entry ) ) . ktr_parms as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( ktr_entry ) , "::" ,
                stringify ! ( ktr_parms ) ));
}
impl Clone for ktr_entry {
    fn clone(&self) -> Self { *self }
}
impl Default for ktr_entry {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    #[link_name = "ktr_cpumask"]
    pub static mut ktr_cpumask: cpuset_t;
}
extern "C" {
    #[link_name = "ktr_mask"]
    pub static mut ktr_mask: u64;
}
extern "C" {
    #[link_name = "ktr_entries"]
    pub static mut ktr_entries: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "ktr_verbose"]
    pub static mut ktr_verbose: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "ktr_idx"]
    pub static mut ktr_idx: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "ktr_buf"]
    pub static mut ktr_buf: *mut ktr_entry;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mtx {
    pub lock_object: lock_object,
    pub mtx_lock: usize,
}
#[test]
fn bindgen_test_layout_mtx() {
    assert_eq!(::core::mem::size_of::<mtx>() , 32usize , concat ! (
               "Size of: " , stringify ! ( mtx ) ));
    assert_eq! (::core::mem::align_of::<mtx>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( mtx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mtx ) ) . lock_object as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mtx ) , "::" ,
                stringify ! ( lock_object ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mtx ) ) . mtx_lock as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( mtx ) , "::" ,
                stringify ! ( mtx_lock ) ));
}
impl Clone for mtx {
    fn clone(&self) -> Self { *self }
}
impl Default for mtx {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct mtx_padalign {
    pub lock_object: lock_object,
    pub mtx_lock: usize,
    pub __bindgen_padding_0: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_mtx_padalign() {
    assert_eq!(::core::mem::size_of::<mtx_padalign>() , 64usize , concat ! (
               "Size of: " , stringify ! ( mtx_padalign ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mtx_padalign ) ) . lock_object as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mtx_padalign ) , "::" ,
                stringify ! ( lock_object ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mtx_padalign ) ) . mtx_lock as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( mtx_padalign ) , "::" ,
                stringify ! ( mtx_lock ) ));
}
impl Clone for mtx_padalign {
    fn clone(&self) -> Self { *self }
}
impl Default for mtx_padalign {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for mtx_padalign {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "mtx_padalign {{ lock_object: {:?}, mtx_lock: {:?} }}" ,
               self . lock_object , self . mtx_lock)
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sx {
    pub lock_object: lock_object,
    pub sx_lock: usize,
}
#[test]
fn bindgen_test_layout_sx() {
    assert_eq!(::core::mem::size_of::<sx>() , 32usize , concat ! (
               "Size of: " , stringify ! ( sx ) ));
    assert_eq! (::core::mem::align_of::<sx>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sx ) ) . lock_object as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sx ) , "::" , stringify
                ! ( lock_object ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sx ) ) . sx_lock as * const _ as usize }
                , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( sx ) , "::" , stringify
                ! ( sx_lock ) ));
}
impl Clone for sx {
    fn clone(&self) -> Self { *self }
}
impl Default for sx {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rmpriolist {
    pub lh_first: *mut rm_priotracker,
}
#[test]
fn bindgen_test_layout_rmpriolist() {
    assert_eq!(::core::mem::size_of::<rmpriolist>() , 8usize , concat ! (
               "Size of: " , stringify ! ( rmpriolist ) ));
    assert_eq! (::core::mem::align_of::<rmpriolist>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rmpriolist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmpriolist ) ) . lh_first as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rmpriolist ) , "::" ,
                stringify ! ( lh_first ) ));
}
impl Clone for rmpriolist {
    fn clone(&self) -> Self { *self }
}
impl Default for rmpriolist {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rm_queue {
    pub rmq_next: *mut rm_queue,
    pub rmq_prev: *mut rm_queue,
}
#[test]
fn bindgen_test_layout_rm_queue() {
    assert_eq!(::core::mem::size_of::<rm_queue>() , 16usize , concat ! (
               "Size of: " , stringify ! ( rm_queue ) ));
    assert_eq! (::core::mem::align_of::<rm_queue>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rm_queue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rm_queue ) ) . rmq_next as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rm_queue ) , "::" ,
                stringify ! ( rmq_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rm_queue ) ) . rmq_prev as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rm_queue ) , "::" ,
                stringify ! ( rmq_prev ) ));
}
impl Clone for rm_queue {
    fn clone(&self) -> Self { *self }
}
impl Default for rm_queue {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct rmlock {
    pub lock_object: lock_object,
    pub rm_writecpus: cpuset_t,
    pub rm_activeReaders: rmlock__bindgen_ty_1,
    pub _rm_lock: rmlock__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rmlock__bindgen_ty_1 {
    pub lh_first: *mut rm_priotracker,
}
#[test]
fn bindgen_test_layout_rmlock__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<rmlock__bindgen_ty_1>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( rmlock__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<rmlock__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rmlock__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmlock__bindgen_ty_1 ) ) . lh_first as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rmlock__bindgen_ty_1 )
                , "::" , stringify ! ( lh_first ) ));
}
impl Clone for rmlock__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for rmlock__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub union rmlock__bindgen_ty_2 {
    pub _rm_wlock_object: lock_object,
    pub _rm_lock_mtx: mtx,
    pub _rm_lock_sx: sx,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_rmlock__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<rmlock__bindgen_ty_2>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( rmlock__bindgen_ty_2 )
               ));
    assert_eq! (::core::mem::align_of::<rmlock__bindgen_ty_2>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rmlock__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmlock__bindgen_ty_2 ) ) .
                _rm_wlock_object as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rmlock__bindgen_ty_2 )
                , "::" , stringify ! ( _rm_wlock_object ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmlock__bindgen_ty_2 ) ) . _rm_lock_mtx
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rmlock__bindgen_ty_2 )
                , "::" , stringify ! ( _rm_lock_mtx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmlock__bindgen_ty_2 ) ) . _rm_lock_sx as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rmlock__bindgen_ty_2 )
                , "::" , stringify ! ( _rm_lock_sx ) ));
}
impl Clone for rmlock__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for rmlock__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for rmlock__bindgen_ty_2 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "rmlock__bindgen_ty_2 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_rmlock() {
    assert_eq!(::core::mem::size_of::<rmlock>() , 96usize , concat ! (
               "Size of: " , stringify ! ( rmlock ) ));
    assert_eq! (::core::mem::align_of::<rmlock>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rmlock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmlock ) ) . lock_object as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rmlock ) , "::" ,
                stringify ! ( lock_object ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmlock ) ) . rm_writecpus as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rmlock ) , "::" ,
                stringify ! ( rm_writecpus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmlock ) ) . rm_activeReaders as * const
                _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( rmlock ) , "::" ,
                stringify ! ( rm_activeReaders ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmlock ) ) . _rm_lock as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( rmlock ) , "::" ,
                stringify ! ( _rm_lock ) ));
}
impl Clone for rmlock {
    fn clone(&self) -> Self { *self }
}
impl Default for rmlock {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for rmlock {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "rmlock {{ lock_object: {:?}, rm_writecpus: {:?}, rm_activeReaders: {:?}, _rm_lock: {:?} }}"
               , self . lock_object , self . rm_writecpus , self .
               rm_activeReaders , self . _rm_lock)
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rm_priotracker {
    pub rmp_cpuQueue: rm_queue,
    pub rmp_rmlock: *mut rmlock,
    pub rmp_thread: *mut thread,
    pub rmp_flags: ::kernel::sys::raw::c_int,
    pub rmp_qentry: rm_priotracker__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rm_priotracker__bindgen_ty_1 {
    pub le_next: *mut rm_priotracker,
    pub le_prev: *mut *mut rm_priotracker,
}
#[test]
fn bindgen_test_layout_rm_priotracker__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<rm_priotracker__bindgen_ty_1>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( rm_priotracker__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<rm_priotracker__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( rm_priotracker__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rm_priotracker__bindgen_ty_1 ) ) .
                le_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rm_priotracker__bindgen_ty_1 ) , "::" , stringify ! ( le_next
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rm_priotracker__bindgen_ty_1 ) ) .
                le_prev as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                rm_priotracker__bindgen_ty_1 ) , "::" , stringify ! ( le_prev
                ) ));
}
impl Clone for rm_priotracker__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for rm_priotracker__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_rm_priotracker() {
    assert_eq!(::core::mem::size_of::<rm_priotracker>() , 56usize , concat ! (
               "Size of: " , stringify ! ( rm_priotracker ) ));
    assert_eq! (::core::mem::align_of::<rm_priotracker>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( rm_priotracker ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rm_priotracker ) ) . rmp_cpuQueue as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rm_priotracker ) , "::"
                , stringify ! ( rmp_cpuQueue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rm_priotracker ) ) . rmp_rmlock as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rm_priotracker ) , "::"
                , stringify ! ( rmp_rmlock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rm_priotracker ) ) . rmp_thread as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rm_priotracker ) , "::"
                , stringify ! ( rmp_thread ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rm_priotracker ) ) . rmp_flags as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rm_priotracker ) , "::"
                , stringify ! ( rmp_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rm_priotracker ) ) . rmp_qentry as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rm_priotracker ) , "::"
                , stringify ! ( rmp_qentry ) ));
}
impl Clone for rm_priotracker {
    fn clone(&self) -> Self { *self }
}
impl Default for rm_priotracker {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct rusage {
    pub ru_utime: timeval,
    pub ru_stime: timeval,
    pub ru_maxrss: ::kernel::sys::raw::c_long,
    pub ru_ixrss: ::kernel::sys::raw::c_long,
    pub ru_idrss: ::kernel::sys::raw::c_long,
    pub ru_isrss: ::kernel::sys::raw::c_long,
    pub ru_minflt: ::kernel::sys::raw::c_long,
    pub ru_majflt: ::kernel::sys::raw::c_long,
    pub ru_nswap: ::kernel::sys::raw::c_long,
    pub ru_inblock: ::kernel::sys::raw::c_long,
    pub ru_oublock: ::kernel::sys::raw::c_long,
    pub ru_msgsnd: ::kernel::sys::raw::c_long,
    pub ru_msgrcv: ::kernel::sys::raw::c_long,
    pub ru_nsignals: ::kernel::sys::raw::c_long,
    pub ru_nvcsw: ::kernel::sys::raw::c_long,
    pub ru_nivcsw: ::kernel::sys::raw::c_long,
}
#[test]
fn bindgen_test_layout_rusage() {
    assert_eq!(::core::mem::size_of::<rusage>() , 144usize , concat ! (
               "Size of: " , stringify ! ( rusage ) ));
    assert_eq! (::core::mem::align_of::<rusage>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rusage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_utime as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_utime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_stime as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_stime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_maxrss as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_maxrss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_ixrss as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_ixrss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_idrss as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_idrss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_isrss as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_isrss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_minflt as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_minflt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_majflt as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_majflt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_nswap as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_nswap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_inblock as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_inblock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_oublock as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_oublock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_msgsnd as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_msgsnd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_msgrcv as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_msgrcv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_nsignals as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_nsignals ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_nvcsw as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_nvcsw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_nivcsw as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_nivcsw ) ));
}
impl Clone for rusage {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct __wrusage {
    pub wru_self: rusage,
    pub wru_children: rusage,
}
#[test]
fn bindgen_test_layout___wrusage() {
    assert_eq!(::core::mem::size_of::<__wrusage>() , 288usize , concat ! (
               "Size of: " , stringify ! ( __wrusage ) ));
    assert_eq! (::core::mem::align_of::<__wrusage>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __wrusage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __wrusage ) ) . wru_self as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __wrusage ) , "::" ,
                stringify ! ( wru_self ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __wrusage ) ) . wru_children as * const _
                as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( __wrusage ) , "::" ,
                stringify ! ( wru_children ) ));
}
impl Clone for __wrusage {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct rlimit {
    pub rlim_cur: rlim_t,
    pub rlim_max: rlim_t,
}
#[test]
fn bindgen_test_layout_rlimit() {
    assert_eq!(::core::mem::size_of::<rlimit>() , 16usize , concat ! (
               "Size of: " , stringify ! ( rlimit ) ));
    assert_eq! (::core::mem::align_of::<rlimit>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rlimit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rlimit ) ) . rlim_cur as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rlimit ) , "::" ,
                stringify ! ( rlim_cur ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rlimit ) ) . rlim_max as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rlimit ) , "::" ,
                stringify ! ( rlim_max ) ));
}
impl Clone for rlimit {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct orlimit {
    pub rlim_cur: __int32_t,
    pub rlim_max: __int32_t,
}
#[test]
fn bindgen_test_layout_orlimit() {
    assert_eq!(::core::mem::size_of::<orlimit>() , 8usize , concat ! (
               "Size of: " , stringify ! ( orlimit ) ));
    assert_eq! (::core::mem::align_of::<orlimit>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( orlimit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const orlimit ) ) . rlim_cur as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( orlimit ) , "::" ,
                stringify ! ( rlim_cur ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const orlimit ) ) . rlim_max as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( orlimit ) , "::" ,
                stringify ! ( rlim_max ) ));
}
impl Clone for orlimit {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct loadavg {
    pub ldavg: [__fixpt_t; 3usize],
    pub fscale: ::kernel::sys::raw::c_long,
}
#[test]
fn bindgen_test_layout_loadavg() {
    assert_eq!(::core::mem::size_of::<loadavg>() , 24usize , concat ! (
               "Size of: " , stringify ! ( loadavg ) ));
    assert_eq! (::core::mem::align_of::<loadavg>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( loadavg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const loadavg ) ) . ldavg as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( loadavg ) , "::" ,
                stringify ! ( ldavg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const loadavg ) ) . fscale as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( loadavg ) , "::" ,
                stringify ! ( fscale ) ));
}
impl Clone for loadavg {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "averunnable"]
    pub static mut averunnable: loadavg;
}
extern "C" {
    pub fn read_cpu_time(cp_time: *mut ::kernel::sys::raw::c_long);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcb {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "__start_set_pcpu"]
    pub static mut __start_set_pcpu: *mut usize;
}
extern "C" {
    #[link_name = "__stop_set_pcpu"]
    pub static mut __stop_set_pcpu: *mut usize;
}
extern "C" {
    #[link_name = "dpcpu_off"]
    pub static mut dpcpu_off: [usize; 0usize];
}
#[repr(C)]
#[derive(Copy)]
pub struct pcpu {
    pub pc_curthread: *mut thread,
    pub pc_idlethread: *mut thread,
    pub pc_fpcurthread: *mut thread,
    pub pc_deadthread: *mut thread,
    pub pc_curpcb: *mut pcb,
    pub pc_switchtime: u64,
    pub pc_switchticks: ::kernel::sys::raw::c_int,
    pub pc_cpuid: u_int,
    pub pc_allcpu: pcpu__bindgen_ty_1,
    pub pc_spinlocks: *mut lock_list_entry,
    pub pc_cp_time: [::kernel::sys::raw::c_long; 5usize],
    pub pc_device: *mut device,
    pub pc_netisr: *mut ::kernel::sys::raw::c_void,
    pub pc_unused1: ::kernel::sys::raw::c_int,
    pub pc_domain: ::kernel::sys::raw::c_int,
    pub pc_rm_queue: rm_queue,
    pub pc_dynamic: usize,
    pub pc_early_dummy_counter: u64,
    pub __bindgen_padding_0: [u8; 88usize],
    pub pc_monitorbuf: [::kernel::sys::raw::c_char; 128usize],
    pub pc_prvspace: *mut pcpu,
    pub pc_curpmap: *mut pmap,
    pub pc_tssp: *mut amd64tss,
    pub pc_commontssp: *mut amd64tss,
    pub pc_kcr3: u64,
    pub pc_ucr3: u64,
    pub pc_saved_ucr3: u64,
    pub pc_rsp0: register_t,
    pub pc_scratch_rsp: register_t,
    pub pc_scratch_rax: register_t,
    pub pc_apic_id: u_int,
    pub pc_acpi_id: u_int,
    pub pc_fs32p: *mut user_segment_descriptor,
    pub pc_gs32p: *mut user_segment_descriptor,
    pub pc_ldt: *mut system_segment_descriptor,
    pub pc_tss: *mut system_segment_descriptor,
    pub pc_pm_save_cnt: u64,
    pub pc_cmci_mask: u_int,
    pub pc_dbreg: [u64; 16usize],
    pub pc_pti_stack: [u64; 16usize],
    pub pc_pti_rsp0: register_t,
    pub pc_dbreg_cmd: ::kernel::sys::raw::c_int,
    pub pc_vcpu_id: u_int,
    pub pc_pcid_next: u32,
    pub pc_pcid_gen: u32,
    pub pc_smp_tlb_done: u32,
    pub pc_ibpb_set: u32,
    pub __pad: [::kernel::sys::raw::c_char; 216usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pcpu__bindgen_ty_1 {
    pub stqe_next: *mut pcpu,
}
#[test]
fn bindgen_test_layout_pcpu__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<pcpu__bindgen_ty_1>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( pcpu__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<pcpu__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( pcpu__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu__bindgen_ty_1 ) ) . stqe_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu__bindgen_ty_1 ) ,
                "::" , stringify ! ( stqe_next ) ));
}
impl Clone for pcpu__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for pcpu__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_pcpu() {
    assert_eq!(::core::mem::size_of::<pcpu>() , 1024usize , concat ! (
               "Size of: " , stringify ! ( pcpu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_curthread as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_curthread ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_idlethread as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_idlethread ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_fpcurthread as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_fpcurthread ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_deadthread as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_deadthread ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_curpcb as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_curpcb ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_switchtime as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_switchtime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_switchticks as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_switchticks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_cpuid as * const _ as usize
                } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_cpuid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_allcpu as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_allcpu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_spinlocks as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_spinlocks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_cp_time as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_cp_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_device as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_device ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_netisr as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_netisr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_unused1 as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_unused1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_domain as * const _ as
                usize } , 132usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_domain ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_rm_queue as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_rm_queue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_dynamic as * const _ as
                usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_dynamic ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_early_dummy_counter as *
                const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_early_dummy_counter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_monitorbuf as * const _ as
                usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_monitorbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_prvspace as * const _ as
                usize } , 384usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_prvspace ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_curpmap as * const _ as
                usize } , 392usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_curpmap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_tssp as * const _ as usize
                } , 400usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_tssp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_commontssp as * const _ as
                usize } , 408usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_commontssp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_kcr3 as * const _ as usize
                } , 416usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_kcr3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_ucr3 as * const _ as usize
                } , 424usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_ucr3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_saved_ucr3 as * const _ as
                usize } , 432usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_saved_ucr3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_rsp0 as * const _ as usize
                } , 440usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_rsp0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_scratch_rsp as * const _ as
                usize } , 448usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_scratch_rsp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_scratch_rax as * const _ as
                usize } , 456usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_scratch_rax ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_apic_id as * const _ as
                usize } , 464usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_apic_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_acpi_id as * const _ as
                usize } , 468usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_acpi_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_fs32p as * const _ as usize
                } , 472usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_fs32p ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_gs32p as * const _ as usize
                } , 480usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_gs32p ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_ldt as * const _ as usize }
                , 488usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_ldt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_tss as * const _ as usize }
                , 496usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_tss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_pm_save_cnt as * const _ as
                usize } , 504usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_pm_save_cnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_cmci_mask as * const _ as
                usize } , 512usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_cmci_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_dbreg as * const _ as usize
                } , 520usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_dbreg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_pti_stack as * const _ as
                usize } , 648usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_pti_stack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_pti_rsp0 as * const _ as
                usize } , 776usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_pti_rsp0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_dbreg_cmd as * const _ as
                usize } , 784usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_dbreg_cmd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_vcpu_id as * const _ as
                usize } , 788usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_vcpu_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_pcid_next as * const _ as
                usize } , 792usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_pcid_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_pcid_gen as * const _ as
                usize } , 796usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_pcid_gen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_smp_tlb_done as * const _
                as usize } , 800usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_smp_tlb_done ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_ibpb_set as * const _ as
                usize } , 804usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_ibpb_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . __pad as * const _ as usize }
                , 808usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( __pad ) ));
}
impl Clone for pcpu {
    fn clone(&self) -> Self { *self }
}
impl Default for pcpu {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for pcpu {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "pcpu {{ pc_curthread: {:?}, pc_idlethread: {:?}, pc_fpcurthread: {:?}, pc_deadthread: {:?}, pc_curpcb: {:?}, pc_switchtime: {:?}, pc_switchticks: {:?}, pc_cpuid: {:?}, pc_allcpu: {:?}, pc_spinlocks: {:?}, pc_cp_time: {:?}, pc_device: {:?}, pc_netisr: {:?}, pc_unused1: {:?}, pc_domain: {:?}, pc_rm_queue: {:?}, pc_dynamic: {:?}, pc_early_dummy_counter: {:?}, pc_monitorbuf: [{}], pc_prvspace: {:?}, pc_curpmap: {:?}, pc_tssp: {:?}, pc_commontssp: {:?}, pc_kcr3: {:?}, pc_ucr3: {:?}, pc_saved_ucr3: {:?}, pc_rsp0: {:?}, pc_scratch_rsp: {:?}, pc_scratch_rax: {:?}, pc_apic_id: {:?}, pc_acpi_id: {:?}, pc_fs32p: {:?}, pc_gs32p: {:?}, pc_ldt: {:?}, pc_tss: {:?}, pc_pm_save_cnt: {:?}, pc_cmci_mask: {:?}, pc_dbreg: {:?}, pc_pti_stack: {:?}, pc_pti_rsp0: {:?}, pc_dbreg_cmd: {:?}, pc_vcpu_id: {:?}, pc_pcid_next: {:?}, pc_pcid_gen: {:?}, pc_smp_tlb_done: {:?}, pc_ibpb_set: {:?}, __pad: [{}] }}"
               , self . pc_curthread , self . pc_idlethread , self .
               pc_fpcurthread , self . pc_deadthread , self . pc_curpcb , self
               . pc_switchtime , self . pc_switchticks , self . pc_cpuid ,
               self . pc_allcpu , self . pc_spinlocks , self . pc_cp_time ,
               self . pc_device , self . pc_netisr , self . pc_unused1 , self
               . pc_domain , self . pc_rm_queue , self . pc_dynamic , self .
               pc_early_dummy_counter , self . pc_monitorbuf . iter (  ) .
               enumerate (  ) . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ) , self . pc_prvspace , self . pc_curpmap , self .
               pc_tssp , self . pc_commontssp , self . pc_kcr3 , self .
               pc_ucr3 , self . pc_saved_ucr3 , self . pc_rsp0 , self .
               pc_scratch_rsp , self . pc_scratch_rax , self . pc_apic_id ,
               self . pc_acpi_id , self . pc_fs32p , self . pc_gs32p , self .
               pc_ldt , self . pc_tss , self . pc_pm_save_cnt , self .
               pc_cmci_mask , self . pc_dbreg , self . pc_pti_stack , self .
               pc_pti_rsp0 , self . pc_dbreg_cmd , self . pc_vcpu_id , self .
               pc_pcid_next , self . pc_pcid_gen , self . pc_smp_tlb_done ,
               self . pc_ibpb_set , self . __pad . iter (  ) . enumerate (  )
               . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ))
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cpuhead {
    pub stqh_first: *mut pcpu,
    pub stqh_last: *mut *mut pcpu,
}
#[test]
fn bindgen_test_layout_cpuhead() {
    assert_eq!(::core::mem::size_of::<cpuhead>() , 16usize , concat ! (
               "Size of: " , stringify ! ( cpuhead ) ));
    assert_eq! (::core::mem::align_of::<cpuhead>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( cpuhead ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuhead ) ) . stqh_first as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuhead ) , "::" ,
                stringify ! ( stqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuhead ) ) . stqh_last as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuhead ) , "::" ,
                stringify ! ( stqh_last ) ));
}
impl Clone for cpuhead {
    fn clone(&self) -> Self { *self }
}
impl Default for cpuhead {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    #[link_name = "cpuhead"]
    pub static mut cpuhead: cpuhead;
}
extern "C" {
    #[link_name = "cpuid_to_pcpu"]
    pub static mut cpuid_to_pcpu: [*mut pcpu; 0usize];
}
extern "C" {
    pub fn cpu_pcpu_init(pcpu: *mut pcpu, cpuid: ::kernel::sys::raw::c_int,
                         size: usize);
}
extern "C" {
    pub fn db_show_mdpcpu(pcpu: *mut pcpu);
}
extern "C" {
    pub fn dpcpu_alloc(size: ::kernel::sys::raw::c_int)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn dpcpu_copy(s: *mut ::kernel::sys::raw::c_void,
                      size: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn dpcpu_free(s: *mut ::kernel::sys::raw::c_void,
                      size: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn dpcpu_init(dpcpu: *mut ::kernel::sys::raw::c_void,
                      cpuid: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn pcpu_destroy(pcpu: *mut pcpu);
}
extern "C" {
    pub fn pcpu_find(cpuid: u_int) -> *mut pcpu;
}
extern "C" {
    pub fn pcpu_init(pcpu: *mut pcpu, cpuid: ::kernel::sys::raw::c_int,
                     size: usize);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lock_profile_object {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lpohead {
    pub lh_first: *mut lock_profile_object,
}
#[test]
fn bindgen_test_layout_lpohead() {
    assert_eq!(::core::mem::size_of::<lpohead>() , 8usize , concat ! (
               "Size of: " , stringify ! ( lpohead ) ));
    assert_eq! (::core::mem::align_of::<lpohead>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lpohead ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lpohead ) ) . lh_first as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lpohead ) , "::" ,
                stringify ! ( lh_first ) ));
}
impl Clone for lpohead {
    fn clone(&self) -> Self { *self }
}
impl Default for lpohead {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    #[link_name = "sdt_probes_enabled"]
    pub static mut sdt_probes_enabled: bool_;
}
pub type sdt_probe_func_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: u32, arg0: usize,
                                                arg1: usize, arg2: usize,
                                                arg3: usize, arg4: usize)>;
extern "C" {
    #[link_name = "sdt_probe_func"]
    pub static mut sdt_probe_func: sdt_probe_func_t;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sdt_probe {
    pub version: ::kernel::sys::raw::c_int,
    pub prov: *mut sdt_provider,
    pub probe_entry: sdt_probe__bindgen_ty_1,
    pub argtype_list: sdt_probe__bindgen_ty_2,
    pub mod_: *const ::kernel::sys::raw::c_char,
    pub func: *const ::kernel::sys::raw::c_char,
    pub name: *const ::kernel::sys::raw::c_char,
    pub id: id_t,
    pub n_args: ::kernel::sys::raw::c_int,
    pub sdtp_lf: *mut linker_file,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sdt_probe__bindgen_ty_1 {
    pub tqe_next: *mut sdt_probe,
    pub tqe_prev: *mut *mut sdt_probe,
}
#[test]
fn bindgen_test_layout_sdt_probe__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<sdt_probe__bindgen_ty_1>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( sdt_probe__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<sdt_probe__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( sdt_probe__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe__bindgen_ty_1 ) ) . tqe_next as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe__bindgen_ty_1
                ) , "::" , stringify ! ( tqe_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe__bindgen_ty_1 ) ) . tqe_prev as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe__bindgen_ty_1
                ) , "::" , stringify ! ( tqe_prev ) ));
}
impl Clone for sdt_probe__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for sdt_probe__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sdt_probe__bindgen_ty_2 {
    pub tqh_first: *mut sdt_argtype,
    pub tqh_last: *mut *mut sdt_argtype,
}
#[test]
fn bindgen_test_layout_sdt_probe__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<sdt_probe__bindgen_ty_2>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( sdt_probe__bindgen_ty_2 ) ));
    assert_eq! (::core::mem::align_of::<sdt_probe__bindgen_ty_2>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( sdt_probe__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe__bindgen_ty_2 ) ) . tqh_first
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe__bindgen_ty_2
                ) , "::" , stringify ! ( tqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe__bindgen_ty_2 ) ) . tqh_last as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe__bindgen_ty_2
                ) , "::" , stringify ! ( tqh_last ) ));
}
impl Clone for sdt_probe__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for sdt_probe__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_sdt_probe() {
    assert_eq!(::core::mem::size_of::<sdt_probe>() , 96usize , concat ! (
               "Size of: " , stringify ! ( sdt_probe ) ));
    assert_eq! (::core::mem::align_of::<sdt_probe>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sdt_probe ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . version as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . prov as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( prov ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . probe_entry as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( probe_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . argtype_list as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( argtype_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . mod_ as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( mod_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . func as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . name as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . id as * const _ as usize
                } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . n_args as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( n_args ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . sdtp_lf as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( sdtp_lf ) ));
}
impl Clone for sdt_probe {
    fn clone(&self) -> Self { *self }
}
impl Default for sdt_probe {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sdt_provider {
    pub name: *mut ::kernel::sys::raw::c_char,
    pub prov_entry: sdt_provider__bindgen_ty_1,
    pub id: usize,
    pub sdt_refs: ::kernel::sys::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sdt_provider__bindgen_ty_1 {
    pub tqe_next: *mut sdt_provider,
    pub tqe_prev: *mut *mut sdt_provider,
}
#[test]
fn bindgen_test_layout_sdt_provider__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<sdt_provider__bindgen_ty_1>() , 16usize
               , concat ! (
               "Size of: " , stringify ! ( sdt_provider__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<sdt_provider__bindgen_ty_1>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( sdt_provider__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_provider__bindgen_ty_1 ) ) . tqe_next
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                sdt_provider__bindgen_ty_1 ) , "::" , stringify ! ( tqe_next )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_provider__bindgen_ty_1 ) ) . tqe_prev
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                sdt_provider__bindgen_ty_1 ) , "::" , stringify ! ( tqe_prev )
                ));
}
impl Clone for sdt_provider__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for sdt_provider__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_sdt_provider() {
    assert_eq!(::core::mem::size_of::<sdt_provider>() , 40usize , concat ! (
               "Size of: " , stringify ! ( sdt_provider ) ));
    assert_eq! (::core::mem::align_of::<sdt_provider>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sdt_provider ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_provider ) ) . name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_provider ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_provider ) ) . prov_entry as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_provider ) , "::" ,
                stringify ! ( prov_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_provider ) ) . id as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_provider ) , "::" ,
                stringify ! ( id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_provider ) ) . sdt_refs as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_provider ) , "::" ,
                stringify ! ( sdt_refs ) ));
}
impl Clone for sdt_provider {
    fn clone(&self) -> Self { *self }
}
impl Default for sdt_provider {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct linker_file {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sdt_argtype {
    pub ndx: ::kernel::sys::raw::c_int,
    pub type_: *const ::kernel::sys::raw::c_char,
    pub xtype: *const ::kernel::sys::raw::c_char,
    pub argtype_entry: sdt_argtype__bindgen_ty_1,
    pub probe: *mut sdt_probe,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sdt_argtype__bindgen_ty_1 {
    pub tqe_next: *mut sdt_argtype,
    pub tqe_prev: *mut *mut sdt_argtype,
}
#[test]
fn bindgen_test_layout_sdt_argtype__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<sdt_argtype__bindgen_ty_1>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( sdt_argtype__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<sdt_argtype__bindgen_ty_1>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( sdt_argtype__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_argtype__bindgen_ty_1 ) ) . tqe_next
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                sdt_argtype__bindgen_ty_1 ) , "::" , stringify ! ( tqe_next )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_argtype__bindgen_ty_1 ) ) . tqe_prev
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                sdt_argtype__bindgen_ty_1 ) , "::" , stringify ! ( tqe_prev )
                ));
}
impl Clone for sdt_argtype__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for sdt_argtype__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_sdt_argtype() {
    assert_eq!(::core::mem::size_of::<sdt_argtype>() , 48usize , concat ! (
               "Size of: " , stringify ! ( sdt_argtype ) ));
    assert_eq! (::core::mem::align_of::<sdt_argtype>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sdt_argtype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_argtype ) ) . ndx as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_argtype ) , "::" ,
                stringify ! ( ndx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_argtype ) ) . type_ as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_argtype ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_argtype ) ) . xtype as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_argtype ) , "::" ,
                stringify ! ( xtype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_argtype ) ) . argtype_entry as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_argtype ) , "::" ,
                stringify ! ( argtype_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_argtype ) ) . probe as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_argtype ) , "::" ,
                stringify ! ( probe ) ));
}
impl Clone for sdt_argtype {
    fn clone(&self) -> Self { *self }
}
impl Default for sdt_argtype {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    pub fn sdt_probe_stub(arg1: u32, arg2: usize, arg3: usize, arg4: usize,
                          arg5: usize, arg6: usize);
}
extern "C" {
    #[link_name = "lockstat_enabled"]
    pub static mut lockstat_enabled: bool_;
}
extern "C" {
    pub fn atomic_cmpset_char(dst: *mut u_char, expect: u_char, src: u_char)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn atomic_cmpset_short(dst: *mut u_short, expect: u_short,
                               src: u_short) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn atomic_cmpset_int(dst: *mut u_int, expect: u_int, src: u_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn atomic_cmpset_long(dst: *mut u_long, expect: u_long, src: u_long)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn atomic_fcmpset_char(dst: *mut u_char, expect: *mut u_char,
                               src: u_char) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn atomic_fcmpset_short(dst: *mut u_short, expect: *mut u_short,
                                src: u_short) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn atomic_fcmpset_int(dst: *mut u_int, expect: *mut u_int, src: u_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn atomic_fcmpset_long(dst: *mut u_long, expect: *mut u_long,
                               src: u_long) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn atomic_fetchadd_int(p: *mut u_int, v: u_int) -> u_int;
}
extern "C" {
    pub fn atomic_fetchadd_long(p: *mut u_long, v: u_long) -> u_long;
}
extern "C" {
    pub fn atomic_testandset_int(p: *mut u_int, v: u_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn atomic_testandset_long(p: *mut u_long, v: u_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn atomic_testandclear_int(p: *mut u_int, v: u_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn atomic_testandclear_long(p: *mut u_long, v: u_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn atomic_thread_fence_acq();
}
extern "C" {
    pub fn atomic_thread_fence_acq_rel();
}
extern "C" {
    pub fn atomic_thread_fence_rel();
}
extern "C" {
    pub fn atomic_thread_fence_seq_cst();
}
extern "C" {
    pub fn atomic_set_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_set_barr_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_clear_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_clear_barr_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_add_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_add_barr_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_subtract_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_subtract_barr_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_set_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_set_barr_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_clear_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_clear_barr_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_add_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_add_barr_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_subtract_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_subtract_barr_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_set_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_set_barr_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_clear_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_clear_barr_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_add_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_add_barr_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_subtract_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_subtract_barr_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_set_long(p: *mut u_long, v: u_long);
}
extern "C" {
    pub fn atomic_set_barr_long(p: *mut u_long, v: u_long);
}
extern "C" {
    pub fn atomic_clear_long(p: *mut u_long, v: u_long);
}
extern "C" {
    pub fn atomic_clear_barr_long(p: *mut u_long, v: u_long);
}
extern "C" {
    pub fn atomic_add_long(p: *mut u_long, v: u_long);
}
extern "C" {
    pub fn atomic_add_barr_long(p: *mut u_long, v: u_long);
}
extern "C" {
    pub fn atomic_subtract_long(p: *mut u_long, v: u_long);
}
extern "C" {
    pub fn atomic_subtract_barr_long(p: *mut u_long, v: u_long);
}
extern "C" {
    pub fn atomic_load_acq_char(p: *mut u_char) -> u_char;
}
extern "C" {
    pub fn atomic_store_rel_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_load_acq_short(p: *mut u_short) -> u_short;
}
extern "C" {
    pub fn atomic_store_rel_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_load_acq_int(p: *mut u_int) -> u_int;
}
extern "C" {
    pub fn atomic_store_rel_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_load_acq_long(p: *mut u_long) -> u_long;
}
extern "C" {
    pub fn atomic_store_rel_long(p: *mut u_long, v: u_long);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct region_descriptor {
    _unused: [u8; 0],
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy)]
pub struct invpcid_descr {
    pub _bitfield_1: u64,
    pub addr: u64,
}
#[test]
fn bindgen_test_layout_invpcid_descr() {
    assert_eq!(::core::mem::size_of::<invpcid_descr>() , 16usize , concat ! (
               "Size of: " , stringify ! ( invpcid_descr ) ));
    assert_eq! (::core::mem::align_of::<invpcid_descr>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( invpcid_descr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const invpcid_descr ) ) . addr as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( invpcid_descr ) , "::"
                , stringify ! ( addr ) ));
}
impl Clone for invpcid_descr {
    fn clone(&self) -> Self { *self }
}
impl invpcid_descr {
    #[inline]
    pub fn pcid(&self) -> u64 {
        let mut unit_field_val: u64 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u64
                                                 as *mut u8,
                                             ::core::mem::size_of::<u64>())
        };
        let mask = 4095u64 as u64;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::core::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_pcid(&mut self, val: u64) {
        let mask = 4095u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u64
                                                 as *mut u8,
                                             ::core::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn pad(&self) -> u64 {
        let mut unit_field_val: u64 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u64
                                                 as *mut u8,
                                             ::core::mem::size_of::<u64>())
        };
        let mask = 18446744073709547520u64 as u64;
        let val = (unit_field_val & mask) >> 12usize;
        unsafe { ::core::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_pad(&mut self, val: u64) {
        let mask = 18446744073709547520u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u64
                                                 as *mut u8,
                                             ::core::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 12usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(pcid: u64, pad: u64) -> u64 {
        ({ ({ 0 } | ((pcid as u64 as u64) << 0usize) & (4095u64 as u64)) } |
             ((pad as u64 as u64) << 12usize) &
                 (18446744073709547520u64 as u64))
    }
}
pub const SGX_ECREATE: _bindgen_ty_1 = _bindgen_ty_1::SGX_ECREATE;
pub const SGX_EADD: _bindgen_ty_1 = _bindgen_ty_1::SGX_EADD;
pub const SGX_EINIT: _bindgen_ty_1 = _bindgen_ty_1::SGX_EINIT;
pub const SGX_EREMOVE: _bindgen_ty_1 = _bindgen_ty_1::SGX_EREMOVE;
pub const SGX_EDGBRD: _bindgen_ty_1 = _bindgen_ty_1::SGX_EDGBRD;
pub const SGX_EDGBWR: _bindgen_ty_1 = _bindgen_ty_1::SGX_EDGBWR;
pub const SGX_EEXTEND: _bindgen_ty_1 = _bindgen_ty_1::SGX_EEXTEND;
pub const SGX_ELDU: _bindgen_ty_1 = _bindgen_ty_1::SGX_ELDU;
pub const SGX_EBLOCK: _bindgen_ty_1 = _bindgen_ty_1::SGX_EBLOCK;
pub const SGX_EPA: _bindgen_ty_1 = _bindgen_ty_1::SGX_EPA;
pub const SGX_EWB: _bindgen_ty_1 = _bindgen_ty_1::SGX_EWB;
pub const SGX_ETRACK: _bindgen_ty_1 = _bindgen_ty_1::SGX_ETRACK;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_1 {
    SGX_ECREATE = 0,
    SGX_EADD = 1,
    SGX_EINIT = 2,
    SGX_EREMOVE = 3,
    SGX_EDGBRD = 4,
    SGX_EDGBWR = 5,
    SGX_EEXTEND = 6,
    SGX_ELDU = 8,
    SGX_EBLOCK = 9,
    SGX_EPA = 10,
    SGX_EWB = 11,
    SGX_ETRACK = 12,
}
pub const SGX_PT_SECS: _bindgen_ty_2 = _bindgen_ty_2::SGX_PT_SECS;
pub const SGX_PT_TCS: _bindgen_ty_2 = _bindgen_ty_2::SGX_PT_TCS;
pub const SGX_PT_REG: _bindgen_ty_2 = _bindgen_ty_2::SGX_PT_REG;
pub const SGX_PT_VA: _bindgen_ty_2 = _bindgen_ty_2::SGX_PT_VA;
pub const SGX_PT_TRIM: _bindgen_ty_2 = _bindgen_ty_2::SGX_PT_TRIM;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_2 {
    SGX_PT_SECS = 0,
    SGX_PT_TCS = 1,
    SGX_PT_REG = 2,
    SGX_PT_VA = 3,
    SGX_PT_TRIM = 4,
}
extern "C" {
    pub fn sgx_encls(eax: u32, rbx: u64, rcx: u64, rdx: u64)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn reset_dbregs();
}
extern "C" {
    pub fn rdmsr_safe(msr: u_int, val: *mut u64) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn wrmsr_safe(msr: u_int, newval: u64) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn _mtx_init(c: *mut usize, name: *const ::kernel::sys::raw::c_char,
                     type_: *const ::kernel::sys::raw::c_char,
                     opts: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn _mtx_destroy(c: *mut usize);
}
extern "C" {
    pub fn mtx_sysinit(arg: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn _mtx_trylock_flags_int(m: *mut mtx,
                                  opts: ::kernel::sys::raw::c_int,
                                  file: *const ::kernel::sys::raw::c_char,
                                  line: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn _mtx_trylock_flags_(c: *mut usize, opts: ::kernel::sys::raw::c_int,
                               file: *const ::kernel::sys::raw::c_char,
                               line: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn mutex_init();
}
extern "C" {
    pub fn __mtx_lock_sleep(c: *mut usize, v: usize,
                            opts: ::kernel::sys::raw::c_int,
                            file: *const ::kernel::sys::raw::c_char,
                            line: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn __mtx_unlock_sleep(c: *mut usize, v: usize,
                              opts: ::kernel::sys::raw::c_int,
                              file: *const ::kernel::sys::raw::c_char,
                              line: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn __mtx_lock_flags(c: *mut usize, opts: ::kernel::sys::raw::c_int,
                            file: *const ::kernel::sys::raw::c_char,
                            line: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn __mtx_unlock_flags(c: *mut usize, opts: ::kernel::sys::raw::c_int,
                              file: *const ::kernel::sys::raw::c_char,
                              line: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn __mtx_lock_spin_flags(c: *mut usize,
                                 opts: ::kernel::sys::raw::c_int,
                                 file: *const ::kernel::sys::raw::c_char,
                                 line: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn __mtx_trylock_spin_flags(c: *mut usize,
                                    opts: ::kernel::sys::raw::c_int,
                                    file: *const ::kernel::sys::raw::c_char,
                                    line: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn __mtx_unlock_spin_flags(c: *mut usize,
                                   opts: ::kernel::sys::raw::c_int,
                                   file: *const ::kernel::sys::raw::c_char,
                                   line: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn mtx_spin_wait_unlocked(m: *mut mtx);
}
extern "C" {
    pub fn thread_lock_flags_(arg1: *mut thread,
                              arg2: ::kernel::sys::raw::c_int,
                              arg3: *const ::kernel::sys::raw::c_char,
                              arg4: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn _thread_lock(td: *mut thread, opts: ::kernel::sys::raw::c_int,
                        file: *const ::kernel::sys::raw::c_char,
                        line: ::kernel::sys::raw::c_int);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mtx_pool {
    _unused: [u8; 0],
}
extern "C" {
    pub fn mtx_pool_create(mtx_name: *const ::kernel::sys::raw::c_char,
                           pool_size: ::kernel::sys::raw::c_int,
                           opts: ::kernel::sys::raw::c_int) -> *mut mtx_pool;
}
extern "C" {
    pub fn mtx_pool_destroy(poolp: *mut *mut mtx_pool);
}
extern "C" {
    pub fn mtx_pool_find(pool: *mut mtx_pool,
                         ptr: *mut ::kernel::sys::raw::c_void) -> *mut mtx;
}
extern "C" {
    pub fn mtx_pool_alloc(pool: *mut mtx_pool) -> *mut mtx;
}
extern "C" {
    #[link_name = "mtxpool_sleep"]
    pub static mut mtxpool_sleep: *mut mtx_pool;
}
extern "C" {
    #[link_name = "Giant"]
    pub static mut Giant: mtx;
}
extern "C" {
    #[link_name = "blocked_lock"]
    pub static mut blocked_lock: mtx;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mtx_args {
    pub ma_mtx: *mut ::kernel::sys::raw::c_void,
    pub ma_desc: *const ::kernel::sys::raw::c_char,
    pub ma_opts: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_mtx_args() {
    assert_eq!(::core::mem::size_of::<mtx_args>() , 24usize , concat ! (
               "Size of: " , stringify ! ( mtx_args ) ));
    assert_eq! (::core::mem::align_of::<mtx_args>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( mtx_args ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mtx_args ) ) . ma_mtx as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mtx_args ) , "::" ,
                stringify ! ( ma_mtx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mtx_args ) ) . ma_desc as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mtx_args ) , "::" ,
                stringify ! ( ma_desc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mtx_args ) ) . ma_opts as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mtx_args ) , "::" ,
                stringify ! ( ma_opts ) ));
}
impl Clone for mtx_args {
    fn clone(&self) -> Self { *self }
}
impl Default for mtx_args {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry {
    pub ee_link: eventhandler_entry__bindgen_ty_1,
    pub ee_priority: ::kernel::sys::raw::c_int,
    pub ee_arg: *mut ::kernel::sys::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry__bindgen_ty_1 {
    pub tqe_next: *mut eventhandler_entry,
    pub tqe_prev: *mut *mut eventhandler_entry,
}
#[test]
fn bindgen_test_layout_eventhandler_entry__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry__bindgen_ty_1>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry__bindgen_ty_1 ) ) .
                tqe_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry__bindgen_ty_1 ) , "::" , stringify ! (
                tqe_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry__bindgen_ty_1 ) ) .
                tqe_prev as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry__bindgen_ty_1 ) , "::" , stringify ! (
                tqe_prev ) ));
}
impl Clone for eventhandler_entry__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_eventhandler_entry() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry>() , 32usize , concat
               ! ( "Size of: " , stringify ! ( eventhandler_entry ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry ) ) . ee_link as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( eventhandler_entry ) ,
                "::" , stringify ! ( ee_link ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry ) ) . ee_priority as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( eventhandler_entry ) ,
                "::" , stringify ! ( ee_priority ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry ) ) . ee_arg as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( eventhandler_entry ) ,
                "::" , stringify ! ( ee_arg ) ));
}
impl Clone for eventhandler_entry {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_list {
    pub el_name: *mut ::kernel::sys::raw::c_char,
    pub el_flags: ::kernel::sys::raw::c_int,
    pub el_runcount: u_int,
    pub el_lock: mtx,
    pub el_link: eventhandler_list__bindgen_ty_1,
    pub el_entries: eventhandler_list__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_list__bindgen_ty_1 {
    pub tqe_next: *mut eventhandler_list,
    pub tqe_prev: *mut *mut eventhandler_list,
}
#[test]
fn bindgen_test_layout_eventhandler_list__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<eventhandler_list__bindgen_ty_1>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_list__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_list__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_list__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_list__bindgen_ty_1 ) ) .
                tqe_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_list__bindgen_ty_1 ) , "::" , stringify ! (
                tqe_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_list__bindgen_ty_1 ) ) .
                tqe_prev as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_list__bindgen_ty_1 ) , "::" , stringify ! (
                tqe_prev ) ));
}
impl Clone for eventhandler_list__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_list__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_list__bindgen_ty_2 {
    pub tqh_first: *mut eventhandler_entry,
    pub tqh_last: *mut *mut eventhandler_entry,
}
#[test]
fn bindgen_test_layout_eventhandler_list__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<eventhandler_list__bindgen_ty_2>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_list__bindgen_ty_2 )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_list__bindgen_ty_2>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_list__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_list__bindgen_ty_2 ) ) .
                tqh_first as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_list__bindgen_ty_2 ) , "::" , stringify ! (
                tqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_list__bindgen_ty_2 ) ) .
                tqh_last as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_list__bindgen_ty_2 ) , "::" , stringify ! (
                tqh_last ) ));
}
impl Clone for eventhandler_list__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_list__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_eventhandler_list() {
    assert_eq!(::core::mem::size_of::<eventhandler_list>() , 80usize , concat
               ! ( "Size of: " , stringify ! ( eventhandler_list ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_list>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( eventhandler_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_list ) ) . el_name as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( eventhandler_list ) ,
                "::" , stringify ! ( el_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_list ) ) . el_flags as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( eventhandler_list ) ,
                "::" , stringify ! ( el_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_list ) ) . el_runcount as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( eventhandler_list ) ,
                "::" , stringify ! ( el_runcount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_list ) ) . el_lock as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( eventhandler_list ) ,
                "::" , stringify ! ( el_lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_list ) ) . el_link as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( eventhandler_list ) ,
                "::" , stringify ! ( el_link ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_list ) ) . el_entries as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( eventhandler_list ) ,
                "::" , stringify ! ( el_entries ) ));
}
impl Clone for eventhandler_list {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_list {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type eventhandler_tag = *mut eventhandler_entry;
extern "C" {
    pub fn eventhandler_register(list: *mut eventhandler_list,
                                 name: *const ::kernel::sys::raw::c_char,
                                 func: *mut ::kernel::sys::raw::c_void,
                                 arg: *mut ::kernel::sys::raw::c_void,
                                 priority: ::kernel::sys::raw::c_int)
     -> eventhandler_tag;
}
extern "C" {
    pub fn eventhandler_deregister(list: *mut eventhandler_list,
                                   tag: eventhandler_tag);
}
extern "C" {
    pub fn eventhandler_deregister_nowait(list: *mut eventhandler_list,
                                          tag: eventhandler_tag);
}
extern "C" {
    pub fn eventhandler_find_list(name: *const ::kernel::sys::raw::c_char)
     -> *mut eventhandler_list;
}
extern "C" {
    pub fn eventhandler_prune_list(list: *mut eventhandler_list);
}
extern "C" {
    pub fn eventhandler_create_list(name: *const ::kernel::sys::raw::c_char)
     -> *mut eventhandler_list;
}
pub type shutdown_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2:
                                                    ::kernel::sys::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_shutdown_pre_sync {
    pub ee: eventhandler_entry,
    pub eh_func: shutdown_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_shutdown_pre_sync() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_shutdown_pre_sync>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_shutdown_pre_sync ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_shutdown_pre_sync>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_shutdown_pre_sync ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_shutdown_pre_sync ) )
                . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_shutdown_pre_sync ) , "::" , stringify ! (
                ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_shutdown_pre_sync ) )
                . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_shutdown_pre_sync ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_shutdown_pre_sync {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_shutdown_pre_sync {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __hack {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_shutdown_post_sync {
    pub ee: eventhandler_entry,
    pub eh_func: shutdown_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_shutdown_post_sync() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_shutdown_post_sync>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_shutdown_post_sync ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_shutdown_post_sync>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_shutdown_post_sync ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_shutdown_post_sync ) )
                . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_shutdown_post_sync ) , "::" , stringify ! (
                ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_shutdown_post_sync ) )
                . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_shutdown_post_sync ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_shutdown_post_sync {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_shutdown_post_sync {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_shutdown_final {
    pub ee: eventhandler_entry,
    pub eh_func: shutdown_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_shutdown_final() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_shutdown_final>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_shutdown_final )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_shutdown_final>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_shutdown_final ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_shutdown_final ) ) .
                ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_shutdown_final ) , "::" , stringify ! ( ee
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_shutdown_final ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_shutdown_final ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_shutdown_final {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_shutdown_final {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type power_change_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_power_resume {
    pub ee: eventhandler_entry,
    pub eh_func: power_change_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_power_resume() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_power_resume>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_power_resume )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_power_resume>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_power_resume ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_power_resume ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_power_resume ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_power_resume ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_power_resume ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_power_resume {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_power_resume {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_power_suspend {
    pub ee: eventhandler_entry,
    pub eh_func: power_change_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_power_suspend() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_power_suspend>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_power_suspend )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_power_suspend>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_power_suspend ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_power_suspend ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_power_suspend ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_power_suspend ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_power_suspend ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_power_suspend {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_power_suspend {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_power_suspend_early {
    pub ee: eventhandler_entry,
    pub eh_func: power_change_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_power_suspend_early() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_power_suspend_early>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_power_suspend_early ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_power_suspend_early>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_power_suspend_early ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_power_suspend_early )
                ) . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_power_suspend_early ) , "::" , stringify !
                ( ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_power_suspend_early )
                ) . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_power_suspend_early ) , "::" , stringify !
                ( eh_func ) ));
}
impl Clone for eventhandler_entry_power_suspend_early {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_power_suspend_early {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type vm_lowmem_handler_t =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2:
                                                    ::kernel::sys::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_vm_lowmem {
    pub ee: eventhandler_entry,
    pub eh_func: vm_lowmem_handler_t,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_vm_lowmem() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_vm_lowmem>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_vm_lowmem ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_vm_lowmem>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_vm_lowmem )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_vm_lowmem ) ) . ee as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_vm_lowmem ) , "::" , stringify ! ( ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_vm_lowmem ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_vm_lowmem ) , "::" , stringify ! ( eh_func
                ) ));
}
impl Clone for eventhandler_entry_vm_lowmem {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_vm_lowmem {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type mountroot_handler_t =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_mountroot {
    pub ee: eventhandler_entry,
    pub eh_func: mountroot_handler_t,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_mountroot() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_mountroot>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_mountroot ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_mountroot>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_mountroot )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_mountroot ) ) . ee as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_mountroot ) , "::" , stringify ! ( ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_mountroot ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_mountroot ) , "::" , stringify ! ( eh_func
                ) ));
}
impl Clone for eventhandler_entry_mountroot {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_mountroot {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mount {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnode {
    _unused: [u8; 0],
}
pub type vfs_mounted_notify_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut mount,
                                                arg3: *mut vnode,
                                                arg4: *mut thread)>;
pub type vfs_unmounted_notify_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut mount,
                                                arg3: *mut thread)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_vfs_mounted {
    pub ee: eventhandler_entry,
    pub eh_func: vfs_mounted_notify_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_vfs_mounted() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_vfs_mounted>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_vfs_mounted )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_vfs_mounted>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_vfs_mounted
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_vfs_mounted ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_vfs_mounted ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_vfs_mounted ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_vfs_mounted ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_vfs_mounted {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_vfs_mounted {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_vfs_unmounted {
    pub ee: eventhandler_entry,
    pub eh_func: vfs_unmounted_notify_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_vfs_unmounted() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_vfs_unmounted>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_vfs_unmounted )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_vfs_unmounted>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_vfs_unmounted ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_vfs_unmounted ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_vfs_unmounted ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_vfs_unmounted ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_vfs_unmounted ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_vfs_unmounted {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_vfs_unmounted {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct proc_ {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct image_params {
    _unused: [u8; 0],
}
pub type exitlist_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut proc_)>;
pub type forklist_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut proc_,
                                                arg3: *mut proc_,
                                                arg4:
                                                    ::kernel::sys::raw::c_int)>;
pub type execlist_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut proc_,
                                                arg3: *mut image_params)>;
pub type proc_ctor_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut proc_)>;
pub type proc_dtor_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut proc_)>;
pub type proc_init_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut proc_)>;
pub type proc_fini_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut proc_)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_process_ctor {
    pub ee: eventhandler_entry,
    pub eh_func: proc_ctor_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_process_ctor() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_process_ctor>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_process_ctor )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_process_ctor>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_process_ctor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_ctor ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_ctor ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_ctor ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_ctor ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_process_ctor {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_process_ctor {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_process_dtor {
    pub ee: eventhandler_entry,
    pub eh_func: proc_dtor_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_process_dtor() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_process_dtor>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_process_dtor )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_process_dtor>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_process_dtor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_dtor ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_dtor ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_dtor ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_dtor ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_process_dtor {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_process_dtor {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_process_init {
    pub ee: eventhandler_entry,
    pub eh_func: proc_init_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_process_init() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_process_init>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_process_init )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_process_init>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_process_init ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_init ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_init ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_init ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_init ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_process_init {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_process_init {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_process_fini {
    pub ee: eventhandler_entry,
    pub eh_func: proc_fini_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_process_fini() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_process_fini>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_process_fini )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_process_fini>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_process_fini ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_fini ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_fini ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_fini ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_fini ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_process_fini {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_process_fini {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_process_exit {
    pub ee: eventhandler_entry,
    pub eh_func: exitlist_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_process_exit() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_process_exit>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_process_exit )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_process_exit>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_process_exit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_exit ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_exit ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_exit ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_exit ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_process_exit {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_process_exit {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_process_fork {
    pub ee: eventhandler_entry,
    pub eh_func: forklist_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_process_fork() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_process_fork>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_process_fork )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_process_fork>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_process_fork ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_fork ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_fork ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_fork ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_fork ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_process_fork {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_process_fork {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_process_exec {
    pub ee: eventhandler_entry,
    pub eh_func: execlist_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_process_exec() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_process_exec>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_process_exec )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_process_exec>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_process_exec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_exec ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_exec ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_exec ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_exec ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_process_exec {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_process_exec {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type app_coredump_start_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut thread,
                                                name:
                                                    *mut ::kernel::sys::raw::c_char)>;
pub type app_coredump_progress_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                td: *mut thread,
                                                byte_count:
                                                    ::kernel::sys::raw::c_int)>;
pub type app_coredump_finish_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                td: *mut thread)>;
pub type app_coredump_error_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                td: *mut thread,
                                                msg:
                                                    *mut ::kernel::sys::raw::c_char, ...)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_app_coredump_start {
    pub ee: eventhandler_entry,
    pub eh_func: app_coredump_start_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_app_coredump_start() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_app_coredump_start>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_app_coredump_start ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_app_coredump_start>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_app_coredump_start ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_app_coredump_start ) )
                . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_app_coredump_start ) , "::" , stringify ! (
                ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_app_coredump_start ) )
                . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_app_coredump_start ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_app_coredump_start {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_app_coredump_start {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_app_coredump_progress {
    pub ee: eventhandler_entry,
    pub eh_func: app_coredump_progress_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_app_coredump_progress() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_app_coredump_progress>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_app_coredump_progress ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_app_coredump_progress>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_app_coredump_progress ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const eventhandler_entry_app_coredump_progress ) )
                . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_app_coredump_progress ) , "::" , stringify
                ! ( ee ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const eventhandler_entry_app_coredump_progress ) )
                . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_app_coredump_progress ) , "::" , stringify
                ! ( eh_func ) ));
}
impl Clone for eventhandler_entry_app_coredump_progress {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_app_coredump_progress {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_app_coredump_finish {
    pub ee: eventhandler_entry,
    pub eh_func: app_coredump_finish_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_app_coredump_finish() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_app_coredump_finish>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_app_coredump_finish ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_app_coredump_finish>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_app_coredump_finish ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_app_coredump_finish )
                ) . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_app_coredump_finish ) , "::" , stringify !
                ( ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_app_coredump_finish )
                ) . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_app_coredump_finish ) , "::" , stringify !
                ( eh_func ) ));
}
impl Clone for eventhandler_entry_app_coredump_finish {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_app_coredump_finish {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_app_coredump_error {
    pub ee: eventhandler_entry,
    pub eh_func: app_coredump_error_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_app_coredump_error() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_app_coredump_error>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_app_coredump_error ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_app_coredump_error>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_app_coredump_error ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_app_coredump_error ) )
                . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_app_coredump_error ) , "::" , stringify ! (
                ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_app_coredump_error ) )
                . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_app_coredump_error ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_app_coredump_error {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_app_coredump_error {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type thread_ctor_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut thread)>;
pub type thread_dtor_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut thread)>;
pub type thread_fini_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut thread)>;
pub type thread_init_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut thread)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_thread_ctor {
    pub ee: eventhandler_entry,
    pub eh_func: thread_ctor_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_thread_ctor() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_thread_ctor>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_thread_ctor )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_thread_ctor>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_thread_ctor
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_thread_ctor ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_thread_ctor ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_thread_ctor ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_thread_ctor ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_thread_ctor {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_thread_ctor {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_thread_dtor {
    pub ee: eventhandler_entry,
    pub eh_func: thread_dtor_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_thread_dtor() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_thread_dtor>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_thread_dtor )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_thread_dtor>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_thread_dtor
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_thread_dtor ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_thread_dtor ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_thread_dtor ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_thread_dtor ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_thread_dtor {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_thread_dtor {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_thread_init {
    pub ee: eventhandler_entry,
    pub eh_func: thread_init_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_thread_init() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_thread_init>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_thread_init )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_thread_init>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_thread_init
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_thread_init ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_thread_init ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_thread_init ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_thread_init ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_thread_init {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_thread_init {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_thread_fini {
    pub ee: eventhandler_entry,
    pub eh_func: thread_fini_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_thread_fini() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_thread_fini>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_thread_fini )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_thread_fini>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_thread_fini
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_thread_fini ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_thread_fini ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_thread_fini ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_thread_fini ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_thread_fini {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_thread_fini {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type uma_zone_chfn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_nmbclusters_change {
    pub ee: eventhandler_entry,
    pub eh_func: uma_zone_chfn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_nmbclusters_change() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_nmbclusters_change>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_nmbclusters_change ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_nmbclusters_change>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_nmbclusters_change ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_nmbclusters_change ) )
                . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_nmbclusters_change ) , "::" , stringify ! (
                ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_nmbclusters_change ) )
                . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_nmbclusters_change ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_nmbclusters_change {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_nmbclusters_change {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_nmbufs_change {
    pub ee: eventhandler_entry,
    pub eh_func: uma_zone_chfn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_nmbufs_change() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_nmbufs_change>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_nmbufs_change )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_nmbufs_change>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_nmbufs_change ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_nmbufs_change ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_nmbufs_change ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_nmbufs_change ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_nmbufs_change ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_nmbufs_change {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_nmbufs_change {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_maxsockets_change {
    pub ee: eventhandler_entry,
    pub eh_func: uma_zone_chfn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_maxsockets_change() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_maxsockets_change>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_maxsockets_change ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_maxsockets_change>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_maxsockets_change ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_maxsockets_change ) )
                . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_maxsockets_change ) , "::" , stringify ! (
                ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_maxsockets_change ) )
                . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_maxsockets_change ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_maxsockets_change {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_maxsockets_change {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type kld_load_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut linker_file)>;
pub type kld_unload_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2:
                                                    *const ::kernel::sys::raw::c_char,
                                                arg3: caddr_t, arg4: usize)>;
pub type kld_unload_try_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut linker_file,
                                                arg3:
                                                    *mut ::kernel::sys::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_kld_load {
    pub ee: eventhandler_entry,
    pub eh_func: kld_load_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_kld_load() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_kld_load>() , 40usize
               , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_kld_load ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_kld_load>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_kld_load )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_kld_load ) ) . ee as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_kld_load ) , "::" , stringify ! ( ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_kld_load ) ) . eh_func
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_kld_load ) , "::" , stringify ! ( eh_func )
                ));
}
impl Clone for eventhandler_entry_kld_load {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_kld_load {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_kld_unload {
    pub ee: eventhandler_entry,
    pub eh_func: kld_unload_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_kld_unload() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_kld_unload>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_kld_unload ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_kld_unload>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_kld_unload
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_kld_unload ) ) . ee as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_kld_unload ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_kld_unload ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_kld_unload ) , "::" , stringify ! ( eh_func
                ) ));
}
impl Clone for eventhandler_entry_kld_unload {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_kld_unload {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_kld_unload_try {
    pub ee: eventhandler_entry,
    pub eh_func: kld_unload_try_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_kld_unload_try() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_kld_unload_try>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_kld_unload_try )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_kld_unload_try>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_kld_unload_try ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_kld_unload_try ) ) .
                ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_kld_unload_try ) , "::" , stringify ! ( ee
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_kld_unload_try ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_kld_unload_try ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_kld_unload_try {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_kld_unload_try {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fb_info {
    _unused: [u8; 0],
}
pub type register_framebuffer_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut fb_info)>;
pub type unregister_framebuffer_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut fb_info)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_register_framebuffer {
    pub ee: eventhandler_entry,
    pub eh_func: register_framebuffer_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_register_framebuffer() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_register_framebuffer>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_register_framebuffer ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_register_framebuffer>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_register_framebuffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_register_framebuffer )
                ) . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_register_framebuffer ) , "::" , stringify !
                ( ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_register_framebuffer )
                ) . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_register_framebuffer ) , "::" , stringify !
                ( eh_func ) ));
}
impl Clone for eventhandler_entry_register_framebuffer {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_register_framebuffer {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_unregister_framebuffer {
    pub ee: eventhandler_entry,
    pub eh_func: unregister_framebuffer_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_unregister_framebuffer() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_unregister_framebuffer>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_unregister_framebuffer ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_unregister_framebuffer>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_unregister_framebuffer ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const eventhandler_entry_unregister_framebuffer ) )
                . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_unregister_framebuffer ) , "::" , stringify
                ! ( ee ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const eventhandler_entry_unregister_framebuffer ) )
                . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_unregister_framebuffer ) , "::" , stringify
                ! ( eh_func ) ));
}
impl Clone for eventhandler_entry_unregister_framebuffer {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_unregister_framebuffer {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cam_path {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ata_params {
    _unused: [u8; 0],
}
pub type ada_probe_veto_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut cam_path,
                                                arg3: *mut ata_params,
                                                arg4:
                                                    *mut ::kernel::sys::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_ada_probe_veto {
    pub ee: eventhandler_entry,
    pub eh_func: ada_probe_veto_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_ada_probe_veto() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_ada_probe_veto>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_ada_probe_veto )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_ada_probe_veto>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_ada_probe_veto ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_ada_probe_veto ) ) .
                ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_ada_probe_veto ) , "::" , stringify ! ( ee
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_ada_probe_veto ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_ada_probe_veto ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_ada_probe_veto {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_ada_probe_veto {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct swdevt {
    _unused: [u8; 0],
}
pub type swapon_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut swdevt)>;
pub type swapoff_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut swdevt)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_swapon {
    pub ee: eventhandler_entry,
    pub eh_func: swapon_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_swapon() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_swapon>() , 40usize ,
               concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_swapon ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_swapon>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_swapon )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_swapon ) ) . ee as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_swapon ) , "::" , stringify ! ( ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_swapon ) ) . eh_func
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_swapon ) , "::" , stringify ! ( eh_func )
                ));
}
impl Clone for eventhandler_entry_swapon {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_swapon {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_swapoff {
    pub ee: eventhandler_entry,
    pub eh_func: swapoff_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_swapoff() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_swapoff>() , 40usize
               , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_swapoff ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_swapoff>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_swapoff )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_swapoff ) ) . ee as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_swapoff ) , "::" , stringify ! ( ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_swapoff ) ) . eh_func
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_swapoff ) , "::" , stringify ! ( eh_func )
                ));
}
impl Clone for eventhandler_entry_swapoff {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_swapoff {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum evhdev_detach {
    EVHDEV_DETACH_BEGIN = 0,
    EVHDEV_DETACH_COMPLETE = 1,
    EVHDEV_DETACH_FAILED = 2,
}
pub type device_attach_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: device_t)>;
pub type device_detach_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: device_t,
                                                arg3: evhdev_detach)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_device_attach {
    pub ee: eventhandler_entry,
    pub eh_func: device_attach_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_device_attach() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_device_attach>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_device_attach )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_device_attach>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_device_attach ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_device_attach ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_device_attach ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_device_attach ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_device_attach ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_device_attach {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_device_attach {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_device_detach {
    pub ee: eventhandler_entry,
    pub eh_func: device_detach_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_device_detach() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_device_detach>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_device_detach )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_device_detach>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_device_detach ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_device_detach ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_device_detach ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_device_detach ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_device_detach ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_device_detach {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_device_detach {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct kobj {
    pub ops: kobj_ops_t,
}
#[test]
fn bindgen_test_layout_kobj() {
    assert_eq!(::core::mem::size_of::<kobj>() , 8usize , concat ! (
               "Size of: " , stringify ! ( kobj ) ));
    assert_eq! (::core::mem::align_of::<kobj>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kobj ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kobj ) ) . ops as * const _ as usize } ,
                0usize , concat ! (
                "Alignment of field: " , stringify ! ( kobj ) , "::" ,
                stringify ! ( ops ) ));
}
impl Clone for kobj {
    fn clone(&self) -> Self { *self }
}
impl Default for kobj {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type kobj_t = *mut kobj;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct kobj_class {
    pub name: *const ::kernel::sys::raw::c_char,
    pub methods: *mut kobj_method_t,
    pub size: usize,
    pub baseclasses: *mut kobj_class_t,
    pub refs: u_int,
    pub ops: kobj_ops_t,
}
#[test]
fn bindgen_test_layout_kobj_class() {
    assert_eq!(::core::mem::size_of::<kobj_class>() , 48usize , concat ! (
               "Size of: " , stringify ! ( kobj_class ) ));
    assert_eq! (::core::mem::align_of::<kobj_class>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kobj_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kobj_class ) ) . name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kobj_class ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kobj_class ) ) . methods as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kobj_class ) , "::" ,
                stringify ! ( methods ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kobj_class ) ) . size as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( kobj_class ) , "::" ,
                stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kobj_class ) ) . baseclasses as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( kobj_class ) , "::" ,
                stringify ! ( baseclasses ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kobj_class ) ) . refs as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( kobj_class ) , "::" ,
                stringify ! ( refs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kobj_class ) ) . ops as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( kobj_class ) , "::" ,
                stringify ! ( ops ) ));
}
impl Clone for kobj_class {
    fn clone(&self) -> Self { *self }
}
impl Default for kobj_class {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type kobj_class_t = *mut kobj_class;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct kobj_method {
    pub desc: kobjop_desc_t,
    pub func: kobjop_t,
}
#[test]
fn bindgen_test_layout_kobj_method() {
    assert_eq!(::core::mem::size_of::<kobj_method>() , 16usize , concat ! (
               "Size of: " , stringify ! ( kobj_method ) ));
    assert_eq! (::core::mem::align_of::<kobj_method>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kobj_method ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kobj_method ) ) . desc as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kobj_method ) , "::" ,
                stringify ! ( desc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kobj_method ) ) . func as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kobj_method ) , "::" ,
                stringify ! ( func ) ));
}
impl Clone for kobj_method {
    fn clone(&self) -> Self { *self }
}
impl Default for kobj_method {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type kobj_method_t = kobj_method;
pub type kobjop_t =
    ::core::option::Option<unsafe extern "C" fn()
                               -> ::kernel::sys::raw::c_int>;
#[repr(C)]
#[derive(Copy)]
pub struct kobj_ops {
    pub cache: [*mut kobj_method_t; 256usize],
    pub cls: kobj_class_t,
}
#[test]
fn bindgen_test_layout_kobj_ops() {
    assert_eq!(::core::mem::size_of::<kobj_ops>() , 2056usize , concat ! (
               "Size of: " , stringify ! ( kobj_ops ) ));
    assert_eq! (::core::mem::align_of::<kobj_ops>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kobj_ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kobj_ops ) ) . cache as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kobj_ops ) , "::" ,
                stringify ! ( cache ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kobj_ops ) ) . cls as * const _ as usize
                } , 2048usize , concat ! (
                "Alignment of field: " , stringify ! ( kobj_ops ) , "::" ,
                stringify ! ( cls ) ));
}
impl Clone for kobj_ops {
    fn clone(&self) -> Self { *self }
}
impl Default for kobj_ops {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for kobj_ops {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "kobj_ops {{ cache: [{}], cls: {:?} }}" , self . cache .
               iter (  ) . enumerate (  ) . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ) , self . cls)
    }
}
pub type kobj_ops_t = *mut kobj_ops;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct kobjop_desc {
    pub id: ::kernel::sys::raw::c_uint,
    pub deflt: kobj_method_t,
}
#[test]
fn bindgen_test_layout_kobjop_desc() {
    assert_eq!(::core::mem::size_of::<kobjop_desc>() , 24usize , concat ! (
               "Size of: " , stringify ! ( kobjop_desc ) ));
    assert_eq! (::core::mem::align_of::<kobjop_desc>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kobjop_desc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kobjop_desc ) ) . id as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kobjop_desc ) , "::" ,
                stringify ! ( id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kobjop_desc ) ) . deflt as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kobjop_desc ) , "::" ,
                stringify ! ( deflt ) ));
}
impl Clone for kobjop_desc {
    fn clone(&self) -> Self { *self }
}
impl Default for kobjop_desc {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type kobjop_desc_t = *mut kobjop_desc;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct malloc_type {
    _unused: [u8; 0],
}
extern "C" {
    pub fn kobj_class_compile(cls: kobj_class_t);
}
extern "C" {
    pub fn kobj_class_compile_static(cls: kobj_class_t, ops: kobj_ops_t);
}
extern "C" {
    pub fn kobj_class_free(cls: kobj_class_t);
}
extern "C" {
    pub fn kobj_create(cls: kobj_class_t, mtype: *mut malloc_type,
                       mflags: ::kernel::sys::raw::c_int) -> kobj_t;
}
extern "C" {
    pub fn kobj_init(obj: kobj_t, cls: kobj_class_t);
}
extern "C" {
    pub fn kobj_init_static(obj: kobj_t, cls: kobj_class_t);
}
extern "C" {
    pub fn kobj_delete(obj: kobj_t, mtype: *mut malloc_type);
}
extern "C" {
    pub fn kobj_lookup_method(cls: kobj_class_t, cep: *mut *mut kobj_method_t,
                              desc: kobjop_desc_t) -> *mut kobj_method_t;
}
extern "C" {
    pub fn kobj_error_method() -> ::kernel::sys::raw::c_int;
}
extern "C" {
    /// devctl hooks.  Typically one should use the devctl_notify
/// hook to send the message.  However, devctl_queue_data is also
/// included in case devctl_notify isn't sufficiently general.
    pub fn devctl_process_running() -> boolean_t;
}
extern "C" {
    pub fn devctl_notify_f(__system: *const ::kernel::sys::raw::c_char,
                           __subsystem: *const ::kernel::sys::raw::c_char,
                           __type: *const ::kernel::sys::raw::c_char,
                           __data: *const ::kernel::sys::raw::c_char,
                           __flags: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn devctl_notify(__system: *const ::kernel::sys::raw::c_char,
                         __subsystem: *const ::kernel::sys::raw::c_char,
                         __type: *const ::kernel::sys::raw::c_char,
                         __data: *const ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn devctl_queue_data_f(__data: *mut ::kernel::sys::raw::c_char,
                               __flags: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn devctl_queue_data(__data: *mut ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn devctl_safe_quote(__dst: *mut ::kernel::sys::raw::c_char,
                             __src: *const ::kernel::sys::raw::c_char,
                             len: usize);
}
/// Device name parsers.  Hook to allow device enumerators to map
/// scheme-specific names to a device.
pub type dev_lookup_fn =
    ::core::option::Option<unsafe extern "C" fn(arg:
                                                    *mut ::kernel::sys::raw::c_void,
                                                name:
                                                    *const ::kernel::sys::raw::c_char,
                                                result: *mut device_t)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_dev_lookup {
    pub ee: eventhandler_entry,
    pub eh_func: dev_lookup_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_dev_lookup() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_dev_lookup>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_dev_lookup ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_dev_lookup>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_dev_lookup
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_dev_lookup ) ) . ee as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_dev_lookup ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_dev_lookup ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_dev_lookup ) , "::" , stringify ! ( eh_func
                ) ));
}
impl Clone for eventhandler_entry_dev_lookup {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_dev_lookup {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
/// @brief A device driver (included mainly for compatibility with
/// FreeBSD 4.x).
pub type driver_t = kobj_class;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct devclass {
    _unused: [u8; 0],
}
/// @brief A device class
///
/// The devclass object has two main functions in the system. The first
/// is to manage the allocation of unit numbers for device instances
/// and the second is to hold the list of device drivers for a
/// particular bus type. Each devclass has a name and there cannot be
/// two devclasses with the same name. This ensures that unique unit
/// numbers are allocated to device instances.
///
/// Drivers that support several different bus attachments (e.g. isa,
/// pci, pccard) should all use the same devclass to ensure that unit
/// numbers do not conflict.
///
/// Each devclass may also have a parent devclass. This is used when
/// searching for device drivers to allow a form of inheritance. When
/// matching drivers with devices, first the driver list of the parent
/// device's devclass is searched. If no driver is found in that list,
/// the search continues in the parent devclass (if any).
pub type devclass_t = *mut devclass;
/// @brief Driver interrupt service routines
///
/// The filter routine is run in primary interrupt context and may not
/// block or use regular mutexes.  It may only use spin mutexes for
/// synchronization.  The filter may either completely handle the
/// interrupt or it may perform some of the work and defer more
/// expensive work to the regular interrupt handler.  If a filter
/// routine is not registered by the driver, then the regular interrupt
/// handler is always used to handle interrupts from this device.
///
/// The regular interrupt handler executes in its own thread context
/// and may use regular mutexes.  However, it is prohibited from
/// sleeping on a sleep queue.
pub type driver_filter_t =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void)
                               -> ::kernel::sys::raw::c_int>;
pub type driver_intr_t =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void)>;
#[repr(u32)]
/// @brief Interrupt type bits.
///
/// These flags are used both by newbus interrupt
/// registration (nexus.c) and also in struct intrec, which defines
/// interrupt properties.
///
/// XXX We should probably revisit this and remove the vestiges of the
/// spls implicit in names like INTR_TYPE_TTY. In the meantime, don't
/// confuse things by renaming them (Grog, 18 July 2000).
///
/// Buses which do interrupt remapping will want to change their type
/// to reflect what sort of devices are underneath.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum intr_type {
    INTR_TYPE_TTY = 1,
    INTR_TYPE_BIO = 2,
    INTR_TYPE_NET = 4,
    INTR_TYPE_CAM = 8,
    INTR_TYPE_MISC = 16,
    INTR_TYPE_CLK = 32,
    INTR_TYPE_AV = 64,
    INTR_EXCL = 256,
    INTR_MPSAFE = 512,
    INTR_ENTROPY = 1024,
    INTR_MD1 = 4096,
    INTR_MD2 = 8192,
    INTR_MD3 = 16384,
    INTR_MD4 = 32768,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum intr_trigger {
    INTR_TRIGGER_INVALID = -1,
    INTR_TRIGGER_CONFORM = 0,
    INTR_TRIGGER_EDGE = 1,
    INTR_TRIGGER_LEVEL = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum intr_polarity {
    INTR_POLARITY_CONFORM = 0,
    INTR_POLARITY_HIGH = 1,
    INTR_POLARITY_LOW = 2,
}
#[repr(u32)]
/// CPU sets supported by bus_get_cpus().  Note that not all sets may be
/// supported for a given device.  If a request is not supported by a
/// device (or its parents), then bus_get_cpus() will fail with EINVAL.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum cpu_sets { LOCAL_CPUS = 0, INTR_CPUS = 1, }
pub type devop_t =
    ::core::option::Option<unsafe extern "C" fn()
                               -> ::kernel::sys::raw::c_int>;
/// @brief This structure is deprecated.
///
/// Use the kobj(9) macro DEFINE_CLASS to
/// declare classes which implement device drivers.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct driver {
    pub name: *const ::kernel::sys::raw::c_char,
    pub methods: *mut kobj_method_t,
    pub size: usize,
    pub baseclasses: *mut kobj_class_t,
    pub refs: u_int,
    pub ops: kobj_ops_t,
}
#[test]
fn bindgen_test_layout_driver() {
    assert_eq!(::core::mem::size_of::<driver>() , 48usize , concat ! (
               "Size of: " , stringify ! ( driver ) ));
    assert_eq! (::core::mem::align_of::<driver>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( driver ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const driver ) ) . name as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( driver ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const driver ) ) . methods as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( driver ) , "::" ,
                stringify ! ( methods ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const driver ) ) . size as * const _ as usize }
                , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( driver ) , "::" ,
                stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const driver ) ) . baseclasses as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( driver ) , "::" ,
                stringify ! ( baseclasses ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const driver ) ) . refs as * const _ as usize }
                , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( driver ) , "::" ,
                stringify ! ( refs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const driver ) ) . ops as * const _ as usize }
                , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( driver ) , "::" ,
                stringify ! ( ops ) ));
}
impl Clone for driver {
    fn clone(&self) -> Self { *self }
}
impl Default for driver {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
/// @brief A resource mapping.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct resource_map {
    pub r_bustag: bus_space_tag_t,
    pub r_bushandle: bus_space_handle_t,
    pub r_size: bus_size_t,
    pub r_vaddr: *mut ::kernel::sys::raw::c_void,
}
#[test]
fn bindgen_test_layout_resource_map() {
    assert_eq!(::core::mem::size_of::<resource_map>() , 32usize , concat ! (
               "Size of: " , stringify ! ( resource_map ) ));
    assert_eq! (::core::mem::align_of::<resource_map>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( resource_map ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_map ) ) . r_bustag as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_map ) , "::" ,
                stringify ! ( r_bustag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_map ) ) . r_bushandle as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_map ) , "::" ,
                stringify ! ( r_bushandle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_map ) ) . r_size as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_map ) , "::" ,
                stringify ! ( r_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_map ) ) . r_vaddr as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_map ) , "::" ,
                stringify ! ( r_vaddr ) ));
}
impl Clone for resource_map {
    fn clone(&self) -> Self { *self }
}
impl Default for resource_map {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
/// @brief Optional properties of a resource mapping request.
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct resource_map_request {
    pub size: usize,
    pub offset: rman_res_t,
    pub length: rman_res_t,
    pub memattr: vm_memattr_t,
}
#[test]
fn bindgen_test_layout_resource_map_request() {
    assert_eq!(::core::mem::size_of::<resource_map_request>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( resource_map_request )
               ));
    assert_eq! (::core::mem::align_of::<resource_map_request>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( resource_map_request ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_map_request ) ) . size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_map_request )
                , "::" , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_map_request ) ) . offset as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_map_request )
                , "::" , stringify ! ( offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_map_request ) ) . length as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_map_request )
                , "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_map_request ) ) . memattr as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_map_request )
                , "::" , stringify ! ( memattr ) ));
}
impl Clone for resource_map_request {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn resource_init_map_request_impl(_args: *mut resource_map_request,
                                          _sz: usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct resource {
    pub __r_i: *mut resource_i,
    pub r_bustag: bus_space_tag_t,
    pub r_bushandle: bus_space_handle_t,
}
#[test]
fn bindgen_test_layout_resource() {
    assert_eq!(::core::mem::size_of::<resource>() , 24usize , concat ! (
               "Size of: " , stringify ! ( resource ) ));
    assert_eq! (::core::mem::align_of::<resource>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( resource ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource ) ) . __r_i as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( resource ) , "::" ,
                stringify ! ( __r_i ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource ) ) . r_bustag as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( resource ) , "::" ,
                stringify ! ( r_bustag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource ) ) . r_bushandle as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( resource ) , "::" ,
                stringify ! ( r_bushandle ) ));
}
impl Clone for resource {
    fn clone(&self) -> Self { *self }
}
impl Default for resource {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
/// @brief An entry for a single resource in a resource list.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct resource_list_entry {
    pub link: resource_list_entry__bindgen_ty_1,
    /// < @brief type argument to alloc_resource
    pub type_: ::kernel::sys::raw::c_int,
    /// < @brief resource identifier
    pub rid: ::kernel::sys::raw::c_int,
    /// < @brief resource flags
    pub flags: ::kernel::sys::raw::c_int,
    /// < @brief the real resource when allocated
    pub res: *mut resource,
    /// < @brief start of resource range
    pub start: rman_res_t,
    /// < @brief end of resource range
    pub end: rman_res_t,
    /// < @brief count within range
    pub count: rman_res_t,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct resource_list_entry__bindgen_ty_1 {
    pub stqe_next: *mut resource_list_entry,
}
#[test]
fn bindgen_test_layout_resource_list_entry__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<resource_list_entry__bindgen_ty_1>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( resource_list_entry__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<resource_list_entry__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                resource_list_entry__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_list_entry__bindgen_ty_1 ) ) .
                stqe_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                resource_list_entry__bindgen_ty_1 ) , "::" , stringify ! (
                stqe_next ) ));
}
impl Clone for resource_list_entry__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for resource_list_entry__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_resource_list_entry() {
    assert_eq!(::core::mem::size_of::<resource_list_entry>() , 56usize ,
               concat ! ( "Size of: " , stringify ! ( resource_list_entry )
               ));
    assert_eq! (::core::mem::align_of::<resource_list_entry>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( resource_list_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_list_entry ) ) . link as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_list_entry ) ,
                "::" , stringify ! ( link ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_list_entry ) ) . type_ as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_list_entry ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_list_entry ) ) . rid as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_list_entry ) ,
                "::" , stringify ! ( rid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_list_entry ) ) . flags as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_list_entry ) ,
                "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_list_entry ) ) . res as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_list_entry ) ,
                "::" , stringify ! ( res ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_list_entry ) ) . start as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_list_entry ) ,
                "::" , stringify ! ( start ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_list_entry ) ) . end as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_list_entry ) ,
                "::" , stringify ! ( end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_list_entry ) ) . count as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_list_entry ) ,
                "::" , stringify ! ( count ) ));
}
impl Clone for resource_list_entry {
    fn clone(&self) -> Self { *self }
}
impl Default for resource_list_entry {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct resource_list {
    pub stqh_first: *mut resource_list_entry,
    pub stqh_last: *mut *mut resource_list_entry,
}
#[test]
fn bindgen_test_layout_resource_list() {
    assert_eq!(::core::mem::size_of::<resource_list>() , 16usize , concat ! (
               "Size of: " , stringify ! ( resource_list ) ));
    assert_eq! (::core::mem::align_of::<resource_list>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( resource_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_list ) ) . stqh_first as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_list ) , "::"
                , stringify ! ( stqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_list ) ) . stqh_last as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_list ) , "::"
                , stringify ! ( stqh_last ) ));
}
impl Clone for resource_list {
    fn clone(&self) -> Self { *self }
}
impl Default for resource_list {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    pub fn resource_list_init(rl: *mut resource_list);
}
extern "C" {
    pub fn resource_list_free(rl: *mut resource_list);
}
extern "C" {
    pub fn resource_list_add(rl: *mut resource_list,
                             type_: ::kernel::sys::raw::c_int,
                             rid: ::kernel::sys::raw::c_int,
                             start: rman_res_t, end: rman_res_t,
                             count: rman_res_t) -> *mut resource_list_entry;
}
extern "C" {
    pub fn resource_list_add_next(rl: *mut resource_list,
                                  type_: ::kernel::sys::raw::c_int,
                                  start: rman_res_t, end: rman_res_t,
                                  count: rman_res_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn resource_list_busy(rl: *mut resource_list,
                              type_: ::kernel::sys::raw::c_int,
                              rid: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn resource_list_reserved(rl: *mut resource_list,
                                  type_: ::kernel::sys::raw::c_int,
                                  rid: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn resource_list_find(rl: *mut resource_list,
                              type_: ::kernel::sys::raw::c_int,
                              rid: ::kernel::sys::raw::c_int)
     -> *mut resource_list_entry;
}
extern "C" {
    pub fn resource_list_delete(rl: *mut resource_list,
                                type_: ::kernel::sys::raw::c_int,
                                rid: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn resource_list_alloc(rl: *mut resource_list, bus: device_t,
                               child: device_t,
                               type_: ::kernel::sys::raw::c_int,
                               rid: *mut ::kernel::sys::raw::c_int,
                               start: rman_res_t, end: rman_res_t,
                               count: rman_res_t, flags: u_int)
     -> *mut resource;
}
extern "C" {
    pub fn resource_list_release(rl: *mut resource_list, bus: device_t,
                                 child: device_t,
                                 type_: ::kernel::sys::raw::c_int,
                                 rid: ::kernel::sys::raw::c_int,
                                 res: *mut resource)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn resource_list_release_active(rl: *mut resource_list, bus: device_t,
                                        child: device_t,
                                        type_: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn resource_list_reserve(rl: *mut resource_list, bus: device_t,
                                 child: device_t,
                                 type_: ::kernel::sys::raw::c_int,
                                 rid: *mut ::kernel::sys::raw::c_int,
                                 start: rman_res_t, end: rman_res_t,
                                 count: rman_res_t, flags: u_int)
     -> *mut resource;
}
extern "C" {
    pub fn resource_list_unreserve(rl: *mut resource_list, bus: device_t,
                                   child: device_t,
                                   type_: ::kernel::sys::raw::c_int,
                                   rid: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn resource_list_purge(rl: *mut resource_list);
}
extern "C" {
    pub fn resource_list_print_type(rl: *mut resource_list,
                                    name: *const ::kernel::sys::raw::c_char,
                                    type_: ::kernel::sys::raw::c_int,
                                    format: *const ::kernel::sys::raw::c_char)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "root_bus"]
    pub static mut root_bus: device_t;
}
extern "C" {
    #[link_name = "root_devclass"]
    pub static mut root_devclass: devclass_t;
}
extern "C" {
    pub fn root_bus_configure();
}
extern "C" {
    pub fn bus_generic_activate_resource(dev: device_t, child: device_t,
                                         type_: ::kernel::sys::raw::c_int,
                                         rid: ::kernel::sys::raw::c_int,
                                         r: *mut resource)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_add_child(dev: device_t, order: u_int,
                                 name: *const ::kernel::sys::raw::c_char,
                                 unit: ::kernel::sys::raw::c_int) -> device_t;
}
extern "C" {
    pub fn bus_generic_adjust_resource(bus: device_t, child: device_t,
                                       type_: ::kernel::sys::raw::c_int,
                                       r: *mut resource, start: rman_res_t,
                                       end: rman_res_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_alloc_resource(bus: device_t, child: device_t,
                                      type_: ::kernel::sys::raw::c_int,
                                      rid: *mut ::kernel::sys::raw::c_int,
                                      start: rman_res_t, end: rman_res_t,
                                      count: rman_res_t, flags: u_int)
     -> *mut resource;
}
extern "C" {
    pub fn bus_generic_attach(dev: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_bind_intr(dev: device_t, child: device_t,
                                 irq: *mut resource,
                                 cpu: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_child_present(dev: device_t, child: device_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_config_intr(arg1: device_t,
                                   arg2: ::kernel::sys::raw::c_int,
                                   arg3: intr_trigger, arg4: intr_polarity)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_describe_intr(dev: device_t, child: device_t,
                                     irq: *mut resource,
                                     cookie: *mut ::kernel::sys::raw::c_void,
                                     descr: *const ::kernel::sys::raw::c_char)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_deactivate_resource(dev: device_t, child: device_t,
                                           type_: ::kernel::sys::raw::c_int,
                                           rid: ::kernel::sys::raw::c_int,
                                           r: *mut resource)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_detach(dev: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_driver_added(dev: device_t, driver: *mut driver_t);
}
extern "C" {
    pub fn bus_generic_get_cpus(dev: device_t, child: device_t, op: cpu_sets,
                                setsize: usize, cpuset: *mut _cpuset)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_get_dma_tag(dev: device_t, child: device_t)
     -> bus_dma_tag_t;
}
extern "C" {
    pub fn bus_generic_get_bus_tag(dev: device_t, child: device_t)
     -> bus_space_tag_t;
}
extern "C" {
    pub fn bus_generic_get_domain(dev: device_t, child: device_t,
                                  domain: *mut ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_get_resource_list(arg1: device_t, arg2: device_t)
     -> *mut resource_list;
}
extern "C" {
    pub fn bus_generic_map_resource(dev: device_t, child: device_t,
                                    type_: ::kernel::sys::raw::c_int,
                                    r: *mut resource,
                                    args: *mut resource_map_request,
                                    map: *mut resource_map)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_new_pass(dev: device_t);
}
extern "C" {
    pub fn bus_print_child_header(dev: device_t, child: device_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_print_child_domain(dev: device_t, child: device_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_print_child_footer(dev: device_t, child: device_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_print_child(dev: device_t, child: device_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_probe(dev: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_read_ivar(dev: device_t, child: device_t,
                                 which: ::kernel::sys::raw::c_int,
                                 result: *mut usize)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_release_resource(bus: device_t, child: device_t,
                                        type_: ::kernel::sys::raw::c_int,
                                        rid: ::kernel::sys::raw::c_int,
                                        r: *mut resource)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_resume(dev: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_resume_child(dev: device_t, child: device_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_setup_intr(dev: device_t, child: device_t,
                                  irq: *mut resource,
                                  flags: ::kernel::sys::raw::c_int,
                                  filter: driver_filter_t,
                                  intr: driver_intr_t,
                                  arg: *mut ::kernel::sys::raw::c_void,
                                  cookiep:
                                      *mut *mut ::kernel::sys::raw::c_void)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_rl_alloc_resource(arg1: device_t, arg2: device_t,
                                         arg3: ::kernel::sys::raw::c_int,
                                         arg4: *mut ::kernel::sys::raw::c_int,
                                         arg5: rman_res_t, arg6: rman_res_t,
                                         arg7: rman_res_t, arg8: u_int)
     -> *mut resource;
}
extern "C" {
    pub fn bus_generic_rl_delete_resource(arg1: device_t, arg2: device_t,
                                          arg3: ::kernel::sys::raw::c_int,
                                          arg4: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn bus_generic_rl_get_resource(arg1: device_t, arg2: device_t,
                                       arg3: ::kernel::sys::raw::c_int,
                                       arg4: ::kernel::sys::raw::c_int,
                                       arg5: *mut rman_res_t,
                                       arg6: *mut rman_res_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_rl_set_resource(arg1: device_t, arg2: device_t,
                                       arg3: ::kernel::sys::raw::c_int,
                                       arg4: ::kernel::sys::raw::c_int,
                                       arg5: rman_res_t, arg6: rman_res_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_rl_release_resource(arg1: device_t, arg2: device_t,
                                           arg3: ::kernel::sys::raw::c_int,
                                           arg4: ::kernel::sys::raw::c_int,
                                           arg5: *mut resource)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_shutdown(dev: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_suspend(dev: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_suspend_child(dev: device_t, child: device_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_teardown_intr(dev: device_t, child: device_t,
                                     irq: *mut resource,
                                     cookie: *mut ::kernel::sys::raw::c_void)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_unmap_resource(dev: device_t, child: device_t,
                                      type_: ::kernel::sys::raw::c_int,
                                      r: *mut resource,
                                      map: *mut resource_map)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_write_ivar(dev: device_t, child: device_t,
                                  which: ::kernel::sys::raw::c_int,
                                  value: usize) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_null_rescan(dev: device_t) -> ::kernel::sys::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct resource_spec {
    pub type_: ::kernel::sys::raw::c_int,
    pub rid: ::kernel::sys::raw::c_int,
    pub flags: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_resource_spec() {
    assert_eq!(::core::mem::size_of::<resource_spec>() , 12usize , concat ! (
               "Size of: " , stringify ! ( resource_spec ) ));
    assert_eq! (::core::mem::align_of::<resource_spec>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( resource_spec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_spec ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_spec ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_spec ) ) . rid as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_spec ) , "::"
                , stringify ! ( rid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_spec ) ) . flags as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_spec ) , "::"
                , stringify ! ( flags ) ));
}
impl Clone for resource_spec {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn bus_alloc_resources(dev: device_t, rs: *mut resource_spec,
                               res: *mut *mut resource)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_release_resources(dev: device_t, rs: *const resource_spec,
                                 res: *mut *mut resource);
}
extern "C" {
    pub fn bus_adjust_resource(child: device_t,
                               type_: ::kernel::sys::raw::c_int,
                               r: *mut resource, start: rman_res_t,
                               end: rman_res_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_alloc_resource(dev: device_t, type_: ::kernel::sys::raw::c_int,
                              rid: *mut ::kernel::sys::raw::c_int,
                              start: rman_res_t, end: rman_res_t,
                              count: rman_res_t, flags: u_int)
     -> *mut resource;
}
extern "C" {
    pub fn bus_activate_resource(dev: device_t,
                                 type_: ::kernel::sys::raw::c_int,
                                 rid: ::kernel::sys::raw::c_int,
                                 r: *mut resource)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_deactivate_resource(dev: device_t,
                                   type_: ::kernel::sys::raw::c_int,
                                   rid: ::kernel::sys::raw::c_int,
                                   r: *mut resource)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_map_resource(dev: device_t, type_: ::kernel::sys::raw::c_int,
                            r: *mut resource, args: *mut resource_map_request,
                            map: *mut resource_map)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_unmap_resource(dev: device_t, type_: ::kernel::sys::raw::c_int,
                              r: *mut resource, map: *mut resource_map)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_get_cpus(dev: device_t, op: cpu_sets, setsize: usize,
                        cpuset: *mut _cpuset) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_get_dma_tag(dev: device_t) -> bus_dma_tag_t;
}
extern "C" {
    pub fn bus_get_bus_tag(dev: device_t) -> bus_space_tag_t;
}
extern "C" {
    pub fn bus_get_domain(dev: device_t,
                          domain: *mut ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_release_resource(dev: device_t,
                                type_: ::kernel::sys::raw::c_int,
                                rid: ::kernel::sys::raw::c_int,
                                r: *mut resource)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_free_resource(dev: device_t, type_: ::kernel::sys::raw::c_int,
                             r: *mut resource) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_setup_intr(dev: device_t, r: *mut resource,
                          flags: ::kernel::sys::raw::c_int,
                          filter: driver_filter_t, handler: driver_intr_t,
                          arg: *mut ::kernel::sys::raw::c_void,
                          cookiep: *mut *mut ::kernel::sys::raw::c_void)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_teardown_intr(dev: device_t, r: *mut resource,
                             cookie: *mut ::kernel::sys::raw::c_void)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_bind_intr(dev: device_t, r: *mut resource,
                         cpu: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_describe_intr(dev: device_t, irq: *mut resource,
                             cookie: *mut ::kernel::sys::raw::c_void,
                             fmt: *const ::kernel::sys::raw::c_char, ...)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_set_resource(dev: device_t, type_: ::kernel::sys::raw::c_int,
                            rid: ::kernel::sys::raw::c_int, start: rman_res_t,
                            count: rman_res_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_get_resource(dev: device_t, type_: ::kernel::sys::raw::c_int,
                            rid: ::kernel::sys::raw::c_int,
                            startp: *mut rman_res_t, countp: *mut rman_res_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_get_resource_start(dev: device_t,
                                  type_: ::kernel::sys::raw::c_int,
                                  rid: ::kernel::sys::raw::c_int)
     -> rman_res_t;
}
extern "C" {
    pub fn bus_get_resource_count(dev: device_t,
                                  type_: ::kernel::sys::raw::c_int,
                                  rid: ::kernel::sys::raw::c_int)
     -> rman_res_t;
}
extern "C" {
    pub fn bus_delete_resource(dev: device_t,
                               type_: ::kernel::sys::raw::c_int,
                               rid: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn bus_child_present(child: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_child_pnpinfo_str(child: device_t,
                                 buf: *mut ::kernel::sys::raw::c_char,
                                 buflen: usize) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_child_location_str(child: device_t,
                                  buf: *mut ::kernel::sys::raw::c_char,
                                  buflen: usize) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_enumerate_hinted_children(bus: device_t);
}
extern "C" {
    pub fn device_add_child(dev: device_t,
                            name: *const ::kernel::sys::raw::c_char,
                            unit: ::kernel::sys::raw::c_int) -> device_t;
}
extern "C" {
    pub fn device_add_child_ordered(dev: device_t, order: u_int,
                                    name: *const ::kernel::sys::raw::c_char,
                                    unit: ::kernel::sys::raw::c_int)
     -> device_t;
}
extern "C" {
    pub fn device_busy(dev: device_t);
}
extern "C" {
    pub fn device_delete_child(dev: device_t, child: device_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn device_delete_children(dev: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn device_attach(dev: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn device_detach(dev: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn device_disable(dev: device_t);
}
extern "C" {
    pub fn device_enable(dev: device_t);
}
extern "C" {
    pub fn device_find_child(dev: device_t,
                             classname: *const ::kernel::sys::raw::c_char,
                             unit: ::kernel::sys::raw::c_int) -> device_t;
}
extern "C" {
    pub fn device_get_desc(dev: device_t)
     -> *const ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn device_get_devclass(dev: device_t) -> devclass_t;
}
extern "C" {
    pub fn device_get_driver(dev: device_t) -> *mut driver_t;
}
extern "C" {
    pub fn device_get_flags(dev: device_t) -> u_int32_t;
}
extern "C" {
    pub fn device_get_parent(dev: device_t) -> device_t;
}
extern "C" {
    pub fn device_get_children(dev: device_t, listp: *mut *mut device_t,
                               countp: *mut ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn device_get_ivars(dev: device_t) -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn device_set_ivars(dev: device_t,
                            ivars: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn device_get_name(dev: device_t)
     -> *const ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn device_get_nameunit(dev: device_t)
     -> *const ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn device_get_softc(dev: device_t) -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn device_get_state(dev: device_t) -> device_state_t;
}
extern "C" {
    pub fn device_get_unit(dev: device_t) -> ::kernel::sys::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sysctl_ctx_list {
    _unused: [u8; 0],
}
extern "C" {
    pub fn device_get_sysctl_ctx(dev: device_t) -> *mut sysctl_ctx_list;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sysctl_oid {
    _unused: [u8; 0],
}
extern "C" {
    pub fn device_get_sysctl_tree(dev: device_t) -> *mut sysctl_oid;
}
extern "C" {
    pub fn device_has_quiet_children(dev: device_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn device_is_alive(dev: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn device_is_attached(dev: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn device_is_enabled(dev: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn device_is_suspended(dev: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn device_is_quiet(dev: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn device_lookup_by_name(name: *const ::kernel::sys::raw::c_char)
     -> device_t;
}
extern "C" {
    pub fn device_print_prettyname(dev: device_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn device_printf(dev: device_t,
                         arg1: *const ::kernel::sys::raw::c_char, ...)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn device_probe(dev: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn device_probe_and_attach(dev: device_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn device_probe_child(bus: device_t, dev: device_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn device_quiesce(dev: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn device_quiet(dev: device_t);
}
extern "C" {
    pub fn device_quiet_children(dev: device_t);
}
extern "C" {
    pub fn device_set_desc(dev: device_t,
                           desc: *const ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn device_set_desc_copy(dev: device_t,
                                desc: *const ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn device_set_devclass(dev: device_t,
                               classname: *const ::kernel::sys::raw::c_char)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn device_set_devclass_fixed(dev: device_t,
                                     classname:
                                         *const ::kernel::sys::raw::c_char)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn device_set_driver(dev: device_t, driver: *mut driver_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn device_set_flags(dev: device_t, flags: u_int32_t);
}
extern "C" {
    pub fn device_set_softc(dev: device_t,
                            softc: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn device_free_softc(softc: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn device_claim_softc(dev: device_t);
}
extern "C" {
    pub fn device_set_unit(dev: device_t, unit: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn device_shutdown(dev: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn device_unbusy(dev: device_t);
}
extern "C" {
    pub fn device_verbose(dev: device_t);
}
extern "C" {
    pub fn devclass_add_driver(dc: devclass_t, driver: *mut driver_t,
                               pass: ::kernel::sys::raw::c_int,
                               dcp: *mut devclass_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn devclass_create(classname: *const ::kernel::sys::raw::c_char)
     -> devclass_t;
}
extern "C" {
    pub fn devclass_delete_driver(busclass: devclass_t, driver: *mut driver_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn devclass_find(classname: *const ::kernel::sys::raw::c_char)
     -> devclass_t;
}
extern "C" {
    pub fn devclass_get_name(dc: devclass_t)
     -> *const ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn devclass_get_device(dc: devclass_t,
                               unit: ::kernel::sys::raw::c_int) -> device_t;
}
extern "C" {
    pub fn devclass_get_softc(dc: devclass_t, unit: ::kernel::sys::raw::c_int)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn devclass_get_devices(dc: devclass_t, listp: *mut *mut device_t,
                                countp: *mut ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn devclass_get_drivers(dc: devclass_t,
                                listp: *mut *mut *mut driver_t,
                                countp: *mut ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn devclass_get_count(dc: devclass_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn devclass_get_maxunit(dc: devclass_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn devclass_find_free_unit(dc: devclass_t,
                                   unit: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn devclass_set_parent(dc: devclass_t, pdc: devclass_t);
}
extern "C" {
    pub fn devclass_get_parent(dc: devclass_t) -> devclass_t;
}
extern "C" {
    pub fn devclass_get_sysctl_ctx(dc: devclass_t) -> *mut sysctl_ctx_list;
}
extern "C" {
    pub fn devclass_get_sysctl_tree(dc: devclass_t) -> *mut sysctl_oid;
}
extern "C" {
    pub fn resource_int_value(name: *const ::kernel::sys::raw::c_char,
                              unit: ::kernel::sys::raw::c_int,
                              resname: *const ::kernel::sys::raw::c_char,
                              result: *mut ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn resource_long_value(name: *const ::kernel::sys::raw::c_char,
                               unit: ::kernel::sys::raw::c_int,
                               resname: *const ::kernel::sys::raw::c_char,
                               result: *mut ::kernel::sys::raw::c_long)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn resource_string_value(name: *const ::kernel::sys::raw::c_char,
                                 unit: ::kernel::sys::raw::c_int,
                                 resname: *const ::kernel::sys::raw::c_char,
                                 result:
                                     *mut *const ::kernel::sys::raw::c_char)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn resource_disabled(name: *const ::kernel::sys::raw::c_char,
                             unit: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn resource_find_match(anchor: *mut ::kernel::sys::raw::c_int,
                               name: *mut *const ::kernel::sys::raw::c_char,
                               unit: *mut ::kernel::sys::raw::c_int,
                               resname: *const ::kernel::sys::raw::c_char,
                               value: *const ::kernel::sys::raw::c_char)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn resource_find_dev(anchor: *mut ::kernel::sys::raw::c_int,
                             name: *const ::kernel::sys::raw::c_char,
                             unit: *mut ::kernel::sys::raw::c_int,
                             resname: *const ::kernel::sys::raw::c_char,
                             value: *const ::kernel::sys::raw::c_char)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn resource_unset_value(name: *const ::kernel::sys::raw::c_char,
                                unit: ::kernel::sys::raw::c_int,
                                resname: *const ::kernel::sys::raw::c_char)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_data_generation_check(generation: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_data_generation_update();
}
extern "C" {
    #[link_name = "bus_current_pass"]
    pub static mut bus_current_pass: ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_set_pass(pass: ::kernel::sys::raw::c_int);
}
extern "C" {
    #[link_name = "device_probe_desc"]
    pub static mut device_probe_desc: kobjop_desc;
}
/// @brief A function implementing the DEVICE_PROBE() method
pub type device_probe_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "device_identify_desc"]
    pub static mut device_identify_desc: kobjop_desc;
}
/// @brief A function implementing the DEVICE_IDENTIFY() method
pub type device_identify_t =
    ::core::option::Option<unsafe extern "C" fn(driver: *mut driver_t,
                                                parent: device_t)>;
extern "C" {
    #[link_name = "device_attach_desc"]
    pub static mut device_attach_desc: kobjop_desc;
}
/// @brief A function implementing the DEVICE_ATTACH() method
pub type device_attach_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "device_detach_desc"]
    pub static mut device_detach_desc: kobjop_desc;
}
/// @brief A function implementing the DEVICE_DETACH() method
pub type device_detach_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "device_shutdown_desc"]
    pub static mut device_shutdown_desc: kobjop_desc;
}
/// @brief A function implementing the DEVICE_SHUTDOWN() method
pub type device_shutdown_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "device_suspend_desc"]
    pub static mut device_suspend_desc: kobjop_desc;
}
/// @brief A function implementing the DEVICE_SUSPEND() method
pub type device_suspend_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "device_resume_desc"]
    pub static mut device_resume_desc: kobjop_desc;
}
/// @brief A function implementing the DEVICE_RESUME() method
pub type device_resume_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "device_quiesce_desc"]
    pub static mut device_quiesce_desc: kobjop_desc;
}
/// @brief A function implementing the DEVICE_QUIESCE() method
pub type device_quiesce_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "device_register_desc"]
    pub static mut device_register_desc: kobjop_desc;
}
/// @brief A function implementing the DEVICE_REGISTER() method
pub type device_register_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t)
                               -> *mut ::kernel::sys::raw::c_void>;
extern "C" {
    #[link_name = "bus_print_child_desc"]
    pub static mut bus_print_child_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_PRINT_CHILD() method
pub type bus_print_child_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_probe_nomatch_desc"]
    pub static mut bus_probe_nomatch_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_PROBE_NOMATCH() method
pub type bus_probe_nomatch_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t)>;
extern "C" {
    #[link_name = "bus_read_ivar_desc"]
    pub static mut bus_read_ivar_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_READ_IVAR() method
pub type bus_read_ivar_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t,
                                                _index:
                                                    ::kernel::sys::raw::c_int,
                                                _result: *mut usize)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_write_ivar_desc"]
    pub static mut bus_write_ivar_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_WRITE_IVAR() method
pub type bus_write_ivar_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t,
                                                _indx:
                                                    ::kernel::sys::raw::c_int,
                                                _value: usize)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_child_deleted_desc"]
    pub static mut bus_child_deleted_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_CHILD_DELETED() method
pub type bus_child_deleted_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t)>;
extern "C" {
    #[link_name = "bus_child_detached_desc"]
    pub static mut bus_child_detached_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_CHILD_DETACHED() method
pub type bus_child_detached_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t)>;
extern "C" {
    #[link_name = "bus_driver_added_desc"]
    pub static mut bus_driver_added_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_DRIVER_ADDED() method
pub type bus_driver_added_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _driver: *mut driver_t)>;
extern "C" {
    #[link_name = "bus_add_child_desc"]
    pub static mut bus_add_child_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_ADD_CHILD() method
pub type bus_add_child_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t, _order: u_int,
                                                _name:
                                                    *const ::kernel::sys::raw::c_char,
                                                _unit:
                                                    ::kernel::sys::raw::c_int)
                               -> device_t>;
extern "C" {
    #[link_name = "bus_rescan_desc"]
    pub static mut bus_rescan_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_RESCAN() method
pub type bus_rescan_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_alloc_resource_desc"]
    pub static mut bus_alloc_resource_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_ALLOC_RESOURCE() method
pub type bus_alloc_resource_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t,
                                                _type:
                                                    ::kernel::sys::raw::c_int,
                                                _rid:
                                                    *mut ::kernel::sys::raw::c_int,
                                                _start: rman_res_t,
                                                _end: rman_res_t,
                                                _count: rman_res_t,
                                                _flags: u_int)
                               -> *mut resource>;
extern "C" {
    #[link_name = "bus_activate_resource_desc"]
    pub static mut bus_activate_resource_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_ACTIVATE_RESOURCE() method
pub type bus_activate_resource_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t,
                                                _type:
                                                    ::kernel::sys::raw::c_int,
                                                _rid:
                                                    ::kernel::sys::raw::c_int,
                                                _r: *mut resource)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_map_resource_desc"]
    pub static mut bus_map_resource_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_MAP_RESOURCE() method
pub type bus_map_resource_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t,
                                                _type:
                                                    ::kernel::sys::raw::c_int,
                                                _r: *mut resource,
                                                _args:
                                                    *mut resource_map_request,
                                                _map: *mut resource_map)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_unmap_resource_desc"]
    pub static mut bus_unmap_resource_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_UNMAP_RESOURCE() method
pub type bus_unmap_resource_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t,
                                                _type:
                                                    ::kernel::sys::raw::c_int,
                                                _r: *mut resource,
                                                _map: *mut resource_map)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_deactivate_resource_desc"]
    pub static mut bus_deactivate_resource_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_DEACTIVATE_RESOURCE() method
pub type bus_deactivate_resource_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t,
                                                _type:
                                                    ::kernel::sys::raw::c_int,
                                                _rid:
                                                    ::kernel::sys::raw::c_int,
                                                _r: *mut resource)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_adjust_resource_desc"]
    pub static mut bus_adjust_resource_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_ADJUST_RESOURCE() method
pub type bus_adjust_resource_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t,
                                                _type:
                                                    ::kernel::sys::raw::c_int,
                                                _res: *mut resource,
                                                _start: rman_res_t,
                                                _end: rman_res_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_release_resource_desc"]
    pub static mut bus_release_resource_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_RELEASE_RESOURCE() method
pub type bus_release_resource_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t,
                                                _type:
                                                    ::kernel::sys::raw::c_int,
                                                _rid:
                                                    ::kernel::sys::raw::c_int,
                                                _res: *mut resource)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_setup_intr_desc"]
    pub static mut bus_setup_intr_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_SETUP_INTR() method
pub type bus_setup_intr_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t,
                                                _irq: *mut resource,
                                                _flags:
                                                    ::kernel::sys::raw::c_int,
                                                _filter: driver_filter_t,
                                                _intr: driver_intr_t,
                                                _arg:
                                                    *mut ::kernel::sys::raw::c_void,
                                                _cookiep:
                                                    *mut *mut ::kernel::sys::raw::c_void)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_teardown_intr_desc"]
    pub static mut bus_teardown_intr_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_TEARDOWN_INTR() method
pub type bus_teardown_intr_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t,
                                                _irq: *mut resource,
                                                _cookie:
                                                    *mut ::kernel::sys::raw::c_void)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_set_resource_desc"]
    pub static mut bus_set_resource_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_SET_RESOURCE() method
pub type bus_set_resource_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t,
                                                _type:
                                                    ::kernel::sys::raw::c_int,
                                                _rid:
                                                    ::kernel::sys::raw::c_int,
                                                _start: rman_res_t,
                                                _count: rman_res_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_get_resource_desc"]
    pub static mut bus_get_resource_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_GET_RESOURCE() method
pub type bus_get_resource_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t,
                                                _type:
                                                    ::kernel::sys::raw::c_int,
                                                _rid:
                                                    ::kernel::sys::raw::c_int,
                                                _startp: *mut rman_res_t,
                                                _countp: *mut rman_res_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_delete_resource_desc"]
    pub static mut bus_delete_resource_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_DELETE_RESOURCE() method
pub type bus_delete_resource_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t,
                                                _type:
                                                    ::kernel::sys::raw::c_int,
                                                _rid:
                                                    ::kernel::sys::raw::c_int)>;
extern "C" {
    #[link_name = "bus_get_resource_list_desc"]
    pub static mut bus_get_resource_list_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_GET_RESOURCE_LIST() method
pub type bus_get_resource_list_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t)
                               -> *mut resource_list>;
extern "C" {
    #[link_name = "bus_child_present_desc"]
    pub static mut bus_child_present_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_CHILD_PRESENT() method
pub type bus_child_present_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_child_pnpinfo_str_desc"]
    pub static mut bus_child_pnpinfo_str_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_CHILD_PNPINFO_STR() method
pub type bus_child_pnpinfo_str_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t,
                                                _buf:
                                                    *mut ::kernel::sys::raw::c_char,
                                                _buflen: usize)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_child_location_str_desc"]
    pub static mut bus_child_location_str_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_CHILD_LOCATION_STR() method
pub type bus_child_location_str_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t,
                                                _buf:
                                                    *mut ::kernel::sys::raw::c_char,
                                                _buflen: usize)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_bind_intr_desc"]
    pub static mut bus_bind_intr_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_BIND_INTR() method
pub type bus_bind_intr_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t,
                                                _irq: *mut resource,
                                                _cpu:
                                                    ::kernel::sys::raw::c_int)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_config_intr_desc"]
    pub static mut bus_config_intr_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_CONFIG_INTR() method
pub type bus_config_intr_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _irq:
                                                    ::kernel::sys::raw::c_int,
                                                _trig: intr_trigger,
                                                _pol: intr_polarity)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_describe_intr_desc"]
    pub static mut bus_describe_intr_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_DESCRIBE_INTR() method
pub type bus_describe_intr_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t,
                                                _irq: *mut resource,
                                                _cookie:
                                                    *mut ::kernel::sys::raw::c_void,
                                                _descr:
                                                    *const ::kernel::sys::raw::c_char)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_hinted_child_desc"]
    pub static mut bus_hinted_child_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_HINTED_CHILD() method
pub type bus_hinted_child_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _dname:
                                                    *const ::kernel::sys::raw::c_char,
                                                _dunit:
                                                    ::kernel::sys::raw::c_int)>;
extern "C" {
    #[link_name = "bus_get_dma_tag_desc"]
    pub static mut bus_get_dma_tag_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_GET_DMA_TAG() method
pub type bus_get_dma_tag_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t)
                               -> bus_dma_tag_t>;
extern "C" {
    #[link_name = "bus_get_bus_tag_desc"]
    pub static mut bus_get_bus_tag_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_GET_BUS_TAG() method
pub type bus_get_bus_tag_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t)
                               -> bus_space_tag_t>;
extern "C" {
    #[link_name = "bus_hint_device_unit_desc"]
    pub static mut bus_hint_device_unit_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_HINT_DEVICE_UNIT() method
pub type bus_hint_device_unit_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t,
                                                _name:
                                                    *const ::kernel::sys::raw::c_char,
                                                _unitp:
                                                    *mut ::kernel::sys::raw::c_int)>;
extern "C" {
    #[link_name = "bus_new_pass_desc"]
    pub static mut bus_new_pass_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_NEW_PASS() method
pub type bus_new_pass_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t)>;
extern "C" {
    #[link_name = "bus_remap_intr_desc"]
    pub static mut bus_remap_intr_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_REMAP_INTR() method
pub type bus_remap_intr_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t, _irq: u_int)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_suspend_child_desc"]
    pub static mut bus_suspend_child_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_SUSPEND_CHILD() method
pub type bus_suspend_child_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_resume_child_desc"]
    pub static mut bus_resume_child_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_RESUME_CHILD() method
pub type bus_resume_child_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_get_domain_desc"]
    pub static mut bus_get_domain_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_GET_DOMAIN() method
pub type bus_get_domain_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t,
                                                _domain:
                                                    *mut ::kernel::sys::raw::c_int)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_get_cpus_desc"]
    pub static mut bus_get_cpus_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_GET_CPUS() method
pub type bus_get_cpus_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t,
                                                _op: cpu_sets,
                                                _setsize: usize,
                                                _cpuset: *mut cpuset_t)
                               -> ::kernel::sys::raw::c_int>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct module {
    _unused: [u8; 0],
}
extern "C" {
    pub fn driver_module_handler(arg1: *mut module,
                                 arg2: ::kernel::sys::raw::c_int,
                                 arg3: *mut ::kernel::sys::raw::c_void)
     -> ::kernel::sys::raw::c_int;
}
/// Module support for automatically adding drivers to buses.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct driver_module_data {
    pub dmd_chainevh: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut module,
                                                                  arg2:
                                                                      ::kernel::sys::raw::c_int,
                                                                  arg3:
                                                                      *mut ::kernel::sys::raw::c_void)
                                                 ->
                                                     ::kernel::sys::raw::c_int>,
    pub dmd_chainarg: *mut ::kernel::sys::raw::c_void,
    pub dmd_busname: *const ::kernel::sys::raw::c_char,
    pub dmd_driver: kobj_class_t,
    pub dmd_devclass: *mut devclass_t,
    pub dmd_pass: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_driver_module_data() {
    assert_eq!(::core::mem::size_of::<driver_module_data>() , 48usize , concat
               ! ( "Size of: " , stringify ! ( driver_module_data ) ));
    assert_eq! (::core::mem::align_of::<driver_module_data>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( driver_module_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const driver_module_data ) ) . dmd_chainevh as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( driver_module_data ) ,
                "::" , stringify ! ( dmd_chainevh ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const driver_module_data ) ) . dmd_chainarg as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( driver_module_data ) ,
                "::" , stringify ! ( dmd_chainarg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const driver_module_data ) ) . dmd_busname as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( driver_module_data ) ,
                "::" , stringify ! ( dmd_busname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const driver_module_data ) ) . dmd_driver as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( driver_module_data ) ,
                "::" , stringify ! ( dmd_driver ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const driver_module_data ) ) . dmd_devclass as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( driver_module_data ) ,
                "::" , stringify ! ( dmd_devclass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const driver_module_data ) ) . dmd_pass as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( driver_module_data ) ,
                "::" , stringify ! ( dmd_pass ) ));
}
impl Clone for driver_module_data {
    fn clone(&self) -> Self { *self }
}
impl Default for driver_module_data {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rman_type { RMAN_UNINIT = 0, RMAN_GAUGE = 1, RMAN_ARRAY = 2, }
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct u_resource {
    pub r_handle: usize,
    pub r_parent: usize,
    pub r_device: usize,
    pub r_devname: [::kernel::sys::raw::c_char; 32usize],
    pub r_start: rman_res_t,
    pub r_size: rman_res_t,
    pub r_flags: u_int,
}
#[test]
fn bindgen_test_layout_u_resource() {
    assert_eq!(::core::mem::size_of::<u_resource>() , 80usize , concat ! (
               "Size of: " , stringify ! ( u_resource ) ));
    assert_eq! (::core::mem::align_of::<u_resource>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( u_resource ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_resource ) ) . r_handle as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( u_resource ) , "::" ,
                stringify ! ( r_handle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_resource ) ) . r_parent as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( u_resource ) , "::" ,
                stringify ! ( r_parent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_resource ) ) . r_device as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( u_resource ) , "::" ,
                stringify ! ( r_device ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_resource ) ) . r_devname as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( u_resource ) , "::" ,
                stringify ! ( r_devname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_resource ) ) . r_start as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( u_resource ) , "::" ,
                stringify ! ( r_start ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_resource ) ) . r_size as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( u_resource ) , "::" ,
                stringify ! ( r_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_resource ) ) . r_flags as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( u_resource ) , "::" ,
                stringify ! ( r_flags ) ));
}
impl Clone for u_resource {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct u_rman {
    pub rm_handle: usize,
    pub rm_descr: [::kernel::sys::raw::c_char; 32usize],
    pub rm_start: rman_res_t,
    pub rm_size: rman_res_t,
    pub rm_type: rman_type,
}
#[test]
fn bindgen_test_layout_u_rman() {
    assert_eq!(::core::mem::size_of::<u_rman>() , 64usize , concat ! (
               "Size of: " , stringify ! ( u_rman ) ));
    assert_eq! (::core::mem::align_of::<u_rman>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( u_rman ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_rman ) ) . rm_handle as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( u_rman ) , "::" ,
                stringify ! ( rm_handle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_rman ) ) . rm_descr as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( u_rman ) , "::" ,
                stringify ! ( rm_descr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_rman ) ) . rm_start as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( u_rman ) , "::" ,
                stringify ! ( rm_start ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_rman ) ) . rm_size as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( u_rman ) , "::" ,
                stringify ! ( rm_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_rman ) ) . rm_type as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( u_rman ) , "::" ,
                stringify ! ( rm_type ) ));
}
impl Clone for u_rman {
    fn clone(&self) -> Self { *self }
}
impl Default for u_rman {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct resource_i {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct resource_head {
    pub tqh_first: *mut resource_i,
    pub tqh_last: *mut *mut resource_i,
}
#[test]
fn bindgen_test_layout_resource_head() {
    assert_eq!(::core::mem::size_of::<resource_head>() , 16usize , concat ! (
               "Size of: " , stringify ! ( resource_head ) ));
    assert_eq! (::core::mem::align_of::<resource_head>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( resource_head ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_head ) ) . tqh_first as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_head ) , "::"
                , stringify ! ( tqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_head ) ) . tqh_last as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_head ) , "::"
                , stringify ! ( tqh_last ) ));
}
impl Clone for resource_head {
    fn clone(&self) -> Self { *self }
}
impl Default for resource_head {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rman {
    pub rm_list: resource_head,
    pub rm_mtx: *mut mtx,
    pub rm_link: rman__bindgen_ty_1,
    pub rm_start: rman_res_t,
    pub rm_end: rman_res_t,
    pub rm_type: rman_type,
    pub rm_descr: *const ::kernel::sys::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rman__bindgen_ty_1 {
    pub tqe_next: *mut rman,
    pub tqe_prev: *mut *mut rman,
}
#[test]
fn bindgen_test_layout_rman__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<rman__bindgen_ty_1>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( rman__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<rman__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rman__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rman__bindgen_ty_1 ) ) . tqe_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rman__bindgen_ty_1 ) ,
                "::" , stringify ! ( tqe_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rman__bindgen_ty_1 ) ) . tqe_prev as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rman__bindgen_ty_1 ) ,
                "::" , stringify ! ( tqe_prev ) ));
}
impl Clone for rman__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for rman__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_rman() {
    assert_eq!(::core::mem::size_of::<rman>() , 72usize , concat ! (
               "Size of: " , stringify ! ( rman ) ));
    assert_eq! (::core::mem::align_of::<rman>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rman ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rman ) ) . rm_list as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rman ) , "::" ,
                stringify ! ( rm_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rman ) ) . rm_mtx as * const _ as usize }
                , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rman ) , "::" ,
                stringify ! ( rm_mtx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rman ) ) . rm_link as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rman ) , "::" ,
                stringify ! ( rm_link ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rman ) ) . rm_start as * const _ as usize
                } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rman ) , "::" ,
                stringify ! ( rm_start ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rman ) ) . rm_end as * const _ as usize }
                , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( rman ) , "::" ,
                stringify ! ( rm_end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rman ) ) . rm_type as * const _ as usize
                } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( rman ) , "::" ,
                stringify ! ( rm_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rman ) ) . rm_descr as * const _ as usize
                } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( rman ) , "::" ,
                stringify ! ( rm_descr ) ));
}
impl Clone for rman {
    fn clone(&self) -> Self { *self }
}
impl Default for rman {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rman_head {
    pub tqh_first: *mut rman,
    pub tqh_last: *mut *mut rman,
}
#[test]
fn bindgen_test_layout_rman_head() {
    assert_eq!(::core::mem::size_of::<rman_head>() , 16usize , concat ! (
               "Size of: " , stringify ! ( rman_head ) ));
    assert_eq! (::core::mem::align_of::<rman_head>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rman_head ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rman_head ) ) . tqh_first as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rman_head ) , "::" ,
                stringify ! ( tqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rman_head ) ) . tqh_last as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rman_head ) , "::" ,
                stringify ! ( tqh_last ) ));
}
impl Clone for rman_head {
    fn clone(&self) -> Self { *self }
}
impl Default for rman_head {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    pub fn rman_activate_resource(r: *mut resource)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn rman_adjust_resource(r: *mut resource, start: rman_res_t,
                                end: rman_res_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn rman_first_free_region(rm: *mut rman, start: *mut rman_res_t,
                                  end: *mut rman_res_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn rman_get_bushandle(arg1: *mut resource) -> bus_space_handle_t;
}
extern "C" {
    pub fn rman_get_bustag(arg1: *mut resource) -> bus_space_tag_t;
}
extern "C" {
    pub fn rman_get_end(arg1: *mut resource) -> rman_res_t;
}
extern "C" {
    pub fn rman_get_device(arg1: *mut resource) -> device_t;
}
extern "C" {
    pub fn rman_get_flags(arg1: *mut resource) -> u_int;
}
extern "C" {
    pub fn rman_get_mapping(arg1: *mut resource, arg2: *mut resource_map);
}
extern "C" {
    pub fn rman_get_rid(arg1: *mut resource) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn rman_get_size(arg1: *mut resource) -> rman_res_t;
}
extern "C" {
    pub fn rman_get_start(arg1: *mut resource) -> rman_res_t;
}
extern "C" {
    pub fn rman_get_virtual(arg1: *mut resource)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn rman_deactivate_resource(r: *mut resource)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn rman_fini(rm: *mut rman) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn rman_init(rm: *mut rman) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn rman_init_from_resource(rm: *mut rman, r: *mut resource)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn rman_last_free_region(rm: *mut rman, start: *mut rman_res_t,
                                 end: *mut rman_res_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn rman_make_alignment_flags(size: u32) -> u32;
}
extern "C" {
    pub fn rman_manage_region(rm: *mut rman, start: rman_res_t,
                              end: rman_res_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn rman_is_region_manager(r: *mut resource, rm: *mut rman)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn rman_release_resource(r: *mut resource)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn rman_reserve_resource(rm: *mut rman, start: rman_res_t,
                                 end: rman_res_t, count: rman_res_t,
                                 flags: u_int, dev: device_t)
     -> *mut resource;
}
extern "C" {
    pub fn rman_reserve_resource_bound(rm: *mut rman, start: rman_res_t,
                                       end: rman_res_t, count: rman_res_t,
                                       bound: rman_res_t, flags: u_int,
                                       dev: device_t) -> *mut resource;
}
extern "C" {
    pub fn rman_set_bushandle(_r: *mut resource, _h: bus_space_handle_t);
}
extern "C" {
    pub fn rman_set_bustag(_r: *mut resource, _t: bus_space_tag_t);
}
extern "C" {
    pub fn rman_set_device(_r: *mut resource, _dev: device_t);
}
extern "C" {
    pub fn rman_set_end(_r: *mut resource, _end: rman_res_t);
}
extern "C" {
    pub fn rman_set_mapping(arg1: *mut resource, arg2: *mut resource_map);
}
extern "C" {
    pub fn rman_set_rid(_r: *mut resource, _rid: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn rman_set_start(_r: *mut resource, _start: rman_res_t);
}
extern "C" {
    pub fn rman_set_virtual(_r: *mut resource,
                            _v: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    #[link_name = "rman_head"]
    pub static mut rman_head: rman_head;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __va_list_tag {
    pub gp_offset: ::kernel::sys::raw::c_uint,
    pub fp_offset: ::kernel::sys::raw::c_uint,
    pub overflow_arg_area: *mut ::kernel::sys::raw::c_void,
    pub reg_save_area: *mut ::kernel::sys::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(::core::mem::size_of::<__va_list_tag>() , 24usize , concat ! (
               "Size of: " , stringify ! ( __va_list_tag ) ));
    assert_eq! (::core::mem::align_of::<__va_list_tag>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __va_list_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . gp_offset as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( gp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . fp_offset as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( fp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . overflow_arg_area as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( overflow_arg_area ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . reg_save_area as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( reg_save_area ) ));
}
impl Clone for __va_list_tag {
    fn clone(&self) -> Self { *self }
}
impl Default for __va_list_tag {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct witness {
    pub _address: u8,
}
impl Clone for witness {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct pmap {
    pub _address: u8,
}
impl Clone for pmap {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct amd64tss {
    pub _address: u8,
}
impl Clone for amd64tss {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct user_segment_descriptor {
    pub _address: u8,
}
impl Clone for user_segment_descriptor {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct system_segment_descriptor {
    pub _address: u8,
}
impl Clone for system_segment_descriptor {
    fn clone(&self) -> Self { *self }
}
