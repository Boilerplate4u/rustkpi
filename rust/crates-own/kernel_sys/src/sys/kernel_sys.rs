/* automatically generated by rust-bindgen */

pub const __GNUCLIKE_ASM: ::std::os::raw::c_uint = 3;
pub const __GNUCLIKE___TYPEOF: ::std::os::raw::c_uint = 1;
pub const __GNUCLIKE___OFFSETOF: ::std::os::raw::c_uint = 1;
pub const __GNUCLIKE___SECTION: ::std::os::raw::c_uint = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: ::std::os::raw::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: ::std::os::raw::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: ::std::os::raw::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: ::std::os::raw::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: ::std::os::raw::c_uint = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: ::std::os::raw::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: ::std::os::raw::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: ::std::os::raw::c_uint = 1;
pub const __CC_SUPPORTS_INLINE: ::std::os::raw::c_uint = 1;
pub const __CC_SUPPORTS___INLINE: ::std::os::raw::c_uint = 1;
pub const __CC_SUPPORTS___INLINE__: ::std::os::raw::c_uint = 1;
pub const __CC_SUPPORTS___FUNC__: ::std::os::raw::c_uint = 1;
pub const __CC_SUPPORTS_WARNING: ::std::os::raw::c_uint = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: ::std::os::raw::c_uint = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: ::std::os::raw::c_uint = 1;
pub const __POSIX_VISIBLE: ::std::os::raw::c_uint = 200809;
pub const __XSI_VISIBLE: ::std::os::raw::c_uint = 700;
pub const __BSD_VISIBLE: ::std::os::raw::c_uint = 1;
pub const __ISO_C_VISIBLE: ::std::os::raw::c_uint = 2011;
pub const __EXT1_VISIBLE: ::std::os::raw::c_uint = 1;
pub const __CHAR_BIT: ::std::os::raw::c_uint = 8;
pub const __SCHAR_MAX: ::std::os::raw::c_uint = 127;
pub const __SCHAR_MIN: ::std::os::raw::c_int = -128;
pub const __UCHAR_MAX: ::std::os::raw::c_uint = 255;
pub const __USHRT_MAX: ::std::os::raw::c_uint = 65535;
pub const __SHRT_MAX: ::std::os::raw::c_uint = 32767;
pub const __SHRT_MIN: ::std::os::raw::c_int = -32768;
pub const __UINT_MAX: ::std::os::raw::c_uint = 4294967295;
pub const __INT_MAX: ::std::os::raw::c_uint = 2147483647;
pub const __INT_MIN: ::std::os::raw::c_int = -2147483648;
pub const __ULONG_MAX: ::std::os::raw::c_int = -1;
pub const __LONG_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const __LONG_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const __ULLONG_MAX: ::std::os::raw::c_int = -1;
pub const __LLONG_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const __LLONG_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const __SSIZE_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const __SIZE_T_MAX: ::std::os::raw::c_int = -1;
pub const __OFF_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const __OFF_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const __UQUAD_MAX: ::std::os::raw::c_int = -1;
pub const __QUAD_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const __QUAD_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const __LONG_BIT: ::std::os::raw::c_uint = 64;
pub const __WORD_BIT: ::std::os::raw::c_uint = 32;
pub const __MINSIGSTKSZ: ::std::os::raw::c_uint = 2048;
pub const __WCHAR_MIN: ::std::os::raw::c_int = -2147483648;
pub const __WCHAR_MAX: ::std::os::raw::c_uint = 2147483647;
pub const _QUAD_HIGHWORD: ::std::os::raw::c_uint = 1;
pub const _QUAD_LOWWORD: ::std::os::raw::c_uint = 0;
pub const _LITTLE_ENDIAN: ::std::os::raw::c_uint = 1234;
pub const _BIG_ENDIAN: ::std::os::raw::c_uint = 4321;
pub const _PDP_ENDIAN: ::std::os::raw::c_uint = 3412;
pub const _BYTE_ORDER: ::std::os::raw::c_uint = 1234;
pub const LITTLE_ENDIAN: ::std::os::raw::c_uint = 1234;
pub const BIG_ENDIAN: ::std::os::raw::c_uint = 4321;
pub const PDP_ENDIAN: ::std::os::raw::c_uint = 3412;
pub const BYTE_ORDER: ::std::os::raw::c_uint = 1234;
pub const __bool_true_false_are_defined: ::std::os::raw::c_uint = 1;
pub const false_: ::std::os::raw::c_uint = 0;
pub const true_: ::std::os::raw::c_uint = 1;
pub const _SIG_WORDS: ::std::os::raw::c_uint = 4;
pub const _SIG_MAXSIG: ::std::os::raw::c_uint = 128;
pub const FD_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const BSD: ::std::os::raw::c_uint = 199506;
pub const BSD4_3: ::std::os::raw::c_uint = 1;
pub const BSD4_4: ::std::os::raw::c_uint = 1;
pub const __FreeBSD_version: ::std::os::raw::c_uint = 1200056;
pub const P_OSREL_SIGWAIT: ::std::os::raw::c_uint = 700000;
pub const P_OSREL_SIGSEGV: ::std::os::raw::c_uint = 700004;
pub const P_OSREL_MAP_ANON: ::std::os::raw::c_uint = 800104;
pub const P_OSREL_MAP_FSTRICT: ::std::os::raw::c_uint = 1100036;
pub const P_OSREL_SHUTDOWN_ENOTCONN: ::std::os::raw::c_uint = 1100077;
pub const P_OSREL_MAP_GUARD: ::std::os::raw::c_uint = 1200035;
pub const P_OSREL_WRFSBASE: ::std::os::raw::c_uint = 1200041;
pub const P_OSREL_CK_CYLGRP: ::std::os::raw::c_uint = 1200046;
pub const P_OSREL_VMTOTAL64: ::std::os::raw::c_uint = 1200054;
pub const ARG_MAX: ::std::os::raw::c_uint = 262144;
pub const CHILD_MAX: ::std::os::raw::c_uint = 40;
pub const MAX_CANON: ::std::os::raw::c_uint = 255;
pub const MAX_INPUT: ::std::os::raw::c_uint = 255;
pub const NAME_MAX: ::std::os::raw::c_uint = 255;
pub const NGROUPS_MAX: ::std::os::raw::c_uint = 1023;
pub const OPEN_MAX: ::std::os::raw::c_uint = 64;
pub const PATH_MAX: ::std::os::raw::c_uint = 1024;
pub const PIPE_BUF: ::std::os::raw::c_uint = 512;
pub const IOV_MAX: ::std::os::raw::c_uint = 1024;
pub const MAXCOMLEN: ::std::os::raw::c_uint = 19;
pub const MAXINTERP: ::std::os::raw::c_uint = 1024;
pub const MAXLOGNAME: ::std::os::raw::c_uint = 33;
pub const MAXUPRC: ::std::os::raw::c_uint = 40;
pub const NCARGS: ::std::os::raw::c_uint = 262144;
pub const NGROUPS: ::std::os::raw::c_uint = 1024;
pub const NOFILE: ::std::os::raw::c_uint = 64;
pub const NOGROUP: ::std::os::raw::c_uint = 65535;
pub const MAXHOSTNAMELEN: ::std::os::raw::c_uint = 256;
pub const SPECNAMELEN: ::std::os::raw::c_uint = 63;
pub const EPERM: ::std::os::raw::c_uint = 1;
pub const ENOENT: ::std::os::raw::c_uint = 2;
pub const ESRCH: ::std::os::raw::c_uint = 3;
pub const EINTR: ::std::os::raw::c_uint = 4;
pub const EIO: ::std::os::raw::c_uint = 5;
pub const ENXIO: ::std::os::raw::c_uint = 6;
pub const E2BIG: ::std::os::raw::c_uint = 7;
pub const ENOEXEC: ::std::os::raw::c_uint = 8;
pub const EBADF: ::std::os::raw::c_uint = 9;
pub const ECHILD: ::std::os::raw::c_uint = 10;
pub const EDEADLK: ::std::os::raw::c_uint = 11;
pub const ENOMEM: ::std::os::raw::c_uint = 12;
pub const EACCES: ::std::os::raw::c_uint = 13;
pub const EFAULT: ::std::os::raw::c_uint = 14;
pub const ENOTBLK: ::std::os::raw::c_uint = 15;
pub const EBUSY: ::std::os::raw::c_uint = 16;
pub const EEXIST: ::std::os::raw::c_uint = 17;
pub const EXDEV: ::std::os::raw::c_uint = 18;
pub const ENODEV: ::std::os::raw::c_uint = 19;
pub const ENOTDIR: ::std::os::raw::c_uint = 20;
pub const EISDIR: ::std::os::raw::c_uint = 21;
pub const EINVAL: ::std::os::raw::c_uint = 22;
pub const ENFILE: ::std::os::raw::c_uint = 23;
pub const EMFILE: ::std::os::raw::c_uint = 24;
pub const ENOTTY: ::std::os::raw::c_uint = 25;
pub const ETXTBSY: ::std::os::raw::c_uint = 26;
pub const EFBIG: ::std::os::raw::c_uint = 27;
pub const ENOSPC: ::std::os::raw::c_uint = 28;
pub const ESPIPE: ::std::os::raw::c_uint = 29;
pub const EROFS: ::std::os::raw::c_uint = 30;
pub const EMLINK: ::std::os::raw::c_uint = 31;
pub const EPIPE: ::std::os::raw::c_uint = 32;
pub const EDOM: ::std::os::raw::c_uint = 33;
pub const ERANGE: ::std::os::raw::c_uint = 34;
pub const EAGAIN: ::std::os::raw::c_uint = 35;
pub const EWOULDBLOCK: ::std::os::raw::c_uint = 35;
pub const EINPROGRESS: ::std::os::raw::c_uint = 36;
pub const EALREADY: ::std::os::raw::c_uint = 37;
pub const ENOTSOCK: ::std::os::raw::c_uint = 38;
pub const EDESTADDRREQ: ::std::os::raw::c_uint = 39;
pub const EMSGSIZE: ::std::os::raw::c_uint = 40;
pub const EPROTOTYPE: ::std::os::raw::c_uint = 41;
pub const ENOPROTOOPT: ::std::os::raw::c_uint = 42;
pub const EPROTONOSUPPORT: ::std::os::raw::c_uint = 43;
pub const ESOCKTNOSUPPORT: ::std::os::raw::c_uint = 44;
pub const EOPNOTSUPP: ::std::os::raw::c_uint = 45;
pub const ENOTSUP: ::std::os::raw::c_uint = 45;
pub const EPFNOSUPPORT: ::std::os::raw::c_uint = 46;
pub const EAFNOSUPPORT: ::std::os::raw::c_uint = 47;
pub const EADDRINUSE: ::std::os::raw::c_uint = 48;
pub const EADDRNOTAVAIL: ::std::os::raw::c_uint = 49;
pub const ENETDOWN: ::std::os::raw::c_uint = 50;
pub const ENETUNREACH: ::std::os::raw::c_uint = 51;
pub const ENETRESET: ::std::os::raw::c_uint = 52;
pub const ECONNABORTED: ::std::os::raw::c_uint = 53;
pub const ECONNRESET: ::std::os::raw::c_uint = 54;
pub const ENOBUFS: ::std::os::raw::c_uint = 55;
pub const EISCONN: ::std::os::raw::c_uint = 56;
pub const ENOTCONN: ::std::os::raw::c_uint = 57;
pub const ESHUTDOWN: ::std::os::raw::c_uint = 58;
pub const ETOOMANYREFS: ::std::os::raw::c_uint = 59;
pub const ETIMEDOUT: ::std::os::raw::c_uint = 60;
pub const ECONNREFUSED: ::std::os::raw::c_uint = 61;
pub const ELOOP: ::std::os::raw::c_uint = 62;
pub const ENAMETOOLONG: ::std::os::raw::c_uint = 63;
pub const EHOSTDOWN: ::std::os::raw::c_uint = 64;
pub const EHOSTUNREACH: ::std::os::raw::c_uint = 65;
pub const ENOTEMPTY: ::std::os::raw::c_uint = 66;
pub const EPROCLIM: ::std::os::raw::c_uint = 67;
pub const EUSERS: ::std::os::raw::c_uint = 68;
pub const EDQUOT: ::std::os::raw::c_uint = 69;
pub const ESTALE: ::std::os::raw::c_uint = 70;
pub const EREMOTE: ::std::os::raw::c_uint = 71;
pub const EBADRPC: ::std::os::raw::c_uint = 72;
pub const ERPCMISMATCH: ::std::os::raw::c_uint = 73;
pub const EPROGUNAVAIL: ::std::os::raw::c_uint = 74;
pub const EPROGMISMATCH: ::std::os::raw::c_uint = 75;
pub const EPROCUNAVAIL: ::std::os::raw::c_uint = 76;
pub const ENOLCK: ::std::os::raw::c_uint = 77;
pub const ENOSYS: ::std::os::raw::c_uint = 78;
pub const EFTYPE: ::std::os::raw::c_uint = 79;
pub const EAUTH: ::std::os::raw::c_uint = 80;
pub const ENEEDAUTH: ::std::os::raw::c_uint = 81;
pub const EIDRM: ::std::os::raw::c_uint = 82;
pub const ENOMSG: ::std::os::raw::c_uint = 83;
pub const EOVERFLOW: ::std::os::raw::c_uint = 84;
pub const ECANCELED: ::std::os::raw::c_uint = 85;
pub const EILSEQ: ::std::os::raw::c_uint = 86;
pub const ENOATTR: ::std::os::raw::c_uint = 87;
pub const EDOOFUS: ::std::os::raw::c_uint = 88;
pub const EBADMSG: ::std::os::raw::c_uint = 89;
pub const EMULTIHOP: ::std::os::raw::c_uint = 90;
pub const ENOLINK: ::std::os::raw::c_uint = 91;
pub const EPROTO: ::std::os::raw::c_uint = 92;
pub const ENOTCAPABLE: ::std::os::raw::c_uint = 93;
pub const ECAPMODE: ::std::os::raw::c_uint = 94;
pub const ENOTRECOVERABLE: ::std::os::raw::c_uint = 95;
pub const EOWNERDEAD: ::std::os::raw::c_uint = 96;
pub const ELAST: ::std::os::raw::c_uint = 96;
pub const ERESTART: ::std::os::raw::c_int = -1;
pub const EJUSTRETURN: ::std::os::raw::c_int = -2;
pub const ENOIOCTL: ::std::os::raw::c_int = -3;
pub const EDIRIOCTL: ::std::os::raw::c_int = -4;
pub const ERELOOKUP: ::std::os::raw::c_int = -5;
pub const DST_NONE: ::std::os::raw::c_uint = 0;
pub const DST_USA: ::std::os::raw::c_uint = 1;
pub const DST_AUST: ::std::os::raw::c_uint = 2;
pub const DST_WET: ::std::os::raw::c_uint = 3;
pub const DST_MET: ::std::os::raw::c_uint = 4;
pub const DST_EET: ::std::os::raw::c_uint = 5;
pub const DST_CAN: ::std::os::raw::c_uint = 6;
pub const SBT_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const ITIMER_REAL: ::std::os::raw::c_uint = 0;
pub const ITIMER_VIRTUAL: ::std::os::raw::c_uint = 1;
pub const ITIMER_PROF: ::std::os::raw::c_uint = 2;
pub const CLOCK_REALTIME: ::std::os::raw::c_uint = 0;
pub const CLOCK_VIRTUAL: ::std::os::raw::c_uint = 1;
pub const CLOCK_PROF: ::std::os::raw::c_uint = 2;
pub const CLOCK_MONOTONIC: ::std::os::raw::c_uint = 4;
pub const CLOCK_UPTIME: ::std::os::raw::c_uint = 5;
pub const CLOCK_UPTIME_PRECISE: ::std::os::raw::c_uint = 7;
pub const CLOCK_UPTIME_FAST: ::std::os::raw::c_uint = 8;
pub const CLOCK_REALTIME_PRECISE: ::std::os::raw::c_uint = 9;
pub const CLOCK_REALTIME_FAST: ::std::os::raw::c_uint = 10;
pub const CLOCK_MONOTONIC_PRECISE: ::std::os::raw::c_uint = 11;
pub const CLOCK_MONOTONIC_FAST: ::std::os::raw::c_uint = 12;
pub const CLOCK_SECOND: ::std::os::raw::c_uint = 13;
pub const CLOCK_THREAD_CPUTIME_ID: ::std::os::raw::c_uint = 14;
pub const CLOCK_PROCESS_CPUTIME_ID: ::std::os::raw::c_uint = 15;
pub const TIMER_RELTIME: ::std::os::raw::c_uint = 0;
pub const TIMER_ABSTIME: ::std::os::raw::c_uint = 1;
pub const CPUCLOCK_WHICH_PID: ::std::os::raw::c_uint = 0;
pub const CPUCLOCK_WHICH_TID: ::std::os::raw::c_uint = 1;
pub const TC_DEFAULTPERC: ::std::os::raw::c_uint = 5;
pub const PRI_ITHD: ::std::os::raw::c_uint = 1;
pub const PRI_REALTIME: ::std::os::raw::c_uint = 2;
pub const PRI_TIMESHARE: ::std::os::raw::c_uint = 3;
pub const PRI_IDLE: ::std::os::raw::c_uint = 4;
pub const PRI_FIFO_BIT: ::std::os::raw::c_uint = 8;
pub const PRI_FIFO: ::std::os::raw::c_uint = 10;
pub const PRI_MIN: ::std::os::raw::c_uint = 0;
pub const PRI_MAX: ::std::os::raw::c_uint = 255;
pub const PRI_MIN_ITHD: ::std::os::raw::c_uint = 0;
pub const PI_REALTIME: ::std::os::raw::c_uint = 0;
pub const PI_AV: ::std::os::raw::c_uint = 4;
pub const PI_NET: ::std::os::raw::c_uint = 8;
pub const PI_DISK: ::std::os::raw::c_uint = 12;
pub const PI_TTY: ::std::os::raw::c_uint = 16;
pub const PI_DULL: ::std::os::raw::c_uint = 20;
pub const PI_SOFT: ::std::os::raw::c_uint = 24;
pub const PRI_MIN_REALTIME: ::std::os::raw::c_uint = 48;
pub const PRI_MIN_KERN: ::std::os::raw::c_uint = 80;
pub const PSWP: ::std::os::raw::c_uint = 80;
pub const PVM: ::std::os::raw::c_uint = 84;
pub const PINOD: ::std::os::raw::c_uint = 88;
pub const PRIBIO: ::std::os::raw::c_uint = 92;
pub const PVFS: ::std::os::raw::c_uint = 96;
pub const PZERO: ::std::os::raw::c_uint = 100;
pub const PSOCK: ::std::os::raw::c_uint = 104;
pub const PWAIT: ::std::os::raw::c_uint = 108;
pub const PLOCK: ::std::os::raw::c_uint = 112;
pub const PPAUSE: ::std::os::raw::c_uint = 116;
pub const PRI_MIN_TIMESHARE: ::std::os::raw::c_uint = 120;
pub const PUSER: ::std::os::raw::c_uint = 120;
pub const PRI_MIN_IDLE: ::std::os::raw::c_uint = 224;
pub const PRI_MAX_IDLE: ::std::os::raw::c_uint = 255;
pub const PRI_USER: ::std::os::raw::c_int = -2;
pub const PRI_UNCHANGED: ::std::os::raw::c_int = -1;
pub const FALSE: ::std::os::raw::c_uint = 0;
pub const TRUE: ::std::os::raw::c_uint = 1;
pub const MACHINE: &'static [u8; 6usize] = b"amd64\x00";
pub const MACHINE_ARCH: &'static [u8; 6usize] = b"amd64\x00";
pub const MACHINE_ARCH32: &'static [u8; 5usize] = b"i386\x00";
pub const MAXCPU: ::std::os::raw::c_uint = 256;
pub const MAXMEMDOM: ::std::os::raw::c_uint = 8;
pub const CACHE_LINE_SHIFT: ::std::os::raw::c_uint = 6;
pub const CACHE_LINE_SIZE: ::std::os::raw::c_uint = 64;
pub const NPTEPGSHIFT: ::std::os::raw::c_uint = 9;
pub const PAGE_SHIFT: ::std::os::raw::c_uint = 12;
pub const PAGE_SIZE: ::std::os::raw::c_uint = 4096;
pub const PAGE_MASK: ::std::os::raw::c_uint = 4095;
pub const NPDEPGSHIFT: ::std::os::raw::c_uint = 9;
pub const PDRSHIFT: ::std::os::raw::c_uint = 21;
pub const NBPDR: ::std::os::raw::c_uint = 2097152;
pub const PDRMASK: ::std::os::raw::c_uint = 2097151;
pub const NPDPEPGSHIFT: ::std::os::raw::c_uint = 9;
pub const PDPSHIFT: ::std::os::raw::c_uint = 30;
pub const NBPDP: ::std::os::raw::c_uint = 1073741824;
pub const PDPMASK: ::std::os::raw::c_uint = 1073741823;
pub const NPML4EPGSHIFT: ::std::os::raw::c_uint = 9;
pub const PML4SHIFT: ::std::os::raw::c_uint = 39;
pub const NBPML4: ::std::os::raw::c_ulonglong = 549755813888;
pub const PML4MASK: ::std::os::raw::c_ulonglong = 549755813887;
pub const MAXPAGESIZES: ::std::os::raw::c_uint = 3;
pub const IOPAGES: ::std::os::raw::c_uint = 2;
pub const IOPERM_BITMAP_SIZE: ::std::os::raw::c_uint = 8193;
pub const KSTACK_PAGES: ::std::os::raw::c_uint = 4;
pub const KSTACK_GUARD_PAGES: ::std::os::raw::c_uint = 1;
pub const DEV_BSHIFT: ::std::os::raw::c_uint = 9;
pub const DEV_BSIZE: ::std::os::raw::c_uint = 512;
pub const BLKDEV_IOSIZE: ::std::os::raw::c_uint = 4096;
pub const DFLTPHYS: ::std::os::raw::c_uint = 65536;
pub const MAXPHYS: ::std::os::raw::c_uint = 131072;
pub const MAXDUMPPGS: ::std::os::raw::c_uint = 16;
pub const MSIZE: ::std::os::raw::c_uint = 256;
pub const MCLSHIFT: ::std::os::raw::c_uint = 11;
pub const MCLBYTES: ::std::os::raw::c_uint = 2048;
pub const MJUMPAGESIZE: ::std::os::raw::c_uint = 4096;
pub const MJUM9BYTES: ::std::os::raw::c_uint = 9216;
pub const MJUM16BYTES: ::std::os::raw::c_uint = 16384;
pub const PRIMASK: ::std::os::raw::c_uint = 255;
pub const PCATCH: ::std::os::raw::c_uint = 256;
pub const PDROP: ::std::os::raw::c_uint = 512;
pub const NZERO: ::std::os::raw::c_uint = 0;
pub const NBBY: ::std::os::raw::c_uint = 8;
pub const CMASK: ::std::os::raw::c_uint = 18;
pub const MAXBSIZE: ::std::os::raw::c_uint = 65536;
pub const MAXBCACHEBUF: ::std::os::raw::c_uint = 65536;
pub const BKVASIZE: ::std::os::raw::c_uint = 16384;
pub const BKVAMASK: ::std::os::raw::c_uint = 16383;
pub const MAXPATHLEN: ::std::os::raw::c_uint = 1024;
pub const MAXSYMLINKS: ::std::os::raw::c_uint = 32;
pub const FSHIFT: ::std::os::raw::c_uint = 11;
pub const FSCALE: ::std::os::raw::c_uint = 2048;
pub const TS_ENTER: ::std::os::raw::c_uint = 0;
pub const TS_EXIT: ::std::os::raw::c_uint = 1;
pub const TS_THREAD: ::std::os::raw::c_uint = 2;
pub const TS_EVENT: ::std::os::raw::c_uint = 3;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __clock_t = __int32_t;
pub type __critical_t = __int64_t;
pub type __double_t = f64;
pub type __float_t = f32;
pub type __intfptr_t = __int64_t;
pub type __intptr_t = __int64_t;
pub type __intmax_t = __int64_t;
pub type __int_fast8_t = __int32_t;
pub type __int_fast16_t = __int32_t;
pub type __int_fast32_t = __int32_t;
pub type __int_fast64_t = __int64_t;
pub type __int_least8_t = __int8_t;
pub type __int_least16_t = __int16_t;
pub type __int_least32_t = __int32_t;
pub type __int_least64_t = __int64_t;
pub type __ptrdiff_t = __int64_t;
pub type __register_t = __int64_t;
pub type __segsz_t = __int64_t;
pub type __size_t = __uint64_t;
pub type __ssize_t = __int64_t;
pub type __time_t = __int64_t;
pub type __uintfptr_t = __uint64_t;
pub type __uintptr_t = __uint64_t;
pub type __uintmax_t = __uint64_t;
pub type __uint_fast8_t = __uint32_t;
pub type __uint_fast16_t = __uint32_t;
pub type __uint_fast32_t = __uint32_t;
pub type __uint_fast64_t = __uint64_t;
pub type __uint_least8_t = __uint8_t;
pub type __uint_least16_t = __uint16_t;
pub type __uint_least32_t = __uint32_t;
pub type __uint_least64_t = __uint64_t;
pub type __u_register_t = __uint64_t;
pub type __vm_offset_t = __uint64_t;
pub type __vm_paddr_t = __uint64_t;
pub type __vm_size_t = __uint64_t;
pub type ___wchar_t = ::std::os::raw::c_int;
pub type __va_list = __builtin_va_list;
pub type __gnuc_va_list = __va_list;
pub type __blksize_t = __int32_t;
pub type __blkcnt_t = __int64_t;
pub type __clockid_t = __int32_t;
pub type __fflags_t = __uint32_t;
pub type __fsblkcnt_t = __uint64_t;
pub type __fsfilcnt_t = __uint64_t;
pub type __gid_t = __uint32_t;
pub type __id_t = __int64_t;
pub type __ino_t = __uint64_t;
pub type __key_t = ::std::os::raw::c_long;
pub type __lwpid_t = __int32_t;
pub type __mode_t = __uint16_t;
pub type __accmode_t = ::std::os::raw::c_int;
pub type __nl_item = ::std::os::raw::c_int;
pub type __nlink_t = __uint64_t;
pub type __off_t = __int64_t;
pub type __off64_t = __int64_t;
pub type __pid_t = __int32_t;
pub type __rlim_t = __int64_t;
pub type __sa_family_t = __uint8_t;
pub type __socklen_t = __uint32_t;
pub type __suseconds_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __timer {
    _unused: [u8; 0],
}
pub type __timer_t = *mut __timer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __mq {
    _unused: [u8; 0],
}
pub type __mqd_t = *mut __mq;
pub type __uid_t = __uint32_t;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __cpuwhich_t = ::std::os::raw::c_int;
pub type __cpulevel_t = ::std::os::raw::c_int;
pub type __cpusetid_t = ::std::os::raw::c_int;
pub type __ct_rune_t = ::std::os::raw::c_int;
pub type __rune_t = __ct_rune_t;
pub type __wint_t = __ct_rune_t;
pub type __char16_t = __uint_least16_t;
pub type __char32_t = __uint_least32_t;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct __max_align_t {
    pub __max_align1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __max_align2: f64,
}
#[test]
fn bindgen_test_layout___max_align_t() {
    assert_eq!(::std::mem::size_of::<__max_align_t>() , 32usize , concat ! (
               "Size of: " , stringify ! ( __max_align_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __max_align_t ) ) . __max_align1 as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __max_align_t ) , "::"
                , stringify ! ( __max_align1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __max_align_t ) ) . __max_align2 as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __max_align_t ) , "::"
                , stringify ! ( __max_align2 ) ));
}
impl Clone for __max_align_t {
    fn clone(&self) -> Self { *self }
}
pub type __dev_t = __uint64_t;
pub type __fixpt_t = __uint32_t;
#[repr(C)]
#[derive(Copy)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: __int64_t,
    _bindgen_union_align: [u64; 16usize],
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(::std::mem::size_of::<__mbstate_t>() , 128usize , concat ! (
               "Size of: " , stringify ! ( __mbstate_t ) ));
    assert_eq! (::std::mem::align_of::<__mbstate_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __mbstate_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . __mbstate8 as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( __mbstate8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . _mbstateL as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( _mbstateL ) ));
}
impl Clone for __mbstate_t {
    fn clone(&self) -> Self { *self }
}
impl Default for __mbstate_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl ::std::fmt::Debug for __mbstate_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f , "__mbstate_t {{ union }}")
    }
}
pub type __rman_res_t = __uintmax_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_cond {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_cond_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutex {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutex_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_once {
    pub state: ::std::os::raw::c_int,
    pub mutex: pthread_mutex_t,
}
#[test]
fn bindgen_test_layout_pthread_once() {
    assert_eq!(::std::mem::size_of::<pthread_once>() , 16usize , concat ! (
               "Size of: " , stringify ! ( pthread_once ) ));
    assert_eq! (::std::mem::align_of::<pthread_once>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_once ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_once ) ) . state as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_once ) , "::" ,
                stringify ! ( state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_once ) ) . mutex as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_once ) , "::" ,
                stringify ! ( mutex ) ));
}
impl Clone for pthread_once {
    fn clone(&self) -> Self { *self }
}
impl Default for pthread_once {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_rwlock {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_rwlockattr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_barrier {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_barrier_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_spinlock {
    _unused: [u8; 0],
}
pub type pthread_t = *mut pthread;
pub type pthread_attr_t = *mut pthread_attr;
pub type pthread_mutex_t = *mut pthread_mutex;
pub type pthread_mutexattr_t = *mut pthread_mutex_attr;
pub type pthread_cond_t = *mut pthread_cond;
pub type pthread_condattr_t = *mut pthread_cond_attr;
pub type pthread_key_t = ::std::os::raw::c_int;
pub type pthread_once_t = pthread_once;
pub type pthread_rwlock_t = *mut pthread_rwlock;
pub type pthread_rwlockattr_t = *mut pthread_rwlockattr;
pub type pthread_barrier_t = *mut pthread_barrier;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_barrierattr {
    _unused: [u8; 0],
}
pub type pthread_barrierattr_t = *mut pthread_barrierattr;
pub type pthread_spinlock_t = *mut pthread_spinlock;
pub type pthread_addr_t = *mut ::std::os::raw::c_void;
pub type pthread_startroutine_t =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void)
                              -> *mut ::std::os::raw::c_void>;
pub type u_char = ::std::os::raw::c_uchar;
pub type u_short = ::std::os::raw::c_ushort;
pub type u_int = ::std::os::raw::c_uint;
pub type u_long = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type u_quad_t = __uint64_t;
pub type quad_t = __int64_t;
pub type qaddr_t = *mut quad_t;
pub type caddr_t = *mut ::std::os::raw::c_char;
pub type c_caddr_t = *const ::std::os::raw::c_char;
pub type blksize_t = __blksize_t;
pub type cpuwhich_t = __cpuwhich_t;
pub type cpulevel_t = __cpulevel_t;
pub type cpusetid_t = __cpusetid_t;
pub type blkcnt_t = __blkcnt_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type critical_t = __critical_t;
pub type daddr_t = __int64_t;
pub type dev_t = __dev_t;
pub type fflags_t = __fflags_t;
pub type fixpt_t = __fixpt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type gid_t = __gid_t;
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type id_t = __id_t;
pub type ino_t = __ino_t;
pub type key_t = __key_t;
pub type lwpid_t = __lwpid_t;
pub type mode_t = __mode_t;
pub type accmode_t = __accmode_t;
pub type nlink_t = __nlink_t;
pub type off_t = __off_t;
pub type off64_t = __off64_t;
pub type pid_t = __pid_t;
pub type register_t = __register_t;
pub type rlim_t = __rlim_t;
pub type sbintime_t = __int64_t;
pub type segsz_t = __segsz_t;
pub type suseconds_t = __suseconds_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type mqd_t = __mqd_t;
pub type u_register_t = __u_register_t;
pub type uid_t = __uid_t;
pub type useconds_t = __useconds_t;
pub type cap_ioctl_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cap_rights {
    _unused: [u8; 0],
}
pub type cap_rights_t = cap_rights;
pub type vm_offset_t = __vm_offset_t;
pub type vm_ooffset_t = __int64_t;
pub type vm_paddr_t = __vm_paddr_t;
pub type vm_pindex_t = __uint64_t;
pub type vm_size_t = __vm_size_t;
pub type rman_res_t = __rman_res_t;
pub type boolean_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct device {
    _unused: [u8; 0],
}
pub type device_t = *mut device;
pub type intfptr_t = __intfptr_t;
pub type intrmask_t = __uint32_t;
pub type uintfptr_t = __uintfptr_t;
pub type uoff_t = __uint64_t;
pub type vm_memattr_t = ::std::os::raw::c_char;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_page {
    _unused: [u8; 0],
}
pub type vm_page_t = *mut vm_page;
pub type bool_ = bool;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct __sigset {
    pub __bits: [__uint32_t; 4usize],
}
#[test]
fn bindgen_test_layout___sigset() {
    assert_eq!(::std::mem::size_of::<__sigset>() , 16usize , concat ! (
               "Size of: " , stringify ! ( __sigset ) ));
    assert_eq! (::std::mem::align_of::<__sigset>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( __sigset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sigset ) ) . __bits as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sigset ) , "::" ,
                stringify ! ( __bits ) ));
}
impl Clone for __sigset {
    fn clone(&self) -> Self { *self }
}
pub type __sigset_t = __sigset;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct timeval {
    pub tv_sec: time_t,
    pub tv_usec: suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(::std::mem::size_of::<timeval>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timeval ) ));
    assert_eq! (::std::mem::align_of::<timeval>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timeval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_usec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_usec ) ));
}
impl Clone for timeval {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(::std::mem::size_of::<timespec>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timespec ) ));
    assert_eq! (::std::mem::align_of::<timespec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timespec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_nsec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_nsec ) ));
}
impl Clone for timespec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(::std::mem::size_of::<itimerspec>() , 32usize , concat ! (
               "Size of: " , stringify ! ( itimerspec ) ));
    assert_eq! (::std::mem::align_of::<itimerspec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( itimerspec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerspec ) ) . it_interval as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerspec ) , "::" ,
                stringify ! ( it_interval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerspec ) ) . it_value as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerspec ) , "::" ,
                stringify ! ( it_value ) ));
}
impl Clone for itimerspec {
    fn clone(&self) -> Self { *self }
}
pub type __fd_mask = ::std::os::raw::c_ulong;
pub type fd_mask = __fd_mask;
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(::std::mem::size_of::<fd_set>() , 128usize , concat ! (
               "Size of: " , stringify ! ( fd_set ) ));
    assert_eq! (::std::mem::align_of::<fd_set>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( fd_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fd_set ) ) . __fds_bits as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( fd_set ) , "::" ,
                stringify ! ( __fds_bits ) ));
}
impl Clone for fd_set {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct timezone {
    pub tz_minuteswest: ::std::os::raw::c_int,
    pub tz_dsttime: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_timezone() {
    assert_eq!(::std::mem::size_of::<timezone>() , 8usize , concat ! (
               "Size of: " , stringify ! ( timezone ) ));
    assert_eq! (::std::mem::align_of::<timezone>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( timezone ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timezone ) ) . tz_minuteswest as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timezone ) , "::" ,
                stringify ! ( tz_minuteswest ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timezone ) ) . tz_dsttime as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( timezone ) , "::" ,
                stringify ! ( tz_dsttime ) ));
}
impl Clone for timezone {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct bintime {
    pub sec: time_t,
    pub frac: u64,
}
#[test]
fn bindgen_test_layout_bintime() {
    assert_eq!(::std::mem::size_of::<bintime>() , 16usize , concat ! (
               "Size of: " , stringify ! ( bintime ) ));
    assert_eq! (::std::mem::align_of::<bintime>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( bintime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bintime ) ) . sec as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( bintime ) , "::" ,
                stringify ! ( sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bintime ) ) . frac as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( bintime ) , "::" ,
                stringify ! ( frac ) ));
}
impl Clone for bintime {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
#[test]
fn bindgen_test_layout_itimerval() {
    assert_eq!(::std::mem::size_of::<itimerval>() , 32usize , concat ! (
               "Size of: " , stringify ! ( itimerval ) ));
    assert_eq! (::std::mem::align_of::<itimerval>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( itimerval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerval ) ) . it_interval as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerval ) , "::" ,
                stringify ! ( it_interval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerval ) ) . it_value as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerval ) , "::" ,
                stringify ! ( it_value ) ));
}
impl Clone for itimerval {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct clockinfo {
    pub hz: ::std::os::raw::c_int,
    pub tick: ::std::os::raw::c_int,
    pub spare: ::std::os::raw::c_int,
    pub stathz: ::std::os::raw::c_int,
    pub profhz: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_clockinfo() {
    assert_eq!(::std::mem::size_of::<clockinfo>() , 20usize , concat ! (
               "Size of: " , stringify ! ( clockinfo ) ));
    assert_eq! (::std::mem::align_of::<clockinfo>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( clockinfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clockinfo ) ) . hz as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( clockinfo ) , "::" ,
                stringify ! ( hz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clockinfo ) ) . tick as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( clockinfo ) , "::" ,
                stringify ! ( tick ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clockinfo ) ) . spare as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( clockinfo ) , "::" ,
                stringify ! ( spare ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clockinfo ) ) . stathz as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( clockinfo ) , "::" ,
                stringify ! ( stathz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clockinfo ) ) . profhz as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( clockinfo ) , "::" ,
                stringify ! ( profhz ) ));
}
impl Clone for clockinfo {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn inittodr(base: time_t);
}
extern "C" {
    pub fn resettodr();
}
extern "C" {
    #[link_name = "time_second"]
    pub static mut time_second: time_t;
}
extern "C" {
    #[link_name = "time_uptime"]
    pub static mut time_uptime: time_t;
}
extern "C" {
    #[link_name = "tc_tick_bt"]
    pub static mut tc_tick_bt: bintime;
}
extern "C" {
    #[link_name = "tc_tick_sbt"]
    pub static mut tc_tick_sbt: sbintime_t;
}
extern "C" {
    #[link_name = "tick_bt"]
    pub static mut tick_bt: bintime;
}
extern "C" {
    #[link_name = "tick_sbt"]
    pub static mut tick_sbt: sbintime_t;
}
extern "C" {
    #[link_name = "tc_precexp"]
    pub static mut tc_precexp: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "tc_timepercentage"]
    pub static mut tc_timepercentage: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "bt_timethreshold"]
    pub static mut bt_timethreshold: bintime;
}
extern "C" {
    #[link_name = "bt_tickthreshold"]
    pub static mut bt_tickthreshold: bintime;
}
extern "C" {
    #[link_name = "sbt_timethreshold"]
    pub static mut sbt_timethreshold: sbintime_t;
}
extern "C" {
    #[link_name = "sbt_tickthreshold"]
    pub static mut sbt_tickthreshold: sbintime_t;
}
extern "C" {
    #[link_name = "rtc_generation"]
    pub static mut rtc_generation: ::std::os::raw::c_int;
}
extern "C" {
    pub fn binuptime(bt: *mut bintime);
}
extern "C" {
    pub fn nanouptime(tsp: *mut timespec);
}
extern "C" {
    pub fn microuptime(tvp: *mut timeval);
}
extern "C" {
    pub fn bintime(bt: *mut bintime);
}
extern "C" {
    pub fn nanotime(tsp: *mut timespec);
}
extern "C" {
    pub fn microtime(tvp: *mut timeval);
}
extern "C" {
    pub fn getbinuptime(bt: *mut bintime);
}
extern "C" {
    pub fn getnanouptime(tsp: *mut timespec);
}
extern "C" {
    pub fn getmicrouptime(tvp: *mut timeval);
}
extern "C" {
    pub fn getbintime(bt: *mut bintime);
}
extern "C" {
    pub fn getnanotime(tsp: *mut timespec);
}
extern "C" {
    pub fn getmicrotime(tvp: *mut timeval);
}
extern "C" {
    pub fn getboottime(boottime: *mut timeval);
}
extern "C" {
    pub fn getboottimebin(boottimebin: *mut bintime);
}
extern "C" {
    pub fn itimerdecr(itp: *mut itimerval, usec: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn itimerfix(tv: *mut timeval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ppsratecheck(arg1: *mut timeval, arg2: *mut ::std::os::raw::c_int,
                        arg3: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ratecheck(arg1: *mut timeval, arg2: *const timeval)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timevaladd(t1: *mut timeval, t2: *const timeval);
}
extern "C" {
    pub fn timevalsub(t1: *mut timeval, t2: *const timeval);
}
extern "C" {
    pub fn tvtohz(tv: *mut timeval) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct priority {
    pub pri_class: u_char,
    pub pri_level: u_char,
    pub pri_native: u_char,
    pub pri_user: u_char,
}
#[test]
fn bindgen_test_layout_priority() {
    assert_eq!(::std::mem::size_of::<priority>() , 4usize , concat ! (
               "Size of: " , stringify ! ( priority ) ));
    assert_eq! (::std::mem::align_of::<priority>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( priority ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const priority ) ) . pri_class as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( priority ) , "::" ,
                stringify ! ( pri_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const priority ) ) . pri_level as * const _ as
                usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( priority ) , "::" ,
                stringify ! ( pri_level ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const priority ) ) . pri_native as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( priority ) , "::" ,
                stringify ! ( pri_native ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const priority ) ) . pri_user as * const _ as
                usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( priority ) , "::" ,
                stringify ! ( pri_user ) ));
}
impl Clone for priority {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn htonl(arg1: __uint32_t) -> __uint32_t;
}
extern "C" {
    pub fn htons(arg1: __uint16_t) -> __uint16_t;
}
extern "C" {
    pub fn ntohl(arg1: __uint32_t) -> __uint32_t;
}
extern "C" {
    pub fn ntohs(arg1: __uint16_t) -> __uint16_t;
}
extern "C" {
    #[link_name = "kernelname"]
    pub static mut kernelname: [::std::os::raw::c_char; 1024usize];
}
extern "C" {
    #[link_name = "tick"]
    pub static mut tick: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "hz"]
    pub static mut hz: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "psratio"]
    pub static mut psratio: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "stathz"]
    pub static mut stathz: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "profhz"]
    pub static mut profhz: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "profprocs"]
    pub static mut profprocs: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "ticks"]
    pub static mut ticks: ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sysinit_sub_id {
    SI_SUB_DUMMY = 0,
    SI_SUB_DONE = 1,
    SI_SUB_TUNABLES = 7340032,
    SI_SUB_COPYRIGHT = 8388609,
    SI_SUB_VM = 16777216,
    SI_SUB_KMEM = 25165824,
    SI_SUB_HYPERVISOR = 27525120,
    SI_SUB_WITNESS = 27787264,
    SI_SUB_MTX_POOL_DYNAMIC = 28049408,
    SI_SUB_LOCK = 28311552,
    SI_SUB_EVENTHANDLER = 29360128,
    SI_SUB_VNET_PRELINK = 31457280,
    SI_SUB_KLD = 33554432,
    SI_SUB_CPU = 34603008,
    SI_SUB_RACCT = 34668544,
    SI_SUB_KDTRACE = 34865152,
    SI_SUB_RANDOM = 34996224,
    SI_SUB_MAC = 35127296,
    SI_SUB_MAC_POLICY = 35389440,
    SI_SUB_MAC_LATE = 35454976,
    SI_SUB_VNET = 35520512,
    SI_SUB_INTRINSIC = 35651584,
    SI_SUB_VM_CONF = 36700160,
    SI_SUB_DDB_SERVICES = 37224448,
    SI_SUB_RUN_QUEUE = 37748736,
    SI_SUB_KTRACE = 38273024,
    SI_SUB_OPENSOLARIS = 38338560,
    SI_SUB_AUDIT = 38535168,
    SI_SUB_CREATE_INIT = 38797312,
    SI_SUB_SCHED_IDLE = 39845888,
    SI_SUB_MBUF = 40894464,
    SI_SUB_INTR = 41943040,
    SI_SUB_TASKQ = 42467328,
    SI_SUB_SOFTINTR = 44040192,
    SI_SUB_DEVFS = 49283072,
    SI_SUB_INIT_IF = 50331648,
    SI_SUB_NETGRAPH = 50397184,
    SI_SUB_DTRACE = 50462720,
    SI_SUB_DTRACE_PROVIDER = 50626560,
    SI_SUB_DTRACE_ANON = 50905088,
    SI_SUB_DRIVERS = 51380224,
    SI_SUB_CONFIGURE = 58720256,
    SI_SUB_VFS = 67108864,
    SI_SUB_CLOCKS = 75497472,
    SI_SUB_SYSV_SHM = 104857600,
    SI_SUB_SYSV_SEM = 109051904,
    SI_SUB_SYSV_MSG = 113246208,
    SI_SUB_P1003_1B = 115343360,
    SI_SUB_PSEUDO = 117440512,
    SI_SUB_EXEC = 121634816,
    SI_SUB_PROTO_BEGIN = 134217728,
    SI_SUB_PROTO_PFIL = 135266304,
    SI_SUB_PROTO_IF = 138412032,
    SI_SUB_PROTO_DOMAININIT = 140509184,
    SI_SUB_PROTO_MC = 141557760,
    SI_SUB_PROTO_DOMAIN = 142606336,
    SI_SUB_PROTO_FIREWALL = 142630912,
    SI_SUB_PROTO_IFATTACHDOMAIN = 142639104,
    SI_SUB_PROTO_END = 150994943,
    SI_SUB_KPROF = 150994944,
    SI_SUB_KICK_SCHEDULER = 167772160,
    SI_SUB_INT_CONFIG_HOOKS = 176160768,
    SI_SUB_ROOT_CONF = 184549376,
    SI_SUB_INTRINSIC_POST = 218103808,
    SI_SUB_SYSCALLS = 226492416,
    SI_SUB_VNET_DONE = 230686720,
    SI_SUB_KTHREAD_INIT = 234881024,
    SI_SUB_KTHREAD_PAGE = 239075328,
    SI_SUB_KTHREAD_VM = 243269632,
    SI_SUB_KTHREAD_BUF = 245366784,
    SI_SUB_KTHREAD_UPDATE = 247463936,
    SI_SUB_KTHREAD_IDLE = 249561088,
    SI_SUB_SMP = 251658240,
    SI_SUB_RACCTD = 252706816,
    SI_SUB_LAST = 268435455,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sysinit_elem_order {
    SI_ORDER_FIRST = 0,
    SI_ORDER_SECOND = 1,
    SI_ORDER_THIRD = 2,
    SI_ORDER_FOURTH = 3,
    SI_ORDER_MIDDLE = 16777216,
    SI_ORDER_ANY = 268435455,
}
pub type sysinit_nfunc_t =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void)>;
pub type sysinit_cfunc_t =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *const ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sysinit {
    pub subsystem: sysinit_sub_id,
    pub order: sysinit_elem_order,
    pub func: sysinit_cfunc_t,
    pub udata: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_sysinit() {
    assert_eq!(::std::mem::size_of::<sysinit>() , 24usize , concat ! (
               "Size of: " , stringify ! ( sysinit ) ));
    assert_eq! (::std::mem::align_of::<sysinit>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sysinit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysinit ) ) . subsystem as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sysinit ) , "::" ,
                stringify ! ( subsystem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysinit ) ) . order as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( sysinit ) , "::" ,
                stringify ! ( order ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysinit ) ) . func as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sysinit ) , "::" ,
                stringify ! ( func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysinit ) ) . udata as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( sysinit ) , "::" ,
                stringify ! ( udata ) ));
}
impl Clone for sysinit {
    fn clone(&self) -> Self { *self }
}
impl Default for sysinit {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
extern "C" {
    pub fn sysinit_add(set: *mut *mut sysinit, set_end: *mut *mut sysinit);
}
extern "C" {
    pub fn tunable_int_init(arg1: *mut ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tunable_int {
    pub path: *const ::std::os::raw::c_char,
    pub var: *mut ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_tunable_int() {
    assert_eq!(::std::mem::size_of::<tunable_int>() , 16usize , concat ! (
               "Size of: " , stringify ! ( tunable_int ) ));
    assert_eq! (::std::mem::align_of::<tunable_int>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( tunable_int ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tunable_int ) ) . path as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tunable_int ) , "::" ,
                stringify ! ( path ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tunable_int ) ) . var as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tunable_int ) , "::" ,
                stringify ! ( var ) ));
}
impl Clone for tunable_int {
    fn clone(&self) -> Self { *self }
}
impl Default for tunable_int {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
extern "C" {
    pub fn tunable_long_init(arg1: *mut ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tunable_long {
    pub path: *const ::std::os::raw::c_char,
    pub var: *mut ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_tunable_long() {
    assert_eq!(::std::mem::size_of::<tunable_long>() , 16usize , concat ! (
               "Size of: " , stringify ! ( tunable_long ) ));
    assert_eq! (::std::mem::align_of::<tunable_long>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( tunable_long ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tunable_long ) ) . path as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tunable_long ) , "::" ,
                stringify ! ( path ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tunable_long ) ) . var as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tunable_long ) , "::" ,
                stringify ! ( var ) ));
}
impl Clone for tunable_long {
    fn clone(&self) -> Self { *self }
}
impl Default for tunable_long {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
extern "C" {
    pub fn tunable_ulong_init(arg1: *mut ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tunable_ulong {
    pub path: *const ::std::os::raw::c_char,
    pub var: *mut ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_tunable_ulong() {
    assert_eq!(::std::mem::size_of::<tunable_ulong>() , 16usize , concat ! (
               "Size of: " , stringify ! ( tunable_ulong ) ));
    assert_eq! (::std::mem::align_of::<tunable_ulong>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( tunable_ulong ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tunable_ulong ) ) . path as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tunable_ulong ) , "::"
                , stringify ! ( path ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tunable_ulong ) ) . var as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tunable_ulong ) , "::"
                , stringify ! ( var ) ));
}
impl Clone for tunable_ulong {
    fn clone(&self) -> Self { *self }
}
impl Default for tunable_ulong {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
extern "C" {
    pub fn tunable_int64_init(arg1: *mut ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tunable_int64 {
    pub path: *const ::std::os::raw::c_char,
    pub var: *mut i64,
}
#[test]
fn bindgen_test_layout_tunable_int64() {
    assert_eq!(::std::mem::size_of::<tunable_int64>() , 16usize , concat ! (
               "Size of: " , stringify ! ( tunable_int64 ) ));
    assert_eq! (::std::mem::align_of::<tunable_int64>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( tunable_int64 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tunable_int64 ) ) . path as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tunable_int64 ) , "::"
                , stringify ! ( path ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tunable_int64 ) ) . var as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tunable_int64 ) , "::"
                , stringify ! ( var ) ));
}
impl Clone for tunable_int64 {
    fn clone(&self) -> Self { *self }
}
impl Default for tunable_int64 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
extern "C" {
    pub fn tunable_uint64_init(arg1: *mut ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tunable_uint64 {
    pub path: *const ::std::os::raw::c_char,
    pub var: *mut u64,
}
#[test]
fn bindgen_test_layout_tunable_uint64() {
    assert_eq!(::std::mem::size_of::<tunable_uint64>() , 16usize , concat ! (
               "Size of: " , stringify ! ( tunable_uint64 ) ));
    assert_eq! (::std::mem::align_of::<tunable_uint64>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( tunable_uint64 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tunable_uint64 ) ) . path as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tunable_uint64 ) , "::"
                , stringify ! ( path ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tunable_uint64 ) ) . var as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tunable_uint64 ) , "::"
                , stringify ! ( var ) ));
}
impl Clone for tunable_uint64 {
    fn clone(&self) -> Self { *self }
}
impl Default for tunable_uint64 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
extern "C" {
    pub fn tunable_quad_init(arg1: *mut ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tunable_quad {
    pub path: *const ::std::os::raw::c_char,
    pub var: *mut quad_t,
}
#[test]
fn bindgen_test_layout_tunable_quad() {
    assert_eq!(::std::mem::size_of::<tunable_quad>() , 16usize , concat ! (
               "Size of: " , stringify ! ( tunable_quad ) ));
    assert_eq! (::std::mem::align_of::<tunable_quad>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( tunable_quad ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tunable_quad ) ) . path as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tunable_quad ) , "::" ,
                stringify ! ( path ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tunable_quad ) ) . var as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tunable_quad ) , "::" ,
                stringify ! ( var ) ));
}
impl Clone for tunable_quad {
    fn clone(&self) -> Self { *self }
}
impl Default for tunable_quad {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
extern "C" {
    pub fn tunable_str_init(arg1: *mut ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tunable_str {
    pub path: *const ::std::os::raw::c_char,
    pub var: *mut ::std::os::raw::c_char,
    pub size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_tunable_str() {
    assert_eq!(::std::mem::size_of::<tunable_str>() , 24usize , concat ! (
               "Size of: " , stringify ! ( tunable_str ) ));
    assert_eq! (::std::mem::align_of::<tunable_str>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( tunable_str ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tunable_str ) ) . path as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tunable_str ) , "::" ,
                stringify ! ( path ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tunable_str ) ) . var as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tunable_str ) , "::" ,
                stringify ! ( var ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tunable_str ) ) . size as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( tunable_str ) , "::" ,
                stringify ! ( size ) ));
}
impl Clone for tunable_str {
    fn clone(&self) -> Self { *self }
}
impl Default for tunable_str {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type ich_func_t =
    ::std::option::Option<unsafe extern "C" fn(_arg:
                                                   *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct intr_config_hook {
    pub ich_links: intr_config_hook__bindgen_ty_1,
    pub ich_func: ich_func_t,
    pub ich_arg: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct intr_config_hook__bindgen_ty_1 {
    pub tqe_next: *mut intr_config_hook,
    pub tqe_prev: *mut *mut intr_config_hook,
}
#[test]
fn bindgen_test_layout_intr_config_hook__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<intr_config_hook__bindgen_ty_1>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( intr_config_hook__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<intr_config_hook__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( intr_config_hook__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const intr_config_hook__bindgen_ty_1 ) ) .
                tqe_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                intr_config_hook__bindgen_ty_1 ) , "::" , stringify ! (
                tqe_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const intr_config_hook__bindgen_ty_1 ) ) .
                tqe_prev as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                intr_config_hook__bindgen_ty_1 ) , "::" , stringify ! (
                tqe_prev ) ));
}
impl Clone for intr_config_hook__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for intr_config_hook__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_intr_config_hook() {
    assert_eq!(::std::mem::size_of::<intr_config_hook>() , 32usize , concat !
               ( "Size of: " , stringify ! ( intr_config_hook ) ));
    assert_eq! (::std::mem::align_of::<intr_config_hook>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( intr_config_hook ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const intr_config_hook ) ) . ich_links as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( intr_config_hook ) ,
                "::" , stringify ! ( ich_links ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const intr_config_hook ) ) . ich_func as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( intr_config_hook ) ,
                "::" , stringify ! ( ich_func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const intr_config_hook ) ) . ich_arg as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( intr_config_hook ) ,
                "::" , stringify ! ( ich_arg ) ));
}
impl Clone for intr_config_hook {
    fn clone(&self) -> Self { *self }
}
impl Default for intr_config_hook {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
extern "C" {
    pub fn config_intrhook_establish(hook: *mut intr_config_hook)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn config_intrhook_disestablish(hook: *mut intr_config_hook);
}
extern "C" {
    pub fn config_intrhook_oneshot(_func: ich_func_t,
                                   _arg: *mut ::std::os::raw::c_void);
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(::std::mem::size_of::<__va_list_tag>() , 24usize , concat ! (
               "Size of: " , stringify ! ( __va_list_tag ) ));
    assert_eq! (::std::mem::align_of::<__va_list_tag>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __va_list_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . gp_offset as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( gp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . fp_offset as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( fp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . overflow_arg_area as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( overflow_arg_area ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . reg_save_area as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( reg_save_area ) ));
}
impl Clone for __va_list_tag {
    fn clone(&self) -> Self { *self }
}
impl Default for __va_list_tag {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
