/* automatically generated by rust-bindgen */

pub const __GNUCLIKE_ASM: ::std::os::raw::c_uint = 3;
pub const __GNUCLIKE___TYPEOF: ::std::os::raw::c_uint = 1;
pub const __GNUCLIKE___OFFSETOF: ::std::os::raw::c_uint = 1;
pub const __GNUCLIKE___SECTION: ::std::os::raw::c_uint = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: ::std::os::raw::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: ::std::os::raw::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: ::std::os::raw::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: ::std::os::raw::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: ::std::os::raw::c_uint = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: ::std::os::raw::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: ::std::os::raw::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: ::std::os::raw::c_uint = 1;
pub const __CC_SUPPORTS_INLINE: ::std::os::raw::c_uint = 1;
pub const __CC_SUPPORTS___INLINE: ::std::os::raw::c_uint = 1;
pub const __CC_SUPPORTS___INLINE__: ::std::os::raw::c_uint = 1;
pub const __CC_SUPPORTS___FUNC__: ::std::os::raw::c_uint = 1;
pub const __CC_SUPPORTS_WARNING: ::std::os::raw::c_uint = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: ::std::os::raw::c_uint = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: ::std::os::raw::c_uint = 1;
pub const __POSIX_VISIBLE: ::std::os::raw::c_uint = 200809;
pub const __XSI_VISIBLE: ::std::os::raw::c_uint = 700;
pub const __BSD_VISIBLE: ::std::os::raw::c_uint = 1;
pub const __ISO_C_VISIBLE: ::std::os::raw::c_uint = 2011;
pub const __EXT1_VISIBLE: ::std::os::raw::c_uint = 1;
pub const __CHAR_BIT: ::std::os::raw::c_uint = 8;
pub const __SCHAR_MAX: ::std::os::raw::c_uint = 127;
pub const __SCHAR_MIN: ::std::os::raw::c_int = -128;
pub const __UCHAR_MAX: ::std::os::raw::c_uint = 255;
pub const __USHRT_MAX: ::std::os::raw::c_uint = 65535;
pub const __SHRT_MAX: ::std::os::raw::c_uint = 32767;
pub const __SHRT_MIN: ::std::os::raw::c_int = -32768;
pub const __UINT_MAX: ::std::os::raw::c_uint = 4294967295;
pub const __INT_MAX: ::std::os::raw::c_uint = 2147483647;
pub const __INT_MIN: ::std::os::raw::c_int = -2147483648;
pub const __ULONG_MAX: ::std::os::raw::c_int = -1;
pub const __LONG_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const __LONG_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const __ULLONG_MAX: ::std::os::raw::c_int = -1;
pub const __LLONG_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const __LLONG_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const __SSIZE_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const __SIZE_T_MAX: ::std::os::raw::c_int = -1;
pub const __OFF_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const __OFF_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const __UQUAD_MAX: ::std::os::raw::c_int = -1;
pub const __QUAD_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const __QUAD_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const __LONG_BIT: ::std::os::raw::c_uint = 64;
pub const __WORD_BIT: ::std::os::raw::c_uint = 32;
pub const __MINSIGSTKSZ: ::std::os::raw::c_uint = 2048;
pub const __WCHAR_MIN: ::std::os::raw::c_int = -2147483648;
pub const __WCHAR_MAX: ::std::os::raw::c_uint = 2147483647;
pub const _QUAD_HIGHWORD: ::std::os::raw::c_uint = 1;
pub const _QUAD_LOWWORD: ::std::os::raw::c_uint = 0;
pub const _LITTLE_ENDIAN: ::std::os::raw::c_uint = 1234;
pub const _BIG_ENDIAN: ::std::os::raw::c_uint = 4321;
pub const _PDP_ENDIAN: ::std::os::raw::c_uint = 3412;
pub const _BYTE_ORDER: ::std::os::raw::c_uint = 1234;
pub const LITTLE_ENDIAN: ::std::os::raw::c_uint = 1234;
pub const BIG_ENDIAN: ::std::os::raw::c_uint = 4321;
pub const PDP_ENDIAN: ::std::os::raw::c_uint = 3412;
pub const BYTE_ORDER: ::std::os::raw::c_uint = 1234;
pub const __bool_true_false_are_defined: ::std::os::raw::c_uint = 1;
pub const false_: ::std::os::raw::c_uint = 0;
pub const true_: ::std::os::raw::c_uint = 1;
pub const _SIG_WORDS: ::std::os::raw::c_uint = 4;
pub const _SIG_MAXSIG: ::std::os::raw::c_uint = 128;
pub const FD_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const KTR_GEN: ::std::os::raw::c_uint = 1;
pub const KTR_NET: ::std::os::raw::c_uint = 2;
pub const KTR_DEV: ::std::os::raw::c_uint = 4;
pub const KTR_LOCK: ::std::os::raw::c_uint = 8;
pub const KTR_SMP: ::std::os::raw::c_uint = 16;
pub const KTR_SUBSYS: ::std::os::raw::c_uint = 32;
pub const KTR_PMAP: ::std::os::raw::c_uint = 64;
pub const KTR_MALLOC: ::std::os::raw::c_uint = 128;
pub const KTR_TRAP: ::std::os::raw::c_uint = 256;
pub const KTR_INTR: ::std::os::raw::c_uint = 512;
pub const KTR_SIG: ::std::os::raw::c_uint = 1024;
pub const KTR_SPARE2: ::std::os::raw::c_uint = 2048;
pub const KTR_PROC: ::std::os::raw::c_uint = 4096;
pub const KTR_SYSC: ::std::os::raw::c_uint = 8192;
pub const KTR_INIT: ::std::os::raw::c_uint = 16384;
pub const KTR_SPARE3: ::std::os::raw::c_uint = 32768;
pub const KTR_SPARE4: ::std::os::raw::c_uint = 65536;
pub const KTR_EVH: ::std::os::raw::c_uint = 131072;
pub const KTR_VFS: ::std::os::raw::c_uint = 262144;
pub const KTR_VOP: ::std::os::raw::c_uint = 524288;
pub const KTR_VM: ::std::os::raw::c_uint = 1048576;
pub const KTR_INET: ::std::os::raw::c_uint = 2097152;
pub const KTR_RUNQ: ::std::os::raw::c_uint = 4194304;
pub const KTR_CONTENTION: ::std::os::raw::c_uint = 8388608;
pub const KTR_UMA: ::std::os::raw::c_uint = 16777216;
pub const KTR_CALLOUT: ::std::os::raw::c_uint = 33554432;
pub const KTR_GEOM: ::std::os::raw::c_uint = 67108864;
pub const KTR_BUSDMA: ::std::os::raw::c_uint = 134217728;
pub const KTR_INET6: ::std::os::raw::c_uint = 268435456;
pub const KTR_SCHED: ::std::os::raw::c_uint = 536870912;
pub const KTR_BUF: ::std::os::raw::c_uint = 1073741824;
pub const KTR_PTRACE: ::std::os::raw::c_uint = 2147483648;
pub const KTR_ALL: ::std::os::raw::c_uint = 4294967295;
pub const KTR_COMPILE: ::std::os::raw::c_uint = 0;
pub const LC_SLEEPLOCK: ::std::os::raw::c_uint = 1;
pub const LC_SPINLOCK: ::std::os::raw::c_uint = 2;
pub const LC_SLEEPABLE: ::std::os::raw::c_uint = 4;
pub const LC_RECURSABLE: ::std::os::raw::c_uint = 8;
pub const LC_UPGRADABLE: ::std::os::raw::c_uint = 16;
pub const LO_CLASSFLAGS: ::std::os::raw::c_uint = 65535;
pub const LO_INITIALIZED: ::std::os::raw::c_uint = 65536;
pub const LO_WITNESS: ::std::os::raw::c_uint = 131072;
pub const LO_QUIET: ::std::os::raw::c_uint = 262144;
pub const LO_RECURSABLE: ::std::os::raw::c_uint = 524288;
pub const LO_SLEEPABLE: ::std::os::raw::c_uint = 1048576;
pub const LO_UPGRADABLE: ::std::os::raw::c_uint = 2097152;
pub const LO_DUPOK: ::std::os::raw::c_uint = 4194304;
pub const LO_IS_VNODE: ::std::os::raw::c_uint = 8388608;
pub const LO_CLASSMASK: ::std::os::raw::c_uint = 251658240;
pub const LO_NOPROFILE: ::std::os::raw::c_uint = 268435456;
pub const LO_NEW: ::std::os::raw::c_uint = 536870912;
pub const LO_CLASSSHIFT: ::std::os::raw::c_uint = 24;
pub const LOCK_CLASS_MAX: ::std::os::raw::c_uint = 15;
pub const LOP_NEWORDER: ::std::os::raw::c_uint = 1;
pub const LOP_QUIET: ::std::os::raw::c_uint = 2;
pub const LOP_TRYLOCK: ::std::os::raw::c_uint = 4;
pub const LOP_EXCLUSIVE: ::std::os::raw::c_uint = 8;
pub const LOP_DUPOK: ::std::os::raw::c_uint = 16;
pub const LA_MASKASSERT: ::std::os::raw::c_uint = 255;
pub const LA_UNLOCKED: ::std::os::raw::c_uint = 0;
pub const LA_LOCKED: ::std::os::raw::c_uint = 1;
pub const LA_SLOCKED: ::std::os::raw::c_uint = 2;
pub const LA_XLOCKED: ::std::os::raw::c_uint = 4;
pub const LA_RECURSED: ::std::os::raw::c_uint = 8;
pub const LA_NOTRECURSED: ::std::os::raw::c_uint = 16;
pub const LOCK_DEBUG: ::std::os::raw::c_uint = 1;
pub const KTR_VERSION: ::std::os::raw::c_uint = 2;
pub const KTR_PARMS: ::std::os::raw::c_uint = 6;
pub const BSD: ::std::os::raw::c_uint = 199506;
pub const BSD4_3: ::std::os::raw::c_uint = 1;
pub const BSD4_4: ::std::os::raw::c_uint = 1;
pub const __FreeBSD_version: ::std::os::raw::c_uint = 1200056;
pub const P_OSREL_SIGWAIT: ::std::os::raw::c_uint = 700000;
pub const P_OSREL_SIGSEGV: ::std::os::raw::c_uint = 700004;
pub const P_OSREL_MAP_ANON: ::std::os::raw::c_uint = 800104;
pub const P_OSREL_MAP_FSTRICT: ::std::os::raw::c_uint = 1100036;
pub const P_OSREL_SHUTDOWN_ENOTCONN: ::std::os::raw::c_uint = 1100077;
pub const P_OSREL_MAP_GUARD: ::std::os::raw::c_uint = 1200035;
pub const P_OSREL_WRFSBASE: ::std::os::raw::c_uint = 1200041;
pub const P_OSREL_CK_CYLGRP: ::std::os::raw::c_uint = 1200046;
pub const P_OSREL_VMTOTAL64: ::std::os::raw::c_uint = 1200054;
pub const ARG_MAX: ::std::os::raw::c_uint = 262144;
pub const CHILD_MAX: ::std::os::raw::c_uint = 40;
pub const MAX_CANON: ::std::os::raw::c_uint = 255;
pub const MAX_INPUT: ::std::os::raw::c_uint = 255;
pub const NAME_MAX: ::std::os::raw::c_uint = 255;
pub const NGROUPS_MAX: ::std::os::raw::c_uint = 1023;
pub const OPEN_MAX: ::std::os::raw::c_uint = 64;
pub const PATH_MAX: ::std::os::raw::c_uint = 1024;
pub const PIPE_BUF: ::std::os::raw::c_uint = 512;
pub const IOV_MAX: ::std::os::raw::c_uint = 1024;
pub const MAXCOMLEN: ::std::os::raw::c_uint = 19;
pub const MAXINTERP: ::std::os::raw::c_uint = 1024;
pub const MAXLOGNAME: ::std::os::raw::c_uint = 33;
pub const MAXUPRC: ::std::os::raw::c_uint = 40;
pub const NCARGS: ::std::os::raw::c_uint = 262144;
pub const NGROUPS: ::std::os::raw::c_uint = 1024;
pub const NOFILE: ::std::os::raw::c_uint = 64;
pub const NOGROUP: ::std::os::raw::c_uint = 65535;
pub const MAXHOSTNAMELEN: ::std::os::raw::c_uint = 256;
pub const SPECNAMELEN: ::std::os::raw::c_uint = 63;
pub const EPERM: ::std::os::raw::c_uint = 1;
pub const ENOENT: ::std::os::raw::c_uint = 2;
pub const ESRCH: ::std::os::raw::c_uint = 3;
pub const EINTR: ::std::os::raw::c_uint = 4;
pub const EIO: ::std::os::raw::c_uint = 5;
pub const ENXIO: ::std::os::raw::c_uint = 6;
pub const E2BIG: ::std::os::raw::c_uint = 7;
pub const ENOEXEC: ::std::os::raw::c_uint = 8;
pub const EBADF: ::std::os::raw::c_uint = 9;
pub const ECHILD: ::std::os::raw::c_uint = 10;
pub const EDEADLK: ::std::os::raw::c_uint = 11;
pub const ENOMEM: ::std::os::raw::c_uint = 12;
pub const EACCES: ::std::os::raw::c_uint = 13;
pub const EFAULT: ::std::os::raw::c_uint = 14;
pub const ENOTBLK: ::std::os::raw::c_uint = 15;
pub const EBUSY: ::std::os::raw::c_uint = 16;
pub const EEXIST: ::std::os::raw::c_uint = 17;
pub const EXDEV: ::std::os::raw::c_uint = 18;
pub const ENODEV: ::std::os::raw::c_uint = 19;
pub const ENOTDIR: ::std::os::raw::c_uint = 20;
pub const EISDIR: ::std::os::raw::c_uint = 21;
pub const EINVAL: ::std::os::raw::c_uint = 22;
pub const ENFILE: ::std::os::raw::c_uint = 23;
pub const EMFILE: ::std::os::raw::c_uint = 24;
pub const ENOTTY: ::std::os::raw::c_uint = 25;
pub const ETXTBSY: ::std::os::raw::c_uint = 26;
pub const EFBIG: ::std::os::raw::c_uint = 27;
pub const ENOSPC: ::std::os::raw::c_uint = 28;
pub const ESPIPE: ::std::os::raw::c_uint = 29;
pub const EROFS: ::std::os::raw::c_uint = 30;
pub const EMLINK: ::std::os::raw::c_uint = 31;
pub const EPIPE: ::std::os::raw::c_uint = 32;
pub const EDOM: ::std::os::raw::c_uint = 33;
pub const ERANGE: ::std::os::raw::c_uint = 34;
pub const EAGAIN: ::std::os::raw::c_uint = 35;
pub const EWOULDBLOCK: ::std::os::raw::c_uint = 35;
pub const EINPROGRESS: ::std::os::raw::c_uint = 36;
pub const EALREADY: ::std::os::raw::c_uint = 37;
pub const ENOTSOCK: ::std::os::raw::c_uint = 38;
pub const EDESTADDRREQ: ::std::os::raw::c_uint = 39;
pub const EMSGSIZE: ::std::os::raw::c_uint = 40;
pub const EPROTOTYPE: ::std::os::raw::c_uint = 41;
pub const ENOPROTOOPT: ::std::os::raw::c_uint = 42;
pub const EPROTONOSUPPORT: ::std::os::raw::c_uint = 43;
pub const ESOCKTNOSUPPORT: ::std::os::raw::c_uint = 44;
pub const EOPNOTSUPP: ::std::os::raw::c_uint = 45;
pub const ENOTSUP: ::std::os::raw::c_uint = 45;
pub const EPFNOSUPPORT: ::std::os::raw::c_uint = 46;
pub const EAFNOSUPPORT: ::std::os::raw::c_uint = 47;
pub const EADDRINUSE: ::std::os::raw::c_uint = 48;
pub const EADDRNOTAVAIL: ::std::os::raw::c_uint = 49;
pub const ENETDOWN: ::std::os::raw::c_uint = 50;
pub const ENETUNREACH: ::std::os::raw::c_uint = 51;
pub const ENETRESET: ::std::os::raw::c_uint = 52;
pub const ECONNABORTED: ::std::os::raw::c_uint = 53;
pub const ECONNRESET: ::std::os::raw::c_uint = 54;
pub const ENOBUFS: ::std::os::raw::c_uint = 55;
pub const EISCONN: ::std::os::raw::c_uint = 56;
pub const ENOTCONN: ::std::os::raw::c_uint = 57;
pub const ESHUTDOWN: ::std::os::raw::c_uint = 58;
pub const ETOOMANYREFS: ::std::os::raw::c_uint = 59;
pub const ETIMEDOUT: ::std::os::raw::c_uint = 60;
pub const ECONNREFUSED: ::std::os::raw::c_uint = 61;
pub const ELOOP: ::std::os::raw::c_uint = 62;
pub const ENAMETOOLONG: ::std::os::raw::c_uint = 63;
pub const EHOSTDOWN: ::std::os::raw::c_uint = 64;
pub const EHOSTUNREACH: ::std::os::raw::c_uint = 65;
pub const ENOTEMPTY: ::std::os::raw::c_uint = 66;
pub const EPROCLIM: ::std::os::raw::c_uint = 67;
pub const EUSERS: ::std::os::raw::c_uint = 68;
pub const EDQUOT: ::std::os::raw::c_uint = 69;
pub const ESTALE: ::std::os::raw::c_uint = 70;
pub const EREMOTE: ::std::os::raw::c_uint = 71;
pub const EBADRPC: ::std::os::raw::c_uint = 72;
pub const ERPCMISMATCH: ::std::os::raw::c_uint = 73;
pub const EPROGUNAVAIL: ::std::os::raw::c_uint = 74;
pub const EPROGMISMATCH: ::std::os::raw::c_uint = 75;
pub const EPROCUNAVAIL: ::std::os::raw::c_uint = 76;
pub const ENOLCK: ::std::os::raw::c_uint = 77;
pub const ENOSYS: ::std::os::raw::c_uint = 78;
pub const EFTYPE: ::std::os::raw::c_uint = 79;
pub const EAUTH: ::std::os::raw::c_uint = 80;
pub const ENEEDAUTH: ::std::os::raw::c_uint = 81;
pub const EIDRM: ::std::os::raw::c_uint = 82;
pub const ENOMSG: ::std::os::raw::c_uint = 83;
pub const EOVERFLOW: ::std::os::raw::c_uint = 84;
pub const ECANCELED: ::std::os::raw::c_uint = 85;
pub const EILSEQ: ::std::os::raw::c_uint = 86;
pub const ENOATTR: ::std::os::raw::c_uint = 87;
pub const EDOOFUS: ::std::os::raw::c_uint = 88;
pub const EBADMSG: ::std::os::raw::c_uint = 89;
pub const EMULTIHOP: ::std::os::raw::c_uint = 90;
pub const ENOLINK: ::std::os::raw::c_uint = 91;
pub const EPROTO: ::std::os::raw::c_uint = 92;
pub const ENOTCAPABLE: ::std::os::raw::c_uint = 93;
pub const ECAPMODE: ::std::os::raw::c_uint = 94;
pub const ENOTRECOVERABLE: ::std::os::raw::c_uint = 95;
pub const EOWNERDEAD: ::std::os::raw::c_uint = 96;
pub const ELAST: ::std::os::raw::c_uint = 96;
pub const ERESTART: ::std::os::raw::c_int = -1;
pub const EJUSTRETURN: ::std::os::raw::c_int = -2;
pub const ENOIOCTL: ::std::os::raw::c_int = -3;
pub const EDIRIOCTL: ::std::os::raw::c_int = -4;
pub const ERELOOKUP: ::std::os::raw::c_int = -5;
pub const DST_NONE: ::std::os::raw::c_uint = 0;
pub const DST_USA: ::std::os::raw::c_uint = 1;
pub const DST_AUST: ::std::os::raw::c_uint = 2;
pub const DST_WET: ::std::os::raw::c_uint = 3;
pub const DST_MET: ::std::os::raw::c_uint = 4;
pub const DST_EET: ::std::os::raw::c_uint = 5;
pub const DST_CAN: ::std::os::raw::c_uint = 6;
pub const SBT_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const ITIMER_REAL: ::std::os::raw::c_uint = 0;
pub const ITIMER_VIRTUAL: ::std::os::raw::c_uint = 1;
pub const ITIMER_PROF: ::std::os::raw::c_uint = 2;
pub const CLOCK_REALTIME: ::std::os::raw::c_uint = 0;
pub const CLOCK_VIRTUAL: ::std::os::raw::c_uint = 1;
pub const CLOCK_PROF: ::std::os::raw::c_uint = 2;
pub const CLOCK_MONOTONIC: ::std::os::raw::c_uint = 4;
pub const CLOCK_UPTIME: ::std::os::raw::c_uint = 5;
pub const CLOCK_UPTIME_PRECISE: ::std::os::raw::c_uint = 7;
pub const CLOCK_UPTIME_FAST: ::std::os::raw::c_uint = 8;
pub const CLOCK_REALTIME_PRECISE: ::std::os::raw::c_uint = 9;
pub const CLOCK_REALTIME_FAST: ::std::os::raw::c_uint = 10;
pub const CLOCK_MONOTONIC_PRECISE: ::std::os::raw::c_uint = 11;
pub const CLOCK_MONOTONIC_FAST: ::std::os::raw::c_uint = 12;
pub const CLOCK_SECOND: ::std::os::raw::c_uint = 13;
pub const CLOCK_THREAD_CPUTIME_ID: ::std::os::raw::c_uint = 14;
pub const CLOCK_PROCESS_CPUTIME_ID: ::std::os::raw::c_uint = 15;
pub const TIMER_RELTIME: ::std::os::raw::c_uint = 0;
pub const TIMER_ABSTIME: ::std::os::raw::c_uint = 1;
pub const CPUCLOCK_WHICH_PID: ::std::os::raw::c_uint = 0;
pub const CPUCLOCK_WHICH_TID: ::std::os::raw::c_uint = 1;
pub const TC_DEFAULTPERC: ::std::os::raw::c_uint = 5;
pub const PRI_ITHD: ::std::os::raw::c_uint = 1;
pub const PRI_REALTIME: ::std::os::raw::c_uint = 2;
pub const PRI_TIMESHARE: ::std::os::raw::c_uint = 3;
pub const PRI_IDLE: ::std::os::raw::c_uint = 4;
pub const PRI_FIFO_BIT: ::std::os::raw::c_uint = 8;
pub const PRI_FIFO: ::std::os::raw::c_uint = 10;
pub const PRI_MIN: ::std::os::raw::c_uint = 0;
pub const PRI_MAX: ::std::os::raw::c_uint = 255;
pub const PRI_MIN_ITHD: ::std::os::raw::c_uint = 0;
pub const PI_REALTIME: ::std::os::raw::c_uint = 0;
pub const PI_AV: ::std::os::raw::c_uint = 4;
pub const PI_NET: ::std::os::raw::c_uint = 8;
pub const PI_DISK: ::std::os::raw::c_uint = 12;
pub const PI_TTY: ::std::os::raw::c_uint = 16;
pub const PI_DULL: ::std::os::raw::c_uint = 20;
pub const PI_SOFT: ::std::os::raw::c_uint = 24;
pub const PRI_MIN_REALTIME: ::std::os::raw::c_uint = 48;
pub const PRI_MIN_KERN: ::std::os::raw::c_uint = 80;
pub const PSWP: ::std::os::raw::c_uint = 80;
pub const PVM: ::std::os::raw::c_uint = 84;
pub const PINOD: ::std::os::raw::c_uint = 88;
pub const PRIBIO: ::std::os::raw::c_uint = 92;
pub const PVFS: ::std::os::raw::c_uint = 96;
pub const PZERO: ::std::os::raw::c_uint = 100;
pub const PSOCK: ::std::os::raw::c_uint = 104;
pub const PWAIT: ::std::os::raw::c_uint = 108;
pub const PLOCK: ::std::os::raw::c_uint = 112;
pub const PPAUSE: ::std::os::raw::c_uint = 116;
pub const PRI_MIN_TIMESHARE: ::std::os::raw::c_uint = 120;
pub const PUSER: ::std::os::raw::c_uint = 120;
pub const PRI_MIN_IDLE: ::std::os::raw::c_uint = 224;
pub const PRI_MAX_IDLE: ::std::os::raw::c_uint = 255;
pub const PRI_USER: ::std::os::raw::c_int = -2;
pub const PRI_UNCHANGED: ::std::os::raw::c_int = -1;
pub const FALSE: ::std::os::raw::c_uint = 0;
pub const TRUE: ::std::os::raw::c_uint = 1;
pub const MACHINE: &'static [u8; 6usize] = b"amd64\x00";
pub const MACHINE_ARCH: &'static [u8; 6usize] = b"amd64\x00";
pub const MACHINE_ARCH32: &'static [u8; 5usize] = b"i386\x00";
pub const MAXCPU: ::std::os::raw::c_uint = 256;
pub const MAXMEMDOM: ::std::os::raw::c_uint = 8;
pub const CACHE_LINE_SHIFT: ::std::os::raw::c_uint = 6;
pub const CACHE_LINE_SIZE: ::std::os::raw::c_uint = 64;
pub const NPTEPGSHIFT: ::std::os::raw::c_uint = 9;
pub const PAGE_SHIFT: ::std::os::raw::c_uint = 12;
pub const PAGE_SIZE: ::std::os::raw::c_uint = 4096;
pub const PAGE_MASK: ::std::os::raw::c_uint = 4095;
pub const NPDEPGSHIFT: ::std::os::raw::c_uint = 9;
pub const PDRSHIFT: ::std::os::raw::c_uint = 21;
pub const NBPDR: ::std::os::raw::c_uint = 2097152;
pub const PDRMASK: ::std::os::raw::c_uint = 2097151;
pub const NPDPEPGSHIFT: ::std::os::raw::c_uint = 9;
pub const PDPSHIFT: ::std::os::raw::c_uint = 30;
pub const NBPDP: ::std::os::raw::c_uint = 1073741824;
pub const PDPMASK: ::std::os::raw::c_uint = 1073741823;
pub const NPML4EPGSHIFT: ::std::os::raw::c_uint = 9;
pub const PML4SHIFT: ::std::os::raw::c_uint = 39;
pub const NBPML4: ::std::os::raw::c_ulonglong = 549755813888;
pub const PML4MASK: ::std::os::raw::c_ulonglong = 549755813887;
pub const MAXPAGESIZES: ::std::os::raw::c_uint = 3;
pub const IOPAGES: ::std::os::raw::c_uint = 2;
pub const IOPERM_BITMAP_SIZE: ::std::os::raw::c_uint = 8193;
pub const KSTACK_PAGES: ::std::os::raw::c_uint = 4;
pub const KSTACK_GUARD_PAGES: ::std::os::raw::c_uint = 1;
pub const DEV_BSHIFT: ::std::os::raw::c_uint = 9;
pub const DEV_BSIZE: ::std::os::raw::c_uint = 512;
pub const BLKDEV_IOSIZE: ::std::os::raw::c_uint = 4096;
pub const DFLTPHYS: ::std::os::raw::c_uint = 65536;
pub const MAXPHYS: ::std::os::raw::c_uint = 131072;
pub const MAXDUMPPGS: ::std::os::raw::c_uint = 16;
pub const MSIZE: ::std::os::raw::c_uint = 256;
pub const MCLSHIFT: ::std::os::raw::c_uint = 11;
pub const MCLBYTES: ::std::os::raw::c_uint = 2048;
pub const MJUMPAGESIZE: ::std::os::raw::c_uint = 4096;
pub const MJUM9BYTES: ::std::os::raw::c_uint = 9216;
pub const MJUM16BYTES: ::std::os::raw::c_uint = 16384;
pub const PRIMASK: ::std::os::raw::c_uint = 255;
pub const PCATCH: ::std::os::raw::c_uint = 256;
pub const PDROP: ::std::os::raw::c_uint = 512;
pub const NZERO: ::std::os::raw::c_uint = 0;
pub const NBBY: ::std::os::raw::c_uint = 8;
pub const CMASK: ::std::os::raw::c_uint = 18;
pub const MAXBSIZE: ::std::os::raw::c_uint = 65536;
pub const MAXBCACHEBUF: ::std::os::raw::c_uint = 65536;
pub const BKVASIZE: ::std::os::raw::c_uint = 16384;
pub const BKVAMASK: ::std::os::raw::c_uint = 16383;
pub const MAXPATHLEN: ::std::os::raw::c_uint = 1024;
pub const MAXSYMLINKS: ::std::os::raw::c_uint = 32;
pub const FSHIFT: ::std::os::raw::c_uint = 11;
pub const FSCALE: ::std::os::raw::c_uint = 2048;
pub const CPU_SETSIZE: ::std::os::raw::c_uint = 256;
pub const CPU_MAXSIZE: ::std::os::raw::c_uint = 256;
pub const PRIO_MIN: ::std::os::raw::c_int = -20;
pub const PRIO_MAX: ::std::os::raw::c_uint = 20;
pub const PRIO_PROCESS: ::std::os::raw::c_uint = 0;
pub const PRIO_PGRP: ::std::os::raw::c_uint = 1;
pub const PRIO_USER: ::std::os::raw::c_uint = 2;
pub const RUSAGE_SELF: ::std::os::raw::c_uint = 0;
pub const RUSAGE_CHILDREN: ::std::os::raw::c_int = -1;
pub const RUSAGE_THREAD: ::std::os::raw::c_uint = 1;
pub const RLIMIT_CPU: ::std::os::raw::c_uint = 0;
pub const RLIMIT_FSIZE: ::std::os::raw::c_uint = 1;
pub const RLIMIT_DATA: ::std::os::raw::c_uint = 2;
pub const RLIMIT_STACK: ::std::os::raw::c_uint = 3;
pub const RLIMIT_CORE: ::std::os::raw::c_uint = 4;
pub const RLIMIT_RSS: ::std::os::raw::c_uint = 5;
pub const RLIMIT_MEMLOCK: ::std::os::raw::c_uint = 6;
pub const RLIMIT_NPROC: ::std::os::raw::c_uint = 7;
pub const RLIMIT_NOFILE: ::std::os::raw::c_uint = 8;
pub const RLIMIT_SBSIZE: ::std::os::raw::c_uint = 9;
pub const RLIMIT_VMEM: ::std::os::raw::c_uint = 10;
pub const RLIMIT_AS: ::std::os::raw::c_uint = 10;
pub const RLIMIT_NPTS: ::std::os::raw::c_uint = 11;
pub const RLIMIT_SWAP: ::std::os::raw::c_uint = 12;
pub const RLIMIT_KQUEUES: ::std::os::raw::c_uint = 13;
pub const RLIMIT_UMTXP: ::std::os::raw::c_uint = 14;
pub const RLIM_NLIMITS: ::std::os::raw::c_uint = 15;
pub const CP_USER: ::std::os::raw::c_uint = 0;
pub const CP_NICE: ::std::os::raw::c_uint = 1;
pub const CP_SYS: ::std::os::raw::c_uint = 2;
pub const CP_INTR: ::std::os::raw::c_uint = 3;
pub const CP_IDLE: ::std::os::raw::c_uint = 4;
pub const CPUSTATES: ::std::os::raw::c_uint = 5;
pub const PC_PTI_STACK_SZ: ::std::os::raw::c_uint = 16;
pub const PC_DBREG_CMD_NONE: ::std::os::raw::c_uint = 0;
pub const PC_DBREG_CMD_LOAD: ::std::os::raw::c_uint = 1;
pub const OFFSETOF_CURTHREAD: ::std::os::raw::c_uint = 0;
pub const OFFSETOF_CURPCB: ::std::os::raw::c_uint = 32;
pub const DPCPU_SETNAME: &'static [u8; 9usize] = b"set_pcpu\x00";
pub const DPCPU_SYMPREFIX: &'static [u8; 12usize] = b"pcpu_entry_\x00";
pub const DPCPU_MODMIN: ::std::os::raw::c_uint = 2048;
pub const LOCKSTAT_WRITER: ::std::os::raw::c_uint = 0;
pub const LOCKSTAT_READER: ::std::os::raw::c_uint = 1;
pub const CR4_PGE: ::std::os::raw::c_uint = 128;
pub const INVPCID_ADDR: ::std::os::raw::c_uint = 0;
pub const INVPCID_CTX: ::std::os::raw::c_uint = 1;
pub const INVPCID_CTXGLOB: ::std::os::raw::c_uint = 2;
pub const INVPCID_ALLCTX: ::std::os::raw::c_uint = 3;
pub const MSR_FSBASE: ::std::os::raw::c_uint = 3221225728;
pub const MSR_GSBASE: ::std::os::raw::c_uint = 3221225729;
pub const MTX_DEF: ::std::os::raw::c_uint = 0;
pub const MTX_SPIN: ::std::os::raw::c_uint = 1;
pub const MTX_RECURSE: ::std::os::raw::c_uint = 4;
pub const MTX_NOWITNESS: ::std::os::raw::c_uint = 8;
pub const MTX_NOPROFILE: ::std::os::raw::c_uint = 32;
pub const MTX_NEW: ::std::os::raw::c_uint = 64;
pub const MTX_QUIET: ::std::os::raw::c_uint = 2;
pub const MTX_DUPOK: ::std::os::raw::c_uint = 16;
pub const MTX_UNOWNED: ::std::os::raw::c_uint = 0;
pub const MTX_RECURSED: ::std::os::raw::c_uint = 1;
pub const MTX_CONTESTED: ::std::os::raw::c_uint = 2;
pub const MTX_DESTROYED: ::std::os::raw::c_uint = 4;
pub const MTX_FLAGMASK: ::std::os::raw::c_uint = 7;
pub const MTX_NETWORK_LOCK: &'static [u8; 15usize] = b"network driver\x00";
pub const EHE_DEAD_PRIORITY: ::std::os::raw::c_int = -1;
pub const EVENTHANDLER_PRI_FIRST: ::std::os::raw::c_uint = 0;
pub const EVENTHANDLER_PRI_ANY: ::std::os::raw::c_uint = 10000;
pub const EVENTHANDLER_PRI_LAST: ::std::os::raw::c_uint = 20000;
pub const SHUTDOWN_PRI_FIRST: ::std::os::raw::c_uint = 0;
pub const SHUTDOWN_PRI_DEFAULT: ::std::os::raw::c_uint = 10000;
pub const SHUTDOWN_PRI_LAST: ::std::os::raw::c_uint = 20000;
pub const LOWMEM_PRI_DEFAULT: ::std::os::raw::c_uint = 0;
pub const SI_ETERNAL: ::std::os::raw::c_uint = 1;
pub const SI_ALIAS: ::std::os::raw::c_uint = 2;
pub const SI_NAMED: ::std::os::raw::c_uint = 4;
pub const SI_CHEAPCLONE: ::std::os::raw::c_uint = 8;
pub const SI_CHILD: ::std::os::raw::c_uint = 16;
pub const SI_DUMPDEV: ::std::os::raw::c_uint = 128;
pub const SI_CLONELIST: ::std::os::raw::c_uint = 512;
pub const SI_UNMAPPED: ::std::os::raw::c_uint = 1024;
pub const SI_NOSPLIT: ::std::os::raw::c_uint = 2048;
pub const D_TAPE: ::std::os::raw::c_uint = 1;
pub const D_DISK: ::std::os::raw::c_uint = 2;
pub const D_TTY: ::std::os::raw::c_uint = 4;
pub const D_MEM: ::std::os::raw::c_uint = 8;
pub const D_TYPEMASK: ::std::os::raw::c_uint = 65535;
pub const D_TRACKCLOSE: ::std::os::raw::c_uint = 524288;
pub const D_MMAP_ANON: ::std::os::raw::c_uint = 1048576;
pub const D_NEEDGIANT: ::std::os::raw::c_uint = 4194304;
pub const D_NEEDMINOR: ::std::os::raw::c_uint = 8388608;
pub const D_VERSION_00: ::std::os::raw::c_uint = 536942950;
pub const D_VERSION_01: ::std::os::raw::c_uint = 386080773;
pub const D_VERSION_02: ::std::os::raw::c_uint = 671358985;
pub const D_VERSION_03: ::std::os::raw::c_uint = 387063817;
pub const D_VERSION: ::std::os::raw::c_uint = 387063817;
pub const D_INIT: ::std::os::raw::c_uint = 2147483648;
pub const CLONE_UNITMASK: ::std::os::raw::c_uint = 1048575;
pub const CLONE_FLAG0: ::std::os::raw::c_uint = 1048576;
pub const MAKEDEV_REF: ::std::os::raw::c_uint = 1;
pub const MAKEDEV_WHTOUT: ::std::os::raw::c_uint = 2;
pub const MAKEDEV_NOWAIT: ::std::os::raw::c_uint = 4;
pub const MAKEDEV_WAITOK: ::std::os::raw::c_uint = 8;
pub const MAKEDEV_ETERNAL: ::std::os::raw::c_uint = 16;
pub const MAKEDEV_CHECKNAME: ::std::os::raw::c_uint = 32;
pub const MAKEDEV_ETERNAL_KLD: ::std::os::raw::c_uint = 0;
pub const UID_ROOT: ::std::os::raw::c_uint = 0;
pub const UID_BIN: ::std::os::raw::c_uint = 3;
pub const UID_UUCP: ::std::os::raw::c_uint = 66;
pub const UID_NOBODY: ::std::os::raw::c_uint = 65534;
pub const GID_WHEEL: ::std::os::raw::c_uint = 0;
pub const GID_KMEM: ::std::os::raw::c_uint = 2;
pub const GID_TTY: ::std::os::raw::c_uint = 4;
pub const GID_OPERATOR: ::std::os::raw::c_uint = 5;
pub const GID_BIN: ::std::os::raw::c_uint = 7;
pub const GID_GAMES: ::std::os::raw::c_uint = 13;
pub const GID_VIDEO: ::std::os::raw::c_uint = 44;
pub const GID_DIALER: ::std::os::raw::c_uint = 68;
pub const GID_NOGROUP: ::std::os::raw::c_uint = 65533;
pub const GID_NOBODY: ::std::os::raw::c_uint = 65534;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __clock_t = __int32_t;
pub type __critical_t = __int64_t;
pub type __double_t = f64;
pub type __float_t = f32;
pub type __intfptr_t = __int64_t;
pub type __intptr_t = __int64_t;
pub type __intmax_t = __int64_t;
pub type __int_fast8_t = __int32_t;
pub type __int_fast16_t = __int32_t;
pub type __int_fast32_t = __int32_t;
pub type __int_fast64_t = __int64_t;
pub type __int_least8_t = __int8_t;
pub type __int_least16_t = __int16_t;
pub type __int_least32_t = __int32_t;
pub type __int_least64_t = __int64_t;
pub type __ptrdiff_t = __int64_t;
pub type __register_t = __int64_t;
pub type __segsz_t = __int64_t;
pub type __size_t = __uint64_t;
pub type __ssize_t = __int64_t;
pub type __time_t = __int64_t;
pub type __uintfptr_t = __uint64_t;
pub type __uintptr_t = __uint64_t;
pub type __uintmax_t = __uint64_t;
pub type __uint_fast8_t = __uint32_t;
pub type __uint_fast16_t = __uint32_t;
pub type __uint_fast32_t = __uint32_t;
pub type __uint_fast64_t = __uint64_t;
pub type __uint_least8_t = __uint8_t;
pub type __uint_least16_t = __uint16_t;
pub type __uint_least32_t = __uint32_t;
pub type __uint_least64_t = __uint64_t;
pub type __u_register_t = __uint64_t;
pub type __vm_offset_t = __uint64_t;
pub type __vm_paddr_t = __uint64_t;
pub type __vm_size_t = __uint64_t;
pub type ___wchar_t = ::std::os::raw::c_int;
pub type __va_list = __builtin_va_list;
pub type __gnuc_va_list = __va_list;
pub type __blksize_t = __int32_t;
pub type __blkcnt_t = __int64_t;
pub type __clockid_t = __int32_t;
pub type __fflags_t = __uint32_t;
pub type __fsblkcnt_t = __uint64_t;
pub type __fsfilcnt_t = __uint64_t;
pub type __gid_t = __uint32_t;
pub type __id_t = __int64_t;
pub type __ino_t = __uint64_t;
pub type __key_t = ::std::os::raw::c_long;
pub type __lwpid_t = __int32_t;
pub type __mode_t = __uint16_t;
pub type __accmode_t = ::std::os::raw::c_int;
pub type __nl_item = ::std::os::raw::c_int;
pub type __nlink_t = __uint64_t;
pub type __off_t = __int64_t;
pub type __off64_t = __int64_t;
pub type __pid_t = __int32_t;
pub type __rlim_t = __int64_t;
pub type __sa_family_t = __uint8_t;
pub type __socklen_t = __uint32_t;
pub type __suseconds_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __timer {
    _unused: [u8; 0],
}
pub type __timer_t = *mut __timer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __mq {
    _unused: [u8; 0],
}
pub type __mqd_t = *mut __mq;
pub type __uid_t = __uint32_t;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __cpuwhich_t = ::std::os::raw::c_int;
pub type __cpulevel_t = ::std::os::raw::c_int;
pub type __cpusetid_t = ::std::os::raw::c_int;
pub type __ct_rune_t = ::std::os::raw::c_int;
pub type __rune_t = __ct_rune_t;
pub type __wint_t = __ct_rune_t;
pub type __char16_t = __uint_least16_t;
pub type __char32_t = __uint_least32_t;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct __max_align_t {
    pub __max_align1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __max_align2: f64,
}
#[test]
fn bindgen_test_layout___max_align_t() {
    assert_eq!(::std::mem::size_of::<__max_align_t>() , 32usize , concat ! (
               "Size of: " , stringify ! ( __max_align_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __max_align_t ) ) . __max_align1 as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __max_align_t ) , "::"
                , stringify ! ( __max_align1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __max_align_t ) ) . __max_align2 as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __max_align_t ) , "::"
                , stringify ! ( __max_align2 ) ));
}
impl Clone for __max_align_t {
    fn clone(&self) -> Self { *self }
}
pub type __dev_t = __uint64_t;
pub type __fixpt_t = __uint32_t;
#[repr(C)]
#[derive(Copy)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: __int64_t,
    _bindgen_union_align: [u64; 16usize],
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(::std::mem::size_of::<__mbstate_t>() , 128usize , concat ! (
               "Size of: " , stringify ! ( __mbstate_t ) ));
    assert_eq! (::std::mem::align_of::<__mbstate_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __mbstate_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . __mbstate8 as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( __mbstate8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . _mbstateL as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( _mbstateL ) ));
}
impl Clone for __mbstate_t {
    fn clone(&self) -> Self { *self }
}
impl Default for __mbstate_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl ::std::fmt::Debug for __mbstate_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f , "__mbstate_t {{ union }}")
    }
}
pub type __rman_res_t = __uintmax_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_cond {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_cond_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutex {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutex_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_once {
    pub state: ::std::os::raw::c_int,
    pub mutex: pthread_mutex_t,
}
#[test]
fn bindgen_test_layout_pthread_once() {
    assert_eq!(::std::mem::size_of::<pthread_once>() , 16usize , concat ! (
               "Size of: " , stringify ! ( pthread_once ) ));
    assert_eq! (::std::mem::align_of::<pthread_once>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_once ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_once ) ) . state as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_once ) , "::" ,
                stringify ! ( state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_once ) ) . mutex as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_once ) , "::" ,
                stringify ! ( mutex ) ));
}
impl Clone for pthread_once {
    fn clone(&self) -> Self { *self }
}
impl Default for pthread_once {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_rwlock {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_rwlockattr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_barrier {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_barrier_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_spinlock {
    _unused: [u8; 0],
}
pub type pthread_t = *mut pthread;
pub type pthread_attr_t = *mut pthread_attr;
pub type pthread_mutex_t = *mut pthread_mutex;
pub type pthread_mutexattr_t = *mut pthread_mutex_attr;
pub type pthread_cond_t = *mut pthread_cond;
pub type pthread_condattr_t = *mut pthread_cond_attr;
pub type pthread_key_t = ::std::os::raw::c_int;
pub type pthread_once_t = pthread_once;
pub type pthread_rwlock_t = *mut pthread_rwlock;
pub type pthread_rwlockattr_t = *mut pthread_rwlockattr;
pub type pthread_barrier_t = *mut pthread_barrier;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_barrierattr {
    _unused: [u8; 0],
}
pub type pthread_barrierattr_t = *mut pthread_barrierattr;
pub type pthread_spinlock_t = *mut pthread_spinlock;
pub type pthread_addr_t = *mut ::std::os::raw::c_void;
pub type pthread_startroutine_t =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void)
                              -> *mut ::std::os::raw::c_void>;
pub type u_char = ::std::os::raw::c_uchar;
pub type u_short = ::std::os::raw::c_ushort;
pub type u_int = ::std::os::raw::c_uint;
pub type u_long = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type u_quad_t = __uint64_t;
pub type quad_t = __int64_t;
pub type qaddr_t = *mut quad_t;
pub type caddr_t = *mut ::std::os::raw::c_char;
pub type c_caddr_t = *const ::std::os::raw::c_char;
pub type blksize_t = __blksize_t;
pub type cpuwhich_t = __cpuwhich_t;
pub type cpulevel_t = __cpulevel_t;
pub type cpusetid_t = __cpusetid_t;
pub type blkcnt_t = __blkcnt_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type critical_t = __critical_t;
pub type daddr_t = __int64_t;
pub type dev_t = __dev_t;
pub type fflags_t = __fflags_t;
pub type fixpt_t = __fixpt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type gid_t = __gid_t;
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type id_t = __id_t;
pub type ino_t = __ino_t;
pub type key_t = __key_t;
pub type lwpid_t = __lwpid_t;
pub type mode_t = __mode_t;
pub type accmode_t = __accmode_t;
pub type nlink_t = __nlink_t;
pub type off_t = __off_t;
pub type off64_t = __off64_t;
pub type pid_t = __pid_t;
pub type register_t = __register_t;
pub type rlim_t = __rlim_t;
pub type sbintime_t = __int64_t;
pub type segsz_t = __segsz_t;
pub type suseconds_t = __suseconds_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type mqd_t = __mqd_t;
pub type u_register_t = __u_register_t;
pub type uid_t = __uid_t;
pub type useconds_t = __useconds_t;
pub type cap_ioctl_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cap_rights {
    _unused: [u8; 0],
}
pub type cap_rights_t = cap_rights;
pub type vm_offset_t = __vm_offset_t;
pub type vm_ooffset_t = __int64_t;
pub type vm_paddr_t = __vm_paddr_t;
pub type vm_pindex_t = __uint64_t;
pub type vm_size_t = __vm_size_t;
pub type rman_res_t = __rman_res_t;
pub type boolean_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct device {
    _unused: [u8; 0],
}
pub type device_t = *mut device;
pub type intfptr_t = __intfptr_t;
pub type intrmask_t = __uint32_t;
pub type uintfptr_t = __uintfptr_t;
pub type uoff_t = __uint64_t;
pub type vm_memattr_t = ::std::os::raw::c_char;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_page {
    _unused: [u8; 0],
}
pub type vm_page_t = *mut vm_page;
pub type bool_ = bool;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct __sigset {
    pub __bits: [__uint32_t; 4usize],
}
#[test]
fn bindgen_test_layout___sigset() {
    assert_eq!(::std::mem::size_of::<__sigset>() , 16usize , concat ! (
               "Size of: " , stringify ! ( __sigset ) ));
    assert_eq! (::std::mem::align_of::<__sigset>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( __sigset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sigset ) ) . __bits as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sigset ) , "::" ,
                stringify ! ( __bits ) ));
}
impl Clone for __sigset {
    fn clone(&self) -> Self { *self }
}
pub type __sigset_t = __sigset;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct timeval {
    pub tv_sec: time_t,
    pub tv_usec: suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(::std::mem::size_of::<timeval>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timeval ) ));
    assert_eq! (::std::mem::align_of::<timeval>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timeval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_usec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_usec ) ));
}
impl Clone for timeval {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(::std::mem::size_of::<timespec>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timespec ) ));
    assert_eq! (::std::mem::align_of::<timespec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timespec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_nsec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_nsec ) ));
}
impl Clone for timespec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(::std::mem::size_of::<itimerspec>() , 32usize , concat ! (
               "Size of: " , stringify ! ( itimerspec ) ));
    assert_eq! (::std::mem::align_of::<itimerspec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( itimerspec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerspec ) ) . it_interval as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerspec ) , "::" ,
                stringify ! ( it_interval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerspec ) ) . it_value as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerspec ) , "::" ,
                stringify ! ( it_value ) ));
}
impl Clone for itimerspec {
    fn clone(&self) -> Self { *self }
}
pub type __fd_mask = ::std::os::raw::c_ulong;
pub type fd_mask = __fd_mask;
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(::std::mem::size_of::<fd_set>() , 128usize , concat ! (
               "Size of: " , stringify ! ( fd_set ) ));
    assert_eq! (::std::mem::align_of::<fd_set>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( fd_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fd_set ) ) . __fds_bits as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( fd_set ) , "::" ,
                stringify ! ( __fds_bits ) ));
}
impl Clone for fd_set {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lock_object {
    pub lo_name: *const ::std::os::raw::c_char,
    pub lo_flags: u_int,
    pub lo_data: u_int,
    pub lo_witness: *mut witness,
}
#[test]
fn bindgen_test_layout_lock_object() {
    assert_eq!(::std::mem::size_of::<lock_object>() , 24usize , concat ! (
               "Size of: " , stringify ! ( lock_object ) ));
    assert_eq! (::std::mem::align_of::<lock_object>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lock_object ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_object ) ) . lo_name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_object ) , "::" ,
                stringify ! ( lo_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_object ) ) . lo_flags as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_object ) , "::" ,
                stringify ! ( lo_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_object ) ) . lo_data as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_object ) , "::" ,
                stringify ! ( lo_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_object ) ) . lo_witness as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_object ) , "::" ,
                stringify ! ( lo_witness ) ));
}
impl Clone for lock_object {
    fn clone(&self) -> Self { *self }
}
impl Default for lock_object {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lock_list_entry {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct thread {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lock_class {
    pub lc_name: *const ::std::os::raw::c_char,
    pub lc_flags: u_int,
    pub lc_assert: ::std::option::Option<unsafe extern "C" fn(lock:
                                                                  *const lock_object,
                                                              what:
                                                                  ::std::os::raw::c_int)>,
    pub lc_ddb_show: ::std::option::Option<unsafe extern "C" fn(lock:
                                                                    *const lock_object)>,
    pub lc_lock: ::std::option::Option<unsafe extern "C" fn(lock:
                                                                *mut lock_object,
                                                            how: usize)>,
    pub lc_owner: ::std::option::Option<unsafe extern "C" fn(lock:
                                                                 *const lock_object,
                                                             owner:
                                                                 *mut *mut thread)
                                            -> ::std::os::raw::c_int>,
    pub lc_unlock: ::std::option::Option<unsafe extern "C" fn(lock:
                                                                  *mut lock_object)
                                             -> usize>,
}
#[test]
fn bindgen_test_layout_lock_class() {
    assert_eq!(::std::mem::size_of::<lock_class>() , 56usize , concat ! (
               "Size of: " , stringify ! ( lock_class ) ));
    assert_eq! (::std::mem::align_of::<lock_class>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lock_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_class ) ) . lc_name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_class ) , "::" ,
                stringify ! ( lc_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_class ) ) . lc_flags as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_class ) , "::" ,
                stringify ! ( lc_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_class ) ) . lc_assert as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_class ) , "::" ,
                stringify ! ( lc_assert ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_class ) ) . lc_ddb_show as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_class ) , "::" ,
                stringify ! ( lc_ddb_show ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_class ) ) . lc_lock as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_class ) , "::" ,
                stringify ! ( lc_lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_class ) ) . lc_owner as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_class ) , "::" ,
                stringify ! ( lc_owner ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_class ) ) . lc_unlock as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_class ) , "::" ,
                stringify ! ( lc_unlock ) ));
}
impl Clone for lock_class {
    fn clone(&self) -> Self { *self }
}
impl Default for lock_class {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
extern "C" {
    #[link_name = "lock_class_mtx_sleep"]
    pub static mut lock_class_mtx_sleep: lock_class;
}
extern "C" {
    #[link_name = "lock_class_mtx_spin"]
    pub static mut lock_class_mtx_spin: lock_class;
}
extern "C" {
    #[link_name = "lock_class_sx"]
    pub static mut lock_class_sx: lock_class;
}
extern "C" {
    #[link_name = "lock_class_rw"]
    pub static mut lock_class_rw: lock_class;
}
extern "C" {
    #[link_name = "lock_class_rm"]
    pub static mut lock_class_rm: lock_class;
}
extern "C" {
    #[link_name = "lock_class_rm_sleepable"]
    pub static mut lock_class_rm_sleepable: lock_class;
}
extern "C" {
    #[link_name = "lock_class_lockmgr"]
    pub static mut lock_class_lockmgr: lock_class;
}
extern "C" {
    #[link_name = "lock_classes"]
    pub static mut lock_classes: [*mut lock_class; 0usize];
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct lock_delay_config {
    pub base: u_int,
    pub max: u_int,
}
#[test]
fn bindgen_test_layout_lock_delay_config() {
    assert_eq!(::std::mem::size_of::<lock_delay_config>() , 8usize , concat !
               ( "Size of: " , stringify ! ( lock_delay_config ) ));
    assert_eq! (::std::mem::align_of::<lock_delay_config>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( lock_delay_config ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_delay_config ) ) . base as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_delay_config ) ,
                "::" , stringify ! ( base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_delay_config ) ) . max as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_delay_config ) ,
                "::" , stringify ! ( max ) ));
}
impl Clone for lock_delay_config {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lock_delay_arg {
    pub config: *mut lock_delay_config,
    pub delay: u_int,
    pub spin_cnt: u_int,
}
#[test]
fn bindgen_test_layout_lock_delay_arg() {
    assert_eq!(::std::mem::size_of::<lock_delay_arg>() , 16usize , concat ! (
               "Size of: " , stringify ! ( lock_delay_arg ) ));
    assert_eq! (::std::mem::align_of::<lock_delay_arg>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lock_delay_arg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_delay_arg ) ) . config as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_delay_arg ) , "::"
                , stringify ! ( config ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_delay_arg ) ) . delay as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_delay_arg ) , "::"
                , stringify ! ( delay ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_delay_arg ) ) . spin_cnt as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_delay_arg ) , "::"
                , stringify ! ( spin_cnt ) ));
}
impl Clone for lock_delay_arg {
    fn clone(&self) -> Self { *self }
}
impl Default for lock_delay_arg {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
extern "C" {
    pub fn lock_init(arg1: *mut lock_object, arg2: *mut lock_class,
                     arg3: *const ::std::os::raw::c_char,
                     arg4: *const ::std::os::raw::c_char,
                     arg5: ::std::os::raw::c_int);
}
extern "C" {
    pub fn lock_destroy(arg1: *mut lock_object);
}
extern "C" {
    pub fn lock_delay(arg1: *mut lock_delay_arg);
}
extern "C" {
    pub fn lock_delay_default_init(arg1: *mut lock_delay_config);
}
extern "C" {
    pub fn spinlock_enter();
}
extern "C" {
    pub fn spinlock_exit();
}
extern "C" {
    pub fn witness_init(arg1: *mut lock_object,
                        arg2: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn witness_destroy(arg1: *mut lock_object);
}
extern "C" {
    pub fn witness_defineorder(arg1: *mut lock_object, arg2: *mut lock_object)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn witness_checkorder(arg1: *mut lock_object,
                              arg2: ::std::os::raw::c_int,
                              arg3: *const ::std::os::raw::c_char,
                              arg4: ::std::os::raw::c_int,
                              arg5: *mut lock_object);
}
extern "C" {
    pub fn witness_lock(arg1: *mut lock_object, arg2: ::std::os::raw::c_int,
                        arg3: *const ::std::os::raw::c_char,
                        arg4: ::std::os::raw::c_int);
}
extern "C" {
    pub fn witness_upgrade(arg1: *mut lock_object,
                           arg2: ::std::os::raw::c_int,
                           arg3: *const ::std::os::raw::c_char,
                           arg4: ::std::os::raw::c_int);
}
extern "C" {
    pub fn witness_downgrade(arg1: *mut lock_object,
                             arg2: ::std::os::raw::c_int,
                             arg3: *const ::std::os::raw::c_char,
                             arg4: ::std::os::raw::c_int);
}
extern "C" {
    pub fn witness_unlock(arg1: *mut lock_object, arg2: ::std::os::raw::c_int,
                          arg3: *const ::std::os::raw::c_char,
                          arg4: ::std::os::raw::c_int);
}
extern "C" {
    pub fn witness_save(arg1: *mut lock_object,
                        arg2: *mut *const ::std::os::raw::c_char,
                        arg3: *mut ::std::os::raw::c_int);
}
extern "C" {
    pub fn witness_restore(arg1: *mut lock_object,
                           arg2: *const ::std::os::raw::c_char,
                           arg3: ::std::os::raw::c_int);
}
extern "C" {
    pub fn witness_list_locks(arg1: *mut *mut lock_list_entry,
                              arg2:
                                  ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                 *const ::std::os::raw::c_char, ...)
                                                            ->
                                                                ::std::os::raw::c_int>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn witness_warn(arg1: ::std::os::raw::c_int, arg2: *mut lock_object,
                        arg3: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn witness_assert(arg1: *const lock_object,
                          arg2: ::std::os::raw::c_int,
                          arg3: *const ::std::os::raw::c_char,
                          arg4: ::std::os::raw::c_int);
}
extern "C" {
    pub fn witness_display_spinlock(arg1: *mut lock_object, arg2: *mut thread,
                                    arg3:
                                        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                       *const ::std::os::raw::c_char, ...)
                                                                  ->
                                                                      ::std::os::raw::c_int>);
}
extern "C" {
    pub fn witness_line(arg1: *mut lock_object) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn witness_norelease(arg1: *mut lock_object);
}
extern "C" {
    pub fn witness_releaseok(arg1: *mut lock_object);
}
extern "C" {
    pub fn witness_file(arg1: *mut lock_object)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn witness_thread_exit(arg1: *mut thread);
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct timezone {
    pub tz_minuteswest: ::std::os::raw::c_int,
    pub tz_dsttime: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_timezone() {
    assert_eq!(::std::mem::size_of::<timezone>() , 8usize , concat ! (
               "Size of: " , stringify ! ( timezone ) ));
    assert_eq! (::std::mem::align_of::<timezone>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( timezone ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timezone ) ) . tz_minuteswest as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timezone ) , "::" ,
                stringify ! ( tz_minuteswest ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timezone ) ) . tz_dsttime as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( timezone ) , "::" ,
                stringify ! ( tz_dsttime ) ));
}
impl Clone for timezone {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct bintime {
    pub sec: time_t,
    pub frac: u64,
}
#[test]
fn bindgen_test_layout_bintime() {
    assert_eq!(::std::mem::size_of::<bintime>() , 16usize , concat ! (
               "Size of: " , stringify ! ( bintime ) ));
    assert_eq! (::std::mem::align_of::<bintime>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( bintime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bintime ) ) . sec as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( bintime ) , "::" ,
                stringify ! ( sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bintime ) ) . frac as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( bintime ) , "::" ,
                stringify ! ( frac ) ));
}
impl Clone for bintime {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
#[test]
fn bindgen_test_layout_itimerval() {
    assert_eq!(::std::mem::size_of::<itimerval>() , 32usize , concat ! (
               "Size of: " , stringify ! ( itimerval ) ));
    assert_eq! (::std::mem::align_of::<itimerval>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( itimerval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerval ) ) . it_interval as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerval ) , "::" ,
                stringify ! ( it_interval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerval ) ) . it_value as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerval ) , "::" ,
                stringify ! ( it_value ) ));
}
impl Clone for itimerval {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct clockinfo {
    pub hz: ::std::os::raw::c_int,
    pub tick: ::std::os::raw::c_int,
    pub spare: ::std::os::raw::c_int,
    pub stathz: ::std::os::raw::c_int,
    pub profhz: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_clockinfo() {
    assert_eq!(::std::mem::size_of::<clockinfo>() , 20usize , concat ! (
               "Size of: " , stringify ! ( clockinfo ) ));
    assert_eq! (::std::mem::align_of::<clockinfo>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( clockinfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clockinfo ) ) . hz as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( clockinfo ) , "::" ,
                stringify ! ( hz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clockinfo ) ) . tick as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( clockinfo ) , "::" ,
                stringify ! ( tick ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clockinfo ) ) . spare as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( clockinfo ) , "::" ,
                stringify ! ( spare ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clockinfo ) ) . stathz as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( clockinfo ) , "::" ,
                stringify ! ( stathz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clockinfo ) ) . profhz as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( clockinfo ) , "::" ,
                stringify ! ( profhz ) ));
}
impl Clone for clockinfo {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn inittodr(base: time_t);
}
extern "C" {
    pub fn resettodr();
}
extern "C" {
    #[link_name = "time_second"]
    pub static mut time_second: time_t;
}
extern "C" {
    #[link_name = "time_uptime"]
    pub static mut time_uptime: time_t;
}
extern "C" {
    #[link_name = "tc_tick_bt"]
    pub static mut tc_tick_bt: bintime;
}
extern "C" {
    #[link_name = "tc_tick_sbt"]
    pub static mut tc_tick_sbt: sbintime_t;
}
extern "C" {
    #[link_name = "tick_bt"]
    pub static mut tick_bt: bintime;
}
extern "C" {
    #[link_name = "tick_sbt"]
    pub static mut tick_sbt: sbintime_t;
}
extern "C" {
    #[link_name = "tc_precexp"]
    pub static mut tc_precexp: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "tc_timepercentage"]
    pub static mut tc_timepercentage: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "bt_timethreshold"]
    pub static mut bt_timethreshold: bintime;
}
extern "C" {
    #[link_name = "bt_tickthreshold"]
    pub static mut bt_tickthreshold: bintime;
}
extern "C" {
    #[link_name = "sbt_timethreshold"]
    pub static mut sbt_timethreshold: sbintime_t;
}
extern "C" {
    #[link_name = "sbt_tickthreshold"]
    pub static mut sbt_tickthreshold: sbintime_t;
}
extern "C" {
    #[link_name = "rtc_generation"]
    pub static mut rtc_generation: ::std::os::raw::c_int;
}
extern "C" {
    pub fn binuptime(bt: *mut bintime);
}
extern "C" {
    pub fn nanouptime(tsp: *mut timespec);
}
extern "C" {
    pub fn microuptime(tvp: *mut timeval);
}
extern "C" {
    pub fn bintime(bt: *mut bintime);
}
extern "C" {
    pub fn nanotime(tsp: *mut timespec);
}
extern "C" {
    pub fn microtime(tvp: *mut timeval);
}
extern "C" {
    pub fn getbinuptime(bt: *mut bintime);
}
extern "C" {
    pub fn getnanouptime(tsp: *mut timespec);
}
extern "C" {
    pub fn getmicrouptime(tvp: *mut timeval);
}
extern "C" {
    pub fn getbintime(bt: *mut bintime);
}
extern "C" {
    pub fn getnanotime(tsp: *mut timespec);
}
extern "C" {
    pub fn getmicrotime(tvp: *mut timeval);
}
extern "C" {
    pub fn getboottime(boottime: *mut timeval);
}
extern "C" {
    pub fn getboottimebin(boottimebin: *mut bintime);
}
extern "C" {
    pub fn itimerdecr(itp: *mut itimerval, usec: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn itimerfix(tv: *mut timeval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ppsratecheck(arg1: *mut timeval, arg2: *mut ::std::os::raw::c_int,
                        arg3: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ratecheck(arg1: *mut timeval, arg2: *const timeval)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timevaladd(t1: *mut timeval, t2: *const timeval);
}
extern "C" {
    pub fn timevalsub(t1: *mut timeval, t2: *const timeval);
}
extern "C" {
    pub fn tvtohz(tv: *mut timeval) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct priority {
    pub pri_class: u_char,
    pub pri_level: u_char,
    pub pri_native: u_char,
    pub pri_user: u_char,
}
#[test]
fn bindgen_test_layout_priority() {
    assert_eq!(::std::mem::size_of::<priority>() , 4usize , concat ! (
               "Size of: " , stringify ! ( priority ) ));
    assert_eq! (::std::mem::align_of::<priority>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( priority ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const priority ) ) . pri_class as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( priority ) , "::" ,
                stringify ! ( pri_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const priority ) ) . pri_level as * const _ as
                usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( priority ) , "::" ,
                stringify ! ( pri_level ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const priority ) ) . pri_native as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( priority ) , "::" ,
                stringify ! ( pri_native ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const priority ) ) . pri_user as * const _ as
                usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( priority ) , "::" ,
                stringify ! ( pri_user ) ));
}
impl Clone for priority {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn htonl(arg1: __uint32_t) -> __uint32_t;
}
extern "C" {
    pub fn htons(arg1: __uint16_t) -> __uint16_t;
}
extern "C" {
    pub fn ntohl(arg1: __uint32_t) -> __uint32_t;
}
extern "C" {
    pub fn ntohs(arg1: __uint16_t) -> __uint16_t;
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct _cpuset {
    pub __bits: [::std::os::raw::c_long; 4usize],
}
#[test]
fn bindgen_test_layout__cpuset() {
    assert_eq!(::std::mem::size_of::<_cpuset>() , 32usize , concat ! (
               "Size of: " , stringify ! ( _cpuset ) ));
    assert_eq! (::std::mem::align_of::<_cpuset>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _cpuset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _cpuset ) ) . __bits as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _cpuset ) , "::" ,
                stringify ! ( __bits ) ));
}
impl Clone for _cpuset {
    fn clone(&self) -> Self { *self }
}
pub type cpuset_t = _cpuset;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ktr_entry {
    pub ktr_timestamp: u_int64_t,
    pub ktr_cpu: ::std::os::raw::c_int,
    pub ktr_line: ::std::os::raw::c_int,
    pub ktr_file: *const ::std::os::raw::c_char,
    pub ktr_desc: *const ::std::os::raw::c_char,
    pub ktr_thread: *mut thread,
    pub ktr_parms: [u_long; 6usize],
}
#[test]
fn bindgen_test_layout_ktr_entry() {
    assert_eq!(::std::mem::size_of::<ktr_entry>() , 88usize , concat ! (
               "Size of: " , stringify ! ( ktr_entry ) ));
    assert_eq! (::std::mem::align_of::<ktr_entry>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ktr_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ktr_entry ) ) . ktr_timestamp as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ktr_entry ) , "::" ,
                stringify ! ( ktr_timestamp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ktr_entry ) ) . ktr_cpu as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ktr_entry ) , "::" ,
                stringify ! ( ktr_cpu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ktr_entry ) ) . ktr_line as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( ktr_entry ) , "::" ,
                stringify ! ( ktr_line ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ktr_entry ) ) . ktr_file as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ktr_entry ) , "::" ,
                stringify ! ( ktr_file ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ktr_entry ) ) . ktr_desc as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ktr_entry ) , "::" ,
                stringify ! ( ktr_desc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ktr_entry ) ) . ktr_thread as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( ktr_entry ) , "::" ,
                stringify ! ( ktr_thread ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ktr_entry ) ) . ktr_parms as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( ktr_entry ) , "::" ,
                stringify ! ( ktr_parms ) ));
}
impl Clone for ktr_entry {
    fn clone(&self) -> Self { *self }
}
impl Default for ktr_entry {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
extern "C" {
    #[link_name = "ktr_cpumask"]
    pub static mut ktr_cpumask: cpuset_t;
}
extern "C" {
    #[link_name = "ktr_mask"]
    pub static mut ktr_mask: u64;
}
extern "C" {
    #[link_name = "ktr_entries"]
    pub static mut ktr_entries: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "ktr_verbose"]
    pub static mut ktr_verbose: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "ktr_idx"]
    pub static mut ktr_idx: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "ktr_buf"]
    pub static mut ktr_buf: *mut ktr_entry;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mtx {
    pub lock_object: lock_object,
    pub mtx_lock: usize,
}
#[test]
fn bindgen_test_layout_mtx() {
    assert_eq!(::std::mem::size_of::<mtx>() , 32usize , concat ! (
               "Size of: " , stringify ! ( mtx ) ));
    assert_eq! (::std::mem::align_of::<mtx>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( mtx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mtx ) ) . lock_object as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mtx ) , "::" ,
                stringify ! ( lock_object ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mtx ) ) . mtx_lock as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( mtx ) , "::" ,
                stringify ! ( mtx_lock ) ));
}
impl Clone for mtx {
    fn clone(&self) -> Self { *self }
}
impl Default for mtx {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct mtx_padalign {
    pub lock_object: lock_object,
    pub mtx_lock: usize,
    pub __bindgen_padding_0: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_mtx_padalign() {
    assert_eq!(::std::mem::size_of::<mtx_padalign>() , 64usize , concat ! (
               "Size of: " , stringify ! ( mtx_padalign ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mtx_padalign ) ) . lock_object as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mtx_padalign ) , "::" ,
                stringify ! ( lock_object ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mtx_padalign ) ) . mtx_lock as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( mtx_padalign ) , "::" ,
                stringify ! ( mtx_lock ) ));
}
impl Clone for mtx_padalign {
    fn clone(&self) -> Self { *self }
}
impl Default for mtx_padalign {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl ::std::fmt::Debug for mtx_padalign {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f , "mtx_padalign {{ lock_object: {:?}, mtx_lock: {:?} }}" ,
               self . lock_object , self . mtx_lock)
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sx {
    pub lock_object: lock_object,
    pub sx_lock: usize,
}
#[test]
fn bindgen_test_layout_sx() {
    assert_eq!(::std::mem::size_of::<sx>() , 32usize , concat ! (
               "Size of: " , stringify ! ( sx ) ));
    assert_eq! (::std::mem::align_of::<sx>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sx ) ) . lock_object as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sx ) , "::" , stringify
                ! ( lock_object ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sx ) ) . sx_lock as * const _ as usize }
                , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( sx ) , "::" , stringify
                ! ( sx_lock ) ));
}
impl Clone for sx {
    fn clone(&self) -> Self { *self }
}
impl Default for sx {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rmpriolist {
    pub lh_first: *mut rm_priotracker,
}
#[test]
fn bindgen_test_layout_rmpriolist() {
    assert_eq!(::std::mem::size_of::<rmpriolist>() , 8usize , concat ! (
               "Size of: " , stringify ! ( rmpriolist ) ));
    assert_eq! (::std::mem::align_of::<rmpriolist>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rmpriolist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmpriolist ) ) . lh_first as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rmpriolist ) , "::" ,
                stringify ! ( lh_first ) ));
}
impl Clone for rmpriolist {
    fn clone(&self) -> Self { *self }
}
impl Default for rmpriolist {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rm_queue {
    pub rmq_next: *mut rm_queue,
    pub rmq_prev: *mut rm_queue,
}
#[test]
fn bindgen_test_layout_rm_queue() {
    assert_eq!(::std::mem::size_of::<rm_queue>() , 16usize , concat ! (
               "Size of: " , stringify ! ( rm_queue ) ));
    assert_eq! (::std::mem::align_of::<rm_queue>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rm_queue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rm_queue ) ) . rmq_next as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rm_queue ) , "::" ,
                stringify ! ( rmq_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rm_queue ) ) . rmq_prev as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rm_queue ) , "::" ,
                stringify ! ( rmq_prev ) ));
}
impl Clone for rm_queue {
    fn clone(&self) -> Self { *self }
}
impl Default for rm_queue {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct rmlock {
    pub lock_object: lock_object,
    pub rm_writecpus: cpuset_t,
    pub rm_activeReaders: rmlock__bindgen_ty_1,
    pub _rm_lock: rmlock__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rmlock__bindgen_ty_1 {
    pub lh_first: *mut rm_priotracker,
}
#[test]
fn bindgen_test_layout_rmlock__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rmlock__bindgen_ty_1>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( rmlock__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<rmlock__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rmlock__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmlock__bindgen_ty_1 ) ) . lh_first as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rmlock__bindgen_ty_1 )
                , "::" , stringify ! ( lh_first ) ));
}
impl Clone for rmlock__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for rmlock__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub union rmlock__bindgen_ty_2 {
    pub _rm_wlock_object: lock_object,
    pub _rm_lock_mtx: mtx,
    pub _rm_lock_sx: sx,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_rmlock__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<rmlock__bindgen_ty_2>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( rmlock__bindgen_ty_2 )
               ));
    assert_eq! (::std::mem::align_of::<rmlock__bindgen_ty_2>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rmlock__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmlock__bindgen_ty_2 ) ) .
                _rm_wlock_object as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rmlock__bindgen_ty_2 )
                , "::" , stringify ! ( _rm_wlock_object ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmlock__bindgen_ty_2 ) ) . _rm_lock_mtx
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rmlock__bindgen_ty_2 )
                , "::" , stringify ! ( _rm_lock_mtx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmlock__bindgen_ty_2 ) ) . _rm_lock_sx as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rmlock__bindgen_ty_2 )
                , "::" , stringify ! ( _rm_lock_sx ) ));
}
impl Clone for rmlock__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for rmlock__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl ::std::fmt::Debug for rmlock__bindgen_ty_2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f , "rmlock__bindgen_ty_2 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_rmlock() {
    assert_eq!(::std::mem::size_of::<rmlock>() , 96usize , concat ! (
               "Size of: " , stringify ! ( rmlock ) ));
    assert_eq! (::std::mem::align_of::<rmlock>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rmlock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmlock ) ) . lock_object as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rmlock ) , "::" ,
                stringify ! ( lock_object ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmlock ) ) . rm_writecpus as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rmlock ) , "::" ,
                stringify ! ( rm_writecpus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmlock ) ) . rm_activeReaders as * const
                _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( rmlock ) , "::" ,
                stringify ! ( rm_activeReaders ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmlock ) ) . _rm_lock as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( rmlock ) , "::" ,
                stringify ! ( _rm_lock ) ));
}
impl Clone for rmlock {
    fn clone(&self) -> Self { *self }
}
impl Default for rmlock {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl ::std::fmt::Debug for rmlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f ,
               "rmlock {{ lock_object: {:?}, rm_writecpus: {:?}, rm_activeReaders: {:?}, _rm_lock: {:?} }}"
               , self . lock_object , self . rm_writecpus , self .
               rm_activeReaders , self . _rm_lock)
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rm_priotracker {
    pub rmp_cpuQueue: rm_queue,
    pub rmp_rmlock: *mut rmlock,
    pub rmp_thread: *mut thread,
    pub rmp_flags: ::std::os::raw::c_int,
    pub rmp_qentry: rm_priotracker__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rm_priotracker__bindgen_ty_1 {
    pub le_next: *mut rm_priotracker,
    pub le_prev: *mut *mut rm_priotracker,
}
#[test]
fn bindgen_test_layout_rm_priotracker__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rm_priotracker__bindgen_ty_1>() , 16usize
               , concat ! (
               "Size of: " , stringify ! ( rm_priotracker__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<rm_priotracker__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( rm_priotracker__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rm_priotracker__bindgen_ty_1 ) ) .
                le_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rm_priotracker__bindgen_ty_1 ) , "::" , stringify ! ( le_next
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rm_priotracker__bindgen_ty_1 ) ) .
                le_prev as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                rm_priotracker__bindgen_ty_1 ) , "::" , stringify ! ( le_prev
                ) ));
}
impl Clone for rm_priotracker__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for rm_priotracker__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_rm_priotracker() {
    assert_eq!(::std::mem::size_of::<rm_priotracker>() , 56usize , concat ! (
               "Size of: " , stringify ! ( rm_priotracker ) ));
    assert_eq! (::std::mem::align_of::<rm_priotracker>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rm_priotracker ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rm_priotracker ) ) . rmp_cpuQueue as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rm_priotracker ) , "::"
                , stringify ! ( rmp_cpuQueue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rm_priotracker ) ) . rmp_rmlock as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rm_priotracker ) , "::"
                , stringify ! ( rmp_rmlock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rm_priotracker ) ) . rmp_thread as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rm_priotracker ) , "::"
                , stringify ! ( rmp_thread ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rm_priotracker ) ) . rmp_flags as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rm_priotracker ) , "::"
                , stringify ! ( rmp_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rm_priotracker ) ) . rmp_qentry as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rm_priotracker ) , "::"
                , stringify ! ( rmp_qentry ) ));
}
impl Clone for rm_priotracker {
    fn clone(&self) -> Self { *self }
}
impl Default for rm_priotracker {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct rusage {
    pub ru_utime: timeval,
    pub ru_stime: timeval,
    pub ru_maxrss: ::std::os::raw::c_long,
    pub ru_ixrss: ::std::os::raw::c_long,
    pub ru_idrss: ::std::os::raw::c_long,
    pub ru_isrss: ::std::os::raw::c_long,
    pub ru_minflt: ::std::os::raw::c_long,
    pub ru_majflt: ::std::os::raw::c_long,
    pub ru_nswap: ::std::os::raw::c_long,
    pub ru_inblock: ::std::os::raw::c_long,
    pub ru_oublock: ::std::os::raw::c_long,
    pub ru_msgsnd: ::std::os::raw::c_long,
    pub ru_msgrcv: ::std::os::raw::c_long,
    pub ru_nsignals: ::std::os::raw::c_long,
    pub ru_nvcsw: ::std::os::raw::c_long,
    pub ru_nivcsw: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_rusage() {
    assert_eq!(::std::mem::size_of::<rusage>() , 144usize , concat ! (
               "Size of: " , stringify ! ( rusage ) ));
    assert_eq! (::std::mem::align_of::<rusage>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rusage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_utime as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_utime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_stime as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_stime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_maxrss as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_maxrss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_ixrss as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_ixrss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_idrss as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_idrss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_isrss as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_isrss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_minflt as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_minflt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_majflt as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_majflt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_nswap as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_nswap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_inblock as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_inblock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_oublock as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_oublock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_msgsnd as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_msgsnd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_msgrcv as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_msgrcv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_nsignals as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_nsignals ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_nvcsw as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_nvcsw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_nivcsw as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_nivcsw ) ));
}
impl Clone for rusage {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct __wrusage {
    pub wru_self: rusage,
    pub wru_children: rusage,
}
#[test]
fn bindgen_test_layout___wrusage() {
    assert_eq!(::std::mem::size_of::<__wrusage>() , 288usize , concat ! (
               "Size of: " , stringify ! ( __wrusage ) ));
    assert_eq! (::std::mem::align_of::<__wrusage>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __wrusage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __wrusage ) ) . wru_self as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __wrusage ) , "::" ,
                stringify ! ( wru_self ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __wrusage ) ) . wru_children as * const _
                as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( __wrusage ) , "::" ,
                stringify ! ( wru_children ) ));
}
impl Clone for __wrusage {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct rlimit {
    pub rlim_cur: rlim_t,
    pub rlim_max: rlim_t,
}
#[test]
fn bindgen_test_layout_rlimit() {
    assert_eq!(::std::mem::size_of::<rlimit>() , 16usize , concat ! (
               "Size of: " , stringify ! ( rlimit ) ));
    assert_eq! (::std::mem::align_of::<rlimit>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rlimit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rlimit ) ) . rlim_cur as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rlimit ) , "::" ,
                stringify ! ( rlim_cur ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rlimit ) ) . rlim_max as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rlimit ) , "::" ,
                stringify ! ( rlim_max ) ));
}
impl Clone for rlimit {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct orlimit {
    pub rlim_cur: __int32_t,
    pub rlim_max: __int32_t,
}
#[test]
fn bindgen_test_layout_orlimit() {
    assert_eq!(::std::mem::size_of::<orlimit>() , 8usize , concat ! (
               "Size of: " , stringify ! ( orlimit ) ));
    assert_eq! (::std::mem::align_of::<orlimit>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( orlimit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const orlimit ) ) . rlim_cur as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( orlimit ) , "::" ,
                stringify ! ( rlim_cur ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const orlimit ) ) . rlim_max as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( orlimit ) , "::" ,
                stringify ! ( rlim_max ) ));
}
impl Clone for orlimit {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct loadavg {
    pub ldavg: [__fixpt_t; 3usize],
    pub fscale: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_loadavg() {
    assert_eq!(::std::mem::size_of::<loadavg>() , 24usize , concat ! (
               "Size of: " , stringify ! ( loadavg ) ));
    assert_eq! (::std::mem::align_of::<loadavg>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( loadavg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const loadavg ) ) . ldavg as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( loadavg ) , "::" ,
                stringify ! ( ldavg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const loadavg ) ) . fscale as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( loadavg ) , "::" ,
                stringify ! ( fscale ) ));
}
impl Clone for loadavg {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "averunnable"]
    pub static mut averunnable: loadavg;
}
extern "C" {
    pub fn read_cpu_time(cp_time: *mut ::std::os::raw::c_long);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcb {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "__start_set_pcpu"]
    pub static mut __start_set_pcpu: *mut usize;
}
extern "C" {
    #[link_name = "__stop_set_pcpu"]
    pub static mut __stop_set_pcpu: *mut usize;
}
extern "C" {
    #[link_name = "dpcpu_off"]
    pub static mut dpcpu_off: [usize; 0usize];
}
#[repr(C)]
#[derive(Copy)]
pub struct pcpu {
    pub pc_curthread: *mut thread,
    pub pc_idlethread: *mut thread,
    pub pc_fpcurthread: *mut thread,
    pub pc_deadthread: *mut thread,
    pub pc_curpcb: *mut pcb,
    pub pc_switchtime: u64,
    pub pc_switchticks: ::std::os::raw::c_int,
    pub pc_cpuid: u_int,
    pub pc_allcpu: pcpu__bindgen_ty_1,
    pub pc_spinlocks: *mut lock_list_entry,
    pub pc_cp_time: [::std::os::raw::c_long; 5usize],
    pub pc_device: *mut device,
    pub pc_netisr: *mut ::std::os::raw::c_void,
    pub pc_unused1: ::std::os::raw::c_int,
    pub pc_domain: ::std::os::raw::c_int,
    pub pc_rm_queue: rm_queue,
    pub pc_dynamic: usize,
    pub pc_early_dummy_counter: u64,
    pub __bindgen_padding_0: [u8; 88usize],
    pub pc_monitorbuf: [::std::os::raw::c_char; 128usize],
    pub pc_prvspace: *mut pcpu,
    pub pc_curpmap: *mut pmap,
    pub pc_tssp: *mut amd64tss,
    pub pc_commontssp: *mut amd64tss,
    pub pc_kcr3: u64,
    pub pc_ucr3: u64,
    pub pc_rsp0: register_t,
    pub pc_scratch_rsp: register_t,
    pub pc_scratch_rax: register_t,
    pub pc_apic_id: u_int,
    pub pc_acpi_id: u_int,
    pub pc_fs32p: *mut user_segment_descriptor,
    pub pc_gs32p: *mut user_segment_descriptor,
    pub pc_ldt: *mut system_segment_descriptor,
    pub pc_tss: *mut system_segment_descriptor,
    pub pc_pm_save_cnt: u64,
    pub pc_cmci_mask: u_int,
    pub pc_dbreg: [u64; 16usize],
    pub pc_pti_stack: [u64; 16usize],
    pub pc_dbreg_cmd: ::std::os::raw::c_int,
    pub pc_vcpu_id: u_int,
    pub pc_pcid_next: u32,
    pub pc_pcid_gen: u32,
    pub pc_smp_tlb_done: u32,
    pub __pad: [::std::os::raw::c_char; 232usize],
    pub __bindgen_padding_1: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pcpu__bindgen_ty_1 {
    pub stqe_next: *mut pcpu,
}
#[test]
fn bindgen_test_layout_pcpu__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<pcpu__bindgen_ty_1>() , 8usize , concat !
               ( "Size of: " , stringify ! ( pcpu__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<pcpu__bindgen_ty_1>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( pcpu__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu__bindgen_ty_1 ) ) . stqe_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu__bindgen_ty_1 ) ,
                "::" , stringify ! ( stqe_next ) ));
}
impl Clone for pcpu__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for pcpu__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_pcpu() {
    assert_eq!(::std::mem::size_of::<pcpu>() , 1024usize , concat ! (
               "Size of: " , stringify ! ( pcpu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_curthread as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_curthread ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_idlethread as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_idlethread ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_fpcurthread as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_fpcurthread ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_deadthread as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_deadthread ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_curpcb as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_curpcb ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_switchtime as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_switchtime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_switchticks as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_switchticks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_cpuid as * const _ as usize
                } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_cpuid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_allcpu as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_allcpu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_spinlocks as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_spinlocks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_cp_time as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_cp_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_device as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_device ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_netisr as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_netisr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_unused1 as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_unused1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_domain as * const _ as
                usize } , 132usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_domain ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_rm_queue as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_rm_queue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_dynamic as * const _ as
                usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_dynamic ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_early_dummy_counter as *
                const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_early_dummy_counter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_monitorbuf as * const _ as
                usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_monitorbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_prvspace as * const _ as
                usize } , 384usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_prvspace ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_curpmap as * const _ as
                usize } , 392usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_curpmap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_tssp as * const _ as usize
                } , 400usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_tssp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_commontssp as * const _ as
                usize } , 408usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_commontssp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_kcr3 as * const _ as usize
                } , 416usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_kcr3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_ucr3 as * const _ as usize
                } , 424usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_ucr3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_rsp0 as * const _ as usize
                } , 432usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_rsp0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_scratch_rsp as * const _ as
                usize } , 440usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_scratch_rsp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_scratch_rax as * const _ as
                usize } , 448usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_scratch_rax ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_apic_id as * const _ as
                usize } , 456usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_apic_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_acpi_id as * const _ as
                usize } , 460usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_acpi_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_fs32p as * const _ as usize
                } , 464usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_fs32p ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_gs32p as * const _ as usize
                } , 472usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_gs32p ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_ldt as * const _ as usize }
                , 480usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_ldt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_tss as * const _ as usize }
                , 488usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_tss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_pm_save_cnt as * const _ as
                usize } , 496usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_pm_save_cnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_cmci_mask as * const _ as
                usize } , 504usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_cmci_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_dbreg as * const _ as usize
                } , 512usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_dbreg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_pti_stack as * const _ as
                usize } , 640usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_pti_stack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_dbreg_cmd as * const _ as
                usize } , 768usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_dbreg_cmd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_vcpu_id as * const _ as
                usize } , 772usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_vcpu_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_pcid_next as * const _ as
                usize } , 776usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_pcid_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_pcid_gen as * const _ as
                usize } , 780usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_pcid_gen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_smp_tlb_done as * const _
                as usize } , 784usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_smp_tlb_done ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . __pad as * const _ as usize }
                , 788usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( __pad ) ));
}
impl Clone for pcpu {
    fn clone(&self) -> Self { *self }
}
impl Default for pcpu {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl ::std::fmt::Debug for pcpu {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f ,
               "pcpu {{ pc_curthread: {:?}, pc_idlethread: {:?}, pc_fpcurthread: {:?}, pc_deadthread: {:?}, pc_curpcb: {:?}, pc_switchtime: {:?}, pc_switchticks: {:?}, pc_cpuid: {:?}, pc_allcpu: {:?}, pc_spinlocks: {:?}, pc_cp_time: {:?}, pc_device: {:?}, pc_netisr: {:?}, pc_unused1: {:?}, pc_domain: {:?}, pc_rm_queue: {:?}, pc_dynamic: {:?}, pc_early_dummy_counter: {:?}, pc_monitorbuf: [{}], pc_prvspace: {:?}, pc_curpmap: {:?}, pc_tssp: {:?}, pc_commontssp: {:?}, pc_kcr3: {:?}, pc_ucr3: {:?}, pc_rsp0: {:?}, pc_scratch_rsp: {:?}, pc_scratch_rax: {:?}, pc_apic_id: {:?}, pc_acpi_id: {:?}, pc_fs32p: {:?}, pc_gs32p: {:?}, pc_ldt: {:?}, pc_tss: {:?}, pc_pm_save_cnt: {:?}, pc_cmci_mask: {:?}, pc_dbreg: {:?}, pc_pti_stack: {:?}, pc_dbreg_cmd: {:?}, pc_vcpu_id: {:?}, pc_pcid_next: {:?}, pc_pcid_gen: {:?}, pc_smp_tlb_done: {:?}, __pad: [{}] }}"
               , self . pc_curthread , self . pc_idlethread , self .
               pc_fpcurthread , self . pc_deadthread , self . pc_curpcb , self
               . pc_switchtime , self . pc_switchticks , self . pc_cpuid ,
               self . pc_allcpu , self . pc_spinlocks , self . pc_cp_time ,
               self . pc_device , self . pc_netisr , self . pc_unused1 , self
               . pc_domain , self . pc_rm_queue , self . pc_dynamic , self .
               pc_early_dummy_counter , self . pc_monitorbuf . iter (  ) .
               enumerate (  ) . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ) , self . pc_prvspace , self . pc_curpmap , self .
               pc_tssp , self . pc_commontssp , self . pc_kcr3 , self .
               pc_ucr3 , self . pc_rsp0 , self . pc_scratch_rsp , self .
               pc_scratch_rax , self . pc_apic_id , self . pc_acpi_id , self .
               pc_fs32p , self . pc_gs32p , self . pc_ldt , self . pc_tss ,
               self . pc_pm_save_cnt , self . pc_cmci_mask , self . pc_dbreg ,
               self . pc_pti_stack , self . pc_dbreg_cmd , self . pc_vcpu_id ,
               self . pc_pcid_next , self . pc_pcid_gen , self .
               pc_smp_tlb_done , self . __pad . iter (  ) . enumerate (  ) .
               map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ))
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cpuhead {
    pub stqh_first: *mut pcpu,
    pub stqh_last: *mut *mut pcpu,
}
#[test]
fn bindgen_test_layout_cpuhead() {
    assert_eq!(::std::mem::size_of::<cpuhead>() , 16usize , concat ! (
               "Size of: " , stringify ! ( cpuhead ) ));
    assert_eq! (::std::mem::align_of::<cpuhead>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( cpuhead ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuhead ) ) . stqh_first as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuhead ) , "::" ,
                stringify ! ( stqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuhead ) ) . stqh_last as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuhead ) , "::" ,
                stringify ! ( stqh_last ) ));
}
impl Clone for cpuhead {
    fn clone(&self) -> Self { *self }
}
impl Default for cpuhead {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
extern "C" {
    #[link_name = "cpuhead"]
    pub static mut cpuhead: cpuhead;
}
extern "C" {
    #[link_name = "cpuid_to_pcpu"]
    pub static mut cpuid_to_pcpu: [*mut pcpu; 0usize];
}
extern "C" {
    pub fn cpu_pcpu_init(pcpu: *mut pcpu, cpuid: ::std::os::raw::c_int,
                         size: usize);
}
extern "C" {
    pub fn db_show_mdpcpu(pcpu: *mut pcpu);
}
extern "C" {
    pub fn dpcpu_alloc(size: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn dpcpu_copy(s: *mut ::std::os::raw::c_void,
                      size: ::std::os::raw::c_int);
}
extern "C" {
    pub fn dpcpu_free(s: *mut ::std::os::raw::c_void,
                      size: ::std::os::raw::c_int);
}
extern "C" {
    pub fn dpcpu_init(dpcpu: *mut ::std::os::raw::c_void,
                      cpuid: ::std::os::raw::c_int);
}
extern "C" {
    pub fn pcpu_destroy(pcpu: *mut pcpu);
}
extern "C" {
    pub fn pcpu_find(cpuid: u_int) -> *mut pcpu;
}
extern "C" {
    pub fn pcpu_init(pcpu: *mut pcpu, cpuid: ::std::os::raw::c_int,
                     size: usize);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lock_profile_object {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lpohead {
    pub lh_first: *mut lock_profile_object,
}
#[test]
fn bindgen_test_layout_lpohead() {
    assert_eq!(::std::mem::size_of::<lpohead>() , 8usize , concat ! (
               "Size of: " , stringify ! ( lpohead ) ));
    assert_eq! (::std::mem::align_of::<lpohead>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lpohead ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lpohead ) ) . lh_first as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lpohead ) , "::" ,
                stringify ! ( lh_first ) ));
}
impl Clone for lpohead {
    fn clone(&self) -> Self { *self }
}
impl Default for lpohead {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
extern "C" {
    #[link_name = "sdt_probes_enabled"]
    pub static mut sdt_probes_enabled: bool_;
}
pub type sdt_probe_func_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: u32, arg0: usize,
                                               arg1: usize, arg2: usize,
                                               arg3: usize, arg4: usize)>;
extern "C" {
    #[link_name = "sdt_probe_func"]
    pub static mut sdt_probe_func: sdt_probe_func_t;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sdt_probe {
    pub version: ::std::os::raw::c_int,
    pub prov: *mut sdt_provider,
    pub probe_entry: sdt_probe__bindgen_ty_1,
    pub argtype_list: sdt_probe__bindgen_ty_2,
    pub mod_: *const ::std::os::raw::c_char,
    pub func: *const ::std::os::raw::c_char,
    pub name: *const ::std::os::raw::c_char,
    pub id: id_t,
    pub n_args: ::std::os::raw::c_int,
    pub sdtp_lf: *mut linker_file,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sdt_probe__bindgen_ty_1 {
    pub tqe_next: *mut sdt_probe,
    pub tqe_prev: *mut *mut sdt_probe,
}
#[test]
fn bindgen_test_layout_sdt_probe__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<sdt_probe__bindgen_ty_1>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( sdt_probe__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<sdt_probe__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( sdt_probe__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe__bindgen_ty_1 ) ) . tqe_next as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe__bindgen_ty_1
                ) , "::" , stringify ! ( tqe_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe__bindgen_ty_1 ) ) . tqe_prev as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe__bindgen_ty_1
                ) , "::" , stringify ! ( tqe_prev ) ));
}
impl Clone for sdt_probe__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for sdt_probe__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sdt_probe__bindgen_ty_2 {
    pub tqh_first: *mut sdt_argtype,
    pub tqh_last: *mut *mut sdt_argtype,
}
#[test]
fn bindgen_test_layout_sdt_probe__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<sdt_probe__bindgen_ty_2>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( sdt_probe__bindgen_ty_2 ) ));
    assert_eq! (::std::mem::align_of::<sdt_probe__bindgen_ty_2>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( sdt_probe__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe__bindgen_ty_2 ) ) . tqh_first
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe__bindgen_ty_2
                ) , "::" , stringify ! ( tqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe__bindgen_ty_2 ) ) . tqh_last as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe__bindgen_ty_2
                ) , "::" , stringify ! ( tqh_last ) ));
}
impl Clone for sdt_probe__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for sdt_probe__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_sdt_probe() {
    assert_eq!(::std::mem::size_of::<sdt_probe>() , 96usize , concat ! (
               "Size of: " , stringify ! ( sdt_probe ) ));
    assert_eq! (::std::mem::align_of::<sdt_probe>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sdt_probe ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . version as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . prov as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( prov ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . probe_entry as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( probe_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . argtype_list as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( argtype_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . mod_ as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( mod_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . func as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . name as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . id as * const _ as usize
                } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . n_args as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( n_args ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . sdtp_lf as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( sdtp_lf ) ));
}
impl Clone for sdt_probe {
    fn clone(&self) -> Self { *self }
}
impl Default for sdt_probe {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sdt_provider {
    pub name: *mut ::std::os::raw::c_char,
    pub prov_entry: sdt_provider__bindgen_ty_1,
    pub id: usize,
    pub sdt_refs: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sdt_provider__bindgen_ty_1 {
    pub tqe_next: *mut sdt_provider,
    pub tqe_prev: *mut *mut sdt_provider,
}
#[test]
fn bindgen_test_layout_sdt_provider__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<sdt_provider__bindgen_ty_1>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( sdt_provider__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<sdt_provider__bindgen_ty_1>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( sdt_provider__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_provider__bindgen_ty_1 ) ) . tqe_next
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                sdt_provider__bindgen_ty_1 ) , "::" , stringify ! ( tqe_next )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_provider__bindgen_ty_1 ) ) . tqe_prev
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                sdt_provider__bindgen_ty_1 ) , "::" , stringify ! ( tqe_prev )
                ));
}
impl Clone for sdt_provider__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for sdt_provider__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_sdt_provider() {
    assert_eq!(::std::mem::size_of::<sdt_provider>() , 40usize , concat ! (
               "Size of: " , stringify ! ( sdt_provider ) ));
    assert_eq! (::std::mem::align_of::<sdt_provider>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sdt_provider ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_provider ) ) . name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_provider ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_provider ) ) . prov_entry as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_provider ) , "::" ,
                stringify ! ( prov_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_provider ) ) . id as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_provider ) , "::" ,
                stringify ! ( id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_provider ) ) . sdt_refs as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_provider ) , "::" ,
                stringify ! ( sdt_refs ) ));
}
impl Clone for sdt_provider {
    fn clone(&self) -> Self { *self }
}
impl Default for sdt_provider {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct linker_file {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sdt_argtype {
    pub ndx: ::std::os::raw::c_int,
    pub type_: *const ::std::os::raw::c_char,
    pub xtype: *const ::std::os::raw::c_char,
    pub argtype_entry: sdt_argtype__bindgen_ty_1,
    pub probe: *mut sdt_probe,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sdt_argtype__bindgen_ty_1 {
    pub tqe_next: *mut sdt_argtype,
    pub tqe_prev: *mut *mut sdt_argtype,
}
#[test]
fn bindgen_test_layout_sdt_argtype__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<sdt_argtype__bindgen_ty_1>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( sdt_argtype__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<sdt_argtype__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( sdt_argtype__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_argtype__bindgen_ty_1 ) ) . tqe_next
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                sdt_argtype__bindgen_ty_1 ) , "::" , stringify ! ( tqe_next )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_argtype__bindgen_ty_1 ) ) . tqe_prev
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                sdt_argtype__bindgen_ty_1 ) , "::" , stringify ! ( tqe_prev )
                ));
}
impl Clone for sdt_argtype__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for sdt_argtype__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_sdt_argtype() {
    assert_eq!(::std::mem::size_of::<sdt_argtype>() , 48usize , concat ! (
               "Size of: " , stringify ! ( sdt_argtype ) ));
    assert_eq! (::std::mem::align_of::<sdt_argtype>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sdt_argtype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_argtype ) ) . ndx as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_argtype ) , "::" ,
                stringify ! ( ndx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_argtype ) ) . type_ as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_argtype ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_argtype ) ) . xtype as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_argtype ) , "::" ,
                stringify ! ( xtype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_argtype ) ) . argtype_entry as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_argtype ) , "::" ,
                stringify ! ( argtype_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_argtype ) ) . probe as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_argtype ) , "::" ,
                stringify ! ( probe ) ));
}
impl Clone for sdt_argtype {
    fn clone(&self) -> Self { *self }
}
impl Default for sdt_argtype {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
extern "C" {
    pub fn sdt_probe_stub(arg1: u32, arg2: usize, arg3: usize, arg4: usize,
                          arg5: usize, arg6: usize);
}
extern "C" {
    #[link_name = "lockstat_enabled"]
    pub static mut lockstat_enabled: ::std::os::raw::c_int;
}
extern "C" {
    pub fn atomic_cmpset_char(dst: *mut u_char, expect: u_char, src: u_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atomic_cmpset_short(dst: *mut u_short, expect: u_short,
                               src: u_short) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atomic_cmpset_int(dst: *mut u_int, expect: u_int, src: u_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atomic_cmpset_long(dst: *mut u_long, expect: u_long, src: u_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atomic_fcmpset_char(dst: *mut u_char, expect: *mut u_char,
                               src: u_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atomic_fcmpset_short(dst: *mut u_short, expect: *mut u_short,
                                src: u_short) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atomic_fcmpset_int(dst: *mut u_int, expect: *mut u_int, src: u_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atomic_fcmpset_long(dst: *mut u_long, expect: *mut u_long,
                               src: u_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atomic_fetchadd_int(p: *mut u_int, v: u_int) -> u_int;
}
extern "C" {
    pub fn atomic_fetchadd_long(p: *mut u_long, v: u_long) -> u_long;
}
extern "C" {
    pub fn atomic_testandset_int(p: *mut u_int, v: u_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atomic_testandset_long(p: *mut u_long, v: u_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atomic_testandclear_int(p: *mut u_int, v: u_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atomic_testandclear_long(p: *mut u_long, v: u_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atomic_thread_fence_acq();
}
extern "C" {
    pub fn atomic_thread_fence_acq_rel();
}
extern "C" {
    pub fn atomic_thread_fence_rel();
}
extern "C" {
    pub fn atomic_thread_fence_seq_cst();
}
extern "C" {
    pub fn atomic_set_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_set_barr_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_clear_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_clear_barr_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_add_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_add_barr_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_subtract_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_subtract_barr_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_set_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_set_barr_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_clear_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_clear_barr_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_add_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_add_barr_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_subtract_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_subtract_barr_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_set_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_set_barr_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_clear_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_clear_barr_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_add_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_add_barr_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_subtract_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_subtract_barr_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_set_long(p: *mut u_long, v: u_long);
}
extern "C" {
    pub fn atomic_set_barr_long(p: *mut u_long, v: u_long);
}
extern "C" {
    pub fn atomic_clear_long(p: *mut u_long, v: u_long);
}
extern "C" {
    pub fn atomic_clear_barr_long(p: *mut u_long, v: u_long);
}
extern "C" {
    pub fn atomic_add_long(p: *mut u_long, v: u_long);
}
extern "C" {
    pub fn atomic_add_barr_long(p: *mut u_long, v: u_long);
}
extern "C" {
    pub fn atomic_subtract_long(p: *mut u_long, v: u_long);
}
extern "C" {
    pub fn atomic_subtract_barr_long(p: *mut u_long, v: u_long);
}
extern "C" {
    pub fn atomic_load_acq_char(p: *mut u_char) -> u_char;
}
extern "C" {
    pub fn atomic_store_rel_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_load_acq_short(p: *mut u_short) -> u_short;
}
extern "C" {
    pub fn atomic_store_rel_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_load_acq_int(p: *mut u_int) -> u_int;
}
extern "C" {
    pub fn atomic_store_rel_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_load_acq_long(p: *mut u_long) -> u_long;
}
extern "C" {
    pub fn atomic_store_rel_long(p: *mut u_long, v: u_long);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct region_descriptor {
    _unused: [u8; 0],
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy)]
pub struct invpcid_descr {
    pub _bitfield_1: u64,
    pub addr: u64,
}
#[test]
fn bindgen_test_layout_invpcid_descr() {
    assert_eq!(::std::mem::size_of::<invpcid_descr>() , 16usize , concat ! (
               "Size of: " , stringify ! ( invpcid_descr ) ));
    assert_eq! (::std::mem::align_of::<invpcid_descr>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( invpcid_descr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const invpcid_descr ) ) . addr as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( invpcid_descr ) , "::"
                , stringify ! ( addr ) ));
}
impl Clone for invpcid_descr {
    fn clone(&self) -> Self { *self }
}
impl invpcid_descr {
    #[inline]
    pub fn pcid(&self) -> u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 4095u64 as u64;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_pcid(&mut self, val: u64) {
        let mask = 4095u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn pad(&self) -> u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 18446744073709547520u64 as u64;
        let val = (unit_field_val & mask) >> 12usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_pad(&mut self, val: u64) {
        let mask = 18446744073709547520u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 12usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(pcid: u64, pad: u64) -> u64 {
        ({ ({ 0 } | ((pcid as u64 as u64) << 0usize) & (4095u64 as u64)) } |
             ((pad as u64 as u64) << 12usize) &
                 (18446744073709547520u64 as u64))
    }
}
pub const SGX_ECREATE: _bindgen_ty_1 = _bindgen_ty_1::SGX_ECREATE;
pub const SGX_EADD: _bindgen_ty_1 = _bindgen_ty_1::SGX_EADD;
pub const SGX_EINIT: _bindgen_ty_1 = _bindgen_ty_1::SGX_EINIT;
pub const SGX_EREMOVE: _bindgen_ty_1 = _bindgen_ty_1::SGX_EREMOVE;
pub const SGX_EDGBRD: _bindgen_ty_1 = _bindgen_ty_1::SGX_EDGBRD;
pub const SGX_EDGBWR: _bindgen_ty_1 = _bindgen_ty_1::SGX_EDGBWR;
pub const SGX_EEXTEND: _bindgen_ty_1 = _bindgen_ty_1::SGX_EEXTEND;
pub const SGX_ELDU: _bindgen_ty_1 = _bindgen_ty_1::SGX_ELDU;
pub const SGX_EBLOCK: _bindgen_ty_1 = _bindgen_ty_1::SGX_EBLOCK;
pub const SGX_EPA: _bindgen_ty_1 = _bindgen_ty_1::SGX_EPA;
pub const SGX_EWB: _bindgen_ty_1 = _bindgen_ty_1::SGX_EWB;
pub const SGX_ETRACK: _bindgen_ty_1 = _bindgen_ty_1::SGX_ETRACK;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_1 {
    SGX_ECREATE = 0,
    SGX_EADD = 1,
    SGX_EINIT = 2,
    SGX_EREMOVE = 3,
    SGX_EDGBRD = 4,
    SGX_EDGBWR = 5,
    SGX_EEXTEND = 6,
    SGX_ELDU = 8,
    SGX_EBLOCK = 9,
    SGX_EPA = 10,
    SGX_EWB = 11,
    SGX_ETRACK = 12,
}
pub const SGX_PT_SECS: _bindgen_ty_2 = _bindgen_ty_2::SGX_PT_SECS;
pub const SGX_PT_TCS: _bindgen_ty_2 = _bindgen_ty_2::SGX_PT_TCS;
pub const SGX_PT_REG: _bindgen_ty_2 = _bindgen_ty_2::SGX_PT_REG;
pub const SGX_PT_VA: _bindgen_ty_2 = _bindgen_ty_2::SGX_PT_VA;
pub const SGX_PT_TRIM: _bindgen_ty_2 = _bindgen_ty_2::SGX_PT_TRIM;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_2 {
    SGX_PT_SECS = 0,
    SGX_PT_TCS = 1,
    SGX_PT_REG = 2,
    SGX_PT_VA = 3,
    SGX_PT_TRIM = 4,
}
extern "C" {
    pub fn sgx_encls(eax: u32, rbx: u64, rcx: u64, rdx: u64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn reset_dbregs();
}
extern "C" {
    pub fn rdmsr_safe(msr: u_int, val: *mut u64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wrmsr_safe(msr: u_int, newval: u64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mtx_init(c: *mut usize, name: *const ::std::os::raw::c_char,
                     type_: *const ::std::os::raw::c_char,
                     opts: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _mtx_destroy(c: *mut usize);
}
extern "C" {
    pub fn mtx_sysinit(arg: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _mtx_trylock_flags_int(m: *mut mtx, opts: ::std::os::raw::c_int,
                                  file: *const ::std::os::raw::c_char,
                                  line: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mtx_trylock_flags_(c: *mut usize, opts: ::std::os::raw::c_int,
                               file: *const ::std::os::raw::c_char,
                               line: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mutex_init();
}
extern "C" {
    pub fn __mtx_lock_sleep(c: *mut usize, v: usize,
                            opts: ::std::os::raw::c_int,
                            file: *const ::std::os::raw::c_char,
                            line: ::std::os::raw::c_int);
}
extern "C" {
    pub fn __mtx_unlock_sleep(c: *mut usize, v: usize,
                              opts: ::std::os::raw::c_int,
                              file: *const ::std::os::raw::c_char,
                              line: ::std::os::raw::c_int);
}
extern "C" {
    pub fn __mtx_lock_flags(c: *mut usize, opts: ::std::os::raw::c_int,
                            file: *const ::std::os::raw::c_char,
                            line: ::std::os::raw::c_int);
}
extern "C" {
    pub fn __mtx_unlock_flags(c: *mut usize, opts: ::std::os::raw::c_int,
                              file: *const ::std::os::raw::c_char,
                              line: ::std::os::raw::c_int);
}
extern "C" {
    pub fn __mtx_lock_spin_flags(c: *mut usize, opts: ::std::os::raw::c_int,
                                 file: *const ::std::os::raw::c_char,
                                 line: ::std::os::raw::c_int);
}
extern "C" {
    pub fn __mtx_trylock_spin_flags(c: *mut usize,
                                    opts: ::std::os::raw::c_int,
                                    file: *const ::std::os::raw::c_char,
                                    line: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __mtx_unlock_spin_flags(c: *mut usize, opts: ::std::os::raw::c_int,
                                   file: *const ::std::os::raw::c_char,
                                   line: ::std::os::raw::c_int);
}
extern "C" {
    pub fn thread_lock_flags_(arg1: *mut thread, arg2: ::std::os::raw::c_int,
                              arg3: *const ::std::os::raw::c_char,
                              arg4: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _thread_lock(td: *mut thread, opts: ::std::os::raw::c_int,
                        file: *const ::std::os::raw::c_char,
                        line: ::std::os::raw::c_int);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mtx_pool {
    _unused: [u8; 0],
}
extern "C" {
    pub fn mtx_pool_create(mtx_name: *const ::std::os::raw::c_char,
                           pool_size: ::std::os::raw::c_int,
                           opts: ::std::os::raw::c_int) -> *mut mtx_pool;
}
extern "C" {
    pub fn mtx_pool_destroy(poolp: *mut *mut mtx_pool);
}
extern "C" {
    pub fn mtx_pool_find(pool: *mut mtx_pool,
                         ptr: *mut ::std::os::raw::c_void) -> *mut mtx;
}
extern "C" {
    pub fn mtx_pool_alloc(pool: *mut mtx_pool) -> *mut mtx;
}
extern "C" {
    #[link_name = "mtxpool_sleep"]
    pub static mut mtxpool_sleep: *mut mtx_pool;
}
extern "C" {
    #[link_name = "Giant"]
    pub static mut Giant: mtx;
}
extern "C" {
    #[link_name = "blocked_lock"]
    pub static mut blocked_lock: mtx;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mtx_args {
    pub ma_mtx: *mut ::std::os::raw::c_void,
    pub ma_desc: *const ::std::os::raw::c_char,
    pub ma_opts: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_mtx_args() {
    assert_eq!(::std::mem::size_of::<mtx_args>() , 24usize , concat ! (
               "Size of: " , stringify ! ( mtx_args ) ));
    assert_eq! (::std::mem::align_of::<mtx_args>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( mtx_args ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mtx_args ) ) . ma_mtx as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mtx_args ) , "::" ,
                stringify ! ( ma_mtx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mtx_args ) ) . ma_desc as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mtx_args ) , "::" ,
                stringify ! ( ma_desc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mtx_args ) ) . ma_opts as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mtx_args ) , "::" ,
                stringify ! ( ma_opts ) ));
}
impl Clone for mtx_args {
    fn clone(&self) -> Self { *self }
}
impl Default for mtx_args {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry {
    pub ee_link: eventhandler_entry__bindgen_ty_1,
    pub ee_priority: ::std::os::raw::c_int,
    pub ee_arg: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry__bindgen_ty_1 {
    pub tqe_next: *mut eventhandler_entry,
    pub tqe_prev: *mut *mut eventhandler_entry,
}
#[test]
fn bindgen_test_layout_eventhandler_entry__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry__bindgen_ty_1>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry__bindgen_ty_1 ) ) .
                tqe_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry__bindgen_ty_1 ) , "::" , stringify ! (
                tqe_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry__bindgen_ty_1 ) ) .
                tqe_prev as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry__bindgen_ty_1 ) , "::" , stringify ! (
                tqe_prev ) ));
}
impl Clone for eventhandler_entry__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_eventhandler_entry() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry>() , 32usize , concat
               ! ( "Size of: " , stringify ! ( eventhandler_entry ) ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( eventhandler_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry ) ) . ee_link as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( eventhandler_entry ) ,
                "::" , stringify ! ( ee_link ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry ) ) . ee_priority as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( eventhandler_entry ) ,
                "::" , stringify ! ( ee_priority ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry ) ) . ee_arg as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( eventhandler_entry ) ,
                "::" , stringify ! ( ee_arg ) ));
}
impl Clone for eventhandler_entry {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_list {
    pub el_name: *mut ::std::os::raw::c_char,
    pub el_flags: ::std::os::raw::c_int,
    pub el_runcount: u_int,
    pub el_lock: mtx,
    pub el_link: eventhandler_list__bindgen_ty_1,
    pub el_entries: eventhandler_list__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_list__bindgen_ty_1 {
    pub tqe_next: *mut eventhandler_list,
    pub tqe_prev: *mut *mut eventhandler_list,
}
#[test]
fn bindgen_test_layout_eventhandler_list__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<eventhandler_list__bindgen_ty_1>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_list__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<eventhandler_list__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_list__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_list__bindgen_ty_1 ) ) .
                tqe_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_list__bindgen_ty_1 ) , "::" , stringify ! (
                tqe_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_list__bindgen_ty_1 ) ) .
                tqe_prev as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_list__bindgen_ty_1 ) , "::" , stringify ! (
                tqe_prev ) ));
}
impl Clone for eventhandler_list__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_list__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_list__bindgen_ty_2 {
    pub tqh_first: *mut eventhandler_entry,
    pub tqh_last: *mut *mut eventhandler_entry,
}
#[test]
fn bindgen_test_layout_eventhandler_list__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<eventhandler_list__bindgen_ty_2>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_list__bindgen_ty_2 )
               ));
    assert_eq! (::std::mem::align_of::<eventhandler_list__bindgen_ty_2>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_list__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_list__bindgen_ty_2 ) ) .
                tqh_first as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_list__bindgen_ty_2 ) , "::" , stringify ! (
                tqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_list__bindgen_ty_2 ) ) .
                tqh_last as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_list__bindgen_ty_2 ) , "::" , stringify ! (
                tqh_last ) ));
}
impl Clone for eventhandler_list__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_list__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_eventhandler_list() {
    assert_eq!(::std::mem::size_of::<eventhandler_list>() , 80usize , concat !
               ( "Size of: " , stringify ! ( eventhandler_list ) ));
    assert_eq! (::std::mem::align_of::<eventhandler_list>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( eventhandler_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_list ) ) . el_name as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( eventhandler_list ) ,
                "::" , stringify ! ( el_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_list ) ) . el_flags as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( eventhandler_list ) ,
                "::" , stringify ! ( el_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_list ) ) . el_runcount as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( eventhandler_list ) ,
                "::" , stringify ! ( el_runcount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_list ) ) . el_lock as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( eventhandler_list ) ,
                "::" , stringify ! ( el_lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_list ) ) . el_link as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( eventhandler_list ) ,
                "::" , stringify ! ( el_link ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_list ) ) . el_entries as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( eventhandler_list ) ,
                "::" , stringify ! ( el_entries ) ));
}
impl Clone for eventhandler_list {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_list {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type eventhandler_tag = *mut eventhandler_entry;
extern "C" {
    pub fn eventhandler_register(list: *mut eventhandler_list,
                                 name: *const ::std::os::raw::c_char,
                                 func: *mut ::std::os::raw::c_void,
                                 arg: *mut ::std::os::raw::c_void,
                                 priority: ::std::os::raw::c_int)
     -> eventhandler_tag;
}
extern "C" {
    pub fn eventhandler_deregister(list: *mut eventhandler_list,
                                   tag: eventhandler_tag);
}
extern "C" {
    pub fn eventhandler_deregister_nowait(list: *mut eventhandler_list,
                                          tag: eventhandler_tag);
}
extern "C" {
    pub fn eventhandler_find_list(name: *const ::std::os::raw::c_char)
     -> *mut eventhandler_list;
}
extern "C" {
    pub fn eventhandler_prune_list(list: *mut eventhandler_list);
}
extern "C" {
    pub fn eventhandler_create_list(name: *const ::std::os::raw::c_char)
     -> *mut eventhandler_list;
}
pub type shutdown_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2: ::std::os::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_shutdown_pre_sync {
    pub ee: eventhandler_entry,
    pub eh_func: shutdown_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_shutdown_pre_sync() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_shutdown_pre_sync>() ,
               40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_shutdown_pre_sync ) ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_shutdown_pre_sync>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_shutdown_pre_sync ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_shutdown_pre_sync ) )
                . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_shutdown_pre_sync ) , "::" , stringify ! (
                ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_shutdown_pre_sync ) )
                . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_shutdown_pre_sync ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_shutdown_pre_sync {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_shutdown_pre_sync {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __hack {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_shutdown_post_sync {
    pub ee: eventhandler_entry,
    pub eh_func: shutdown_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_shutdown_post_sync() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_shutdown_post_sync>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_shutdown_post_sync ) ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_shutdown_post_sync>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_shutdown_post_sync ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_shutdown_post_sync ) )
                . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_shutdown_post_sync ) , "::" , stringify ! (
                ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_shutdown_post_sync ) )
                . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_shutdown_post_sync ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_shutdown_post_sync {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_shutdown_post_sync {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_shutdown_final {
    pub ee: eventhandler_entry,
    pub eh_func: shutdown_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_shutdown_final() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_shutdown_final>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_shutdown_final )
               ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_shutdown_final>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_shutdown_final ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_shutdown_final ) ) .
                ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_shutdown_final ) , "::" , stringify ! ( ee
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_shutdown_final ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_shutdown_final ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_shutdown_final {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_shutdown_final {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type power_change_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_power_resume {
    pub ee: eventhandler_entry,
    pub eh_func: power_change_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_power_resume() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_power_resume>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_power_resume )
               ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_power_resume>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_power_resume ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_power_resume ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_power_resume ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_power_resume ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_power_resume ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_power_resume {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_power_resume {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_power_suspend {
    pub ee: eventhandler_entry,
    pub eh_func: power_change_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_power_suspend() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_power_suspend>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_power_suspend )
               ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_power_suspend>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_power_suspend ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_power_suspend ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_power_suspend ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_power_suspend ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_power_suspend ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_power_suspend {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_power_suspend {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_power_suspend_early {
    pub ee: eventhandler_entry,
    pub eh_func: power_change_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_power_suspend_early() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_power_suspend_early>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_power_suspend_early ) ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_power_suspend_early>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_power_suspend_early ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_power_suspend_early )
                ) . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_power_suspend_early ) , "::" , stringify !
                ( ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_power_suspend_early )
                ) . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_power_suspend_early ) , "::" , stringify !
                ( eh_func ) ));
}
impl Clone for eventhandler_entry_power_suspend_early {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_power_suspend_early {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type vm_lowmem_handler_t =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2: ::std::os::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_vm_lowmem {
    pub ee: eventhandler_entry,
    pub eh_func: vm_lowmem_handler_t,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_vm_lowmem() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_vm_lowmem>() , 40usize
               , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_vm_lowmem ) ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_vm_lowmem>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_vm_lowmem )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_vm_lowmem ) ) . ee as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_vm_lowmem ) , "::" , stringify ! ( ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_vm_lowmem ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_vm_lowmem ) , "::" , stringify ! ( eh_func
                ) ));
}
impl Clone for eventhandler_entry_vm_lowmem {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_vm_lowmem {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type mountroot_handler_t =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_mountroot {
    pub ee: eventhandler_entry,
    pub eh_func: mountroot_handler_t,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_mountroot() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_mountroot>() , 40usize
               , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_mountroot ) ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_mountroot>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_mountroot )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_mountroot ) ) . ee as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_mountroot ) , "::" , stringify ! ( ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_mountroot ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_mountroot ) , "::" , stringify ! ( eh_func
                ) ));
}
impl Clone for eventhandler_entry_mountroot {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_mountroot {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mount {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnode {
    _unused: [u8; 0],
}
pub type vfs_mounted_notify_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2: *mut mount,
                                               arg3: *mut vnode,
                                               arg4: *mut thread)>;
pub type vfs_unmounted_notify_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2: *mut mount,
                                               arg3: *mut thread)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_vfs_mounted {
    pub ee: eventhandler_entry,
    pub eh_func: vfs_mounted_notify_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_vfs_mounted() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_vfs_mounted>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_vfs_mounted )
               ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_vfs_mounted>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_vfs_mounted
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_vfs_mounted ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_vfs_mounted ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_vfs_mounted ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_vfs_mounted ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_vfs_mounted {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_vfs_mounted {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_vfs_unmounted {
    pub ee: eventhandler_entry,
    pub eh_func: vfs_unmounted_notify_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_vfs_unmounted() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_vfs_unmounted>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_vfs_unmounted )
               ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_vfs_unmounted>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_vfs_unmounted ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_vfs_unmounted ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_vfs_unmounted ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_vfs_unmounted ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_vfs_unmounted ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_vfs_unmounted {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_vfs_unmounted {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct proc_ {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct image_params {
    _unused: [u8; 0],
}
pub type exitlist_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2: *mut proc_)>;
pub type forklist_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2: *mut proc_,
                                               arg3: *mut proc_,
                                               arg4: ::std::os::raw::c_int)>;
pub type execlist_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2: *mut proc_,
                                               arg3: *mut image_params)>;
pub type proc_ctor_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2: *mut proc_)>;
pub type proc_dtor_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2: *mut proc_)>;
pub type proc_init_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2: *mut proc_)>;
pub type proc_fini_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2: *mut proc_)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_process_ctor {
    pub ee: eventhandler_entry,
    pub eh_func: proc_ctor_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_process_ctor() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_process_ctor>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_process_ctor )
               ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_process_ctor>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_process_ctor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_ctor ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_ctor ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_ctor ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_ctor ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_process_ctor {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_process_ctor {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_process_dtor {
    pub ee: eventhandler_entry,
    pub eh_func: proc_dtor_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_process_dtor() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_process_dtor>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_process_dtor )
               ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_process_dtor>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_process_dtor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_dtor ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_dtor ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_dtor ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_dtor ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_process_dtor {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_process_dtor {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_process_init {
    pub ee: eventhandler_entry,
    pub eh_func: proc_init_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_process_init() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_process_init>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_process_init )
               ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_process_init>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_process_init ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_init ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_init ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_init ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_init ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_process_init {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_process_init {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_process_fini {
    pub ee: eventhandler_entry,
    pub eh_func: proc_fini_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_process_fini() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_process_fini>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_process_fini )
               ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_process_fini>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_process_fini ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_fini ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_fini ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_fini ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_fini ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_process_fini {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_process_fini {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_process_exit {
    pub ee: eventhandler_entry,
    pub eh_func: exitlist_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_process_exit() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_process_exit>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_process_exit )
               ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_process_exit>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_process_exit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_exit ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_exit ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_exit ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_exit ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_process_exit {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_process_exit {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_process_fork {
    pub ee: eventhandler_entry,
    pub eh_func: forklist_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_process_fork() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_process_fork>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_process_fork )
               ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_process_fork>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_process_fork ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_fork ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_fork ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_fork ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_fork ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_process_fork {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_process_fork {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_process_exec {
    pub ee: eventhandler_entry,
    pub eh_func: execlist_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_process_exec() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_process_exec>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_process_exec )
               ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_process_exec>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_process_exec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_exec ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_exec ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_exec ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_exec ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_process_exec {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_process_exec {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type app_coredump_start_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2: *mut thread,
                                               name:
                                                   *mut ::std::os::raw::c_char)>;
pub type app_coredump_progress_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               td: *mut thread,
                                               byte_count:
                                                   ::std::os::raw::c_int)>;
pub type app_coredump_finish_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               td: *mut thread)>;
pub type app_coredump_error_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               td: *mut thread,
                                               msg:
                                                   *mut ::std::os::raw::c_char, ...)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_app_coredump_start {
    pub ee: eventhandler_entry,
    pub eh_func: app_coredump_start_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_app_coredump_start() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_app_coredump_start>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_app_coredump_start ) ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_app_coredump_start>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_app_coredump_start ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_app_coredump_start ) )
                . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_app_coredump_start ) , "::" , stringify ! (
                ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_app_coredump_start ) )
                . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_app_coredump_start ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_app_coredump_start {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_app_coredump_start {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_app_coredump_progress {
    pub ee: eventhandler_entry,
    pub eh_func: app_coredump_progress_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_app_coredump_progress() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_app_coredump_progress>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_app_coredump_progress ) ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_app_coredump_progress>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_app_coredump_progress ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const eventhandler_entry_app_coredump_progress ) )
                . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_app_coredump_progress ) , "::" , stringify
                ! ( ee ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const eventhandler_entry_app_coredump_progress ) )
                . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_app_coredump_progress ) , "::" , stringify
                ! ( eh_func ) ));
}
impl Clone for eventhandler_entry_app_coredump_progress {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_app_coredump_progress {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_app_coredump_finish {
    pub ee: eventhandler_entry,
    pub eh_func: app_coredump_finish_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_app_coredump_finish() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_app_coredump_finish>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_app_coredump_finish ) ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_app_coredump_finish>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_app_coredump_finish ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_app_coredump_finish )
                ) . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_app_coredump_finish ) , "::" , stringify !
                ( ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_app_coredump_finish )
                ) . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_app_coredump_finish ) , "::" , stringify !
                ( eh_func ) ));
}
impl Clone for eventhandler_entry_app_coredump_finish {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_app_coredump_finish {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_app_coredump_error {
    pub ee: eventhandler_entry,
    pub eh_func: app_coredump_error_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_app_coredump_error() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_app_coredump_error>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_app_coredump_error ) ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_app_coredump_error>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_app_coredump_error ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_app_coredump_error ) )
                . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_app_coredump_error ) , "::" , stringify ! (
                ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_app_coredump_error ) )
                . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_app_coredump_error ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_app_coredump_error {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_app_coredump_error {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type thread_ctor_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2: *mut thread)>;
pub type thread_dtor_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2: *mut thread)>;
pub type thread_fini_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2: *mut thread)>;
pub type thread_init_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2: *mut thread)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_thread_ctor {
    pub ee: eventhandler_entry,
    pub eh_func: thread_ctor_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_thread_ctor() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_thread_ctor>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_thread_ctor )
               ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_thread_ctor>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_thread_ctor
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_thread_ctor ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_thread_ctor ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_thread_ctor ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_thread_ctor ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_thread_ctor {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_thread_ctor {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_thread_dtor {
    pub ee: eventhandler_entry,
    pub eh_func: thread_dtor_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_thread_dtor() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_thread_dtor>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_thread_dtor )
               ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_thread_dtor>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_thread_dtor
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_thread_dtor ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_thread_dtor ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_thread_dtor ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_thread_dtor ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_thread_dtor {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_thread_dtor {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_thread_init {
    pub ee: eventhandler_entry,
    pub eh_func: thread_init_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_thread_init() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_thread_init>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_thread_init )
               ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_thread_init>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_thread_init
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_thread_init ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_thread_init ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_thread_init ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_thread_init ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_thread_init {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_thread_init {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_thread_fini {
    pub ee: eventhandler_entry,
    pub eh_func: thread_fini_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_thread_fini() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_thread_fini>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_thread_fini )
               ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_thread_fini>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_thread_fini
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_thread_fini ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_thread_fini ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_thread_fini ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_thread_fini ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_thread_fini {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_thread_fini {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type uma_zone_chfn =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_nmbclusters_change {
    pub ee: eventhandler_entry,
    pub eh_func: uma_zone_chfn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_nmbclusters_change() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_nmbclusters_change>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_nmbclusters_change ) ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_nmbclusters_change>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_nmbclusters_change ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_nmbclusters_change ) )
                . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_nmbclusters_change ) , "::" , stringify ! (
                ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_nmbclusters_change ) )
                . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_nmbclusters_change ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_nmbclusters_change {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_nmbclusters_change {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_nmbufs_change {
    pub ee: eventhandler_entry,
    pub eh_func: uma_zone_chfn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_nmbufs_change() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_nmbufs_change>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_nmbufs_change )
               ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_nmbufs_change>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_nmbufs_change ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_nmbufs_change ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_nmbufs_change ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_nmbufs_change ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_nmbufs_change ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_nmbufs_change {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_nmbufs_change {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_maxsockets_change {
    pub ee: eventhandler_entry,
    pub eh_func: uma_zone_chfn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_maxsockets_change() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_maxsockets_change>() ,
               40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_maxsockets_change ) ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_maxsockets_change>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_maxsockets_change ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_maxsockets_change ) )
                . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_maxsockets_change ) , "::" , stringify ! (
                ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_maxsockets_change ) )
                . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_maxsockets_change ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_maxsockets_change {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_maxsockets_change {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type kld_load_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2: *mut linker_file)>;
pub type kld_unload_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2:
                                                   *const ::std::os::raw::c_char,
                                               arg3: caddr_t, arg4: usize)>;
pub type kld_unload_try_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2: *mut linker_file,
                                               arg3:
                                                   *mut ::std::os::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_kld_load {
    pub ee: eventhandler_entry,
    pub eh_func: kld_load_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_kld_load() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_kld_load>() , 40usize
               , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_kld_load ) ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_kld_load>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_kld_load )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_kld_load ) ) . ee as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_kld_load ) , "::" , stringify ! ( ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_kld_load ) ) . eh_func
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_kld_load ) , "::" , stringify ! ( eh_func )
                ));
}
impl Clone for eventhandler_entry_kld_load {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_kld_load {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_kld_unload {
    pub ee: eventhandler_entry,
    pub eh_func: kld_unload_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_kld_unload() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_kld_unload>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_kld_unload ) ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_kld_unload>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_kld_unload
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_kld_unload ) ) . ee as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_kld_unload ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_kld_unload ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_kld_unload ) , "::" , stringify ! ( eh_func
                ) ));
}
impl Clone for eventhandler_entry_kld_unload {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_kld_unload {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_kld_unload_try {
    pub ee: eventhandler_entry,
    pub eh_func: kld_unload_try_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_kld_unload_try() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_kld_unload_try>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_kld_unload_try )
               ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_kld_unload_try>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_kld_unload_try ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_kld_unload_try ) ) .
                ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_kld_unload_try ) , "::" , stringify ! ( ee
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_kld_unload_try ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_kld_unload_try ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_kld_unload_try {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_kld_unload_try {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fb_info {
    _unused: [u8; 0],
}
pub type register_framebuffer_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2: *mut fb_info)>;
pub type unregister_framebuffer_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2: *mut fb_info)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_register_framebuffer {
    pub ee: eventhandler_entry,
    pub eh_func: register_framebuffer_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_register_framebuffer() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_register_framebuffer>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_register_framebuffer ) ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_register_framebuffer>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_register_framebuffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_register_framebuffer )
                ) . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_register_framebuffer ) , "::" , stringify !
                ( ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_register_framebuffer )
                ) . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_register_framebuffer ) , "::" , stringify !
                ( eh_func ) ));
}
impl Clone for eventhandler_entry_register_framebuffer {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_register_framebuffer {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_unregister_framebuffer {
    pub ee: eventhandler_entry,
    pub eh_func: unregister_framebuffer_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_unregister_framebuffer() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_unregister_framebuffer>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_unregister_framebuffer ) ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_unregister_framebuffer>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_unregister_framebuffer ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const eventhandler_entry_unregister_framebuffer ) )
                . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_unregister_framebuffer ) , "::" , stringify
                ! ( ee ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const eventhandler_entry_unregister_framebuffer ) )
                . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_unregister_framebuffer ) , "::" , stringify
                ! ( eh_func ) ));
}
impl Clone for eventhandler_entry_unregister_framebuffer {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_unregister_framebuffer {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cam_path {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ata_params {
    _unused: [u8; 0],
}
pub type ada_probe_veto_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2: *mut cam_path,
                                               arg3: *mut ata_params,
                                               arg4:
                                                   *mut ::std::os::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_ada_probe_veto {
    pub ee: eventhandler_entry,
    pub eh_func: ada_probe_veto_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_ada_probe_veto() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_ada_probe_veto>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_ada_probe_veto )
               ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_ada_probe_veto>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_ada_probe_veto ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_ada_probe_veto ) ) .
                ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_ada_probe_veto ) , "::" , stringify ! ( ee
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_ada_probe_veto ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_ada_probe_veto ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_ada_probe_veto {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_ada_probe_veto {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct swdevt {
    _unused: [u8; 0],
}
pub type swapon_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2: *mut swdevt)>;
pub type swapoff_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2: *mut swdevt)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_swapon {
    pub ee: eventhandler_entry,
    pub eh_func: swapon_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_swapon() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_swapon>() , 40usize ,
               concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_swapon ) ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_swapon>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_swapon )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_swapon ) ) . ee as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_swapon ) , "::" , stringify ! ( ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_swapon ) ) . eh_func
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_swapon ) , "::" , stringify ! ( eh_func )
                ));
}
impl Clone for eventhandler_entry_swapon {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_swapon {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_swapoff {
    pub ee: eventhandler_entry,
    pub eh_func: swapoff_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_swapoff() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_swapoff>() , 40usize ,
               concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_swapoff ) ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_swapoff>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_swapoff )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_swapoff ) ) . ee as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_swapoff ) , "::" , stringify ! ( ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_swapoff ) ) . eh_func
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_swapoff ) , "::" , stringify ! ( eh_func )
                ));
}
impl Clone for eventhandler_entry_swapoff {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_swapoff {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum evhdev_detach {
    EVHDEV_DETACH_BEGIN = 0,
    EVHDEV_DETACH_COMPLETE = 1,
    EVHDEV_DETACH_FAILED = 2,
}
pub type device_attach_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2: device_t)>;
pub type device_detach_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2: device_t,
                                               arg3: evhdev_detach)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_device_attach {
    pub ee: eventhandler_entry,
    pub eh_func: device_attach_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_device_attach() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_device_attach>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_device_attach )
               ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_device_attach>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_device_attach ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_device_attach ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_device_attach ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_device_attach ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_device_attach ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_device_attach {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_device_attach {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_device_detach {
    pub ee: eventhandler_entry,
    pub eh_func: device_detach_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_device_detach() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_device_detach>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_device_detach )
               ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_device_detach>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_device_detach ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_device_detach ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_device_detach ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_device_detach ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_device_detach ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_device_detach {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_device_detach {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct snapdata {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct devfs_dirent {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy)]
pub struct cdevsw {
    pub d_version: ::std::os::raw::c_int,
    pub d_flags: u_int,
    pub d_name: *const ::std::os::raw::c_char,
    pub d_open: d_open_t,
    pub d_fdopen: d_fdopen_t,
    pub d_close: d_close_t,
    pub d_read: d_read_t,
    pub d_write: d_write_t,
    pub d_ioctl: d_ioctl_t,
    pub d_poll: d_poll_t,
    pub d_mmap: d_mmap_t,
    pub d_strategy: d_strategy_t,
    pub d_dump: dumper_t,
    pub d_kqfilter: d_kqfilter_t,
    pub d_purge: d_purge_t,
    pub d_mmap_single: d_mmap_single_t,
    pub d_spare0: [i32; 3usize],
    pub d_spare1: [*mut ::std::os::raw::c_void; 3usize],
    pub d_devs: cdevsw__bindgen_ty_1,
    pub d_spare2: ::std::os::raw::c_int,
    pub __d_giant: cdevsw__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cdevsw__bindgen_ty_1 {
    pub lh_first: *mut cdev,
}
#[test]
fn bindgen_test_layout_cdevsw__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<cdevsw__bindgen_ty_1>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( cdevsw__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<cdevsw__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( cdevsw__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cdevsw__bindgen_ty_1 ) ) . lh_first as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( cdevsw__bindgen_ty_1 )
                , "::" , stringify ! ( lh_first ) ));
}
impl Clone for cdevsw__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for cdevsw__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub union cdevsw__bindgen_ty_2 {
    pub gianttrick: *mut cdevsw,
    pub postfree_list: cdevsw__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cdevsw__bindgen_ty_2__bindgen_ty_1 {
    pub sle_next: *mut cdevsw,
}
#[test]
fn bindgen_test_layout_cdevsw__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<cdevsw__bindgen_ty_2__bindgen_ty_1>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( cdevsw__bindgen_ty_2__bindgen_ty_1
               ) ));
    assert_eq! (::std::mem::align_of::<cdevsw__bindgen_ty_2__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                cdevsw__bindgen_ty_2__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cdevsw__bindgen_ty_2__bindgen_ty_1 ) ) .
                sle_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                cdevsw__bindgen_ty_2__bindgen_ty_1 ) , "::" , stringify ! (
                sle_next ) ));
}
impl Clone for cdevsw__bindgen_ty_2__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for cdevsw__bindgen_ty_2__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_cdevsw__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<cdevsw__bindgen_ty_2>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( cdevsw__bindgen_ty_2 ) ));
    assert_eq! (::std::mem::align_of::<cdevsw__bindgen_ty_2>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( cdevsw__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cdevsw__bindgen_ty_2 ) ) . gianttrick as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( cdevsw__bindgen_ty_2 )
                , "::" , stringify ! ( gianttrick ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cdevsw__bindgen_ty_2 ) ) . postfree_list
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( cdevsw__bindgen_ty_2 )
                , "::" , stringify ! ( postfree_list ) ));
}
impl Clone for cdevsw__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for cdevsw__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl ::std::fmt::Debug for cdevsw__bindgen_ty_2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f , "cdevsw__bindgen_ty_2 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_cdevsw() {
    assert_eq!(::std::mem::size_of::<cdevsw>() , 184usize , concat ! (
               "Size of: " , stringify ! ( cdevsw ) ));
    assert_eq! (::std::mem::align_of::<cdevsw>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( cdevsw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cdevsw ) ) . d_version as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( cdevsw ) , "::" ,
                stringify ! ( d_version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cdevsw ) ) . d_flags as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( cdevsw ) , "::" ,
                stringify ! ( d_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cdevsw ) ) . d_name as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( cdevsw ) , "::" ,
                stringify ! ( d_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cdevsw ) ) . d_open as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( cdevsw ) , "::" ,
                stringify ! ( d_open ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cdevsw ) ) . d_fdopen as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( cdevsw ) , "::" ,
                stringify ! ( d_fdopen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cdevsw ) ) . d_close as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( cdevsw ) , "::" ,
                stringify ! ( d_close ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cdevsw ) ) . d_read as * const _ as usize
                } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( cdevsw ) , "::" ,
                stringify ! ( d_read ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cdevsw ) ) . d_write as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( cdevsw ) , "::" ,
                stringify ! ( d_write ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cdevsw ) ) . d_ioctl as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( cdevsw ) , "::" ,
                stringify ! ( d_ioctl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cdevsw ) ) . d_poll as * const _ as usize
                } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( cdevsw ) , "::" ,
                stringify ! ( d_poll ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cdevsw ) ) . d_mmap as * const _ as usize
                } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( cdevsw ) , "::" ,
                stringify ! ( d_mmap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cdevsw ) ) . d_strategy as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( cdevsw ) , "::" ,
                stringify ! ( d_strategy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cdevsw ) ) . d_dump as * const _ as usize
                } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( cdevsw ) , "::" ,
                stringify ! ( d_dump ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cdevsw ) ) . d_kqfilter as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( cdevsw ) , "::" ,
                stringify ! ( d_kqfilter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cdevsw ) ) . d_purge as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( cdevsw ) , "::" ,
                stringify ! ( d_purge ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cdevsw ) ) . d_mmap_single as * const _
                as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( cdevsw ) , "::" ,
                stringify ! ( d_mmap_single ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cdevsw ) ) . d_spare0 as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( cdevsw ) , "::" ,
                stringify ! ( d_spare0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cdevsw ) ) . d_spare1 as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( cdevsw ) , "::" ,
                stringify ! ( d_spare1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cdevsw ) ) . d_devs as * const _ as usize
                } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( cdevsw ) , "::" ,
                stringify ! ( d_devs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cdevsw ) ) . d_spare2 as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( cdevsw ) , "::" ,
                stringify ! ( d_spare2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cdevsw ) ) . __d_giant as * const _ as
                usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( cdevsw ) , "::" ,
                stringify ! ( __d_giant ) ));
}
impl Clone for cdevsw {
    fn clone(&self) -> Self { *self }
}
impl Default for cdevsw {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl ::std::fmt::Debug for cdevsw {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f ,
               "cdevsw {{ d_version: {:?}, d_flags: {:?}, d_name: {:?}, d_open: {:?}, d_fdopen: {:?}, d_close: {:?}, d_read: {:?}, d_write: {:?}, d_ioctl: {:?}, d_poll: {:?}, d_mmap: {:?}, d_strategy: {:?}, d_dump: {:?}, d_kqfilter: {:?}, d_purge: {:?}, d_mmap_single: {:?}, d_spare0: {:?}, d_spare1: {:?}, d_devs: {:?}, d_spare2: {:?}, __d_giant: {:?} }}"
               , self . d_version , self . d_flags , self . d_name , self .
               d_open , self . d_fdopen , self . d_close , self . d_read ,
               self . d_write , self . d_ioctl , self . d_poll , self . d_mmap
               , self . d_strategy , self . d_dump , self . d_kqfilter , self
               . d_purge , self . d_mmap_single , self . d_spare0 , self .
               d_spare1 , self . d_devs , self . d_spare2 , self . __d_giant)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct file {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy)]
pub struct cdev {
    pub si_spare0: *mut ::std::os::raw::c_void,
    pub si_flags: u_int,
    pub si_atime: timespec,
    pub si_ctime: timespec,
    pub si_mtime: timespec,
    pub si_uid: uid_t,
    pub si_gid: gid_t,
    pub si_mode: mode_t,
    pub si_cred: *mut ucred,
    pub si_drv0: ::std::os::raw::c_int,
    pub si_refcount: ::std::os::raw::c_int,
    pub si_list: cdev__bindgen_ty_1,
    pub si_clone: cdev__bindgen_ty_2,
    pub si_children: cdev__bindgen_ty_3,
    pub si_siblings: cdev__bindgen_ty_4,
    pub si_parent: *mut cdev,
    pub si_mountpt: *mut mount,
    pub si_drv1: *mut ::std::os::raw::c_void,
    pub si_drv2: *mut ::std::os::raw::c_void,
    pub si_devsw: *mut cdevsw,
    pub si_iosize_max: ::std::os::raw::c_int,
    pub si_usecount: u_long,
    pub si_threadcount: u_long,
    pub __si_u: cdev__bindgen_ty_5,
    pub si_name: [::std::os::raw::c_char; 64usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cdev__bindgen_ty_1 {
    pub le_next: *mut cdev,
    pub le_prev: *mut *mut cdev,
}
#[test]
fn bindgen_test_layout_cdev__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<cdev__bindgen_ty_1>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( cdev__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<cdev__bindgen_ty_1>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( cdev__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cdev__bindgen_ty_1 ) ) . le_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( cdev__bindgen_ty_1 ) ,
                "::" , stringify ! ( le_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cdev__bindgen_ty_1 ) ) . le_prev as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( cdev__bindgen_ty_1 ) ,
                "::" , stringify ! ( le_prev ) ));
}
impl Clone for cdev__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for cdev__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cdev__bindgen_ty_2 {
    pub le_next: *mut cdev,
    pub le_prev: *mut *mut cdev,
}
#[test]
fn bindgen_test_layout_cdev__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<cdev__bindgen_ty_2>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( cdev__bindgen_ty_2 ) ));
    assert_eq! (::std::mem::align_of::<cdev__bindgen_ty_2>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( cdev__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cdev__bindgen_ty_2 ) ) . le_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( cdev__bindgen_ty_2 ) ,
                "::" , stringify ! ( le_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cdev__bindgen_ty_2 ) ) . le_prev as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( cdev__bindgen_ty_2 ) ,
                "::" , stringify ! ( le_prev ) ));
}
impl Clone for cdev__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for cdev__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cdev__bindgen_ty_3 {
    pub lh_first: *mut cdev,
}
#[test]
fn bindgen_test_layout_cdev__bindgen_ty_3() {
    assert_eq!(::std::mem::size_of::<cdev__bindgen_ty_3>() , 8usize , concat !
               ( "Size of: " , stringify ! ( cdev__bindgen_ty_3 ) ));
    assert_eq! (::std::mem::align_of::<cdev__bindgen_ty_3>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( cdev__bindgen_ty_3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cdev__bindgen_ty_3 ) ) . lh_first as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( cdev__bindgen_ty_3 ) ,
                "::" , stringify ! ( lh_first ) ));
}
impl Clone for cdev__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
impl Default for cdev__bindgen_ty_3 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cdev__bindgen_ty_4 {
    pub le_next: *mut cdev,
    pub le_prev: *mut *mut cdev,
}
#[test]
fn bindgen_test_layout_cdev__bindgen_ty_4() {
    assert_eq!(::std::mem::size_of::<cdev__bindgen_ty_4>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( cdev__bindgen_ty_4 ) ));
    assert_eq! (::std::mem::align_of::<cdev__bindgen_ty_4>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( cdev__bindgen_ty_4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cdev__bindgen_ty_4 ) ) . le_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( cdev__bindgen_ty_4 ) ,
                "::" , stringify ! ( le_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cdev__bindgen_ty_4 ) ) . le_prev as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( cdev__bindgen_ty_4 ) ,
                "::" , stringify ! ( le_prev ) ));
}
impl Clone for cdev__bindgen_ty_4 {
    fn clone(&self) -> Self { *self }
}
impl Default for cdev__bindgen_ty_4 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub union cdev__bindgen_ty_5 {
    pub __sid_snapdata: *mut snapdata,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_cdev__bindgen_ty_5() {
    assert_eq!(::std::mem::size_of::<cdev__bindgen_ty_5>() , 8usize , concat !
               ( "Size of: " , stringify ! ( cdev__bindgen_ty_5 ) ));
    assert_eq! (::std::mem::align_of::<cdev__bindgen_ty_5>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( cdev__bindgen_ty_5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cdev__bindgen_ty_5 ) ) . __sid_snapdata
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( cdev__bindgen_ty_5 ) ,
                "::" , stringify ! ( __sid_snapdata ) ));
}
impl Clone for cdev__bindgen_ty_5 {
    fn clone(&self) -> Self { *self }
}
impl Default for cdev__bindgen_ty_5 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl ::std::fmt::Debug for cdev__bindgen_ty_5 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f , "cdev__bindgen_ty_5 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_cdev() {
    assert_eq!(::std::mem::size_of::<cdev>() , 288usize , concat ! (
               "Size of: " , stringify ! ( cdev ) ));
    assert_eq! (::std::mem::align_of::<cdev>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( cdev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cdev ) ) . si_spare0 as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( cdev ) , "::" ,
                stringify ! ( si_spare0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cdev ) ) . si_flags as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( cdev ) , "::" ,
                stringify ! ( si_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cdev ) ) . si_atime as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( cdev ) , "::" ,
                stringify ! ( si_atime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cdev ) ) . si_ctime as * const _ as usize
                } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( cdev ) , "::" ,
                stringify ! ( si_ctime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cdev ) ) . si_mtime as * const _ as usize
                } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( cdev ) , "::" ,
                stringify ! ( si_mtime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cdev ) ) . si_uid as * const _ as usize }
                , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( cdev ) , "::" ,
                stringify ! ( si_uid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cdev ) ) . si_gid as * const _ as usize }
                , 68usize , concat ! (
                "Alignment of field: " , stringify ! ( cdev ) , "::" ,
                stringify ! ( si_gid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cdev ) ) . si_mode as * const _ as usize
                } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( cdev ) , "::" ,
                stringify ! ( si_mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cdev ) ) . si_cred as * const _ as usize
                } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( cdev ) , "::" ,
                stringify ! ( si_cred ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cdev ) ) . si_drv0 as * const _ as usize
                } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( cdev ) , "::" ,
                stringify ! ( si_drv0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cdev ) ) . si_refcount as * const _ as
                usize } , 92usize , concat ! (
                "Alignment of field: " , stringify ! ( cdev ) , "::" ,
                stringify ! ( si_refcount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cdev ) ) . si_list as * const _ as usize
                } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( cdev ) , "::" ,
                stringify ! ( si_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cdev ) ) . si_clone as * const _ as usize
                } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( cdev ) , "::" ,
                stringify ! ( si_clone ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cdev ) ) . si_children as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( cdev ) , "::" ,
                stringify ! ( si_children ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cdev ) ) . si_siblings as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( cdev ) , "::" ,
                stringify ! ( si_siblings ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cdev ) ) . si_parent as * const _ as
                usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( cdev ) , "::" ,
                stringify ! ( si_parent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cdev ) ) . si_mountpt as * const _ as
                usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( cdev ) , "::" ,
                stringify ! ( si_mountpt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cdev ) ) . si_drv1 as * const _ as usize
                } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( cdev ) , "::" ,
                stringify ! ( si_drv1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cdev ) ) . si_drv2 as * const _ as usize
                } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( cdev ) , "::" ,
                stringify ! ( si_drv2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cdev ) ) . si_devsw as * const _ as usize
                } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( cdev ) , "::" ,
                stringify ! ( si_devsw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cdev ) ) . si_iosize_max as * const _ as
                usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( cdev ) , "::" ,
                stringify ! ( si_iosize_max ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cdev ) ) . si_usecount as * const _ as
                usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( cdev ) , "::" ,
                stringify ! ( si_usecount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cdev ) ) . si_threadcount as * const _ as
                usize } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( cdev ) , "::" ,
                stringify ! ( si_threadcount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cdev ) ) . __si_u as * const _ as usize }
                , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( cdev ) , "::" ,
                stringify ! ( __si_u ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cdev ) ) . si_name as * const _ as usize
                } , 224usize , concat ! (
                "Alignment of field: " , stringify ! ( cdev ) , "::" ,
                stringify ! ( si_name ) ));
}
impl Clone for cdev {
    fn clone(&self) -> Self { *self }
}
impl Default for cdev {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl ::std::fmt::Debug for cdev {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f ,
               "cdev {{ si_spare0: {:?}, si_flags: {:?}, si_atime: {:?}, si_ctime: {:?}, si_mtime: {:?}, si_uid: {:?}, si_gid: {:?}, si_mode: {:?}, si_cred: {:?}, si_drv0: {:?}, si_refcount: {:?}, si_list: {:?}, si_clone: {:?}, si_children: {:?}, si_siblings: {:?}, si_parent: {:?}, si_mountpt: {:?}, si_drv1: {:?}, si_drv2: {:?}, si_devsw: {:?}, si_iosize_max: {:?}, si_usecount: {:?}, si_threadcount: {:?}, __si_u: {:?}, si_name: [{}] }}"
               , self . si_spare0 , self . si_flags , self . si_atime , self .
               si_ctime , self . si_mtime , self . si_uid , self . si_gid ,
               self . si_mode , self . si_cred , self . si_drv0 , self .
               si_refcount , self . si_list , self . si_clone , self .
               si_children , self . si_siblings , self . si_parent , self .
               si_mountpt , self . si_drv1 , self . si_drv2 , self . si_devsw
               , self . si_iosize_max , self . si_usecount , self .
               si_threadcount , self . __si_u , self . si_name . iter (  ) .
               enumerate (  ) . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ))
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bio {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct buf {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uio {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct knote {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clonedevs {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_object {
    _unused: [u8; 0],
}
pub type d_open_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut cdev,
                                               oflags: ::std::os::raw::c_int,
                                               devtype: ::std::os::raw::c_int,
                                               td: *mut thread)
                              -> ::std::os::raw::c_int>;
pub type d_fdopen_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut cdev,
                                               oflags: ::std::os::raw::c_int,
                                               td: *mut thread, fp: *mut file)
                              -> ::std::os::raw::c_int>;
pub type d_close_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut cdev,
                                               fflag: ::std::os::raw::c_int,
                                               devtype: ::std::os::raw::c_int,
                                               td: *mut thread)
                              -> ::std::os::raw::c_int>;
pub type d_strategy_t =
    ::std::option::Option<unsafe extern "C" fn(bp: *mut bio)>;
pub type d_ioctl_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut cdev, cmd: u_long,
                                               data: caddr_t,
                                               fflag: ::std::os::raw::c_int,
                                               td: *mut thread)
                              -> ::std::os::raw::c_int>;
pub type d_read_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut cdev, uio: *mut uio,
                                               ioflag: ::std::os::raw::c_int)
                              -> ::std::os::raw::c_int>;
pub type d_write_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut cdev, uio: *mut uio,
                                               ioflag: ::std::os::raw::c_int)
                              -> ::std::os::raw::c_int>;
pub type d_poll_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut cdev,
                                               events: ::std::os::raw::c_int,
                                               td: *mut thread)
                              -> ::std::os::raw::c_int>;
pub type d_kqfilter_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut cdev, kn: *mut knote)
                              -> ::std::os::raw::c_int>;
pub type d_mmap_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut cdev,
                                               offset: vm_ooffset_t,
                                               paddr: *mut vm_paddr_t,
                                               nprot: ::std::os::raw::c_int,
                                               memattr: *mut vm_memattr_t)
                              -> ::std::os::raw::c_int>;
pub type d_mmap_single_t =
    ::std::option::Option<unsafe extern "C" fn(cdev: *mut cdev,
                                               offset: *mut vm_ooffset_t,
                                               size: vm_size_t,
                                               object: *mut *mut vm_object,
                                               nprot: ::std::os::raw::c_int)
                              -> ::std::os::raw::c_int>;
pub type d_purge_t =
    ::std::option::Option<unsafe extern "C" fn(dev: *mut cdev)>;
pub type dumper_t =
    ::std::option::Option<unsafe extern "C" fn(_priv:
                                                   *mut ::std::os::raw::c_void,
                                               _virtual:
                                                   *mut ::std::os::raw::c_void,
                                               _physical: vm_offset_t,
                                               _offset: off_t, _length: usize)
                              -> ::std::os::raw::c_int>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct module {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct devsw_module_data {
    pub chainevh: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                 *mut module,
                                                             arg2:
                                                                 ::std::os::raw::c_int,
                                                             arg3:
                                                                 *mut ::std::os::raw::c_void)
                                            -> ::std::os::raw::c_int>,
    pub chainarg: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_devsw_module_data() {
    assert_eq!(::std::mem::size_of::<devsw_module_data>() , 16usize , concat !
               ( "Size of: " , stringify ! ( devsw_module_data ) ));
    assert_eq! (::std::mem::align_of::<devsw_module_data>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( devsw_module_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const devsw_module_data ) ) . chainevh as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( devsw_module_data ) ,
                "::" , stringify ! ( chainevh ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const devsw_module_data ) ) . chainarg as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( devsw_module_data ) ,
                "::" , stringify ! ( chainarg ) ));
}
impl Clone for devsw_module_data {
    fn clone(&self) -> Self { *self }
}
impl Default for devsw_module_data {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
extern "C" {
    pub fn clone_setup(cdp: *mut *mut clonedevs);
}
extern "C" {
    pub fn clone_cleanup(arg1: *mut *mut clonedevs);
}
extern "C" {
    pub fn clone_create(arg1: *mut *mut clonedevs, arg2: *mut cdevsw,
                        unit: *mut ::std::os::raw::c_int, dev: *mut *mut cdev,
                        extra: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct make_dev_args {
    pub mda_size: usize,
    pub mda_flags: ::std::os::raw::c_int,
    pub mda_devsw: *mut cdevsw,
    pub mda_cr: *mut ucred,
    pub mda_uid: uid_t,
    pub mda_gid: gid_t,
    pub mda_mode: ::std::os::raw::c_int,
    pub mda_unit: ::std::os::raw::c_int,
    pub mda_si_drv1: *mut ::std::os::raw::c_void,
    pub mda_si_drv2: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_make_dev_args() {
    assert_eq!(::std::mem::size_of::<make_dev_args>() , 64usize , concat ! (
               "Size of: " , stringify ! ( make_dev_args ) ));
    assert_eq! (::std::mem::align_of::<make_dev_args>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( make_dev_args ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const make_dev_args ) ) . mda_size as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( make_dev_args ) , "::"
                , stringify ! ( mda_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const make_dev_args ) ) . mda_flags as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( make_dev_args ) , "::"
                , stringify ! ( mda_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const make_dev_args ) ) . mda_devsw as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( make_dev_args ) , "::"
                , stringify ! ( mda_devsw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const make_dev_args ) ) . mda_cr as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( make_dev_args ) , "::"
                , stringify ! ( mda_cr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const make_dev_args ) ) . mda_uid as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( make_dev_args ) , "::"
                , stringify ! ( mda_uid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const make_dev_args ) ) . mda_gid as * const _
                as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( make_dev_args ) , "::"
                , stringify ! ( mda_gid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const make_dev_args ) ) . mda_mode as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( make_dev_args ) , "::"
                , stringify ! ( mda_mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const make_dev_args ) ) . mda_unit as * const _
                as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( make_dev_args ) , "::"
                , stringify ! ( mda_unit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const make_dev_args ) ) . mda_si_drv1 as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( make_dev_args ) , "::"
                , stringify ! ( mda_si_drv1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const make_dev_args ) ) . mda_si_drv2 as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( make_dev_args ) , "::"
                , stringify ! ( mda_si_drv2 ) ));
}
impl Clone for make_dev_args {
    fn clone(&self) -> Self { *self }
}
impl Default for make_dev_args {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
extern "C" {
    pub fn make_dev_args_init_impl(_args: *mut make_dev_args, _sz: usize);
}
extern "C" {
    pub fn count_dev(_dev: *mut cdev) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn delist_dev(_dev: *mut cdev);
}
extern "C" {
    pub fn destroy_dev(_dev: *mut cdev);
}
extern "C" {
    pub fn destroy_dev_sched(dev: *mut cdev) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn destroy_dev_sched_cb(dev: *mut cdev,
                                cb:
                                    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                   *mut ::std::os::raw::c_void)>,
                                arg: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn destroy_dev_drain(csw: *mut cdevsw);
}
extern "C" {
    pub fn drain_dev_clone_events();
}
extern "C" {
    pub fn dev_refthread(_dev: *mut cdev, _ref: *mut ::std::os::raw::c_int)
     -> *mut cdevsw;
}
extern "C" {
    pub fn devvn_refthread(vp: *mut vnode, devp: *mut *mut cdev,
                           _ref: *mut ::std::os::raw::c_int) -> *mut cdevsw;
}
extern "C" {
    pub fn dev_relthread(_dev: *mut cdev, _ref: ::std::os::raw::c_int);
}
extern "C" {
    pub fn dev_depends(_pdev: *mut cdev, _cdev: *mut cdev);
}
extern "C" {
    pub fn dev_ref(dev: *mut cdev);
}
extern "C" {
    pub fn dev_refl(dev: *mut cdev);
}
extern "C" {
    pub fn dev_rel(dev: *mut cdev);
}
extern "C" {
    pub fn make_dev(_devsw: *mut cdevsw, _unit: ::std::os::raw::c_int,
                    _uid: uid_t, _gid: gid_t, _perms: ::std::os::raw::c_int,
                    _fmt: *const ::std::os::raw::c_char, ...) -> *mut cdev;
}
extern "C" {
    pub fn make_dev_cred(_devsw: *mut cdevsw, _unit: ::std::os::raw::c_int,
                         _cr: *mut ucred, _uid: uid_t, _gid: gid_t,
                         _perms: ::std::os::raw::c_int,
                         _fmt: *const ::std::os::raw::c_char, ...)
     -> *mut cdev;
}
extern "C" {
    pub fn make_dev_credf(_flags: ::std::os::raw::c_int, _devsw: *mut cdevsw,
                          _unit: ::std::os::raw::c_int, _cr: *mut ucred,
                          _uid: uid_t, _gid: gid_t,
                          _mode: ::std::os::raw::c_int,
                          _fmt: *const ::std::os::raw::c_char, ...)
     -> *mut cdev;
}
extern "C" {
    pub fn make_dev_p(_flags: ::std::os::raw::c_int, _cdev: *mut *mut cdev,
                      _devsw: *mut cdevsw, _cr: *mut ucred, _uid: uid_t,
                      _gid: gid_t, _mode: ::std::os::raw::c_int,
                      _fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn make_dev_s(_args: *mut make_dev_args, _cdev: *mut *mut cdev,
                      _fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn make_dev_alias(_pdev: *mut cdev,
                          _fmt: *const ::std::os::raw::c_char, ...)
     -> *mut cdev;
}
extern "C" {
    pub fn make_dev_alias_p(_flags: ::std::os::raw::c_int,
                            _cdev: *mut *mut cdev, _pdev: *mut cdev,
                            _fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn make_dev_physpath_alias(_flags: ::std::os::raw::c_int,
                                   _cdev: *mut *mut cdev, _pdev: *mut cdev,
                                   _old_alias: *mut cdev,
                                   _physpath: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dev_lock();
}
extern "C" {
    pub fn dev_unlock();
}
pub type d_priv_dtor_t =
    ::std::option::Option<unsafe extern "C" fn(data:
                                                   *mut ::std::os::raw::c_void)>;
extern "C" {
    pub fn devfs_get_cdevpriv(datap: *mut *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn devfs_set_cdevpriv(priv_: *mut ::std::os::raw::c_void,
                              dtr: d_priv_dtor_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn devfs_clear_cdevpriv();
}
extern "C" {
    pub fn devfs_alloc_cdp_inode() -> ino_t;
}
extern "C" {
    pub fn devfs_free_cdp_inode(ino: ino_t);
}
pub type dev_clone_fn =
    ::std::option::Option<unsafe extern "C" fn(arg:
                                                   *mut ::std::os::raw::c_void,
                                               cred: *mut ucred,
                                               name:
                                                   *mut ::std::os::raw::c_char,
                                               namelen: ::std::os::raw::c_int,
                                               result: *mut *mut cdev)>;
extern "C" {
    pub fn dev_stdclone(_name: *mut ::std::os::raw::c_char,
                        _namep: *mut *mut ::std::os::raw::c_char,
                        _stem: *const ::std::os::raw::c_char,
                        _unit: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_dev_clone {
    pub ee: eventhandler_entry,
    pub eh_func: dev_clone_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_dev_clone() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_dev_clone>() , 40usize
               , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_dev_clone ) ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_dev_clone>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_dev_clone )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_dev_clone ) ) . ee as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_dev_clone ) , "::" , stringify ! ( ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_dev_clone ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_dev_clone ) , "::" , stringify ! ( eh_func
                ) ));
}
impl Clone for eventhandler_entry_dev_clone {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_dev_clone {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kerneldumpcrypto {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kerneldumpheader {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct dumperinfo {
    pub dumper: dumper_t,
    pub priv_: *mut ::std::os::raw::c_void,
    pub blocksize: u_int,
    pub maxiosize: u_int,
    pub mediaoffset: off_t,
    pub mediasize: off_t,
    pub blockbuf: *mut ::std::os::raw::c_void,
    pub dumpoff: off_t,
    pub kdcrypto: *mut kerneldumpcrypto,
    pub kdcomp: *mut kerneldumpcomp,
}
#[test]
fn bindgen_test_layout_dumperinfo() {
    assert_eq!(::std::mem::size_of::<dumperinfo>() , 72usize , concat ! (
               "Size of: " , stringify ! ( dumperinfo ) ));
    assert_eq! (::std::mem::align_of::<dumperinfo>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( dumperinfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dumperinfo ) ) . dumper as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( dumperinfo ) , "::" ,
                stringify ! ( dumper ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dumperinfo ) ) . priv_ as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( dumperinfo ) , "::" ,
                stringify ! ( priv_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dumperinfo ) ) . blocksize as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( dumperinfo ) , "::" ,
                stringify ! ( blocksize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dumperinfo ) ) . maxiosize as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( dumperinfo ) , "::" ,
                stringify ! ( maxiosize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dumperinfo ) ) . mediaoffset as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( dumperinfo ) , "::" ,
                stringify ! ( mediaoffset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dumperinfo ) ) . mediasize as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( dumperinfo ) , "::" ,
                stringify ! ( mediasize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dumperinfo ) ) . blockbuf as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( dumperinfo ) , "::" ,
                stringify ! ( blockbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dumperinfo ) ) . dumpoff as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( dumperinfo ) , "::" ,
                stringify ! ( dumpoff ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dumperinfo ) ) . kdcrypto as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( dumperinfo ) , "::" ,
                stringify ! ( kdcrypto ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const dumperinfo ) ) . kdcomp as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( dumperinfo ) , "::" ,
                stringify ! ( kdcomp ) ));
}
impl Clone for dumperinfo {
    fn clone(&self) -> Self { *self }
}
impl Default for dumperinfo {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
extern "C" {
    #[link_name = "dumping"]
    pub static mut dumping: ::std::os::raw::c_int;
}
extern "C" {
    pub fn doadump(arg1: boolean_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn set_dumper(di: *mut dumperinfo,
                      devname: *const ::std::os::raw::c_char, td: *mut thread,
                      compression: u8, encryption: u8, key: *const u8,
                      encryptedkeysize: u32, encryptedkey: *const u8)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dump_start(di: *mut dumperinfo, kdh: *mut kerneldumpheader)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dump_append(arg1: *mut dumperinfo,
                       arg2: *mut ::std::os::raw::c_void, arg3: vm_offset_t,
                       arg4: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dump_write(arg1: *mut dumperinfo,
                      arg2: *mut ::std::os::raw::c_void, arg3: vm_offset_t,
                      arg4: off_t, arg5: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dump_finish(di: *mut dumperinfo, kdh: *mut kerneldumpheader)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dump_init_header(di: *const dumperinfo, kdh: *mut kerneldumpheader,
                            magic: *mut ::std::os::raw::c_char, archver: u32,
                            dumplen: u64);
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(::std::mem::size_of::<__va_list_tag>() , 24usize , concat ! (
               "Size of: " , stringify ! ( __va_list_tag ) ));
    assert_eq! (::std::mem::align_of::<__va_list_tag>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __va_list_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . gp_offset as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( gp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . fp_offset as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( fp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . overflow_arg_area as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( overflow_arg_area ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . reg_save_area as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( reg_save_area ) ));
}
impl Clone for __va_list_tag {
    fn clone(&self) -> Self { *self }
}
impl Default for __va_list_tag {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct witness {
    pub _address: u8,
}
impl Clone for witness {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct pmap {
    pub _address: u8,
}
impl Clone for pmap {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct amd64tss {
    pub _address: u8,
}
impl Clone for amd64tss {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct user_segment_descriptor {
    pub _address: u8,
}
impl Clone for user_segment_descriptor {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct system_segment_descriptor {
    pub _address: u8,
}
impl Clone for system_segment_descriptor {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct ucred {
    pub _address: u8,
}
impl Clone for ucred {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kerneldumpcomp {
    pub _address: u8,
}
impl Clone for kerneldumpcomp {
    fn clone(&self) -> Self { *self }
}
