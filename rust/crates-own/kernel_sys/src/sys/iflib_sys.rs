/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>);
impl <T> __IncompleteArrayField<T> {
    #[inline]
    pub fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ptr(&self) -> *const T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut_ptr(&mut self) -> *mut T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl <T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
impl <T> ::std::clone::Clone for __IncompleteArrayField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::std::marker::Copy for __IncompleteArrayField<T> { }
#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl <T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self { __BindgenUnionField(::std::marker::PhantomData) }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T { ::std::mem::transmute(self) }
}
impl <T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self { Self::new() }
}
impl <T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::std::marker::Copy for __BindgenUnionField<T> { }
impl <T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl <T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) { }
}
impl <T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool { true }
}
impl <T> ::std::cmp::Eq for __BindgenUnionField<T> { }
pub const __GNUCLIKE_ASM: ::std::os::raw::c_uint = 3;
pub const __GNUCLIKE___TYPEOF: ::std::os::raw::c_uint = 1;
pub const __GNUCLIKE___OFFSETOF: ::std::os::raw::c_uint = 1;
pub const __GNUCLIKE___SECTION: ::std::os::raw::c_uint = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: ::std::os::raw::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: ::std::os::raw::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: ::std::os::raw::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: ::std::os::raw::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: ::std::os::raw::c_uint = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: ::std::os::raw::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: ::std::os::raw::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: ::std::os::raw::c_uint = 1;
pub const __CC_SUPPORTS_INLINE: ::std::os::raw::c_uint = 1;
pub const __CC_SUPPORTS___INLINE: ::std::os::raw::c_uint = 1;
pub const __CC_SUPPORTS___INLINE__: ::std::os::raw::c_uint = 1;
pub const __CC_SUPPORTS___FUNC__: ::std::os::raw::c_uint = 1;
pub const __CC_SUPPORTS_WARNING: ::std::os::raw::c_uint = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: ::std::os::raw::c_uint = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: ::std::os::raw::c_uint = 1;
pub const __POSIX_VISIBLE: ::std::os::raw::c_uint = 200809;
pub const __XSI_VISIBLE: ::std::os::raw::c_uint = 700;
pub const __BSD_VISIBLE: ::std::os::raw::c_uint = 1;
pub const __ISO_C_VISIBLE: ::std::os::raw::c_uint = 2011;
pub const __EXT1_VISIBLE: ::std::os::raw::c_uint = 1;
pub const __CHAR_BIT: ::std::os::raw::c_uint = 8;
pub const __SCHAR_MAX: ::std::os::raw::c_uint = 127;
pub const __SCHAR_MIN: ::std::os::raw::c_int = -128;
pub const __UCHAR_MAX: ::std::os::raw::c_uint = 255;
pub const __USHRT_MAX: ::std::os::raw::c_uint = 65535;
pub const __SHRT_MAX: ::std::os::raw::c_uint = 32767;
pub const __SHRT_MIN: ::std::os::raw::c_int = -32768;
pub const __UINT_MAX: ::std::os::raw::c_uint = 4294967295;
pub const __INT_MAX: ::std::os::raw::c_uint = 2147483647;
pub const __INT_MIN: ::std::os::raw::c_int = -2147483648;
pub const __ULONG_MAX: ::std::os::raw::c_int = -1;
pub const __LONG_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const __LONG_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const __ULLONG_MAX: ::std::os::raw::c_int = -1;
pub const __LLONG_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const __LLONG_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const __SSIZE_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const __SIZE_T_MAX: ::std::os::raw::c_int = -1;
pub const __OFF_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const __OFF_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const __UQUAD_MAX: ::std::os::raw::c_int = -1;
pub const __QUAD_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const __QUAD_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const __LONG_BIT: ::std::os::raw::c_uint = 64;
pub const __WORD_BIT: ::std::os::raw::c_uint = 32;
pub const __MINSIGSTKSZ: ::std::os::raw::c_uint = 2048;
pub const __WCHAR_MIN: ::std::os::raw::c_int = -2147483648;
pub const __WCHAR_MAX: ::std::os::raw::c_uint = 2147483647;
pub const _QUAD_HIGHWORD: ::std::os::raw::c_uint = 1;
pub const _QUAD_LOWWORD: ::std::os::raw::c_uint = 0;
pub const _LITTLE_ENDIAN: ::std::os::raw::c_uint = 1234;
pub const _BIG_ENDIAN: ::std::os::raw::c_uint = 4321;
pub const _PDP_ENDIAN: ::std::os::raw::c_uint = 3412;
pub const _BYTE_ORDER: ::std::os::raw::c_uint = 1234;
pub const LITTLE_ENDIAN: ::std::os::raw::c_uint = 1234;
pub const BIG_ENDIAN: ::std::os::raw::c_uint = 4321;
pub const PDP_ENDIAN: ::std::os::raw::c_uint = 3412;
pub const BYTE_ORDER: ::std::os::raw::c_uint = 1234;
pub const __bool_true_false_are_defined: ::std::os::raw::c_uint = 1;
pub const false_: ::std::os::raw::c_uint = 0;
pub const true_: ::std::os::raw::c_uint = 1;
pub const _SIG_WORDS: ::std::os::raw::c_uint = 4;
pub const _SIG_MAXSIG: ::std::os::raw::c_uint = 128;
pub const FD_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const SOCK_STREAM: ::std::os::raw::c_uint = 1;
pub const SOCK_DGRAM: ::std::os::raw::c_uint = 2;
pub const SOCK_RAW: ::std::os::raw::c_uint = 3;
pub const SOCK_RDM: ::std::os::raw::c_uint = 4;
pub const SOCK_SEQPACKET: ::std::os::raw::c_uint = 5;
pub const SOCK_CLOEXEC: ::std::os::raw::c_uint = 268435456;
pub const SOCK_NONBLOCK: ::std::os::raw::c_uint = 536870912;
pub const ACCEPT4_INHERIT: ::std::os::raw::c_uint = 1;
pub const ACCEPT4_COMPAT: ::std::os::raw::c_uint = 2;
pub const SO_DEBUG: ::std::os::raw::c_uint = 1;
pub const SO_ACCEPTCONN: ::std::os::raw::c_uint = 2;
pub const SO_REUSEADDR: ::std::os::raw::c_uint = 4;
pub const SO_KEEPALIVE: ::std::os::raw::c_uint = 8;
pub const SO_DONTROUTE: ::std::os::raw::c_uint = 16;
pub const SO_BROADCAST: ::std::os::raw::c_uint = 32;
pub const SO_USELOOPBACK: ::std::os::raw::c_uint = 64;
pub const SO_LINGER: ::std::os::raw::c_uint = 128;
pub const SO_OOBINLINE: ::std::os::raw::c_uint = 256;
pub const SO_REUSEPORT: ::std::os::raw::c_uint = 512;
pub const SO_TIMESTAMP: ::std::os::raw::c_uint = 1024;
pub const SO_NOSIGPIPE: ::std::os::raw::c_uint = 2048;
pub const SO_ACCEPTFILTER: ::std::os::raw::c_uint = 4096;
pub const SO_BINTIME: ::std::os::raw::c_uint = 8192;
pub const SO_NO_OFFLOAD: ::std::os::raw::c_uint = 16384;
pub const SO_NO_DDP: ::std::os::raw::c_uint = 32768;
pub const SO_SNDBUF: ::std::os::raw::c_uint = 4097;
pub const SO_RCVBUF: ::std::os::raw::c_uint = 4098;
pub const SO_SNDLOWAT: ::std::os::raw::c_uint = 4099;
pub const SO_RCVLOWAT: ::std::os::raw::c_uint = 4100;
pub const SO_SNDTIMEO: ::std::os::raw::c_uint = 4101;
pub const SO_RCVTIMEO: ::std::os::raw::c_uint = 4102;
pub const SO_ERROR: ::std::os::raw::c_uint = 4103;
pub const SO_TYPE: ::std::os::raw::c_uint = 4104;
pub const SO_LABEL: ::std::os::raw::c_uint = 4105;
pub const SO_PEERLABEL: ::std::os::raw::c_uint = 4112;
pub const SO_LISTENQLIMIT: ::std::os::raw::c_uint = 4113;
pub const SO_LISTENQLEN: ::std::os::raw::c_uint = 4114;
pub const SO_LISTENINCQLEN: ::std::os::raw::c_uint = 4115;
pub const SO_SETFIB: ::std::os::raw::c_uint = 4116;
pub const SO_USER_COOKIE: ::std::os::raw::c_uint = 4117;
pub const SO_PROTOCOL: ::std::os::raw::c_uint = 4118;
pub const SO_PROTOTYPE: ::std::os::raw::c_uint = 4118;
pub const SO_TS_CLOCK: ::std::os::raw::c_uint = 4119;
pub const SO_MAX_PACING_RATE: ::std::os::raw::c_uint = 4120;
pub const SO_TS_REALTIME_MICRO: ::std::os::raw::c_uint = 0;
pub const SO_TS_BINTIME: ::std::os::raw::c_uint = 1;
pub const SO_TS_REALTIME: ::std::os::raw::c_uint = 2;
pub const SO_TS_MONOTONIC: ::std::os::raw::c_uint = 3;
pub const SO_TS_DEFAULT: ::std::os::raw::c_uint = 0;
pub const SO_TS_CLOCK_MAX: ::std::os::raw::c_uint = 3;
pub const SO_VENDOR: ::std::os::raw::c_uint = 2147483648;
pub const SOL_SOCKET: ::std::os::raw::c_uint = 65535;
pub const AF_UNSPEC: ::std::os::raw::c_uint = 0;
pub const AF_UNIX: ::std::os::raw::c_uint = 1;
pub const AF_INET: ::std::os::raw::c_uint = 2;
pub const AF_IMPLINK: ::std::os::raw::c_uint = 3;
pub const AF_PUP: ::std::os::raw::c_uint = 4;
pub const AF_CHAOS: ::std::os::raw::c_uint = 5;
pub const AF_NETBIOS: ::std::os::raw::c_uint = 6;
pub const AF_ISO: ::std::os::raw::c_uint = 7;
pub const AF_OSI: ::std::os::raw::c_uint = 7;
pub const AF_ECMA: ::std::os::raw::c_uint = 8;
pub const AF_DATAKIT: ::std::os::raw::c_uint = 9;
pub const AF_CCITT: ::std::os::raw::c_uint = 10;
pub const AF_SNA: ::std::os::raw::c_uint = 11;
pub const AF_DECnet: ::std::os::raw::c_uint = 12;
pub const AF_DLI: ::std::os::raw::c_uint = 13;
pub const AF_LAT: ::std::os::raw::c_uint = 14;
pub const AF_HYLINK: ::std::os::raw::c_uint = 15;
pub const AF_APPLETALK: ::std::os::raw::c_uint = 16;
pub const AF_ROUTE: ::std::os::raw::c_uint = 17;
pub const AF_LINK: ::std::os::raw::c_uint = 18;
pub const pseudo_AF_XTP: ::std::os::raw::c_uint = 19;
pub const AF_COIP: ::std::os::raw::c_uint = 20;
pub const AF_CNT: ::std::os::raw::c_uint = 21;
pub const pseudo_AF_RTIP: ::std::os::raw::c_uint = 22;
pub const AF_IPX: ::std::os::raw::c_uint = 23;
pub const AF_SIP: ::std::os::raw::c_uint = 24;
pub const pseudo_AF_PIP: ::std::os::raw::c_uint = 25;
pub const AF_ISDN: ::std::os::raw::c_uint = 26;
pub const AF_E164: ::std::os::raw::c_uint = 26;
pub const pseudo_AF_KEY: ::std::os::raw::c_uint = 27;
pub const AF_INET6: ::std::os::raw::c_uint = 28;
pub const AF_NATM: ::std::os::raw::c_uint = 29;
pub const AF_ATM: ::std::os::raw::c_uint = 30;
pub const pseudo_AF_HDRCMPLT: ::std::os::raw::c_uint = 31;
pub const AF_NETGRAPH: ::std::os::raw::c_uint = 32;
pub const AF_SLOW: ::std::os::raw::c_uint = 33;
pub const AF_SCLUSTER: ::std::os::raw::c_uint = 34;
pub const AF_ARP: ::std::os::raw::c_uint = 35;
pub const AF_BLUETOOTH: ::std::os::raw::c_uint = 36;
pub const AF_IEEE80211: ::std::os::raw::c_uint = 37;
pub const AF_INET_SDP: ::std::os::raw::c_uint = 40;
pub const AF_INET6_SDP: ::std::os::raw::c_uint = 42;
pub const AF_MAX: ::std::os::raw::c_uint = 42;
pub const AF_VENDOR00: ::std::os::raw::c_uint = 39;
pub const AF_VENDOR01: ::std::os::raw::c_uint = 41;
pub const AF_VENDOR02: ::std::os::raw::c_uint = 43;
pub const AF_VENDOR03: ::std::os::raw::c_uint = 45;
pub const AF_VENDOR04: ::std::os::raw::c_uint = 47;
pub const AF_VENDOR05: ::std::os::raw::c_uint = 49;
pub const AF_VENDOR06: ::std::os::raw::c_uint = 51;
pub const AF_VENDOR07: ::std::os::raw::c_uint = 53;
pub const AF_VENDOR08: ::std::os::raw::c_uint = 55;
pub const AF_VENDOR09: ::std::os::raw::c_uint = 57;
pub const AF_VENDOR10: ::std::os::raw::c_uint = 59;
pub const AF_VENDOR11: ::std::os::raw::c_uint = 61;
pub const AF_VENDOR12: ::std::os::raw::c_uint = 63;
pub const AF_VENDOR13: ::std::os::raw::c_uint = 65;
pub const AF_VENDOR14: ::std::os::raw::c_uint = 67;
pub const AF_VENDOR15: ::std::os::raw::c_uint = 69;
pub const AF_VENDOR16: ::std::os::raw::c_uint = 71;
pub const AF_VENDOR17: ::std::os::raw::c_uint = 73;
pub const AF_VENDOR18: ::std::os::raw::c_uint = 75;
pub const AF_VENDOR19: ::std::os::raw::c_uint = 77;
pub const AF_VENDOR20: ::std::os::raw::c_uint = 79;
pub const AF_VENDOR21: ::std::os::raw::c_uint = 81;
pub const AF_VENDOR22: ::std::os::raw::c_uint = 83;
pub const AF_VENDOR23: ::std::os::raw::c_uint = 85;
pub const AF_VENDOR24: ::std::os::raw::c_uint = 87;
pub const AF_VENDOR25: ::std::os::raw::c_uint = 89;
pub const AF_VENDOR26: ::std::os::raw::c_uint = 91;
pub const AF_VENDOR27: ::std::os::raw::c_uint = 93;
pub const AF_VENDOR28: ::std::os::raw::c_uint = 95;
pub const AF_VENDOR29: ::std::os::raw::c_uint = 97;
pub const AF_VENDOR30: ::std::os::raw::c_uint = 99;
pub const AF_VENDOR31: ::std::os::raw::c_uint = 101;
pub const AF_VENDOR32: ::std::os::raw::c_uint = 103;
pub const AF_VENDOR33: ::std::os::raw::c_uint = 105;
pub const AF_VENDOR34: ::std::os::raw::c_uint = 107;
pub const AF_VENDOR35: ::std::os::raw::c_uint = 109;
pub const AF_VENDOR36: ::std::os::raw::c_uint = 111;
pub const AF_VENDOR37: ::std::os::raw::c_uint = 113;
pub const AF_VENDOR38: ::std::os::raw::c_uint = 115;
pub const AF_VENDOR39: ::std::os::raw::c_uint = 117;
pub const AF_VENDOR40: ::std::os::raw::c_uint = 119;
pub const AF_VENDOR41: ::std::os::raw::c_uint = 121;
pub const AF_VENDOR42: ::std::os::raw::c_uint = 123;
pub const AF_VENDOR43: ::std::os::raw::c_uint = 125;
pub const AF_VENDOR44: ::std::os::raw::c_uint = 127;
pub const AF_VENDOR45: ::std::os::raw::c_uint = 129;
pub const AF_VENDOR46: ::std::os::raw::c_uint = 131;
pub const AF_VENDOR47: ::std::os::raw::c_uint = 133;
pub const SOCK_MAXADDRLEN: ::std::os::raw::c_uint = 255;
pub const _SS_MAXSIZE: ::std::os::raw::c_uint = 128;
pub const PF_UNSPEC: ::std::os::raw::c_uint = 0;
pub const PF_INET: ::std::os::raw::c_uint = 2;
pub const PF_IMPLINK: ::std::os::raw::c_uint = 3;
pub const PF_PUP: ::std::os::raw::c_uint = 4;
pub const PF_CHAOS: ::std::os::raw::c_uint = 5;
pub const PF_NETBIOS: ::std::os::raw::c_uint = 6;
pub const PF_ISO: ::std::os::raw::c_uint = 7;
pub const PF_OSI: ::std::os::raw::c_uint = 7;
pub const PF_ECMA: ::std::os::raw::c_uint = 8;
pub const PF_DATAKIT: ::std::os::raw::c_uint = 9;
pub const PF_CCITT: ::std::os::raw::c_uint = 10;
pub const PF_SNA: ::std::os::raw::c_uint = 11;
pub const PF_DECnet: ::std::os::raw::c_uint = 12;
pub const PF_DLI: ::std::os::raw::c_uint = 13;
pub const PF_LAT: ::std::os::raw::c_uint = 14;
pub const PF_HYLINK: ::std::os::raw::c_uint = 15;
pub const PF_APPLETALK: ::std::os::raw::c_uint = 16;
pub const PF_ROUTE: ::std::os::raw::c_uint = 17;
pub const PF_LINK: ::std::os::raw::c_uint = 18;
pub const PF_XTP: ::std::os::raw::c_uint = 19;
pub const PF_COIP: ::std::os::raw::c_uint = 20;
pub const PF_CNT: ::std::os::raw::c_uint = 21;
pub const PF_SIP: ::std::os::raw::c_uint = 24;
pub const PF_IPX: ::std::os::raw::c_uint = 23;
pub const PF_RTIP: ::std::os::raw::c_uint = 22;
pub const PF_PIP: ::std::os::raw::c_uint = 25;
pub const PF_ISDN: ::std::os::raw::c_uint = 26;
pub const PF_KEY: ::std::os::raw::c_uint = 27;
pub const PF_INET6: ::std::os::raw::c_uint = 28;
pub const PF_NATM: ::std::os::raw::c_uint = 29;
pub const PF_ATM: ::std::os::raw::c_uint = 30;
pub const PF_NETGRAPH: ::std::os::raw::c_uint = 32;
pub const PF_SLOW: ::std::os::raw::c_uint = 33;
pub const PF_SCLUSTER: ::std::os::raw::c_uint = 34;
pub const PF_ARP: ::std::os::raw::c_uint = 35;
pub const PF_BLUETOOTH: ::std::os::raw::c_uint = 36;
pub const PF_IEEE80211: ::std::os::raw::c_uint = 37;
pub const PF_INET_SDP: ::std::os::raw::c_uint = 40;
pub const PF_INET6_SDP: ::std::os::raw::c_uint = 42;
pub const PF_MAX: ::std::os::raw::c_uint = 42;
pub const NET_RT_DUMP: ::std::os::raw::c_uint = 1;
pub const NET_RT_FLAGS: ::std::os::raw::c_uint = 2;
pub const NET_RT_IFLIST: ::std::os::raw::c_uint = 3;
pub const NET_RT_IFMALIST: ::std::os::raw::c_uint = 4;
pub const NET_RT_IFLISTL: ::std::os::raw::c_uint = 5;
pub const SOMAXCONN: ::std::os::raw::c_uint = 128;
pub const MSG_OOB: ::std::os::raw::c_uint = 1;
pub const MSG_PEEK: ::std::os::raw::c_uint = 2;
pub const MSG_DONTROUTE: ::std::os::raw::c_uint = 4;
pub const MSG_EOR: ::std::os::raw::c_uint = 8;
pub const MSG_TRUNC: ::std::os::raw::c_uint = 16;
pub const MSG_CTRUNC: ::std::os::raw::c_uint = 32;
pub const MSG_WAITALL: ::std::os::raw::c_uint = 64;
pub const MSG_DONTWAIT: ::std::os::raw::c_uint = 128;
pub const MSG_EOF: ::std::os::raw::c_uint = 256;
pub const MSG_NOTIFICATION: ::std::os::raw::c_uint = 8192;
pub const MSG_NBIO: ::std::os::raw::c_uint = 16384;
pub const MSG_COMPAT: ::std::os::raw::c_uint = 32768;
pub const MSG_SOCALLBCK: ::std::os::raw::c_uint = 65536;
pub const MSG_NOSIGNAL: ::std::os::raw::c_uint = 131072;
pub const MSG_CMSG_CLOEXEC: ::std::os::raw::c_uint = 262144;
pub const MSG_WAITFORONE: ::std::os::raw::c_uint = 524288;
pub const MSG_MORETOCOME: ::std::os::raw::c_uint = 1048576;
pub const CMGROUP_MAX: ::std::os::raw::c_uint = 16;
pub const SCM_RIGHTS: ::std::os::raw::c_uint = 1;
pub const SCM_TIMESTAMP: ::std::os::raw::c_uint = 2;
pub const SCM_CREDS: ::std::os::raw::c_uint = 3;
pub const SCM_BINTIME: ::std::os::raw::c_uint = 4;
pub const SCM_REALTIME: ::std::os::raw::c_uint = 5;
pub const SCM_MONOTONIC: ::std::os::raw::c_uint = 6;
pub const SCM_TIME_INFO: ::std::os::raw::c_uint = 7;
pub const ST_INFO_HW: ::std::os::raw::c_uint = 1;
pub const ST_INFO_HW_HPREC: ::std::os::raw::c_uint = 2;
pub const SHUT_RD: ::std::os::raw::c_uint = 0;
pub const SHUT_WR: ::std::os::raw::c_uint = 1;
pub const SHUT_RDWR: ::std::os::raw::c_uint = 2;
pub const PRU_FLUSH_RD: ::std::os::raw::c_uint = 0;
pub const PRU_FLUSH_WR: ::std::os::raw::c_uint = 1;
pub const PRU_FLUSH_RDWR: ::std::os::raw::c_uint = 2;
pub const SF_NODISKIO: ::std::os::raw::c_uint = 1;
pub const SF_MNOWAIT: ::std::os::raw::c_uint = 2;
pub const SF_SYNC: ::std::os::raw::c_uint = 4;
pub const SF_USER_READAHEAD: ::std::os::raw::c_uint = 8;
pub const SF_NOCACHE: ::std::os::raw::c_uint = 16;
pub const IF_NAMESIZE: ::std::os::raw::c_uint = 16;
pub const IFNAMSIZ: ::std::os::raw::c_uint = 16;
pub const IF_MAXUNIT: ::std::os::raw::c_uint = 32767;
pub const IFF_UP: ::std::os::raw::c_uint = 1;
pub const IFF_BROADCAST: ::std::os::raw::c_uint = 2;
pub const IFF_DEBUG: ::std::os::raw::c_uint = 4;
pub const IFF_LOOPBACK: ::std::os::raw::c_uint = 8;
pub const IFF_POINTOPOINT: ::std::os::raw::c_uint = 16;
pub const IFF_DRV_RUNNING: ::std::os::raw::c_uint = 64;
pub const IFF_NOARP: ::std::os::raw::c_uint = 128;
pub const IFF_PROMISC: ::std::os::raw::c_uint = 256;
pub const IFF_ALLMULTI: ::std::os::raw::c_uint = 512;
pub const IFF_DRV_OACTIVE: ::std::os::raw::c_uint = 1024;
pub const IFF_SIMPLEX: ::std::os::raw::c_uint = 2048;
pub const IFF_LINK0: ::std::os::raw::c_uint = 4096;
pub const IFF_LINK1: ::std::os::raw::c_uint = 8192;
pub const IFF_LINK2: ::std::os::raw::c_uint = 16384;
pub const IFF_ALTPHYS: ::std::os::raw::c_uint = 16384;
pub const IFF_MULTICAST: ::std::os::raw::c_uint = 32768;
pub const IFF_CANTCONFIG: ::std::os::raw::c_uint = 65536;
pub const IFF_PPROMISC: ::std::os::raw::c_uint = 131072;
pub const IFF_MONITOR: ::std::os::raw::c_uint = 262144;
pub const IFF_STATICARP: ::std::os::raw::c_uint = 524288;
pub const IFF_DYING: ::std::os::raw::c_uint = 2097152;
pub const IFF_RENAMING: ::std::os::raw::c_uint = 4194304;
pub const IFF_CANTCHANGE: ::std::os::raw::c_uint = 2199378;
pub const LINK_STATE_UNKNOWN: ::std::os::raw::c_uint = 0;
pub const LINK_STATE_DOWN: ::std::os::raw::c_uint = 1;
pub const LINK_STATE_UP: ::std::os::raw::c_uint = 2;
pub const IFCAP_RXCSUM: ::std::os::raw::c_uint = 1;
pub const IFCAP_TXCSUM: ::std::os::raw::c_uint = 2;
pub const IFCAP_NETCONS: ::std::os::raw::c_uint = 4;
pub const IFCAP_VLAN_MTU: ::std::os::raw::c_uint = 8;
pub const IFCAP_VLAN_HWTAGGING: ::std::os::raw::c_uint = 16;
pub const IFCAP_JUMBO_MTU: ::std::os::raw::c_uint = 32;
pub const IFCAP_POLLING: ::std::os::raw::c_uint = 64;
pub const IFCAP_VLAN_HWCSUM: ::std::os::raw::c_uint = 128;
pub const IFCAP_TSO4: ::std::os::raw::c_uint = 256;
pub const IFCAP_TSO6: ::std::os::raw::c_uint = 512;
pub const IFCAP_LRO: ::std::os::raw::c_uint = 1024;
pub const IFCAP_WOL_UCAST: ::std::os::raw::c_uint = 2048;
pub const IFCAP_WOL_MCAST: ::std::os::raw::c_uint = 4096;
pub const IFCAP_WOL_MAGIC: ::std::os::raw::c_uint = 8192;
pub const IFCAP_TOE4: ::std::os::raw::c_uint = 16384;
pub const IFCAP_TOE6: ::std::os::raw::c_uint = 32768;
pub const IFCAP_VLAN_HWFILTER: ::std::os::raw::c_uint = 65536;
pub const IFCAP_VLAN_HWTSO: ::std::os::raw::c_uint = 262144;
pub const IFCAP_LINKSTATE: ::std::os::raw::c_uint = 524288;
pub const IFCAP_NETMAP: ::std::os::raw::c_uint = 1048576;
pub const IFCAP_RXCSUM_IPV6: ::std::os::raw::c_uint = 2097152;
pub const IFCAP_TXCSUM_IPV6: ::std::os::raw::c_uint = 4194304;
pub const IFCAP_HWSTATS: ::std::os::raw::c_uint = 8388608;
pub const IFCAP_TXRTLMT: ::std::os::raw::c_uint = 16777216;
pub const IFCAP_HWRXTSTMP: ::std::os::raw::c_uint = 33554432;
pub const IFCAP_HWCSUM_IPV6: ::std::os::raw::c_uint = 6291456;
pub const IFCAP_HWCSUM: ::std::os::raw::c_uint = 3;
pub const IFCAP_TSO: ::std::os::raw::c_uint = 768;
pub const IFCAP_WOL: ::std::os::raw::c_uint = 14336;
pub const IFCAP_TOE: ::std::os::raw::c_uint = 49152;
pub const IFCAP_CANTCHANGE: ::std::os::raw::c_uint = 1048576;
pub const IFQ_MAXLEN: ::std::os::raw::c_uint = 50;
pub const IFNET_SLOWHZ: ::std::os::raw::c_uint = 1;
pub const IFAN_ARRIVAL: ::std::os::raw::c_uint = 0;
pub const IFAN_DEPARTURE: ::std::os::raw::c_uint = 1;
pub const IFSTATMAX: ::std::os::raw::c_uint = 800;
pub const IFG_ALL: &'static [u8; 4usize] = b"all\x00";
pub const IFG_EGRESS: &'static [u8; 7usize] = b"egress\x00";
pub const RSS_FUNC_NONE: ::std::os::raw::c_uint = 0;
pub const RSS_FUNC_PRIVATE: ::std::os::raw::c_uint = 1;
pub const RSS_FUNC_TOEPLITZ: ::std::os::raw::c_uint = 2;
pub const RSS_TYPE_IPV4: ::std::os::raw::c_uint = 1;
pub const RSS_TYPE_TCP_IPV4: ::std::os::raw::c_uint = 2;
pub const RSS_TYPE_IPV6: ::std::os::raw::c_uint = 4;
pub const RSS_TYPE_IPV6_EX: ::std::os::raw::c_uint = 8;
pub const RSS_TYPE_TCP_IPV6: ::std::os::raw::c_uint = 16;
pub const RSS_TYPE_TCP_IPV6_EX: ::std::os::raw::c_uint = 32;
pub const RSS_TYPE_UDP_IPV4: ::std::os::raw::c_uint = 64;
pub const RSS_TYPE_UDP_IPV6: ::std::os::raw::c_uint = 128;
pub const RSS_TYPE_UDP_IPV6_EX: ::std::os::raw::c_uint = 256;
pub const RSS_KEYLEN: ::std::os::raw::c_uint = 128;
pub const CR4_PGE: ::std::os::raw::c_uint = 128;
pub const INVPCID_ADDR: ::std::os::raw::c_uint = 0;
pub const INVPCID_CTX: ::std::os::raw::c_uint = 1;
pub const INVPCID_CTXGLOB: ::std::os::raw::c_uint = 2;
pub const INVPCID_ALLCTX: ::std::os::raw::c_uint = 3;
pub const MSR_FSBASE: ::std::os::raw::c_uint = 3221225728;
pub const MSR_GSBASE: ::std::os::raw::c_uint = 3221225729;
pub const CALLOUT_LOCAL_ALLOC: ::std::os::raw::c_uint = 1;
pub const CALLOUT_ACTIVE: ::std::os::raw::c_uint = 2;
pub const CALLOUT_PENDING: ::std::os::raw::c_uint = 4;
pub const CALLOUT_MPSAFE: ::std::os::raw::c_uint = 8;
pub const CALLOUT_RETURNUNLOCKED: ::std::os::raw::c_uint = 16;
pub const CALLOUT_SHAREDLOCK: ::std::os::raw::c_uint = 32;
pub const CALLOUT_DFRMIGRATION: ::std::os::raw::c_uint = 64;
pub const CALLOUT_PROCESSED: ::std::os::raw::c_uint = 128;
pub const CALLOUT_DIRECT: ::std::os::raw::c_uint = 256;
pub const C_DIRECT_EXEC: ::std::os::raw::c_uint = 1;
pub const C_PRELBITS: ::std::os::raw::c_uint = 7;
pub const C_PRELRANGE: ::std::os::raw::c_uint = 127;
pub const C_HARDCLOCK: ::std::os::raw::c_uint = 256;
pub const C_ABSOLUTE: ::std::os::raw::c_uint = 512;
pub const C_PRECALC: ::std::os::raw::c_uint = 1024;
pub const CS_DRAIN: ::std::os::raw::c_uint = 1;
pub const CS_EXECUTING: ::std::os::raw::c_uint = 2;
pub const INT8_MIN: ::std::os::raw::c_int = -128;
pub const INT16_MIN: ::std::os::raw::c_int = -32768;
pub const INT32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT8_MAX: ::std::os::raw::c_uint = 127;
pub const INT16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const UINT8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const INT64_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT64_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINT64_MAX: ::std::os::raw::c_int = -1;
pub const INT_LEAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_LEAST16_MIN: ::std::os::raw::c_int = -32768;
pub const INT_LEAST32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_LEAST64_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_LEAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_LEAST16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT_LEAST32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const INT_LEAST64_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINT_LEAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_LEAST16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT_LEAST32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const UINT_LEAST64_MAX: ::std::os::raw::c_int = -1;
pub const INT_FAST8_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_FAST16_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_FAST32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_FAST64_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST8_MAX: ::std::os::raw::c_uint = 2147483647;
pub const INT_FAST16_MAX: ::std::os::raw::c_uint = 2147483647;
pub const INT_FAST32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const INT_FAST64_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINT_FAST8_MAX: ::std::os::raw::c_uint = 4294967295;
pub const UINT_FAST16_MAX: ::std::os::raw::c_uint = 4294967295;
pub const UINT_FAST32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const UINT_FAST64_MAX: ::std::os::raw::c_int = -1;
pub const INTPTR_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INTPTR_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINTPTR_MAX: ::std::os::raw::c_int = -1;
pub const INTMAX_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INTMAX_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINTMAX_MAX: ::std::os::raw::c_int = -1;
pub const PTRDIFF_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const PTRDIFF_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const SIG_ATOMIC_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const SIG_ATOMIC_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const SIZE_MAX: ::std::os::raw::c_int = -1;
pub const WINT_MIN: ::std::os::raw::c_int = -2147483648;
pub const WINT_MAX: ::std::os::raw::c_uint = 2147483647;
pub const __WORDSIZE: ::std::os::raw::c_uint = 64;
pub const WCHAR_MIN: ::std::os::raw::c_int = -2147483648;
pub const WCHAR_MAX: ::std::os::raw::c_uint = 2147483647;
pub const RSIZE_MAX: ::std::os::raw::c_int = -1;
pub const HASH_NOWAIT: ::std::os::raw::c_uint = 1;
pub const HASH_WAITOK: ::std::os::raw::c_uint = 2;
pub const HD_COLUMN_MASK: ::std::os::raw::c_uint = 255;
pub const HD_DELIM_MASK: ::std::os::raw::c_uint = 65280;
pub const HD_OMIT_COUNT: ::std::os::raw::c_uint = 65536;
pub const HD_OMIT_HEX: ::std::os::raw::c_uint = 131072;
pub const HD_OMIT_CHARS: ::std::os::raw::c_uint = 262144;
pub const LIBKERN_LEN_BCD2BIN: ::std::os::raw::c_uint = 154;
pub const LIBKERN_LEN_BIN2BCD: ::std::os::raw::c_uint = 100;
pub const LIBKERN_LEN_HEX2ASCII: ::std::os::raw::c_uint = 36;
pub const ARC4_ENTR_NONE: ::std::os::raw::c_uint = 0;
pub const ARC4_ENTR_HAVE: ::std::os::raw::c_uint = 1;
pub const ARC4_ENTR_SEED: ::std::os::raw::c_uint = 2;
pub const FNM_NOMATCH: ::std::os::raw::c_uint = 1;
pub const FNM_NOESCAPE: ::std::os::raw::c_uint = 1;
pub const FNM_PATHNAME: ::std::os::raw::c_uint = 2;
pub const FNM_PERIOD: ::std::os::raw::c_uint = 4;
pub const FNM_LEADING_DIR: ::std::os::raw::c_uint = 8;
pub const FNM_CASEFOLD: ::std::os::raw::c_uint = 16;
pub const FNM_IGNORECASE: ::std::os::raw::c_uint = 16;
pub const FNM_FILE_NAME: ::std::os::raw::c_uint = 2;
pub const BSD: ::std::os::raw::c_uint = 199506;
pub const BSD4_3: ::std::os::raw::c_uint = 1;
pub const BSD4_4: ::std::os::raw::c_uint = 1;
pub const __FreeBSD_version: ::std::os::raw::c_uint = 1200056;
pub const P_OSREL_SIGWAIT: ::std::os::raw::c_uint = 700000;
pub const P_OSREL_SIGSEGV: ::std::os::raw::c_uint = 700004;
pub const P_OSREL_MAP_ANON: ::std::os::raw::c_uint = 800104;
pub const P_OSREL_MAP_FSTRICT: ::std::os::raw::c_uint = 1100036;
pub const P_OSREL_SHUTDOWN_ENOTCONN: ::std::os::raw::c_uint = 1100077;
pub const P_OSREL_MAP_GUARD: ::std::os::raw::c_uint = 1200035;
pub const P_OSREL_WRFSBASE: ::std::os::raw::c_uint = 1200041;
pub const P_OSREL_CK_CYLGRP: ::std::os::raw::c_uint = 1200046;
pub const P_OSREL_VMTOTAL64: ::std::os::raw::c_uint = 1200054;
pub const ARG_MAX: ::std::os::raw::c_uint = 262144;
pub const CHILD_MAX: ::std::os::raw::c_uint = 40;
pub const MAX_CANON: ::std::os::raw::c_uint = 255;
pub const MAX_INPUT: ::std::os::raw::c_uint = 255;
pub const NAME_MAX: ::std::os::raw::c_uint = 255;
pub const NGROUPS_MAX: ::std::os::raw::c_uint = 1023;
pub const OPEN_MAX: ::std::os::raw::c_uint = 64;
pub const PATH_MAX: ::std::os::raw::c_uint = 1024;
pub const PIPE_BUF: ::std::os::raw::c_uint = 512;
pub const IOV_MAX: ::std::os::raw::c_uint = 1024;
pub const MAXCOMLEN: ::std::os::raw::c_uint = 19;
pub const MAXINTERP: ::std::os::raw::c_uint = 1024;
pub const MAXLOGNAME: ::std::os::raw::c_uint = 33;
pub const MAXUPRC: ::std::os::raw::c_uint = 40;
pub const NCARGS: ::std::os::raw::c_uint = 262144;
pub const NGROUPS: ::std::os::raw::c_uint = 1024;
pub const NOFILE: ::std::os::raw::c_uint = 64;
pub const NOGROUP: ::std::os::raw::c_uint = 65535;
pub const MAXHOSTNAMELEN: ::std::os::raw::c_uint = 256;
pub const SPECNAMELEN: ::std::os::raw::c_uint = 63;
pub const EPERM: ::std::os::raw::c_uint = 1;
pub const ENOENT: ::std::os::raw::c_uint = 2;
pub const ESRCH: ::std::os::raw::c_uint = 3;
pub const EINTR: ::std::os::raw::c_uint = 4;
pub const EIO: ::std::os::raw::c_uint = 5;
pub const ENXIO: ::std::os::raw::c_uint = 6;
pub const E2BIG: ::std::os::raw::c_uint = 7;
pub const ENOEXEC: ::std::os::raw::c_uint = 8;
pub const EBADF: ::std::os::raw::c_uint = 9;
pub const ECHILD: ::std::os::raw::c_uint = 10;
pub const EDEADLK: ::std::os::raw::c_uint = 11;
pub const ENOMEM: ::std::os::raw::c_uint = 12;
pub const EACCES: ::std::os::raw::c_uint = 13;
pub const EFAULT: ::std::os::raw::c_uint = 14;
pub const ENOTBLK: ::std::os::raw::c_uint = 15;
pub const EBUSY: ::std::os::raw::c_uint = 16;
pub const EEXIST: ::std::os::raw::c_uint = 17;
pub const EXDEV: ::std::os::raw::c_uint = 18;
pub const ENODEV: ::std::os::raw::c_uint = 19;
pub const ENOTDIR: ::std::os::raw::c_uint = 20;
pub const EISDIR: ::std::os::raw::c_uint = 21;
pub const EINVAL: ::std::os::raw::c_uint = 22;
pub const ENFILE: ::std::os::raw::c_uint = 23;
pub const EMFILE: ::std::os::raw::c_uint = 24;
pub const ENOTTY: ::std::os::raw::c_uint = 25;
pub const ETXTBSY: ::std::os::raw::c_uint = 26;
pub const EFBIG: ::std::os::raw::c_uint = 27;
pub const ENOSPC: ::std::os::raw::c_uint = 28;
pub const ESPIPE: ::std::os::raw::c_uint = 29;
pub const EROFS: ::std::os::raw::c_uint = 30;
pub const EMLINK: ::std::os::raw::c_uint = 31;
pub const EPIPE: ::std::os::raw::c_uint = 32;
pub const EDOM: ::std::os::raw::c_uint = 33;
pub const ERANGE: ::std::os::raw::c_uint = 34;
pub const EAGAIN: ::std::os::raw::c_uint = 35;
pub const EWOULDBLOCK: ::std::os::raw::c_uint = 35;
pub const EINPROGRESS: ::std::os::raw::c_uint = 36;
pub const EALREADY: ::std::os::raw::c_uint = 37;
pub const ENOTSOCK: ::std::os::raw::c_uint = 38;
pub const EDESTADDRREQ: ::std::os::raw::c_uint = 39;
pub const EMSGSIZE: ::std::os::raw::c_uint = 40;
pub const EPROTOTYPE: ::std::os::raw::c_uint = 41;
pub const ENOPROTOOPT: ::std::os::raw::c_uint = 42;
pub const EPROTONOSUPPORT: ::std::os::raw::c_uint = 43;
pub const ESOCKTNOSUPPORT: ::std::os::raw::c_uint = 44;
pub const EOPNOTSUPP: ::std::os::raw::c_uint = 45;
pub const ENOTSUP: ::std::os::raw::c_uint = 45;
pub const EPFNOSUPPORT: ::std::os::raw::c_uint = 46;
pub const EAFNOSUPPORT: ::std::os::raw::c_uint = 47;
pub const EADDRINUSE: ::std::os::raw::c_uint = 48;
pub const EADDRNOTAVAIL: ::std::os::raw::c_uint = 49;
pub const ENETDOWN: ::std::os::raw::c_uint = 50;
pub const ENETUNREACH: ::std::os::raw::c_uint = 51;
pub const ENETRESET: ::std::os::raw::c_uint = 52;
pub const ECONNABORTED: ::std::os::raw::c_uint = 53;
pub const ECONNRESET: ::std::os::raw::c_uint = 54;
pub const ENOBUFS: ::std::os::raw::c_uint = 55;
pub const EISCONN: ::std::os::raw::c_uint = 56;
pub const ENOTCONN: ::std::os::raw::c_uint = 57;
pub const ESHUTDOWN: ::std::os::raw::c_uint = 58;
pub const ETOOMANYREFS: ::std::os::raw::c_uint = 59;
pub const ETIMEDOUT: ::std::os::raw::c_uint = 60;
pub const ECONNREFUSED: ::std::os::raw::c_uint = 61;
pub const ELOOP: ::std::os::raw::c_uint = 62;
pub const ENAMETOOLONG: ::std::os::raw::c_uint = 63;
pub const EHOSTDOWN: ::std::os::raw::c_uint = 64;
pub const EHOSTUNREACH: ::std::os::raw::c_uint = 65;
pub const ENOTEMPTY: ::std::os::raw::c_uint = 66;
pub const EPROCLIM: ::std::os::raw::c_uint = 67;
pub const EUSERS: ::std::os::raw::c_uint = 68;
pub const EDQUOT: ::std::os::raw::c_uint = 69;
pub const ESTALE: ::std::os::raw::c_uint = 70;
pub const EREMOTE: ::std::os::raw::c_uint = 71;
pub const EBADRPC: ::std::os::raw::c_uint = 72;
pub const ERPCMISMATCH: ::std::os::raw::c_uint = 73;
pub const EPROGUNAVAIL: ::std::os::raw::c_uint = 74;
pub const EPROGMISMATCH: ::std::os::raw::c_uint = 75;
pub const EPROCUNAVAIL: ::std::os::raw::c_uint = 76;
pub const ENOLCK: ::std::os::raw::c_uint = 77;
pub const ENOSYS: ::std::os::raw::c_uint = 78;
pub const EFTYPE: ::std::os::raw::c_uint = 79;
pub const EAUTH: ::std::os::raw::c_uint = 80;
pub const ENEEDAUTH: ::std::os::raw::c_uint = 81;
pub const EIDRM: ::std::os::raw::c_uint = 82;
pub const ENOMSG: ::std::os::raw::c_uint = 83;
pub const EOVERFLOW: ::std::os::raw::c_uint = 84;
pub const ECANCELED: ::std::os::raw::c_uint = 85;
pub const EILSEQ: ::std::os::raw::c_uint = 86;
pub const ENOATTR: ::std::os::raw::c_uint = 87;
pub const EDOOFUS: ::std::os::raw::c_uint = 88;
pub const EBADMSG: ::std::os::raw::c_uint = 89;
pub const EMULTIHOP: ::std::os::raw::c_uint = 90;
pub const ENOLINK: ::std::os::raw::c_uint = 91;
pub const EPROTO: ::std::os::raw::c_uint = 92;
pub const ENOTCAPABLE: ::std::os::raw::c_uint = 93;
pub const ECAPMODE: ::std::os::raw::c_uint = 94;
pub const ENOTRECOVERABLE: ::std::os::raw::c_uint = 95;
pub const EOWNERDEAD: ::std::os::raw::c_uint = 96;
pub const ELAST: ::std::os::raw::c_uint = 96;
pub const ERESTART: ::std::os::raw::c_int = -1;
pub const EJUSTRETURN: ::std::os::raw::c_int = -2;
pub const ENOIOCTL: ::std::os::raw::c_int = -3;
pub const EDIRIOCTL: ::std::os::raw::c_int = -4;
pub const ERELOOKUP: ::std::os::raw::c_int = -5;
pub const DST_NONE: ::std::os::raw::c_uint = 0;
pub const DST_USA: ::std::os::raw::c_uint = 1;
pub const DST_AUST: ::std::os::raw::c_uint = 2;
pub const DST_WET: ::std::os::raw::c_uint = 3;
pub const DST_MET: ::std::os::raw::c_uint = 4;
pub const DST_EET: ::std::os::raw::c_uint = 5;
pub const DST_CAN: ::std::os::raw::c_uint = 6;
pub const SBT_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const ITIMER_REAL: ::std::os::raw::c_uint = 0;
pub const ITIMER_VIRTUAL: ::std::os::raw::c_uint = 1;
pub const ITIMER_PROF: ::std::os::raw::c_uint = 2;
pub const CLOCK_REALTIME: ::std::os::raw::c_uint = 0;
pub const CLOCK_VIRTUAL: ::std::os::raw::c_uint = 1;
pub const CLOCK_PROF: ::std::os::raw::c_uint = 2;
pub const CLOCK_MONOTONIC: ::std::os::raw::c_uint = 4;
pub const CLOCK_UPTIME: ::std::os::raw::c_uint = 5;
pub const CLOCK_UPTIME_PRECISE: ::std::os::raw::c_uint = 7;
pub const CLOCK_UPTIME_FAST: ::std::os::raw::c_uint = 8;
pub const CLOCK_REALTIME_PRECISE: ::std::os::raw::c_uint = 9;
pub const CLOCK_REALTIME_FAST: ::std::os::raw::c_uint = 10;
pub const CLOCK_MONOTONIC_PRECISE: ::std::os::raw::c_uint = 11;
pub const CLOCK_MONOTONIC_FAST: ::std::os::raw::c_uint = 12;
pub const CLOCK_SECOND: ::std::os::raw::c_uint = 13;
pub const CLOCK_THREAD_CPUTIME_ID: ::std::os::raw::c_uint = 14;
pub const CLOCK_PROCESS_CPUTIME_ID: ::std::os::raw::c_uint = 15;
pub const TIMER_RELTIME: ::std::os::raw::c_uint = 0;
pub const TIMER_ABSTIME: ::std::os::raw::c_uint = 1;
pub const CPUCLOCK_WHICH_PID: ::std::os::raw::c_uint = 0;
pub const CPUCLOCK_WHICH_TID: ::std::os::raw::c_uint = 1;
pub const TC_DEFAULTPERC: ::std::os::raw::c_uint = 5;
pub const PRI_ITHD: ::std::os::raw::c_uint = 1;
pub const PRI_REALTIME: ::std::os::raw::c_uint = 2;
pub const PRI_TIMESHARE: ::std::os::raw::c_uint = 3;
pub const PRI_IDLE: ::std::os::raw::c_uint = 4;
pub const PRI_FIFO_BIT: ::std::os::raw::c_uint = 8;
pub const PRI_FIFO: ::std::os::raw::c_uint = 10;
pub const PRI_MIN: ::std::os::raw::c_uint = 0;
pub const PRI_MAX: ::std::os::raw::c_uint = 255;
pub const PRI_MIN_ITHD: ::std::os::raw::c_uint = 0;
pub const PI_REALTIME: ::std::os::raw::c_uint = 0;
pub const PI_AV: ::std::os::raw::c_uint = 4;
pub const PI_NET: ::std::os::raw::c_uint = 8;
pub const PI_DISK: ::std::os::raw::c_uint = 12;
pub const PI_TTY: ::std::os::raw::c_uint = 16;
pub const PI_DULL: ::std::os::raw::c_uint = 20;
pub const PI_SOFT: ::std::os::raw::c_uint = 24;
pub const PRI_MIN_REALTIME: ::std::os::raw::c_uint = 48;
pub const PRI_MIN_KERN: ::std::os::raw::c_uint = 80;
pub const PSWP: ::std::os::raw::c_uint = 80;
pub const PVM: ::std::os::raw::c_uint = 84;
pub const PINOD: ::std::os::raw::c_uint = 88;
pub const PRIBIO: ::std::os::raw::c_uint = 92;
pub const PVFS: ::std::os::raw::c_uint = 96;
pub const PZERO: ::std::os::raw::c_uint = 100;
pub const PSOCK: ::std::os::raw::c_uint = 104;
pub const PWAIT: ::std::os::raw::c_uint = 108;
pub const PLOCK: ::std::os::raw::c_uint = 112;
pub const PPAUSE: ::std::os::raw::c_uint = 116;
pub const PRI_MIN_TIMESHARE: ::std::os::raw::c_uint = 120;
pub const PUSER: ::std::os::raw::c_uint = 120;
pub const PRI_MIN_IDLE: ::std::os::raw::c_uint = 224;
pub const PRI_MAX_IDLE: ::std::os::raw::c_uint = 255;
pub const PRI_USER: ::std::os::raw::c_int = -2;
pub const PRI_UNCHANGED: ::std::os::raw::c_int = -1;
pub const FALSE: ::std::os::raw::c_uint = 0;
pub const TRUE: ::std::os::raw::c_uint = 1;
pub const MACHINE: &'static [u8; 6usize] = b"amd64\x00";
pub const MACHINE_ARCH: &'static [u8; 6usize] = b"amd64\x00";
pub const MACHINE_ARCH32: &'static [u8; 5usize] = b"i386\x00";
pub const MAXCPU: ::std::os::raw::c_uint = 256;
pub const MAXMEMDOM: ::std::os::raw::c_uint = 8;
pub const CACHE_LINE_SHIFT: ::std::os::raw::c_uint = 6;
pub const CACHE_LINE_SIZE: ::std::os::raw::c_uint = 64;
pub const NPTEPGSHIFT: ::std::os::raw::c_uint = 9;
pub const PAGE_SHIFT: ::std::os::raw::c_uint = 12;
pub const PAGE_SIZE: ::std::os::raw::c_uint = 4096;
pub const PAGE_MASK: ::std::os::raw::c_uint = 4095;
pub const NPDEPGSHIFT: ::std::os::raw::c_uint = 9;
pub const PDRSHIFT: ::std::os::raw::c_uint = 21;
pub const NBPDR: ::std::os::raw::c_uint = 2097152;
pub const PDRMASK: ::std::os::raw::c_uint = 2097151;
pub const NPDPEPGSHIFT: ::std::os::raw::c_uint = 9;
pub const PDPSHIFT: ::std::os::raw::c_uint = 30;
pub const NBPDP: ::std::os::raw::c_uint = 1073741824;
pub const PDPMASK: ::std::os::raw::c_uint = 1073741823;
pub const NPML4EPGSHIFT: ::std::os::raw::c_uint = 9;
pub const PML4SHIFT: ::std::os::raw::c_uint = 39;
pub const NBPML4: ::std::os::raw::c_ulonglong = 549755813888;
pub const PML4MASK: ::std::os::raw::c_ulonglong = 549755813887;
pub const MAXPAGESIZES: ::std::os::raw::c_uint = 3;
pub const IOPAGES: ::std::os::raw::c_uint = 2;
pub const IOPERM_BITMAP_SIZE: ::std::os::raw::c_uint = 8193;
pub const KSTACK_PAGES: ::std::os::raw::c_uint = 4;
pub const KSTACK_GUARD_PAGES: ::std::os::raw::c_uint = 1;
pub const DEV_BSHIFT: ::std::os::raw::c_uint = 9;
pub const DEV_BSIZE: ::std::os::raw::c_uint = 512;
pub const BLKDEV_IOSIZE: ::std::os::raw::c_uint = 4096;
pub const DFLTPHYS: ::std::os::raw::c_uint = 65536;
pub const MAXPHYS: ::std::os::raw::c_uint = 131072;
pub const MAXDUMPPGS: ::std::os::raw::c_uint = 16;
pub const MSIZE: ::std::os::raw::c_uint = 256;
pub const MCLSHIFT: ::std::os::raw::c_uint = 11;
pub const MCLBYTES: ::std::os::raw::c_uint = 2048;
pub const MJUMPAGESIZE: ::std::os::raw::c_uint = 4096;
pub const MJUM9BYTES: ::std::os::raw::c_uint = 9216;
pub const MJUM16BYTES: ::std::os::raw::c_uint = 16384;
pub const PRIMASK: ::std::os::raw::c_uint = 255;
pub const PCATCH: ::std::os::raw::c_uint = 256;
pub const PDROP: ::std::os::raw::c_uint = 512;
pub const NZERO: ::std::os::raw::c_uint = 0;
pub const NBBY: ::std::os::raw::c_uint = 8;
pub const CMASK: ::std::os::raw::c_uint = 18;
pub const MAXBSIZE: ::std::os::raw::c_uint = 65536;
pub const MAXBCACHEBUF: ::std::os::raw::c_uint = 65536;
pub const BKVASIZE: ::std::os::raw::c_uint = 16384;
pub const BKVAMASK: ::std::os::raw::c_uint = 16383;
pub const MAXPATHLEN: ::std::os::raw::c_uint = 1024;
pub const MAXSYMLINKS: ::std::os::raw::c_uint = 32;
pub const FSHIFT: ::std::os::raw::c_uint = 11;
pub const FSCALE: ::std::os::raw::c_uint = 2048;
pub const M_NOWAIT: ::std::os::raw::c_uint = 1;
pub const M_WAITOK: ::std::os::raw::c_uint = 2;
pub const M_ZERO: ::std::os::raw::c_uint = 256;
pub const M_NOVM: ::std::os::raw::c_uint = 512;
pub const M_USE_RESERVE: ::std::os::raw::c_uint = 1024;
pub const M_NODUMP: ::std::os::raw::c_uint = 2048;
pub const M_FIRSTFIT: ::std::os::raw::c_uint = 4096;
pub const M_BESTFIT: ::std::os::raw::c_uint = 8192;
pub const M_MAGIC: ::std::os::raw::c_uint = 877983977;
pub const DTMALLOC_PROBE_MALLOC: ::std::os::raw::c_uint = 0;
pub const DTMALLOC_PROBE_FREE: ::std::os::raw::c_uint = 1;
pub const DTMALLOC_PROBE_MAX: ::std::os::raw::c_uint = 2;
pub const MALLOC_TYPE_STREAM_VERSION: ::std::os::raw::c_uint = 1;
pub const MALLOC_MAX_NAME: ::std::os::raw::c_uint = 32;
pub const UMA_SMALLEST_UNIT: ::std::os::raw::c_uint = 16;
pub const UMA_ZONE_PAGEABLE: ::std::os::raw::c_uint = 1;
pub const UMA_ZONE_ZINIT: ::std::os::raw::c_uint = 2;
pub const UMA_ZONE_STATIC: ::std::os::raw::c_uint = 4;
pub const UMA_ZONE_OFFPAGE: ::std::os::raw::c_uint = 8;
pub const UMA_ZONE_MALLOC: ::std::os::raw::c_uint = 16;
pub const UMA_ZONE_NOFREE: ::std::os::raw::c_uint = 32;
pub const UMA_ZONE_MTXCLASS: ::std::os::raw::c_uint = 64;
pub const UMA_ZONE_VM: ::std::os::raw::c_uint = 128;
pub const UMA_ZONE_HASH: ::std::os::raw::c_uint = 256;
pub const UMA_ZONE_SECONDARY: ::std::os::raw::c_uint = 512;
pub const UMA_ZONE_MAXBUCKET: ::std::os::raw::c_uint = 2048;
pub const UMA_ZONE_CACHESPREAD: ::std::os::raw::c_uint = 4096;
pub const UMA_ZONE_VTOSLAB: ::std::os::raw::c_uint = 8192;
pub const UMA_ZONE_NODUMP: ::std::os::raw::c_uint = 16384;
pub const UMA_ZONE_PCPU: ::std::os::raw::c_uint = 32768;
pub const UMA_ZONE_NUMA: ::std::os::raw::c_uint = 65536;
pub const UMA_ZONE_INHERIT: ::std::os::raw::c_uint = 41272;
pub const UMA_ALIGN_CACHE: ::std::os::raw::c_int = -1;
pub const UMA_SLAB_BOOT: ::std::os::raw::c_uint = 1;
pub const UMA_SLAB_KERNEL: ::std::os::raw::c_uint = 4;
pub const UMA_SLAB_PRIV: ::std::os::raw::c_uint = 8;
pub const UMA_SLAB_OFFP: ::std::os::raw::c_uint = 16;
pub const UMA_SLAB_MALLOC: ::std::os::raw::c_uint = 32;
pub const UMA_STREAM_VERSION: ::std::os::raw::c_uint = 1;
pub const UTH_MAX_NAME: ::std::os::raw::c_uint = 32;
pub const UTH_ZONE_SECONDARY: ::std::os::raw::c_uint = 1;
pub const M_EXT: ::std::os::raw::c_uint = 1;
pub const M_PKTHDR: ::std::os::raw::c_uint = 2;
pub const M_EOR: ::std::os::raw::c_uint = 4;
pub const M_RDONLY: ::std::os::raw::c_uint = 8;
pub const M_BCAST: ::std::os::raw::c_uint = 16;
pub const M_MCAST: ::std::os::raw::c_uint = 32;
pub const M_PROMISC: ::std::os::raw::c_uint = 64;
pub const M_VLANTAG: ::std::os::raw::c_uint = 128;
pub const M_UNUSED_8: ::std::os::raw::c_uint = 256;
pub const M_NOFREE: ::std::os::raw::c_uint = 512;
pub const M_TSTMP: ::std::os::raw::c_uint = 1024;
pub const M_TSTMP_HPREC: ::std::os::raw::c_uint = 2048;
pub const M_PROTO1: ::std::os::raw::c_uint = 4096;
pub const M_PROTO2: ::std::os::raw::c_uint = 8192;
pub const M_PROTO3: ::std::os::raw::c_uint = 16384;
pub const M_PROTO4: ::std::os::raw::c_uint = 32768;
pub const M_PROTO5: ::std::os::raw::c_uint = 65536;
pub const M_PROTO6: ::std::os::raw::c_uint = 131072;
pub const M_PROTO7: ::std::os::raw::c_uint = 262144;
pub const M_PROTO8: ::std::os::raw::c_uint = 524288;
pub const M_PROTO9: ::std::os::raw::c_uint = 1048576;
pub const M_PROTO10: ::std::os::raw::c_uint = 2097152;
pub const M_PROTO11: ::std::os::raw::c_uint = 4194304;
pub const M_PROTO12: ::std::os::raw::c_uint = 8388608;
pub const MB_DTOR_SKIP: ::std::os::raw::c_uint = 1;
pub const M_PROTOFLAGS: ::std::os::raw::c_uint = 16773120;
pub const M_COPYFLAGS: ::std::os::raw::c_uint = 16776446;
pub const M_FLAG_BITS: &'static [u8; 101usize] =
    b"\x10\x01M_EXT\\2M_PKTHDR\\3M_EOR\\4M_RDONLY\\5M_BCAST\\6M_MCAST\x07M_PROMISC\\10M_VLANTAG\\13M_TSTMP\\14M_TSTMP_HPREC\x00";
pub const M_FLAG_PROTOBITS: &'static [u8; 130usize] =
    b"\rM_PROTO1\\16M_PROTO2\\17M_PROTO3\\20M_PROTO4\\21M_PROTO5\x12M_PROTO6\\23M_PROTO7\\24M_PROTO8\\25M_PROTO9\\26M_PROTO10\x17M_PROTO11\\30M_PROTO12\x00";
pub const M_FLAG_PRINTF: &'static [u8; 230usize] =
    b"\x10\x01M_EXT\\2M_PKTHDR\\3M_EOR\\4M_RDONLY\\5M_BCAST\\6M_MCAST\x07M_PROMISC\\10M_VLANTAG\\13M_TSTMP\\14M_TSTMP_HPREC\rM_PROTO1\\16M_PROTO2\\17M_PROTO3\\20M_PROTO4\\21M_PROTO5\x12M_PROTO6\\23M_PROTO7\\24M_PROTO8\\25M_PROTO9\\26M_PROTO10\x17M_PROTO11\\30M_PROTO12\x00";
pub const M_HASHTYPE_HASHPROP: ::std::os::raw::c_uint = 128;
pub const M_HASHTYPE_NONE: ::std::os::raw::c_uint = 0;
pub const M_HASHTYPE_OPAQUE: ::std::os::raw::c_uint = 63;
pub const QOS_DSCP_CS0: ::std::os::raw::c_uint = 0;
pub const QOS_DSCP_DEF: ::std::os::raw::c_uint = 0;
pub const QOS_DSCP_CS1: ::std::os::raw::c_uint = 32;
pub const QOS_DSCP_AF11: ::std::os::raw::c_uint = 40;
pub const QOS_DSCP_AF12: ::std::os::raw::c_uint = 48;
pub const QOS_DSCP_AF13: ::std::os::raw::c_uint = 56;
pub const QOS_DSCP_CS2: ::std::os::raw::c_uint = 64;
pub const QOS_DSCP_AF21: ::std::os::raw::c_uint = 72;
pub const QOS_DSCP_AF22: ::std::os::raw::c_uint = 80;
pub const QOS_DSCP_AF23: ::std::os::raw::c_uint = 88;
pub const QOS_DSCP_CS3: ::std::os::raw::c_uint = 96;
pub const QOS_DSCP_AF31: ::std::os::raw::c_uint = 104;
pub const QOS_DSCP_AF32: ::std::os::raw::c_uint = 112;
pub const QOS_DSCP_AF33: ::std::os::raw::c_uint = 120;
pub const QOS_DSCP_CS4: ::std::os::raw::c_uint = 128;
pub const QOS_DSCP_AF41: ::std::os::raw::c_uint = 136;
pub const QOS_DSCP_AF42: ::std::os::raw::c_uint = 144;
pub const QOS_DSCP_AF43: ::std::os::raw::c_uint = 152;
pub const QOS_DSCP_CS5: ::std::os::raw::c_uint = 160;
pub const QOS_DSCP_EF: ::std::os::raw::c_uint = 184;
pub const QOS_DSCP_CS6: ::std::os::raw::c_uint = 192;
pub const QOS_DSCP_CS7: ::std::os::raw::c_uint = 224;
pub const EXT_CLUSTER: ::std::os::raw::c_uint = 1;
pub const EXT_SFBUF: ::std::os::raw::c_uint = 2;
pub const EXT_JUMBOP: ::std::os::raw::c_uint = 3;
pub const EXT_JUMBO9: ::std::os::raw::c_uint = 4;
pub const EXT_JUMBO16: ::std::os::raw::c_uint = 5;
pub const EXT_PACKET: ::std::os::raw::c_uint = 6;
pub const EXT_MBUF: ::std::os::raw::c_uint = 7;
pub const EXT_VENDOR1: ::std::os::raw::c_uint = 224;
pub const EXT_VENDOR2: ::std::os::raw::c_uint = 225;
pub const EXT_VENDOR3: ::std::os::raw::c_uint = 226;
pub const EXT_VENDOR4: ::std::os::raw::c_uint = 227;
pub const EXT_EXP1: ::std::os::raw::c_uint = 244;
pub const EXT_EXP2: ::std::os::raw::c_uint = 245;
pub const EXT_EXP3: ::std::os::raw::c_uint = 246;
pub const EXT_EXP4: ::std::os::raw::c_uint = 247;
pub const EXT_NET_DRV: ::std::os::raw::c_uint = 252;
pub const EXT_MOD_TYPE: ::std::os::raw::c_uint = 253;
pub const EXT_DISPOSABLE: ::std::os::raw::c_uint = 254;
pub const EXT_EXTREF: ::std::os::raw::c_uint = 255;
pub const EXT_FLAG_EMBREF: ::std::os::raw::c_uint = 1;
pub const EXT_FLAG_EXTREF: ::std::os::raw::c_uint = 2;
pub const EXT_FLAG_NOFREE: ::std::os::raw::c_uint = 16;
pub const EXT_FLAG_VENDOR1: ::std::os::raw::c_uint = 65536;
pub const EXT_FLAG_VENDOR2: ::std::os::raw::c_uint = 131072;
pub const EXT_FLAG_VENDOR3: ::std::os::raw::c_uint = 262144;
pub const EXT_FLAG_VENDOR4: ::std::os::raw::c_uint = 524288;
pub const EXT_FLAG_EXP1: ::std::os::raw::c_uint = 1048576;
pub const EXT_FLAG_EXP2: ::std::os::raw::c_uint = 2097152;
pub const EXT_FLAG_EXP3: ::std::os::raw::c_uint = 4194304;
pub const EXT_FLAG_EXP4: ::std::os::raw::c_uint = 8388608;
pub const EXT_FLAG_BITS: &'static [u8; 186usize] =
    b"\x10\x01EXT_FLAG_EMBREF\\2EXT_FLAG_EXTREF\\5EXT_FLAG_NOFREE\x11EXT_FLAG_VENDOR1\\22EXT_FLAG_VENDOR2\\23EXT_FLAG_VENDOR3\x14EXT_FLAG_VENDOR4\\25EXT_FLAG_EXP1\\26EXT_FLAG_EXP2\\27EXT_FLAG_EXP3\x18EXT_FLAG_EXP4\x00";
pub const CSUM_IP: ::std::os::raw::c_uint = 1;
pub const CSUM_IP_UDP: ::std::os::raw::c_uint = 2;
pub const CSUM_IP_TCP: ::std::os::raw::c_uint = 4;
pub const CSUM_IP_SCTP: ::std::os::raw::c_uint = 8;
pub const CSUM_IP_TSO: ::std::os::raw::c_uint = 16;
pub const CSUM_IP_ISCSI: ::std::os::raw::c_uint = 32;
pub const CSUM_IP6_UDP: ::std::os::raw::c_uint = 512;
pub const CSUM_IP6_TCP: ::std::os::raw::c_uint = 1024;
pub const CSUM_IP6_SCTP: ::std::os::raw::c_uint = 2048;
pub const CSUM_IP6_TSO: ::std::os::raw::c_uint = 4096;
pub const CSUM_IP6_ISCSI: ::std::os::raw::c_uint = 8192;
pub const CSUM_L3_CALC: ::std::os::raw::c_uint = 16777216;
pub const CSUM_L3_VALID: ::std::os::raw::c_uint = 33554432;
pub const CSUM_L4_CALC: ::std::os::raw::c_uint = 67108864;
pub const CSUM_L4_VALID: ::std::os::raw::c_uint = 134217728;
pub const CSUM_L5_CALC: ::std::os::raw::c_uint = 268435456;
pub const CSUM_L5_VALID: ::std::os::raw::c_uint = 536870912;
pub const CSUM_COALESCED: ::std::os::raw::c_uint = 1073741824;
pub const CSUM_BITS: &'static [u8; 257usize] =
    b"\x10\x01CSUM_IP\\2CSUM_IP_UDP\\3CSUM_IP_TCP\\4CSUM_IP_SCTP\\5CSUM_IP_TSO\x06CSUM_IP_ISCSI\nCSUM_IP6_UDP\\13CSUM_IP6_TCP\\14CSUM_IP6_SCTP\\15CSUM_IP6_TSO\x0eCSUM_IP6_ISCSI\x19CSUM_L3_CALC\\32CSUM_L3_VALID\\33CSUM_L4_CALC\\34CSUM_L4_VALID\x1dCSUM_L5_CALC\\36CSUM_L5_VALID\\37CSUM_COALESCED\x00";
pub const CSUM_IP_CHECKED: ::std::os::raw::c_uint = 16777216;
pub const CSUM_IP_VALID: ::std::os::raw::c_uint = 33554432;
pub const CSUM_DATA_VALID: ::std::os::raw::c_uint = 134217728;
pub const CSUM_PSEUDO_HDR: ::std::os::raw::c_uint = 67108864;
pub const CSUM_SCTP_VALID: ::std::os::raw::c_uint = 134217728;
pub const CSUM_DELAY_IP: ::std::os::raw::c_uint = 1;
pub const CSUM_DATA_VALID_IPV6: ::std::os::raw::c_uint = 134217728;
pub const CSUM_TCP: ::std::os::raw::c_uint = 4;
pub const CSUM_UDP: ::std::os::raw::c_uint = 2;
pub const CSUM_SCTP: ::std::os::raw::c_uint = 8;
pub const CSUM_TSO: ::std::os::raw::c_uint = 4112;
pub const CSUM_UDP_IPV6: ::std::os::raw::c_uint = 512;
pub const CSUM_TCP_IPV6: ::std::os::raw::c_uint = 1024;
pub const CSUM_SCTP_IPV6: ::std::os::raw::c_uint = 2048;
pub const MT_NOTMBUF: ::std::os::raw::c_uint = 0;
pub const MT_DATA: ::std::os::raw::c_uint = 1;
pub const MT_HEADER: ::std::os::raw::c_uint = 1;
pub const MT_VENDOR1: ::std::os::raw::c_uint = 4;
pub const MT_VENDOR2: ::std::os::raw::c_uint = 5;
pub const MT_VENDOR3: ::std::os::raw::c_uint = 6;
pub const MT_VENDOR4: ::std::os::raw::c_uint = 7;
pub const MT_SONAME: ::std::os::raw::c_uint = 8;
pub const MT_EXP1: ::std::os::raw::c_uint = 9;
pub const MT_EXP2: ::std::os::raw::c_uint = 10;
pub const MT_EXP3: ::std::os::raw::c_uint = 11;
pub const MT_EXP4: ::std::os::raw::c_uint = 12;
pub const MT_CONTROL: ::std::os::raw::c_uint = 14;
pub const MT_OOBDATA: ::std::os::raw::c_uint = 15;
pub const MT_NTYPES: ::std::os::raw::c_uint = 16;
pub const MT_NOINIT: ::std::os::raw::c_uint = 255;
pub const MBUF_MEM_NAME: &'static [u8; 5usize] = b"mbuf\x00";
pub const MBUF_CLUSTER_MEM_NAME: &'static [u8; 13usize] = b"mbuf_cluster\x00";
pub const MBUF_PACKET_MEM_NAME: &'static [u8; 12usize] = b"mbuf_packet\x00";
pub const MBUF_JUMBOP_MEM_NAME: &'static [u8; 16usize] =
    b"mbuf_jumbo_page\x00";
pub const MBUF_JUMBO9_MEM_NAME: &'static [u8; 14usize] = b"mbuf_jumbo_9k\x00";
pub const MBUF_JUMBO16_MEM_NAME: &'static [u8; 15usize] =
    b"mbuf_jumbo_16k\x00";
pub const MBUF_TAG_MEM_NAME: &'static [u8; 9usize] = b"mbuf_tag\x00";
pub const MBUF_EXTREFCNT_MEM_NAME: &'static [u8; 16usize] =
    b"mbuf_ext_refcnt\x00";
pub const M_COPYALL: ::std::os::raw::c_uint = 1000000000;
pub const MTAG_PERSISTENT: ::std::os::raw::c_uint = 2048;
pub const PACKET_TAG_NONE: ::std::os::raw::c_uint = 0;
pub const PACKET_TAG_IPSEC_IN_DONE: ::std::os::raw::c_uint = 1;
pub const PACKET_TAG_IPSEC_OUT_DONE: ::std::os::raw::c_uint = 2;
pub const PACKET_TAG_IPSEC_IN_CRYPTO_DONE: ::std::os::raw::c_uint = 3;
pub const PACKET_TAG_IPSEC_OUT_CRYPTO_NEEDED: ::std::os::raw::c_uint = 4;
pub const PACKET_TAG_IPSEC_IN_COULD_DO_CRYPTO: ::std::os::raw::c_uint = 5;
pub const PACKET_TAG_IPSEC_PENDING_TDB: ::std::os::raw::c_uint = 6;
pub const PACKET_TAG_BRIDGE: ::std::os::raw::c_uint = 7;
pub const PACKET_TAG_GIF: ::std::os::raw::c_uint = 8;
pub const PACKET_TAG_GRE: ::std::os::raw::c_uint = 9;
pub const PACKET_TAG_IN_PACKET_CHECKSUM: ::std::os::raw::c_uint = 10;
pub const PACKET_TAG_ENCAP: ::std::os::raw::c_uint = 11;
pub const PACKET_TAG_IPSEC_SOCKET: ::std::os::raw::c_uint = 12;
pub const PACKET_TAG_IPSEC_HISTORY: ::std::os::raw::c_uint = 13;
pub const PACKET_TAG_IPV6_INPUT: ::std::os::raw::c_uint = 14;
pub const PACKET_TAG_DUMMYNET: ::std::os::raw::c_uint = 15;
pub const PACKET_TAG_DIVERT: ::std::os::raw::c_uint = 17;
pub const PACKET_TAG_IPFORWARD: ::std::os::raw::c_uint = 18;
pub const PACKET_TAG_MACLABEL: ::std::os::raw::c_uint = 2067;
pub const PACKET_TAG_PF: ::std::os::raw::c_uint = 2069;
pub const PACKET_TAG_RTSOCKFAM: ::std::os::raw::c_uint = 25;
pub const PACKET_TAG_IPOPTIONS: ::std::os::raw::c_uint = 27;
pub const PACKET_TAG_CARP: ::std::os::raw::c_uint = 28;
pub const PACKET_TAG_IPSEC_NAT_T_PORTS: ::std::os::raw::c_uint = 29;
pub const PACKET_TAG_ND_OUTGOING: ::std::os::raw::c_uint = 30;
pub const MTAG_ABI_COMPAT: ::std::os::raw::c_uint = 0;
pub const MBUF_HASHFLAG_L2: ::std::os::raw::c_uint = 4;
pub const MBUF_HASHFLAG_L3: ::std::os::raw::c_uint = 8;
pub const MBUF_HASHFLAG_L4: ::std::os::raw::c_uint = 16;
pub const PSL_C: ::std::os::raw::c_uint = 1;
pub const PSL_PF: ::std::os::raw::c_uint = 4;
pub const PSL_AF: ::std::os::raw::c_uint = 16;
pub const PSL_Z: ::std::os::raw::c_uint = 64;
pub const PSL_N: ::std::os::raw::c_uint = 128;
pub const PSL_T: ::std::os::raw::c_uint = 256;
pub const PSL_I: ::std::os::raw::c_uint = 512;
pub const PSL_D: ::std::os::raw::c_uint = 1024;
pub const PSL_V: ::std::os::raw::c_uint = 2048;
pub const PSL_IOPL: ::std::os::raw::c_uint = 12288;
pub const PSL_NT: ::std::os::raw::c_uint = 16384;
pub const PSL_RF: ::std::os::raw::c_uint = 65536;
pub const PSL_VM: ::std::os::raw::c_uint = 131072;
pub const PSL_AC: ::std::os::raw::c_uint = 262144;
pub const PSL_VIF: ::std::os::raw::c_uint = 524288;
pub const PSL_VIP: ::std::os::raw::c_uint = 1048576;
pub const PSL_ID: ::std::os::raw::c_uint = 2097152;
pub const PSL_RESERVED_DEFAULT: ::std::os::raw::c_uint = 2;
pub const PSL_KERNEL: ::std::os::raw::c_uint = 2;
pub const PSL_USER: ::std::os::raw::c_uint = 514;
pub const PSL_USERCHANGE: ::std::os::raw::c_uint = 2444757;
pub const _MACHINE_FRAME_H_: ::std::os::raw::c_uint = 1;
pub const TF_HASSEGS: ::std::os::raw::c_uint = 1;
pub const TF_HASBASES: ::std::os::raw::c_uint = 2;
pub const TF_HASFPXSTATE: ::std::os::raw::c_uint = 4;
pub const SEL_RPL_MASK: ::std::os::raw::c_uint = 3;
pub const SEL_KPL: ::std::os::raw::c_uint = 0;
pub const SEL_UPL: ::std::os::raw::c_uint = 3;
pub const SEL_LDT: ::std::os::raw::c_uint = 4;
pub const SDT_SYSNULL: ::std::os::raw::c_uint = 0;
pub const SDT_SYS286TSS: ::std::os::raw::c_uint = 1;
pub const SDT_SYSLDT: ::std::os::raw::c_uint = 2;
pub const SDT_SYS286BSY: ::std::os::raw::c_uint = 3;
pub const SDT_SYS286CGT: ::std::os::raw::c_uint = 4;
pub const SDT_SYSTASKGT: ::std::os::raw::c_uint = 5;
pub const SDT_SYS286IGT: ::std::os::raw::c_uint = 6;
pub const SDT_SYS286TGT: ::std::os::raw::c_uint = 7;
pub const SDT_SYSNULL2: ::std::os::raw::c_uint = 8;
pub const SDT_SYS386TSS: ::std::os::raw::c_uint = 9;
pub const SDT_SYSTSS: ::std::os::raw::c_uint = 9;
pub const SDT_SYSNULL3: ::std::os::raw::c_uint = 10;
pub const SDT_SYS386BSY: ::std::os::raw::c_uint = 11;
pub const SDT_SYSBSY: ::std::os::raw::c_uint = 11;
pub const SDT_SYS386CGT: ::std::os::raw::c_uint = 12;
pub const SDT_SYSCGT: ::std::os::raw::c_uint = 12;
pub const SDT_SYSNULL4: ::std::os::raw::c_uint = 13;
pub const SDT_SYS386IGT: ::std::os::raw::c_uint = 14;
pub const SDT_SYSIGT: ::std::os::raw::c_uint = 14;
pub const SDT_SYS386TGT: ::std::os::raw::c_uint = 15;
pub const SDT_SYSTGT: ::std::os::raw::c_uint = 15;
pub const SDT_MEMRO: ::std::os::raw::c_uint = 16;
pub const SDT_MEMROA: ::std::os::raw::c_uint = 17;
pub const SDT_MEMRW: ::std::os::raw::c_uint = 18;
pub const SDT_MEMRWA: ::std::os::raw::c_uint = 19;
pub const SDT_MEMROD: ::std::os::raw::c_uint = 20;
pub const SDT_MEMRODA: ::std::os::raw::c_uint = 21;
pub const SDT_MEMRWD: ::std::os::raw::c_uint = 22;
pub const SDT_MEMRWDA: ::std::os::raw::c_uint = 23;
pub const SDT_MEME: ::std::os::raw::c_uint = 24;
pub const SDT_MEMEA: ::std::os::raw::c_uint = 25;
pub const SDT_MEMER: ::std::os::raw::c_uint = 26;
pub const SDT_MEMERA: ::std::os::raw::c_uint = 27;
pub const SDT_MEMEC: ::std::os::raw::c_uint = 28;
pub const SDT_MEMEAC: ::std::os::raw::c_uint = 29;
pub const SDT_MEMERC: ::std::os::raw::c_uint = 30;
pub const SDT_MEMERAC: ::std::os::raw::c_uint = 31;
pub const NIDT: ::std::os::raw::c_uint = 256;
pub const NRSVIDT: ::std::os::raw::c_uint = 32;
pub const IDT_DE: ::std::os::raw::c_uint = 0;
pub const IDT_DB: ::std::os::raw::c_uint = 1;
pub const IDT_NMI: ::std::os::raw::c_uint = 2;
pub const IDT_BP: ::std::os::raw::c_uint = 3;
pub const IDT_OF: ::std::os::raw::c_uint = 4;
pub const IDT_BR: ::std::os::raw::c_uint = 5;
pub const IDT_UD: ::std::os::raw::c_uint = 6;
pub const IDT_NM: ::std::os::raw::c_uint = 7;
pub const IDT_DF: ::std::os::raw::c_uint = 8;
pub const IDT_FPUGP: ::std::os::raw::c_uint = 9;
pub const IDT_TS: ::std::os::raw::c_uint = 10;
pub const IDT_NP: ::std::os::raw::c_uint = 11;
pub const IDT_SS: ::std::os::raw::c_uint = 12;
pub const IDT_GP: ::std::os::raw::c_uint = 13;
pub const IDT_PF: ::std::os::raw::c_uint = 14;
pub const IDT_MF: ::std::os::raw::c_uint = 16;
pub const IDT_AC: ::std::os::raw::c_uint = 17;
pub const IDT_MC: ::std::os::raw::c_uint = 18;
pub const IDT_XF: ::std::os::raw::c_uint = 19;
pub const IDT_IO_INTS: ::std::os::raw::c_uint = 32;
pub const IDT_SYSCALL: ::std::os::raw::c_uint = 128;
pub const IDT_DTRACE_RET: ::std::os::raw::c_uint = 146;
pub const IDT_EVTCHN: ::std::os::raw::c_uint = 147;
pub const GNULL_SEL: ::std::os::raw::c_uint = 0;
pub const GNULL2_SEL: ::std::os::raw::c_uint = 1;
pub const GUFS32_SEL: ::std::os::raw::c_uint = 2;
pub const GUGS32_SEL: ::std::os::raw::c_uint = 3;
pub const GCODE_SEL: ::std::os::raw::c_uint = 4;
pub const GDATA_SEL: ::std::os::raw::c_uint = 5;
pub const GUCODE32_SEL: ::std::os::raw::c_uint = 6;
pub const GUDATA_SEL: ::std::os::raw::c_uint = 7;
pub const GUCODE_SEL: ::std::os::raw::c_uint = 8;
pub const GPROC0_SEL: ::std::os::raw::c_uint = 9;
pub const GUSERLDT_SEL: ::std::os::raw::c_uint = 11;
pub const NGDT: ::std::os::raw::c_uint = 13;
pub const VNET_MAGIC_N: ::std::os::raw::c_uint = 1041076009;
pub const VNET_SETNAME: &'static [u8; 9usize] = b"set_vnet\x00";
pub const VNET_SYMPREFIX: &'static [u8; 12usize] = b"vnet_entry_\x00";
pub const CPU_SETSIZE: ::std::os::raw::c_uint = 256;
pub const CPU_MAXSIZE: ::std::os::raw::c_uint = 256;
pub const PRIO_MIN: ::std::os::raw::c_int = -20;
pub const PRIO_MAX: ::std::os::raw::c_uint = 20;
pub const PRIO_PROCESS: ::std::os::raw::c_uint = 0;
pub const PRIO_PGRP: ::std::os::raw::c_uint = 1;
pub const PRIO_USER: ::std::os::raw::c_uint = 2;
pub const RUSAGE_SELF: ::std::os::raw::c_uint = 0;
pub const RUSAGE_CHILDREN: ::std::os::raw::c_int = -1;
pub const RUSAGE_THREAD: ::std::os::raw::c_uint = 1;
pub const RLIMIT_CPU: ::std::os::raw::c_uint = 0;
pub const RLIMIT_FSIZE: ::std::os::raw::c_uint = 1;
pub const RLIMIT_DATA: ::std::os::raw::c_uint = 2;
pub const RLIMIT_STACK: ::std::os::raw::c_uint = 3;
pub const RLIMIT_CORE: ::std::os::raw::c_uint = 4;
pub const RLIMIT_RSS: ::std::os::raw::c_uint = 5;
pub const RLIMIT_MEMLOCK: ::std::os::raw::c_uint = 6;
pub const RLIMIT_NPROC: ::std::os::raw::c_uint = 7;
pub const RLIMIT_NOFILE: ::std::os::raw::c_uint = 8;
pub const RLIMIT_SBSIZE: ::std::os::raw::c_uint = 9;
pub const RLIMIT_VMEM: ::std::os::raw::c_uint = 10;
pub const RLIMIT_AS: ::std::os::raw::c_uint = 10;
pub const RLIMIT_NPTS: ::std::os::raw::c_uint = 11;
pub const RLIMIT_SWAP: ::std::os::raw::c_uint = 12;
pub const RLIMIT_KQUEUES: ::std::os::raw::c_uint = 13;
pub const RLIMIT_UMTXP: ::std::os::raw::c_uint = 14;
pub const RLIM_NLIMITS: ::std::os::raw::c_uint = 15;
pub const CP_USER: ::std::os::raw::c_uint = 0;
pub const CP_NICE: ::std::os::raw::c_uint = 1;
pub const CP_SYS: ::std::os::raw::c_uint = 2;
pub const CP_INTR: ::std::os::raw::c_uint = 3;
pub const CP_IDLE: ::std::os::raw::c_uint = 4;
pub const CPUSTATES: ::std::os::raw::c_uint = 5;
pub const PC_PTI_STACK_SZ: ::std::os::raw::c_uint = 16;
pub const PC_DBREG_CMD_NONE: ::std::os::raw::c_uint = 0;
pub const PC_DBREG_CMD_LOAD: ::std::os::raw::c_uint = 1;
pub const OFFSETOF_CURTHREAD: ::std::os::raw::c_uint = 0;
pub const OFFSETOF_CURPCB: ::std::os::raw::c_uint = 32;
pub const DPCPU_SETNAME: &'static [u8; 9usize] = b"set_pcpu\x00";
pub const DPCPU_SYMPREFIX: &'static [u8; 12usize] = b"pcpu_entry_\x00";
pub const DPCPU_MODMIN: ::std::os::raw::c_uint = 2048;
pub const KTR_GEN: ::std::os::raw::c_uint = 1;
pub const KTR_NET: ::std::os::raw::c_uint = 2;
pub const KTR_DEV: ::std::os::raw::c_uint = 4;
pub const KTR_LOCK: ::std::os::raw::c_uint = 8;
pub const KTR_SMP: ::std::os::raw::c_uint = 16;
pub const KTR_SUBSYS: ::std::os::raw::c_uint = 32;
pub const KTR_PMAP: ::std::os::raw::c_uint = 64;
pub const KTR_MALLOC: ::std::os::raw::c_uint = 128;
pub const KTR_TRAP: ::std::os::raw::c_uint = 256;
pub const KTR_INTR: ::std::os::raw::c_uint = 512;
pub const KTR_SIG: ::std::os::raw::c_uint = 1024;
pub const KTR_SPARE2: ::std::os::raw::c_uint = 2048;
pub const KTR_PROC: ::std::os::raw::c_uint = 4096;
pub const KTR_SYSC: ::std::os::raw::c_uint = 8192;
pub const KTR_INIT: ::std::os::raw::c_uint = 16384;
pub const KTR_SPARE3: ::std::os::raw::c_uint = 32768;
pub const KTR_SPARE4: ::std::os::raw::c_uint = 65536;
pub const KTR_EVH: ::std::os::raw::c_uint = 131072;
pub const KTR_VFS: ::std::os::raw::c_uint = 262144;
pub const KTR_VOP: ::std::os::raw::c_uint = 524288;
pub const KTR_VM: ::std::os::raw::c_uint = 1048576;
pub const KTR_INET: ::std::os::raw::c_uint = 2097152;
pub const KTR_RUNQ: ::std::os::raw::c_uint = 4194304;
pub const KTR_CONTENTION: ::std::os::raw::c_uint = 8388608;
pub const KTR_UMA: ::std::os::raw::c_uint = 16777216;
pub const KTR_CALLOUT: ::std::os::raw::c_uint = 33554432;
pub const KTR_GEOM: ::std::os::raw::c_uint = 67108864;
pub const KTR_BUSDMA: ::std::os::raw::c_uint = 134217728;
pub const KTR_INET6: ::std::os::raw::c_uint = 268435456;
pub const KTR_SCHED: ::std::os::raw::c_uint = 536870912;
pub const KTR_BUF: ::std::os::raw::c_uint = 1073741824;
pub const KTR_PTRACE: ::std::os::raw::c_uint = 2147483648;
pub const KTR_ALL: ::std::os::raw::c_uint = 4294967295;
pub const KTR_COMPILE: ::std::os::raw::c_uint = 0;
pub const LC_SLEEPLOCK: ::std::os::raw::c_uint = 1;
pub const LC_SPINLOCK: ::std::os::raw::c_uint = 2;
pub const LC_SLEEPABLE: ::std::os::raw::c_uint = 4;
pub const LC_RECURSABLE: ::std::os::raw::c_uint = 8;
pub const LC_UPGRADABLE: ::std::os::raw::c_uint = 16;
pub const LO_CLASSFLAGS: ::std::os::raw::c_uint = 65535;
pub const LO_INITIALIZED: ::std::os::raw::c_uint = 65536;
pub const LO_WITNESS: ::std::os::raw::c_uint = 131072;
pub const LO_QUIET: ::std::os::raw::c_uint = 262144;
pub const LO_RECURSABLE: ::std::os::raw::c_uint = 524288;
pub const LO_SLEEPABLE: ::std::os::raw::c_uint = 1048576;
pub const LO_UPGRADABLE: ::std::os::raw::c_uint = 2097152;
pub const LO_DUPOK: ::std::os::raw::c_uint = 4194304;
pub const LO_IS_VNODE: ::std::os::raw::c_uint = 8388608;
pub const LO_CLASSMASK: ::std::os::raw::c_uint = 251658240;
pub const LO_NOPROFILE: ::std::os::raw::c_uint = 268435456;
pub const LO_NEW: ::std::os::raw::c_uint = 536870912;
pub const LO_CLASSSHIFT: ::std::os::raw::c_uint = 24;
pub const LOCK_CLASS_MAX: ::std::os::raw::c_uint = 15;
pub const LOP_NEWORDER: ::std::os::raw::c_uint = 1;
pub const LOP_QUIET: ::std::os::raw::c_uint = 2;
pub const LOP_TRYLOCK: ::std::os::raw::c_uint = 4;
pub const LOP_EXCLUSIVE: ::std::os::raw::c_uint = 8;
pub const LOP_DUPOK: ::std::os::raw::c_uint = 16;
pub const LA_MASKASSERT: ::std::os::raw::c_uint = 255;
pub const LA_UNLOCKED: ::std::os::raw::c_uint = 0;
pub const LA_LOCKED: ::std::os::raw::c_uint = 1;
pub const LA_SLOCKED: ::std::os::raw::c_uint = 2;
pub const LA_XLOCKED: ::std::os::raw::c_uint = 4;
pub const LA_RECURSED: ::std::os::raw::c_uint = 8;
pub const LA_NOTRECURSED: ::std::os::raw::c_uint = 16;
pub const LOCK_DEBUG: ::std::os::raw::c_uint = 1;
pub const LOCKSTAT_WRITER: ::std::os::raw::c_uint = 0;
pub const LOCKSTAT_READER: ::std::os::raw::c_uint = 1;
pub const MTX_DEF: ::std::os::raw::c_uint = 0;
pub const MTX_SPIN: ::std::os::raw::c_uint = 1;
pub const MTX_RECURSE: ::std::os::raw::c_uint = 4;
pub const MTX_NOWITNESS: ::std::os::raw::c_uint = 8;
pub const MTX_NOPROFILE: ::std::os::raw::c_uint = 32;
pub const MTX_NEW: ::std::os::raw::c_uint = 64;
pub const MTX_QUIET: ::std::os::raw::c_uint = 2;
pub const MTX_DUPOK: ::std::os::raw::c_uint = 16;
pub const MTX_UNOWNED: ::std::os::raw::c_uint = 0;
pub const MTX_RECURSED: ::std::os::raw::c_uint = 1;
pub const MTX_CONTESTED: ::std::os::raw::c_uint = 2;
pub const MTX_DESTROYED: ::std::os::raw::c_uint = 4;
pub const MTX_FLAGMASK: ::std::os::raw::c_uint = 7;
pub const MTX_NETWORK_LOCK: &'static [u8; 15usize] = b"network driver\x00";
pub const RW_LOCK_READ: ::std::os::raw::c_uint = 1;
pub const RW_LOCK_READ_WAITERS: ::std::os::raw::c_uint = 2;
pub const RW_LOCK_WRITE_WAITERS: ::std::os::raw::c_uint = 4;
pub const RW_LOCK_WRITE_SPINNER: ::std::os::raw::c_uint = 8;
pub const RW_LOCK_WRITER_RECURSED: ::std::os::raw::c_uint = 16;
pub const RW_LOCK_FLAGMASK: ::std::os::raw::c_uint = 31;
pub const RW_LOCK_WAITERS: ::std::os::raw::c_uint = 6;
pub const RW_READERS_SHIFT: ::std::os::raw::c_uint = 5;
pub const RW_ONE_READER: ::std::os::raw::c_uint = 32;
pub const RW_DESTROYED: ::std::os::raw::c_uint = 6;
pub const RW_DUPOK: ::std::os::raw::c_uint = 1;
pub const RW_NOPROFILE: ::std::os::raw::c_uint = 2;
pub const RW_NOWITNESS: ::std::os::raw::c_uint = 4;
pub const RW_QUIET: ::std::os::raw::c_uint = 8;
pub const RW_RECURSE: ::std::os::raw::c_uint = 16;
pub const RW_NEW: ::std::os::raw::c_uint = 32;
pub const SX_LOCK_SHARED: ::std::os::raw::c_uint = 1;
pub const SX_LOCK_SHARED_WAITERS: ::std::os::raw::c_uint = 2;
pub const SX_LOCK_EXCLUSIVE_WAITERS: ::std::os::raw::c_uint = 4;
pub const SX_LOCK_RECURSED: ::std::os::raw::c_uint = 8;
pub const SX_LOCK_FLAGMASK: ::std::os::raw::c_uint = 15;
pub const SX_SHARERS_SHIFT: ::std::os::raw::c_uint = 4;
pub const SX_ONE_SHARER: ::std::os::raw::c_uint = 16;
pub const SX_LOCK_DESTROYED: ::std::os::raw::c_uint = 6;
pub const SX_DUPOK: ::std::os::raw::c_uint = 1;
pub const SX_NOPROFILE: ::std::os::raw::c_uint = 2;
pub const SX_NOWITNESS: ::std::os::raw::c_uint = 4;
pub const SX_QUIET: ::std::os::raw::c_uint = 8;
pub const SX_NOADAPTIVE: ::std::os::raw::c_uint = 16;
pub const SX_RECURSE: ::std::os::raw::c_uint = 32;
pub const SX_NEW: ::std::os::raw::c_uint = 64;
pub const SX_INTERRUPTIBLE: ::std::os::raw::c_uint = 64;
pub const GROUPTASK_NAMELEN: ::std::os::raw::c_uint = 32;
pub const IF_DUNIT_NONE: ::std::os::raw::c_int = -1;
pub const EVFILT_READ: ::std::os::raw::c_int = -1;
pub const EVFILT_WRITE: ::std::os::raw::c_int = -2;
pub const EVFILT_AIO: ::std::os::raw::c_int = -3;
pub const EVFILT_VNODE: ::std::os::raw::c_int = -4;
pub const EVFILT_PROC: ::std::os::raw::c_int = -5;
pub const EVFILT_SIGNAL: ::std::os::raw::c_int = -6;
pub const EVFILT_TIMER: ::std::os::raw::c_int = -7;
pub const EVFILT_PROCDESC: ::std::os::raw::c_int = -8;
pub const EVFILT_FS: ::std::os::raw::c_int = -9;
pub const EVFILT_LIO: ::std::os::raw::c_int = -10;
pub const EVFILT_USER: ::std::os::raw::c_int = -11;
pub const EVFILT_SENDFILE: ::std::os::raw::c_int = -12;
pub const EVFILT_EMPTY: ::std::os::raw::c_int = -13;
pub const EVFILT_SYSCOUNT: ::std::os::raw::c_uint = 13;
pub const EV_ADD: ::std::os::raw::c_uint = 1;
pub const EV_DELETE: ::std::os::raw::c_uint = 2;
pub const EV_ENABLE: ::std::os::raw::c_uint = 4;
pub const EV_DISABLE: ::std::os::raw::c_uint = 8;
pub const EV_FORCEONESHOT: ::std::os::raw::c_uint = 256;
pub const EV_ONESHOT: ::std::os::raw::c_uint = 16;
pub const EV_CLEAR: ::std::os::raw::c_uint = 32;
pub const EV_RECEIPT: ::std::os::raw::c_uint = 64;
pub const EV_DISPATCH: ::std::os::raw::c_uint = 128;
pub const EV_SYSFLAGS: ::std::os::raw::c_uint = 61440;
pub const EV_DROP: ::std::os::raw::c_uint = 4096;
pub const EV_FLAG1: ::std::os::raw::c_uint = 8192;
pub const EV_FLAG2: ::std::os::raw::c_uint = 16384;
pub const EV_EOF: ::std::os::raw::c_uint = 32768;
pub const EV_ERROR: ::std::os::raw::c_uint = 16384;
pub const NOTE_FFNOP: ::std::os::raw::c_uint = 0;
pub const NOTE_FFAND: ::std::os::raw::c_uint = 1073741824;
pub const NOTE_FFOR: ::std::os::raw::c_uint = 2147483648;
pub const NOTE_FFCOPY: ::std::os::raw::c_uint = 3221225472;
pub const NOTE_FFCTRLMASK: ::std::os::raw::c_uint = 3221225472;
pub const NOTE_FFLAGSMASK: ::std::os::raw::c_uint = 16777215;
pub const NOTE_TRIGGER: ::std::os::raw::c_uint = 16777216;
pub const NOTE_LOWAT: ::std::os::raw::c_uint = 1;
pub const NOTE_FILE_POLL: ::std::os::raw::c_uint = 2;
pub const NOTE_DELETE: ::std::os::raw::c_uint = 1;
pub const NOTE_WRITE: ::std::os::raw::c_uint = 2;
pub const NOTE_EXTEND: ::std::os::raw::c_uint = 4;
pub const NOTE_ATTRIB: ::std::os::raw::c_uint = 8;
pub const NOTE_LINK: ::std::os::raw::c_uint = 16;
pub const NOTE_RENAME: ::std::os::raw::c_uint = 32;
pub const NOTE_REVOKE: ::std::os::raw::c_uint = 64;
pub const NOTE_OPEN: ::std::os::raw::c_uint = 128;
pub const NOTE_CLOSE: ::std::os::raw::c_uint = 256;
pub const NOTE_CLOSE_WRITE: ::std::os::raw::c_uint = 512;
pub const NOTE_READ: ::std::os::raw::c_uint = 1024;
pub const NOTE_EXIT: ::std::os::raw::c_uint = 2147483648;
pub const NOTE_FORK: ::std::os::raw::c_uint = 1073741824;
pub const NOTE_EXEC: ::std::os::raw::c_uint = 536870912;
pub const NOTE_PCTRLMASK: ::std::os::raw::c_uint = 4026531840;
pub const NOTE_PDATAMASK: ::std::os::raw::c_uint = 1048575;
pub const NOTE_TRACK: ::std::os::raw::c_uint = 1;
pub const NOTE_TRACKERR: ::std::os::raw::c_uint = 2;
pub const NOTE_CHILD: ::std::os::raw::c_uint = 4;
pub const NOTE_SECONDS: ::std::os::raw::c_uint = 1;
pub const NOTE_MSECONDS: ::std::os::raw::c_uint = 2;
pub const NOTE_USECONDS: ::std::os::raw::c_uint = 4;
pub const NOTE_NSECONDS: ::std::os::raw::c_uint = 8;
pub const NOTE_ABSTIME: ::std::os::raw::c_uint = 16;
pub const KNF_LISTLOCKED: ::std::os::raw::c_uint = 1;
pub const KNF_NOKQLOCK: ::std::os::raw::c_uint = 2;
pub const NOTE_SIGNAL: ::std::os::raw::c_uint = 134217728;
pub const EVENT_REGISTER: ::std::os::raw::c_uint = 1;
pub const EVENT_PROCESS: ::std::os::raw::c_uint = 2;
pub const KN_ACTIVE: ::std::os::raw::c_uint = 1;
pub const KN_QUEUED: ::std::os::raw::c_uint = 2;
pub const KN_DISABLED: ::std::os::raw::c_uint = 4;
pub const KN_DETACHED: ::std::os::raw::c_uint = 8;
pub const KN_MARKER: ::std::os::raw::c_uint = 32;
pub const KN_KQUEUE: ::std::os::raw::c_uint = 64;
pub const KN_HASKQLOCK: ::std::os::raw::c_uint = 128;
pub const KN_SCAN: ::std::os::raw::c_uint = 256;
pub const ALTQF_READY: ::std::os::raw::c_uint = 1;
pub const ALTQF_ENABLED: ::std::os::raw::c_uint = 2;
pub const ALTQF_CLASSIFY: ::std::os::raw::c_uint = 4;
pub const ALTQF_CNDTNING: ::std::os::raw::c_uint = 8;
pub const ALTQF_DRIVER1: ::std::os::raw::c_uint = 64;
pub const ALTQF_CANTCHANGE: ::std::os::raw::c_uint = 1;
pub const ALTDQ_REMOVE: ::std::os::raw::c_uint = 1;
pub const ALTDQ_POLL: ::std::os::raw::c_uint = 2;
pub const ALTRQ_PURGE: ::std::os::raw::c_uint = 1;
pub const HHOOK_IPSEC_INET: ::std::os::raw::c_uint = 0;
pub const HHOOK_IPSEC_INET6: ::std::os::raw::c_uint = 1;
pub const HHOOK_IPSEC_COUNT: ::std::os::raw::c_uint = 2;
pub const IFENCAP_FLAG_BROADCAST: ::std::os::raw::c_uint = 2;
pub const IF_SND_TAG_TYPE_RATE_LIMIT: ::std::os::raw::c_uint = 0;
pub const IF_SND_TAG_TYPE_UNLIMITED: ::std::os::raw::c_uint = 1;
pub const IF_SND_TAG_TYPE_MAX: ::std::os::raw::c_uint = 2;
pub const IF_SND_QUEUE_LEVEL_MIN: ::std::os::raw::c_uint = 0;
pub const IF_SND_QUEUE_LEVEL_MAX: ::std::os::raw::c_uint = 65535;
pub const IF_MINMTU: ::std::os::raw::c_uint = 72;
pub const IF_MAXMTU: ::std::os::raw::c_uint = 65535;
pub const ETHER_ADDR_LEN: ::std::os::raw::c_uint = 6;
pub const ETHER_TYPE_LEN: ::std::os::raw::c_uint = 2;
pub const ETHER_CRC_LEN: ::std::os::raw::c_uint = 4;
pub const ETHER_HDR_LEN: ::std::os::raw::c_uint = 14;
pub const ETHER_MIN_LEN: ::std::os::raw::c_uint = 64;
pub const ETHER_MAX_LEN: ::std::os::raw::c_uint = 1518;
pub const ETHER_MAX_LEN_JUMBO: ::std::os::raw::c_uint = 9018;
pub const ETHER_VLAN_ENCAP_LEN: ::std::os::raw::c_uint = 4;
pub const ETHER_ALIGN: ::std::os::raw::c_uint = 2;
pub const M_HASFCS: ::std::os::raw::c_uint = 65536;
pub const ETHER_CRC_POLY_LE: ::std::os::raw::c_uint = 3988292384;
pub const ETHER_CRC_POLY_BE: ::std::os::raw::c_uint = 79764918;
pub const EVL_VLID_MASK: ::std::os::raw::c_uint = 4095;
pub const EVL_PRI_MASK: ::std::os::raw::c_uint = 57344;
pub const ETHERTYPE_8023: ::std::os::raw::c_uint = 4;
pub const ETHERTYPE_PUP: ::std::os::raw::c_uint = 512;
pub const ETHERTYPE_PUPAT: ::std::os::raw::c_uint = 512;
pub const ETHERTYPE_SPRITE: ::std::os::raw::c_uint = 1280;
pub const ETHERTYPE_NS: ::std::os::raw::c_uint = 1536;
pub const ETHERTYPE_NSAT: ::std::os::raw::c_uint = 1537;
pub const ETHERTYPE_DLOG1: ::std::os::raw::c_uint = 1632;
pub const ETHERTYPE_DLOG2: ::std::os::raw::c_uint = 1633;
pub const ETHERTYPE_IP: ::std::os::raw::c_uint = 2048;
pub const ETHERTYPE_X75: ::std::os::raw::c_uint = 2049;
pub const ETHERTYPE_NBS: ::std::os::raw::c_uint = 2050;
pub const ETHERTYPE_ECMA: ::std::os::raw::c_uint = 2051;
pub const ETHERTYPE_CHAOS: ::std::os::raw::c_uint = 2052;
pub const ETHERTYPE_X25: ::std::os::raw::c_uint = 2053;
pub const ETHERTYPE_ARP: ::std::os::raw::c_uint = 2054;
pub const ETHERTYPE_NSCOMPAT: ::std::os::raw::c_uint = 2055;
pub const ETHERTYPE_FRARP: ::std::os::raw::c_uint = 2056;
pub const ETHERTYPE_UBDEBUG: ::std::os::raw::c_uint = 2304;
pub const ETHERTYPE_IEEEPUP: ::std::os::raw::c_uint = 2560;
pub const ETHERTYPE_IEEEPUPAT: ::std::os::raw::c_uint = 2561;
pub const ETHERTYPE_VINES: ::std::os::raw::c_uint = 2989;
pub const ETHERTYPE_VINESLOOP: ::std::os::raw::c_uint = 2990;
pub const ETHERTYPE_VINESECHO: ::std::os::raw::c_uint = 2991;
pub const ETHERTYPE_TRAIL: ::std::os::raw::c_uint = 4096;
pub const ETHERTYPE_NTRAILER: ::std::os::raw::c_uint = 16;
pub const ETHERTYPE_DCA: ::std::os::raw::c_uint = 4660;
pub const ETHERTYPE_VALID: ::std::os::raw::c_uint = 5632;
pub const ETHERTYPE_DOGFIGHT: ::std::os::raw::c_uint = 6537;
pub const ETHERTYPE_RCL: ::std::os::raw::c_uint = 6549;
pub const ETHERTYPE_NBPVCD: ::std::os::raw::c_uint = 15360;
pub const ETHERTYPE_NBPSCD: ::std::os::raw::c_uint = 15361;
pub const ETHERTYPE_NBPCREQ: ::std::os::raw::c_uint = 15362;
pub const ETHERTYPE_NBPCRSP: ::std::os::raw::c_uint = 15363;
pub const ETHERTYPE_NBPCC: ::std::os::raw::c_uint = 15364;
pub const ETHERTYPE_NBPCLREQ: ::std::os::raw::c_uint = 15365;
pub const ETHERTYPE_NBPCLRSP: ::std::os::raw::c_uint = 15366;
pub const ETHERTYPE_NBPDG: ::std::os::raw::c_uint = 15367;
pub const ETHERTYPE_NBPDGB: ::std::os::raw::c_uint = 15368;
pub const ETHERTYPE_NBPCLAIM: ::std::os::raw::c_uint = 15369;
pub const ETHERTYPE_NBPDLTE: ::std::os::raw::c_uint = 15370;
pub const ETHERTYPE_NBPRAS: ::std::os::raw::c_uint = 15371;
pub const ETHERTYPE_NBPRAR: ::std::os::raw::c_uint = 15372;
pub const ETHERTYPE_NBPRST: ::std::os::raw::c_uint = 15373;
pub const ETHERTYPE_PCS: ::std::os::raw::c_uint = 16962;
pub const ETHERTYPE_IMLBLDIAG: ::std::os::raw::c_uint = 16972;
pub const ETHERTYPE_DIDDLE: ::std::os::raw::c_uint = 17185;
pub const ETHERTYPE_IMLBL: ::std::os::raw::c_uint = 19522;
pub const ETHERTYPE_SIMNET: ::std::os::raw::c_uint = 21000;
pub const ETHERTYPE_DECEXPER: ::std::os::raw::c_uint = 24576;
pub const ETHERTYPE_MOPDL: ::std::os::raw::c_uint = 24577;
pub const ETHERTYPE_MOPRC: ::std::os::raw::c_uint = 24578;
pub const ETHERTYPE_DECnet: ::std::os::raw::c_uint = 24579;
pub const ETHERTYPE_DN: ::std::os::raw::c_uint = 24579;
pub const ETHERTYPE_LAT: ::std::os::raw::c_uint = 24580;
pub const ETHERTYPE_DECDIAG: ::std::os::raw::c_uint = 24581;
pub const ETHERTYPE_DECCUST: ::std::os::raw::c_uint = 24582;
pub const ETHERTYPE_SCA: ::std::os::raw::c_uint = 24583;
pub const ETHERTYPE_AMBER: ::std::os::raw::c_uint = 24584;
pub const ETHERTYPE_DECMUMPS: ::std::os::raw::c_uint = 24585;
pub const ETHERTYPE_TRANSETHER: ::std::os::raw::c_uint = 25944;
pub const ETHERTYPE_RAWFR: ::std::os::raw::c_uint = 25945;
pub const ETHERTYPE_UBDL: ::std::os::raw::c_uint = 28672;
pub const ETHERTYPE_UBNIU: ::std::os::raw::c_uint = 28673;
pub const ETHERTYPE_UBDIAGLOOP: ::std::os::raw::c_uint = 28674;
pub const ETHERTYPE_UBNMC: ::std::os::raw::c_uint = 28675;
pub const ETHERTYPE_UBBST: ::std::os::raw::c_uint = 28677;
pub const ETHERTYPE_OS9: ::std::os::raw::c_uint = 28679;
pub const ETHERTYPE_OS9NET: ::std::os::raw::c_uint = 28681;
pub const ETHERTYPE_RACAL: ::std::os::raw::c_uint = 28720;
pub const ETHERTYPE_PRIMENTS: ::std::os::raw::c_uint = 28721;
pub const ETHERTYPE_CABLETRON: ::std::os::raw::c_uint = 28724;
pub const ETHERTYPE_CRONUSVLN: ::std::os::raw::c_uint = 32771;
pub const ETHERTYPE_CRONUS: ::std::os::raw::c_uint = 32772;
pub const ETHERTYPE_HP: ::std::os::raw::c_uint = 32773;
pub const ETHERTYPE_NESTAR: ::std::os::raw::c_uint = 32774;
pub const ETHERTYPE_ATTSTANFORD: ::std::os::raw::c_uint = 32776;
pub const ETHERTYPE_EXCELAN: ::std::os::raw::c_uint = 32784;
pub const ETHERTYPE_SG_DIAG: ::std::os::raw::c_uint = 32787;
pub const ETHERTYPE_SG_NETGAMES: ::std::os::raw::c_uint = 32788;
pub const ETHERTYPE_SG_RESV: ::std::os::raw::c_uint = 32789;
pub const ETHERTYPE_SG_BOUNCE: ::std::os::raw::c_uint = 32790;
pub const ETHERTYPE_APOLLODOMAIN: ::std::os::raw::c_uint = 32793;
pub const ETHERTYPE_TYMSHARE: ::std::os::raw::c_uint = 32814;
pub const ETHERTYPE_TIGAN: ::std::os::raw::c_uint = 32815;
pub const ETHERTYPE_REVARP: ::std::os::raw::c_uint = 32821;
pub const ETHERTYPE_AEONIC: ::std::os::raw::c_uint = 32822;
pub const ETHERTYPE_IPXNEW: ::std::os::raw::c_uint = 32823;
pub const ETHERTYPE_LANBRIDGE: ::std::os::raw::c_uint = 32824;
pub const ETHERTYPE_DSMD: ::std::os::raw::c_uint = 32825;
pub const ETHERTYPE_ARGONAUT: ::std::os::raw::c_uint = 32826;
pub const ETHERTYPE_VAXELN: ::std::os::raw::c_uint = 32827;
pub const ETHERTYPE_DECDNS: ::std::os::raw::c_uint = 32828;
pub const ETHERTYPE_ENCRYPT: ::std::os::raw::c_uint = 32829;
pub const ETHERTYPE_DECDTS: ::std::os::raw::c_uint = 32830;
pub const ETHERTYPE_DECLTM: ::std::os::raw::c_uint = 32831;
pub const ETHERTYPE_DECNETBIOS: ::std::os::raw::c_uint = 32832;
pub const ETHERTYPE_DECLAST: ::std::os::raw::c_uint = 32833;
pub const ETHERTYPE_PLANNING: ::std::os::raw::c_uint = 32836;
pub const ETHERTYPE_DECAM: ::std::os::raw::c_uint = 32840;
pub const ETHERTYPE_EXPERDATA: ::std::os::raw::c_uint = 32841;
pub const ETHERTYPE_VEXP: ::std::os::raw::c_uint = 32859;
pub const ETHERTYPE_VPROD: ::std::os::raw::c_uint = 32860;
pub const ETHERTYPE_ES: ::std::os::raw::c_uint = 32861;
pub const ETHERTYPE_LITTLE: ::std::os::raw::c_uint = 32864;
pub const ETHERTYPE_COUNTERPOINT: ::std::os::raw::c_uint = 32866;
pub const ETHERTYPE_VEECO: ::std::os::raw::c_uint = 32871;
pub const ETHERTYPE_GENDYN: ::std::os::raw::c_uint = 32872;
pub const ETHERTYPE_ATT: ::std::os::raw::c_uint = 32873;
pub const ETHERTYPE_AUTOPHON: ::std::os::raw::c_uint = 32874;
pub const ETHERTYPE_COMDESIGN: ::std::os::raw::c_uint = 32876;
pub const ETHERTYPE_COMPUGRAPHIC: ::std::os::raw::c_uint = 32877;
pub const ETHERTYPE_MATRA: ::std::os::raw::c_uint = 32890;
pub const ETHERTYPE_DDE: ::std::os::raw::c_uint = 32891;
pub const ETHERTYPE_MERIT: ::std::os::raw::c_uint = 32892;
pub const ETHERTYPE_VLTLMAN: ::std::os::raw::c_uint = 32896;
pub const ETHERTYPE_ATALK: ::std::os::raw::c_uint = 32923;
pub const ETHERTYPE_AT: ::std::os::raw::c_uint = 32923;
pub const ETHERTYPE_APPLETALK: ::std::os::raw::c_uint = 32923;
pub const ETHERTYPE_SPIDER: ::std::os::raw::c_uint = 32927;
pub const ETHERTYPE_PACER: ::std::os::raw::c_uint = 32966;
pub const ETHERTYPE_APPLITEK: ::std::os::raw::c_uint = 32967;
pub const ETHERTYPE_SNA: ::std::os::raw::c_uint = 32981;
pub const ETHERTYPE_VARIAN: ::std::os::raw::c_uint = 32989;
pub const ETHERTYPE_RETIX: ::std::os::raw::c_uint = 33010;
pub const ETHERTYPE_AARP: ::std::os::raw::c_uint = 33011;
pub const ETHERTYPE_APOLLO: ::std::os::raw::c_uint = 33015;
pub const ETHERTYPE_VLAN: ::std::os::raw::c_uint = 33024;
pub const ETHERTYPE_BOFL: ::std::os::raw::c_uint = 33026;
pub const ETHERTYPE_WELLFLEET: ::std::os::raw::c_uint = 33027;
pub const ETHERTYPE_TALARIS: ::std::os::raw::c_uint = 33067;
pub const ETHERTYPE_WATERLOO: ::std::os::raw::c_uint = 33072;
pub const ETHERTYPE_HAYES: ::std::os::raw::c_uint = 33072;
pub const ETHERTYPE_VGLAB: ::std::os::raw::c_uint = 33073;
pub const ETHERTYPE_IPX: ::std::os::raw::c_uint = 33079;
pub const ETHERTYPE_NOVELL: ::std::os::raw::c_uint = 33080;
pub const ETHERTYPE_MUMPS: ::std::os::raw::c_uint = 33087;
pub const ETHERTYPE_AMOEBA: ::std::os::raw::c_uint = 33093;
pub const ETHERTYPE_FLIP: ::std::os::raw::c_uint = 33094;
pub const ETHERTYPE_VURESERVED: ::std::os::raw::c_uint = 33095;
pub const ETHERTYPE_LOGICRAFT: ::std::os::raw::c_uint = 33096;
pub const ETHERTYPE_NCD: ::std::os::raw::c_uint = 33097;
pub const ETHERTYPE_ALPHA: ::std::os::raw::c_uint = 33098;
pub const ETHERTYPE_SNMP: ::std::os::raw::c_uint = 33100;
pub const ETHERTYPE_TEC: ::std::os::raw::c_uint = 33103;
pub const ETHERTYPE_RATIONAL: ::std::os::raw::c_uint = 33104;
pub const ETHERTYPE_XTP: ::std::os::raw::c_uint = 33149;
pub const ETHERTYPE_SGITW: ::std::os::raw::c_uint = 33150;
pub const ETHERTYPE_HIPPI_FP: ::std::os::raw::c_uint = 33152;
pub const ETHERTYPE_STP: ::std::os::raw::c_uint = 33153;
pub const ETHERTYPE_MOTOROLA: ::std::os::raw::c_uint = 33165;
pub const ETHERTYPE_NETBEUI: ::std::os::raw::c_uint = 33169;
pub const ETHERTYPE_ACCTON: ::std::os::raw::c_uint = 33680;
pub const ETHERTYPE_TALARISMC: ::std::os::raw::c_uint = 34091;
pub const ETHERTYPE_KALPANA: ::std::os::raw::c_uint = 34178;
pub const ETHERTYPE_SECTRA: ::std::os::raw::c_uint = 34523;
pub const ETHERTYPE_IPV6: ::std::os::raw::c_uint = 34525;
pub const ETHERTYPE_DELTACON: ::std::os::raw::c_uint = 34526;
pub const ETHERTYPE_ATOMIC: ::std::os::raw::c_uint = 34527;
pub const ETHERTYPE_RDP: ::std::os::raw::c_uint = 34617;
pub const ETHERTYPE_MICP: ::std::os::raw::c_uint = 34618;
pub const ETHERTYPE_TCPCOMP: ::std::os::raw::c_uint = 34667;
pub const ETHERTYPE_IPAS: ::std::os::raw::c_uint = 34668;
pub const ETHERTYPE_SECUREDATA: ::std::os::raw::c_uint = 34669;
pub const ETHERTYPE_FLOWCONTROL: ::std::os::raw::c_uint = 34824;
pub const ETHERTYPE_SLOW: ::std::os::raw::c_uint = 34825;
pub const ETHERTYPE_PPP: ::std::os::raw::c_uint = 34827;
pub const ETHERTYPE_HITACHI: ::std::os::raw::c_uint = 34848;
pub const ETHERTYPE_TEST: ::std::os::raw::c_uint = 34850;
pub const ETHERTYPE_MPLS: ::std::os::raw::c_uint = 34887;
pub const ETHERTYPE_MPLS_MCAST: ::std::os::raw::c_uint = 34888;
pub const ETHERTYPE_AXIS: ::std::os::raw::c_uint = 34902;
pub const ETHERTYPE_PPPOEDISC: ::std::os::raw::c_uint = 34915;
pub const ETHERTYPE_PPPOE: ::std::os::raw::c_uint = 34916;
pub const ETHERTYPE_LANPROBE: ::std::os::raw::c_uint = 34952;
pub const ETHERTYPE_PAE: ::std::os::raw::c_uint = 34958;
pub const ETHERTYPE_LOOPBACK: ::std::os::raw::c_uint = 36864;
pub const ETHERTYPE_LBACK: ::std::os::raw::c_uint = 36864;
pub const ETHERTYPE_XNSSM: ::std::os::raw::c_uint = 36865;
pub const ETHERTYPE_TCPSM: ::std::os::raw::c_uint = 36866;
pub const ETHERTYPE_BCLOOP: ::std::os::raw::c_uint = 36867;
pub const ETHERTYPE_DEBNI: ::std::os::raw::c_uint = 43690;
pub const ETHERTYPE_SONIX: ::std::os::raw::c_uint = 64245;
pub const ETHERTYPE_VITAL: ::std::os::raw::c_uint = 65280;
pub const ETHERTYPE_MAX: ::std::os::raw::c_uint = 65535;
pub const ETHERMTU: ::std::os::raw::c_uint = 1500;
pub const ETHERMIN: ::std::os::raw::c_uint = 46;
pub const ETHERMTU_JUMBO: ::std::os::raw::c_uint = 9000;
pub const KOBJ_CACHE_SIZE: ::std::os::raw::c_uint = 256;
pub const IOCPARM_SHIFT: ::std::os::raw::c_uint = 13;
pub const IOCPARM_MASK: ::std::os::raw::c_uint = 8191;
pub const IOCPARM_MAX: ::std::os::raw::c_uint = 8192;
pub const IOC_VOID: ::std::os::raw::c_uint = 536870912;
pub const IOC_OUT: ::std::os::raw::c_uint = 1073741824;
pub const IOC_IN: ::std::os::raw::c_uint = 2147483648;
pub const IOC_INOUT: ::std::os::raw::c_uint = 3221225472;
pub const IOC_DIRMASK: ::std::os::raw::c_uint = 3758096384;
pub const BUS_USER_VERSION: ::std::os::raw::c_uint = 1;
pub const DF_ENABLED: ::std::os::raw::c_uint = 1;
pub const DF_FIXEDCLASS: ::std::os::raw::c_uint = 2;
pub const DF_WILDCARD: ::std::os::raw::c_uint = 4;
pub const DF_DESCMALLOCED: ::std::os::raw::c_uint = 8;
pub const DF_QUIET: ::std::os::raw::c_uint = 16;
pub const DF_DONENOMATCH: ::std::os::raw::c_uint = 32;
pub const DF_EXTERNALSOFTC: ::std::os::raw::c_uint = 64;
pub const DF_REBID: ::std::os::raw::c_uint = 128;
pub const DF_SUSPENDED: ::std::os::raw::c_uint = 256;
pub const DEVF_FORCE_DETACH: ::std::os::raw::c_uint = 1;
pub const DEVF_SET_DRIVER_DETACH: ::std::os::raw::c_uint = 1;
pub const DEVF_CLEAR_DRIVER_DETACH: ::std::os::raw::c_uint = 1;
pub const DEVF_FORCE_DELETE: ::std::os::raw::c_uint = 1;
pub const KTR_VERSION: ::std::os::raw::c_uint = 2;
pub const KTR_PARMS: ::std::os::raw::c_uint = 6;
pub const EHE_DEAD_PRIORITY: ::std::os::raw::c_int = -1;
pub const EVENTHANDLER_PRI_FIRST: ::std::os::raw::c_uint = 0;
pub const EVENTHANDLER_PRI_ANY: ::std::os::raw::c_uint = 10000;
pub const EVENTHANDLER_PRI_LAST: ::std::os::raw::c_uint = 20000;
pub const SHUTDOWN_PRI_FIRST: ::std::os::raw::c_uint = 0;
pub const SHUTDOWN_PRI_DEFAULT: ::std::os::raw::c_uint = 10000;
pub const SHUTDOWN_PRI_LAST: ::std::os::raw::c_uint = 20000;
pub const LOWMEM_PRI_DEFAULT: ::std::os::raw::c_uint = 0;
pub const FILTER_STRAY: ::std::os::raw::c_uint = 1;
pub const FILTER_HANDLED: ::std::os::raw::c_uint = 2;
pub const FILTER_SCHEDULE_THREAD: ::std::os::raw::c_uint = 4;
pub const RLE_RESERVED: ::std::os::raw::c_uint = 1;
pub const RLE_ALLOCATED: ::std::os::raw::c_uint = 2;
pub const RLE_PREFETCH: ::std::os::raw::c_uint = 4;
pub const BUS_PROBE_SPECIFIC: ::std::os::raw::c_uint = 0;
pub const BUS_PROBE_VENDOR: ::std::os::raw::c_int = -10;
pub const BUS_PROBE_DEFAULT: ::std::os::raw::c_int = -20;
pub const BUS_PROBE_LOW_PRIORITY: ::std::os::raw::c_int = -40;
pub const BUS_PROBE_GENERIC: ::std::os::raw::c_int = -100;
pub const BUS_PROBE_HOOVER: ::std::os::raw::c_int = -1000000;
pub const BUS_PROBE_NOWILDCARD: ::std::os::raw::c_int = -2000000000;
pub const BUS_PASS_ROOT: ::std::os::raw::c_uint = 0;
pub const BUS_PASS_BUS: ::std::os::raw::c_uint = 10;
pub const BUS_PASS_CPU: ::std::os::raw::c_uint = 20;
pub const BUS_PASS_RESOURCE: ::std::os::raw::c_uint = 30;
pub const BUS_PASS_INTERRUPT: ::std::os::raw::c_uint = 40;
pub const BUS_PASS_TIMER: ::std::os::raw::c_uint = 50;
pub const BUS_PASS_SCHEDULER: ::std::os::raw::c_uint = 60;
pub const BUS_PASS_DEFAULT: ::std::os::raw::c_uint = 2147483647;
pub const BUS_PASS_ORDER_FIRST: ::std::os::raw::c_uint = 0;
pub const BUS_PASS_ORDER_EARLY: ::std::os::raw::c_uint = 2;
pub const BUS_PASS_ORDER_MIDDLE: ::std::os::raw::c_uint = 5;
pub const BUS_PASS_ORDER_LATE: ::std::os::raw::c_uint = 7;
pub const BUS_PASS_ORDER_LAST: ::std::os::raw::c_uint = 9;
pub const CPU_LEVEL_ROOT: ::std::os::raw::c_uint = 1;
pub const CPU_LEVEL_CPUSET: ::std::os::raw::c_uint = 2;
pub const CPU_LEVEL_WHICH: ::std::os::raw::c_uint = 3;
pub const CPU_WHICH_TID: ::std::os::raw::c_uint = 1;
pub const CPU_WHICH_PID: ::std::os::raw::c_uint = 2;
pub const CPU_WHICH_CPUSET: ::std::os::raw::c_uint = 3;
pub const CPU_WHICH_IRQ: ::std::os::raw::c_uint = 4;
pub const CPU_WHICH_JAIL: ::std::os::raw::c_uint = 5;
pub const CPU_WHICH_DOMAIN: ::std::os::raw::c_uint = 6;
pub const CPU_WHICH_INTRHANDLER: ::std::os::raw::c_uint = 7;
pub const CPU_WHICH_ITHREAD: ::std::os::raw::c_uint = 8;
pub const CPUSET_INVALID: ::std::os::raw::c_int = -1;
pub const CPUSET_DEFAULT: ::std::os::raw::c_uint = 0;
pub const CPU_SET_ROOT: ::std::os::raw::c_uint = 1;
pub const CPU_SET_RDONLY: ::std::os::raw::c_uint = 2;
pub const X86_BUS_SPACE_IO: ::std::os::raw::c_uint = 0;
pub const X86_BUS_SPACE_MEM: ::std::os::raw::c_uint = 1;
pub const BUS_SPACE_MAXSIZE_24BIT: ::std::os::raw::c_uint = 16777215;
pub const BUS_SPACE_MAXSIZE_32BIT: ::std::os::raw::c_uint = 4294967295;
pub const BUS_SPACE_MAXSIZE: ::std::os::raw::c_uint = 4294967295;
pub const BUS_SPACE_MAXADDR_24BIT: ::std::os::raw::c_uint = 16777215;
pub const BUS_SPACE_MAXADDR_32BIT: ::std::os::raw::c_uint = 4294967295;
pub const BUS_SPACE_MAXADDR_48BIT: ::std::os::raw::c_ulonglong =
    281474976710655;
pub const BUS_SPACE_MAXADDR: ::std::os::raw::c_int = -1;
pub const BUS_SPACE_INVALID_DATA: ::std::os::raw::c_int = -1;
pub const BUS_SPACE_UNRESTRICTED: ::std::os::raw::c_int = -1;
pub const BUS_SPACE_BARRIER_READ: ::std::os::raw::c_uint = 1;
pub const BUS_SPACE_BARRIER_WRITE: ::std::os::raw::c_uint = 2;
pub const BUS_DMA_WAITOK: ::std::os::raw::c_uint = 0;
pub const BUS_DMA_NOWAIT: ::std::os::raw::c_uint = 1;
pub const BUS_DMA_ALLOCNOW: ::std::os::raw::c_uint = 2;
pub const BUS_DMA_COHERENT: ::std::os::raw::c_uint = 4;
pub const BUS_DMA_ZERO: ::std::os::raw::c_uint = 8;
pub const BUS_DMA_BUS1: ::std::os::raw::c_uint = 16;
pub const BUS_DMA_BUS2: ::std::os::raw::c_uint = 32;
pub const BUS_DMA_BUS3: ::std::os::raw::c_uint = 64;
pub const BUS_DMA_BUS4: ::std::os::raw::c_uint = 128;
pub const BUS_DMA_NOWRITE: ::std::os::raw::c_uint = 256;
pub const BUS_DMA_NOCACHE: ::std::os::raw::c_uint = 512;
pub const BUS_DMA_KEEP_PG_OFFSET: ::std::os::raw::c_uint = 1024;
pub const BUS_DMA_LOAD_MBUF: ::std::os::raw::c_uint = 2048;
pub const BUS_DMASYNC_PREREAD: ::std::os::raw::c_uint = 1;
pub const BUS_DMASYNC_POSTREAD: ::std::os::raw::c_uint = 2;
pub const BUS_DMASYNC_PREWRITE: ::std::os::raw::c_uint = 4;
pub const BUS_DMASYNC_POSTWRITE: ::std::os::raw::c_uint = 8;
pub const NV_NAME_MAX: ::std::os::raw::c_uint = 2048;
pub const NV_TYPE_NONE: ::std::os::raw::c_uint = 0;
pub const NV_TYPE_NULL: ::std::os::raw::c_uint = 1;
pub const NV_TYPE_BOOL: ::std::os::raw::c_uint = 2;
pub const NV_TYPE_NUMBER: ::std::os::raw::c_uint = 3;
pub const NV_TYPE_STRING: ::std::os::raw::c_uint = 4;
pub const NV_TYPE_NVLIST: ::std::os::raw::c_uint = 5;
pub const NV_TYPE_DESCRIPTOR: ::std::os::raw::c_uint = 6;
pub const NV_TYPE_BINARY: ::std::os::raw::c_uint = 7;
pub const NV_TYPE_BOOL_ARRAY: ::std::os::raw::c_uint = 8;
pub const NV_TYPE_NUMBER_ARRAY: ::std::os::raw::c_uint = 9;
pub const NV_TYPE_STRING_ARRAY: ::std::os::raw::c_uint = 10;
pub const NV_TYPE_NVLIST_ARRAY: ::std::os::raw::c_uint = 11;
pub const NV_TYPE_DESCRIPTOR_ARRAY: ::std::os::raw::c_uint = 12;
pub const NV_FLAG_IGNORE_CASE: ::std::os::raw::c_uint = 1;
pub const NV_FLAG_NO_UNIQUE: ::std::os::raw::c_uint = 2;
pub const TASKQUEUE_NAMELEN: ::std::os::raw::c_uint = 32;
pub const TASK_ENQUEUED: ::std::os::raw::c_uint = 1;
pub const TASK_SKIP_WAKEUP: ::std::os::raw::c_uint = 2;
pub const QIDX_INVALID: ::std::os::raw::c_uint = 65535;
pub const FREEBSD_TSO_SIZE_MAX: ::std::os::raw::c_uint = 65518;
pub const IPI_TX_INTR: ::std::os::raw::c_uint = 1;
pub const IPI_TX_IPV4: ::std::os::raw::c_uint = 2;
pub const IPI_TX_IPV6: ::std::os::raw::c_uint = 4;
pub const IFLIB_PNP_DESCR: &'static [u8; 77usize] =
    b"U32:vendor;U32:device;U32:subvendor;U32:subdevice;U32:revision;U32:class;D:#\x00";
pub const IFLIB_MAGIC: ::std::os::raw::c_uint = 3405705229;
pub const ETH_ADDR_LEN: ::std::os::raw::c_uint = 6;
pub const IFLIB_HAS_RXCQ: ::std::os::raw::c_uint = 1;
pub const IFLIB_SKIP_MSIX: ::std::os::raw::c_uint = 2;
pub const IFLIB_IS_VF: ::std::os::raw::c_uint = 4;
pub const IFLIB_HAS_TXCQ: ::std::os::raw::c_uint = 8;
pub const IFLIB_NEED_SCRATCH: ::std::os::raw::c_uint = 16;
pub const IFLIB_TSO_INIT_IP: ::std::os::raw::c_uint = 32;
pub const IFLIB_DO_RX_FIXUP: ::std::os::raw::c_uint = 64;
pub const IFLIB_NEED_ZERO_CSUM: ::std::os::raw::c_uint = 128;
pub const IFLIB_NEED_ETHER_PAD: ::std::os::raw::c_uint = 256;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __clock_t = __int32_t;
pub type __critical_t = __int64_t;
pub type __double_t = f64;
pub type __float_t = f32;
pub type __intfptr_t = __int64_t;
pub type __intptr_t = __int64_t;
pub type __intmax_t = __int64_t;
pub type __int_fast8_t = __int32_t;
pub type __int_fast16_t = __int32_t;
pub type __int_fast32_t = __int32_t;
pub type __int_fast64_t = __int64_t;
pub type __int_least8_t = __int8_t;
pub type __int_least16_t = __int16_t;
pub type __int_least32_t = __int32_t;
pub type __int_least64_t = __int64_t;
pub type __ptrdiff_t = __int64_t;
pub type __register_t = __int64_t;
pub type __segsz_t = __int64_t;
pub type __size_t = __uint64_t;
pub type __ssize_t = __int64_t;
pub type __time_t = __int64_t;
pub type __uintfptr_t = __uint64_t;
pub type __uintptr_t = __uint64_t;
pub type __uintmax_t = __uint64_t;
pub type __uint_fast8_t = __uint32_t;
pub type __uint_fast16_t = __uint32_t;
pub type __uint_fast32_t = __uint32_t;
pub type __uint_fast64_t = __uint64_t;
pub type __uint_least8_t = __uint8_t;
pub type __uint_least16_t = __uint16_t;
pub type __uint_least32_t = __uint32_t;
pub type __uint_least64_t = __uint64_t;
pub type __u_register_t = __uint64_t;
pub type __vm_offset_t = __uint64_t;
pub type __vm_paddr_t = __uint64_t;
pub type __vm_size_t = __uint64_t;
pub type ___wchar_t = ::std::os::raw::c_int;
pub type __va_list = __builtin_va_list;
pub type __gnuc_va_list = __va_list;
pub type __blksize_t = __int32_t;
pub type __blkcnt_t = __int64_t;
pub type __clockid_t = __int32_t;
pub type __fflags_t = __uint32_t;
pub type __fsblkcnt_t = __uint64_t;
pub type __fsfilcnt_t = __uint64_t;
pub type __gid_t = __uint32_t;
pub type __id_t = __int64_t;
pub type __ino_t = __uint64_t;
pub type __key_t = ::std::os::raw::c_long;
pub type __lwpid_t = __int32_t;
pub type __mode_t = __uint16_t;
pub type __accmode_t = ::std::os::raw::c_int;
pub type __nl_item = ::std::os::raw::c_int;
pub type __nlink_t = __uint64_t;
pub type __off_t = __int64_t;
pub type __off64_t = __int64_t;
pub type __pid_t = __int32_t;
pub type __rlim_t = __int64_t;
pub type __sa_family_t = __uint8_t;
pub type __socklen_t = __uint32_t;
pub type __suseconds_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __timer {
    _unused: [u8; 0],
}
pub type __timer_t = *mut __timer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __mq {
    _unused: [u8; 0],
}
pub type __mqd_t = *mut __mq;
pub type __uid_t = __uint32_t;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __cpuwhich_t = ::std::os::raw::c_int;
pub type __cpulevel_t = ::std::os::raw::c_int;
pub type __cpusetid_t = ::std::os::raw::c_int;
pub type __ct_rune_t = ::std::os::raw::c_int;
pub type __rune_t = __ct_rune_t;
pub type __wint_t = __ct_rune_t;
pub type __char16_t = __uint_least16_t;
pub type __char32_t = __uint_least32_t;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct __max_align_t {
    pub __max_align1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __max_align2: f64,
}
#[test]
fn bindgen_test_layout___max_align_t() {
    assert_eq!(::std::mem::size_of::<__max_align_t>() , 32usize , concat ! (
               "Size of: " , stringify ! ( __max_align_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __max_align_t ) ) . __max_align1 as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __max_align_t ) , "::"
                , stringify ! ( __max_align1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __max_align_t ) ) . __max_align2 as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __max_align_t ) , "::"
                , stringify ! ( __max_align2 ) ));
}
impl Clone for __max_align_t {
    fn clone(&self) -> Self { *self }
}
pub type __dev_t = __uint64_t;
pub type __fixpt_t = __uint32_t;
#[repr(C)]
#[derive(Copy)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: __int64_t,
    _bindgen_union_align: [u64; 16usize],
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(::std::mem::size_of::<__mbstate_t>() , 128usize , concat ! (
               "Size of: " , stringify ! ( __mbstate_t ) ));
    assert_eq! (::std::mem::align_of::<__mbstate_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __mbstate_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . __mbstate8 as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( __mbstate8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . _mbstateL as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( _mbstateL ) ));
}
impl Clone for __mbstate_t {
    fn clone(&self) -> Self { *self }
}
impl Default for __mbstate_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl ::std::fmt::Debug for __mbstate_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f , "__mbstate_t {{ union }}")
    }
}
pub type __rman_res_t = __uintmax_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_cond {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_cond_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutex {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutex_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_once {
    pub state: ::std::os::raw::c_int,
    pub mutex: pthread_mutex_t,
}
#[test]
fn bindgen_test_layout_pthread_once() {
    assert_eq!(::std::mem::size_of::<pthread_once>() , 16usize , concat ! (
               "Size of: " , stringify ! ( pthread_once ) ));
    assert_eq! (::std::mem::align_of::<pthread_once>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_once ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_once ) ) . state as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_once ) , "::" ,
                stringify ! ( state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_once ) ) . mutex as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_once ) , "::" ,
                stringify ! ( mutex ) ));
}
impl Clone for pthread_once {
    fn clone(&self) -> Self { *self }
}
impl Default for pthread_once {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_rwlock {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_rwlockattr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_barrier {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_barrier_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_spinlock {
    _unused: [u8; 0],
}
pub type pthread_t = *mut pthread;
pub type pthread_attr_t = *mut pthread_attr;
pub type pthread_mutex_t = *mut pthread_mutex;
pub type pthread_mutexattr_t = *mut pthread_mutex_attr;
pub type pthread_cond_t = *mut pthread_cond;
pub type pthread_condattr_t = *mut pthread_cond_attr;
pub type pthread_key_t = ::std::os::raw::c_int;
pub type pthread_once_t = pthread_once;
pub type pthread_rwlock_t = *mut pthread_rwlock;
pub type pthread_rwlockattr_t = *mut pthread_rwlockattr;
pub type pthread_barrier_t = *mut pthread_barrier;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_barrierattr {
    _unused: [u8; 0],
}
pub type pthread_barrierattr_t = *mut pthread_barrierattr;
pub type pthread_spinlock_t = *mut pthread_spinlock;
pub type pthread_addr_t = *mut ::std::os::raw::c_void;
pub type pthread_startroutine_t =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void)
                              -> *mut ::std::os::raw::c_void>;
pub type u_char = ::std::os::raw::c_uchar;
pub type u_short = ::std::os::raw::c_ushort;
pub type u_int = ::std::os::raw::c_uint;
pub type u_long = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type u_quad_t = __uint64_t;
pub type quad_t = __int64_t;
pub type qaddr_t = *mut quad_t;
pub type caddr_t = *mut ::std::os::raw::c_char;
pub type c_caddr_t = *const ::std::os::raw::c_char;
pub type blksize_t = __blksize_t;
pub type cpuwhich_t = __cpuwhich_t;
pub type cpulevel_t = __cpulevel_t;
pub type cpusetid_t = __cpusetid_t;
pub type blkcnt_t = __blkcnt_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type critical_t = __critical_t;
pub type daddr_t = __int64_t;
pub type dev_t = __dev_t;
pub type fflags_t = __fflags_t;
pub type fixpt_t = __fixpt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type gid_t = __gid_t;
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type id_t = __id_t;
pub type ino_t = __ino_t;
pub type key_t = __key_t;
pub type lwpid_t = __lwpid_t;
pub type mode_t = __mode_t;
pub type accmode_t = __accmode_t;
pub type nlink_t = __nlink_t;
pub type off_t = __off_t;
pub type off64_t = __off64_t;
pub type pid_t = __pid_t;
pub type register_t = __register_t;
pub type rlim_t = __rlim_t;
pub type sbintime_t = __int64_t;
pub type segsz_t = __segsz_t;
pub type suseconds_t = __suseconds_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type mqd_t = __mqd_t;
pub type u_register_t = __u_register_t;
pub type uid_t = __uid_t;
pub type useconds_t = __useconds_t;
pub type cap_ioctl_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cap_rights {
    _unused: [u8; 0],
}
pub type cap_rights_t = cap_rights;
pub type vm_offset_t = __vm_offset_t;
pub type vm_ooffset_t = __int64_t;
pub type vm_paddr_t = __vm_paddr_t;
pub type vm_pindex_t = __uint64_t;
pub type vm_size_t = __vm_size_t;
pub type rman_res_t = __rman_res_t;
pub type boolean_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct device {
    _unused: [u8; 0],
}
pub type device_t = *mut device;
pub type intfptr_t = __intfptr_t;
pub type intrmask_t = __uint32_t;
pub type uintfptr_t = __uintfptr_t;
pub type uoff_t = __uint64_t;
pub type vm_memattr_t = ::std::os::raw::c_char;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_page {
    _unused: [u8; 0],
}
pub type vm_page_t = *mut vm_page;
pub type bool_ = bool;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct __sigset {
    pub __bits: [__uint32_t; 4usize],
}
#[test]
fn bindgen_test_layout___sigset() {
    assert_eq!(::std::mem::size_of::<__sigset>() , 16usize , concat ! (
               "Size of: " , stringify ! ( __sigset ) ));
    assert_eq! (::std::mem::align_of::<__sigset>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( __sigset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sigset ) ) . __bits as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sigset ) , "::" ,
                stringify ! ( __bits ) ));
}
impl Clone for __sigset {
    fn clone(&self) -> Self { *self }
}
pub type __sigset_t = __sigset;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct timeval {
    pub tv_sec: time_t,
    pub tv_usec: suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(::std::mem::size_of::<timeval>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timeval ) ));
    assert_eq! (::std::mem::align_of::<timeval>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timeval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_usec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_usec ) ));
}
impl Clone for timeval {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(::std::mem::size_of::<timespec>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timespec ) ));
    assert_eq! (::std::mem::align_of::<timespec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timespec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_nsec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_nsec ) ));
}
impl Clone for timespec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(::std::mem::size_of::<itimerspec>() , 32usize , concat ! (
               "Size of: " , stringify ! ( itimerspec ) ));
    assert_eq! (::std::mem::align_of::<itimerspec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( itimerspec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerspec ) ) . it_interval as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerspec ) , "::" ,
                stringify ! ( it_interval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerspec ) ) . it_value as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerspec ) , "::" ,
                stringify ! ( it_value ) ));
}
impl Clone for itimerspec {
    fn clone(&self) -> Self { *self }
}
pub type __fd_mask = ::std::os::raw::c_ulong;
pub type fd_mask = __fd_mask;
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(::std::mem::size_of::<fd_set>() , 128usize , concat ! (
               "Size of: " , stringify ! ( fd_set ) ));
    assert_eq! (::std::mem::align_of::<fd_set>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( fd_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fd_set ) ) . __fds_bits as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( fd_set ) , "::" ,
                stringify ! ( __fds_bits ) ));
}
impl Clone for fd_set {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct iovec {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: usize,
}
#[test]
fn bindgen_test_layout_iovec() {
    assert_eq!(::std::mem::size_of::<iovec>() , 16usize , concat ! (
               "Size of: " , stringify ! ( iovec ) ));
    assert_eq! (::std::mem::align_of::<iovec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( iovec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const iovec ) ) . iov_base as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( iovec ) , "::" ,
                stringify ! ( iov_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const iovec ) ) . iov_len as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( iovec ) , "::" ,
                stringify ! ( iov_len ) ));
}
impl Clone for iovec {
    fn clone(&self) -> Self { *self }
}
impl Default for iovec {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type sa_family_t = __sa_family_t;
pub type socklen_t = __socklen_t;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct linger {
    pub l_onoff: ::std::os::raw::c_int,
    pub l_linger: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_linger() {
    assert_eq!(::std::mem::size_of::<linger>() , 8usize , concat ! (
               "Size of: " , stringify ! ( linger ) ));
    assert_eq! (::std::mem::align_of::<linger>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( linger ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const linger ) ) . l_onoff as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( linger ) , "::" ,
                stringify ! ( l_onoff ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const linger ) ) . l_linger as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( linger ) , "::" ,
                stringify ! ( l_linger ) ));
}
impl Clone for linger {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct accept_filter_arg {
    pub af_name: [::std::os::raw::c_char; 16usize],
    pub af_arg: [::std::os::raw::c_char; 240usize],
}
#[test]
fn bindgen_test_layout_accept_filter_arg() {
    assert_eq!(::std::mem::size_of::<accept_filter_arg>() , 256usize , concat
               ! ( "Size of: " , stringify ! ( accept_filter_arg ) ));
    assert_eq! (::std::mem::align_of::<accept_filter_arg>() , 1usize , concat
                ! ( "Alignment of " , stringify ! ( accept_filter_arg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const accept_filter_arg ) ) . af_name as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( accept_filter_arg ) ,
                "::" , stringify ! ( af_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const accept_filter_arg ) ) . af_arg as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( accept_filter_arg ) ,
                "::" , stringify ! ( af_arg ) ));
}
impl Clone for accept_filter_arg {
    fn clone(&self) -> Self { *self }
}
impl Default for accept_filter_arg {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl ::std::fmt::Debug for accept_filter_arg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f , "accept_filter_arg {{ af_name: {:?}, af_arg: [{}] }}" ,
               self . af_name , self . af_arg . iter (  ) . enumerate (  ) .
               map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ))
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct sockaddr {
    pub sa_len: ::std::os::raw::c_uchar,
    pub sa_family: sa_family_t,
    pub sa_data: [::std::os::raw::c_char; 14usize],
}
#[test]
fn bindgen_test_layout_sockaddr() {
    assert_eq!(::std::mem::size_of::<sockaddr>() , 16usize , concat ! (
               "Size of: " , stringify ! ( sockaddr ) ));
    assert_eq! (::std::mem::align_of::<sockaddr>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( sockaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr ) ) . sa_len as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr ) , "::" ,
                stringify ! ( sa_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr ) ) . sa_family as * const _ as
                usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr ) , "::" ,
                stringify ! ( sa_family ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr ) ) . sa_data as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr ) , "::" ,
                stringify ! ( sa_data ) ));
}
impl Clone for sockaddr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct sockproto {
    pub sp_family: ::std::os::raw::c_ushort,
    pub sp_protocol: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_sockproto() {
    assert_eq!(::std::mem::size_of::<sockproto>() , 4usize , concat ! (
               "Size of: " , stringify ! ( sockproto ) ));
    assert_eq! (::std::mem::align_of::<sockproto>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( sockproto ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockproto ) ) . sp_family as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sockproto ) , "::" ,
                stringify ! ( sp_family ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockproto ) ) . sp_protocol as * const _
                as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( sockproto ) , "::" ,
                stringify ! ( sp_protocol ) ));
}
impl Clone for sockproto {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct sockaddr_storage {
    pub ss_len: ::std::os::raw::c_uchar,
    pub ss_family: sa_family_t,
    pub __ss_pad1: [::std::os::raw::c_char; 6usize],
    pub __ss_align: __int64_t,
    pub __ss_pad2: [::std::os::raw::c_char; 112usize],
}
#[test]
fn bindgen_test_layout_sockaddr_storage() {
    assert_eq!(::std::mem::size_of::<sockaddr_storage>() , 128usize , concat !
               ( "Size of: " , stringify ! ( sockaddr_storage ) ));
    assert_eq! (::std::mem::align_of::<sockaddr_storage>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( sockaddr_storage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_storage ) ) . ss_len as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_storage ) ,
                "::" , stringify ! ( ss_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_storage ) ) . ss_family as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_storage ) ,
                "::" , stringify ! ( ss_family ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_storage ) ) . __ss_pad1 as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_storage ) ,
                "::" , stringify ! ( __ss_pad1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_storage ) ) . __ss_align as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_storage ) ,
                "::" , stringify ! ( __ss_align ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_storage ) ) . __ss_pad2 as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_storage ) ,
                "::" , stringify ! ( __ss_pad2 ) ));
}
impl Clone for sockaddr_storage {
    fn clone(&self) -> Self { *self }
}
impl Default for sockaddr_storage {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl ::std::fmt::Debug for sockaddr_storage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f ,
               "sockaddr_storage {{ ss_len: {:?}, ss_family: {:?}, __ss_pad1: {:?}, __ss_align: {:?}, __ss_pad2: [{}] }}"
               , self . ss_len , self . ss_family , self . __ss_pad1 , self .
               __ss_align , self . __ss_pad2 . iter (  ) . enumerate (  ) .
               map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ))
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct msghdr {
    pub msg_name: *mut ::std::os::raw::c_void,
    pub msg_namelen: socklen_t,
    pub msg_iov: *mut iovec,
    pub msg_iovlen: ::std::os::raw::c_int,
    pub msg_control: *mut ::std::os::raw::c_void,
    pub msg_controllen: socklen_t,
    pub msg_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_msghdr() {
    assert_eq!(::std::mem::size_of::<msghdr>() , 48usize , concat ! (
               "Size of: " , stringify ! ( msghdr ) ));
    assert_eq! (::std::mem::align_of::<msghdr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( msghdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msghdr ) ) . msg_name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( msghdr ) , "::" ,
                stringify ! ( msg_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msghdr ) ) . msg_namelen as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( msghdr ) , "::" ,
                stringify ! ( msg_namelen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msghdr ) ) . msg_iov as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( msghdr ) , "::" ,
                stringify ! ( msg_iov ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msghdr ) ) . msg_iovlen as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( msghdr ) , "::" ,
                stringify ! ( msg_iovlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msghdr ) ) . msg_control as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( msghdr ) , "::" ,
                stringify ! ( msg_control ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msghdr ) ) . msg_controllen as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( msghdr ) , "::" ,
                stringify ! ( msg_controllen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msghdr ) ) . msg_flags as * const _ as
                usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( msghdr ) , "::" ,
                stringify ! ( msg_flags ) ));
}
impl Clone for msghdr {
    fn clone(&self) -> Self { *self }
}
impl Default for msghdr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct cmsghdr {
    pub cmsg_len: socklen_t,
    pub cmsg_level: ::std::os::raw::c_int,
    pub cmsg_type: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cmsghdr() {
    assert_eq!(::std::mem::size_of::<cmsghdr>() , 12usize , concat ! (
               "Size of: " , stringify ! ( cmsghdr ) ));
    assert_eq! (::std::mem::align_of::<cmsghdr>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( cmsghdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmsghdr ) ) . cmsg_len as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( cmsghdr ) , "::" ,
                stringify ! ( cmsg_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmsghdr ) ) . cmsg_level as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( cmsghdr ) , "::" ,
                stringify ! ( cmsg_level ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmsghdr ) ) . cmsg_type as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( cmsghdr ) , "::" ,
                stringify ! ( cmsg_type ) ));
}
impl Clone for cmsghdr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct cmsgcred {
    pub cmcred_pid: pid_t,
    pub cmcred_uid: uid_t,
    pub cmcred_euid: uid_t,
    pub cmcred_gid: gid_t,
    pub cmcred_ngroups: ::std::os::raw::c_short,
    pub cmcred_groups: [gid_t; 16usize],
}
#[test]
fn bindgen_test_layout_cmsgcred() {
    assert_eq!(::std::mem::size_of::<cmsgcred>() , 84usize , concat ! (
               "Size of: " , stringify ! ( cmsgcred ) ));
    assert_eq! (::std::mem::align_of::<cmsgcred>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( cmsgcred ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmsgcred ) ) . cmcred_pid as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( cmsgcred ) , "::" ,
                stringify ! ( cmcred_pid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmsgcred ) ) . cmcred_uid as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( cmsgcred ) , "::" ,
                stringify ! ( cmcred_uid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmsgcred ) ) . cmcred_euid as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( cmsgcred ) , "::" ,
                stringify ! ( cmcred_euid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmsgcred ) ) . cmcred_gid as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( cmsgcred ) , "::" ,
                stringify ! ( cmcred_gid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmsgcred ) ) . cmcred_ngroups as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( cmsgcred ) , "::" ,
                stringify ! ( cmcred_ngroups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmsgcred ) ) . cmcred_groups as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( cmsgcred ) , "::" ,
                stringify ! ( cmcred_groups ) ));
}
impl Clone for cmsgcred {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct sockcred {
    pub sc_uid: uid_t,
    pub sc_euid: uid_t,
    pub sc_gid: gid_t,
    pub sc_egid: gid_t,
    pub sc_ngroups: ::std::os::raw::c_int,
    pub sc_groups: [gid_t; 1usize],
}
#[test]
fn bindgen_test_layout_sockcred() {
    assert_eq!(::std::mem::size_of::<sockcred>() , 24usize , concat ! (
               "Size of: " , stringify ! ( sockcred ) ));
    assert_eq! (::std::mem::align_of::<sockcred>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( sockcred ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockcred ) ) . sc_uid as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sockcred ) , "::" ,
                stringify ! ( sc_uid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockcred ) ) . sc_euid as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( sockcred ) , "::" ,
                stringify ! ( sc_euid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockcred ) ) . sc_gid as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sockcred ) , "::" ,
                stringify ! ( sc_gid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockcred ) ) . sc_egid as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( sockcred ) , "::" ,
                stringify ! ( sc_egid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockcred ) ) . sc_ngroups as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( sockcred ) , "::" ,
                stringify ! ( sc_ngroups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockcred ) ) . sc_groups as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( sockcred ) , "::" ,
                stringify ! ( sc_groups ) ));
}
impl Clone for sockcred {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct sock_timestamp_info {
    pub st_info_flags: __uint32_t,
    pub st_info_pad0: __uint32_t,
    pub st_info_rsv: [__uint64_t; 7usize],
}
#[test]
fn bindgen_test_layout_sock_timestamp_info() {
    assert_eq!(::std::mem::size_of::<sock_timestamp_info>() , 64usize , concat
               ! ( "Size of: " , stringify ! ( sock_timestamp_info ) ));
    assert_eq! (::std::mem::align_of::<sock_timestamp_info>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( sock_timestamp_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sock_timestamp_info ) ) . st_info_flags
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sock_timestamp_info ) ,
                "::" , stringify ! ( st_info_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sock_timestamp_info ) ) . st_info_pad0 as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( sock_timestamp_info ) ,
                "::" , stringify ! ( st_info_pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sock_timestamp_info ) ) . st_info_rsv as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sock_timestamp_info ) ,
                "::" , stringify ! ( st_info_rsv ) ));
}
impl Clone for sock_timestamp_info {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct osockaddr {
    pub sa_family: ::std::os::raw::c_ushort,
    pub sa_data: [::std::os::raw::c_char; 14usize],
}
#[test]
fn bindgen_test_layout_osockaddr() {
    assert_eq!(::std::mem::size_of::<osockaddr>() , 16usize , concat ! (
               "Size of: " , stringify ! ( osockaddr ) ));
    assert_eq! (::std::mem::align_of::<osockaddr>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( osockaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const osockaddr ) ) . sa_family as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( osockaddr ) , "::" ,
                stringify ! ( sa_family ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const osockaddr ) ) . sa_data as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( osockaddr ) , "::" ,
                stringify ! ( sa_data ) ));
}
impl Clone for osockaddr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct omsghdr {
    pub msg_name: *mut ::std::os::raw::c_char,
    pub msg_namelen: ::std::os::raw::c_int,
    pub msg_iov: *mut iovec,
    pub msg_iovlen: ::std::os::raw::c_int,
    pub msg_accrights: *mut ::std::os::raw::c_char,
    pub msg_accrightslen: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_omsghdr() {
    assert_eq!(::std::mem::size_of::<omsghdr>() , 48usize , concat ! (
               "Size of: " , stringify ! ( omsghdr ) ));
    assert_eq! (::std::mem::align_of::<omsghdr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( omsghdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const omsghdr ) ) . msg_name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( omsghdr ) , "::" ,
                stringify ! ( msg_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const omsghdr ) ) . msg_namelen as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( omsghdr ) , "::" ,
                stringify ! ( msg_namelen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const omsghdr ) ) . msg_iov as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( omsghdr ) , "::" ,
                stringify ! ( msg_iov ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const omsghdr ) ) . msg_iovlen as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( omsghdr ) , "::" ,
                stringify ! ( msg_iovlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const omsghdr ) ) . msg_accrights as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( omsghdr ) , "::" ,
                stringify ! ( msg_accrights ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const omsghdr ) ) . msg_accrightslen as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( omsghdr ) , "::" ,
                stringify ! ( msg_accrightslen ) ));
}
impl Clone for omsghdr {
    fn clone(&self) -> Self { *self }
}
impl Default for omsghdr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sf_hdtr {
    pub headers: *mut iovec,
    pub hdr_cnt: ::std::os::raw::c_int,
    pub trailers: *mut iovec,
    pub trl_cnt: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sf_hdtr() {
    assert_eq!(::std::mem::size_of::<sf_hdtr>() , 32usize , concat ! (
               "Size of: " , stringify ! ( sf_hdtr ) ));
    assert_eq! (::std::mem::align_of::<sf_hdtr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sf_hdtr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sf_hdtr ) ) . headers as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sf_hdtr ) , "::" ,
                stringify ! ( headers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sf_hdtr ) ) . hdr_cnt as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sf_hdtr ) , "::" ,
                stringify ! ( hdr_cnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sf_hdtr ) ) . trailers as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( sf_hdtr ) , "::" ,
                stringify ! ( trailers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sf_hdtr ) ) . trl_cnt as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( sf_hdtr ) , "::" ,
                stringify ! ( trl_cnt ) ));
}
impl Clone for sf_hdtr {
    fn clone(&self) -> Self { *self }
}
impl Default for sf_hdtr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mmsghdr {
    pub msg_hdr: msghdr,
    pub msg_len: isize,
}
#[test]
fn bindgen_test_layout_mmsghdr() {
    assert_eq!(::std::mem::size_of::<mmsghdr>() , 56usize , concat ! (
               "Size of: " , stringify ! ( mmsghdr ) ));
    assert_eq! (::std::mem::align_of::<mmsghdr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( mmsghdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mmsghdr ) ) . msg_hdr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mmsghdr ) , "::" ,
                stringify ! ( msg_hdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mmsghdr ) ) . msg_len as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( mmsghdr ) , "::" ,
                stringify ! ( msg_len ) ));
}
impl Clone for mmsghdr {
    fn clone(&self) -> Self { *self }
}
impl Default for mmsghdr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct socket {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcpcb {
    _unused: [u8; 0],
}
extern "C" {
    pub fn so_sototcpcb(so: *mut socket) -> *mut tcpcb;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct inpcb {
    _unused: [u8; 0],
}
extern "C" {
    pub fn so_sotoinpcb(so: *mut socket) -> *mut inpcb;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockbuf {
    _unused: [u8; 0],
}
extern "C" {
    pub fn so_sockbuf_snd(arg1: *mut socket) -> *mut sockbuf;
}
extern "C" {
    pub fn so_sockbuf_rcv(arg1: *mut socket) -> *mut sockbuf;
}
extern "C" {
    pub fn so_state_get(arg1: *const socket) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn so_state_set(arg1: *mut socket, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn so_options_get(arg1: *const socket) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn so_options_set(arg1: *mut socket, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn so_error_get(arg1: *const socket) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn so_error_set(arg1: *mut socket, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn so_linger_get(arg1: *const socket) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn so_linger_set(arg1: *mut socket, arg2: ::std::os::raw::c_int);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct protosw {
    _unused: [u8; 0],
}
extern "C" {
    pub fn so_protosw_get(arg1: *const socket) -> *mut protosw;
}
extern "C" {
    pub fn so_protosw_set(arg1: *mut socket, arg2: *mut protosw);
}
extern "C" {
    pub fn so_sorwakeup_locked(so: *mut socket);
}
extern "C" {
    pub fn so_sowwakeup_locked(so: *mut socket);
}
extern "C" {
    pub fn so_sorwakeup(so: *mut socket);
}
extern "C" {
    pub fn so_sowwakeup(so: *mut socket);
}
extern "C" {
    pub fn so_lock(so: *mut socket);
}
extern "C" {
    pub fn so_unlock(so: *mut socket);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct if_clonereq {
    pub ifcr_total: ::std::os::raw::c_int,
    pub ifcr_count: ::std::os::raw::c_int,
    pub ifcr_buffer: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_if_clonereq() {
    assert_eq!(::std::mem::size_of::<if_clonereq>() , 16usize , concat ! (
               "Size of: " , stringify ! ( if_clonereq ) ));
    assert_eq! (::std::mem::align_of::<if_clonereq>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( if_clonereq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_clonereq ) ) . ifcr_total as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_clonereq ) , "::" ,
                stringify ! ( ifcr_total ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_clonereq ) ) . ifcr_count as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( if_clonereq ) , "::" ,
                stringify ! ( ifcr_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_clonereq ) ) . ifcr_buffer as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( if_clonereq ) , "::" ,
                stringify ! ( ifcr_buffer ) ));
}
impl Clone for if_clonereq {
    fn clone(&self) -> Self { *self }
}
impl Default for if_clonereq {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct if_data {
    pub ifi_type: u8,
    pub ifi_physical: u8,
    pub ifi_addrlen: u8,
    pub ifi_hdrlen: u8,
    pub ifi_link_state: u8,
    pub ifi_vhid: u8,
    pub ifi_datalen: u16,
    pub ifi_mtu: u32,
    pub ifi_metric: u32,
    pub ifi_baudrate: u64,
    pub ifi_ipackets: u64,
    pub ifi_ierrors: u64,
    pub ifi_opackets: u64,
    pub ifi_oerrors: u64,
    pub ifi_collisions: u64,
    pub ifi_ibytes: u64,
    pub ifi_obytes: u64,
    pub ifi_imcasts: u64,
    pub ifi_omcasts: u64,
    pub ifi_iqdrops: u64,
    pub ifi_oqdrops: u64,
    pub ifi_noproto: u64,
    pub ifi_hwassist: u64,
    pub __ifi_epoch: if_data__bindgen_ty_1,
    pub __ifi_lastchange: if_data__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy)]
pub union if_data__bindgen_ty_1 {
    pub tt: time_t,
    pub ph: u64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_if_data__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<if_data__bindgen_ty_1>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( if_data__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<if_data__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( if_data__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data__bindgen_ty_1 ) ) . tt as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data__bindgen_ty_1 )
                , "::" , stringify ! ( tt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data__bindgen_ty_1 ) ) . ph as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data__bindgen_ty_1 )
                , "::" , stringify ! ( ph ) ));
}
impl Clone for if_data__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for if_data__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl ::std::fmt::Debug for if_data__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f , "if_data__bindgen_ty_1 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy)]
pub union if_data__bindgen_ty_2 {
    pub tv: timeval,
    pub ph: if_data__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct if_data__bindgen_ty_2__bindgen_ty_1 {
    pub ph1: u64,
    pub ph2: u64,
}
#[test]
fn bindgen_test_layout_if_data__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<if_data__bindgen_ty_2__bindgen_ty_1>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( if_data__bindgen_ty_2__bindgen_ty_1
               ) ));
    assert_eq! (::std::mem::align_of::<if_data__bindgen_ty_2__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                if_data__bindgen_ty_2__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data__bindgen_ty_2__bindgen_ty_1 ) ) .
                ph1 as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                if_data__bindgen_ty_2__bindgen_ty_1 ) , "::" , stringify ! (
                ph1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data__bindgen_ty_2__bindgen_ty_1 ) ) .
                ph2 as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                if_data__bindgen_ty_2__bindgen_ty_1 ) , "::" , stringify ! (
                ph2 ) ));
}
impl Clone for if_data__bindgen_ty_2__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_if_data__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<if_data__bindgen_ty_2>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( if_data__bindgen_ty_2 )
               ));
    assert_eq! (::std::mem::align_of::<if_data__bindgen_ty_2>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( if_data__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data__bindgen_ty_2 ) ) . tv as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data__bindgen_ty_2 )
                , "::" , stringify ! ( tv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data__bindgen_ty_2 ) ) . ph as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data__bindgen_ty_2 )
                , "::" , stringify ! ( ph ) ));
}
impl Clone for if_data__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for if_data__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl ::std::fmt::Debug for if_data__bindgen_ty_2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f , "if_data__bindgen_ty_2 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_if_data() {
    assert_eq!(::std::mem::size_of::<if_data>() , 152usize , concat ! (
               "Size of: " , stringify ! ( if_data ) ));
    assert_eq! (::std::mem::align_of::<if_data>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( if_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_type as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_physical as * const _
                as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_physical ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_addrlen as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_addrlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_hdrlen as * const _ as
                usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_hdrlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_link_state as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_link_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_vhid as * const _ as
                usize } , 5usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_vhid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_datalen as * const _ as
                usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_datalen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_mtu as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_mtu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_metric as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_metric ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_baudrate as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_baudrate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_ipackets as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_ipackets ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_ierrors as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_ierrors ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_opackets as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_opackets ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_oerrors as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_oerrors ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_collisions as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_collisions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_ibytes as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_ibytes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_obytes as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_obytes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_imcasts as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_imcasts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_omcasts as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_omcasts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_iqdrops as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_iqdrops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_oqdrops as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_oqdrops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_noproto as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_noproto ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_hwassist as * const _
                as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_hwassist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . __ifi_epoch as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( __ifi_epoch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . __ifi_lastchange as * const
                _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( __ifi_lastchange ) ));
}
impl Clone for if_data {
    fn clone(&self) -> Self { *self }
}
impl Default for if_data {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl ::std::fmt::Debug for if_data {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f ,
               "if_data {{ ifi_type: {:?}, ifi_physical: {:?}, ifi_addrlen: {:?}, ifi_hdrlen: {:?}, ifi_link_state: {:?}, ifi_vhid: {:?}, ifi_datalen: {:?}, ifi_mtu: {:?}, ifi_metric: {:?}, ifi_baudrate: {:?}, ifi_ipackets: {:?}, ifi_ierrors: {:?}, ifi_opackets: {:?}, ifi_oerrors: {:?}, ifi_collisions: {:?}, ifi_ibytes: {:?}, ifi_obytes: {:?}, ifi_imcasts: {:?}, ifi_omcasts: {:?}, ifi_iqdrops: {:?}, ifi_oqdrops: {:?}, ifi_noproto: {:?}, ifi_hwassist: {:?}, __ifi_epoch: {:?}, __ifi_lastchange: {:?} }}"
               , self . ifi_type , self . ifi_physical , self . ifi_addrlen ,
               self . ifi_hdrlen , self . ifi_link_state , self . ifi_vhid ,
               self . ifi_datalen , self . ifi_mtu , self . ifi_metric , self
               . ifi_baudrate , self . ifi_ipackets , self . ifi_ierrors ,
               self . ifi_opackets , self . ifi_oerrors , self .
               ifi_collisions , self . ifi_ibytes , self . ifi_obytes , self .
               ifi_imcasts , self . ifi_omcasts , self . ifi_iqdrops , self .
               ifi_oqdrops , self . ifi_noproto , self . ifi_hwassist , self .
               __ifi_epoch , self . __ifi_lastchange)
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct if_msghdr {
    pub ifm_msglen: u_short,
    pub ifm_version: u_char,
    pub ifm_type: u_char,
    pub ifm_addrs: ::std::os::raw::c_int,
    pub ifm_flags: ::std::os::raw::c_int,
    pub ifm_index: u_short,
    pub ifm_data: if_data,
}
#[test]
fn bindgen_test_layout_if_msghdr() {
    assert_eq!(::std::mem::size_of::<if_msghdr>() , 168usize , concat ! (
               "Size of: " , stringify ! ( if_msghdr ) ));
    assert_eq! (::std::mem::align_of::<if_msghdr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( if_msghdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_msghdr ) ) . ifm_msglen as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_msghdr ) , "::" ,
                stringify ! ( ifm_msglen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_msghdr ) ) . ifm_version as * const _
                as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( if_msghdr ) , "::" ,
                stringify ! ( ifm_version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_msghdr ) ) . ifm_type as * const _ as
                usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( if_msghdr ) , "::" ,
                stringify ! ( ifm_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_msghdr ) ) . ifm_addrs as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( if_msghdr ) , "::" ,
                stringify ! ( ifm_addrs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_msghdr ) ) . ifm_flags as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( if_msghdr ) , "::" ,
                stringify ! ( ifm_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_msghdr ) ) . ifm_index as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( if_msghdr ) , "::" ,
                stringify ! ( ifm_index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_msghdr ) ) . ifm_data as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( if_msghdr ) , "::" ,
                stringify ! ( ifm_data ) ));
}
impl Clone for if_msghdr {
    fn clone(&self) -> Self { *self }
}
impl Default for if_msghdr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl ::std::fmt::Debug for if_msghdr {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f ,
               "if_msghdr {{ ifm_msglen: {:?}, ifm_version: {:?}, ifm_type: {:?}, ifm_addrs: {:?}, ifm_flags: {:?}, ifm_index: {:?}, ifm_data: {:?} }}"
               , self . ifm_msglen , self . ifm_version , self . ifm_type ,
               self . ifm_addrs , self . ifm_flags , self . ifm_index , self .
               ifm_data)
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct if_msghdrl {
    pub ifm_msglen: u_short,
    pub ifm_version: u_char,
    pub ifm_type: u_char,
    pub ifm_addrs: ::std::os::raw::c_int,
    pub ifm_flags: ::std::os::raw::c_int,
    pub ifm_index: u_short,
    pub _ifm_spare1: u_short,
    pub ifm_len: u_short,
    pub ifm_data_off: u_short,
    pub ifm_data: if_data,
}
#[test]
fn bindgen_test_layout_if_msghdrl() {
    assert_eq!(::std::mem::size_of::<if_msghdrl>() , 176usize , concat ! (
               "Size of: " , stringify ! ( if_msghdrl ) ));
    assert_eq! (::std::mem::align_of::<if_msghdrl>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( if_msghdrl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_msghdrl ) ) . ifm_msglen as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_msghdrl ) , "::" ,
                stringify ! ( ifm_msglen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_msghdrl ) ) . ifm_version as * const _
                as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( if_msghdrl ) , "::" ,
                stringify ! ( ifm_version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_msghdrl ) ) . ifm_type as * const _ as
                usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( if_msghdrl ) , "::" ,
                stringify ! ( ifm_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_msghdrl ) ) . ifm_addrs as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( if_msghdrl ) , "::" ,
                stringify ! ( ifm_addrs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_msghdrl ) ) . ifm_flags as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( if_msghdrl ) , "::" ,
                stringify ! ( ifm_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_msghdrl ) ) . ifm_index as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( if_msghdrl ) , "::" ,
                stringify ! ( ifm_index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_msghdrl ) ) . _ifm_spare1 as * const _
                as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( if_msghdrl ) , "::" ,
                stringify ! ( _ifm_spare1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_msghdrl ) ) . ifm_len as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( if_msghdrl ) , "::" ,
                stringify ! ( ifm_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_msghdrl ) ) . ifm_data_off as * const
                _ as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( if_msghdrl ) , "::" ,
                stringify ! ( ifm_data_off ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_msghdrl ) ) . ifm_data as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( if_msghdrl ) , "::" ,
                stringify ! ( ifm_data ) ));
}
impl Clone for if_msghdrl {
    fn clone(&self) -> Self { *self }
}
impl Default for if_msghdrl {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl ::std::fmt::Debug for if_msghdrl {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f ,
               "if_msghdrl {{ ifm_msglen: {:?}, ifm_version: {:?}, ifm_type: {:?}, ifm_addrs: {:?}, ifm_flags: {:?}, ifm_index: {:?}, _ifm_spare1: {:?}, ifm_len: {:?}, ifm_data_off: {:?}, ifm_data: {:?} }}"
               , self . ifm_msglen , self . ifm_version , self . ifm_type ,
               self . ifm_addrs , self . ifm_flags , self . ifm_index , self .
               _ifm_spare1 , self . ifm_len , self . ifm_data_off , self .
               ifm_data)
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct ifa_msghdr {
    pub ifam_msglen: u_short,
    pub ifam_version: u_char,
    pub ifam_type: u_char,
    pub ifam_addrs: ::std::os::raw::c_int,
    pub ifam_flags: ::std::os::raw::c_int,
    pub ifam_index: u_short,
    pub ifam_metric: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ifa_msghdr() {
    assert_eq!(::std::mem::size_of::<ifa_msghdr>() , 20usize , concat ! (
               "Size of: " , stringify ! ( ifa_msghdr ) ));
    assert_eq! (::std::mem::align_of::<ifa_msghdr>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( ifa_msghdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifa_msghdr ) ) . ifam_msglen as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifa_msghdr ) , "::" ,
                stringify ! ( ifam_msglen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifa_msghdr ) ) . ifam_version as * const
                _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( ifa_msghdr ) , "::" ,
                stringify ! ( ifam_version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifa_msghdr ) ) . ifam_type as * const _
                as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( ifa_msghdr ) , "::" ,
                stringify ! ( ifam_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifa_msghdr ) ) . ifam_addrs as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ifa_msghdr ) , "::" ,
                stringify ! ( ifam_addrs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifa_msghdr ) ) . ifam_flags as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifa_msghdr ) , "::" ,
                stringify ! ( ifam_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifa_msghdr ) ) . ifam_index as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( ifa_msghdr ) , "::" ,
                stringify ! ( ifam_index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifa_msghdr ) ) . ifam_metric as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ifa_msghdr ) , "::" ,
                stringify ! ( ifam_metric ) ));
}
impl Clone for ifa_msghdr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ifa_msghdrl {
    pub ifam_msglen: u_short,
    pub ifam_version: u_char,
    pub ifam_type: u_char,
    pub ifam_addrs: ::std::os::raw::c_int,
    pub ifam_flags: ::std::os::raw::c_int,
    pub ifam_index: u_short,
    pub _ifam_spare1: u_short,
    pub ifam_len: u_short,
    pub ifam_data_off: u_short,
    pub ifam_metric: ::std::os::raw::c_int,
    pub ifam_data: if_data,
}
#[test]
fn bindgen_test_layout_ifa_msghdrl() {
    assert_eq!(::std::mem::size_of::<ifa_msghdrl>() , 176usize , concat ! (
               "Size of: " , stringify ! ( ifa_msghdrl ) ));
    assert_eq! (::std::mem::align_of::<ifa_msghdrl>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ifa_msghdrl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifa_msghdrl ) ) . ifam_msglen as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifa_msghdrl ) , "::" ,
                stringify ! ( ifam_msglen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifa_msghdrl ) ) . ifam_version as * const
                _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( ifa_msghdrl ) , "::" ,
                stringify ! ( ifam_version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifa_msghdrl ) ) . ifam_type as * const _
                as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( ifa_msghdrl ) , "::" ,
                stringify ! ( ifam_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifa_msghdrl ) ) . ifam_addrs as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ifa_msghdrl ) , "::" ,
                stringify ! ( ifam_addrs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifa_msghdrl ) ) . ifam_flags as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifa_msghdrl ) , "::" ,
                stringify ! ( ifam_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifa_msghdrl ) ) . ifam_index as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( ifa_msghdrl ) , "::" ,
                stringify ! ( ifam_index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifa_msghdrl ) ) . _ifam_spare1 as * const
                _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( ifa_msghdrl ) , "::" ,
                stringify ! ( _ifam_spare1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifa_msghdrl ) ) . ifam_len as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ifa_msghdrl ) , "::" ,
                stringify ! ( ifam_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifa_msghdrl ) ) . ifam_data_off as *
                const _ as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( ifa_msghdrl ) , "::" ,
                stringify ! ( ifam_data_off ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifa_msghdrl ) ) . ifam_metric as * const
                _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( ifa_msghdrl ) , "::" ,
                stringify ! ( ifam_metric ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifa_msghdrl ) ) . ifam_data as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ifa_msghdrl ) , "::" ,
                stringify ! ( ifam_data ) ));
}
impl Clone for ifa_msghdrl {
    fn clone(&self) -> Self { *self }
}
impl Default for ifa_msghdrl {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl ::std::fmt::Debug for ifa_msghdrl {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f ,
               "ifa_msghdrl {{ ifam_msglen: {:?}, ifam_version: {:?}, ifam_type: {:?}, ifam_addrs: {:?}, ifam_flags: {:?}, ifam_index: {:?}, _ifam_spare1: {:?}, ifam_len: {:?}, ifam_data_off: {:?}, ifam_metric: {:?}, ifam_data: {:?} }}"
               , self . ifam_msglen , self . ifam_version , self . ifam_type ,
               self . ifam_addrs , self . ifam_flags , self . ifam_index ,
               self . _ifam_spare1 , self . ifam_len , self . ifam_data_off ,
               self . ifam_metric , self . ifam_data)
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct ifma_msghdr {
    pub ifmam_msglen: u_short,
    pub ifmam_version: u_char,
    pub ifmam_type: u_char,
    pub ifmam_addrs: ::std::os::raw::c_int,
    pub ifmam_flags: ::std::os::raw::c_int,
    pub ifmam_index: u_short,
}
#[test]
fn bindgen_test_layout_ifma_msghdr() {
    assert_eq!(::std::mem::size_of::<ifma_msghdr>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ifma_msghdr ) ));
    assert_eq! (::std::mem::align_of::<ifma_msghdr>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( ifma_msghdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifma_msghdr ) ) . ifmam_msglen as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifma_msghdr ) , "::" ,
                stringify ! ( ifmam_msglen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifma_msghdr ) ) . ifmam_version as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( ifma_msghdr ) , "::" ,
                stringify ! ( ifmam_version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifma_msghdr ) ) . ifmam_type as * const _
                as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( ifma_msghdr ) , "::" ,
                stringify ! ( ifmam_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifma_msghdr ) ) . ifmam_addrs as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ifma_msghdr ) , "::" ,
                stringify ! ( ifmam_addrs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifma_msghdr ) ) . ifmam_flags as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifma_msghdr ) , "::" ,
                stringify ! ( ifmam_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifma_msghdr ) ) . ifmam_index as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( ifma_msghdr ) , "::" ,
                stringify ! ( ifmam_index ) ));
}
impl Clone for ifma_msghdr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct if_announcemsghdr {
    pub ifan_msglen: u_short,
    pub ifan_version: u_char,
    pub ifan_type: u_char,
    pub ifan_index: u_short,
    pub ifan_name: [::std::os::raw::c_char; 16usize],
    pub ifan_what: u_short,
}
#[test]
fn bindgen_test_layout_if_announcemsghdr() {
    assert_eq!(::std::mem::size_of::<if_announcemsghdr>() , 24usize , concat !
               ( "Size of: " , stringify ! ( if_announcemsghdr ) ));
    assert_eq! (::std::mem::align_of::<if_announcemsghdr>() , 2usize , concat
                ! ( "Alignment of " , stringify ! ( if_announcemsghdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_announcemsghdr ) ) . ifan_msglen as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_announcemsghdr ) ,
                "::" , stringify ! ( ifan_msglen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_announcemsghdr ) ) . ifan_version as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( if_announcemsghdr ) ,
                "::" , stringify ! ( ifan_version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_announcemsghdr ) ) . ifan_type as *
                const _ as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( if_announcemsghdr ) ,
                "::" , stringify ! ( ifan_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_announcemsghdr ) ) . ifan_index as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( if_announcemsghdr ) ,
                "::" , stringify ! ( ifan_index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_announcemsghdr ) ) . ifan_name as *
                const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( if_announcemsghdr ) ,
                "::" , stringify ! ( ifan_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_announcemsghdr ) ) . ifan_what as *
                const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! ( if_announcemsghdr ) ,
                "::" , stringify ! ( ifan_what ) ));
}
impl Clone for if_announcemsghdr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifreq_buffer {
    pub length: usize,
    pub buffer: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ifreq_buffer() {
    assert_eq!(::std::mem::size_of::<ifreq_buffer>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ifreq_buffer ) ));
    assert_eq! (::std::mem::align_of::<ifreq_buffer>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ifreq_buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifreq_buffer ) ) . length as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifreq_buffer ) , "::" ,
                stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifreq_buffer ) ) . buffer as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifreq_buffer ) , "::" ,
                stringify ! ( buffer ) ));
}
impl Clone for ifreq_buffer {
    fn clone(&self) -> Self { *self }
}
impl Default for ifreq_buffer {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct ifreq {
    pub ifr_name: [::std::os::raw::c_char; 16usize],
    pub ifr_ifru: ifreq__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub union ifreq__bindgen_ty_1 {
    pub ifru_addr: sockaddr,
    pub ifru_dstaddr: sockaddr,
    pub ifru_broadaddr: sockaddr,
    pub ifru_buffer: ifreq_buffer,
    pub ifru_flags: [::std::os::raw::c_short; 2usize],
    pub ifru_index: ::std::os::raw::c_short,
    pub ifru_jid: ::std::os::raw::c_int,
    pub ifru_metric: ::std::os::raw::c_int,
    pub ifru_mtu: ::std::os::raw::c_int,
    pub ifru_phys: ::std::os::raw::c_int,
    pub ifru_media: ::std::os::raw::c_int,
    pub ifru_data: caddr_t,
    pub ifru_cap: [::std::os::raw::c_int; 2usize],
    pub ifru_fib: u_int,
    pub ifru_vlan_pcp: u_char,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_ifreq__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<ifreq__bindgen_ty_1>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( ifreq__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<ifreq__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( ifreq__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifreq__bindgen_ty_1 ) ) . ifru_addr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifreq__bindgen_ty_1 ) ,
                "::" , stringify ! ( ifru_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifreq__bindgen_ty_1 ) ) . ifru_dstaddr as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifreq__bindgen_ty_1 ) ,
                "::" , stringify ! ( ifru_dstaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifreq__bindgen_ty_1 ) ) . ifru_broadaddr
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifreq__bindgen_ty_1 ) ,
                "::" , stringify ! ( ifru_broadaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifreq__bindgen_ty_1 ) ) . ifru_buffer as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifreq__bindgen_ty_1 ) ,
                "::" , stringify ! ( ifru_buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifreq__bindgen_ty_1 ) ) . ifru_flags as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifreq__bindgen_ty_1 ) ,
                "::" , stringify ! ( ifru_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifreq__bindgen_ty_1 ) ) . ifru_index as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifreq__bindgen_ty_1 ) ,
                "::" , stringify ! ( ifru_index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifreq__bindgen_ty_1 ) ) . ifru_jid as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifreq__bindgen_ty_1 ) ,
                "::" , stringify ! ( ifru_jid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifreq__bindgen_ty_1 ) ) . ifru_metric as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifreq__bindgen_ty_1 ) ,
                "::" , stringify ! ( ifru_metric ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifreq__bindgen_ty_1 ) ) . ifru_mtu as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifreq__bindgen_ty_1 ) ,
                "::" , stringify ! ( ifru_mtu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifreq__bindgen_ty_1 ) ) . ifru_phys as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifreq__bindgen_ty_1 ) ,
                "::" , stringify ! ( ifru_phys ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifreq__bindgen_ty_1 ) ) . ifru_media as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifreq__bindgen_ty_1 ) ,
                "::" , stringify ! ( ifru_media ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifreq__bindgen_ty_1 ) ) . ifru_data as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifreq__bindgen_ty_1 ) ,
                "::" , stringify ! ( ifru_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifreq__bindgen_ty_1 ) ) . ifru_cap as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifreq__bindgen_ty_1 ) ,
                "::" , stringify ! ( ifru_cap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifreq__bindgen_ty_1 ) ) . ifru_fib as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifreq__bindgen_ty_1 ) ,
                "::" , stringify ! ( ifru_fib ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifreq__bindgen_ty_1 ) ) . ifru_vlan_pcp
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifreq__bindgen_ty_1 ) ,
                "::" , stringify ! ( ifru_vlan_pcp ) ));
}
impl Clone for ifreq__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for ifreq__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl ::std::fmt::Debug for ifreq__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f , "ifreq__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_ifreq() {
    assert_eq!(::std::mem::size_of::<ifreq>() , 32usize , concat ! (
               "Size of: " , stringify ! ( ifreq ) ));
    assert_eq! (::std::mem::align_of::<ifreq>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ifreq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifreq ) ) . ifr_name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifreq ) , "::" ,
                stringify ! ( ifr_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifreq ) ) . ifr_ifru as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ifreq ) , "::" ,
                stringify ! ( ifr_ifru ) ));
}
impl Clone for ifreq {
    fn clone(&self) -> Self { *self }
}
impl Default for ifreq {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl ::std::fmt::Debug for ifreq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f , "ifreq {{ ifr_name: {:?}, ifr_ifru: {:?} }}" , self .
               ifr_name , self . ifr_ifru)
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct ifaliasreq {
    pub ifra_name: [::std::os::raw::c_char; 16usize],
    pub ifra_addr: sockaddr,
    pub ifra_broadaddr: sockaddr,
    pub ifra_mask: sockaddr,
    pub ifra_vhid: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ifaliasreq() {
    assert_eq!(::std::mem::size_of::<ifaliasreq>() , 68usize , concat ! (
               "Size of: " , stringify ! ( ifaliasreq ) ));
    assert_eq! (::std::mem::align_of::<ifaliasreq>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( ifaliasreq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaliasreq ) ) . ifra_name as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaliasreq ) , "::" ,
                stringify ! ( ifra_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaliasreq ) ) . ifra_addr as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaliasreq ) , "::" ,
                stringify ! ( ifra_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaliasreq ) ) . ifra_broadaddr as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaliasreq ) , "::" ,
                stringify ! ( ifra_broadaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaliasreq ) ) . ifra_mask as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaliasreq ) , "::" ,
                stringify ! ( ifra_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaliasreq ) ) . ifra_vhid as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaliasreq ) , "::" ,
                stringify ! ( ifra_vhid ) ));
}
impl Clone for ifaliasreq {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct oifaliasreq {
    pub ifra_name: [::std::os::raw::c_char; 16usize],
    pub ifra_addr: sockaddr,
    pub ifra_broadaddr: sockaddr,
    pub ifra_mask: sockaddr,
}
#[test]
fn bindgen_test_layout_oifaliasreq() {
    assert_eq!(::std::mem::size_of::<oifaliasreq>() , 64usize , concat ! (
               "Size of: " , stringify ! ( oifaliasreq ) ));
    assert_eq! (::std::mem::align_of::<oifaliasreq>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( oifaliasreq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const oifaliasreq ) ) . ifra_name as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( oifaliasreq ) , "::" ,
                stringify ! ( ifra_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const oifaliasreq ) ) . ifra_addr as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( oifaliasreq ) , "::" ,
                stringify ! ( ifra_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const oifaliasreq ) ) . ifra_broadaddr as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( oifaliasreq ) , "::" ,
                stringify ! ( ifra_broadaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const oifaliasreq ) ) . ifra_mask as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( oifaliasreq ) , "::" ,
                stringify ! ( ifra_mask ) ));
}
impl Clone for oifaliasreq {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifmediareq {
    pub ifm_name: [::std::os::raw::c_char; 16usize],
    pub ifm_current: ::std::os::raw::c_int,
    pub ifm_mask: ::std::os::raw::c_int,
    pub ifm_status: ::std::os::raw::c_int,
    pub ifm_active: ::std::os::raw::c_int,
    pub ifm_count: ::std::os::raw::c_int,
    pub ifm_ulist: *mut ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ifmediareq() {
    assert_eq!(::std::mem::size_of::<ifmediareq>() , 48usize , concat ! (
               "Size of: " , stringify ! ( ifmediareq ) ));
    assert_eq! (::std::mem::align_of::<ifmediareq>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ifmediareq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmediareq ) ) . ifm_name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmediareq ) , "::" ,
                stringify ! ( ifm_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmediareq ) ) . ifm_current as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmediareq ) , "::" ,
                stringify ! ( ifm_current ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmediareq ) ) . ifm_mask as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmediareq ) , "::" ,
                stringify ! ( ifm_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmediareq ) ) . ifm_status as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmediareq ) , "::" ,
                stringify ! ( ifm_status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmediareq ) ) . ifm_active as * const _
                as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmediareq ) , "::" ,
                stringify ! ( ifm_active ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmediareq ) ) . ifm_count as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmediareq ) , "::" ,
                stringify ! ( ifm_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmediareq ) ) . ifm_ulist as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmediareq ) , "::" ,
                stringify ! ( ifm_ulist ) ));
}
impl Clone for ifmediareq {
    fn clone(&self) -> Self { *self }
}
impl Default for ifmediareq {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifdrv {
    pub ifd_name: [::std::os::raw::c_char; 16usize],
    pub ifd_cmd: ::std::os::raw::c_ulong,
    pub ifd_len: usize,
    pub ifd_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ifdrv() {
    assert_eq!(::std::mem::size_of::<ifdrv>() , 40usize , concat ! (
               "Size of: " , stringify ! ( ifdrv ) ));
    assert_eq! (::std::mem::align_of::<ifdrv>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ifdrv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifdrv ) ) . ifd_name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifdrv ) , "::" ,
                stringify ! ( ifd_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifdrv ) ) . ifd_cmd as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ifdrv ) , "::" ,
                stringify ! ( ifd_cmd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifdrv ) ) . ifd_len as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ifdrv ) , "::" ,
                stringify ! ( ifd_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifdrv ) ) . ifd_data as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( ifdrv ) , "::" ,
                stringify ! ( ifd_data ) ));
}
impl Clone for ifdrv {
    fn clone(&self) -> Self { *self }
}
impl Default for ifdrv {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct ifstat {
    pub ifs_name: [::std::os::raw::c_char; 16usize],
    pub ascii: [::std::os::raw::c_char; 801usize],
}
#[test]
fn bindgen_test_layout_ifstat() {
    assert_eq!(::std::mem::size_of::<ifstat>() , 817usize , concat ! (
               "Size of: " , stringify ! ( ifstat ) ));
    assert_eq! (::std::mem::align_of::<ifstat>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( ifstat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifstat ) ) . ifs_name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifstat ) , "::" ,
                stringify ! ( ifs_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifstat ) ) . ascii as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ifstat ) , "::" ,
                stringify ! ( ascii ) ));
}
impl Clone for ifstat {
    fn clone(&self) -> Self { *self }
}
impl Default for ifstat {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl ::std::fmt::Debug for ifstat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f , "ifstat {{ ifs_name: {:?}, ascii: [{}] }}" , self .
               ifs_name , self . ascii . iter (  ) . enumerate (  ) . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ))
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct ifconf {
    pub ifc_len: ::std::os::raw::c_int,
    pub ifc_ifcu: ifconf__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub union ifconf__bindgen_ty_1 {
    pub ifcu_buf: caddr_t,
    pub ifcu_req: *mut ifreq,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_ifconf__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<ifconf__bindgen_ty_1>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( ifconf__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<ifconf__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( ifconf__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifconf__bindgen_ty_1 ) ) . ifcu_buf as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifconf__bindgen_ty_1 )
                , "::" , stringify ! ( ifcu_buf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifconf__bindgen_ty_1 ) ) . ifcu_req as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifconf__bindgen_ty_1 )
                , "::" , stringify ! ( ifcu_req ) ));
}
impl Clone for ifconf__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for ifconf__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl ::std::fmt::Debug for ifconf__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f , "ifconf__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_ifconf() {
    assert_eq!(::std::mem::size_of::<ifconf>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ifconf ) ));
    assert_eq! (::std::mem::align_of::<ifconf>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ifconf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifconf ) ) . ifc_len as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifconf ) , "::" ,
                stringify ! ( ifc_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifconf ) ) . ifc_ifcu as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifconf ) , "::" ,
                stringify ! ( ifc_ifcu ) ));
}
impl Clone for ifconf {
    fn clone(&self) -> Self { *self }
}
impl Default for ifconf {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl ::std::fmt::Debug for ifconf {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f , "ifconf {{ ifc_len: {:?}, ifc_ifcu: {:?} }}" , self .
               ifc_len , self . ifc_ifcu)
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct ifg_req {
    pub ifgrq_ifgrqu: ifg_req__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub union ifg_req__bindgen_ty_1 {
    pub ifgrqu_group: [::std::os::raw::c_char; 16usize],
    pub ifgrqu_member: [::std::os::raw::c_char; 16usize],
    _bindgen_union_align: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_ifg_req__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<ifg_req__bindgen_ty_1>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( ifg_req__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<ifg_req__bindgen_ty_1>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( ifg_req__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifg_req__bindgen_ty_1 ) ) . ifgrqu_group
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifg_req__bindgen_ty_1 )
                , "::" , stringify ! ( ifgrqu_group ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifg_req__bindgen_ty_1 ) ) . ifgrqu_member
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifg_req__bindgen_ty_1 )
                , "::" , stringify ! ( ifgrqu_member ) ));
}
impl Clone for ifg_req__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for ifg_req__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl ::std::fmt::Debug for ifg_req__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f , "ifg_req__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_ifg_req() {
    assert_eq!(::std::mem::size_of::<ifg_req>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ifg_req ) ));
    assert_eq! (::std::mem::align_of::<ifg_req>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( ifg_req ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifg_req ) ) . ifgrq_ifgrqu as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifg_req ) , "::" ,
                stringify ! ( ifgrq_ifgrqu ) ));
}
impl Clone for ifg_req {
    fn clone(&self) -> Self { *self }
}
impl Default for ifg_req {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl ::std::fmt::Debug for ifg_req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f , "ifg_req {{ ifgrq_ifgrqu: {:?} }}" , self . ifgrq_ifgrqu)
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct ifgroupreq {
    pub ifgr_name: [::std::os::raw::c_char; 16usize],
    pub ifgr_len: u_int,
    pub ifgr_ifgru: ifgroupreq__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub union ifgroupreq__bindgen_ty_1 {
    pub ifgru_group: [::std::os::raw::c_char; 16usize],
    pub ifgru_groups: *mut ifg_req,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_ifgroupreq__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<ifgroupreq__bindgen_ty_1>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( ifgroupreq__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<ifgroupreq__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( ifgroupreq__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifgroupreq__bindgen_ty_1 ) ) .
                ifgru_group as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                ifgroupreq__bindgen_ty_1 ) , "::" , stringify ! ( ifgru_group
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifgroupreq__bindgen_ty_1 ) ) .
                ifgru_groups as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                ifgroupreq__bindgen_ty_1 ) , "::" , stringify ! ( ifgru_groups
                ) ));
}
impl Clone for ifgroupreq__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for ifgroupreq__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl ::std::fmt::Debug for ifgroupreq__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f , "ifgroupreq__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_ifgroupreq() {
    assert_eq!(::std::mem::size_of::<ifgroupreq>() , 40usize , concat ! (
               "Size of: " , stringify ! ( ifgroupreq ) ));
    assert_eq! (::std::mem::align_of::<ifgroupreq>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ifgroupreq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifgroupreq ) ) . ifgr_name as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifgroupreq ) , "::" ,
                stringify ! ( ifgr_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifgroupreq ) ) . ifgr_len as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ifgroupreq ) , "::" ,
                stringify ! ( ifgr_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifgroupreq ) ) . ifgr_ifgru as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ifgroupreq ) , "::" ,
                stringify ! ( ifgr_ifgru ) ));
}
impl Clone for ifgroupreq {
    fn clone(&self) -> Self { *self }
}
impl Default for ifgroupreq {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl ::std::fmt::Debug for ifgroupreq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f ,
               "ifgroupreq {{ ifgr_name: {:?}, ifgr_len: {:?}, ifgr_ifgru: {:?} }}"
               , self . ifgr_name , self . ifgr_len , self . ifgr_ifgru)
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct ifi2creq {
    pub dev_addr: u8,
    pub offset: u8,
    pub len: u8,
    pub spare0: u8,
    pub spare1: u32,
    pub data: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_ifi2creq() {
    assert_eq!(::std::mem::size_of::<ifi2creq>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ifi2creq ) ));
    assert_eq! (::std::mem::align_of::<ifi2creq>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( ifi2creq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifi2creq ) ) . dev_addr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifi2creq ) , "::" ,
                stringify ! ( dev_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifi2creq ) ) . offset as * const _ as
                usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( ifi2creq ) , "::" ,
                stringify ! ( offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifi2creq ) ) . len as * const _ as usize
                } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( ifi2creq ) , "::" ,
                stringify ! ( len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifi2creq ) ) . spare0 as * const _ as
                usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( ifi2creq ) , "::" ,
                stringify ! ( spare0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifi2creq ) ) . spare1 as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ifi2creq ) , "::" ,
                stringify ! ( spare1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifi2creq ) ) . data as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifi2creq ) , "::" ,
                stringify ! ( data ) ));
}
impl Clone for ifi2creq {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ifrsskey {
    pub ifrk_name: [::std::os::raw::c_char; 16usize],
    pub ifrk_func: u8,
    pub ifrk_spare0: u8,
    pub ifrk_keylen: u16,
    pub ifrk_key: [u8; 128usize],
}
#[test]
fn bindgen_test_layout_ifrsskey() {
    assert_eq!(::std::mem::size_of::<ifrsskey>() , 148usize , concat ! (
               "Size of: " , stringify ! ( ifrsskey ) ));
    assert_eq! (::std::mem::align_of::<ifrsskey>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( ifrsskey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifrsskey ) ) . ifrk_name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifrsskey ) , "::" ,
                stringify ! ( ifrk_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifrsskey ) ) . ifrk_func as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ifrsskey ) , "::" ,
                stringify ! ( ifrk_func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifrsskey ) ) . ifrk_spare0 as * const _
                as usize } , 17usize , concat ! (
                "Alignment of field: " , stringify ! ( ifrsskey ) , "::" ,
                stringify ! ( ifrk_spare0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifrsskey ) ) . ifrk_keylen as * const _
                as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( ifrsskey ) , "::" ,
                stringify ! ( ifrk_keylen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifrsskey ) ) . ifrk_key as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( ifrsskey ) , "::" ,
                stringify ! ( ifrk_key ) ));
}
impl Clone for ifrsskey {
    fn clone(&self) -> Self { *self }
}
impl Default for ifrsskey {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl ::std::fmt::Debug for ifrsskey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f ,
               "ifrsskey {{ ifrk_name: {:?}, ifrk_func: {:?}, ifrk_spare0: {:?}, ifrk_keylen: {:?}, ifrk_key: [{}] }}"
               , self . ifrk_name , self . ifrk_func , self . ifrk_spare0 ,
               self . ifrk_keylen , self . ifrk_key . iter (  ) . enumerate (
               ) . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ))
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct ifrsshash {
    pub ifrh_name: [::std::os::raw::c_char; 16usize],
    pub ifrh_func: u8,
    pub ifrh_spare0: u8,
    pub ifrh_spare1: u16,
    pub ifrh_types: u32,
}
#[test]
fn bindgen_test_layout_ifrsshash() {
    assert_eq!(::std::mem::size_of::<ifrsshash>() , 24usize , concat ! (
               "Size of: " , stringify ! ( ifrsshash ) ));
    assert_eq! (::std::mem::align_of::<ifrsshash>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( ifrsshash ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifrsshash ) ) . ifrh_name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifrsshash ) , "::" ,
                stringify ! ( ifrh_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifrsshash ) ) . ifrh_func as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ifrsshash ) , "::" ,
                stringify ! ( ifrh_func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifrsshash ) ) . ifrh_spare0 as * const _
                as usize } , 17usize , concat ! (
                "Alignment of field: " , stringify ! ( ifrsshash ) , "::" ,
                stringify ! ( ifrh_spare0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifrsshash ) ) . ifrh_spare1 as * const _
                as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( ifrsshash ) , "::" ,
                stringify ! ( ifrh_spare1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifrsshash ) ) . ifrh_types as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( ifrsshash ) , "::" ,
                stringify ! ( ifrh_types ) ));
}
impl Clone for ifrsshash {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rtentry {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_addrinfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct carp_if {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct carp_softc {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ifvlantrunk {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct route {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct vnet {
    pub vnet_le: vnet__bindgen_ty_1,
    pub vnet_magic_n: u_int,
    pub vnet_ifcnt: u_int,
    pub vnet_sockcnt: u_int,
    pub vnet_state: u_int,
    pub vnet_data_mem: *mut ::std::os::raw::c_void,
    pub vnet_data_base: usize,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct vnet__bindgen_ty_1 {
    pub le_next: *mut vnet,
    pub le_prev: *mut *mut vnet,
}
#[test]
fn bindgen_test_layout_vnet__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<vnet__bindgen_ty_1>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( vnet__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<vnet__bindgen_ty_1>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( vnet__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vnet__bindgen_ty_1 ) ) . le_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( vnet__bindgen_ty_1 ) ,
                "::" , stringify ! ( le_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vnet__bindgen_ty_1 ) ) . le_prev as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( vnet__bindgen_ty_1 ) ,
                "::" , stringify ! ( le_prev ) ));
}
impl Clone for vnet__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for vnet__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_vnet() {
    assert_eq!(::std::mem::size_of::<vnet>() , 48usize , concat ! (
               "Size of: " , stringify ! ( vnet ) ));
    assert_eq! (::std::mem::align_of::<vnet>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( vnet ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vnet ) ) . vnet_le as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( vnet ) , "::" ,
                stringify ! ( vnet_le ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vnet ) ) . vnet_magic_n as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( vnet ) , "::" ,
                stringify ! ( vnet_magic_n ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vnet ) ) . vnet_ifcnt as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( vnet ) , "::" ,
                stringify ! ( vnet_ifcnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vnet ) ) . vnet_sockcnt as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( vnet ) , "::" ,
                stringify ! ( vnet_sockcnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vnet ) ) . vnet_state as * const _ as
                usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( vnet ) , "::" ,
                stringify ! ( vnet_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vnet ) ) . vnet_data_mem as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( vnet ) , "::" ,
                stringify ! ( vnet_data_mem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vnet ) ) . vnet_data_base as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( vnet ) , "::" ,
                stringify ! ( vnet_data_base ) ));
}
impl Clone for vnet {
    fn clone(&self) -> Self { *self }
}
impl Default for vnet {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ifmedia {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netmap_adapter {
    _unused: [u8; 0],
}
extern "C" {
    pub fn atomic_cmpset_char(dst: *mut u_char, expect: u_char, src: u_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atomic_cmpset_short(dst: *mut u_short, expect: u_short,
                               src: u_short) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atomic_cmpset_int(dst: *mut u_int, expect: u_int, src: u_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atomic_cmpset_long(dst: *mut u_long, expect: u_long, src: u_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atomic_fcmpset_char(dst: *mut u_char, expect: *mut u_char,
                               src: u_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atomic_fcmpset_short(dst: *mut u_short, expect: *mut u_short,
                                src: u_short) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atomic_fcmpset_int(dst: *mut u_int, expect: *mut u_int, src: u_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atomic_fcmpset_long(dst: *mut u_long, expect: *mut u_long,
                               src: u_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atomic_fetchadd_int(p: *mut u_int, v: u_int) -> u_int;
}
extern "C" {
    pub fn atomic_fetchadd_long(p: *mut u_long, v: u_long) -> u_long;
}
extern "C" {
    pub fn atomic_testandset_int(p: *mut u_int, v: u_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atomic_testandset_long(p: *mut u_long, v: u_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atomic_testandclear_int(p: *mut u_int, v: u_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atomic_testandclear_long(p: *mut u_long, v: u_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atomic_thread_fence_acq();
}
extern "C" {
    pub fn atomic_thread_fence_acq_rel();
}
extern "C" {
    pub fn atomic_thread_fence_rel();
}
extern "C" {
    pub fn atomic_thread_fence_seq_cst();
}
extern "C" {
    pub fn atomic_set_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_set_barr_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_clear_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_clear_barr_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_add_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_add_barr_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_subtract_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_subtract_barr_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_set_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_set_barr_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_clear_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_clear_barr_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_add_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_add_barr_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_subtract_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_subtract_barr_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_set_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_set_barr_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_clear_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_clear_barr_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_add_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_add_barr_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_subtract_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_subtract_barr_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_set_long(p: *mut u_long, v: u_long);
}
extern "C" {
    pub fn atomic_set_barr_long(p: *mut u_long, v: u_long);
}
extern "C" {
    pub fn atomic_clear_long(p: *mut u_long, v: u_long);
}
extern "C" {
    pub fn atomic_clear_barr_long(p: *mut u_long, v: u_long);
}
extern "C" {
    pub fn atomic_add_long(p: *mut u_long, v: u_long);
}
extern "C" {
    pub fn atomic_add_barr_long(p: *mut u_long, v: u_long);
}
extern "C" {
    pub fn atomic_subtract_long(p: *mut u_long, v: u_long);
}
extern "C" {
    pub fn atomic_subtract_barr_long(p: *mut u_long, v: u_long);
}
extern "C" {
    pub fn atomic_load_acq_char(p: *mut u_char) -> u_char;
}
extern "C" {
    pub fn atomic_store_rel_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_load_acq_short(p: *mut u_short) -> u_short;
}
extern "C" {
    pub fn atomic_store_rel_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_load_acq_int(p: *mut u_int) -> u_int;
}
extern "C" {
    pub fn atomic_store_rel_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_load_acq_long(p: *mut u_long) -> u_long;
}
extern "C" {
    pub fn atomic_store_rel_long(p: *mut u_long, v: u_long);
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy)]
pub struct region_descriptor {
    pub _bitfield_1: [u64; 2usize],
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_region_descriptor() {
    assert_eq!(::std::mem::size_of::<region_descriptor>() , 10usize , concat !
               ( "Size of: " , stringify ! ( region_descriptor ) ));
    assert_eq! (::std::mem::align_of::<region_descriptor>() , 1usize , concat
                ! ( "Alignment of " , stringify ! ( region_descriptor ) ));
}
impl Clone for region_descriptor {
    fn clone(&self) -> Self { *self }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy)]
pub struct invpcid_descr {
    pub _bitfield_1: u64,
    pub addr: u64,
}
#[test]
fn bindgen_test_layout_invpcid_descr() {
    assert_eq!(::std::mem::size_of::<invpcid_descr>() , 16usize , concat ! (
               "Size of: " , stringify ! ( invpcid_descr ) ));
    assert_eq! (::std::mem::align_of::<invpcid_descr>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( invpcid_descr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const invpcid_descr ) ) . addr as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( invpcid_descr ) , "::"
                , stringify ! ( addr ) ));
}
impl Clone for invpcid_descr {
    fn clone(&self) -> Self { *self }
}
impl invpcid_descr {
    #[inline]
    pub fn pcid(&self) -> u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 4095u64 as u64;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_pcid(&mut self, val: u64) {
        let mask = 4095u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn pad(&self) -> u64 {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        let mask = 18446744073709547520u64 as u64;
        let val = (unit_field_val & mask) >> 12usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_pad(&mut self, val: u64) {
        let mask = 18446744073709547520u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u64 as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 12usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(pcid: u64, pad: u64) -> u64 {
        ({ ({ 0 } | ((pcid as u64 as u64) << 0usize) & (4095u64 as u64)) } |
             ((pad as u64 as u64) << 12usize) &
                 (18446744073709547520u64 as u64))
    }
}
pub const SGX_ECREATE: _bindgen_ty_1 = _bindgen_ty_1::SGX_ECREATE;
pub const SGX_EADD: _bindgen_ty_1 = _bindgen_ty_1::SGX_EADD;
pub const SGX_EINIT: _bindgen_ty_1 = _bindgen_ty_1::SGX_EINIT;
pub const SGX_EREMOVE: _bindgen_ty_1 = _bindgen_ty_1::SGX_EREMOVE;
pub const SGX_EDGBRD: _bindgen_ty_1 = _bindgen_ty_1::SGX_EDGBRD;
pub const SGX_EDGBWR: _bindgen_ty_1 = _bindgen_ty_1::SGX_EDGBWR;
pub const SGX_EEXTEND: _bindgen_ty_1 = _bindgen_ty_1::SGX_EEXTEND;
pub const SGX_ELDU: _bindgen_ty_1 = _bindgen_ty_1::SGX_ELDU;
pub const SGX_EBLOCK: _bindgen_ty_1 = _bindgen_ty_1::SGX_EBLOCK;
pub const SGX_EPA: _bindgen_ty_1 = _bindgen_ty_1::SGX_EPA;
pub const SGX_EWB: _bindgen_ty_1 = _bindgen_ty_1::SGX_EWB;
pub const SGX_ETRACK: _bindgen_ty_1 = _bindgen_ty_1::SGX_ETRACK;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_1 {
    SGX_ECREATE = 0,
    SGX_EADD = 1,
    SGX_EINIT = 2,
    SGX_EREMOVE = 3,
    SGX_EDGBRD = 4,
    SGX_EDGBWR = 5,
    SGX_EEXTEND = 6,
    SGX_ELDU = 8,
    SGX_EBLOCK = 9,
    SGX_EPA = 10,
    SGX_EWB = 11,
    SGX_ETRACK = 12,
}
pub const SGX_PT_SECS: _bindgen_ty_2 = _bindgen_ty_2::SGX_PT_SECS;
pub const SGX_PT_TCS: _bindgen_ty_2 = _bindgen_ty_2::SGX_PT_TCS;
pub const SGX_PT_REG: _bindgen_ty_2 = _bindgen_ty_2::SGX_PT_REG;
pub const SGX_PT_VA: _bindgen_ty_2 = _bindgen_ty_2::SGX_PT_VA;
pub const SGX_PT_TRIM: _bindgen_ty_2 = _bindgen_ty_2::SGX_PT_TRIM;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_2 {
    SGX_PT_SECS = 0,
    SGX_PT_TCS = 1,
    SGX_PT_REG = 2,
    SGX_PT_VA = 3,
    SGX_PT_TRIM = 4,
}
extern "C" {
    pub fn sgx_encls(eax: u32, rbx: u64, rcx: u64, rdx: u64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn reset_dbregs();
}
extern "C" {
    pub fn rdmsr_safe(msr: u_int, val: *mut u64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wrmsr_safe(msr: u_int, newval: u64) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lock_object {
    pub lo_name: *const ::std::os::raw::c_char,
    pub lo_flags: u_int,
    pub lo_data: u_int,
    pub lo_witness: *mut witness,
}
#[test]
fn bindgen_test_layout_lock_object() {
    assert_eq!(::std::mem::size_of::<lock_object>() , 24usize , concat ! (
               "Size of: " , stringify ! ( lock_object ) ));
    assert_eq! (::std::mem::align_of::<lock_object>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lock_object ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_object ) ) . lo_name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_object ) , "::" ,
                stringify ! ( lo_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_object ) ) . lo_flags as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_object ) , "::" ,
                stringify ! ( lo_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_object ) ) . lo_data as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_object ) , "::" ,
                stringify ! ( lo_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_object ) ) . lo_witness as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_object ) , "::" ,
                stringify ! ( lo_witness ) ));
}
impl Clone for lock_object {
    fn clone(&self) -> Self { *self }
}
impl Default for lock_object {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct callout_list {
    pub lh_first: *mut callout,
}
#[test]
fn bindgen_test_layout_callout_list() {
    assert_eq!(::std::mem::size_of::<callout_list>() , 8usize , concat ! (
               "Size of: " , stringify ! ( callout_list ) ));
    assert_eq! (::std::mem::align_of::<callout_list>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( callout_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout_list ) ) . lh_first as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( callout_list ) , "::" ,
                stringify ! ( lh_first ) ));
}
impl Clone for callout_list {
    fn clone(&self) -> Self { *self }
}
impl Default for callout_list {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct callout_slist {
    pub slh_first: *mut callout,
}
#[test]
fn bindgen_test_layout_callout_slist() {
    assert_eq!(::std::mem::size_of::<callout_slist>() , 8usize , concat ! (
               "Size of: " , stringify ! ( callout_slist ) ));
    assert_eq! (::std::mem::align_of::<callout_slist>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( callout_slist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout_slist ) ) . slh_first as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( callout_slist ) , "::"
                , stringify ! ( slh_first ) ));
}
impl Clone for callout_slist {
    fn clone(&self) -> Self { *self }
}
impl Default for callout_slist {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct callout_tailq {
    pub tqh_first: *mut callout,
    pub tqh_last: *mut *mut callout,
}
#[test]
fn bindgen_test_layout_callout_tailq() {
    assert_eq!(::std::mem::size_of::<callout_tailq>() , 16usize , concat ! (
               "Size of: " , stringify ! ( callout_tailq ) ));
    assert_eq! (::std::mem::align_of::<callout_tailq>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( callout_tailq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout_tailq ) ) . tqh_first as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( callout_tailq ) , "::"
                , stringify ! ( tqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout_tailq ) ) . tqh_last as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( callout_tailq ) , "::"
                , stringify ! ( tqh_last ) ));
}
impl Clone for callout_tailq {
    fn clone(&self) -> Self { *self }
}
impl Default for callout_tailq {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct callout {
    pub c_links: callout__bindgen_ty_1,
    pub c_time: sbintime_t,
    pub c_precision: sbintime_t,
    pub c_arg: *mut ::std::os::raw::c_void,
    pub c_func: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                               *mut ::std::os::raw::c_void)>,
    pub c_lock: *mut lock_object,
    pub c_flags: ::std::os::raw::c_short,
    pub c_iflags: ::std::os::raw::c_short,
    pub c_cpu: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy)]
pub union callout__bindgen_ty_1 {
    pub le: callout__bindgen_ty_1__bindgen_ty_1,
    pub sle: callout__bindgen_ty_1__bindgen_ty_2,
    pub tqe: callout__bindgen_ty_1__bindgen_ty_3,
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct callout__bindgen_ty_1__bindgen_ty_1 {
    pub le_next: *mut callout,
    pub le_prev: *mut *mut callout,
}
#[test]
fn bindgen_test_layout_callout__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<callout__bindgen_ty_1__bindgen_ty_1>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( callout__bindgen_ty_1__bindgen_ty_1
               ) ));
    assert_eq! (::std::mem::align_of::<callout__bindgen_ty_1__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                callout__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout__bindgen_ty_1__bindgen_ty_1 ) ) .
                le_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                callout__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! (
                le_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout__bindgen_ty_1__bindgen_ty_1 ) ) .
                le_prev as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                callout__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! (
                le_prev ) ));
}
impl Clone for callout__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for callout__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct callout__bindgen_ty_1__bindgen_ty_2 {
    pub sle_next: *mut callout,
}
#[test]
fn bindgen_test_layout_callout__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<callout__bindgen_ty_1__bindgen_ty_2>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( callout__bindgen_ty_1__bindgen_ty_2
               ) ));
    assert_eq! (::std::mem::align_of::<callout__bindgen_ty_1__bindgen_ty_2>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                callout__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout__bindgen_ty_1__bindgen_ty_2 ) ) .
                sle_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                callout__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify ! (
                sle_next ) ));
}
impl Clone for callout__bindgen_ty_1__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for callout__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct callout__bindgen_ty_1__bindgen_ty_3 {
    pub tqe_next: *mut callout,
    pub tqe_prev: *mut *mut callout,
}
#[test]
fn bindgen_test_layout_callout__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(::std::mem::size_of::<callout__bindgen_ty_1__bindgen_ty_3>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( callout__bindgen_ty_1__bindgen_ty_3
               ) ));
    assert_eq! (::std::mem::align_of::<callout__bindgen_ty_1__bindgen_ty_3>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                callout__bindgen_ty_1__bindgen_ty_3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout__bindgen_ty_1__bindgen_ty_3 ) ) .
                tqe_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                callout__bindgen_ty_1__bindgen_ty_3 ) , "::" , stringify ! (
                tqe_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout__bindgen_ty_1__bindgen_ty_3 ) ) .
                tqe_prev as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                callout__bindgen_ty_1__bindgen_ty_3 ) , "::" , stringify ! (
                tqe_prev ) ));
}
impl Clone for callout__bindgen_ty_1__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
impl Default for callout__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_callout__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<callout__bindgen_ty_1>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( callout__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<callout__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( callout__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout__bindgen_ty_1 ) ) . le as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( callout__bindgen_ty_1 )
                , "::" , stringify ! ( le ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout__bindgen_ty_1 ) ) . sle as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( callout__bindgen_ty_1 )
                , "::" , stringify ! ( sle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout__bindgen_ty_1 ) ) . tqe as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( callout__bindgen_ty_1 )
                , "::" , stringify ! ( tqe ) ));
}
impl Clone for callout__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for callout__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl ::std::fmt::Debug for callout__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f , "callout__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_callout() {
    assert_eq!(::std::mem::size_of::<callout>() , 64usize , concat ! (
               "Size of: " , stringify ! ( callout ) ));
    assert_eq! (::std::mem::align_of::<callout>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( callout ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout ) ) . c_links as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( callout ) , "::" ,
                stringify ! ( c_links ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout ) ) . c_time as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( callout ) , "::" ,
                stringify ! ( c_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout ) ) . c_precision as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( callout ) , "::" ,
                stringify ! ( c_precision ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout ) ) . c_arg as * const _ as usize
                } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( callout ) , "::" ,
                stringify ! ( c_arg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout ) ) . c_func as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( callout ) , "::" ,
                stringify ! ( c_func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout ) ) . c_lock as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( callout ) , "::" ,
                stringify ! ( c_lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout ) ) . c_flags as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( callout ) , "::" ,
                stringify ! ( c_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout ) ) . c_iflags as * const _ as
                usize } , 58usize , concat ! (
                "Alignment of field: " , stringify ! ( callout ) , "::" ,
                stringify ! ( c_iflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout ) ) . c_cpu as * const _ as usize
                } , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( callout ) , "::" ,
                stringify ! ( c_cpu ) ));
}
impl Clone for callout {
    fn clone(&self) -> Self { *self }
}
impl Default for callout {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl ::std::fmt::Debug for callout {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f ,
               "callout {{ c_links: {:?}, c_time: {:?}, c_precision: {:?}, c_arg: {:?}, c_func: {:?}, c_lock: {:?}, c_flags: {:?}, c_iflags: {:?}, c_cpu: {:?} }}"
               , self . c_links , self . c_time , self . c_precision , self .
               c_arg , self . c_func , self . c_lock , self . c_flags , self .
               c_iflags , self . c_cpu)
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct callout_handle {
    pub callout: *mut callout,
}
#[test]
fn bindgen_test_layout_callout_handle() {
    assert_eq!(::std::mem::size_of::<callout_handle>() , 8usize , concat ! (
               "Size of: " , stringify ! ( callout_handle ) ));
    assert_eq! (::std::mem::align_of::<callout_handle>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( callout_handle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout_handle ) ) . callout as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( callout_handle ) , "::"
                , stringify ! ( callout ) ));
}
impl Clone for callout_handle {
    fn clone(&self) -> Self { *self }
}
impl Default for callout_handle {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
extern "C" {
    pub fn callout_init(arg1: *mut callout, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _callout_init_lock(arg1: *mut callout, arg2: *mut lock_object,
                              arg3: ::std::os::raw::c_int);
}
extern "C" {
    pub fn callout_reset_sbt_on(arg1: *mut callout, arg2: sbintime_t,
                                arg3: sbintime_t,
                                arg4:
                                    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                   *mut ::std::os::raw::c_void)>,
                                arg5: *mut ::std::os::raw::c_void,
                                arg6: ::std::os::raw::c_int,
                                arg7: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn callout_schedule(arg1: *mut callout, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn callout_schedule_on(arg1: *mut callout,
                               arg2: ::std::os::raw::c_int,
                               arg3: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _callout_stop_safe(arg1: *mut callout, arg2: ::std::os::raw::c_int,
                              arg3:
                                  ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                 *mut ::std::os::raw::c_void)>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn callout_process(now: sbintime_t);
}
extern "C" {
    pub fn callout_when(sbt: sbintime_t, precision: sbintime_t,
                        flags: ::std::os::raw::c_int,
                        sbt_res: *mut sbintime_t, prec_res: *mut sbintime_t);
}
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = __int_fast8_t;
pub type int_fast16_t = __int_fast16_t;
pub type int_fast32_t = __int_fast32_t;
pub type int_fast64_t = __int_fast64_t;
pub type uint_fast8_t = __uint_fast8_t;
pub type uint_fast16_t = __uint_fast16_t;
pub type uint_fast32_t = __uint_fast32_t;
pub type uint_fast64_t = __uint_fast64_t;
extern "C" {
    #[link_name = "cold"]
    pub static mut cold: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "suspend_blocked"]
    pub static mut suspend_blocked: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "rebooting"]
    pub static mut rebooting: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "panicstr"]
    pub static mut panicstr: *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "version"]
    pub static mut version: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "compiler_version"]
    pub static mut compiler_version: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "copyright"]
    pub static mut copyright: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "kstack_pages"]
    pub static mut kstack_pages: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "pagesizes"]
    pub static mut pagesizes: [u_long; 0usize];
}
extern "C" {
    #[link_name = "physmem"]
    pub static mut physmem: ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "realmem"]
    pub static mut realmem: ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "rootdevnames"]
    pub static mut rootdevnames: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    #[link_name = "boothowto"]
    pub static mut boothowto: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "bootverbose"]
    pub static mut bootverbose: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "maxusers"]
    pub static mut maxusers: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "ngroups_max"]
    pub static mut ngroups_max: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "vm_guest"]
    pub static mut vm_guest: ::std::os::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VM_GUEST {
    VM_GUEST_NO = 0,
    VM_GUEST_VM = 1,
    VM_GUEST_XEN = 2,
    VM_GUEST_HV = 3,
    VM_GUEST_VMWARE = 4,
    VM_GUEST_KVM = 5,
    VM_GUEST_BHYVE = 6,
    VM_LAST = 7,
}
extern "C" {
    #[link_name = "osreldate"]
    pub static mut osreldate: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "envmode"]
    pub static mut envmode: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "hintmode"]
    pub static mut hintmode: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "dynamic_kenv"]
    pub static mut dynamic_kenv: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mtx {
    pub lock_object: lock_object,
    pub mtx_lock: usize,
}
#[test]
fn bindgen_test_layout_mtx() {
    assert_eq!(::std::mem::size_of::<mtx>() , 32usize , concat ! (
               "Size of: " , stringify ! ( mtx ) ));
    assert_eq! (::std::mem::align_of::<mtx>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( mtx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mtx ) ) . lock_object as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mtx ) , "::" ,
                stringify ! ( lock_object ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mtx ) ) . mtx_lock as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( mtx ) , "::" ,
                stringify ! ( mtx_lock ) ));
}
impl Clone for mtx {
    fn clone(&self) -> Self { *self }
}
impl Default for mtx {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
extern "C" {
    #[link_name = "kenv_lock"]
    pub static mut kenv_lock: mtx;
}
extern "C" {
    #[link_name = "kern_envp"]
    pub static mut kern_envp: *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "static_env"]
    pub static mut static_env: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "static_hints"]
    pub static mut static_hints: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "kenvp"]
    pub static mut kenvp: *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "zero_region"]
    pub static mut zero_region: *const ::std::os::raw::c_void;
}
extern "C" {
    #[link_name = "unmapped_buf_allowed"]
    pub static mut unmapped_buf_allowed: ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct malloc_type {
    pub ks_next: *mut malloc_type,
    pub ks_magic: u_long,
    pub ks_shortdesc: *const ::std::os::raw::c_char,
    pub ks_handle: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_malloc_type() {
    assert_eq!(::std::mem::size_of::<malloc_type>() , 32usize , concat ! (
               "Size of: " , stringify ! ( malloc_type ) ));
    assert_eq! (::std::mem::align_of::<malloc_type>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( malloc_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type ) ) . ks_next as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_type ) , "::" ,
                stringify ! ( ks_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type ) ) . ks_magic as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_type ) , "::" ,
                stringify ! ( ks_magic ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type ) ) . ks_shortdesc as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_type ) , "::" ,
                stringify ! ( ks_shortdesc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type ) ) . ks_handle as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_type ) , "::" ,
                stringify ! ( ks_handle ) ));
}
impl Clone for malloc_type {
    fn clone(&self) -> Self { *self }
}
impl Default for malloc_type {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct proc_ {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct thread {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tty {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucred {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uio {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _jmp_buf {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct trapframe {
    pub tf_rdi: register_t,
    pub tf_rsi: register_t,
    pub tf_rdx: register_t,
    pub tf_rcx: register_t,
    pub tf_r8: register_t,
    pub tf_r9: register_t,
    pub tf_rax: register_t,
    pub tf_rbx: register_t,
    pub tf_rbp: register_t,
    pub tf_r10: register_t,
    pub tf_r11: register_t,
    pub tf_r12: register_t,
    pub tf_r13: register_t,
    pub tf_r14: register_t,
    pub tf_r15: register_t,
    pub tf_trapno: u32,
    pub tf_fs: u16,
    pub tf_gs: u16,
    pub tf_addr: register_t,
    pub tf_flags: u32,
    pub tf_es: u16,
    pub tf_ds: u16,
    pub tf_err: register_t,
    pub tf_rip: register_t,
    pub tf_cs: register_t,
    pub tf_rflags: register_t,
    pub tf_rsp: register_t,
    pub tf_ss: register_t,
}
#[test]
fn bindgen_test_layout_trapframe() {
    assert_eq!(::std::mem::size_of::<trapframe>() , 192usize , concat ! (
               "Size of: " , stringify ! ( trapframe ) ));
    assert_eq! (::std::mem::align_of::<trapframe>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( trapframe ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_rdi as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_rdi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_rsi as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_rsi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_rdx as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_rdx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_rcx as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_rcx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_r8 as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_r8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_r9 as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_r9 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_rax as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_rax ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_rbx as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_rbx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_rbp as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_rbp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_r10 as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_r10 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_r11 as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_r11 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_r12 as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_r12 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_r13 as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_r13 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_r14 as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_r14 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_r15 as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_r15 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_trapno as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_trapno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_fs as * const _ as
                usize } , 124usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_fs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_gs as * const _ as
                usize } , 126usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_gs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_addr as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_flags as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_es as * const _ as
                usize } , 140usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_es ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_ds as * const _ as
                usize } , 142usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_ds ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_err as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_err ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_rip as * const _ as
                usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_rip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_cs as * const _ as
                usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_cs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_rflags as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_rflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_rsp as * const _ as
                usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_rsp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_ss as * const _ as
                usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_ss ) ));
}
impl Clone for trapframe {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eventtimer {
    _unused: [u8; 0],
}
extern "C" {
    pub fn setjmp(arg1: *mut _jmp_buf) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn longjmp(arg1: *mut _jmp_buf, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn dumpstatus(addr: vm_offset_t, count: off_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nullop() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn eopnotsupp() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ureadc(arg1: ::std::os::raw::c_int, arg2: *mut uio)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hashdestroy(arg1: *mut ::std::os::raw::c_void,
                       arg2: *mut malloc_type, arg3: u_long);
}
extern "C" {
    pub fn hashinit(count: ::std::os::raw::c_int, type_: *mut malloc_type,
                    hashmask: *mut u_long) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn hashinit_flags(count: ::std::os::raw::c_int,
                          type_: *mut malloc_type, hashmask: *mut u_long,
                          flags: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn phashinit(count: ::std::os::raw::c_int, type_: *mut malloc_type,
                     nentries: *mut u_long) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn phashinit_flags(count: ::std::os::raw::c_int,
                           type_: *mut malloc_type, nentries: *mut u_long,
                           flags: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn g_waitidle();
}
extern "C" {
    pub fn panic(arg1: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn vpanic(arg1: *const ::std::os::raw::c_char,
                  arg2: *mut __va_list_tag);
}
extern "C" {
    pub fn cpu_boot(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn cpu_flush_dcache(arg1: *mut ::std::os::raw::c_void, arg2: usize);
}
extern "C" {
    pub fn cpu_rootconf();
}
extern "C" {
    pub fn critical_enter();
}
extern "C" {
    pub fn critical_exit();
}
extern "C" {
    pub fn init_param1();
}
extern "C" {
    pub fn init_param2(physpages: ::std::os::raw::c_long);
}
extern "C" {
    pub fn init_static_kenv(arg1: *mut ::std::os::raw::c_char, arg2: usize);
}
extern "C" {
    pub fn tablefull(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn kvprintf(arg1: *const ::std::os::raw::c_char,
                    arg2:
                        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                       ::std::os::raw::c_int,
                                                                   arg2:
                                                                       *mut ::std::os::raw::c_void)>,
                    arg3: *mut ::std::os::raw::c_void,
                    arg4: ::std::os::raw::c_int, arg5: *mut __va_list_tag)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn log(arg1: ::std::os::raw::c_int,
               arg2: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn log_console(arg1: *mut uio);
}
extern "C" {
    pub fn vlog(arg1: ::std::os::raw::c_int,
                arg2: *const ::std::os::raw::c_char,
                arg3: *mut __va_list_tag);
}
extern "C" {
    pub fn asprintf(ret: *mut *mut ::std::os::raw::c_char,
                    mtp: *mut malloc_type,
                    format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(arg1: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(arg1: *mut ::std::os::raw::c_char, arg2: usize,
                    arg3: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(buf: *mut ::std::os::raw::c_char,
                   arg1: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uprintf(arg1: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(arg1: *const ::std::os::raw::c_char,
                   arg2: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasprintf(ret: *mut *mut ::std::os::raw::c_char,
                     mtp: *mut malloc_type,
                     format: *const ::std::os::raw::c_char,
                     ap: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(arg1: *mut ::std::os::raw::c_char, arg2: usize,
                     arg3: *const ::std::os::raw::c_char,
                     arg4: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnrprintf(arg1: *mut ::std::os::raw::c_char, arg2: usize,
                      arg3: ::std::os::raw::c_int,
                      arg4: *const ::std::os::raw::c_char,
                      arg5: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(buf: *mut ::std::os::raw::c_char,
                    arg1: *const ::std::os::raw::c_char,
                    arg2: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ttyprintf(arg1: *mut tty, arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(arg1: *const ::std::os::raw::c_char,
                  arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(arg1: *const ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char,
                   arg3: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strtol(arg1: *const ::std::os::raw::c_char,
                  arg2: *mut *mut ::std::os::raw::c_char,
                  arg3: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(arg1: *const ::std::os::raw::c_char,
                   arg2: *mut *mut ::std::os::raw::c_char,
                   arg3: ::std::os::raw::c_int) -> u_long;
}
extern "C" {
    pub fn strtoq(arg1: *const ::std::os::raw::c_char,
                  arg2: *mut *mut ::std::os::raw::c_char,
                  arg3: ::std::os::raw::c_int) -> quad_t;
}
extern "C" {
    pub fn strtouq(arg1: *const ::std::os::raw::c_char,
                   arg2: *mut *mut ::std::os::raw::c_char,
                   arg3: ::std::os::raw::c_int) -> u_quad_t;
}
extern "C" {
    pub fn tprintf(p: *mut proc_, pri: ::std::os::raw::c_int,
                   arg1: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn vtprintf(arg1: *mut proc_, arg2: ::std::os::raw::c_int,
                    arg3: *const ::std::os::raw::c_char,
                    arg4: *mut __va_list_tag);
}
extern "C" {
    pub fn hexdump(ptr: *const ::std::os::raw::c_void,
                   length: ::std::os::raw::c_int,
                   hdr: *const ::std::os::raw::c_char,
                   flags: ::std::os::raw::c_int);
}
extern "C" {
    pub fn bcopy(from: *const ::std::os::raw::c_void,
                 to: *mut ::std::os::raw::c_void, len: usize);
}
extern "C" {
    pub fn bzero(buf: *mut ::std::os::raw::c_void, len: usize);
}
extern "C" {
    pub fn explicit_bzero(arg1: *mut ::std::os::raw::c_void, arg2: usize);
}
extern "C" {
    pub fn memcpy(to: *mut ::std::os::raw::c_void,
                  from: *const ::std::os::raw::c_void, len: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(dest: *mut ::std::os::raw::c_void,
                   src: *const ::std::os::raw::c_void, n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn copystr(kfaddr: *const ::std::os::raw::c_void,
                   kdaddr: *mut ::std::os::raw::c_void, len: usize,
                   lencopied: *mut usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn copyinstr(udaddr: *const ::std::os::raw::c_void,
                     kaddr: *mut ::std::os::raw::c_void, len: usize,
                     lencopied: *mut usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn copyin(udaddr: *const ::std::os::raw::c_void,
                  kaddr: *mut ::std::os::raw::c_void, len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn copyin_nofault(udaddr: *const ::std::os::raw::c_void,
                          kaddr: *mut ::std::os::raw::c_void, len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn copyout(kaddr: *const ::std::os::raw::c_void,
                   udaddr: *mut ::std::os::raw::c_void, len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn copyout_nofault(kaddr: *const ::std::os::raw::c_void,
                           udaddr: *mut ::std::os::raw::c_void, len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fubyte(base: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fuword(base: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn fuword16(base: *const ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fuword32(base: *const ::std::os::raw::c_void) -> i32;
}
extern "C" {
    pub fn fuword64(base: *const ::std::os::raw::c_void) -> i64;
}
extern "C" {
    pub fn fueword(base: *const ::std::os::raw::c_void,
                   val: *mut ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fueword32(base: *const ::std::os::raw::c_void, val: *mut i32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fueword64(base: *const ::std::os::raw::c_void, val: *mut i64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn subyte(base: *mut ::std::os::raw::c_void,
                  byte: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn suword(base: *mut ::std::os::raw::c_void,
                  word: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn suword16(base: *mut ::std::os::raw::c_void,
                    word: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn suword32(base: *mut ::std::os::raw::c_void, word: i32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn suword64(base: *mut ::std::os::raw::c_void, word: i64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn casuword32(base: *mut u32, oldval: u32, newval: u32) -> u32;
}
extern "C" {
    pub fn casuword(p: *mut u_long, oldval: u_long, newval: u_long) -> u_long;
}
extern "C" {
    pub fn casueword32(base: *mut u32, oldval: u32, oldvalp: *mut u32,
                       newval: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn casueword(p: *mut u_long, oldval: u_long, oldvalp: *mut u_long,
                     newval: u_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realitexpire(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn sysbeep(hertz: ::std::os::raw::c_int,
                   period: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn hardclock(usermode: ::std::os::raw::c_int, pc: uintfptr_t);
}
extern "C" {
    pub fn hardclock_cnt(cnt: ::std::os::raw::c_int,
                         usermode: ::std::os::raw::c_int);
}
extern "C" {
    pub fn hardclock_cpu(usermode: ::std::os::raw::c_int);
}
extern "C" {
    pub fn hardclock_sync(cpu: ::std::os::raw::c_int);
}
extern "C" {
    pub fn softclock(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn statclock(usermode: ::std::os::raw::c_int);
}
extern "C" {
    pub fn statclock_cnt(cnt: ::std::os::raw::c_int,
                         usermode: ::std::os::raw::c_int);
}
extern "C" {
    pub fn profclock(usermode: ::std::os::raw::c_int, pc: uintfptr_t);
}
extern "C" {
    pub fn profclock_cnt(cnt: ::std::os::raw::c_int,
                         usermode: ::std::os::raw::c_int, pc: uintfptr_t);
}
extern "C" {
    pub fn hardclockintr() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn startprofclock(arg1: *mut proc_);
}
extern "C" {
    pub fn stopprofclock(arg1: *mut proc_);
}
extern "C" {
    pub fn cpu_startprofclock();
}
extern "C" {
    pub fn cpu_stopprofclock();
}
extern "C" {
    pub fn cpu_idleclock() -> sbintime_t;
}
extern "C" {
    pub fn cpu_activeclock();
}
extern "C" {
    pub fn cpu_new_callout(cpu: ::std::os::raw::c_int, bt: sbintime_t,
                           bt_opt: sbintime_t);
}
extern "C" {
    pub fn cpu_et_frequency(et: *mut eventtimer, newfreq: u64);
}
extern "C" {
    #[link_name = "cpu_disable_c2_sleep"]
    pub static mut cpu_disable_c2_sleep: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "cpu_disable_c3_sleep"]
    pub static mut cpu_disable_c3_sleep: ::std::os::raw::c_int;
}
extern "C" {
    pub fn kern_getenv(name: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn freeenv(env: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn getenv_int(name: *const ::std::os::raw::c_char,
                      data: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getenv_uint(name: *const ::std::os::raw::c_char,
                       data: *mut ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getenv_long(name: *const ::std::os::raw::c_char,
                       data: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getenv_ulong(name: *const ::std::os::raw::c_char,
                        data: *mut ::std::os::raw::c_ulong)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getenv_string(name: *const ::std::os::raw::c_char,
                         data: *mut ::std::os::raw::c_char,
                         size: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getenv_int64(name: *const ::std::os::raw::c_char, data: *mut i64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getenv_uint64(name: *const ::std::os::raw::c_char, data: *mut u64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getenv_quad(name: *const ::std::os::raw::c_char, data: *mut quad_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kern_setenv(name: *const ::std::os::raw::c_char,
                       value: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kern_unsetenv(name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn testenv(name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
pub type cpu_tick_f = ::std::option::Option<unsafe extern "C" fn() -> u64>;
extern "C" {
    pub fn set_cputicker(func: cpu_tick_f, freq: u64,
                         var: ::std::os::raw::c_uint);
}
extern "C" {
    #[link_name = "cpu_ticks"]
    pub static mut cpu_ticks: cpu_tick_f;
}
extern "C" {
    pub fn cpu_tickrate() -> u64;
}
extern "C" {
    pub fn cputick2usec(tick: u64) -> u64;
}
extern "C" {
    #[link_name = "bcd2bin_data"]
    pub static mut bcd2bin_data: [u_char; 0usize];
}
extern "C" {
    #[link_name = "bin2bcd_data"]
    pub static mut bin2bcd_data: [u_char; 0usize];
}
extern "C" {
    #[link_name = "hex2ascii_data"]
    pub static mut hex2ascii_data: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "arc4rand_iniseed_state"]
    pub static mut arc4rand_iniseed_state: ::std::os::raw::c_int;
}
extern "C" {
    pub fn arc4random() -> u32;
}
extern "C" {
    pub fn arc4random_buf(arg1: *mut ::std::os::raw::c_void, arg2: usize);
}
extern "C" {
    pub fn arc4rand(arg1: *mut ::std::os::raw::c_void, arg2: u_int,
                    arg3: ::std::os::raw::c_int);
}
extern "C" {
    pub fn bcmp(arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void, arg3: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timingsafe_bcmp(arg1: *const ::std::os::raw::c_void,
                           arg2: *const ::std::os::raw::c_void, arg3: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bsearch(arg1: *const ::std::os::raw::c_void,
                   arg2: *const ::std::os::raw::c_void, arg3: usize,
                   arg4: usize,
                   arg5:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *const ::std::os::raw::c_void,
                                                                  arg2:
                                                                      *const ::std::os::raw::c_void)
                                                 -> ::std::os::raw::c_int>)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn fnmatch(arg1: *const ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char,
                   arg3: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn locc(arg1: ::std::os::raw::c_int,
                arg2: *mut ::std::os::raw::c_char, arg3: u_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(s: *const ::std::os::raw::c_void, c: ::std::os::raw::c_int,
                  n: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcchr(s: *const ::std::os::raw::c_void, c: ::std::os::raw::c_int,
                   n: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(b1: *const ::std::os::raw::c_void,
                  b2: *const ::std::os::raw::c_void, len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memmem(l: *const ::std::os::raw::c_void, l_len: usize,
                  s: *const ::std::os::raw::c_void, s_len: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(base: *mut ::std::os::raw::c_void, nmemb: usize, size: usize,
                 compar:
                     ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                    *const ::std::os::raw::c_void,
                                                                arg2:
                                                                    *const ::std::os::raw::c_void)
                                               -> ::std::os::raw::c_int>);
}
extern "C" {
    pub fn qsort_r(base: *mut ::std::os::raw::c_void, nmemb: usize,
                   size: usize, thunk: *mut ::std::os::raw::c_void,
                   compar:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ::std::os::raw::c_void,
                                                                  arg2:
                                                                      *const ::std::os::raw::c_void,
                                                                  arg3:
                                                                      *const ::std::os::raw::c_void)
                                                 -> ::std::os::raw::c_int>);
}
extern "C" {
    pub fn random() -> u_long;
}
extern "C" {
    pub fn scanc(arg1: u_int, arg2: *const u_char, arg3: *const u_char,
                 arg4: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom(arg1: u_long);
}
extern "C" {
    pub fn strcasecmp(arg1: *const ::std::os::raw::c_char,
                      arg2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcat(arg1: *mut ::std::os::raw::c_char,
                  arg2: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(arg1: *const ::std::os::raw::c_char,
                  arg2: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(arg1: *const ::std::os::raw::c_char,
                  arg2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcpy(arg1: *mut ::std::os::raw::c_char,
                  arg2: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(arg1: *const ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char) -> usize;
}
extern "C" {
    pub fn strdup(arg1: *const ::std::os::raw::c_char, arg2: *mut malloc_type)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(arg1: *mut ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char, arg3: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(arg1: *const ::std::os::raw::c_char, arg2: usize,
                   arg3: *mut malloc_type) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlcat(arg1: *mut ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char, arg3: usize) -> usize;
}
extern "C" {
    pub fn strlcpy(arg1: *mut ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char, arg3: usize) -> usize;
}
extern "C" {
    pub fn strlen(arg1: *const ::std::os::raw::c_char) -> usize;
}
extern "C" {
    pub fn strncasecmp(arg1: *const ::std::os::raw::c_char,
                       arg2: *const ::std::os::raw::c_char, arg3: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncmp(arg1: *const ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char, arg3: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncpy(arg1: *mut ::std::os::raw::c_char,
                   arg2: *const ::std::os::raw::c_char, arg3: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnlen(arg1: *const ::std::os::raw::c_char, arg2: usize) -> usize;
}
extern "C" {
    pub fn strrchr(arg1: *const ::std::os::raw::c_char,
                   arg2: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsep(arg1: *mut *mut ::std::os::raw::c_char,
                  delim: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strspn(arg1: *const ::std::os::raw::c_char,
                  arg2: *const ::std::os::raw::c_char) -> usize;
}
extern "C" {
    pub fn strstr(arg1: *const ::std::os::raw::c_char,
                  arg2: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strvalid(arg1: *const ::std::os::raw::c_char, arg2: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "crc32_tab"]
    pub static mut crc32_tab: [u32; 0usize];
}
extern "C" {
    pub fn calculate_crc32c(crc32c: u32,
                            buffer: *const ::std::os::raw::c_uchar,
                            length: ::std::os::raw::c_uint) -> u32;
}
extern "C" {
    pub fn sse42_crc32c(arg1: u32, arg2: *const ::std::os::raw::c_uchar,
                        arg3: ::std::os::raw::c_uint) -> u32;
}
extern "C" {
    pub fn consinit();
}
extern "C" {
    pub fn cpu_initclocks();
}
extern "C" {
    pub fn cpu_initclocks_bsp();
}
extern "C" {
    pub fn cpu_initclocks_ap();
}
extern "C" {
    pub fn usrinfoinit();
}
extern "C" {
    pub fn kern_reboot(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn shutdown_nice(arg1: ::std::os::raw::c_int);
}
pub type timeout_t =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void)>;
extern "C" {
    pub fn callout_handle_init(arg1: *mut callout_handle);
}
extern "C" {
    pub fn timeout(arg1: timeout_t, arg2: *mut ::std::os::raw::c_void,
                   arg3: ::std::os::raw::c_int) -> callout_handle;
}
extern "C" {
    pub fn untimeout(arg1: timeout_t, arg2: *mut ::std::os::raw::c_void,
                     arg3: callout_handle);
}
extern "C" {
    pub fn _sleep(chan: *mut ::std::os::raw::c_void, lock: *mut lock_object,
                  pri: ::std::os::raw::c_int,
                  wmesg: *const ::std::os::raw::c_char, sbt: sbintime_t,
                  pr: sbintime_t, flags: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn msleep_spin_sbt(chan: *mut ::std::os::raw::c_void, mtx: *mut mtx,
                           wmesg: *const ::std::os::raw::c_char,
                           sbt: sbintime_t, pr: sbintime_t,
                           flags: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pause_sbt(wmesg: *const ::std::os::raw::c_char, sbt: sbintime_t,
                     pr: sbintime_t, flags: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wakeup(chan: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn wakeup_one(chan: *mut ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cdev {
    _unused: [u8; 0],
}
extern "C" {
    pub fn dev2udev(x: *mut cdev) -> dev_t;
}
extern "C" {
    pub fn devtoname(cdev: *mut cdev) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn devfs_iosize_max() -> usize;
}
extern "C" {
    pub fn iosize_max() -> usize;
}
extern "C" {
    pub fn poll_no_poll(events: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn DELAY(usec: ::std::os::raw::c_int);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct root_hold_token {
    _unused: [u8; 0],
}
extern "C" {
    pub fn root_mount_hold(identifier: *const ::std::os::raw::c_char)
     -> *mut root_hold_token;
}
extern "C" {
    pub fn root_mount_rel(h: *mut root_hold_token);
}
extern "C" {
    pub fn root_mounted() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct unrhdr {
    _unused: [u8; 0],
}
extern "C" {
    pub fn new_unrhdr(low: ::std::os::raw::c_int, high: ::std::os::raw::c_int,
                      mutex: *mut mtx) -> *mut unrhdr;
}
extern "C" {
    pub fn init_unrhdr(uh: *mut unrhdr, low: ::std::os::raw::c_int,
                       high: ::std::os::raw::c_int, mutex: *mut mtx);
}
extern "C" {
    pub fn delete_unrhdr(uh: *mut unrhdr);
}
extern "C" {
    pub fn clear_unrhdr(uh: *mut unrhdr);
}
extern "C" {
    pub fn clean_unrhdr(uh: *mut unrhdr);
}
extern "C" {
    pub fn clean_unrhdrl(uh: *mut unrhdr);
}
extern "C" {
    pub fn alloc_unr(uh: *mut unrhdr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alloc_unr_specific(uh: *mut unrhdr, item: u_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alloc_unrl(uh: *mut unrhdr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn free_unr(uh: *mut unrhdr, item: u_int);
}
extern "C" {
    pub fn intr_prof_stack_use(td: *mut thread, frame: *mut trapframe);
}
extern "C" {
    pub fn counted_warning(counter: *mut ::std::os::raw::c_uint,
                           msg: *const ::std::os::raw::c_char);
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct timezone {
    pub tz_minuteswest: ::std::os::raw::c_int,
    pub tz_dsttime: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_timezone() {
    assert_eq!(::std::mem::size_of::<timezone>() , 8usize , concat ! (
               "Size of: " , stringify ! ( timezone ) ));
    assert_eq! (::std::mem::align_of::<timezone>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( timezone ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timezone ) ) . tz_minuteswest as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timezone ) , "::" ,
                stringify ! ( tz_minuteswest ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timezone ) ) . tz_dsttime as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( timezone ) , "::" ,
                stringify ! ( tz_dsttime ) ));
}
impl Clone for timezone {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct bintime {
    pub sec: time_t,
    pub frac: u64,
}
#[test]
fn bindgen_test_layout_bintime() {
    assert_eq!(::std::mem::size_of::<bintime>() , 16usize , concat ! (
               "Size of: " , stringify ! ( bintime ) ));
    assert_eq! (::std::mem::align_of::<bintime>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( bintime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bintime ) ) . sec as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( bintime ) , "::" ,
                stringify ! ( sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bintime ) ) . frac as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( bintime ) , "::" ,
                stringify ! ( frac ) ));
}
impl Clone for bintime {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
#[test]
fn bindgen_test_layout_itimerval() {
    assert_eq!(::std::mem::size_of::<itimerval>() , 32usize , concat ! (
               "Size of: " , stringify ! ( itimerval ) ));
    assert_eq! (::std::mem::align_of::<itimerval>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( itimerval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerval ) ) . it_interval as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerval ) , "::" ,
                stringify ! ( it_interval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerval ) ) . it_value as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerval ) , "::" ,
                stringify ! ( it_value ) ));
}
impl Clone for itimerval {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct clockinfo {
    pub hz: ::std::os::raw::c_int,
    pub tick: ::std::os::raw::c_int,
    pub spare: ::std::os::raw::c_int,
    pub stathz: ::std::os::raw::c_int,
    pub profhz: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_clockinfo() {
    assert_eq!(::std::mem::size_of::<clockinfo>() , 20usize , concat ! (
               "Size of: " , stringify ! ( clockinfo ) ));
    assert_eq! (::std::mem::align_of::<clockinfo>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( clockinfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clockinfo ) ) . hz as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( clockinfo ) , "::" ,
                stringify ! ( hz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clockinfo ) ) . tick as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( clockinfo ) , "::" ,
                stringify ! ( tick ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clockinfo ) ) . spare as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( clockinfo ) , "::" ,
                stringify ! ( spare ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clockinfo ) ) . stathz as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( clockinfo ) , "::" ,
                stringify ! ( stathz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clockinfo ) ) . profhz as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( clockinfo ) , "::" ,
                stringify ! ( profhz ) ));
}
impl Clone for clockinfo {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn inittodr(base: time_t);
}
extern "C" {
    pub fn resettodr();
}
extern "C" {
    #[link_name = "time_second"]
    pub static mut time_second: time_t;
}
extern "C" {
    #[link_name = "time_uptime"]
    pub static mut time_uptime: time_t;
}
extern "C" {
    #[link_name = "tc_tick_bt"]
    pub static mut tc_tick_bt: bintime;
}
extern "C" {
    #[link_name = "tc_tick_sbt"]
    pub static mut tc_tick_sbt: sbintime_t;
}
extern "C" {
    #[link_name = "tick_bt"]
    pub static mut tick_bt: bintime;
}
extern "C" {
    #[link_name = "tick_sbt"]
    pub static mut tick_sbt: sbintime_t;
}
extern "C" {
    #[link_name = "tc_precexp"]
    pub static mut tc_precexp: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "tc_timepercentage"]
    pub static mut tc_timepercentage: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "bt_timethreshold"]
    pub static mut bt_timethreshold: bintime;
}
extern "C" {
    #[link_name = "bt_tickthreshold"]
    pub static mut bt_tickthreshold: bintime;
}
extern "C" {
    #[link_name = "sbt_timethreshold"]
    pub static mut sbt_timethreshold: sbintime_t;
}
extern "C" {
    #[link_name = "sbt_tickthreshold"]
    pub static mut sbt_tickthreshold: sbintime_t;
}
extern "C" {
    #[link_name = "rtc_generation"]
    pub static mut rtc_generation: ::std::os::raw::c_int;
}
extern "C" {
    pub fn binuptime(bt: *mut bintime);
}
extern "C" {
    pub fn nanouptime(tsp: *mut timespec);
}
extern "C" {
    pub fn microuptime(tvp: *mut timeval);
}
extern "C" {
    pub fn bintime(bt: *mut bintime);
}
extern "C" {
    pub fn nanotime(tsp: *mut timespec);
}
extern "C" {
    pub fn microtime(tvp: *mut timeval);
}
extern "C" {
    pub fn getbinuptime(bt: *mut bintime);
}
extern "C" {
    pub fn getnanouptime(tsp: *mut timespec);
}
extern "C" {
    pub fn getmicrouptime(tvp: *mut timeval);
}
extern "C" {
    pub fn getbintime(bt: *mut bintime);
}
extern "C" {
    pub fn getnanotime(tsp: *mut timespec);
}
extern "C" {
    pub fn getmicrotime(tvp: *mut timeval);
}
extern "C" {
    pub fn getboottime(boottime: *mut timeval);
}
extern "C" {
    pub fn getboottimebin(boottimebin: *mut bintime);
}
extern "C" {
    pub fn itimerdecr(itp: *mut itimerval, usec: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn itimerfix(tv: *mut timeval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ppsratecheck(arg1: *mut timeval, arg2: *mut ::std::os::raw::c_int,
                        arg3: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ratecheck(arg1: *mut timeval, arg2: *const timeval)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timevaladd(t1: *mut timeval, t2: *const timeval);
}
extern "C" {
    pub fn timevalsub(t1: *mut timeval, t2: *const timeval);
}
extern "C" {
    pub fn tvtohz(tv: *mut timeval) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct priority {
    pub pri_class: u_char,
    pub pri_level: u_char,
    pub pri_native: u_char,
    pub pri_user: u_char,
}
#[test]
fn bindgen_test_layout_priority() {
    assert_eq!(::std::mem::size_of::<priority>() , 4usize , concat ! (
               "Size of: " , stringify ! ( priority ) ));
    assert_eq! (::std::mem::align_of::<priority>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( priority ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const priority ) ) . pri_class as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( priority ) , "::" ,
                stringify ! ( pri_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const priority ) ) . pri_level as * const _ as
                usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( priority ) , "::" ,
                stringify ! ( pri_level ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const priority ) ) . pri_native as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( priority ) , "::" ,
                stringify ! ( pri_native ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const priority ) ) . pri_user as * const _ as
                usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( priority ) , "::" ,
                stringify ! ( pri_user ) ));
}
impl Clone for priority {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn htonl(arg1: __uint32_t) -> __uint32_t;
}
extern "C" {
    pub fn htons(arg1: __uint16_t) -> __uint16_t;
}
extern "C" {
    pub fn ntohl(arg1: __uint32_t) -> __uint32_t;
}
extern "C" {
    pub fn ntohs(arg1: __uint16_t) -> __uint16_t;
}
#[repr(C)]
#[derive(Copy)]
pub struct mtx_padalign {
    pub lock_object: lock_object,
    pub mtx_lock: usize,
    pub __bindgen_padding_0: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_mtx_padalign() {
    assert_eq!(::std::mem::size_of::<mtx_padalign>() , 64usize , concat ! (
               "Size of: " , stringify ! ( mtx_padalign ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mtx_padalign ) ) . lock_object as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mtx_padalign ) , "::" ,
                stringify ! ( lock_object ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mtx_padalign ) ) . mtx_lock as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( mtx_padalign ) , "::" ,
                stringify ! ( mtx_lock ) ));
}
impl Clone for mtx_padalign {
    fn clone(&self) -> Self { *self }
}
impl Default for mtx_padalign {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl ::std::fmt::Debug for mtx_padalign {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f , "mtx_padalign {{ lock_object: {:?}, mtx_lock: {:?} }}" ,
               self . lock_object , self . mtx_lock)
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct malloc_type_stats {
    pub mts_memalloced: u64,
    pub mts_memfreed: u64,
    pub mts_numallocs: u64,
    pub mts_numfrees: u64,
    pub mts_size: u64,
    pub _mts_reserved1: u64,
    pub _mts_reserved2: u64,
    pub _mts_reserved3: u64,
}
#[test]
fn bindgen_test_layout_malloc_type_stats() {
    assert_eq!(::std::mem::size_of::<malloc_type_stats>() , 64usize , concat !
               ( "Size of: " , stringify ! ( malloc_type_stats ) ));
    assert_eq! (::std::mem::align_of::<malloc_type_stats>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( malloc_type_stats ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type_stats ) ) . mts_memalloced as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_type_stats ) ,
                "::" , stringify ! ( mts_memalloced ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type_stats ) ) . mts_memfreed as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_type_stats ) ,
                "::" , stringify ! ( mts_memfreed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type_stats ) ) . mts_numallocs as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_type_stats ) ,
                "::" , stringify ! ( mts_numallocs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type_stats ) ) . mts_numfrees as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_type_stats ) ,
                "::" , stringify ! ( mts_numfrees ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type_stats ) ) . mts_size as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_type_stats ) ,
                "::" , stringify ! ( mts_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type_stats ) ) . _mts_reserved1 as
                * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_type_stats ) ,
                "::" , stringify ! ( _mts_reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type_stats ) ) . _mts_reserved2 as
                * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_type_stats ) ,
                "::" , stringify ! ( _mts_reserved2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type_stats ) ) . _mts_reserved3 as
                * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_type_stats ) ,
                "::" , stringify ! ( _mts_reserved3 ) ));
}
impl Clone for malloc_type_stats {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct malloc_type_internal {
    pub mti_probes: [u32; 2usize],
    pub mti_zone: u_char,
    pub mti_stats: [malloc_type_stats; 256usize],
}
#[test]
fn bindgen_test_layout_malloc_type_internal() {
    assert_eq!(::std::mem::size_of::<malloc_type_internal>() , 16400usize ,
               concat ! ( "Size of: " , stringify ! ( malloc_type_internal )
               ));
    assert_eq! (::std::mem::align_of::<malloc_type_internal>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( malloc_type_internal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type_internal ) ) . mti_probes as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_type_internal )
                , "::" , stringify ! ( mti_probes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type_internal ) ) . mti_zone as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_type_internal )
                , "::" , stringify ! ( mti_zone ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type_internal ) ) . mti_stats as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_type_internal )
                , "::" , stringify ! ( mti_stats ) ));
}
impl Clone for malloc_type_internal {
    fn clone(&self) -> Self { *self }
}
impl Default for malloc_type_internal {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl ::std::fmt::Debug for malloc_type_internal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f ,
               "malloc_type_internal {{ mti_probes: {:?}, mti_zone: {:?}, mti_stats: [{}] }}"
               , self . mti_probes , self . mti_zone , self . mti_stats . iter
               (  ) . enumerate (  ) . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ))
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct malloc_type_stream_header {
    pub mtsh_version: u32,
    pub mtsh_maxcpus: u32,
    pub mtsh_count: u32,
    pub _mtsh_pad: u32,
}
#[test]
fn bindgen_test_layout_malloc_type_stream_header() {
    assert_eq!(::std::mem::size_of::<malloc_type_stream_header>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( malloc_type_stream_header ) ));
    assert_eq! (::std::mem::align_of::<malloc_type_stream_header>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( malloc_type_stream_header )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type_stream_header ) ) .
                mtsh_version as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                malloc_type_stream_header ) , "::" , stringify ! (
                mtsh_version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type_stream_header ) ) .
                mtsh_maxcpus as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                malloc_type_stream_header ) , "::" , stringify ! (
                mtsh_maxcpus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type_stream_header ) ) .
                mtsh_count as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                malloc_type_stream_header ) , "::" , stringify ! ( mtsh_count
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type_stream_header ) ) . _mtsh_pad
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                malloc_type_stream_header ) , "::" , stringify ! ( _mtsh_pad )
                ));
}
impl Clone for malloc_type_stream_header {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct malloc_type_header {
    pub mth_name: [::std::os::raw::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_malloc_type_header() {
    assert_eq!(::std::mem::size_of::<malloc_type_header>() , 32usize , concat
               ! ( "Size of: " , stringify ! ( malloc_type_header ) ));
    assert_eq! (::std::mem::align_of::<malloc_type_header>() , 1usize , concat
                ! ( "Alignment of " , stringify ! ( malloc_type_header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type_header ) ) . mth_name as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_type_header ) ,
                "::" , stringify ! ( mth_name ) ));
}
impl Clone for malloc_type_header {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "M_CACHE"]
    pub static mut M_CACHE: [malloc_type; 1usize];
}
extern "C" {
    #[link_name = "M_DEVBUF"]
    pub static mut M_DEVBUF: [malloc_type; 1usize];
}
extern "C" {
    #[link_name = "M_TEMP"]
    pub static mut M_TEMP: [malloc_type; 1usize];
}
extern "C" {
    #[link_name = "M_IOV"]
    pub static mut M_IOV: [malloc_type; 1usize];
}
extern "C" {
    #[link_name = "malloc_mtx"]
    pub static mut malloc_mtx: mtx;
}
pub type malloc_type_list_func_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut malloc_type,
                                               arg2:
                                                   *mut ::std::os::raw::c_void)>;
extern "C" {
    pub fn contigfree(addr: *mut ::std::os::raw::c_void,
                      size: ::std::os::raw::c_ulong, type_: *mut malloc_type);
}
extern "C" {
    pub fn contigmalloc(size: ::std::os::raw::c_ulong,
                        type_: *mut malloc_type, flags: ::std::os::raw::c_int,
                        low: vm_paddr_t, high: vm_paddr_t,
                        alignment: ::std::os::raw::c_ulong,
                        boundary: vm_paddr_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn contigmalloc_domain(size: ::std::os::raw::c_ulong,
                               type_: *mut malloc_type,
                               domain: ::std::os::raw::c_int,
                               flags: ::std::os::raw::c_int, low: vm_paddr_t,
                               high: vm_paddr_t,
                               alignment: ::std::os::raw::c_ulong,
                               boundary: vm_paddr_t)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(addr: *mut ::std::os::raw::c_void, type_: *mut malloc_type);
}
extern "C" {
    pub fn free_domain(addr: *mut ::std::os::raw::c_void,
                       type_: *mut malloc_type);
}
extern "C" {
    pub fn malloc(size: ::std::os::raw::c_ulong, type_: *mut malloc_type,
                  flags: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc_domain(size: ::std::os::raw::c_ulong,
                         type_: *mut malloc_type,
                         domain: ::std::os::raw::c_int,
                         flags: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mallocarray(nmemb: usize, size: usize, type_: *mut malloc_type,
                       flags: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc_init(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn malloc_last_fail() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc_type_allocated(type_: *mut malloc_type,
                                 size: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn malloc_type_freed(type_: *mut malloc_type,
                             size: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn malloc_type_list(arg1: malloc_type_list_func_t,
                            arg2: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn malloc_uninit(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn realloc(addr: *mut ::std::os::raw::c_void,
                   size: ::std::os::raw::c_ulong, type_: *mut malloc_type,
                   flags: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn reallocf(addr: *mut ::std::os::raw::c_void,
                    size: ::std::os::raw::c_ulong, type_: *mut malloc_type,
                    flags: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc_desc2type(desc: *const ::std::os::raw::c_char)
     -> *mut malloc_type;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uma_zone {
    _unused: [u8; 0],
}
pub type uma_zone_t = *mut uma_zone;
extern "C" {
    pub fn zone_drain(arg1: uma_zone_t);
}
pub type uma_ctor =
    ::std::option::Option<unsafe extern "C" fn(mem:
                                                   *mut ::std::os::raw::c_void,
                                               size: ::std::os::raw::c_int,
                                               arg:
                                                   *mut ::std::os::raw::c_void,
                                               flags: ::std::os::raw::c_int)
                              -> ::std::os::raw::c_int>;
pub type uma_dtor =
    ::std::option::Option<unsafe extern "C" fn(mem:
                                                   *mut ::std::os::raw::c_void,
                                               size: ::std::os::raw::c_int,
                                               arg:
                                                   *mut ::std::os::raw::c_void)>;
pub type uma_init =
    ::std::option::Option<unsafe extern "C" fn(mem:
                                                   *mut ::std::os::raw::c_void,
                                               size: ::std::os::raw::c_int,
                                               flags: ::std::os::raw::c_int)
                              -> ::std::os::raw::c_int>;
pub type uma_fini =
    ::std::option::Option<unsafe extern "C" fn(mem:
                                                   *mut ::std::os::raw::c_void,
                                               size: ::std::os::raw::c_int)>;
pub type uma_import =
    ::std::option::Option<unsafe extern "C" fn(arg:
                                                   *mut ::std::os::raw::c_void,
                                               store:
                                                   *mut *mut ::std::os::raw::c_void,
                                               count: ::std::os::raw::c_int,
                                               domain: ::std::os::raw::c_int,
                                               flags: ::std::os::raw::c_int)
                              -> ::std::os::raw::c_int>;
pub type uma_release =
    ::std::option::Option<unsafe extern "C" fn(arg:
                                                   *mut ::std::os::raw::c_void,
                                               store:
                                                   *mut *mut ::std::os::raw::c_void,
                                               count: ::std::os::raw::c_int)>;
extern "C" {
    pub fn uma_zcreate(name: *const ::std::os::raw::c_char, size: usize,
                       ctor: uma_ctor, dtor: uma_dtor, uminit: uma_init,
                       fini: uma_fini, align: ::std::os::raw::c_int,
                       flags: u32) -> uma_zone_t;
}
extern "C" {
    pub fn uma_zsecond_create(name: *mut ::std::os::raw::c_char,
                              ctor: uma_ctor, dtor: uma_dtor, zinit: uma_init,
                              zfini: uma_fini, master: uma_zone_t)
     -> uma_zone_t;
}
extern "C" {
    pub fn uma_zsecond_add(zone: uma_zone_t, master: uma_zone_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uma_zcache_create(name: *mut ::std::os::raw::c_char,
                             size: ::std::os::raw::c_int, ctor: uma_ctor,
                             dtor: uma_dtor, zinit: uma_init, zfini: uma_fini,
                             zimport: uma_import, zrelease: uma_release,
                             arg: *mut ::std::os::raw::c_void,
                             flags: ::std::os::raw::c_int) -> uma_zone_t;
}
extern "C" {
    pub fn uma_zdestroy(zone: uma_zone_t);
}
extern "C" {
    pub fn uma_zalloc_arg(zone: uma_zone_t, arg: *mut ::std::os::raw::c_void,
                          flags: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn uma_zalloc_domain(zone: uma_zone_t,
                             arg: *mut ::std::os::raw::c_void,
                             domain: ::std::os::raw::c_int,
                             flags: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn uma_zfree_arg(zone: uma_zone_t, item: *mut ::std::os::raw::c_void,
                         arg: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn uma_zfree_domain(zone: uma_zone_t,
                            item: *mut ::std::os::raw::c_void,
                            arg: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn uma_zwait(zone: uma_zone_t);
}
pub type uma_alloc =
    ::std::option::Option<unsafe extern "C" fn(zone: uma_zone_t,
                                               size: vm_size_t,
                                               domain: ::std::os::raw::c_int,
                                               pflag: *mut u8,
                                               wait: ::std::os::raw::c_int)
                              -> *mut ::std::os::raw::c_void>;
pub type uma_free =
    ::std::option::Option<unsafe extern "C" fn(item:
                                                   *mut ::std::os::raw::c_void,
                                               size: vm_size_t, pflag: u8)>;
extern "C" {
    pub fn uma_startup(bootmem: *mut ::std::os::raw::c_void,
                       boot_pages: ::std::os::raw::c_int);
}
extern "C" {
    pub fn uma_startup2();
}
extern "C" {
    pub fn uma_reclaim();
}
extern "C" {
    pub fn uma_set_align(align: ::std::os::raw::c_int);
}
extern "C" {
    pub fn uma_zone_reserve(zone: uma_zone_t, nitems: ::std::os::raw::c_int);
}
extern "C" {
    pub fn uma_zone_reserve_kva(zone: uma_zone_t,
                                nitems: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uma_zone_set_max(zone: uma_zone_t, nitems: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uma_zone_get_max(zone: uma_zone_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uma_zone_set_warning(zone: uma_zone_t,
                                warning: *const ::std::os::raw::c_char);
}
pub type uma_maxaction_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: uma_zone_t,
                                               arg2: ::std::os::raw::c_int)>;
extern "C" {
    pub fn uma_zone_set_maxaction(zone: uma_zone_t, arg1: uma_maxaction_t);
}
extern "C" {
    pub fn uma_zone_get_cur(zone: uma_zone_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uma_zone_set_init(zone: uma_zone_t, uminit: uma_init);
}
extern "C" {
    pub fn uma_zone_set_fini(zone: uma_zone_t, fini: uma_fini);
}
extern "C" {
    pub fn uma_zone_set_zinit(zone: uma_zone_t, zinit: uma_init);
}
extern "C" {
    pub fn uma_zone_set_zfini(zone: uma_zone_t, zfini: uma_fini);
}
extern "C" {
    pub fn uma_zone_set_allocf(zone: uma_zone_t, allocf: uma_alloc);
}
extern "C" {
    pub fn uma_zone_set_freef(zone: uma_zone_t, freef: uma_free);
}
extern "C" {
    pub fn uma_prealloc(zone: uma_zone_t, itemcnt: ::std::os::raw::c_int);
}
extern "C" {
    pub fn uma_zone_exhausted(zone: uma_zone_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn uma_zone_exhausted_nolock(zone: uma_zone_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "pcpu_zone_64"]
    pub static mut pcpu_zone_64: uma_zone_t;
}
extern "C" {
    #[link_name = "pcpu_zone_ptr"]
    pub static mut pcpu_zone_ptr: uma_zone_t;
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct uma_stream_header {
    pub ush_version: u32,
    pub ush_maxcpus: u32,
    pub ush_count: u32,
    pub _ush_pad: u32,
}
#[test]
fn bindgen_test_layout_uma_stream_header() {
    assert_eq!(::std::mem::size_of::<uma_stream_header>() , 16usize , concat !
               ( "Size of: " , stringify ! ( uma_stream_header ) ));
    assert_eq! (::std::mem::align_of::<uma_stream_header>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( uma_stream_header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_stream_header ) ) . ush_version as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_stream_header ) ,
                "::" , stringify ! ( ush_version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_stream_header ) ) . ush_maxcpus as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_stream_header ) ,
                "::" , stringify ! ( ush_maxcpus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_stream_header ) ) . ush_count as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_stream_header ) ,
                "::" , stringify ! ( ush_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_stream_header ) ) . _ush_pad as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_stream_header ) ,
                "::" , stringify ! ( _ush_pad ) ));
}
impl Clone for uma_stream_header {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct uma_type_header {
    pub uth_name: [::std::os::raw::c_char; 32usize],
    pub uth_align: u32,
    pub uth_size: u32,
    pub uth_rsize: u32,
    pub uth_maxpages: u32,
    pub uth_limit: u32,
    pub uth_pages: u32,
    pub uth_keg_free: u32,
    pub uth_zone_free: u32,
    pub uth_bucketsize: u32,
    pub uth_zone_flags: u32,
    pub uth_allocs: u64,
    pub uth_frees: u64,
    pub uth_fails: u64,
    pub uth_sleeps: u64,
    pub _uth_reserved1: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_uma_type_header() {
    assert_eq!(::std::mem::size_of::<uma_type_header>() , 120usize , concat !
               ( "Size of: " , stringify ! ( uma_type_header ) ));
    assert_eq! (::std::mem::align_of::<uma_type_header>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( uma_type_header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_type_header ) ) . uth_name as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_type_header ) ,
                "::" , stringify ! ( uth_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_type_header ) ) . uth_align as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_type_header ) ,
                "::" , stringify ! ( uth_align ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_type_header ) ) . uth_size as * const
                _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_type_header ) ,
                "::" , stringify ! ( uth_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_type_header ) ) . uth_rsize as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_type_header ) ,
                "::" , stringify ! ( uth_rsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_type_header ) ) . uth_maxpages as *
                const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_type_header ) ,
                "::" , stringify ! ( uth_maxpages ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_type_header ) ) . uth_limit as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_type_header ) ,
                "::" , stringify ! ( uth_limit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_type_header ) ) . uth_pages as *
                const _ as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_type_header ) ,
                "::" , stringify ! ( uth_pages ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_type_header ) ) . uth_keg_free as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_type_header ) ,
                "::" , stringify ! ( uth_keg_free ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_type_header ) ) . uth_zone_free as *
                const _ as usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_type_header ) ,
                "::" , stringify ! ( uth_zone_free ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_type_header ) ) . uth_bucketsize as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_type_header ) ,
                "::" , stringify ! ( uth_bucketsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_type_header ) ) . uth_zone_flags as *
                const _ as usize } , 68usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_type_header ) ,
                "::" , stringify ! ( uth_zone_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_type_header ) ) . uth_allocs as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_type_header ) ,
                "::" , stringify ! ( uth_allocs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_type_header ) ) . uth_frees as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_type_header ) ,
                "::" , stringify ! ( uth_frees ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_type_header ) ) . uth_fails as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_type_header ) ,
                "::" , stringify ! ( uth_fails ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_type_header ) ) . uth_sleeps as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_type_header ) ,
                "::" , stringify ! ( uth_sleeps ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_type_header ) ) . _uth_reserved1 as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_type_header ) ,
                "::" , stringify ! ( _uth_reserved1 ) ));
}
impl Clone for uma_type_header {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct uma_percpu_stat {
    pub ups_allocs: u64,
    pub ups_frees: u64,
    pub ups_cache_free: u64,
    pub _ups_reserved: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_uma_percpu_stat() {
    assert_eq!(::std::mem::size_of::<uma_percpu_stat>() , 64usize , concat ! (
               "Size of: " , stringify ! ( uma_percpu_stat ) ));
    assert_eq! (::std::mem::align_of::<uma_percpu_stat>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( uma_percpu_stat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_percpu_stat ) ) . ups_allocs as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_percpu_stat ) ,
                "::" , stringify ! ( ups_allocs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_percpu_stat ) ) . ups_frees as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_percpu_stat ) ,
                "::" , stringify ! ( ups_frees ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_percpu_stat ) ) . ups_cache_free as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_percpu_stat ) ,
                "::" , stringify ! ( ups_cache_free ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_percpu_stat ) ) . _ups_reserved as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_percpu_stat ) ,
                "::" , stringify ! ( _ups_reserved ) ));
}
impl Clone for uma_percpu_stat {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn uma_reclaim_wakeup();
}
extern "C" {
    pub fn uma_reclaim_worker(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn uma_limit() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn uma_size() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn uma_avail() -> ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "sdt_probes_enabled"]
    pub static mut sdt_probes_enabled: bool_;
}
pub type sdt_probe_func_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: u32, arg0: usize,
                                               arg1: usize, arg2: usize,
                                               arg3: usize, arg4: usize)>;
extern "C" {
    #[link_name = "sdt_probe_func"]
    pub static mut sdt_probe_func: sdt_probe_func_t;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sdt_probe {
    pub version: ::std::os::raw::c_int,
    pub prov: *mut sdt_provider,
    pub probe_entry: sdt_probe__bindgen_ty_1,
    pub argtype_list: sdt_probe__bindgen_ty_2,
    pub mod_: *const ::std::os::raw::c_char,
    pub func: *const ::std::os::raw::c_char,
    pub name: *const ::std::os::raw::c_char,
    pub id: id_t,
    pub n_args: ::std::os::raw::c_int,
    pub sdtp_lf: *mut linker_file,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sdt_probe__bindgen_ty_1 {
    pub tqe_next: *mut sdt_probe,
    pub tqe_prev: *mut *mut sdt_probe,
}
#[test]
fn bindgen_test_layout_sdt_probe__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<sdt_probe__bindgen_ty_1>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( sdt_probe__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<sdt_probe__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( sdt_probe__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe__bindgen_ty_1 ) ) . tqe_next as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe__bindgen_ty_1
                ) , "::" , stringify ! ( tqe_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe__bindgen_ty_1 ) ) . tqe_prev as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe__bindgen_ty_1
                ) , "::" , stringify ! ( tqe_prev ) ));
}
impl Clone for sdt_probe__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for sdt_probe__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sdt_probe__bindgen_ty_2 {
    pub tqh_first: *mut sdt_argtype,
    pub tqh_last: *mut *mut sdt_argtype,
}
#[test]
fn bindgen_test_layout_sdt_probe__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<sdt_probe__bindgen_ty_2>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( sdt_probe__bindgen_ty_2 ) ));
    assert_eq! (::std::mem::align_of::<sdt_probe__bindgen_ty_2>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( sdt_probe__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe__bindgen_ty_2 ) ) . tqh_first
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe__bindgen_ty_2
                ) , "::" , stringify ! ( tqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe__bindgen_ty_2 ) ) . tqh_last as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe__bindgen_ty_2
                ) , "::" , stringify ! ( tqh_last ) ));
}
impl Clone for sdt_probe__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for sdt_probe__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_sdt_probe() {
    assert_eq!(::std::mem::size_of::<sdt_probe>() , 96usize , concat ! (
               "Size of: " , stringify ! ( sdt_probe ) ));
    assert_eq! (::std::mem::align_of::<sdt_probe>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sdt_probe ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . version as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . prov as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( prov ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . probe_entry as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( probe_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . argtype_list as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( argtype_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . mod_ as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( mod_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . func as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . name as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . id as * const _ as usize
                } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . n_args as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( n_args ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . sdtp_lf as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( sdtp_lf ) ));
}
impl Clone for sdt_probe {
    fn clone(&self) -> Self { *self }
}
impl Default for sdt_probe {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sdt_provider {
    pub name: *mut ::std::os::raw::c_char,
    pub prov_entry: sdt_provider__bindgen_ty_1,
    pub id: usize,
    pub sdt_refs: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sdt_provider__bindgen_ty_1 {
    pub tqe_next: *mut sdt_provider,
    pub tqe_prev: *mut *mut sdt_provider,
}
#[test]
fn bindgen_test_layout_sdt_provider__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<sdt_provider__bindgen_ty_1>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( sdt_provider__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<sdt_provider__bindgen_ty_1>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( sdt_provider__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_provider__bindgen_ty_1 ) ) . tqe_next
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                sdt_provider__bindgen_ty_1 ) , "::" , stringify ! ( tqe_next )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_provider__bindgen_ty_1 ) ) . tqe_prev
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                sdt_provider__bindgen_ty_1 ) , "::" , stringify ! ( tqe_prev )
                ));
}
impl Clone for sdt_provider__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for sdt_provider__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_sdt_provider() {
    assert_eq!(::std::mem::size_of::<sdt_provider>() , 40usize , concat ! (
               "Size of: " , stringify ! ( sdt_provider ) ));
    assert_eq! (::std::mem::align_of::<sdt_provider>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sdt_provider ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_provider ) ) . name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_provider ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_provider ) ) . prov_entry as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_provider ) , "::" ,
                stringify ! ( prov_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_provider ) ) . id as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_provider ) , "::" ,
                stringify ! ( id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_provider ) ) . sdt_refs as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_provider ) , "::" ,
                stringify ! ( sdt_refs ) ));
}
impl Clone for sdt_provider {
    fn clone(&self) -> Self { *self }
}
impl Default for sdt_provider {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct linker_file {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sdt_argtype {
    pub ndx: ::std::os::raw::c_int,
    pub type_: *const ::std::os::raw::c_char,
    pub xtype: *const ::std::os::raw::c_char,
    pub argtype_entry: sdt_argtype__bindgen_ty_1,
    pub probe: *mut sdt_probe,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sdt_argtype__bindgen_ty_1 {
    pub tqe_next: *mut sdt_argtype,
    pub tqe_prev: *mut *mut sdt_argtype,
}
#[test]
fn bindgen_test_layout_sdt_argtype__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<sdt_argtype__bindgen_ty_1>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( sdt_argtype__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<sdt_argtype__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( sdt_argtype__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_argtype__bindgen_ty_1 ) ) . tqe_next
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                sdt_argtype__bindgen_ty_1 ) , "::" , stringify ! ( tqe_next )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_argtype__bindgen_ty_1 ) ) . tqe_prev
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                sdt_argtype__bindgen_ty_1 ) , "::" , stringify ! ( tqe_prev )
                ));
}
impl Clone for sdt_argtype__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for sdt_argtype__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_sdt_argtype() {
    assert_eq!(::std::mem::size_of::<sdt_argtype>() , 48usize , concat ! (
               "Size of: " , stringify ! ( sdt_argtype ) ));
    assert_eq! (::std::mem::align_of::<sdt_argtype>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sdt_argtype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_argtype ) ) . ndx as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_argtype ) , "::" ,
                stringify ! ( ndx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_argtype ) ) . type_ as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_argtype ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_argtype ) ) . xtype as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_argtype ) , "::" ,
                stringify ! ( xtype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_argtype ) ) . argtype_entry as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_argtype ) , "::" ,
                stringify ! ( argtype_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_argtype ) ) . probe as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_argtype ) , "::" ,
                stringify ! ( probe ) ));
}
impl Clone for sdt_argtype {
    fn clone(&self) -> Self { *self }
}
impl Default for sdt_argtype {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
extern "C" {
    pub fn sdt_probe_stub(arg1: u32, arg2: usize, arg3: usize, arg4: usize,
                          arg5: usize, arg6: usize);
}
#[repr(C)]
pub struct mbuf {
    pub __bindgen_anon_1: mbuf__bindgen_ty_1,
    pub __bindgen_anon_2: mbuf__bindgen_ty_2,
    pub m_data: caddr_t,
    pub m_len: i32,
    pub _bitfield_1: u32,
    pub __bindgen_anon_3: mbuf__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy)]
pub union mbuf__bindgen_ty_1 {
    pub m_next: *mut mbuf,
    pub m_slist: mbuf__bindgen_ty_1__bindgen_ty_1,
    pub m_stailq: mbuf__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mbuf__bindgen_ty_1__bindgen_ty_1 {
    pub sle_next: *mut mbuf,
}
#[test]
fn bindgen_test_layout_mbuf__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<mbuf__bindgen_ty_1__bindgen_ty_1>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( mbuf__bindgen_ty_1__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<mbuf__bindgen_ty_1__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                mbuf__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbuf__bindgen_ty_1__bindgen_ty_1 ) ) .
                sle_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                mbuf__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! (
                sle_next ) ));
}
impl Clone for mbuf__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for mbuf__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mbuf__bindgen_ty_1__bindgen_ty_2 {
    pub stqe_next: *mut mbuf,
}
#[test]
fn bindgen_test_layout_mbuf__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<mbuf__bindgen_ty_1__bindgen_ty_2>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( mbuf__bindgen_ty_1__bindgen_ty_2 )
               ));
    assert_eq! (::std::mem::align_of::<mbuf__bindgen_ty_1__bindgen_ty_2>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                mbuf__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbuf__bindgen_ty_1__bindgen_ty_2 ) ) .
                stqe_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                mbuf__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify ! (
                stqe_next ) ));
}
impl Clone for mbuf__bindgen_ty_1__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for mbuf__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_mbuf__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<mbuf__bindgen_ty_1>() , 8usize , concat !
               ( "Size of: " , stringify ! ( mbuf__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<mbuf__bindgen_ty_1>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( mbuf__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbuf__bindgen_ty_1 ) ) . m_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mbuf__bindgen_ty_1 ) ,
                "::" , stringify ! ( m_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbuf__bindgen_ty_1 ) ) . m_slist as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mbuf__bindgen_ty_1 ) ,
                "::" , stringify ! ( m_slist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbuf__bindgen_ty_1 ) ) . m_stailq as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mbuf__bindgen_ty_1 ) ,
                "::" , stringify ! ( m_stailq ) ));
}
impl Clone for mbuf__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for mbuf__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl ::std::fmt::Debug for mbuf__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f , "mbuf__bindgen_ty_1 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy)]
pub union mbuf__bindgen_ty_2 {
    pub m_nextpkt: *mut mbuf,
    pub m_slistpkt: mbuf__bindgen_ty_2__bindgen_ty_1,
    pub m_stailqpkt: mbuf__bindgen_ty_2__bindgen_ty_2,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mbuf__bindgen_ty_2__bindgen_ty_1 {
    pub sle_next: *mut mbuf,
}
#[test]
fn bindgen_test_layout_mbuf__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<mbuf__bindgen_ty_2__bindgen_ty_1>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( mbuf__bindgen_ty_2__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<mbuf__bindgen_ty_2__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                mbuf__bindgen_ty_2__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbuf__bindgen_ty_2__bindgen_ty_1 ) ) .
                sle_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                mbuf__bindgen_ty_2__bindgen_ty_1 ) , "::" , stringify ! (
                sle_next ) ));
}
impl Clone for mbuf__bindgen_ty_2__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for mbuf__bindgen_ty_2__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mbuf__bindgen_ty_2__bindgen_ty_2 {
    pub stqe_next: *mut mbuf,
}
#[test]
fn bindgen_test_layout_mbuf__bindgen_ty_2__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<mbuf__bindgen_ty_2__bindgen_ty_2>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( mbuf__bindgen_ty_2__bindgen_ty_2 )
               ));
    assert_eq! (::std::mem::align_of::<mbuf__bindgen_ty_2__bindgen_ty_2>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                mbuf__bindgen_ty_2__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbuf__bindgen_ty_2__bindgen_ty_2 ) ) .
                stqe_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                mbuf__bindgen_ty_2__bindgen_ty_2 ) , "::" , stringify ! (
                stqe_next ) ));
}
impl Clone for mbuf__bindgen_ty_2__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for mbuf__bindgen_ty_2__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_mbuf__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<mbuf__bindgen_ty_2>() , 8usize , concat !
               ( "Size of: " , stringify ! ( mbuf__bindgen_ty_2 ) ));
    assert_eq! (::std::mem::align_of::<mbuf__bindgen_ty_2>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( mbuf__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbuf__bindgen_ty_2 ) ) . m_nextpkt as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mbuf__bindgen_ty_2 ) ,
                "::" , stringify ! ( m_nextpkt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbuf__bindgen_ty_2 ) ) . m_slistpkt as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mbuf__bindgen_ty_2 ) ,
                "::" , stringify ! ( m_slistpkt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbuf__bindgen_ty_2 ) ) . m_stailqpkt as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mbuf__bindgen_ty_2 ) ,
                "::" , stringify ! ( m_stailqpkt ) ));
}
impl Clone for mbuf__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for mbuf__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl ::std::fmt::Debug for mbuf__bindgen_ty_2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f , "mbuf__bindgen_ty_2 {{ union }}")
    }
}
#[repr(C)]
pub struct mbuf__bindgen_ty_3 {
    pub __bindgen_anon_1: __BindgenUnionField<mbuf__bindgen_ty_3__bindgen_ty_1>,
    pub m_dat: __BindgenUnionField<[::std::os::raw::c_char; 0usize]>,
    pub bindgen_union_field: [u64; 13usize],
}
#[repr(C)]
pub struct mbuf__bindgen_ty_3__bindgen_ty_1 {
    pub m_pkthdr: pkthdr,
    pub __bindgen_anon_1: mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
pub struct mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {
    pub m_ext: __BindgenUnionField<m_ext>,
    pub m_pktdat: __BindgenUnionField<[::std::os::raw::c_char; 0usize]>,
    pub bindgen_union_field: [u64; 6usize],
}
#[test]
fn bindgen_test_layout_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1>()
               , 48usize , concat ! (
               "Size of: " , stringify ! (
               mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 )
                ) . m_ext as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( m_ext ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 )
                ) . m_pktdat as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( m_pktdat ) ));
}
impl Default for mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl ::std::fmt::Debug for mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f ,
               "mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_mbuf__bindgen_ty_3__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<mbuf__bindgen_ty_3__bindgen_ty_1>() ,
               104usize , concat ! (
               "Size of: " , stringify ! ( mbuf__bindgen_ty_3__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<mbuf__bindgen_ty_3__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                mbuf__bindgen_ty_3__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbuf__bindgen_ty_3__bindgen_ty_1 ) ) .
                m_pkthdr as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                mbuf__bindgen_ty_3__bindgen_ty_1 ) , "::" , stringify ! (
                m_pkthdr ) ));
}
impl Default for mbuf__bindgen_ty_3__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl ::std::fmt::Debug for mbuf__bindgen_ty_3__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f , "mbuf__bindgen_ty_3__bindgen_ty_1 {{ m_pkthdr: {:?} }}" ,
               self . m_pkthdr)
    }
}
#[test]
fn bindgen_test_layout_mbuf__bindgen_ty_3() {
    assert_eq!(::std::mem::size_of::<mbuf__bindgen_ty_3>() , 104usize , concat
               ! ( "Size of: " , stringify ! ( mbuf__bindgen_ty_3 ) ));
    assert_eq! (::std::mem::align_of::<mbuf__bindgen_ty_3>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( mbuf__bindgen_ty_3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbuf__bindgen_ty_3 ) ) . m_dat as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mbuf__bindgen_ty_3 ) ,
                "::" , stringify ! ( m_dat ) ));
}
impl Default for mbuf__bindgen_ty_3 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl ::std::fmt::Debug for mbuf__bindgen_ty_3 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f , "mbuf__bindgen_ty_3 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_mbuf() {
    assert_eq!(::std::mem::size_of::<mbuf>() , 136usize , concat ! (
               "Size of: " , stringify ! ( mbuf ) ));
    assert_eq! (::std::mem::align_of::<mbuf>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( mbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbuf ) ) . m_data as * const _ as usize }
                , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mbuf ) , "::" ,
                stringify ! ( m_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbuf ) ) . m_len as * const _ as usize }
                , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( mbuf ) , "::" ,
                stringify ! ( m_len ) ));
}
impl Default for mbuf {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl ::std::fmt::Debug for mbuf {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f ,
               "mbuf {{ m_data: {:?}, m_len: {:?}, m_type : {:?}, m_flags : {:?} }}"
               , self . m_data , self . m_len , self . m_type (  ) , self .
               m_flags (  ))
    }
}
impl mbuf {
    #[inline]
    pub fn m_type(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 255u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_m_type(&mut self, val: u32) {
        let mask = 255u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn m_flags(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4294967040u64 as u32;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_m_flags(&mut self, val: u32) {
        let mask = 4294967040u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(m_type: u32, m_flags: u32) -> u32 {
        ({ ({ 0 } | ((m_type as u32 as u32) << 0usize) & (255u64 as u32)) } |
             ((m_flags as u32 as u32) << 8usize) & (4294967040u64 as u32))
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct mb_args {
    pub flags: ::std::os::raw::c_int,
    pub type_: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout_mb_args() {
    assert_eq!(::std::mem::size_of::<mb_args>() , 8usize , concat ! (
               "Size of: " , stringify ! ( mb_args ) ));
    assert_eq! (::std::mem::align_of::<mb_args>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( mb_args ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mb_args ) ) . flags as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mb_args ) , "::" ,
                stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mb_args ) ) . type_ as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( mb_args ) , "::" ,
                stringify ! ( type_ ) ));
}
impl Clone for mb_args {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct m_tag {
    pub m_tag_link: m_tag__bindgen_ty_1,
    pub m_tag_id: u_int16_t,
    pub m_tag_len: u_int16_t,
    pub m_tag_cookie: u_int32_t,
    pub m_tag_free: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                   *mut m_tag)>,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct m_tag__bindgen_ty_1 {
    pub sle_next: *mut m_tag,
}
#[test]
fn bindgen_test_layout_m_tag__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<m_tag__bindgen_ty_1>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( m_tag__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<m_tag__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( m_tag__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const m_tag__bindgen_ty_1 ) ) . sle_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( m_tag__bindgen_ty_1 ) ,
                "::" , stringify ! ( sle_next ) ));
}
impl Clone for m_tag__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for m_tag__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_m_tag() {
    assert_eq!(::std::mem::size_of::<m_tag>() , 24usize , concat ! (
               "Size of: " , stringify ! ( m_tag ) ));
    assert_eq! (::std::mem::align_of::<m_tag>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( m_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const m_tag ) ) . m_tag_link as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( m_tag ) , "::" ,
                stringify ! ( m_tag_link ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const m_tag ) ) . m_tag_id as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( m_tag ) , "::" ,
                stringify ! ( m_tag_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const m_tag ) ) . m_tag_len as * const _ as
                usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( m_tag ) , "::" ,
                stringify ! ( m_tag_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const m_tag ) ) . m_tag_cookie as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( m_tag ) , "::" ,
                stringify ! ( m_tag_cookie ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const m_tag ) ) . m_tag_free as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( m_tag ) , "::" ,
                stringify ! ( m_tag_free ) ));
}
impl Clone for m_tag {
    fn clone(&self) -> Self { *self }
}
impl Default for m_tag {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct m_snd_tag {
    pub ifp: *mut ifnet,
}
#[test]
fn bindgen_test_layout_m_snd_tag() {
    assert_eq!(::std::mem::size_of::<m_snd_tag>() , 8usize , concat ! (
               "Size of: " , stringify ! ( m_snd_tag ) ));
    assert_eq! (::std::mem::align_of::<m_snd_tag>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( m_snd_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const m_snd_tag ) ) . ifp as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( m_snd_tag ) , "::" ,
                stringify ! ( ifp ) ));
}
impl Clone for m_snd_tag {
    fn clone(&self) -> Self { *self }
}
impl Default for m_snd_tag {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct pkthdr {
    pub __bindgen_anon_1: pkthdr__bindgen_ty_1,
    pub tags: pkthdr_packet_tags,
    pub len: i32,
    pub flowid: u32,
    pub csum_flags: u32,
    pub fibnum: u16,
    pub cosqos: u8,
    pub rsstype: u8,
    pub __bindgen_anon_2: pkthdr__bindgen_ty_2,
    pub PH_per: pkthdr__bindgen_ty_3,
    pub PH_loc: pkthdr__bindgen_ty_4,
}
#[repr(C)]
#[derive(Copy)]
pub union pkthdr__bindgen_ty_1 {
    pub snd_tag: *mut m_snd_tag,
    pub rcvif: *mut ifnet,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_pkthdr__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<pkthdr__bindgen_ty_1>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( pkthdr__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<pkthdr__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( pkthdr__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_1 ) ) . snd_tag as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr__bindgen_ty_1 )
                , "::" , stringify ! ( snd_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_1 ) ) . rcvif as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr__bindgen_ty_1 )
                , "::" , stringify ! ( rcvif ) ));
}
impl Clone for pkthdr__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for pkthdr__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl ::std::fmt::Debug for pkthdr__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f , "pkthdr__bindgen_ty_1 {{ union }}")
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pkthdr_packet_tags {
    pub slh_first: *mut m_tag,
}
#[test]
fn bindgen_test_layout_pkthdr_packet_tags() {
    assert_eq!(::std::mem::size_of::<pkthdr_packet_tags>() , 8usize , concat !
               ( "Size of: " , stringify ! ( pkthdr_packet_tags ) ));
    assert_eq! (::std::mem::align_of::<pkthdr_packet_tags>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( pkthdr_packet_tags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr_packet_tags ) ) . slh_first as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr_packet_tags ) ,
                "::" , stringify ! ( slh_first ) ));
}
impl Clone for pkthdr_packet_tags {
    fn clone(&self) -> Self { *self }
}
impl Default for pkthdr_packet_tags {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub union pkthdr__bindgen_ty_2 {
    pub rcv_tstmp: u64,
    pub __bindgen_anon_1: pkthdr__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct pkthdr__bindgen_ty_2__bindgen_ty_1 {
    pub l2hlen: u8,
    pub l3hlen: u8,
    pub l4hlen: u8,
    pub l5hlen: u8,
    pub spare: u32,
}
#[test]
fn bindgen_test_layout_pkthdr__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<pkthdr__bindgen_ty_2__bindgen_ty_1>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( pkthdr__bindgen_ty_2__bindgen_ty_1
               ) ));
    assert_eq! (::std::mem::align_of::<pkthdr__bindgen_ty_2__bindgen_ty_1>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                pkthdr__bindgen_ty_2__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_2__bindgen_ty_1 ) ) .
                l2hlen as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pkthdr__bindgen_ty_2__bindgen_ty_1 ) , "::" , stringify ! (
                l2hlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_2__bindgen_ty_1 ) ) .
                l3hlen as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                pkthdr__bindgen_ty_2__bindgen_ty_1 ) , "::" , stringify ! (
                l3hlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_2__bindgen_ty_1 ) ) .
                l4hlen as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                pkthdr__bindgen_ty_2__bindgen_ty_1 ) , "::" , stringify ! (
                l4hlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_2__bindgen_ty_1 ) ) .
                l5hlen as * const _ as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! (
                pkthdr__bindgen_ty_2__bindgen_ty_1 ) , "::" , stringify ! (
                l5hlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_2__bindgen_ty_1 ) ) .
                spare as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                pkthdr__bindgen_ty_2__bindgen_ty_1 ) , "::" , stringify ! (
                spare ) ));
}
impl Clone for pkthdr__bindgen_ty_2__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_pkthdr__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<pkthdr__bindgen_ty_2>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( pkthdr__bindgen_ty_2 ) ));
    assert_eq! (::std::mem::align_of::<pkthdr__bindgen_ty_2>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( pkthdr__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_2 ) ) . rcv_tstmp as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr__bindgen_ty_2 )
                , "::" , stringify ! ( rcv_tstmp ) ));
}
impl Clone for pkthdr__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for pkthdr__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl ::std::fmt::Debug for pkthdr__bindgen_ty_2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f , "pkthdr__bindgen_ty_2 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy)]
pub union pkthdr__bindgen_ty_3 {
    pub eight: [u8; 8usize],
    pub sixteen: [u16; 4usize],
    pub thirtytwo: [u32; 2usize],
    pub sixtyfour: [u64; 1usize],
    pub unintptr: [usize; 1usize],
    pub ptr: *mut ::std::os::raw::c_void,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_pkthdr__bindgen_ty_3() {
    assert_eq!(::std::mem::size_of::<pkthdr__bindgen_ty_3>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( pkthdr__bindgen_ty_3 ) ));
    assert_eq! (::std::mem::align_of::<pkthdr__bindgen_ty_3>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( pkthdr__bindgen_ty_3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_3 ) ) . eight as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr__bindgen_ty_3 )
                , "::" , stringify ! ( eight ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_3 ) ) . sixteen as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr__bindgen_ty_3 )
                , "::" , stringify ! ( sixteen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_3 ) ) . thirtytwo as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr__bindgen_ty_3 )
                , "::" , stringify ! ( thirtytwo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_3 ) ) . sixtyfour as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr__bindgen_ty_3 )
                , "::" , stringify ! ( sixtyfour ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_3 ) ) . unintptr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr__bindgen_ty_3 )
                , "::" , stringify ! ( unintptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_3 ) ) . ptr as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr__bindgen_ty_3 )
                , "::" , stringify ! ( ptr ) ));
}
impl Clone for pkthdr__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
impl Default for pkthdr__bindgen_ty_3 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl ::std::fmt::Debug for pkthdr__bindgen_ty_3 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f , "pkthdr__bindgen_ty_3 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy)]
pub union pkthdr__bindgen_ty_4 {
    pub eight: [u8; 8usize],
    pub sixteen: [u16; 4usize],
    pub thirtytwo: [u32; 2usize],
    pub sixtyfour: [u64; 1usize],
    pub unintptr: [usize; 1usize],
    pub ptr: *mut ::std::os::raw::c_void,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_pkthdr__bindgen_ty_4() {
    assert_eq!(::std::mem::size_of::<pkthdr__bindgen_ty_4>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( pkthdr__bindgen_ty_4 ) ));
    assert_eq! (::std::mem::align_of::<pkthdr__bindgen_ty_4>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( pkthdr__bindgen_ty_4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_4 ) ) . eight as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr__bindgen_ty_4 )
                , "::" , stringify ! ( eight ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_4 ) ) . sixteen as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr__bindgen_ty_4 )
                , "::" , stringify ! ( sixteen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_4 ) ) . thirtytwo as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr__bindgen_ty_4 )
                , "::" , stringify ! ( thirtytwo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_4 ) ) . sixtyfour as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr__bindgen_ty_4 )
                , "::" , stringify ! ( sixtyfour ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_4 ) ) . unintptr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr__bindgen_ty_4 )
                , "::" , stringify ! ( unintptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_4 ) ) . ptr as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr__bindgen_ty_4 )
                , "::" , stringify ! ( ptr ) ));
}
impl Clone for pkthdr__bindgen_ty_4 {
    fn clone(&self) -> Self { *self }
}
impl Default for pkthdr__bindgen_ty_4 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl ::std::fmt::Debug for pkthdr__bindgen_ty_4 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f , "pkthdr__bindgen_ty_4 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_pkthdr() {
    assert_eq!(::std::mem::size_of::<pkthdr>() , 56usize , concat ! (
               "Size of: " , stringify ! ( pkthdr ) ));
    assert_eq! (::std::mem::align_of::<pkthdr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pkthdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr ) ) . tags as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr ) , "::" ,
                stringify ! ( tags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr ) ) . len as * const _ as usize }
                , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr ) , "::" ,
                stringify ! ( len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr ) ) . flowid as * const _ as usize
                } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr ) , "::" ,
                stringify ! ( flowid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr ) ) . csum_flags as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr ) , "::" ,
                stringify ! ( csum_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr ) ) . fibnum as * const _ as usize
                } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr ) , "::" ,
                stringify ! ( fibnum ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr ) ) . cosqos as * const _ as usize
                } , 30usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr ) , "::" ,
                stringify ! ( cosqos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr ) ) . rsstype as * const _ as
                usize } , 31usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr ) , "::" ,
                stringify ! ( rsstype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr ) ) . PH_per as * const _ as usize
                } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr ) , "::" ,
                stringify ! ( PH_per ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr ) ) . PH_loc as * const _ as usize
                } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr ) , "::" ,
                stringify ! ( PH_loc ) ));
}
impl Clone for pkthdr {
    fn clone(&self) -> Self { *self }
}
impl Default for pkthdr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl ::std::fmt::Debug for pkthdr {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f ,
               "pkthdr {{ tags: {:?}, len: {:?}, flowid: {:?}, csum_flags: {:?}, fibnum: {:?}, cosqos: {:?}, rsstype: {:?}, PH_per: {:?}, PH_loc: {:?} }}"
               , self . tags , self . len , self . flowid , self . csum_flags
               , self . fibnum , self . cosqos , self . rsstype , self .
               PH_per , self . PH_loc)
    }
}
pub type m_ext_free_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut mbuf)>;
#[repr(C)]
#[derive(Copy)]
pub struct m_ext {
    pub __bindgen_anon_1: m_ext__bindgen_ty_1,
    pub ext_buf: *mut ::std::os::raw::c_char,
    pub ext_size: u32,
    pub _bitfield_1: u32,
    pub ext_free: m_ext_free_t,
    pub ext_arg1: *mut ::std::os::raw::c_void,
    pub ext_arg2: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy)]
pub union m_ext__bindgen_ty_1 {
    pub ext_count: u_int,
    pub ext_cnt: *mut u_int,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_m_ext__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<m_ext__bindgen_ty_1>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( m_ext__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<m_ext__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( m_ext__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const m_ext__bindgen_ty_1 ) ) . ext_count as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( m_ext__bindgen_ty_1 ) ,
                "::" , stringify ! ( ext_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const m_ext__bindgen_ty_1 ) ) . ext_cnt as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( m_ext__bindgen_ty_1 ) ,
                "::" , stringify ! ( ext_cnt ) ));
}
impl Clone for m_ext__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for m_ext__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl ::std::fmt::Debug for m_ext__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f , "m_ext__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_m_ext() {
    assert_eq!(::std::mem::size_of::<m_ext>() , 48usize , concat ! (
               "Size of: " , stringify ! ( m_ext ) ));
    assert_eq! (::std::mem::align_of::<m_ext>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( m_ext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const m_ext ) ) . ext_buf as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( m_ext ) , "::" ,
                stringify ! ( ext_buf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const m_ext ) ) . ext_size as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( m_ext ) , "::" ,
                stringify ! ( ext_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const m_ext ) ) . ext_free as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( m_ext ) , "::" ,
                stringify ! ( ext_free ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const m_ext ) ) . ext_arg1 as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( m_ext ) , "::" ,
                stringify ! ( ext_arg1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const m_ext ) ) . ext_arg2 as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( m_ext ) , "::" ,
                stringify ! ( ext_arg2 ) ));
}
impl Clone for m_ext {
    fn clone(&self) -> Self { *self }
}
impl Default for m_ext {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl ::std::fmt::Debug for m_ext {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f ,
               "m_ext {{ ext_buf: {:?}, ext_size: {:?}, ext_type : {:?}, ext_flags : {:?}, ext_free: {:?}, ext_arg1: {:?}, ext_arg2: {:?} }}"
               , self . ext_buf , self . ext_size , self . ext_type (  ) ,
               self . ext_flags (  ) , self . ext_free , self . ext_arg1 ,
               self . ext_arg2)
    }
}
impl m_ext {
    #[inline]
    pub fn ext_type(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 255u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_ext_type(&mut self, val: u32) {
        let mask = 255u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn ext_flags(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        let mask = 4294967040u64 as u32;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_ext_flags(&mut self, val: u32) {
        let mask = 4294967040u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u32 as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(ext_type: u32, ext_flags: u32) -> u32 {
        ({ ({ 0 } | ((ext_type as u32 as u32) << 0usize) & (255u64 as u32)) }
             | ((ext_flags as u32 as u32) << 8usize) & (4294967040u64 as u32))
    }
}
extern "C" {
    #[link_name = "zone_mbuf"]
    pub static mut zone_mbuf: uma_zone_t;
}
extern "C" {
    #[link_name = "zone_clust"]
    pub static mut zone_clust: uma_zone_t;
}
extern "C" {
    #[link_name = "zone_pack"]
    pub static mut zone_pack: uma_zone_t;
}
extern "C" {
    #[link_name = "zone_jumbop"]
    pub static mut zone_jumbop: uma_zone_t;
}
extern "C" {
    #[link_name = "zone_jumbo9"]
    pub static mut zone_jumbo9: uma_zone_t;
}
extern "C" {
    #[link_name = "zone_jumbo16"]
    pub static mut zone_jumbo16: uma_zone_t;
}
extern "C" {
    pub fn mb_dupcl(arg1: *mut mbuf, arg2: *mut mbuf);
}
extern "C" {
    pub fn mb_free_ext(arg1: *mut mbuf);
}
extern "C" {
    pub fn m_adj(arg1: *mut mbuf, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn m_apply(arg1: *mut mbuf, arg2: ::std::os::raw::c_int,
                   arg3: ::std::os::raw::c_int,
                   arg4:
                       ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ::std::os::raw::c_void,
                                                                  arg2:
                                                                      *mut ::std::os::raw::c_void,
                                                                  arg3: u_int)
                                                 -> ::std::os::raw::c_int>,
                   arg5: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn m_append(arg1: *mut mbuf, arg2: ::std::os::raw::c_int,
                    arg3: c_caddr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn m_cat(arg1: *mut mbuf, arg2: *mut mbuf);
}
extern "C" {
    pub fn m_catpkt(arg1: *mut mbuf, arg2: *mut mbuf);
}
extern "C" {
    pub fn m_clget(m: *mut mbuf, how: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn m_cljget(m: *mut mbuf, how: ::std::os::raw::c_int,
                    size: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn m_collapse(arg1: *mut mbuf, arg2: ::std::os::raw::c_int,
                      arg3: ::std::os::raw::c_int) -> *mut mbuf;
}
extern "C" {
    pub fn m_copyback(arg1: *mut mbuf, arg2: ::std::os::raw::c_int,
                      arg3: ::std::os::raw::c_int, arg4: c_caddr_t);
}
extern "C" {
    pub fn m_copydata(arg1: *const mbuf, arg2: ::std::os::raw::c_int,
                      arg3: ::std::os::raw::c_int, arg4: caddr_t);
}
extern "C" {
    pub fn m_copym(arg1: *mut mbuf, arg2: ::std::os::raw::c_int,
                   arg3: ::std::os::raw::c_int, arg4: ::std::os::raw::c_int)
     -> *mut mbuf;
}
extern "C" {
    pub fn m_copypacket(arg1: *mut mbuf, arg2: ::std::os::raw::c_int)
     -> *mut mbuf;
}
extern "C" {
    pub fn m_copy_pkthdr(arg1: *mut mbuf, arg2: *mut mbuf);
}
extern "C" {
    pub fn m_copyup(arg1: *mut mbuf, arg2: ::std::os::raw::c_int,
                    arg3: ::std::os::raw::c_int) -> *mut mbuf;
}
extern "C" {
    pub fn m_defrag(arg1: *mut mbuf, arg2: ::std::os::raw::c_int)
     -> *mut mbuf;
}
extern "C" {
    pub fn m_demote_pkthdr(arg1: *mut mbuf);
}
extern "C" {
    pub fn m_demote(arg1: *mut mbuf, arg2: ::std::os::raw::c_int,
                    arg3: ::std::os::raw::c_int);
}
extern "C" {
    pub fn m_devget(arg1: *mut ::std::os::raw::c_char,
                    arg2: ::std::os::raw::c_int, arg3: ::std::os::raw::c_int,
                    arg4: *mut ifnet,
                    arg5:
                        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                       *mut ::std::os::raw::c_char,
                                                                   arg2:
                                                                       caddr_t,
                                                                   arg3:
                                                                       u_int)>)
     -> *mut mbuf;
}
extern "C" {
    pub fn m_dup(arg1: *const mbuf, arg2: ::std::os::raw::c_int) -> *mut mbuf;
}
extern "C" {
    pub fn m_dup_pkthdr(arg1: *mut mbuf, arg2: *const mbuf,
                        arg3: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn m_extadd(arg1: *mut mbuf, arg2: *mut ::std::os::raw::c_char,
                    arg3: u_int, arg4: m_ext_free_t,
                    arg5: *mut ::std::os::raw::c_void,
                    arg6: *mut ::std::os::raw::c_void,
                    arg7: ::std::os::raw::c_int, arg8: ::std::os::raw::c_int);
}
extern "C" {
    pub fn m_fixhdr(arg1: *mut mbuf) -> u_int;
}
extern "C" {
    pub fn m_fragment(arg1: *mut mbuf, arg2: ::std::os::raw::c_int,
                      arg3: ::std::os::raw::c_int) -> *mut mbuf;
}
extern "C" {
    pub fn m_freem(arg1: *mut mbuf);
}
extern "C" {
    pub fn m_get2(arg1: ::std::os::raw::c_int, arg2: ::std::os::raw::c_int,
                  arg3: ::std::os::raw::c_short, arg4: ::std::os::raw::c_int)
     -> *mut mbuf;
}
extern "C" {
    pub fn m_getjcl(arg1: ::std::os::raw::c_int,
                    arg2: ::std::os::raw::c_short,
                    arg3: ::std::os::raw::c_int, arg4: ::std::os::raw::c_int)
     -> *mut mbuf;
}
extern "C" {
    pub fn m_getm2(arg1: *mut mbuf, arg2: ::std::os::raw::c_int,
                   arg3: ::std::os::raw::c_int, arg4: ::std::os::raw::c_short,
                   arg5: ::std::os::raw::c_int) -> *mut mbuf;
}
extern "C" {
    pub fn m_getptr(arg1: *mut mbuf, arg2: ::std::os::raw::c_int,
                    arg3: *mut ::std::os::raw::c_int) -> *mut mbuf;
}
extern "C" {
    pub fn m_length(arg1: *mut mbuf, arg2: *mut *mut mbuf) -> u_int;
}
extern "C" {
    pub fn m_mbuftouio(arg1: *mut uio, arg2: *const mbuf,
                       arg3: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn m_move_pkthdr(arg1: *mut mbuf, arg2: *mut mbuf);
}
extern "C" {
    pub fn m_pkthdr_init(arg1: *mut mbuf, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn m_prepend(arg1: *mut mbuf, arg2: ::std::os::raw::c_int,
                     arg3: ::std::os::raw::c_int) -> *mut mbuf;
}
extern "C" {
    pub fn m_print(arg1: *const mbuf, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn m_pulldown(arg1: *mut mbuf, arg2: ::std::os::raw::c_int,
                      arg3: ::std::os::raw::c_int,
                      arg4: *mut ::std::os::raw::c_int) -> *mut mbuf;
}
extern "C" {
    pub fn m_pullup(arg1: *mut mbuf, arg2: ::std::os::raw::c_int)
     -> *mut mbuf;
}
extern "C" {
    pub fn m_sanity(arg1: *mut mbuf, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn m_split(arg1: *mut mbuf, arg2: ::std::os::raw::c_int,
                   arg3: ::std::os::raw::c_int) -> *mut mbuf;
}
extern "C" {
    pub fn m_uiotombuf(arg1: *mut uio, arg2: ::std::os::raw::c_int,
                       arg3: ::std::os::raw::c_int,
                       arg4: ::std::os::raw::c_int,
                       arg5: ::std::os::raw::c_int) -> *mut mbuf;
}
extern "C" {
    pub fn m_unshare(arg1: *mut mbuf, arg2: ::std::os::raw::c_int)
     -> *mut mbuf;
}
extern "C" {
    #[link_name = "max_datalen"]
    pub static mut max_datalen: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "max_hdr"]
    pub static mut max_hdr: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "max_linkhdr"]
    pub static mut max_linkhdr: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "max_protohdr"]
    pub static mut max_protohdr: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "nmbclusters"]
    pub static mut nmbclusters: ::std::os::raw::c_int;
}
extern "C" {
    pub fn m_tag_alloc(arg1: u_int32_t, arg2: ::std::os::raw::c_int,
                       arg3: ::std::os::raw::c_int,
                       arg4: ::std::os::raw::c_int) -> *mut m_tag;
}
extern "C" {
    pub fn m_tag_delete(arg1: *mut mbuf, arg2: *mut m_tag);
}
extern "C" {
    pub fn m_tag_delete_chain(arg1: *mut mbuf, arg2: *mut m_tag);
}
extern "C" {
    pub fn m_tag_free_default(arg1: *mut m_tag);
}
extern "C" {
    pub fn m_tag_locate(arg1: *mut mbuf, arg2: u_int32_t,
                        arg3: ::std::os::raw::c_int, arg4: *mut m_tag)
     -> *mut m_tag;
}
extern "C" {
    pub fn m_tag_copy(arg1: *mut m_tag, arg2: ::std::os::raw::c_int)
     -> *mut m_tag;
}
extern "C" {
    pub fn m_tag_copy_chain(arg1: *mut mbuf, arg2: *const mbuf,
                            arg3: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn m_tag_delete_nonpersistent(arg1: *mut mbuf);
}
extern "C" {
    pub fn m_ether_tcpip_hash_init() -> u32;
}
extern "C" {
    pub fn m_ether_tcpip_hash(arg1: u32, arg2: *const mbuf, arg3: u32) -> u32;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mbufq {
    pub mq_head: mbufq__bindgen_ty_1,
    pub mq_len: ::std::os::raw::c_int,
    pub mq_maxlen: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mbufq__bindgen_ty_1 {
    pub stqh_first: *mut mbuf,
    pub stqh_last: *mut *mut mbuf,
}
#[test]
fn bindgen_test_layout_mbufq__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<mbufq__bindgen_ty_1>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( mbufq__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<mbufq__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( mbufq__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbufq__bindgen_ty_1 ) ) . stqh_first as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mbufq__bindgen_ty_1 ) ,
                "::" , stringify ! ( stqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbufq__bindgen_ty_1 ) ) . stqh_last as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mbufq__bindgen_ty_1 ) ,
                "::" , stringify ! ( stqh_last ) ));
}
impl Clone for mbufq__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for mbufq__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_mbufq() {
    assert_eq!(::std::mem::size_of::<mbufq>() , 24usize , concat ! (
               "Size of: " , stringify ! ( mbufq ) ));
    assert_eq! (::std::mem::align_of::<mbufq>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( mbufq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbufq ) ) . mq_head as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mbufq ) , "::" ,
                stringify ! ( mq_head ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbufq ) ) . mq_len as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mbufq ) , "::" ,
                stringify ! ( mq_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbufq ) ) . mq_maxlen as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( mbufq ) , "::" ,
                stringify ! ( mq_maxlen ) ));
}
impl Clone for mbufq {
    fn clone(&self) -> Self { *self }
}
impl Default for mbufq {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct pti_frame {
    pub pti_rdx: register_t,
    pub pti_rax: register_t,
    pub pti_err: register_t,
    pub pti_rip: register_t,
    pub pti_cs: register_t,
    pub pti_rflags: register_t,
    pub pti_rsp: register_t,
    pub pti_ss: register_t,
}
#[test]
fn bindgen_test_layout_pti_frame() {
    assert_eq!(::std::mem::size_of::<pti_frame>() , 64usize , concat ! (
               "Size of: " , stringify ! ( pti_frame ) ));
    assert_eq! (::std::mem::align_of::<pti_frame>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pti_frame ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pti_frame ) ) . pti_rdx as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pti_frame ) , "::" ,
                stringify ! ( pti_rdx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pti_frame ) ) . pti_rax as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pti_frame ) , "::" ,
                stringify ! ( pti_rax ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pti_frame ) ) . pti_err as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( pti_frame ) , "::" ,
                stringify ! ( pti_err ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pti_frame ) ) . pti_rip as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( pti_frame ) , "::" ,
                stringify ! ( pti_rip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pti_frame ) ) . pti_cs as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( pti_frame ) , "::" ,
                stringify ! ( pti_cs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pti_frame ) ) . pti_rflags as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( pti_frame ) , "::" ,
                stringify ! ( pti_rflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pti_frame ) ) . pti_rsp as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( pti_frame ) , "::" ,
                stringify ! ( pti_rsp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pti_frame ) ) . pti_ss as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( pti_frame ) , "::" ,
                stringify ! ( pti_ss ) ));
}
impl Clone for pti_frame {
    fn clone(&self) -> Self { *self }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy)]
pub struct segment_descriptor {
    pub _bitfield_1: [u32; 3usize],
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_segment_descriptor() {
    assert_eq!(::std::mem::size_of::<segment_descriptor>() , 8usize , concat !
               ( "Size of: " , stringify ! ( segment_descriptor ) ));
    assert_eq! (::std::mem::align_of::<segment_descriptor>() , 1usize , concat
                ! ( "Alignment of " , stringify ! ( segment_descriptor ) ));
}
impl Clone for segment_descriptor {
    fn clone(&self) -> Self { *self }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy)]
pub struct user_segment_descriptor {
    pub _bitfield_1: [u32; 3usize],
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_user_segment_descriptor() {
    assert_eq!(::std::mem::size_of::<user_segment_descriptor>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( user_segment_descriptor ) ));
    assert_eq! (::std::mem::align_of::<user_segment_descriptor>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( user_segment_descriptor ) ));
}
impl Clone for user_segment_descriptor {
    fn clone(&self) -> Self { *self }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy)]
pub struct gate_descriptor {
    pub _bitfield_1: [u64; 3usize],
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_gate_descriptor() {
    assert_eq!(::std::mem::size_of::<gate_descriptor>() , 16usize , concat ! (
               "Size of: " , stringify ! ( gate_descriptor ) ));
    assert_eq! (::std::mem::align_of::<gate_descriptor>() , 1usize , concat !
                ( "Alignment of " , stringify ! ( gate_descriptor ) ));
}
impl Clone for gate_descriptor {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union descriptor {
    pub sd: user_segment_descriptor,
    pub gd: gate_descriptor,
    _bindgen_union_align: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_descriptor() {
    assert_eq!(::std::mem::size_of::<descriptor>() , 16usize , concat ! (
               "Size of: " , stringify ! ( descriptor ) ));
    assert_eq! (::std::mem::align_of::<descriptor>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( descriptor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const descriptor ) ) . sd as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( descriptor ) , "::" ,
                stringify ! ( sd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const descriptor ) ) . gd as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( descriptor ) , "::" ,
                stringify ! ( gd ) ));
}
impl Clone for descriptor {
    fn clone(&self) -> Self { *self }
}
impl Default for descriptor {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl ::std::fmt::Debug for descriptor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f , "descriptor {{ union }}")
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy)]
pub struct system_segment_descriptor {
    pub _bitfield_1: [u64; 3usize],
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_system_segment_descriptor() {
    assert_eq!(::std::mem::size_of::<system_segment_descriptor>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( system_segment_descriptor ) ));
    assert_eq! (::std::mem::align_of::<system_segment_descriptor>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( system_segment_descriptor )
                ));
}
impl Clone for system_segment_descriptor {
    fn clone(&self) -> Self { *self }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy)]
pub struct soft_segment_descriptor {
    pub ssd_base: ::std::os::raw::c_ulong,
    pub ssd_limit: ::std::os::raw::c_ulong,
    pub _bitfield_1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_soft_segment_descriptor() {
    assert_eq!(::std::mem::size_of::<soft_segment_descriptor>() , 18usize ,
               concat ! (
               "Size of: " , stringify ! ( soft_segment_descriptor ) ));
    assert_eq! (::std::mem::align_of::<soft_segment_descriptor>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( soft_segment_descriptor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const soft_segment_descriptor ) ) . ssd_base as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( soft_segment_descriptor
                ) , "::" , stringify ! ( ssd_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const soft_segment_descriptor ) ) . ssd_limit
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( soft_segment_descriptor
                ) , "::" , stringify ! ( ssd_limit ) ));
}
impl Clone for soft_segment_descriptor {
    fn clone(&self) -> Self { *self }
}
impl soft_segment_descriptor {
    #[inline]
    pub fn ssd_type(&self) -> ::std::os::raw::c_ulong {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 31u64 as u16;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_ssd_type(&mut self, val: ::std::os::raw::c_ulong) {
        let mask = 31u64 as u16;
        let val = val as u64 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn ssd_dpl(&self) -> ::std::os::raw::c_ulong {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 96u64 as u16;
        let val = (unit_field_val & mask) >> 5usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_ssd_dpl(&mut self, val: ::std::os::raw::c_ulong) {
        let mask = 96u64 as u16;
        let val = val as u64 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 5usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn ssd_p(&self) -> ::std::os::raw::c_ulong {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 128u64 as u16;
        let val = (unit_field_val & mask) >> 7usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_ssd_p(&mut self, val: ::std::os::raw::c_ulong) {
        let mask = 128u64 as u16;
        let val = val as u64 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 7usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn ssd_long(&self) -> ::std::os::raw::c_ulong {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 256u64 as u16;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_ssd_long(&mut self, val: ::std::os::raw::c_ulong) {
        let mask = 256u64 as u16;
        let val = val as u64 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn ssd_def32(&self) -> ::std::os::raw::c_ulong {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 512u64 as u16;
        let val = (unit_field_val & mask) >> 9usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_ssd_def32(&mut self, val: ::std::os::raw::c_ulong) {
        let mask = 512u64 as u16;
        let val = val as u64 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 9usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn ssd_gran(&self) -> ::std::os::raw::c_ulong {
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        let mask = 1024u64 as u16;
        let val = (unit_field_val & mask) >> 10usize;
        unsafe { ::std::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_ssd_gran(&mut self, val: ::std::os::raw::c_ulong) {
        let mask = 1024u64 as u16;
        let val = val as u64 as u16;
        let mut unit_field_val: u16 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                *const u8,
                                            &mut unit_field_val as *mut u16 as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 10usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                *const u8,
                                            &mut self._bitfield_1 as *mut _ as
                                                *mut u8,
                                            ::std::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(ssd_type: ::std::os::raw::c_ulong,
                          ssd_dpl: ::std::os::raw::c_ulong,
                          ssd_p: ::std::os::raw::c_ulong,
                          ssd_long: ::std::os::raw::c_ulong,
                          ssd_def32: ::std::os::raw::c_ulong,
                          ssd_gran: ::std::os::raw::c_ulong) -> u16 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({ 0 } |
                                      ((ssd_type as u64 as u16) << 0usize) &
                                          (31u64 as u16))
                             } |
                                 ((ssd_dpl as u64 as u16) << 5usize) &
                                     (96u64 as u16))
                        } |
                            ((ssd_p as u64 as u16) << 7usize) &
                                (128u64 as u16))
                   } | ((ssd_long as u64 as u16) << 8usize) & (256u64 as u16))
              } | ((ssd_def32 as u64 as u16) << 9usize) & (512u64 as u16))
         } | ((ssd_gran as u64 as u16) << 10usize) & (1024u64 as u16))
    }
}
extern "C" {
    #[link_name = "gdt"]
    pub static mut gdt: [user_segment_descriptor; 0usize];
}
extern "C" {
    #[link_name = "gdt_segs"]
    pub static mut gdt_segs: [soft_segment_descriptor; 0usize];
}
extern "C" {
    #[link_name = "idt"]
    pub static mut idt: *mut gate_descriptor;
}
extern "C" {
    #[link_name = "r_gdt"]
    pub static mut r_gdt: region_descriptor;
}
extern "C" {
    #[link_name = "r_idt"]
    pub static mut r_idt: region_descriptor;
}
extern "C" {
    pub fn lgdt(rdp: *mut region_descriptor);
}
extern "C" {
    pub fn sdtossd(sdp: *mut user_segment_descriptor,
                   ssdp: *mut soft_segment_descriptor);
}
extern "C" {
    pub fn ssdtosd(ssdp: *mut soft_segment_descriptor,
                   sdp: *mut user_segment_descriptor);
}
extern "C" {
    pub fn ssdtosyssd(ssdp: *mut soft_segment_descriptor,
                      sdp: *mut system_segment_descriptor);
}
extern "C" {
    pub fn update_gdt_gsbase(td: *mut thread, base: u32);
}
extern "C" {
    pub fn update_gdt_fsbase(td: *mut thread, base: u32);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cpu_ops {
    pub cpu_init: ::std::option::Option<unsafe extern "C" fn()>,
    pub cpu_resume: ::std::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout_cpu_ops() {
    assert_eq!(::std::mem::size_of::<cpu_ops>() , 16usize , concat ! (
               "Size of: " , stringify ! ( cpu_ops ) ));
    assert_eq! (::std::mem::align_of::<cpu_ops>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( cpu_ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_ops ) ) . cpu_init as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( cpu_ops ) , "::" ,
                stringify ! ( cpu_init ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_ops ) ) . cpu_resume as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( cpu_ops ) , "::" ,
                stringify ! ( cpu_resume ) ));
}
impl Clone for cpu_ops {
    fn clone(&self) -> Self { *self }
}
impl Default for cpu_ops {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
extern "C" {
    #[link_name = "cpu_ops"]
    pub static mut cpu_ops: cpu_ops;
}
extern "C" {
    #[link_name = "btext"]
    pub static mut btext: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "etext"]
    pub static mut etext: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "kernphys"]
    pub static mut kernphys: [::std::os::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "vmm_resume_p"]
    pub static mut vmm_resume_p:
               ::std::option::Option<unsafe extern "C" fn()>;
}
extern "C" {
    pub fn cpu_halt();
}
extern "C" {
    pub fn cpu_reset();
}
extern "C" {
    pub fn fork_trampoline();
}
extern "C" {
    pub fn swi_vm(arg1: *mut ::std::os::raw::c_void);
}
#[repr(C)]
pub struct buf_ring {
    pub br_prod_head: u32,
    pub br_prod_tail: u32,
    pub br_prod_size: ::std::os::raw::c_int,
    pub br_prod_mask: ::std::os::raw::c_int,
    pub br_drops: u64,
    pub __bindgen_padding_0: [u32; 10usize],
    pub br_cons_head: u32,
    pub br_cons_tail: u32,
    pub br_cons_size: ::std::os::raw::c_int,
    pub br_cons_mask: ::std::os::raw::c_int,
    pub __bindgen_padding_1: [u64; 6usize],
    pub br_ring: __IncompleteArrayField<*mut ::std::os::raw::c_void>,
}
#[test]
fn bindgen_test_layout_buf_ring() {
    assert_eq!(::std::mem::size_of::<buf_ring>() , 128usize , concat ! (
               "Size of: " , stringify ! ( buf_ring ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const buf_ring ) ) . br_prod_head as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( buf_ring ) , "::" ,
                stringify ! ( br_prod_head ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const buf_ring ) ) . br_prod_tail as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( buf_ring ) , "::" ,
                stringify ! ( br_prod_tail ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const buf_ring ) ) . br_prod_size as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( buf_ring ) , "::" ,
                stringify ! ( br_prod_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const buf_ring ) ) . br_prod_mask as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( buf_ring ) , "::" ,
                stringify ! ( br_prod_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const buf_ring ) ) . br_drops as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( buf_ring ) , "::" ,
                stringify ! ( br_drops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const buf_ring ) ) . br_cons_head as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( buf_ring ) , "::" ,
                stringify ! ( br_cons_head ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const buf_ring ) ) . br_cons_tail as * const _
                as usize } , 68usize , concat ! (
                "Alignment of field: " , stringify ! ( buf_ring ) , "::" ,
                stringify ! ( br_cons_tail ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const buf_ring ) ) . br_cons_size as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( buf_ring ) , "::" ,
                stringify ! ( br_cons_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const buf_ring ) ) . br_cons_mask as * const _
                as usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( buf_ring ) , "::" ,
                stringify ! ( br_cons_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const buf_ring ) ) . br_ring as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( buf_ring ) , "::" ,
                stringify ! ( br_ring ) ));
}
impl Default for buf_ring {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl ::std::fmt::Debug for buf_ring {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f ,
               "buf_ring {{ br_prod_head: {:?}, br_prod_tail: {:?}, br_prod_size: {:?}, br_prod_mask: {:?}, br_drops: {:?}, br_cons_head: {:?}, br_cons_tail: {:?}, br_cons_size: {:?}, br_cons_mask: {:?}, br_ring: {:?} }}"
               , self . br_prod_head , self . br_prod_tail , self .
               br_prod_size , self . br_prod_mask , self . br_drops , self .
               br_cons_head , self . br_cons_tail , self . br_cons_size , self
               . br_cons_mask , self . br_ring)
    }
}
extern "C" {
    pub fn buf_ring_alloc(count: ::std::os::raw::c_int,
                          type_: *mut malloc_type,
                          flags: ::std::os::raw::c_int, arg1: *mut mtx)
     -> *mut buf_ring;
}
extern "C" {
    pub fn buf_ring_free(br: *mut buf_ring, type_: *mut malloc_type);
}
pub type counter_u64_t = *mut u64;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct _cpuset {
    pub __bits: [::std::os::raw::c_long; 4usize],
}
#[test]
fn bindgen_test_layout__cpuset() {
    assert_eq!(::std::mem::size_of::<_cpuset>() , 32usize , concat ! (
               "Size of: " , stringify ! ( _cpuset ) ));
    assert_eq! (::std::mem::align_of::<_cpuset>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _cpuset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _cpuset ) ) . __bits as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _cpuset ) , "::" ,
                stringify ! ( __bits ) ));
}
impl Clone for _cpuset {
    fn clone(&self) -> Self { *self }
}
pub type cpuset_t = _cpuset;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sx {
    pub lock_object: lock_object,
    pub sx_lock: usize,
}
#[test]
fn bindgen_test_layout_sx() {
    assert_eq!(::std::mem::size_of::<sx>() , 32usize , concat ! (
               "Size of: " , stringify ! ( sx ) ));
    assert_eq! (::std::mem::align_of::<sx>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sx ) ) . lock_object as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sx ) , "::" , stringify
                ! ( lock_object ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sx ) ) . sx_lock as * const _ as usize }
                , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( sx ) , "::" , stringify
                ! ( sx_lock ) ));
}
impl Clone for sx {
    fn clone(&self) -> Self { *self }
}
impl Default for sx {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rmpriolist {
    pub lh_first: *mut rm_priotracker,
}
#[test]
fn bindgen_test_layout_rmpriolist() {
    assert_eq!(::std::mem::size_of::<rmpriolist>() , 8usize , concat ! (
               "Size of: " , stringify ! ( rmpriolist ) ));
    assert_eq! (::std::mem::align_of::<rmpriolist>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rmpriolist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmpriolist ) ) . lh_first as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rmpriolist ) , "::" ,
                stringify ! ( lh_first ) ));
}
impl Clone for rmpriolist {
    fn clone(&self) -> Self { *self }
}
impl Default for rmpriolist {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rm_queue {
    pub rmq_next: *mut rm_queue,
    pub rmq_prev: *mut rm_queue,
}
#[test]
fn bindgen_test_layout_rm_queue() {
    assert_eq!(::std::mem::size_of::<rm_queue>() , 16usize , concat ! (
               "Size of: " , stringify ! ( rm_queue ) ));
    assert_eq! (::std::mem::align_of::<rm_queue>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rm_queue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rm_queue ) ) . rmq_next as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rm_queue ) , "::" ,
                stringify ! ( rmq_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rm_queue ) ) . rmq_prev as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rm_queue ) , "::" ,
                stringify ! ( rmq_prev ) ));
}
impl Clone for rm_queue {
    fn clone(&self) -> Self { *self }
}
impl Default for rm_queue {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct rmlock {
    pub lock_object: lock_object,
    pub rm_writecpus: cpuset_t,
    pub rm_activeReaders: rmlock__bindgen_ty_1,
    pub _rm_lock: rmlock__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rmlock__bindgen_ty_1 {
    pub lh_first: *mut rm_priotracker,
}
#[test]
fn bindgen_test_layout_rmlock__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rmlock__bindgen_ty_1>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( rmlock__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<rmlock__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rmlock__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmlock__bindgen_ty_1 ) ) . lh_first as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rmlock__bindgen_ty_1 )
                , "::" , stringify ! ( lh_first ) ));
}
impl Clone for rmlock__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for rmlock__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub union rmlock__bindgen_ty_2 {
    pub _rm_wlock_object: lock_object,
    pub _rm_lock_mtx: mtx,
    pub _rm_lock_sx: sx,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_rmlock__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<rmlock__bindgen_ty_2>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( rmlock__bindgen_ty_2 )
               ));
    assert_eq! (::std::mem::align_of::<rmlock__bindgen_ty_2>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rmlock__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmlock__bindgen_ty_2 ) ) .
                _rm_wlock_object as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rmlock__bindgen_ty_2 )
                , "::" , stringify ! ( _rm_wlock_object ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmlock__bindgen_ty_2 ) ) . _rm_lock_mtx
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rmlock__bindgen_ty_2 )
                , "::" , stringify ! ( _rm_lock_mtx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmlock__bindgen_ty_2 ) ) . _rm_lock_sx as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rmlock__bindgen_ty_2 )
                , "::" , stringify ! ( _rm_lock_sx ) ));
}
impl Clone for rmlock__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for rmlock__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl ::std::fmt::Debug for rmlock__bindgen_ty_2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f , "rmlock__bindgen_ty_2 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_rmlock() {
    assert_eq!(::std::mem::size_of::<rmlock>() , 96usize , concat ! (
               "Size of: " , stringify ! ( rmlock ) ));
    assert_eq! (::std::mem::align_of::<rmlock>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rmlock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmlock ) ) . lock_object as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rmlock ) , "::" ,
                stringify ! ( lock_object ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmlock ) ) . rm_writecpus as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rmlock ) , "::" ,
                stringify ! ( rm_writecpus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmlock ) ) . rm_activeReaders as * const
                _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( rmlock ) , "::" ,
                stringify ! ( rm_activeReaders ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmlock ) ) . _rm_lock as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( rmlock ) , "::" ,
                stringify ! ( _rm_lock ) ));
}
impl Clone for rmlock {
    fn clone(&self) -> Self { *self }
}
impl Default for rmlock {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl ::std::fmt::Debug for rmlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f ,
               "rmlock {{ lock_object: {:?}, rm_writecpus: {:?}, rm_activeReaders: {:?}, _rm_lock: {:?} }}"
               , self . lock_object , self . rm_writecpus , self .
               rm_activeReaders , self . _rm_lock)
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rm_priotracker {
    pub rmp_cpuQueue: rm_queue,
    pub rmp_rmlock: *mut rmlock,
    pub rmp_thread: *mut thread,
    pub rmp_flags: ::std::os::raw::c_int,
    pub rmp_qentry: rm_priotracker__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rm_priotracker__bindgen_ty_1 {
    pub le_next: *mut rm_priotracker,
    pub le_prev: *mut *mut rm_priotracker,
}
#[test]
fn bindgen_test_layout_rm_priotracker__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<rm_priotracker__bindgen_ty_1>() , 16usize
               , concat ! (
               "Size of: " , stringify ! ( rm_priotracker__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<rm_priotracker__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( rm_priotracker__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rm_priotracker__bindgen_ty_1 ) ) .
                le_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rm_priotracker__bindgen_ty_1 ) , "::" , stringify ! ( le_next
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rm_priotracker__bindgen_ty_1 ) ) .
                le_prev as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                rm_priotracker__bindgen_ty_1 ) , "::" , stringify ! ( le_prev
                ) ));
}
impl Clone for rm_priotracker__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for rm_priotracker__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_rm_priotracker() {
    assert_eq!(::std::mem::size_of::<rm_priotracker>() , 56usize , concat ! (
               "Size of: " , stringify ! ( rm_priotracker ) ));
    assert_eq! (::std::mem::align_of::<rm_priotracker>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rm_priotracker ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rm_priotracker ) ) . rmp_cpuQueue as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rm_priotracker ) , "::"
                , stringify ! ( rmp_cpuQueue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rm_priotracker ) ) . rmp_rmlock as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rm_priotracker ) , "::"
                , stringify ! ( rmp_rmlock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rm_priotracker ) ) . rmp_thread as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rm_priotracker ) , "::"
                , stringify ! ( rmp_thread ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rm_priotracker ) ) . rmp_flags as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rm_priotracker ) , "::"
                , stringify ! ( rmp_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rm_priotracker ) ) . rmp_qentry as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rm_priotracker ) , "::"
                , stringify ! ( rmp_qentry ) ));
}
impl Clone for rm_priotracker {
    fn clone(&self) -> Self { *self }
}
impl Default for rm_priotracker {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct rusage {
    pub ru_utime: timeval,
    pub ru_stime: timeval,
    pub ru_maxrss: ::std::os::raw::c_long,
    pub ru_ixrss: ::std::os::raw::c_long,
    pub ru_idrss: ::std::os::raw::c_long,
    pub ru_isrss: ::std::os::raw::c_long,
    pub ru_minflt: ::std::os::raw::c_long,
    pub ru_majflt: ::std::os::raw::c_long,
    pub ru_nswap: ::std::os::raw::c_long,
    pub ru_inblock: ::std::os::raw::c_long,
    pub ru_oublock: ::std::os::raw::c_long,
    pub ru_msgsnd: ::std::os::raw::c_long,
    pub ru_msgrcv: ::std::os::raw::c_long,
    pub ru_nsignals: ::std::os::raw::c_long,
    pub ru_nvcsw: ::std::os::raw::c_long,
    pub ru_nivcsw: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_rusage() {
    assert_eq!(::std::mem::size_of::<rusage>() , 144usize , concat ! (
               "Size of: " , stringify ! ( rusage ) ));
    assert_eq! (::std::mem::align_of::<rusage>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rusage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_utime as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_utime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_stime as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_stime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_maxrss as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_maxrss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_ixrss as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_ixrss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_idrss as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_idrss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_isrss as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_isrss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_minflt as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_minflt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_majflt as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_majflt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_nswap as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_nswap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_inblock as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_inblock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_oublock as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_oublock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_msgsnd as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_msgsnd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_msgrcv as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_msgrcv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_nsignals as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_nsignals ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_nvcsw as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_nvcsw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_nivcsw as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_nivcsw ) ));
}
impl Clone for rusage {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct __wrusage {
    pub wru_self: rusage,
    pub wru_children: rusage,
}
#[test]
fn bindgen_test_layout___wrusage() {
    assert_eq!(::std::mem::size_of::<__wrusage>() , 288usize , concat ! (
               "Size of: " , stringify ! ( __wrusage ) ));
    assert_eq! (::std::mem::align_of::<__wrusage>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __wrusage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __wrusage ) ) . wru_self as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __wrusage ) , "::" ,
                stringify ! ( wru_self ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __wrusage ) ) . wru_children as * const _
                as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( __wrusage ) , "::" ,
                stringify ! ( wru_children ) ));
}
impl Clone for __wrusage {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct rlimit {
    pub rlim_cur: rlim_t,
    pub rlim_max: rlim_t,
}
#[test]
fn bindgen_test_layout_rlimit() {
    assert_eq!(::std::mem::size_of::<rlimit>() , 16usize , concat ! (
               "Size of: " , stringify ! ( rlimit ) ));
    assert_eq! (::std::mem::align_of::<rlimit>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rlimit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rlimit ) ) . rlim_cur as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rlimit ) , "::" ,
                stringify ! ( rlim_cur ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rlimit ) ) . rlim_max as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rlimit ) , "::" ,
                stringify ! ( rlim_max ) ));
}
impl Clone for rlimit {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct orlimit {
    pub rlim_cur: __int32_t,
    pub rlim_max: __int32_t,
}
#[test]
fn bindgen_test_layout_orlimit() {
    assert_eq!(::std::mem::size_of::<orlimit>() , 8usize , concat ! (
               "Size of: " , stringify ! ( orlimit ) ));
    assert_eq! (::std::mem::align_of::<orlimit>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( orlimit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const orlimit ) ) . rlim_cur as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( orlimit ) , "::" ,
                stringify ! ( rlim_cur ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const orlimit ) ) . rlim_max as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( orlimit ) , "::" ,
                stringify ! ( rlim_max ) ));
}
impl Clone for orlimit {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct loadavg {
    pub ldavg: [__fixpt_t; 3usize],
    pub fscale: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_loadavg() {
    assert_eq!(::std::mem::size_of::<loadavg>() , 24usize , concat ! (
               "Size of: " , stringify ! ( loadavg ) ));
    assert_eq! (::std::mem::align_of::<loadavg>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( loadavg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const loadavg ) ) . ldavg as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( loadavg ) , "::" ,
                stringify ! ( ldavg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const loadavg ) ) . fscale as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( loadavg ) , "::" ,
                stringify ! ( fscale ) ));
}
impl Clone for loadavg {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "averunnable"]
    pub static mut averunnable: loadavg;
}
extern "C" {
    pub fn read_cpu_time(cp_time: *mut ::std::os::raw::c_long);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcb {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "__start_set_pcpu"]
    pub static mut __start_set_pcpu: *mut usize;
}
extern "C" {
    #[link_name = "__stop_set_pcpu"]
    pub static mut __stop_set_pcpu: *mut usize;
}
extern "C" {
    #[link_name = "dpcpu_off"]
    pub static mut dpcpu_off: [usize; 0usize];
}
#[repr(C)]
#[derive(Copy)]
pub struct pcpu {
    pub pc_curthread: *mut thread,
    pub pc_idlethread: *mut thread,
    pub pc_fpcurthread: *mut thread,
    pub pc_deadthread: *mut thread,
    pub pc_curpcb: *mut pcb,
    pub pc_switchtime: u64,
    pub pc_switchticks: ::std::os::raw::c_int,
    pub pc_cpuid: u_int,
    pub pc_allcpu: pcpu__bindgen_ty_1,
    pub pc_spinlocks: *mut lock_list_entry,
    pub pc_cp_time: [::std::os::raw::c_long; 5usize],
    pub pc_device: *mut device,
    pub pc_netisr: *mut ::std::os::raw::c_void,
    pub pc_unused1: ::std::os::raw::c_int,
    pub pc_domain: ::std::os::raw::c_int,
    pub pc_rm_queue: rm_queue,
    pub pc_dynamic: usize,
    pub pc_early_dummy_counter: u64,
    pub __bindgen_padding_0: [u8; 88usize],
    pub pc_monitorbuf: [::std::os::raw::c_char; 128usize],
    pub pc_prvspace: *mut pcpu,
    pub pc_curpmap: *mut pmap,
    pub pc_tssp: *mut amd64tss,
    pub pc_commontssp: *mut amd64tss,
    pub pc_kcr3: u64,
    pub pc_ucr3: u64,
    pub pc_rsp0: register_t,
    pub pc_scratch_rsp: register_t,
    pub pc_scratch_rax: register_t,
    pub pc_apic_id: u_int,
    pub pc_acpi_id: u_int,
    pub pc_fs32p: *mut user_segment_descriptor,
    pub pc_gs32p: *mut user_segment_descriptor,
    pub pc_ldt: *mut system_segment_descriptor,
    pub pc_tss: *mut system_segment_descriptor,
    pub pc_pm_save_cnt: u64,
    pub pc_cmci_mask: u_int,
    pub pc_dbreg: [u64; 16usize],
    pub pc_pti_stack: [u64; 16usize],
    pub pc_dbreg_cmd: ::std::os::raw::c_int,
    pub pc_vcpu_id: u_int,
    pub pc_pcid_next: u32,
    pub pc_pcid_gen: u32,
    pub pc_smp_tlb_done: u32,
    pub __pad: [::std::os::raw::c_char; 232usize],
    pub __bindgen_padding_1: u32,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pcpu__bindgen_ty_1 {
    pub stqe_next: *mut pcpu,
}
#[test]
fn bindgen_test_layout_pcpu__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<pcpu__bindgen_ty_1>() , 8usize , concat !
               ( "Size of: " , stringify ! ( pcpu__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<pcpu__bindgen_ty_1>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( pcpu__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu__bindgen_ty_1 ) ) . stqe_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu__bindgen_ty_1 ) ,
                "::" , stringify ! ( stqe_next ) ));
}
impl Clone for pcpu__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for pcpu__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_pcpu() {
    assert_eq!(::std::mem::size_of::<pcpu>() , 1024usize , concat ! (
               "Size of: " , stringify ! ( pcpu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_curthread as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_curthread ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_idlethread as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_idlethread ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_fpcurthread as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_fpcurthread ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_deadthread as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_deadthread ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_curpcb as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_curpcb ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_switchtime as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_switchtime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_switchticks as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_switchticks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_cpuid as * const _ as usize
                } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_cpuid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_allcpu as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_allcpu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_spinlocks as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_spinlocks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_cp_time as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_cp_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_device as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_device ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_netisr as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_netisr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_unused1 as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_unused1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_domain as * const _ as
                usize } , 132usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_domain ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_rm_queue as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_rm_queue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_dynamic as * const _ as
                usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_dynamic ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_early_dummy_counter as *
                const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_early_dummy_counter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_monitorbuf as * const _ as
                usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_monitorbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_prvspace as * const _ as
                usize } , 384usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_prvspace ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_curpmap as * const _ as
                usize } , 392usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_curpmap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_tssp as * const _ as usize
                } , 400usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_tssp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_commontssp as * const _ as
                usize } , 408usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_commontssp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_kcr3 as * const _ as usize
                } , 416usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_kcr3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_ucr3 as * const _ as usize
                } , 424usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_ucr3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_rsp0 as * const _ as usize
                } , 432usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_rsp0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_scratch_rsp as * const _ as
                usize } , 440usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_scratch_rsp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_scratch_rax as * const _ as
                usize } , 448usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_scratch_rax ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_apic_id as * const _ as
                usize } , 456usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_apic_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_acpi_id as * const _ as
                usize } , 460usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_acpi_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_fs32p as * const _ as usize
                } , 464usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_fs32p ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_gs32p as * const _ as usize
                } , 472usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_gs32p ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_ldt as * const _ as usize }
                , 480usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_ldt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_tss as * const _ as usize }
                , 488usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_tss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_pm_save_cnt as * const _ as
                usize } , 496usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_pm_save_cnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_cmci_mask as * const _ as
                usize } , 504usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_cmci_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_dbreg as * const _ as usize
                } , 512usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_dbreg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_pti_stack as * const _ as
                usize } , 640usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_pti_stack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_dbreg_cmd as * const _ as
                usize } , 768usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_dbreg_cmd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_vcpu_id as * const _ as
                usize } , 772usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_vcpu_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_pcid_next as * const _ as
                usize } , 776usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_pcid_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_pcid_gen as * const _ as
                usize } , 780usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_pcid_gen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_smp_tlb_done as * const _
                as usize } , 784usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_smp_tlb_done ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . __pad as * const _ as usize }
                , 788usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( __pad ) ));
}
impl Clone for pcpu {
    fn clone(&self) -> Self { *self }
}
impl Default for pcpu {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl ::std::fmt::Debug for pcpu {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f ,
               "pcpu {{ pc_curthread: {:?}, pc_idlethread: {:?}, pc_fpcurthread: {:?}, pc_deadthread: {:?}, pc_curpcb: {:?}, pc_switchtime: {:?}, pc_switchticks: {:?}, pc_cpuid: {:?}, pc_allcpu: {:?}, pc_spinlocks: {:?}, pc_cp_time: {:?}, pc_device: {:?}, pc_netisr: {:?}, pc_unused1: {:?}, pc_domain: {:?}, pc_rm_queue: {:?}, pc_dynamic: {:?}, pc_early_dummy_counter: {:?}, pc_monitorbuf: [{}], pc_prvspace: {:?}, pc_curpmap: {:?}, pc_tssp: {:?}, pc_commontssp: {:?}, pc_kcr3: {:?}, pc_ucr3: {:?}, pc_rsp0: {:?}, pc_scratch_rsp: {:?}, pc_scratch_rax: {:?}, pc_apic_id: {:?}, pc_acpi_id: {:?}, pc_fs32p: {:?}, pc_gs32p: {:?}, pc_ldt: {:?}, pc_tss: {:?}, pc_pm_save_cnt: {:?}, pc_cmci_mask: {:?}, pc_dbreg: {:?}, pc_pti_stack: {:?}, pc_dbreg_cmd: {:?}, pc_vcpu_id: {:?}, pc_pcid_next: {:?}, pc_pcid_gen: {:?}, pc_smp_tlb_done: {:?}, __pad: [{}] }}"
               , self . pc_curthread , self . pc_idlethread , self .
               pc_fpcurthread , self . pc_deadthread , self . pc_curpcb , self
               . pc_switchtime , self . pc_switchticks , self . pc_cpuid ,
               self . pc_allcpu , self . pc_spinlocks , self . pc_cp_time ,
               self . pc_device , self . pc_netisr , self . pc_unused1 , self
               . pc_domain , self . pc_rm_queue , self . pc_dynamic , self .
               pc_early_dummy_counter , self . pc_monitorbuf . iter (  ) .
               enumerate (  ) . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ) , self . pc_prvspace , self . pc_curpmap , self .
               pc_tssp , self . pc_commontssp , self . pc_kcr3 , self .
               pc_ucr3 , self . pc_rsp0 , self . pc_scratch_rsp , self .
               pc_scratch_rax , self . pc_apic_id , self . pc_acpi_id , self .
               pc_fs32p , self . pc_gs32p , self . pc_ldt , self . pc_tss ,
               self . pc_pm_save_cnt , self . pc_cmci_mask , self . pc_dbreg ,
               self . pc_pti_stack , self . pc_dbreg_cmd , self . pc_vcpu_id ,
               self . pc_pcid_next , self . pc_pcid_gen , self .
               pc_smp_tlb_done , self . __pad . iter (  ) . enumerate (  ) .
               map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ))
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cpuhead {
    pub stqh_first: *mut pcpu,
    pub stqh_last: *mut *mut pcpu,
}
#[test]
fn bindgen_test_layout_cpuhead() {
    assert_eq!(::std::mem::size_of::<cpuhead>() , 16usize , concat ! (
               "Size of: " , stringify ! ( cpuhead ) ));
    assert_eq! (::std::mem::align_of::<cpuhead>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( cpuhead ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuhead ) ) . stqh_first as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuhead ) , "::" ,
                stringify ! ( stqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuhead ) ) . stqh_last as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuhead ) , "::" ,
                stringify ! ( stqh_last ) ));
}
impl Clone for cpuhead {
    fn clone(&self) -> Self { *self }
}
impl Default for cpuhead {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
extern "C" {
    #[link_name = "cpuhead"]
    pub static mut cpuhead: cpuhead;
}
extern "C" {
    #[link_name = "cpuid_to_pcpu"]
    pub static mut cpuid_to_pcpu: [*mut pcpu; 0usize];
}
extern "C" {
    pub fn cpu_pcpu_init(pcpu: *mut pcpu, cpuid: ::std::os::raw::c_int,
                         size: usize);
}
extern "C" {
    pub fn db_show_mdpcpu(pcpu: *mut pcpu);
}
extern "C" {
    pub fn dpcpu_alloc(size: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn dpcpu_copy(s: *mut ::std::os::raw::c_void,
                      size: ::std::os::raw::c_int);
}
extern "C" {
    pub fn dpcpu_free(s: *mut ::std::os::raw::c_void,
                      size: ::std::os::raw::c_int);
}
extern "C" {
    pub fn dpcpu_init(dpcpu: *mut ::std::os::raw::c_void,
                      cpuid: ::std::os::raw::c_int);
}
extern "C" {
    pub fn pcpu_destroy(pcpu: *mut pcpu);
}
extern "C" {
    pub fn pcpu_find(cpuid: u_int) -> *mut pcpu;
}
extern "C" {
    pub fn pcpu_init(pcpu: *mut pcpu, cpuid: ::std::os::raw::c_int,
                     size: usize);
}
extern "C" {
    #[link_name = "__pcpu"]
    pub static mut __pcpu: [pcpu; 0usize];
}
extern "C" {
    pub fn counter_u64_alloc(arg1: ::std::os::raw::c_int) -> counter_u64_t;
}
extern "C" {
    pub fn counter_u64_free(arg1: counter_u64_t);
}
extern "C" {
    pub fn counter_u64_zero(arg1: counter_u64_t);
}
extern "C" {
    pub fn counter_u64_fetch(arg1: counter_u64_t) -> u64;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct counter_rate {
    pub cr_rate: counter_u64_t,
    pub cr_lock: ::std::os::raw::c_int,
    pub cr_ticks: ::std::os::raw::c_int,
    pub cr_over: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_counter_rate() {
    assert_eq!(::std::mem::size_of::<counter_rate>() , 24usize , concat ! (
               "Size of: " , stringify ! ( counter_rate ) ));
    assert_eq! (::std::mem::align_of::<counter_rate>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( counter_rate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const counter_rate ) ) . cr_rate as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( counter_rate ) , "::" ,
                stringify ! ( cr_rate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const counter_rate ) ) . cr_lock as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( counter_rate ) , "::" ,
                stringify ! ( cr_lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const counter_rate ) ) . cr_ticks as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( counter_rate ) , "::" ,
                stringify ! ( cr_ticks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const counter_rate ) ) . cr_over as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( counter_rate ) , "::" ,
                stringify ! ( cr_over ) ));
}
impl Clone for counter_rate {
    fn clone(&self) -> Self { *self }
}
impl Default for counter_rate {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
extern "C" {
    pub fn counter_ratecheck(arg1: *mut counter_rate, arg2: i64) -> i64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lock_list_entry {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lock_class {
    pub lc_name: *const ::std::os::raw::c_char,
    pub lc_flags: u_int,
    pub lc_assert: ::std::option::Option<unsafe extern "C" fn(lock:
                                                                  *const lock_object,
                                                              what:
                                                                  ::std::os::raw::c_int)>,
    pub lc_ddb_show: ::std::option::Option<unsafe extern "C" fn(lock:
                                                                    *const lock_object)>,
    pub lc_lock: ::std::option::Option<unsafe extern "C" fn(lock:
                                                                *mut lock_object,
                                                            how: usize)>,
    pub lc_owner: ::std::option::Option<unsafe extern "C" fn(lock:
                                                                 *const lock_object,
                                                             owner:
                                                                 *mut *mut thread)
                                            -> ::std::os::raw::c_int>,
    pub lc_unlock: ::std::option::Option<unsafe extern "C" fn(lock:
                                                                  *mut lock_object)
                                             -> usize>,
}
#[test]
fn bindgen_test_layout_lock_class() {
    assert_eq!(::std::mem::size_of::<lock_class>() , 56usize , concat ! (
               "Size of: " , stringify ! ( lock_class ) ));
    assert_eq! (::std::mem::align_of::<lock_class>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lock_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_class ) ) . lc_name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_class ) , "::" ,
                stringify ! ( lc_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_class ) ) . lc_flags as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_class ) , "::" ,
                stringify ! ( lc_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_class ) ) . lc_assert as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_class ) , "::" ,
                stringify ! ( lc_assert ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_class ) ) . lc_ddb_show as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_class ) , "::" ,
                stringify ! ( lc_ddb_show ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_class ) ) . lc_lock as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_class ) , "::" ,
                stringify ! ( lc_lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_class ) ) . lc_owner as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_class ) , "::" ,
                stringify ! ( lc_owner ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_class ) ) . lc_unlock as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_class ) , "::" ,
                stringify ! ( lc_unlock ) ));
}
impl Clone for lock_class {
    fn clone(&self) -> Self { *self }
}
impl Default for lock_class {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
extern "C" {
    #[link_name = "lock_class_mtx_sleep"]
    pub static mut lock_class_mtx_sleep: lock_class;
}
extern "C" {
    #[link_name = "lock_class_mtx_spin"]
    pub static mut lock_class_mtx_spin: lock_class;
}
extern "C" {
    #[link_name = "lock_class_sx"]
    pub static mut lock_class_sx: lock_class;
}
extern "C" {
    #[link_name = "lock_class_rw"]
    pub static mut lock_class_rw: lock_class;
}
extern "C" {
    #[link_name = "lock_class_rm"]
    pub static mut lock_class_rm: lock_class;
}
extern "C" {
    #[link_name = "lock_class_rm_sleepable"]
    pub static mut lock_class_rm_sleepable: lock_class;
}
extern "C" {
    #[link_name = "lock_class_lockmgr"]
    pub static mut lock_class_lockmgr: lock_class;
}
extern "C" {
    #[link_name = "lock_classes"]
    pub static mut lock_classes: [*mut lock_class; 0usize];
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct lock_delay_config {
    pub base: u_int,
    pub max: u_int,
}
#[test]
fn bindgen_test_layout_lock_delay_config() {
    assert_eq!(::std::mem::size_of::<lock_delay_config>() , 8usize , concat !
               ( "Size of: " , stringify ! ( lock_delay_config ) ));
    assert_eq! (::std::mem::align_of::<lock_delay_config>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( lock_delay_config ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_delay_config ) ) . base as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_delay_config ) ,
                "::" , stringify ! ( base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_delay_config ) ) . max as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_delay_config ) ,
                "::" , stringify ! ( max ) ));
}
impl Clone for lock_delay_config {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lock_delay_arg {
    pub config: *mut lock_delay_config,
    pub delay: u_int,
    pub spin_cnt: u_int,
}
#[test]
fn bindgen_test_layout_lock_delay_arg() {
    assert_eq!(::std::mem::size_of::<lock_delay_arg>() , 16usize , concat ! (
               "Size of: " , stringify ! ( lock_delay_arg ) ));
    assert_eq! (::std::mem::align_of::<lock_delay_arg>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lock_delay_arg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_delay_arg ) ) . config as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_delay_arg ) , "::"
                , stringify ! ( config ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_delay_arg ) ) . delay as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_delay_arg ) , "::"
                , stringify ! ( delay ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_delay_arg ) ) . spin_cnt as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_delay_arg ) , "::"
                , stringify ! ( spin_cnt ) ));
}
impl Clone for lock_delay_arg {
    fn clone(&self) -> Self { *self }
}
impl Default for lock_delay_arg {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
extern "C" {
    pub fn lock_init(arg1: *mut lock_object, arg2: *mut lock_class,
                     arg3: *const ::std::os::raw::c_char,
                     arg4: *const ::std::os::raw::c_char,
                     arg5: ::std::os::raw::c_int);
}
extern "C" {
    pub fn lock_destroy(arg1: *mut lock_object);
}
extern "C" {
    pub fn lock_delay(arg1: *mut lock_delay_arg);
}
extern "C" {
    pub fn lock_delay_default_init(arg1: *mut lock_delay_config);
}
extern "C" {
    pub fn spinlock_enter();
}
extern "C" {
    pub fn spinlock_exit();
}
extern "C" {
    pub fn witness_init(arg1: *mut lock_object,
                        arg2: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn witness_destroy(arg1: *mut lock_object);
}
extern "C" {
    pub fn witness_defineorder(arg1: *mut lock_object, arg2: *mut lock_object)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn witness_checkorder(arg1: *mut lock_object,
                              arg2: ::std::os::raw::c_int,
                              arg3: *const ::std::os::raw::c_char,
                              arg4: ::std::os::raw::c_int,
                              arg5: *mut lock_object);
}
extern "C" {
    pub fn witness_lock(arg1: *mut lock_object, arg2: ::std::os::raw::c_int,
                        arg3: *const ::std::os::raw::c_char,
                        arg4: ::std::os::raw::c_int);
}
extern "C" {
    pub fn witness_upgrade(arg1: *mut lock_object,
                           arg2: ::std::os::raw::c_int,
                           arg3: *const ::std::os::raw::c_char,
                           arg4: ::std::os::raw::c_int);
}
extern "C" {
    pub fn witness_downgrade(arg1: *mut lock_object,
                             arg2: ::std::os::raw::c_int,
                             arg3: *const ::std::os::raw::c_char,
                             arg4: ::std::os::raw::c_int);
}
extern "C" {
    pub fn witness_unlock(arg1: *mut lock_object, arg2: ::std::os::raw::c_int,
                          arg3: *const ::std::os::raw::c_char,
                          arg4: ::std::os::raw::c_int);
}
extern "C" {
    pub fn witness_save(arg1: *mut lock_object,
                        arg2: *mut *const ::std::os::raw::c_char,
                        arg3: *mut ::std::os::raw::c_int);
}
extern "C" {
    pub fn witness_restore(arg1: *mut lock_object,
                           arg2: *const ::std::os::raw::c_char,
                           arg3: ::std::os::raw::c_int);
}
extern "C" {
    pub fn witness_list_locks(arg1: *mut *mut lock_list_entry,
                              arg2:
                                  ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                 *const ::std::os::raw::c_char, ...)
                                                            ->
                                                                ::std::os::raw::c_int>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn witness_warn(arg1: ::std::os::raw::c_int, arg2: *mut lock_object,
                        arg3: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn witness_assert(arg1: *const lock_object,
                          arg2: ::std::os::raw::c_int,
                          arg3: *const ::std::os::raw::c_char,
                          arg4: ::std::os::raw::c_int);
}
extern "C" {
    pub fn witness_display_spinlock(arg1: *mut lock_object, arg2: *mut thread,
                                    arg3:
                                        ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                                       *const ::std::os::raw::c_char, ...)
                                                                  ->
                                                                      ::std::os::raw::c_int>);
}
extern "C" {
    pub fn witness_line(arg1: *mut lock_object) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn witness_norelease(arg1: *mut lock_object);
}
extern "C" {
    pub fn witness_releaseok(arg1: *mut lock_object);
}
extern "C" {
    pub fn witness_file(arg1: *mut lock_object)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn witness_thread_exit(arg1: *mut thread);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lock_profile_object {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lpohead {
    pub lh_first: *mut lock_profile_object,
}
#[test]
fn bindgen_test_layout_lpohead() {
    assert_eq!(::std::mem::size_of::<lpohead>() , 8usize , concat ! (
               "Size of: " , stringify ! ( lpohead ) ));
    assert_eq! (::std::mem::align_of::<lpohead>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lpohead ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lpohead ) ) . lh_first as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lpohead ) , "::" ,
                stringify ! ( lh_first ) ));
}
impl Clone for lpohead {
    fn clone(&self) -> Self { *self }
}
impl Default for lpohead {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
extern "C" {
    #[link_name = "lockstat_enabled"]
    pub static mut lockstat_enabled: ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mtx_init(c: *mut usize, name: *const ::std::os::raw::c_char,
                     type_: *const ::std::os::raw::c_char,
                     opts: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _mtx_destroy(c: *mut usize);
}
extern "C" {
    pub fn mtx_sysinit(arg: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _mtx_trylock_flags_int(m: *mut mtx, opts: ::std::os::raw::c_int,
                                  file: *const ::std::os::raw::c_char,
                                  line: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mtx_trylock_flags_(c: *mut usize, opts: ::std::os::raw::c_int,
                               file: *const ::std::os::raw::c_char,
                               line: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mutex_init();
}
extern "C" {
    pub fn __mtx_lock_sleep(c: *mut usize, v: usize,
                            opts: ::std::os::raw::c_int,
                            file: *const ::std::os::raw::c_char,
                            line: ::std::os::raw::c_int);
}
extern "C" {
    pub fn __mtx_unlock_sleep(c: *mut usize, v: usize,
                              opts: ::std::os::raw::c_int,
                              file: *const ::std::os::raw::c_char,
                              line: ::std::os::raw::c_int);
}
extern "C" {
    pub fn __mtx_lock_flags(c: *mut usize, opts: ::std::os::raw::c_int,
                            file: *const ::std::os::raw::c_char,
                            line: ::std::os::raw::c_int);
}
extern "C" {
    pub fn __mtx_unlock_flags(c: *mut usize, opts: ::std::os::raw::c_int,
                              file: *const ::std::os::raw::c_char,
                              line: ::std::os::raw::c_int);
}
extern "C" {
    pub fn __mtx_lock_spin_flags(c: *mut usize, opts: ::std::os::raw::c_int,
                                 file: *const ::std::os::raw::c_char,
                                 line: ::std::os::raw::c_int);
}
extern "C" {
    pub fn __mtx_trylock_spin_flags(c: *mut usize,
                                    opts: ::std::os::raw::c_int,
                                    file: *const ::std::os::raw::c_char,
                                    line: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __mtx_unlock_spin_flags(c: *mut usize, opts: ::std::os::raw::c_int,
                                   file: *const ::std::os::raw::c_char,
                                   line: ::std::os::raw::c_int);
}
extern "C" {
    pub fn thread_lock_flags_(arg1: *mut thread, arg2: ::std::os::raw::c_int,
                              arg3: *const ::std::os::raw::c_char,
                              arg4: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _thread_lock(td: *mut thread, opts: ::std::os::raw::c_int,
                        file: *const ::std::os::raw::c_char,
                        line: ::std::os::raw::c_int);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mtx_pool {
    _unused: [u8; 0],
}
extern "C" {
    pub fn mtx_pool_create(mtx_name: *const ::std::os::raw::c_char,
                           pool_size: ::std::os::raw::c_int,
                           opts: ::std::os::raw::c_int) -> *mut mtx_pool;
}
extern "C" {
    pub fn mtx_pool_destroy(poolp: *mut *mut mtx_pool);
}
extern "C" {
    pub fn mtx_pool_find(pool: *mut mtx_pool,
                         ptr: *mut ::std::os::raw::c_void) -> *mut mtx;
}
extern "C" {
    pub fn mtx_pool_alloc(pool: *mut mtx_pool) -> *mut mtx;
}
extern "C" {
    #[link_name = "mtxpool_sleep"]
    pub static mut mtxpool_sleep: *mut mtx_pool;
}
extern "C" {
    #[link_name = "Giant"]
    pub static mut Giant: mtx;
}
extern "C" {
    #[link_name = "blocked_lock"]
    pub static mut blocked_lock: mtx;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mtx_args {
    pub ma_mtx: *mut ::std::os::raw::c_void,
    pub ma_desc: *const ::std::os::raw::c_char,
    pub ma_opts: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_mtx_args() {
    assert_eq!(::std::mem::size_of::<mtx_args>() , 24usize , concat ! (
               "Size of: " , stringify ! ( mtx_args ) ));
    assert_eq! (::std::mem::align_of::<mtx_args>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( mtx_args ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mtx_args ) ) . ma_mtx as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mtx_args ) , "::" ,
                stringify ! ( ma_mtx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mtx_args ) ) . ma_desc as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mtx_args ) , "::" ,
                stringify ! ( ma_desc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mtx_args ) ) . ma_opts as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mtx_args ) , "::" ,
                stringify ! ( ma_opts ) ));
}
impl Clone for mtx_args {
    fn clone(&self) -> Self { *self }
}
impl Default for mtx_args {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rwlock {
    pub lock_object: lock_object,
    pub rw_lock: usize,
}
#[test]
fn bindgen_test_layout_rwlock() {
    assert_eq!(::std::mem::size_of::<rwlock>() , 32usize , concat ! (
               "Size of: " , stringify ! ( rwlock ) ));
    assert_eq! (::std::mem::align_of::<rwlock>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rwlock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rwlock ) ) . lock_object as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rwlock ) , "::" ,
                stringify ! ( lock_object ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rwlock ) ) . rw_lock as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rwlock ) , "::" ,
                stringify ! ( rw_lock ) ));
}
impl Clone for rwlock {
    fn clone(&self) -> Self { *self }
}
impl Default for rwlock {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct rwlock_padalign {
    pub lock_object: lock_object,
    pub rw_lock: usize,
    pub __bindgen_padding_0: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_rwlock_padalign() {
    assert_eq!(::std::mem::size_of::<rwlock_padalign>() , 64usize , concat ! (
               "Size of: " , stringify ! ( rwlock_padalign ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rwlock_padalign ) ) . lock_object as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rwlock_padalign ) ,
                "::" , stringify ! ( lock_object ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rwlock_padalign ) ) . rw_lock as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rwlock_padalign ) ,
                "::" , stringify ! ( rw_lock ) ));
}
impl Clone for rwlock_padalign {
    fn clone(&self) -> Self { *self }
}
impl Default for rwlock_padalign {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl ::std::fmt::Debug for rwlock_padalign {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f , "rwlock_padalign {{ lock_object: {:?}, rw_lock: {:?} }}" ,
               self . lock_object , self . rw_lock)
    }
}
extern "C" {
    pub fn _rw_init_flags(c: *mut usize, name: *const ::std::os::raw::c_char,
                          opts: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _rw_destroy(c: *mut usize);
}
extern "C" {
    pub fn rw_sysinit(arg: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn rw_sysinit_flags(arg: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _rw_wowned(c: *const usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _rw_wlock_cookie(c: *mut usize,
                            file: *const ::std::os::raw::c_char,
                            line: ::std::os::raw::c_int);
}
extern "C" {
    pub fn __rw_try_wlock_int(rw: *mut rwlock,
                              file: *const ::std::os::raw::c_char,
                              line: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __rw_try_wlock(c: *mut usize, file: *const ::std::os::raw::c_char,
                          line: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _rw_wunlock_cookie(c: *mut usize,
                              file: *const ::std::os::raw::c_char,
                              line: ::std::os::raw::c_int);
}
extern "C" {
    pub fn __rw_rlock_int(rw: *mut rwlock,
                          file: *const ::std::os::raw::c_char,
                          line: ::std::os::raw::c_int);
}
extern "C" {
    pub fn __rw_rlock(c: *mut usize, file: *const ::std::os::raw::c_char,
                      line: ::std::os::raw::c_int);
}
extern "C" {
    pub fn __rw_try_rlock_int(rw: *mut rwlock,
                              file: *const ::std::os::raw::c_char,
                              line: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __rw_try_rlock(c: *mut usize, file: *const ::std::os::raw::c_char,
                          line: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _rw_runlock_cookie_int(rw: *mut rwlock,
                                  file: *const ::std::os::raw::c_char,
                                  line: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _rw_runlock_cookie(c: *mut usize,
                              file: *const ::std::os::raw::c_char,
                              line: ::std::os::raw::c_int);
}
extern "C" {
    pub fn __rw_wlock_hard(c: *mut usize, v: usize,
                           file: *const ::std::os::raw::c_char,
                           line: ::std::os::raw::c_int);
}
extern "C" {
    pub fn __rw_wunlock_hard(c: *mut usize, v: usize,
                             file: *const ::std::os::raw::c_char,
                             line: ::std::os::raw::c_int);
}
extern "C" {
    pub fn __rw_try_upgrade_int(rw: *mut rwlock,
                                file: *const ::std::os::raw::c_char,
                                line: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __rw_try_upgrade(c: *mut usize,
                            file: *const ::std::os::raw::c_char,
                            line: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __rw_downgrade_int(rw: *mut rwlock,
                              file: *const ::std::os::raw::c_char,
                              line: ::std::os::raw::c_int);
}
extern "C" {
    pub fn __rw_downgrade(c: *mut usize, file: *const ::std::os::raw::c_char,
                          line: ::std::os::raw::c_int);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rw_args {
    pub ra_rw: *mut ::std::os::raw::c_void,
    pub ra_desc: *const ::std::os::raw::c_char,
    pub ra_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_rw_args() {
    assert_eq!(::std::mem::size_of::<rw_args>() , 24usize , concat ! (
               "Size of: " , stringify ! ( rw_args ) ));
    assert_eq! (::std::mem::align_of::<rw_args>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rw_args ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rw_args ) ) . ra_rw as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rw_args ) , "::" ,
                stringify ! ( ra_rw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rw_args ) ) . ra_desc as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rw_args ) , "::" ,
                stringify ! ( ra_desc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rw_args ) ) . ra_flags as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rw_args ) , "::" ,
                stringify ! ( ra_flags ) ));
}
impl Clone for rw_args {
    fn clone(&self) -> Self { *self }
}
impl Default for rw_args {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
extern "C" {
    pub fn sx_sysinit(arg: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn sx_init_flags(sx: *mut sx,
                         description: *const ::std::os::raw::c_char,
                         opts: ::std::os::raw::c_int);
}
extern "C" {
    pub fn sx_destroy(sx: *mut sx);
}
extern "C" {
    pub fn sx_try_slock_int(sx: *mut sx, file: *const ::std::os::raw::c_char,
                            line: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sx_try_slock_(sx: *mut sx, file: *const ::std::os::raw::c_char,
                         line: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sx_try_xlock_int(sx: *mut sx, file: *const ::std::os::raw::c_char,
                            line: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sx_try_xlock_(sx: *mut sx, file: *const ::std::os::raw::c_char,
                         line: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sx_try_upgrade_int(sx: *mut sx,
                              file: *const ::std::os::raw::c_char,
                              line: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sx_try_upgrade_(sx: *mut sx, file: *const ::std::os::raw::c_char,
                           line: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sx_downgrade_int(sx: *mut sx, file: *const ::std::os::raw::c_char,
                            line: ::std::os::raw::c_int);
}
extern "C" {
    pub fn sx_downgrade_(sx: *mut sx, file: *const ::std::os::raw::c_char,
                         line: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _sx_slock_int(sx: *mut sx, opts: ::std::os::raw::c_int,
                         file: *const ::std::os::raw::c_char,
                         line: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _sx_slock(sx: *mut sx, opts: ::std::os::raw::c_int,
                     file: *const ::std::os::raw::c_char,
                     line: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _sx_xlock(sx: *mut sx, opts: ::std::os::raw::c_int,
                     file: *const ::std::os::raw::c_char,
                     line: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _sx_sunlock_int(sx: *mut sx, file: *const ::std::os::raw::c_char,
                           line: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _sx_sunlock(sx: *mut sx, file: *const ::std::os::raw::c_char,
                       line: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _sx_xunlock(sx: *mut sx, file: *const ::std::os::raw::c_char,
                       line: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _sx_xlock_hard(sx: *mut sx, x: usize, opts: ::std::os::raw::c_int,
                          file: *const ::std::os::raw::c_char,
                          line: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _sx_xunlock_hard(sx: *mut sx, x: usize,
                            file: *const ::std::os::raw::c_char,
                            line: ::std::os::raw::c_int);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sx_args {
    pub sa_sx: *mut sx,
    pub sa_desc: *const ::std::os::raw::c_char,
    pub sa_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sx_args() {
    assert_eq!(::std::mem::size_of::<sx_args>() , 24usize , concat ! (
               "Size of: " , stringify ! ( sx_args ) ));
    assert_eq! (::std::mem::align_of::<sx_args>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sx_args ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sx_args ) ) . sa_sx as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sx_args ) , "::" ,
                stringify ! ( sa_sx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sx_args ) ) . sa_desc as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sx_args ) , "::" ,
                stringify ! ( sa_desc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sx_args ) ) . sa_flags as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( sx_args ) , "::" ,
                stringify ! ( sa_flags ) ));
}
impl Clone for sx_args {
    fn clone(&self) -> Self { *self }
}
impl Default for sx_args {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type task_fn_t =
    ::std::option::Option<unsafe extern "C" fn(context:
                                                   *mut ::std::os::raw::c_void,
                                               pending:
                                                   ::std::os::raw::c_int)>;
pub type gtask_fn_t =
    ::std::option::Option<unsafe extern "C" fn(context:
                                                   *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct task {
    pub ta_link: task__bindgen_ty_1,
    pub ta_pending: u16,
    pub ta_priority: u_short,
    pub ta_func: task_fn_t,
    pub ta_context: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct task__bindgen_ty_1 {
    pub stqe_next: *mut task,
}
#[test]
fn bindgen_test_layout_task__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<task__bindgen_ty_1>() , 8usize , concat !
               ( "Size of: " , stringify ! ( task__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<task__bindgen_ty_1>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( task__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const task__bindgen_ty_1 ) ) . stqe_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( task__bindgen_ty_1 ) ,
                "::" , stringify ! ( stqe_next ) ));
}
impl Clone for task__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for task__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_task() {
    assert_eq!(::std::mem::size_of::<task>() , 32usize , concat ! (
               "Size of: " , stringify ! ( task ) ));
    assert_eq! (::std::mem::align_of::<task>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( task ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const task ) ) . ta_link as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( task ) , "::" ,
                stringify ! ( ta_link ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const task ) ) . ta_pending as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( task ) , "::" ,
                stringify ! ( ta_pending ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const task ) ) . ta_priority as * const _ as
                usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( task ) , "::" ,
                stringify ! ( ta_priority ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const task ) ) . ta_func as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( task ) , "::" ,
                stringify ! ( ta_func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const task ) ) . ta_context as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( task ) , "::" ,
                stringify ! ( ta_context ) ));
}
impl Clone for task {
    fn clone(&self) -> Self { *self }
}
impl Default for task {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct gtask {
    pub ta_link: gtask__bindgen_ty_1,
    pub ta_flags: u16,
    pub ta_priority: u_short,
    pub ta_func: gtask_fn_t,
    pub ta_context: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct gtask__bindgen_ty_1 {
    pub stqe_next: *mut gtask,
}
#[test]
fn bindgen_test_layout_gtask__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<gtask__bindgen_ty_1>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( gtask__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<gtask__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( gtask__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gtask__bindgen_ty_1 ) ) . stqe_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( gtask__bindgen_ty_1 ) ,
                "::" , stringify ! ( stqe_next ) ));
}
impl Clone for gtask__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for gtask__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_gtask() {
    assert_eq!(::std::mem::size_of::<gtask>() , 32usize , concat ! (
               "Size of: " , stringify ! ( gtask ) ));
    assert_eq! (::std::mem::align_of::<gtask>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( gtask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gtask ) ) . ta_link as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( gtask ) , "::" ,
                stringify ! ( ta_link ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gtask ) ) . ta_flags as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( gtask ) , "::" ,
                stringify ! ( ta_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gtask ) ) . ta_priority as * const _ as
                usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( gtask ) , "::" ,
                stringify ! ( ta_priority ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gtask ) ) . ta_func as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( gtask ) , "::" ,
                stringify ! ( ta_func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gtask ) ) . ta_context as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( gtask ) , "::" ,
                stringify ! ( ta_context ) ));
}
impl Clone for gtask {
    fn clone(&self) -> Self { *self }
}
impl Default for gtask {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct grouptask {
    pub gt_task: gtask,
    pub gt_taskqueue: *mut ::std::os::raw::c_void,
    pub gt_list: grouptask__bindgen_ty_1,
    pub gt_uniq: *mut ::std::os::raw::c_void,
    pub gt_name: [::std::os::raw::c_char; 32usize],
    pub gt_irq: i16,
    pub gt_cpu: i16,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct grouptask__bindgen_ty_1 {
    pub le_next: *mut grouptask,
    pub le_prev: *mut *mut grouptask,
}
#[test]
fn bindgen_test_layout_grouptask__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<grouptask__bindgen_ty_1>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( grouptask__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<grouptask__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( grouptask__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const grouptask__bindgen_ty_1 ) ) . le_next as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( grouptask__bindgen_ty_1
                ) , "::" , stringify ! ( le_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const grouptask__bindgen_ty_1 ) ) . le_prev as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( grouptask__bindgen_ty_1
                ) , "::" , stringify ! ( le_prev ) ));
}
impl Clone for grouptask__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for grouptask__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_grouptask() {
    assert_eq!(::std::mem::size_of::<grouptask>() , 104usize , concat ! (
               "Size of: " , stringify ! ( grouptask ) ));
    assert_eq! (::std::mem::align_of::<grouptask>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( grouptask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const grouptask ) ) . gt_task as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( grouptask ) , "::" ,
                stringify ! ( gt_task ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const grouptask ) ) . gt_taskqueue as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( grouptask ) , "::" ,
                stringify ! ( gt_taskqueue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const grouptask ) ) . gt_list as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( grouptask ) , "::" ,
                stringify ! ( gt_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const grouptask ) ) . gt_uniq as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( grouptask ) , "::" ,
                stringify ! ( gt_uniq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const grouptask ) ) . gt_name as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( grouptask ) , "::" ,
                stringify ! ( gt_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const grouptask ) ) . gt_irq as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( grouptask ) , "::" ,
                stringify ! ( gt_irq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const grouptask ) ) . gt_cpu as * const _ as
                usize } , 98usize , concat ! (
                "Alignment of field: " , stringify ! ( grouptask ) , "::" ,
                stringify ! ( gt_cpu ) ));
}
impl Clone for grouptask {
    fn clone(&self) -> Self { *self }
}
impl Default for grouptask {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct kevent {
    pub ident: __uintptr_t,
    pub filter: ::std::os::raw::c_short,
    pub flags: ::std::os::raw::c_ushort,
    pub fflags: ::std::os::raw::c_uint,
    pub data: __int64_t,
    pub udata: *mut ::std::os::raw::c_void,
    pub ext: [__uint64_t; 4usize],
}
#[test]
fn bindgen_test_layout_kevent() {
    assert_eq!(::std::mem::size_of::<kevent>() , 64usize , concat ! (
               "Size of: " , stringify ! ( kevent ) ));
    assert_eq! (::std::mem::align_of::<kevent>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kevent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kevent ) ) . ident as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kevent ) , "::" ,
                stringify ! ( ident ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kevent ) ) . filter as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kevent ) , "::" ,
                stringify ! ( filter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kevent ) ) . flags as * const _ as usize
                } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( kevent ) , "::" ,
                stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kevent ) ) . fflags as * const _ as usize
                } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( kevent ) , "::" ,
                stringify ! ( fflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kevent ) ) . data as * const _ as usize }
                , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( kevent ) , "::" ,
                stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kevent ) ) . udata as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( kevent ) , "::" ,
                stringify ! ( udata ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kevent ) ) . ext as * const _ as usize }
                , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( kevent ) , "::" ,
                stringify ! ( ext ) ));
}
impl Clone for kevent {
    fn clone(&self) -> Self { *self }
}
impl Default for kevent {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kevent32 {
    pub ident: u32,
    pub filter: ::std::os::raw::c_short,
    pub flags: u_short,
    pub fflags: u_int,
    pub data1: i32,
    pub data2: i32,
    pub udata: u32,
    pub ext64: [u32; 8usize],
}
#[test]
fn bindgen_test_layout_kevent32() {
    assert_eq!(::std::mem::size_of::<kevent32>() , 56usize , concat ! (
               "Size of: " , stringify ! ( kevent32 ) ));
    assert_eq! (::std::mem::align_of::<kevent32>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( kevent32 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kevent32 ) ) . ident as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kevent32 ) , "::" ,
                stringify ! ( ident ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kevent32 ) ) . filter as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kevent32 ) , "::" ,
                stringify ! ( filter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kevent32 ) ) . flags as * const _ as
                usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( kevent32 ) , "::" ,
                stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kevent32 ) ) . fflags as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kevent32 ) , "::" ,
                stringify ! ( fflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kevent32 ) ) . data1 as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( kevent32 ) , "::" ,
                stringify ! ( data1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kevent32 ) ) . data2 as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( kevent32 ) , "::" ,
                stringify ! ( data2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kevent32 ) ) . udata as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( kevent32 ) , "::" ,
                stringify ! ( udata ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kevent32 ) ) . ext64 as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( kevent32 ) , "::" ,
                stringify ! ( ext64 ) ));
}
impl Clone for kevent32 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct knote {
    pub kn_link: knote__bindgen_ty_1,
    pub kn_selnext: knote__bindgen_ty_2,
    pub kn_knlist: *mut knlist,
    pub kn_tqe: knote__bindgen_ty_3,
    pub kn_kq: *mut kqueue,
    pub kn_kevent: kevent,
    pub kn_hook: *mut ::std::os::raw::c_void,
    pub kn_hookid: ::std::os::raw::c_int,
    pub kn_status: ::std::os::raw::c_int,
    pub kn_influx: ::std::os::raw::c_int,
    pub kn_sfflags: ::std::os::raw::c_int,
    pub kn_sdata: i64,
    pub kn_ptr: knote__bindgen_ty_4,
    pub kn_fop: *mut filterops,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct knote__bindgen_ty_1 {
    pub sle_next: *mut knote,
}
#[test]
fn bindgen_test_layout_knote__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<knote__bindgen_ty_1>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( knote__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<knote__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( knote__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote__bindgen_ty_1 ) ) . sle_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( knote__bindgen_ty_1 ) ,
                "::" , stringify ! ( sle_next ) ));
}
impl Clone for knote__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for knote__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct knote__bindgen_ty_2 {
    pub sle_next: *mut knote,
}
#[test]
fn bindgen_test_layout_knote__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<knote__bindgen_ty_2>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( knote__bindgen_ty_2 ) ));
    assert_eq! (::std::mem::align_of::<knote__bindgen_ty_2>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( knote__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote__bindgen_ty_2 ) ) . sle_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( knote__bindgen_ty_2 ) ,
                "::" , stringify ! ( sle_next ) ));
}
impl Clone for knote__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for knote__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct knote__bindgen_ty_3 {
    pub tqe_next: *mut knote,
    pub tqe_prev: *mut *mut knote,
}
#[test]
fn bindgen_test_layout_knote__bindgen_ty_3() {
    assert_eq!(::std::mem::size_of::<knote__bindgen_ty_3>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( knote__bindgen_ty_3 ) ));
    assert_eq! (::std::mem::align_of::<knote__bindgen_ty_3>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( knote__bindgen_ty_3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote__bindgen_ty_3 ) ) . tqe_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( knote__bindgen_ty_3 ) ,
                "::" , stringify ! ( tqe_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote__bindgen_ty_3 ) ) . tqe_prev as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( knote__bindgen_ty_3 ) ,
                "::" , stringify ! ( tqe_prev ) ));
}
impl Clone for knote__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
impl Default for knote__bindgen_ty_3 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub union knote__bindgen_ty_4 {
    pub p_fp: *mut file,
    pub p_proc: *mut proc_,
    pub p_aio: *mut kaiocb,
    pub p_lio: *mut aioliojob,
    pub p_v: *mut ::std::os::raw::c_void,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_knote__bindgen_ty_4() {
    assert_eq!(::std::mem::size_of::<knote__bindgen_ty_4>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( knote__bindgen_ty_4 ) ));
    assert_eq! (::std::mem::align_of::<knote__bindgen_ty_4>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( knote__bindgen_ty_4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote__bindgen_ty_4 ) ) . p_fp as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( knote__bindgen_ty_4 ) ,
                "::" , stringify ! ( p_fp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote__bindgen_ty_4 ) ) . p_proc as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( knote__bindgen_ty_4 ) ,
                "::" , stringify ! ( p_proc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote__bindgen_ty_4 ) ) . p_aio as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( knote__bindgen_ty_4 ) ,
                "::" , stringify ! ( p_aio ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote__bindgen_ty_4 ) ) . p_lio as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( knote__bindgen_ty_4 ) ,
                "::" , stringify ! ( p_lio ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote__bindgen_ty_4 ) ) . p_v as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( knote__bindgen_ty_4 ) ,
                "::" , stringify ! ( p_v ) ));
}
impl Clone for knote__bindgen_ty_4 {
    fn clone(&self) -> Self { *self }
}
impl Default for knote__bindgen_ty_4 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl ::std::fmt::Debug for knote__bindgen_ty_4 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f , "knote__bindgen_ty_4 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_knote() {
    assert_eq!(::std::mem::size_of::<knote>() , 160usize , concat ! (
               "Size of: " , stringify ! ( knote ) ));
    assert_eq! (::std::mem::align_of::<knote>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( knote ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote ) ) . kn_link as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( knote ) , "::" ,
                stringify ! ( kn_link ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote ) ) . kn_selnext as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( knote ) , "::" ,
                stringify ! ( kn_selnext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote ) ) . kn_knlist as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( knote ) , "::" ,
                stringify ! ( kn_knlist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote ) ) . kn_tqe as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( knote ) , "::" ,
                stringify ! ( kn_tqe ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote ) ) . kn_kq as * const _ as usize }
                , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( knote ) , "::" ,
                stringify ! ( kn_kq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote ) ) . kn_kevent as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( knote ) , "::" ,
                stringify ! ( kn_kevent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote ) ) . kn_hook as * const _ as usize
                } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( knote ) , "::" ,
                stringify ! ( kn_hook ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote ) ) . kn_hookid as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( knote ) , "::" ,
                stringify ! ( kn_hookid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote ) ) . kn_status as * const _ as
                usize } , 124usize , concat ! (
                "Alignment of field: " , stringify ! ( knote ) , "::" ,
                stringify ! ( kn_status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote ) ) . kn_influx as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( knote ) , "::" ,
                stringify ! ( kn_influx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote ) ) . kn_sfflags as * const _ as
                usize } , 132usize , concat ! (
                "Alignment of field: " , stringify ! ( knote ) , "::" ,
                stringify ! ( kn_sfflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote ) ) . kn_sdata as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( knote ) , "::" ,
                stringify ! ( kn_sdata ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote ) ) . kn_ptr as * const _ as usize
                } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( knote ) , "::" ,
                stringify ! ( kn_ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote ) ) . kn_fop as * const _ as usize
                } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( knote ) , "::" ,
                stringify ! ( kn_fop ) ));
}
impl Clone for knote {
    fn clone(&self) -> Self { *self }
}
impl Default for knote {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl ::std::fmt::Debug for knote {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f ,
               "knote {{ kn_link: {:?}, kn_selnext: {:?}, kn_knlist: {:?}, kn_tqe: {:?}, kn_kq: {:?}, kn_kevent: {:?}, kn_hook: {:?}, kn_hookid: {:?}, kn_status: {:?}, kn_influx: {:?}, kn_sfflags: {:?}, kn_sdata: {:?}, kn_ptr: {:?}, kn_fop: {:?} }}"
               , self . kn_link , self . kn_selnext , self . kn_knlist , self
               . kn_tqe , self . kn_kq , self . kn_kevent , self . kn_hook ,
               self . kn_hookid , self . kn_status , self . kn_influx , self .
               kn_sfflags , self . kn_sdata , self . kn_ptr , self . kn_fop)
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct klist {
    pub slh_first: *mut knote,
}
#[test]
fn bindgen_test_layout_klist() {
    assert_eq!(::std::mem::size_of::<klist>() , 8usize , concat ! (
               "Size of: " , stringify ! ( klist ) ));
    assert_eq! (::std::mem::align_of::<klist>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( klist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const klist ) ) . slh_first as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( klist ) , "::" ,
                stringify ! ( slh_first ) ));
}
impl Clone for klist {
    fn clone(&self) -> Self { *self }
}
impl Default for klist {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kqueue {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct kqlist {
    pub tqh_first: *mut kqueue,
    pub tqh_last: *mut *mut kqueue,
}
#[test]
fn bindgen_test_layout_kqlist() {
    assert_eq!(::std::mem::size_of::<kqlist>() , 16usize , concat ! (
               "Size of: " , stringify ! ( kqlist ) ));
    assert_eq! (::std::mem::align_of::<kqlist>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kqlist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kqlist ) ) . tqh_first as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kqlist ) , "::" ,
                stringify ! ( tqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kqlist ) ) . tqh_last as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kqlist ) , "::" ,
                stringify ! ( tqh_last ) ));
}
impl Clone for kqlist {
    fn clone(&self) -> Self { *self }
}
impl Default for kqlist {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct knlist {
    pub kl_list: klist,
    pub kl_lock: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                *mut ::std::os::raw::c_void)>,
    pub kl_unlock: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                  *mut ::std::os::raw::c_void)>,
    pub kl_assert_locked: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                         *mut ::std::os::raw::c_void)>,
    pub kl_assert_unlocked: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                           *mut ::std::os::raw::c_void)>,
    pub kl_lockarg: *mut ::std::os::raw::c_void,
    pub kl_autodestroy: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_knlist() {
    assert_eq!(::std::mem::size_of::<knlist>() , 56usize , concat ! (
               "Size of: " , stringify ! ( knlist ) ));
    assert_eq! (::std::mem::align_of::<knlist>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( knlist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knlist ) ) . kl_list as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( knlist ) , "::" ,
                stringify ! ( kl_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knlist ) ) . kl_lock as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( knlist ) , "::" ,
                stringify ! ( kl_lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knlist ) ) . kl_unlock as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( knlist ) , "::" ,
                stringify ! ( kl_unlock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knlist ) ) . kl_assert_locked as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( knlist ) , "::" ,
                stringify ! ( kl_assert_locked ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knlist ) ) . kl_assert_unlocked as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( knlist ) , "::" ,
                stringify ! ( kl_assert_unlocked ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knlist ) ) . kl_lockarg as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( knlist ) , "::" ,
                stringify ! ( kl_lockarg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knlist ) ) . kl_autodestroy as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( knlist ) , "::" ,
                stringify ! ( kl_autodestroy ) ));
}
impl Clone for knlist {
    fn clone(&self) -> Self { *self }
}
impl Default for knlist {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct filterops {
    pub f_isfd: ::std::os::raw::c_int,
    pub f_attach: ::std::option::Option<unsafe extern "C" fn(kn: *mut knote)
                                            -> ::std::os::raw::c_int>,
    pub f_detach: ::std::option::Option<unsafe extern "C" fn(kn: *mut knote)>,
    pub f_event: ::std::option::Option<unsafe extern "C" fn(kn: *mut knote,
                                                            hint:
                                                                ::std::os::raw::c_long)
                                           -> ::std::os::raw::c_int>,
    pub f_touch: ::std::option::Option<unsafe extern "C" fn(kn: *mut knote,
                                                            kev: *mut kevent,
                                                            type_: u_long)>,
}
#[test]
fn bindgen_test_layout_filterops() {
    assert_eq!(::std::mem::size_of::<filterops>() , 40usize , concat ! (
               "Size of: " , stringify ! ( filterops ) ));
    assert_eq! (::std::mem::align_of::<filterops>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( filterops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const filterops ) ) . f_isfd as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( filterops ) , "::" ,
                stringify ! ( f_isfd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const filterops ) ) . f_attach as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( filterops ) , "::" ,
                stringify ! ( f_attach ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const filterops ) ) . f_detach as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( filterops ) , "::" ,
                stringify ! ( f_detach ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const filterops ) ) . f_event as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( filterops ) , "::" ,
                stringify ! ( f_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const filterops ) ) . f_touch as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( filterops ) , "::" ,
                stringify ! ( f_touch ) ));
}
impl Clone for filterops {
    fn clone(&self) -> Self { *self }
}
impl Default for filterops {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct kevent_copyops {
    pub arg: *mut ::std::os::raw::c_void,
    pub k_copyout: ::std::option::Option<unsafe extern "C" fn(arg:
                                                                  *mut ::std::os::raw::c_void,
                                                              kevp:
                                                                  *mut kevent,
                                                              count:
                                                                  ::std::os::raw::c_int)
                                             -> ::std::os::raw::c_int>,
    pub k_copyin: ::std::option::Option<unsafe extern "C" fn(arg:
                                                                 *mut ::std::os::raw::c_void,
                                                             kevp:
                                                                 *mut kevent,
                                                             count:
                                                                 ::std::os::raw::c_int)
                                            -> ::std::os::raw::c_int>,
    pub kevent_size: usize,
}
#[test]
fn bindgen_test_layout_kevent_copyops() {
    assert_eq!(::std::mem::size_of::<kevent_copyops>() , 32usize , concat ! (
               "Size of: " , stringify ! ( kevent_copyops ) ));
    assert_eq! (::std::mem::align_of::<kevent_copyops>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kevent_copyops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kevent_copyops ) ) . arg as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kevent_copyops ) , "::"
                , stringify ! ( arg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kevent_copyops ) ) . k_copyout as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kevent_copyops ) , "::"
                , stringify ! ( k_copyout ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kevent_copyops ) ) . k_copyin as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( kevent_copyops ) , "::"
                , stringify ! ( k_copyin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kevent_copyops ) ) . kevent_size as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( kevent_copyops ) , "::"
                , stringify ! ( kevent_size ) ));
}
impl Clone for kevent_copyops {
    fn clone(&self) -> Self { *self }
}
impl Default for kevent_copyops {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
extern "C" {
    pub fn knote(list: *mut knlist, hint: ::std::os::raw::c_long,
                 lockflags: ::std::os::raw::c_int);
}
extern "C" {
    pub fn knote_fork(list: *mut knlist, pid: ::std::os::raw::c_int);
}
extern "C" {
    pub fn knlist_alloc(lock: *mut mtx) -> *mut knlist;
}
extern "C" {
    pub fn knlist_detach(knl: *mut knlist);
}
extern "C" {
    pub fn knlist_add(knl: *mut knlist, kn: *mut knote,
                      islocked: ::std::os::raw::c_int);
}
extern "C" {
    pub fn knlist_remove(knl: *mut knlist, kn: *mut knote,
                         islocked: ::std::os::raw::c_int);
}
extern "C" {
    pub fn knlist_empty(knl: *mut knlist) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn knlist_init(knl: *mut knlist, lock: *mut ::std::os::raw::c_void,
                       kl_lock:
                           ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                          *mut ::std::os::raw::c_void)>,
                       kl_unlock:
                           ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                          *mut ::std::os::raw::c_void)>,
                       kl_assert_locked:
                           ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                          *mut ::std::os::raw::c_void)>,
                       kl_assert_unlocked:
                           ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                          *mut ::std::os::raw::c_void)>);
}
extern "C" {
    pub fn knlist_init_mtx(knl: *mut knlist, lock: *mut mtx);
}
extern "C" {
    pub fn knlist_init_rw_reader(knl: *mut knlist, lock: *mut rwlock);
}
extern "C" {
    pub fn knlist_destroy(knl: *mut knlist);
}
extern "C" {
    pub fn knlist_cleardel(knl: *mut knlist, td: *mut thread,
                           islocked: ::std::os::raw::c_int,
                           killkn: ::std::os::raw::c_int);
}
extern "C" {
    pub fn knote_fdclose(p: *mut thread, fd: ::std::os::raw::c_int);
}
extern "C" {
    pub fn kqfd_register(fd: ::std::os::raw::c_int, kev: *mut kevent,
                         p: *mut thread, waitok: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kqueue_add_filteropts(filt: ::std::os::raw::c_int,
                                 filtops: *mut filterops)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn kqueue_del_filteropts(filt: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct altq_pktattr {
    pub pattr_class: *mut ::std::os::raw::c_void,
    pub pattr_af: ::std::os::raw::c_int,
    pub pattr_hdr: caddr_t,
}
#[test]
fn bindgen_test_layout_altq_pktattr() {
    assert_eq!(::std::mem::size_of::<altq_pktattr>() , 24usize , concat ! (
               "Size of: " , stringify ! ( altq_pktattr ) ));
    assert_eq! (::std::mem::align_of::<altq_pktattr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( altq_pktattr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const altq_pktattr ) ) . pattr_class as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( altq_pktattr ) , "::" ,
                stringify ! ( pattr_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const altq_pktattr ) ) . pattr_af as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( altq_pktattr ) , "::" ,
                stringify ! ( pattr_af ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const altq_pktattr ) ) . pattr_hdr as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( altq_pktattr ) , "::" ,
                stringify ! ( pattr_hdr ) ));
}
impl Clone for altq_pktattr {
    fn clone(&self) -> Self { *self }
}
impl Default for altq_pktattr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct tb_regulator {
    pub tbr_rate: i64,
    pub tbr_depth: i64,
    pub tbr_token: i64,
    pub tbr_filluptime: i64,
    pub tbr_last: u_int64_t,
    pub tbr_lastop: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_tb_regulator() {
    assert_eq!(::std::mem::size_of::<tb_regulator>() , 48usize , concat ! (
               "Size of: " , stringify ! ( tb_regulator ) ));
    assert_eq! (::std::mem::align_of::<tb_regulator>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( tb_regulator ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tb_regulator ) ) . tbr_rate as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tb_regulator ) , "::" ,
                stringify ! ( tbr_rate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tb_regulator ) ) . tbr_depth as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tb_regulator ) , "::" ,
                stringify ! ( tbr_depth ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tb_regulator ) ) . tbr_token as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( tb_regulator ) , "::" ,
                stringify ! ( tbr_token ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tb_regulator ) ) . tbr_filluptime as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( tb_regulator ) , "::" ,
                stringify ! ( tbr_filluptime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tb_regulator ) ) . tbr_last as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( tb_regulator ) , "::" ,
                stringify ! ( tbr_last ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tb_regulator ) ) . tbr_lastop as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( tb_regulator ) , "::" ,
                stringify ! ( tbr_lastop ) ));
}
impl Clone for tb_regulator {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct top_cdnr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifaltq {
    pub ifq_head: *mut mbuf,
    pub ifq_tail: *mut mbuf,
    pub ifq_len: ::std::os::raw::c_int,
    pub ifq_maxlen: ::std::os::raw::c_int,
    pub ifq_mtx: mtx,
    pub ifq_drv_head: *mut mbuf,
    pub ifq_drv_tail: *mut mbuf,
    pub ifq_drv_len: ::std::os::raw::c_int,
    pub ifq_drv_maxlen: ::std::os::raw::c_int,
    pub altq_type: ::std::os::raw::c_int,
    pub altq_flags: ::std::os::raw::c_int,
    pub altq_disc: *mut ::std::os::raw::c_void,
    pub altq_ifp: *mut ifnet,
    pub altq_enqueue: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                     *mut ifaltq,
                                                                 arg2:
                                                                     *mut mbuf,
                                                                 arg3:
                                                                     *mut altq_pktattr)
                                                -> ::std::os::raw::c_int>,
    pub altq_dequeue: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                     *mut ifaltq,
                                                                 arg2:
                                                                     ::std::os::raw::c_int)
                                                -> *mut mbuf>,
    pub altq_request: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                     *mut ifaltq,
                                                                 arg2:
                                                                     ::std::os::raw::c_int,
                                                                 arg3:
                                                                     *mut ::std::os::raw::c_void)
                                                -> ::std::os::raw::c_int>,
    pub altq_clfier: *mut ::std::os::raw::c_void,
    pub altq_classify: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ::std::os::raw::c_void,
                                                                  arg2:
                                                                      *mut mbuf,
                                                                  arg3:
                                                                      ::std::os::raw::c_int)
                                                 ->
                                                     *mut ::std::os::raw::c_void>,
    pub altq_tbr: *mut tb_regulator,
    pub altq_cdnr: *mut top_cdnr,
}
#[test]
fn bindgen_test_layout_ifaltq() {
    assert_eq!(::std::mem::size_of::<ifaltq>() , 160usize , concat ! (
               "Size of: " , stringify ! ( ifaltq ) ));
    assert_eq! (::std::mem::align_of::<ifaltq>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ifaltq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaltq ) ) . ifq_head as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaltq ) , "::" ,
                stringify ! ( ifq_head ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaltq ) ) . ifq_tail as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaltq ) , "::" ,
                stringify ! ( ifq_tail ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaltq ) ) . ifq_len as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaltq ) , "::" ,
                stringify ! ( ifq_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaltq ) ) . ifq_maxlen as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaltq ) , "::" ,
                stringify ! ( ifq_maxlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaltq ) ) . ifq_mtx as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaltq ) , "::" ,
                stringify ! ( ifq_mtx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaltq ) ) . ifq_drv_head as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaltq ) , "::" ,
                stringify ! ( ifq_drv_head ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaltq ) ) . ifq_drv_tail as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaltq ) , "::" ,
                stringify ! ( ifq_drv_tail ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaltq ) ) . ifq_drv_len as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaltq ) , "::" ,
                stringify ! ( ifq_drv_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaltq ) ) . ifq_drv_maxlen as * const _
                as usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaltq ) , "::" ,
                stringify ! ( ifq_drv_maxlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaltq ) ) . altq_type as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaltq ) , "::" ,
                stringify ! ( altq_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaltq ) ) . altq_flags as * const _ as
                usize } , 84usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaltq ) , "::" ,
                stringify ! ( altq_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaltq ) ) . altq_disc as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaltq ) , "::" ,
                stringify ! ( altq_disc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaltq ) ) . altq_ifp as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaltq ) , "::" ,
                stringify ! ( altq_ifp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaltq ) ) . altq_enqueue as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaltq ) , "::" ,
                stringify ! ( altq_enqueue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaltq ) ) . altq_dequeue as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaltq ) , "::" ,
                stringify ! ( altq_dequeue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaltq ) ) . altq_request as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaltq ) , "::" ,
                stringify ! ( altq_request ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaltq ) ) . altq_clfier as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaltq ) , "::" ,
                stringify ! ( altq_clfier ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaltq ) ) . altq_classify as * const _
                as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaltq ) , "::" ,
                stringify ! ( altq_classify ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaltq ) ) . altq_tbr as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaltq ) , "::" ,
                stringify ! ( altq_tbr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaltq ) ) . altq_cdnr as * const _ as
                usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaltq ) , "::" ,
                stringify ! ( altq_cdnr ) ));
}
impl Clone for ifaltq {
    fn clone(&self) -> Self { *self }
}
impl Default for ifaltq {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct altq_tag {
    pub qid: u_int32_t,
    pub af: ::std::os::raw::c_int,
    pub hdr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_altq_tag() {
    assert_eq!(::std::mem::size_of::<altq_tag>() , 16usize , concat ! (
               "Size of: " , stringify ! ( altq_tag ) ));
    assert_eq! (::std::mem::align_of::<altq_tag>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( altq_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const altq_tag ) ) . qid as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( altq_tag ) , "::" ,
                stringify ! ( qid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const altq_tag ) ) . af as * const _ as usize }
                , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( altq_tag ) , "::" ,
                stringify ! ( af ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const altq_tag ) ) . hdr as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( altq_tag ) , "::" ,
                stringify ! ( hdr ) ));
}
impl Clone for altq_tag {
    fn clone(&self) -> Self { *self }
}
impl Default for altq_tag {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
extern "C" {
    pub fn altq_attach(arg1: *mut ifaltq, arg2: ::std::os::raw::c_int,
                       arg3: *mut ::std::os::raw::c_void,
                       arg4:
                           ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                          *mut ifaltq,
                                                                      arg2:
                                                                          *mut mbuf,
                                                                      arg3:
                                                                          *mut altq_pktattr)
                                                     ->
                                                         ::std::os::raw::c_int>,
                       arg5:
                           ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                          *mut ifaltq,
                                                                      arg2:
                                                                          ::std::os::raw::c_int)
                                                     -> *mut mbuf>,
                       arg6:
                           ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                          *mut ifaltq,
                                                                      arg2:
                                                                          ::std::os::raw::c_int,
                                                                      arg3:
                                                                          *mut ::std::os::raw::c_void)
                                                     ->
                                                         ::std::os::raw::c_int>,
                       arg7: *mut ::std::os::raw::c_void,
                       arg8:
                           ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                          *mut ::std::os::raw::c_void,
                                                                      arg2:
                                                                          *mut mbuf,
                                                                      arg3:
                                                                          ::std::os::raw::c_int)
                                                     ->
                                                         *mut ::std::os::raw::c_void>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn altq_detach(arg1: *mut ifaltq) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn altq_enable(arg1: *mut ifaltq) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn altq_disable(arg1: *mut ifaltq) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "tbr_dequeue_ptr"]
    pub static mut tbr_dequeue_ptr:
               ::std::option::Option<unsafe extern "C" fn(arg1: *mut ifaltq,
                                                          arg2:
                                                              ::std::os::raw::c_int)
                                         -> *mut mbuf>;
}
extern "C" {
    #[link_name = "altq_input"]
    pub static mut altq_input:
               ::std::option::Option<unsafe extern "C" fn(arg1: *mut mbuf,
                                                          arg2:
                                                              ::std::os::raw::c_int)
                                         -> ::std::os::raw::c_int>;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifnethead {
    pub tqh_first: *mut ifnet,
    pub tqh_last: *mut *mut ifnet,
}
#[test]
fn bindgen_test_layout_ifnethead() {
    assert_eq!(::std::mem::size_of::<ifnethead>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ifnethead ) ));
    assert_eq! (::std::mem::align_of::<ifnethead>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ifnethead ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnethead ) ) . tqh_first as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnethead ) , "::" ,
                stringify ! ( tqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnethead ) ) . tqh_last as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnethead ) , "::" ,
                stringify ! ( tqh_last ) ));
}
impl Clone for ifnethead {
    fn clone(&self) -> Self { *self }
}
impl Default for ifnethead {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifaddrhead {
    pub tqh_first: *mut ifaddr,
    pub tqh_last: *mut *mut ifaddr,
}
#[test]
fn bindgen_test_layout_ifaddrhead() {
    assert_eq!(::std::mem::size_of::<ifaddrhead>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ifaddrhead ) ));
    assert_eq! (::std::mem::align_of::<ifaddrhead>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ifaddrhead ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaddrhead ) ) . tqh_first as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaddrhead ) , "::" ,
                stringify ! ( tqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaddrhead ) ) . tqh_last as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaddrhead ) , "::" ,
                stringify ! ( tqh_last ) ));
}
impl Clone for ifaddrhead {
    fn clone(&self) -> Self { *self }
}
impl Default for ifaddrhead {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifmultihead {
    pub tqh_first: *mut ifmultiaddr,
    pub tqh_last: *mut *mut ifmultiaddr,
}
#[test]
fn bindgen_test_layout_ifmultihead() {
    assert_eq!(::std::mem::size_of::<ifmultihead>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ifmultihead ) ));
    assert_eq! (::std::mem::align_of::<ifmultihead>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ifmultihead ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmultihead ) ) . tqh_first as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmultihead ) , "::" ,
                stringify ! ( tqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmultihead ) ) . tqh_last as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmultihead ) , "::" ,
                stringify ! ( tqh_last ) ));
}
impl Clone for ifmultihead {
    fn clone(&self) -> Self { *self }
}
impl Default for ifmultihead {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifgrouphead {
    pub tqh_first: *mut ifg_group,
    pub tqh_last: *mut *mut ifg_group,
}
#[test]
fn bindgen_test_layout_ifgrouphead() {
    assert_eq!(::std::mem::size_of::<ifgrouphead>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ifgrouphead ) ));
    assert_eq! (::std::mem::align_of::<ifgrouphead>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ifgrouphead ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifgrouphead ) ) . tqh_first as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifgrouphead ) , "::" ,
                stringify ! ( tqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifgrouphead ) ) . tqh_last as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifgrouphead ) , "::" ,
                stringify ! ( tqh_last ) ));
}
impl Clone for ifgrouphead {
    fn clone(&self) -> Self { *self }
}
impl Default for ifgrouphead {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pfil_head {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "link_pfil_hook"]
    pub static mut link_pfil_hook: pfil_head;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hhook_head {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "ipsec_hhh_in"]
    pub static mut ipsec_hhh_in: [*mut hhook_head; 2usize];
}
extern "C" {
    #[link_name = "ipsec_hhh_out"]
    pub static mut ipsec_hhh_out: [*mut hhook_head; 2usize];
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ift_counter {
    IFCOUNTER_IPACKETS = 0,
    IFCOUNTER_IERRORS = 1,
    IFCOUNTER_OPACKETS = 2,
    IFCOUNTER_OERRORS = 3,
    IFCOUNTER_COLLISIONS = 4,
    IFCOUNTER_IBYTES = 5,
    IFCOUNTER_OBYTES = 6,
    IFCOUNTER_IMCASTS = 7,
    IFCOUNTER_OMCASTS = 8,
    IFCOUNTER_IQDROPS = 9,
    IFCOUNTER_OQDROPS = 10,
    IFCOUNTER_NOPROTO = 11,
    IFCOUNTERS = 12,
}
pub type if_t = *mut ifnet;
pub type if_start_fn_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: if_t)>;
pub type if_ioctl_fn_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: if_t, arg2: u_long,
                                               arg3: caddr_t)
                              -> ::std::os::raw::c_int>;
pub type if_init_fn_t =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void)>;
pub type if_qflush_fn_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: if_t)>;
pub type if_transmit_fn_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: if_t, arg2: *mut mbuf)
                              -> ::std::os::raw::c_int>;
pub type if_get_counter_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: if_t, arg2: ift_counter)
                              -> u64>;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct ifnet_hw_tsomax {
    pub tsomaxbytes: u_int,
    pub tsomaxsegcount: u_int,
    pub tsomaxsegsize: u_int,
}
#[test]
fn bindgen_test_layout_ifnet_hw_tsomax() {
    assert_eq!(::std::mem::size_of::<ifnet_hw_tsomax>() , 12usize , concat ! (
               "Size of: " , stringify ! ( ifnet_hw_tsomax ) ));
    assert_eq! (::std::mem::align_of::<ifnet_hw_tsomax>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( ifnet_hw_tsomax ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet_hw_tsomax ) ) . tsomaxbytes as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet_hw_tsomax ) ,
                "::" , stringify ! ( tsomaxbytes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet_hw_tsomax ) ) . tsomaxsegcount as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet_hw_tsomax ) ,
                "::" , stringify ! ( tsomaxsegcount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet_hw_tsomax ) ) . tsomaxsegsize as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet_hw_tsomax ) ,
                "::" , stringify ! ( tsomaxsegsize ) ));
}
impl Clone for ifnet_hw_tsomax {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ife_type { IFENCAP_LL = 1, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct if_encap_req {
    pub buf: *mut u_char,
    pub bufsize: usize,
    pub rtype: ife_type,
    pub flags: u32,
    pub family: ::std::os::raw::c_int,
    pub lladdr_off: ::std::os::raw::c_int,
    pub lladdr_len: ::std::os::raw::c_int,
    pub lladdr: *mut ::std::os::raw::c_char,
    pub hdata: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_if_encap_req() {
    assert_eq!(::std::mem::size_of::<if_encap_req>() , 56usize , concat ! (
               "Size of: " , stringify ! ( if_encap_req ) ));
    assert_eq! (::std::mem::align_of::<if_encap_req>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( if_encap_req ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_encap_req ) ) . buf as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_encap_req ) , "::" ,
                stringify ! ( buf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_encap_req ) ) . bufsize as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( if_encap_req ) , "::" ,
                stringify ! ( bufsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_encap_req ) ) . rtype as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( if_encap_req ) , "::" ,
                stringify ! ( rtype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_encap_req ) ) . flags as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( if_encap_req ) , "::" ,
                stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_encap_req ) ) . family as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( if_encap_req ) , "::" ,
                stringify ! ( family ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_encap_req ) ) . lladdr_off as * const
                _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( if_encap_req ) , "::" ,
                stringify ! ( lladdr_off ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_encap_req ) ) . lladdr_len as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( if_encap_req ) , "::" ,
                stringify ! ( lladdr_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_encap_req ) ) . lladdr as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( if_encap_req ) , "::" ,
                stringify ! ( lladdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_encap_req ) ) . hdata as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( if_encap_req ) , "::" ,
                stringify ! ( hdata ) ));
}
impl Clone for if_encap_req {
    fn clone(&self) -> Self { *self }
}
impl Default for if_encap_req {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct if_snd_tag_alloc_header {
    pub type_: u32,
    pub flowid: u32,
    pub flowtype: u32,
}
#[test]
fn bindgen_test_layout_if_snd_tag_alloc_header() {
    assert_eq!(::std::mem::size_of::<if_snd_tag_alloc_header>() , 12usize ,
               concat ! (
               "Size of: " , stringify ! ( if_snd_tag_alloc_header ) ));
    assert_eq! (::std::mem::align_of::<if_snd_tag_alloc_header>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( if_snd_tag_alloc_header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_snd_tag_alloc_header ) ) . type_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_snd_tag_alloc_header
                ) , "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_snd_tag_alloc_header ) ) . flowid as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( if_snd_tag_alloc_header
                ) , "::" , stringify ! ( flowid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_snd_tag_alloc_header ) ) . flowtype as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( if_snd_tag_alloc_header
                ) , "::" , stringify ! ( flowtype ) ));
}
impl Clone for if_snd_tag_alloc_header {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct if_snd_tag_alloc_rate_limit {
    pub hdr: if_snd_tag_alloc_header,
    pub max_rate: u64,
}
#[test]
fn bindgen_test_layout_if_snd_tag_alloc_rate_limit() {
    assert_eq!(::std::mem::size_of::<if_snd_tag_alloc_rate_limit>() , 24usize
               , concat ! (
               "Size of: " , stringify ! ( if_snd_tag_alloc_rate_limit ) ));
    assert_eq! (::std::mem::align_of::<if_snd_tag_alloc_rate_limit>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( if_snd_tag_alloc_rate_limit )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_snd_tag_alloc_rate_limit ) ) . hdr as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                if_snd_tag_alloc_rate_limit ) , "::" , stringify ! ( hdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_snd_tag_alloc_rate_limit ) ) .
                max_rate as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                if_snd_tag_alloc_rate_limit ) , "::" , stringify ! ( max_rate
                ) ));
}
impl Clone for if_snd_tag_alloc_rate_limit {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct if_snd_tag_rate_limit_params {
    pub max_rate: u64,
    pub queue_level: u32,
    pub reserved: u32,
}
#[test]
fn bindgen_test_layout_if_snd_tag_rate_limit_params() {
    assert_eq!(::std::mem::size_of::<if_snd_tag_rate_limit_params>() , 16usize
               , concat ! (
               "Size of: " , stringify ! ( if_snd_tag_rate_limit_params ) ));
    assert_eq! (::std::mem::align_of::<if_snd_tag_rate_limit_params>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( if_snd_tag_rate_limit_params )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_snd_tag_rate_limit_params ) ) .
                max_rate as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                if_snd_tag_rate_limit_params ) , "::" , stringify ! ( max_rate
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_snd_tag_rate_limit_params ) ) .
                queue_level as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                if_snd_tag_rate_limit_params ) , "::" , stringify ! (
                queue_level ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_snd_tag_rate_limit_params ) ) .
                reserved as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                if_snd_tag_rate_limit_params ) , "::" , stringify ! ( reserved
                ) ));
}
impl Clone for if_snd_tag_rate_limit_params {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union if_snd_tag_alloc_params {
    pub hdr: if_snd_tag_alloc_header,
    pub rate_limit: if_snd_tag_alloc_rate_limit,
    pub unlimited: if_snd_tag_alloc_rate_limit,
    _bindgen_union_align: [u64; 3usize],
}
#[test]
fn bindgen_test_layout_if_snd_tag_alloc_params() {
    assert_eq!(::std::mem::size_of::<if_snd_tag_alloc_params>() , 24usize ,
               concat ! (
               "Size of: " , stringify ! ( if_snd_tag_alloc_params ) ));
    assert_eq! (::std::mem::align_of::<if_snd_tag_alloc_params>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( if_snd_tag_alloc_params ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_snd_tag_alloc_params ) ) . hdr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_snd_tag_alloc_params
                ) , "::" , stringify ! ( hdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_snd_tag_alloc_params ) ) . rate_limit
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_snd_tag_alloc_params
                ) , "::" , stringify ! ( rate_limit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_snd_tag_alloc_params ) ) . unlimited
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_snd_tag_alloc_params
                ) , "::" , stringify ! ( unlimited ) ));
}
impl Clone for if_snd_tag_alloc_params {
    fn clone(&self) -> Self { *self }
}
impl Default for if_snd_tag_alloc_params {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl ::std::fmt::Debug for if_snd_tag_alloc_params {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f , "if_snd_tag_alloc_params {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy)]
pub union if_snd_tag_modify_params {
    pub rate_limit: if_snd_tag_rate_limit_params,
    pub unlimited: if_snd_tag_rate_limit_params,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_if_snd_tag_modify_params() {
    assert_eq!(::std::mem::size_of::<if_snd_tag_modify_params>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( if_snd_tag_modify_params ) ));
    assert_eq! (::std::mem::align_of::<if_snd_tag_modify_params>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( if_snd_tag_modify_params ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_snd_tag_modify_params ) ) . rate_limit
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                if_snd_tag_modify_params ) , "::" , stringify ! ( rate_limit )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_snd_tag_modify_params ) ) . unlimited
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                if_snd_tag_modify_params ) , "::" , stringify ! ( unlimited )
                ));
}
impl Clone for if_snd_tag_modify_params {
    fn clone(&self) -> Self { *self }
}
impl Default for if_snd_tag_modify_params {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl ::std::fmt::Debug for if_snd_tag_modify_params {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f , "if_snd_tag_modify_params {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy)]
pub union if_snd_tag_query_params {
    pub rate_limit: if_snd_tag_rate_limit_params,
    pub unlimited: if_snd_tag_rate_limit_params,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_if_snd_tag_query_params() {
    assert_eq!(::std::mem::size_of::<if_snd_tag_query_params>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( if_snd_tag_query_params ) ));
    assert_eq! (::std::mem::align_of::<if_snd_tag_query_params>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( if_snd_tag_query_params ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_snd_tag_query_params ) ) . rate_limit
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_snd_tag_query_params
                ) , "::" , stringify ! ( rate_limit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_snd_tag_query_params ) ) . unlimited
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_snd_tag_query_params
                ) , "::" , stringify ! ( unlimited ) ));
}
impl Clone for if_snd_tag_query_params {
    fn clone(&self) -> Self { *self }
}
impl Default for if_snd_tag_query_params {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl ::std::fmt::Debug for if_snd_tag_query_params {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f , "if_snd_tag_query_params {{ union }}")
    }
}
pub type if_snd_tag_alloc_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ifnet,
                                               arg2:
                                                   *mut if_snd_tag_alloc_params,
                                               arg3: *mut *mut m_snd_tag)
                              -> ::std::os::raw::c_int>;
pub type if_snd_tag_modify_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut m_snd_tag,
                                               arg2:
                                                   *mut if_snd_tag_modify_params)
                              -> ::std::os::raw::c_int>;
pub type if_snd_tag_query_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut m_snd_tag,
                                               arg2:
                                                   *mut if_snd_tag_query_params)
                              -> ::std::os::raw::c_int>;
pub type if_snd_tag_free_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut m_snd_tag)>;
#[repr(C)]
#[derive(Copy)]
pub struct ifnet {
    pub if_link: ifnet__bindgen_ty_1,
    pub if_clones: ifnet__bindgen_ty_2,
    pub if_groups: ifnet__bindgen_ty_3,
    pub if_alloctype: u_char,
    pub if_softc: *mut ::std::os::raw::c_void,
    pub if_llsoftc: *mut ::std::os::raw::c_void,
    pub if_l2com: *mut ::std::os::raw::c_void,
    pub if_dname: *const ::std::os::raw::c_char,
    pub if_dunit: ::std::os::raw::c_int,
    pub if_index: u_short,
    pub if_index_reserved: ::std::os::raw::c_short,
    pub if_xname: [::std::os::raw::c_char; 16usize],
    pub if_description: *mut ::std::os::raw::c_char,
    pub if_flags: ::std::os::raw::c_int,
    pub if_drv_flags: ::std::os::raw::c_int,
    pub if_capabilities: ::std::os::raw::c_int,
    pub if_capenable: ::std::os::raw::c_int,
    pub if_linkmib: *mut ::std::os::raw::c_void,
    pub if_linkmiblen: usize,
    pub if_refcount: u_int,
    pub if_type: u8,
    pub if_addrlen: u8,
    pub if_hdrlen: u8,
    pub if_link_state: u8,
    pub if_mtu: u32,
    pub if_metric: u32,
    pub if_baudrate: u64,
    pub if_hwassist: u64,
    pub if_epoch: time_t,
    pub if_lastchange: timeval,
    pub if_snd: ifaltq,
    pub if_linktask: task,
    pub if_addr_lock: rwlock,
    pub if_addrhead: ifaddrhead,
    pub if_multiaddrs: ifmultihead,
    pub if_amcount: ::std::os::raw::c_int,
    pub if_addr: *mut ifaddr,
    pub if_hw_addr: *mut ::std::os::raw::c_void,
    pub if_broadcastaddr: *const u_int8_t,
    pub if_afdata_lock: rwlock,
    pub if_afdata: [*mut ::std::os::raw::c_void; 42usize],
    pub if_afdata_initialized: ::std::os::raw::c_int,
    pub if_fib: u_int,
    pub if_vnet: *mut vnet,
    pub if_home_vnet: *mut vnet,
    pub if_vlantrunk: *mut ifvlantrunk,
    pub if_bpf: *mut bpf_if,
    pub if_pcount: ::std::os::raw::c_int,
    pub if_bridge: *mut ::std::os::raw::c_void,
    pub if_lagg: *mut ::std::os::raw::c_void,
    pub if_pf_kif: *mut ::std::os::raw::c_void,
    pub if_carp: *mut carp_if,
    pub if_label: *mut label,
    pub if_netmap: *mut netmap_adapter,
    pub if_output: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                  *mut ifnet,
                                                              arg2: *mut mbuf,
                                                              arg3:
                                                                  *const sockaddr,
                                                              arg4:
                                                                  *mut route)
                                             -> ::std::os::raw::c_int>,
    pub if_input: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ifnet,
                                                             arg2:
                                                                 *mut mbuf)>,
    pub if_start: if_start_fn_t,
    pub if_ioctl: if_ioctl_fn_t,
    pub if_init: if_init_fn_t,
    pub if_resolvemulti: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                        *mut ifnet,
                                                                    arg2:
                                                                        *mut *mut sockaddr,
                                                                    arg3:
                                                                        *mut sockaddr)
                                                   -> ::std::os::raw::c_int>,
    pub if_qflush: if_qflush_fn_t,
    pub if_transmit: if_transmit_fn_t,
    pub if_reassign: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                    *mut ifnet,
                                                                arg2:
                                                                    *mut vnet,
                                                                arg3:
                                                                    *mut ::std::os::raw::c_char)>,
    pub if_get_counter: if_get_counter_t,
    pub if_requestencap: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                        *mut ifnet,
                                                                    arg2:
                                                                        *mut if_encap_req)
                                                   -> ::std::os::raw::c_int>,
    pub if_counters: [counter_u64_t; 12usize],
    pub if_hw_tsomax: u_int,
    pub if_hw_tsomaxsegcount: u_int,
    pub if_hw_tsomaxsegsize: u_int,
    pub if_snd_tag_alloc: if_snd_tag_alloc_t,
    pub if_snd_tag_modify: if_snd_tag_modify_t,
    pub if_snd_tag_query: if_snd_tag_query_t,
    pub if_snd_tag_free: if_snd_tag_free_t,
    pub if_ispare: [::std::os::raw::c_int; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifnet__bindgen_ty_1 {
    pub tqe_next: *mut ifnet,
    pub tqe_prev: *mut *mut ifnet,
}
#[test]
fn bindgen_test_layout_ifnet__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<ifnet__bindgen_ty_1>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( ifnet__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<ifnet__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( ifnet__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet__bindgen_ty_1 ) ) . tqe_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet__bindgen_ty_1 ) ,
                "::" , stringify ! ( tqe_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet__bindgen_ty_1 ) ) . tqe_prev as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet__bindgen_ty_1 ) ,
                "::" , stringify ! ( tqe_prev ) ));
}
impl Clone for ifnet__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for ifnet__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifnet__bindgen_ty_2 {
    pub le_next: *mut ifnet,
    pub le_prev: *mut *mut ifnet,
}
#[test]
fn bindgen_test_layout_ifnet__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<ifnet__bindgen_ty_2>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( ifnet__bindgen_ty_2 ) ));
    assert_eq! (::std::mem::align_of::<ifnet__bindgen_ty_2>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( ifnet__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet__bindgen_ty_2 ) ) . le_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet__bindgen_ty_2 ) ,
                "::" , stringify ! ( le_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet__bindgen_ty_2 ) ) . le_prev as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet__bindgen_ty_2 ) ,
                "::" , stringify ! ( le_prev ) ));
}
impl Clone for ifnet__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for ifnet__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifnet__bindgen_ty_3 {
    pub tqh_first: *mut ifg_list,
    pub tqh_last: *mut *mut ifg_list,
}
#[test]
fn bindgen_test_layout_ifnet__bindgen_ty_3() {
    assert_eq!(::std::mem::size_of::<ifnet__bindgen_ty_3>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( ifnet__bindgen_ty_3 ) ));
    assert_eq! (::std::mem::align_of::<ifnet__bindgen_ty_3>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( ifnet__bindgen_ty_3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet__bindgen_ty_3 ) ) . tqh_first as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet__bindgen_ty_3 ) ,
                "::" , stringify ! ( tqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet__bindgen_ty_3 ) ) . tqh_last as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet__bindgen_ty_3 ) ,
                "::" , stringify ! ( tqh_last ) ));
}
impl Clone for ifnet__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
impl Default for ifnet__bindgen_ty_3 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_ifnet() {
    assert_eq!(::std::mem::size_of::<ifnet>() , 1208usize , concat ! (
               "Size of: " , stringify ! ( ifnet ) ));
    assert_eq! (::std::mem::align_of::<ifnet>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ifnet ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_link as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_link ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_clones as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_clones ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_groups as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_groups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_alloctype as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_alloctype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_softc as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_softc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_llsoftc as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_llsoftc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_l2com as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_l2com ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_dname as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_dname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_dunit as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_dunit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_index as * const _ as
                usize } , 92usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_index_reserved as * const
                _ as usize } , 94usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_index_reserved ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_xname as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_xname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_description as * const _
                as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_description ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_flags as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_drv_flags as * const _ as
                usize } , 124usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_drv_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_capabilities as * const _
                as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_capabilities ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_capenable as * const _ as
                usize } , 132usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_capenable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_linkmib as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_linkmib ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_linkmiblen as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_linkmiblen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_refcount as * const _ as
                usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_refcount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_type as * const _ as usize
                } , 156usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_addrlen as * const _ as
                usize } , 157usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_addrlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_hdrlen as * const _ as
                usize } , 158usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_hdrlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_link_state as * const _ as
                usize } , 159usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_link_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_mtu as * const _ as usize
                } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_mtu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_metric as * const _ as
                usize } , 164usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_metric ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_baudrate as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_baudrate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_hwassist as * const _ as
                usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_hwassist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_epoch as * const _ as
                usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_epoch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_lastchange as * const _ as
                usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_lastchange ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_snd as * const _ as usize
                } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_snd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_linktask as * const _ as
                usize } , 368usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_linktask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_addr_lock as * const _ as
                usize } , 400usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_addr_lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_addrhead as * const _ as
                usize } , 432usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_addrhead ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_multiaddrs as * const _ as
                usize } , 448usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_multiaddrs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_amcount as * const _ as
                usize } , 464usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_amcount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_addr as * const _ as usize
                } , 472usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_hw_addr as * const _ as
                usize } , 480usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_hw_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_broadcastaddr as * const _
                as usize } , 488usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_broadcastaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_afdata_lock as * const _
                as usize } , 496usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_afdata_lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_afdata as * const _ as
                usize } , 528usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_afdata ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_afdata_initialized as *
                const _ as usize } , 864usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_afdata_initialized ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_fib as * const _ as usize
                } , 868usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_fib ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_vnet as * const _ as usize
                } , 872usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_vnet ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_home_vnet as * const _ as
                usize } , 880usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_home_vnet ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_vlantrunk as * const _ as
                usize } , 888usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_vlantrunk ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_bpf as * const _ as usize
                } , 896usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_bpf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_pcount as * const _ as
                usize } , 904usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_pcount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_bridge as * const _ as
                usize } , 912usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_bridge ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_lagg as * const _ as usize
                } , 920usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_lagg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_pf_kif as * const _ as
                usize } , 928usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_pf_kif ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_carp as * const _ as usize
                } , 936usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_carp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_label as * const _ as
                usize } , 944usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_label ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_netmap as * const _ as
                usize } , 952usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_netmap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_output as * const _ as
                usize } , 960usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_output ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_input as * const _ as
                usize } , 968usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_input ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_start as * const _ as
                usize } , 976usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_start ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_ioctl as * const _ as
                usize } , 984usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_ioctl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_init as * const _ as usize
                } , 992usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_init ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_resolvemulti as * const _
                as usize } , 1000usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_resolvemulti ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_qflush as * const _ as
                usize } , 1008usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_qflush ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_transmit as * const _ as
                usize } , 1016usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_transmit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_reassign as * const _ as
                usize } , 1024usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_reassign ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_get_counter as * const _
                as usize } , 1032usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_get_counter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_requestencap as * const _
                as usize } , 1040usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_requestencap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_counters as * const _ as
                usize } , 1048usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_counters ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_hw_tsomax as * const _ as
                usize } , 1144usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_hw_tsomax ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_hw_tsomaxsegcount as *
                const _ as usize } , 1148usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_hw_tsomaxsegcount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_hw_tsomaxsegsize as *
                const _ as usize } , 1152usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_hw_tsomaxsegsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_snd_tag_alloc as * const _
                as usize } , 1160usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_snd_tag_alloc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_snd_tag_modify as * const
                _ as usize } , 1168usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_snd_tag_modify ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_snd_tag_query as * const _
                as usize } , 1176usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_snd_tag_query ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_snd_tag_free as * const _
                as usize } , 1184usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_snd_tag_free ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_ispare as * const _ as
                usize } , 1192usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_ispare ) ));
}
impl Clone for ifnet {
    fn clone(&self) -> Self { *self }
}
impl Default for ifnet {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl ::std::fmt::Debug for ifnet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f ,
               "ifnet {{ if_link: {:?}, if_clones: {:?}, if_groups: {:?}, if_alloctype: {:?}, if_softc: {:?}, if_llsoftc: {:?}, if_l2com: {:?}, if_dname: {:?}, if_dunit: {:?}, if_index: {:?}, if_index_reserved: {:?}, if_xname: {:?}, if_description: {:?}, if_flags: {:?}, if_drv_flags: {:?}, if_capabilities: {:?}, if_capenable: {:?}, if_linkmib: {:?}, if_linkmiblen: {:?}, if_refcount: {:?}, if_type: {:?}, if_addrlen: {:?}, if_hdrlen: {:?}, if_link_state: {:?}, if_mtu: {:?}, if_metric: {:?}, if_baudrate: {:?}, if_hwassist: {:?}, if_epoch: {:?}, if_lastchange: {:?}, if_snd: {:?}, if_linktask: {:?}, if_addr_lock: {:?}, if_addrhead: {:?}, if_multiaddrs: {:?}, if_amcount: {:?}, if_addr: {:?}, if_hw_addr: {:?}, if_broadcastaddr: {:?}, if_afdata_lock: {:?}, if_afdata: [{}], if_afdata_initialized: {:?}, if_fib: {:?}, if_vnet: {:?}, if_home_vnet: {:?}, if_vlantrunk: {:?}, if_bpf: {:?}, if_pcount: {:?}, if_bridge: {:?}, if_lagg: {:?}, if_pf_kif: {:?}, if_carp: {:?}, if_label: {:?}, if_netmap: {:?}, if_output: {:?}, if_input: {:?}, if_start: {:?}, if_ioctl: {:?}, if_init: {:?}, if_resolvemulti: {:?}, if_qflush: {:?}, if_transmit: {:?}, if_reassign: {:?}, if_get_counter: {:?}, if_requestencap: {:?}, if_counters: {:?}, if_hw_tsomax: {:?}, if_hw_tsomaxsegcount: {:?}, if_hw_tsomaxsegsize: {:?}, if_snd_tag_alloc: {:?}, if_snd_tag_modify: {:?}, if_snd_tag_query: {:?}, if_snd_tag_free: {:?}, if_ispare: {:?} }}"
               , self . if_link , self . if_clones , self . if_groups , self .
               if_alloctype , self . if_softc , self . if_llsoftc , self .
               if_l2com , self . if_dname , self . if_dunit , self . if_index
               , self . if_index_reserved , self . if_xname , self .
               if_description , self . if_flags , self . if_drv_flags , self .
               if_capabilities , self . if_capenable , self . if_linkmib ,
               self . if_linkmiblen , self . if_refcount , self . if_type ,
               self . if_addrlen , self . if_hdrlen , self . if_link_state ,
               self . if_mtu , self . if_metric , self . if_baudrate , self .
               if_hwassist , self . if_epoch , self . if_lastchange , self .
               if_snd , self . if_linktask , self . if_addr_lock , self .
               if_addrhead , self . if_multiaddrs , self . if_amcount , self .
               if_addr , self . if_hw_addr , self . if_broadcastaddr , self .
               if_afdata_lock , self . if_afdata . iter (  ) . enumerate (  )
               . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ) , self . if_afdata_initialized , self . if_fib ,
               self . if_vnet , self . if_home_vnet , self . if_vlantrunk ,
               self . if_bpf , self . if_pcount , self . if_bridge , self .
               if_lagg , self . if_pf_kif , self . if_carp , self . if_label ,
               self . if_netmap , self . if_output , self . if_input , self .
               if_start , self . if_ioctl , self . if_init , self .
               if_resolvemulti , self . if_qflush , self . if_transmit , self
               . if_reassign , self . if_get_counter , self . if_requestencap
               , self . if_counters , self . if_hw_tsomax , self .
               if_hw_tsomaxsegcount , self . if_hw_tsomaxsegsize , self .
               if_snd_tag_alloc , self . if_snd_tag_modify , self .
               if_snd_tag_query , self . if_snd_tag_free , self . if_ispare)
    }
}
extern "C" {
    pub fn if_addr_rlock(ifp: *mut ifnet);
}
extern "C" {
    pub fn if_addr_runlock(ifp: *mut ifnet);
}
extern "C" {
    pub fn if_maddr_rlock(ifp: if_t);
}
extern "C" {
    pub fn if_maddr_runlock(ifp: if_t);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifg_group {
    pub ifg_group: [::std::os::raw::c_char; 16usize],
    pub ifg_refcnt: u_int,
    pub ifg_pf_kif: *mut ::std::os::raw::c_void,
    pub ifg_members: ifg_group__bindgen_ty_1,
    pub ifg_next: ifg_group__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifg_group__bindgen_ty_1 {
    pub tqh_first: *mut ifg_member,
    pub tqh_last: *mut *mut ifg_member,
}
#[test]
fn bindgen_test_layout_ifg_group__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<ifg_group__bindgen_ty_1>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( ifg_group__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<ifg_group__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( ifg_group__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifg_group__bindgen_ty_1 ) ) . tqh_first
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifg_group__bindgen_ty_1
                ) , "::" , stringify ! ( tqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifg_group__bindgen_ty_1 ) ) . tqh_last as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifg_group__bindgen_ty_1
                ) , "::" , stringify ! ( tqh_last ) ));
}
impl Clone for ifg_group__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for ifg_group__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifg_group__bindgen_ty_2 {
    pub tqe_next: *mut ifg_group,
    pub tqe_prev: *mut *mut ifg_group,
}
#[test]
fn bindgen_test_layout_ifg_group__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<ifg_group__bindgen_ty_2>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( ifg_group__bindgen_ty_2 ) ));
    assert_eq! (::std::mem::align_of::<ifg_group__bindgen_ty_2>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( ifg_group__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifg_group__bindgen_ty_2 ) ) . tqe_next as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifg_group__bindgen_ty_2
                ) , "::" , stringify ! ( tqe_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifg_group__bindgen_ty_2 ) ) . tqe_prev as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifg_group__bindgen_ty_2
                ) , "::" , stringify ! ( tqe_prev ) ));
}
impl Clone for ifg_group__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for ifg_group__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_ifg_group() {
    assert_eq!(::std::mem::size_of::<ifg_group>() , 64usize , concat ! (
               "Size of: " , stringify ! ( ifg_group ) ));
    assert_eq! (::std::mem::align_of::<ifg_group>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ifg_group ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifg_group ) ) . ifg_group as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifg_group ) , "::" ,
                stringify ! ( ifg_group ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifg_group ) ) . ifg_refcnt as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ifg_group ) , "::" ,
                stringify ! ( ifg_refcnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifg_group ) ) . ifg_pf_kif as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ifg_group ) , "::" ,
                stringify ! ( ifg_pf_kif ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifg_group ) ) . ifg_members as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( ifg_group ) , "::" ,
                stringify ! ( ifg_members ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifg_group ) ) . ifg_next as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( ifg_group ) , "::" ,
                stringify ! ( ifg_next ) ));
}
impl Clone for ifg_group {
    fn clone(&self) -> Self { *self }
}
impl Default for ifg_group {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifg_member {
    pub ifgm_next: ifg_member__bindgen_ty_1,
    pub ifgm_ifp: *mut ifnet,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifg_member__bindgen_ty_1 {
    pub tqe_next: *mut ifg_member,
    pub tqe_prev: *mut *mut ifg_member,
}
#[test]
fn bindgen_test_layout_ifg_member__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<ifg_member__bindgen_ty_1>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( ifg_member__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<ifg_member__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( ifg_member__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifg_member__bindgen_ty_1 ) ) . tqe_next
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                ifg_member__bindgen_ty_1 ) , "::" , stringify ! ( tqe_next )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifg_member__bindgen_ty_1 ) ) . tqe_prev
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                ifg_member__bindgen_ty_1 ) , "::" , stringify ! ( tqe_prev )
                ));
}
impl Clone for ifg_member__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for ifg_member__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_ifg_member() {
    assert_eq!(::std::mem::size_of::<ifg_member>() , 24usize , concat ! (
               "Size of: " , stringify ! ( ifg_member ) ));
    assert_eq! (::std::mem::align_of::<ifg_member>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ifg_member ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifg_member ) ) . ifgm_next as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifg_member ) , "::" ,
                stringify ! ( ifgm_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifg_member ) ) . ifgm_ifp as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ifg_member ) , "::" ,
                stringify ! ( ifgm_ifp ) ));
}
impl Clone for ifg_member {
    fn clone(&self) -> Self { *self }
}
impl Default for ifg_member {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifg_list {
    pub ifgl_group: *mut ifg_group,
    pub ifgl_next: ifg_list__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifg_list__bindgen_ty_1 {
    pub tqe_next: *mut ifg_list,
    pub tqe_prev: *mut *mut ifg_list,
}
#[test]
fn bindgen_test_layout_ifg_list__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<ifg_list__bindgen_ty_1>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( ifg_list__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<ifg_list__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( ifg_list__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifg_list__bindgen_ty_1 ) ) . tqe_next as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifg_list__bindgen_ty_1
                ) , "::" , stringify ! ( tqe_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifg_list__bindgen_ty_1 ) ) . tqe_prev as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifg_list__bindgen_ty_1
                ) , "::" , stringify ! ( tqe_prev ) ));
}
impl Clone for ifg_list__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for ifg_list__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_ifg_list() {
    assert_eq!(::std::mem::size_of::<ifg_list>() , 24usize , concat ! (
               "Size of: " , stringify ! ( ifg_list ) ));
    assert_eq! (::std::mem::align_of::<ifg_list>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ifg_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifg_list ) ) . ifgl_group as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifg_list ) , "::" ,
                stringify ! ( ifgl_group ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifg_list ) ) . ifgl_next as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifg_list ) , "::" ,
                stringify ! ( ifgl_next ) ));
}
impl Clone for ifg_list {
    fn clone(&self) -> Self { *self }
}
impl Default for ifg_list {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifaddr {
    pub ifa_addr: *mut sockaddr,
    pub ifa_dstaddr: *mut sockaddr,
    pub ifa_netmask: *mut sockaddr,
    pub ifa_ifp: *mut ifnet,
    pub ifa_carp: *mut carp_softc,
    pub ifa_link: ifaddr__bindgen_ty_1,
    pub ifa_rtrequest: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      ::std::os::raw::c_int,
                                                                  arg2:
                                                                      *mut rtentry,
                                                                  arg3:
                                                                      *mut rt_addrinfo)>,
    pub ifa_flags: u_short,
    pub ifa_refcnt: u_int,
    pub ifa_ipackets: counter_u64_t,
    pub ifa_opackets: counter_u64_t,
    pub ifa_ibytes: counter_u64_t,
    pub ifa_obytes: counter_u64_t,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifaddr__bindgen_ty_1 {
    pub tqe_next: *mut ifaddr,
    pub tqe_prev: *mut *mut ifaddr,
}
#[test]
fn bindgen_test_layout_ifaddr__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<ifaddr__bindgen_ty_1>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( ifaddr__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<ifaddr__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( ifaddr__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaddr__bindgen_ty_1 ) ) . tqe_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaddr__bindgen_ty_1 )
                , "::" , stringify ! ( tqe_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaddr__bindgen_ty_1 ) ) . tqe_prev as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaddr__bindgen_ty_1 )
                , "::" , stringify ! ( tqe_prev ) ));
}
impl Clone for ifaddr__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for ifaddr__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_ifaddr() {
    assert_eq!(::std::mem::size_of::<ifaddr>() , 104usize , concat ! (
               "Size of: " , stringify ! ( ifaddr ) ));
    assert_eq! (::std::mem::align_of::<ifaddr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ifaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaddr ) ) . ifa_addr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaddr ) , "::" ,
                stringify ! ( ifa_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaddr ) ) . ifa_dstaddr as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaddr ) , "::" ,
                stringify ! ( ifa_dstaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaddr ) ) . ifa_netmask as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaddr ) , "::" ,
                stringify ! ( ifa_netmask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaddr ) ) . ifa_ifp as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaddr ) , "::" ,
                stringify ! ( ifa_ifp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaddr ) ) . ifa_carp as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaddr ) , "::" ,
                stringify ! ( ifa_carp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaddr ) ) . ifa_link as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaddr ) , "::" ,
                stringify ! ( ifa_link ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaddr ) ) . ifa_rtrequest as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaddr ) , "::" ,
                stringify ! ( ifa_rtrequest ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaddr ) ) . ifa_flags as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaddr ) , "::" ,
                stringify ! ( ifa_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaddr ) ) . ifa_refcnt as * const _ as
                usize } , 68usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaddr ) , "::" ,
                stringify ! ( ifa_refcnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaddr ) ) . ifa_ipackets as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaddr ) , "::" ,
                stringify ! ( ifa_ipackets ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaddr ) ) . ifa_opackets as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaddr ) , "::" ,
                stringify ! ( ifa_opackets ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaddr ) ) . ifa_ibytes as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaddr ) , "::" ,
                stringify ! ( ifa_ibytes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaddr ) ) . ifa_obytes as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaddr ) , "::" ,
                stringify ! ( ifa_obytes ) ));
}
impl Clone for ifaddr {
    fn clone(&self) -> Self { *self }
}
impl Default for ifaddr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
extern "C" {
    pub fn ifa_alloc(size: usize, flags: ::std::os::raw::c_int)
     -> *mut ifaddr;
}
extern "C" {
    pub fn ifa_free(ifa: *mut ifaddr);
}
extern "C" {
    pub fn ifa_ref(ifa: *mut ifaddr);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifmultiaddr {
    pub ifma_link: ifmultiaddr__bindgen_ty_1,
    pub ifma_addr: *mut sockaddr,
    pub ifma_lladdr: *mut sockaddr,
    pub ifma_ifp: *mut ifnet,
    pub ifma_refcount: u_int,
    pub ifma_protospec: *mut ::std::os::raw::c_void,
    pub ifma_llifma: *mut ifmultiaddr,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifmultiaddr__bindgen_ty_1 {
    pub tqe_next: *mut ifmultiaddr,
    pub tqe_prev: *mut *mut ifmultiaddr,
}
#[test]
fn bindgen_test_layout_ifmultiaddr__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<ifmultiaddr__bindgen_ty_1>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( ifmultiaddr__bindgen_ty_1 ) ));
    assert_eq! (::std::mem::align_of::<ifmultiaddr__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( ifmultiaddr__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmultiaddr__bindgen_ty_1 ) ) . tqe_next
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                ifmultiaddr__bindgen_ty_1 ) , "::" , stringify ! ( tqe_next )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmultiaddr__bindgen_ty_1 ) ) . tqe_prev
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                ifmultiaddr__bindgen_ty_1 ) , "::" , stringify ! ( tqe_prev )
                ));
}
impl Clone for ifmultiaddr__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for ifmultiaddr__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_ifmultiaddr() {
    assert_eq!(::std::mem::size_of::<ifmultiaddr>() , 64usize , concat ! (
               "Size of: " , stringify ! ( ifmultiaddr ) ));
    assert_eq! (::std::mem::align_of::<ifmultiaddr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ifmultiaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmultiaddr ) ) . ifma_link as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmultiaddr ) , "::" ,
                stringify ! ( ifma_link ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmultiaddr ) ) . ifma_addr as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmultiaddr ) , "::" ,
                stringify ! ( ifma_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmultiaddr ) ) . ifma_lladdr as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmultiaddr ) , "::" ,
                stringify ! ( ifma_lladdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmultiaddr ) ) . ifma_ifp as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmultiaddr ) , "::" ,
                stringify ! ( ifma_ifp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmultiaddr ) ) . ifma_refcount as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmultiaddr ) , "::" ,
                stringify ! ( ifma_refcount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmultiaddr ) ) . ifma_protospec as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmultiaddr ) , "::" ,
                stringify ! ( ifma_protospec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmultiaddr ) ) . ifma_llifma as * const
                _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmultiaddr ) , "::" ,
                stringify ! ( ifma_llifma ) ));
}
impl Clone for ifmultiaddr {
    fn clone(&self) -> Self { *self }
}
impl Default for ifmultiaddr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
extern "C" {
    #[link_name = "ifnet_rwlock"]
    pub static mut ifnet_rwlock: rwlock;
}
extern "C" {
    #[link_name = "ifnet_sxlock"]
    pub static mut ifnet_sxlock: sx;
}
extern "C" {
    pub fn ifnet_byindex(idx: u_short) -> *mut ifnet;
}
extern "C" {
    pub fn ifnet_byindex_locked(idx: u_short) -> *mut ifnet;
}
extern "C" {
    pub fn ifnet_byindex_ref(idx: u_short) -> *mut ifnet;
}
extern "C" {
    pub fn ifaddr_byindex(idx: u_short) -> *mut ifaddr;
}
extern "C" {
    #[link_name = "ifnet"]
    pub static mut ifnet: ifnethead;
}
extern "C" {
    #[link_name = "ifg_head"]
    pub static mut ifg_head: ifgrouphead;
}
extern "C" {
    #[link_name = "if_index"]
    pub static mut if_index: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "loif"]
    pub static mut loif: *mut ifnet;
}
extern "C" {
    pub fn if_addgroup(arg1: *mut ifnet, arg2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn if_delgroup(arg1: *mut ifnet, arg2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn if_addmulti(arg1: *mut ifnet, arg2: *mut sockaddr,
                       arg3: *mut *mut ifmultiaddr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn if_allmulti(arg1: *mut ifnet, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn if_alloc(arg1: u_char) -> *mut ifnet;
}
extern "C" {
    pub fn if_attach(arg1: *mut ifnet);
}
extern "C" {
    pub fn if_dead(arg1: *mut ifnet);
}
extern "C" {
    pub fn if_delmulti(arg1: *mut ifnet, arg2: *mut sockaddr)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn if_delmulti_ifma(arg1: *mut ifmultiaddr);
}
extern "C" {
    pub fn if_detach(arg1: *mut ifnet);
}
extern "C" {
    pub fn if_purgeaddrs(arg1: *mut ifnet);
}
extern "C" {
    pub fn if_delallmulti(arg1: *mut ifnet);
}
extern "C" {
    pub fn if_down(arg1: *mut ifnet);
}
extern "C" {
    pub fn if_findmulti(arg1: *mut ifnet, arg2: *const sockaddr)
     -> *mut ifmultiaddr;
}
extern "C" {
    pub fn if_free(arg1: *mut ifnet);
}
extern "C" {
    pub fn if_initname(arg1: *mut ifnet, arg2: *const ::std::os::raw::c_char,
                       arg3: ::std::os::raw::c_int);
}
extern "C" {
    pub fn if_link_state_change(arg1: *mut ifnet,
                                arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn if_printf(arg1: *mut ifnet,
                     arg2: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn if_ref(arg1: *mut ifnet);
}
extern "C" {
    pub fn if_rele(arg1: *mut ifnet);
}
extern "C" {
    pub fn if_setlladdr(arg1: *mut ifnet, arg2: *const u_char,
                        arg3: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn if_up(arg1: *mut ifnet);
}
extern "C" {
    pub fn ifioctl(arg1: *mut socket, arg2: u_long, arg3: caddr_t,
                   arg4: *mut thread) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ifpromisc(arg1: *mut ifnet, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ifunit(arg1: *const ::std::os::raw::c_char) -> *mut ifnet;
}
extern "C" {
    pub fn ifunit_ref(arg1: *const ::std::os::raw::c_char) -> *mut ifnet;
}
extern "C" {
    pub fn ifa_add_loopback_route(arg1: *mut ifaddr, arg2: *mut sockaddr)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ifa_del_loopback_route(arg1: *mut ifaddr, arg2: *mut sockaddr)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ifa_switch_loopback_route(arg1: *mut ifaddr, arg2: *mut sockaddr)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ifa_ifwithaddr(arg1: *const sockaddr) -> *mut ifaddr;
}
extern "C" {
    pub fn ifa_ifwithaddr_check(arg1: *const sockaddr)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ifa_ifwithbroadaddr(arg1: *const sockaddr,
                               arg2: ::std::os::raw::c_int) -> *mut ifaddr;
}
extern "C" {
    pub fn ifa_ifwithdstaddr(arg1: *const sockaddr,
                             arg2: ::std::os::raw::c_int) -> *mut ifaddr;
}
extern "C" {
    pub fn ifa_ifwithnet(arg1: *const sockaddr, arg2: ::std::os::raw::c_int,
                         arg3: ::std::os::raw::c_int) -> *mut ifaddr;
}
extern "C" {
    pub fn ifa_ifwithroute(arg1: ::std::os::raw::c_int, arg2: *const sockaddr,
                           arg3: *mut sockaddr, arg4: u_int) -> *mut ifaddr;
}
extern "C" {
    pub fn ifaof_ifpforaddr(arg1: *const sockaddr, arg2: *mut ifnet)
     -> *mut ifaddr;
}
extern "C" {
    pub fn ifa_preferred(arg1: *mut ifaddr, arg2: *mut ifaddr)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn if_simloop(ifp: *mut ifnet, m: *mut mbuf,
                      af: ::std::os::raw::c_int, hlen: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
pub type if_com_alloc_t =
    ::std::option::Option<unsafe extern "C" fn(type_: u_char, ifp: *mut ifnet)
                              -> *mut ::std::os::raw::c_void>;
pub type if_com_free_t =
    ::std::option::Option<unsafe extern "C" fn(com:
                                                   *mut ::std::os::raw::c_void,
                                               type_: u_char)>;
extern "C" {
    pub fn if_register_com_alloc(type_: u_char, a: if_com_alloc_t,
                                 f: if_com_free_t);
}
extern "C" {
    pub fn if_deregister_com_alloc(type_: u_char);
}
extern "C" {
    pub fn if_data_copy(arg1: *mut ifnet, arg2: *mut if_data);
}
extern "C" {
    pub fn if_get_counter_default(arg1: *mut ifnet, arg2: ift_counter) -> u64;
}
extern "C" {
    pub fn if_inc_counter(arg1: *mut ifnet, arg2: ift_counter, arg3: i64);
}
extern "C" {
    pub fn if_setbaudrate(ifp: if_t, baudrate: u64) -> u64;
}
extern "C" {
    pub fn if_getbaudrate(ifp: if_t) -> u64;
}
extern "C" {
    pub fn if_setcapabilities(ifp: if_t, capabilities: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn if_setcapabilitiesbit(ifp: if_t, setbit: ::std::os::raw::c_int,
                                 clearbit: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn if_getcapabilities(ifp: if_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn if_togglecapenable(ifp: if_t, togglecap: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn if_setcapenable(ifp: if_t, capenable: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn if_setcapenablebit(ifp: if_t, setcap: ::std::os::raw::c_int,
                              clearcap: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn if_getcapenable(ifp: if_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn if_getdname(ifp: if_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn if_setdev(ifp: if_t, dev: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn if_setdrvflagbits(ifp: if_t, if_setflags: ::std::os::raw::c_int,
                             clear_flags: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn if_getdrvflags(ifp: if_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn if_setdrvflags(ifp: if_t, flags: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn if_clearhwassist(ifp: if_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn if_sethwassistbits(ifp: if_t, toset: ::std::os::raw::c_int,
                              toclear: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn if_sethwassist(ifp: if_t, hwassist_bit: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn if_gethwassist(ifp: if_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn if_setsoftc(ifp: if_t, softc: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn if_getsoftc(ifp: if_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn if_setflags(ifp: if_t, flags: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn if_gethwaddr(ifp: if_t, arg1: *mut ifreq) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn if_setmtu(ifp: if_t, mtu: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn if_getmtu(ifp: if_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn if_getmtu_family(ifp: if_t, family: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn if_setflagbits(ifp: if_t, set: ::std::os::raw::c_int,
                          clear: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn if_getflags(ifp: if_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn if_sendq_empty(ifp: if_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn if_setsendqready(ifp: if_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn if_setsendqlen(ifp: if_t, tx_desc_count: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn if_sethwtsomax(ifp: if_t, if_hw_tsomax: u_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn if_sethwtsomaxsegcount(ifp: if_t, if_hw_tsomaxsegcount: u_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn if_sethwtsomaxsegsize(ifp: if_t, if_hw_tsomaxsegsize: u_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn if_gethwtsomax(ifp: if_t) -> u_int;
}
extern "C" {
    pub fn if_gethwtsomaxsegcount(ifp: if_t) -> u_int;
}
extern "C" {
    pub fn if_gethwtsomaxsegsize(ifp: if_t) -> u_int;
}
extern "C" {
    pub fn if_input(ifp: if_t, sendmp: *mut mbuf) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn if_sendq_prepend(ifp: if_t, m: *mut mbuf) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn if_dequeue(ifp: if_t) -> *mut mbuf;
}
extern "C" {
    pub fn if_setifheaderlen(ifp: if_t, len: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn if_setrcvif(m: *mut mbuf, ifp: if_t);
}
extern "C" {
    pub fn if_setvtag(m: *mut mbuf, tag: u_int16_t);
}
extern "C" {
    pub fn if_getvtag(m: *mut mbuf) -> u_int16_t;
}
extern "C" {
    pub fn if_vlantrunkinuse(ifp: if_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn if_getlladdr(ifp: if_t) -> caddr_t;
}
extern "C" {
    pub fn if_gethandle(arg1: u_char) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn if_bpfmtap(ifp: if_t, m: *mut mbuf);
}
extern "C" {
    pub fn if_etherbpfmtap(ifp: if_t, m: *mut mbuf);
}
extern "C" {
    pub fn if_vlancap(ifp: if_t);
}
extern "C" {
    pub fn if_setupmultiaddr(ifp: if_t, mta: *mut ::std::os::raw::c_void,
                             cnt: *mut ::std::os::raw::c_int,
                             max: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn if_multiaddr_array(ifp: if_t, mta: *mut ::std::os::raw::c_void,
                              cnt: *mut ::std::os::raw::c_int,
                              max: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn if_multiaddr_count(ifp: if_t, max: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn if_multi_apply(ifp: *mut ifnet,
                          filter:
                              ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                             *mut ::std::os::raw::c_void,
                                                                         arg2:
                                                                             *mut ifmultiaddr,
                                                                         arg3:
                                                                             ::std::os::raw::c_int)
                                                        ->
                                                            ::std::os::raw::c_int>,
                          arg: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn if_getamcount(ifp: if_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn if_getifaddr(ifp: if_t) -> *mut ifaddr;
}
extern "C" {
    pub fn if_setinitfn(ifp: if_t,
                        arg1:
                            ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                           *mut ::std::os::raw::c_void)>);
}
extern "C" {
    pub fn if_setioctlfn(ifp: if_t,
                         arg1:
                             ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                            if_t,
                                                                        arg2:
                                                                            u_long,
                                                                        arg3:
                                                                            caddr_t)
                                                       ->
                                                           ::std::os::raw::c_int>);
}
extern "C" {
    pub fn if_setstartfn(ifp: if_t,
                         arg1:
                             ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                            if_t)>);
}
extern "C" {
    pub fn if_settransmitfn(ifp: if_t, arg1: if_transmit_fn_t);
}
extern "C" {
    pub fn if_setqflushfn(ifp: if_t, arg1: if_qflush_fn_t);
}
extern "C" {
    pub fn if_setgetcounterfn(ifp: if_t, arg1: if_get_counter_t);
}
extern "C" {
    pub fn drbr_inuse_drv(ifp: if_t, br: *mut buf_ring)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drbr_dequeue_drv(ifp: if_t, br: *mut buf_ring) -> *mut mbuf;
}
extern "C" {
    pub fn drbr_needs_enqueue_drv(ifp: if_t, br: *mut buf_ring)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drbr_enqueue_drv(ifp: if_t, br: *mut buf_ring, m: *mut mbuf)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn if_hw_tsomax_common(ifp: if_t, arg1: *mut ifnet_hw_tsomax);
}
extern "C" {
    pub fn if_hw_tsomax_update(ifp: if_t, arg1: *mut ifnet_hw_tsomax)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifqueue {
    pub ifq_head: *mut mbuf,
    pub ifq_tail: *mut mbuf,
    pub ifq_len: ::std::os::raw::c_int,
    pub ifq_maxlen: ::std::os::raw::c_int,
    pub ifq_mtx: mtx,
}
#[test]
fn bindgen_test_layout_ifqueue() {
    assert_eq!(::std::mem::size_of::<ifqueue>() , 56usize , concat ! (
               "Size of: " , stringify ! ( ifqueue ) ));
    assert_eq! (::std::mem::align_of::<ifqueue>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ifqueue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifqueue ) ) . ifq_head as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifqueue ) , "::" ,
                stringify ! ( ifq_head ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifqueue ) ) . ifq_tail as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifqueue ) , "::" ,
                stringify ! ( ifq_tail ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifqueue ) ) . ifq_len as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ifqueue ) , "::" ,
                stringify ! ( ifq_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifqueue ) ) . ifq_maxlen as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( ifqueue ) , "::" ,
                stringify ! ( ifq_maxlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifqueue ) ) . ifq_mtx as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ifqueue ) , "::" ,
                stringify ! ( ifq_mtx ) ));
}
impl Clone for ifqueue {
    fn clone(&self) -> Self { *self }
}
impl Default for ifqueue {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
extern "C" {
    pub fn if_handoff(ifq: *mut ifqueue, m: *mut mbuf, ifp: *mut ifnet,
                      adjust: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn if_start(arg1: *mut ifnet);
}
extern "C" {
    #[link_name = "ifqmaxlen"]
    pub static mut ifqmaxlen: ::std::os::raw::c_int;
}
extern "C" {
    pub fn if_qflush(arg1: *mut ifnet);
}
extern "C" {
    pub fn ifq_init(arg1: *mut ifaltq, ifp: *mut ifnet);
}
extern "C" {
    pub fn ifq_delete(arg1: *mut ifaltq);
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy)]
pub struct ether_header {
    pub ether_dhost: [u_char; 6usize],
    pub ether_shost: [u_char; 6usize],
    pub ether_type: u_short,
}
#[test]
fn bindgen_test_layout_ether_header() {
    assert_eq!(::std::mem::size_of::<ether_header>() , 14usize , concat ! (
               "Size of: " , stringify ! ( ether_header ) ));
    assert_eq! (::std::mem::align_of::<ether_header>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( ether_header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ether_header ) ) . ether_dhost as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ether_header ) , "::" ,
                stringify ! ( ether_dhost ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ether_header ) ) . ether_shost as * const
                _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( ether_header ) , "::" ,
                stringify ! ( ether_shost ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ether_header ) ) . ether_type as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( ether_header ) , "::" ,
                stringify ! ( ether_type ) ));
}
impl Clone for ether_header {
    fn clone(&self) -> Self { *self }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy)]
pub struct ether_addr {
    pub octet: [u_char; 6usize],
}
#[test]
fn bindgen_test_layout_ether_addr() {
    assert_eq!(::std::mem::size_of::<ether_addr>() , 6usize , concat ! (
               "Size of: " , stringify ! ( ether_addr ) ));
    assert_eq! (::std::mem::align_of::<ether_addr>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( ether_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ether_addr ) ) . octet as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ether_addr ) , "::" ,
                stringify ! ( octet ) ));
}
impl Clone for ether_addr {
    fn clone(&self) -> Self { *self }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy)]
pub struct ether_vlan_header {
    pub evl_dhost: [u8; 6usize],
    pub evl_shost: [u8; 6usize],
    pub evl_encap_proto: u16,
    pub evl_tag: u16,
    pub evl_proto: u16,
}
#[test]
fn bindgen_test_layout_ether_vlan_header() {
    assert_eq!(::std::mem::size_of::<ether_vlan_header>() , 18usize , concat !
               ( "Size of: " , stringify ! ( ether_vlan_header ) ));
    assert_eq! (::std::mem::align_of::<ether_vlan_header>() , 1usize , concat
                ! ( "Alignment of " , stringify ! ( ether_vlan_header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ether_vlan_header ) ) . evl_dhost as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ether_vlan_header ) ,
                "::" , stringify ! ( evl_dhost ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ether_vlan_header ) ) . evl_shost as *
                const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( ether_vlan_header ) ,
                "::" , stringify ! ( evl_shost ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ether_vlan_header ) ) . evl_encap_proto
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( ether_vlan_header ) ,
                "::" , stringify ! ( evl_encap_proto ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ether_vlan_header ) ) . evl_tag as *
                const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( ether_vlan_header ) ,
                "::" , stringify ! ( evl_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ether_vlan_header ) ) . evl_proto as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ether_vlan_header ) ,
                "::" , stringify ! ( evl_proto ) ));
}
impl Clone for ether_vlan_header {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_if {
    _unused: [u8; 0],
}
extern "C" {
    pub fn ether_crc32_le(arg1: *const u8, arg2: usize) -> u32;
}
extern "C" {
    pub fn ether_crc32_be(arg1: *const u8, arg2: usize) -> u32;
}
extern "C" {
    pub fn ether_demux(arg1: *mut ifnet, arg2: *mut mbuf);
}
extern "C" {
    pub fn ether_ifattach(arg1: *mut ifnet, arg2: *const u_int8_t);
}
extern "C" {
    pub fn ether_ifdetach(arg1: *mut ifnet);
}
extern "C" {
    pub fn ether_ioctl(arg1: *mut ifnet, arg2: u_long, arg3: caddr_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ether_output(arg1: *mut ifnet, arg2: *mut mbuf,
                        arg3: *const sockaddr, arg4: *mut route)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ether_output_frame(arg1: *mut ifnet, arg2: *mut mbuf)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ether_sprintf(arg1: *const u_int8_t)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ether_vlan_mtap(arg1: *mut bpf_if, arg2: *mut mbuf,
                           arg3: *mut ::std::os::raw::c_void, arg4: u_int);
}
extern "C" {
    pub fn ether_vlanencap(arg1: *mut mbuf, arg2: u16) -> *mut mbuf;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct kobj {
    pub ops: kobj_ops_t,
}
#[test]
fn bindgen_test_layout_kobj() {
    assert_eq!(::std::mem::size_of::<kobj>() , 8usize , concat ! (
               "Size of: " , stringify ! ( kobj ) ));
    assert_eq! (::std::mem::align_of::<kobj>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kobj ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kobj ) ) . ops as * const _ as usize } ,
                0usize , concat ! (
                "Alignment of field: " , stringify ! ( kobj ) , "::" ,
                stringify ! ( ops ) ));
}
impl Clone for kobj {
    fn clone(&self) -> Self { *self }
}
impl Default for kobj {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type kobj_t = *mut kobj;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct kobj_class {
    pub name: *const ::std::os::raw::c_char,
    pub methods: *mut kobj_method_t,
    pub size: usize,
    pub baseclasses: *mut kobj_class_t,
    pub refs: u_int,
    pub ops: kobj_ops_t,
}
#[test]
fn bindgen_test_layout_kobj_class() {
    assert_eq!(::std::mem::size_of::<kobj_class>() , 48usize , concat ! (
               "Size of: " , stringify ! ( kobj_class ) ));
    assert_eq! (::std::mem::align_of::<kobj_class>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kobj_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kobj_class ) ) . name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kobj_class ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kobj_class ) ) . methods as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kobj_class ) , "::" ,
                stringify ! ( methods ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kobj_class ) ) . size as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( kobj_class ) , "::" ,
                stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kobj_class ) ) . baseclasses as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( kobj_class ) , "::" ,
                stringify ! ( baseclasses ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kobj_class ) ) . refs as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( kobj_class ) , "::" ,
                stringify ! ( refs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kobj_class ) ) . ops as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( kobj_class ) , "::" ,
                stringify ! ( ops ) ));
}
impl Clone for kobj_class {
    fn clone(&self) -> Self { *self }
}
impl Default for kobj_class {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type kobj_class_t = *mut kobj_class;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct kobj_method {
    pub desc: kobjop_desc_t,
    pub func: kobjop_t,
}
#[test]
fn bindgen_test_layout_kobj_method() {
    assert_eq!(::std::mem::size_of::<kobj_method>() , 16usize , concat ! (
               "Size of: " , stringify ! ( kobj_method ) ));
    assert_eq! (::std::mem::align_of::<kobj_method>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kobj_method ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kobj_method ) ) . desc as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kobj_method ) , "::" ,
                stringify ! ( desc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kobj_method ) ) . func as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kobj_method ) , "::" ,
                stringify ! ( func ) ));
}
impl Clone for kobj_method {
    fn clone(&self) -> Self { *self }
}
impl Default for kobj_method {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type kobj_method_t = kobj_method;
pub type kobjop_t =
    ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>;
#[repr(C)]
#[derive(Copy)]
pub struct kobj_ops {
    pub cache: [*mut kobj_method_t; 256usize],
    pub cls: kobj_class_t,
}
#[test]
fn bindgen_test_layout_kobj_ops() {
    assert_eq!(::std::mem::size_of::<kobj_ops>() , 2056usize , concat ! (
               "Size of: " , stringify ! ( kobj_ops ) ));
    assert_eq! (::std::mem::align_of::<kobj_ops>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kobj_ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kobj_ops ) ) . cache as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kobj_ops ) , "::" ,
                stringify ! ( cache ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kobj_ops ) ) . cls as * const _ as usize
                } , 2048usize , concat ! (
                "Alignment of field: " , stringify ! ( kobj_ops ) , "::" ,
                stringify ! ( cls ) ));
}
impl Clone for kobj_ops {
    fn clone(&self) -> Self { *self }
}
impl Default for kobj_ops {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl ::std::fmt::Debug for kobj_ops {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f , "kobj_ops {{ cache: [{}], cls: {:?} }}" , self . cache .
               iter (  ) . enumerate (  ) . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ) , self . cls)
    }
}
pub type kobj_ops_t = *mut kobj_ops;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct kobjop_desc {
    pub id: ::std::os::raw::c_uint,
    pub deflt: kobj_method_t,
}
#[test]
fn bindgen_test_layout_kobjop_desc() {
    assert_eq!(::std::mem::size_of::<kobjop_desc>() , 24usize , concat ! (
               "Size of: " , stringify ! ( kobjop_desc ) ));
    assert_eq! (::std::mem::align_of::<kobjop_desc>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kobjop_desc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kobjop_desc ) ) . id as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kobjop_desc ) , "::" ,
                stringify ! ( id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kobjop_desc ) ) . deflt as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kobjop_desc ) , "::" ,
                stringify ! ( deflt ) ));
}
impl Clone for kobjop_desc {
    fn clone(&self) -> Self { *self }
}
impl Default for kobjop_desc {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type kobjop_desc_t = *mut kobjop_desc;
extern "C" {
    pub fn kobj_class_compile(cls: kobj_class_t);
}
extern "C" {
    pub fn kobj_class_compile_static(cls: kobj_class_t, ops: kobj_ops_t);
}
extern "C" {
    pub fn kobj_class_free(cls: kobj_class_t);
}
extern "C" {
    pub fn kobj_create(cls: kobj_class_t, mtype: *mut malloc_type,
                       mflags: ::std::os::raw::c_int) -> kobj_t;
}
extern "C" {
    pub fn kobj_init(obj: kobj_t, cls: kobj_class_t);
}
extern "C" {
    pub fn kobj_init_static(obj: kobj_t, cls: kobj_class_t);
}
extern "C" {
    pub fn kobj_delete(obj: kobj_t, mtype: *mut malloc_type);
}
extern "C" {
    pub fn kobj_lookup_method(cls: kobj_class_t, cep: *mut *mut kobj_method_t,
                              desc: kobjop_desc_t) -> *mut kobj_method_t;
}
extern "C" {
    pub fn kobj_error_method() -> ::std::os::raw::c_int;
}
pub type bus_addr_t = u64;
pub type bus_size_t = u64;
pub type bus_space_tag_t = u64;
pub type bus_space_handle_t = u64;
pub type bus_dmasync_op_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bus_dma_tag {
    _unused: [u8; 0],
}
pub type bus_dma_tag_t = *mut bus_dma_tag;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bus_dmamap {
    _unused: [u8; 0],
}
pub type bus_dmamap_t = *mut bus_dmamap;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum bus_dma_lock_op_t { BUS_DMA_LOCK = 1, BUS_DMA_UNLOCK = 2, }
pub type bus_dma_lock_t =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2: bus_dma_lock_op_t)>;
/// @brief Interface information structure.
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct u_businfo {
    /// < @brief interface version
    pub ub_version: ::std::os::raw::c_int,
    /// < @brief generation count
    pub ub_generation: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_u_businfo() {
    assert_eq!(::std::mem::size_of::<u_businfo>() , 8usize , concat ! (
               "Size of: " , stringify ! ( u_businfo ) ));
    assert_eq! (::std::mem::align_of::<u_businfo>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( u_businfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_businfo ) ) . ub_version as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( u_businfo ) , "::" ,
                stringify ! ( ub_version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_businfo ) ) . ub_generation as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( u_businfo ) , "::" ,
                stringify ! ( ub_generation ) ));
}
impl Clone for u_businfo {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
/// @brief State of the device.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum device_state {
    DS_NOTPRESENT = 10,
    DS_ALIVE = 20,
    DS_ATTACHING = 25,
    DS_ATTACHED = 30,
    DS_BUSY = 40,
}
pub use self::device_state as device_state_t;
/// @brief Device information exported to userspace.
#[repr(C)]
#[derive(Copy)]
pub struct u_device {
    pub dv_handle: usize,
    pub dv_parent: usize,
    /// < @brief Name of device in tree.
    pub dv_name: [::std::os::raw::c_char; 32usize],
    /// < @brief Driver description
    pub dv_desc: [::std::os::raw::c_char; 32usize],
    /// < @brief Driver name
    pub dv_drivername: [::std::os::raw::c_char; 32usize],
    /// < @brief Plug and play info
    pub dv_pnpinfo: [::std::os::raw::c_char; 128usize],
    /// < @brief Where is the device?
    pub dv_location: [::std::os::raw::c_char; 128usize],
    /// < @brief API Flags for device
    pub dv_devflags: u32,
    /// < @brief flags for dev state
    pub dv_flags: u16,
    /// < @brief State of attachment
    pub dv_state: device_state_t,
}
#[test]
fn bindgen_test_layout_u_device() {
    assert_eq!(::std::mem::size_of::<u_device>() , 384usize , concat ! (
               "Size of: " , stringify ! ( u_device ) ));
    assert_eq! (::std::mem::align_of::<u_device>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( u_device ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_device ) ) . dv_handle as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( u_device ) , "::" ,
                stringify ! ( dv_handle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_device ) ) . dv_parent as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( u_device ) , "::" ,
                stringify ! ( dv_parent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_device ) ) . dv_name as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( u_device ) , "::" ,
                stringify ! ( dv_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_device ) ) . dv_desc as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( u_device ) , "::" ,
                stringify ! ( dv_desc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_device ) ) . dv_drivername as * const _
                as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( u_device ) , "::" ,
                stringify ! ( dv_drivername ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_device ) ) . dv_pnpinfo as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( u_device ) , "::" ,
                stringify ! ( dv_pnpinfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_device ) ) . dv_location as * const _
                as usize } , 240usize , concat ! (
                "Alignment of field: " , stringify ! ( u_device ) , "::" ,
                stringify ! ( dv_location ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_device ) ) . dv_devflags as * const _
                as usize } , 368usize , concat ! (
                "Alignment of field: " , stringify ! ( u_device ) , "::" ,
                stringify ! ( dv_devflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_device ) ) . dv_flags as * const _ as
                usize } , 372usize , concat ! (
                "Alignment of field: " , stringify ! ( u_device ) , "::" ,
                stringify ! ( dv_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_device ) ) . dv_state as * const _ as
                usize } , 376usize , concat ! (
                "Alignment of field: " , stringify ! ( u_device ) , "::" ,
                stringify ! ( dv_state ) ));
}
impl Clone for u_device {
    fn clone(&self) -> Self { *self }
}
impl Default for u_device {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl ::std::fmt::Debug for u_device {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f ,
               "u_device {{ dv_handle: {:?}, dv_parent: {:?}, dv_name: [{}], dv_desc: [{}], dv_drivername: [{}], dv_pnpinfo: [{}], dv_location: [{}], dv_devflags: {:?}, dv_flags: {:?}, dv_state: {:?} }}"
               , self . dv_handle , self . dv_parent , self . dv_name . iter (
                ) . enumerate (  ) . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ) , self . dv_desc . iter (  ) . enumerate (  ) .
               map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ) , self . dv_drivername . iter (  ) . enumerate (
               ) . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ) , self . dv_pnpinfo . iter (  ) . enumerate (  )
               . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ) , self . dv_location . iter (  ) . enumerate (  )
               . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ) , self . dv_devflags , self . dv_flags , self .
               dv_state)
    }
}
/// @brief Device request structure used for ioctl's.
///
/// Used for ioctl's on /dev/devctl2.  All device ioctl's
/// must have parameter definitions which begin with dr_name.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct devreq_buffer {
    pub buffer: *mut ::std::os::raw::c_void,
    pub length: usize,
}
#[test]
fn bindgen_test_layout_devreq_buffer() {
    assert_eq!(::std::mem::size_of::<devreq_buffer>() , 16usize , concat ! (
               "Size of: " , stringify ! ( devreq_buffer ) ));
    assert_eq! (::std::mem::align_of::<devreq_buffer>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( devreq_buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const devreq_buffer ) ) . buffer as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( devreq_buffer ) , "::"
                , stringify ! ( buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const devreq_buffer ) ) . length as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( devreq_buffer ) , "::"
                , stringify ! ( length ) ));
}
impl Clone for devreq_buffer {
    fn clone(&self) -> Self { *self }
}
impl Default for devreq_buffer {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct devreq {
    pub dr_name: [::std::os::raw::c_char; 128usize],
    pub dr_flags: ::std::os::raw::c_int,
    pub dr_dru: devreq__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub union devreq__bindgen_ty_1 {
    pub dru_buffer: devreq_buffer,
    pub dru_data: *mut ::std::os::raw::c_void,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_devreq__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<devreq__bindgen_ty_1>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( devreq__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<devreq__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( devreq__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const devreq__bindgen_ty_1 ) ) . dru_buffer as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( devreq__bindgen_ty_1 )
                , "::" , stringify ! ( dru_buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const devreq__bindgen_ty_1 ) ) . dru_data as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( devreq__bindgen_ty_1 )
                , "::" , stringify ! ( dru_data ) ));
}
impl Clone for devreq__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for devreq__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl ::std::fmt::Debug for devreq__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f , "devreq__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_devreq() {
    assert_eq!(::std::mem::size_of::<devreq>() , 152usize , concat ! (
               "Size of: " , stringify ! ( devreq ) ));
    assert_eq! (::std::mem::align_of::<devreq>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( devreq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const devreq ) ) . dr_name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( devreq ) , "::" ,
                stringify ! ( dr_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const devreq ) ) . dr_flags as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( devreq ) , "::" ,
                stringify ! ( dr_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const devreq ) ) . dr_dru as * const _ as usize
                } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( devreq ) , "::" ,
                stringify ! ( dr_dru ) ));
}
impl Clone for devreq {
    fn clone(&self) -> Self { *self }
}
impl Default for devreq {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl ::std::fmt::Debug for devreq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f , "devreq {{ dr_name: [{}], dr_flags: {:?}, dr_dru: {:?} }}"
               , self . dr_name . iter (  ) . enumerate (  ) . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ) , self . dr_flags , self . dr_dru)
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ktr_entry {
    pub ktr_timestamp: u_int64_t,
    pub ktr_cpu: ::std::os::raw::c_int,
    pub ktr_line: ::std::os::raw::c_int,
    pub ktr_file: *const ::std::os::raw::c_char,
    pub ktr_desc: *const ::std::os::raw::c_char,
    pub ktr_thread: *mut thread,
    pub ktr_parms: [u_long; 6usize],
}
#[test]
fn bindgen_test_layout_ktr_entry() {
    assert_eq!(::std::mem::size_of::<ktr_entry>() , 88usize , concat ! (
               "Size of: " , stringify ! ( ktr_entry ) ));
    assert_eq! (::std::mem::align_of::<ktr_entry>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ktr_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ktr_entry ) ) . ktr_timestamp as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ktr_entry ) , "::" ,
                stringify ! ( ktr_timestamp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ktr_entry ) ) . ktr_cpu as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ktr_entry ) , "::" ,
                stringify ! ( ktr_cpu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ktr_entry ) ) . ktr_line as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( ktr_entry ) , "::" ,
                stringify ! ( ktr_line ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ktr_entry ) ) . ktr_file as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ktr_entry ) , "::" ,
                stringify ! ( ktr_file ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ktr_entry ) ) . ktr_desc as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ktr_entry ) , "::" ,
                stringify ! ( ktr_desc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ktr_entry ) ) . ktr_thread as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( ktr_entry ) , "::" ,
                stringify ! ( ktr_thread ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ktr_entry ) ) . ktr_parms as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( ktr_entry ) , "::" ,
                stringify ! ( ktr_parms ) ));
}
impl Clone for ktr_entry {
    fn clone(&self) -> Self { *self }
}
impl Default for ktr_entry {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
extern "C" {
    #[link_name = "ktr_cpumask"]
    pub static mut ktr_cpumask: cpuset_t;
}
extern "C" {
    #[link_name = "ktr_mask"]
    pub static mut ktr_mask: u64;
}
extern "C" {
    #[link_name = "ktr_entries"]
    pub static mut ktr_entries: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "ktr_verbose"]
    pub static mut ktr_verbose: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "ktr_idx"]
    pub static mut ktr_idx: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "ktr_buf"]
    pub static mut ktr_buf: *mut ktr_entry;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry {
    pub ee_link: eventhandler_entry__bindgen_ty_1,
    pub ee_priority: ::std::os::raw::c_int,
    pub ee_arg: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry__bindgen_ty_1 {
    pub tqe_next: *mut eventhandler_entry,
    pub tqe_prev: *mut *mut eventhandler_entry,
}
#[test]
fn bindgen_test_layout_eventhandler_entry__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry__bindgen_ty_1>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry__bindgen_ty_1 ) ) .
                tqe_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry__bindgen_ty_1 ) , "::" , stringify ! (
                tqe_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry__bindgen_ty_1 ) ) .
                tqe_prev as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry__bindgen_ty_1 ) , "::" , stringify ! (
                tqe_prev ) ));
}
impl Clone for eventhandler_entry__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_eventhandler_entry() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry>() , 32usize , concat
               ! ( "Size of: " , stringify ! ( eventhandler_entry ) ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( eventhandler_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry ) ) . ee_link as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( eventhandler_entry ) ,
                "::" , stringify ! ( ee_link ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry ) ) . ee_priority as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( eventhandler_entry ) ,
                "::" , stringify ! ( ee_priority ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry ) ) . ee_arg as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( eventhandler_entry ) ,
                "::" , stringify ! ( ee_arg ) ));
}
impl Clone for eventhandler_entry {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_list {
    pub el_name: *mut ::std::os::raw::c_char,
    pub el_flags: ::std::os::raw::c_int,
    pub el_runcount: u_int,
    pub el_lock: mtx,
    pub el_link: eventhandler_list__bindgen_ty_1,
    pub el_entries: eventhandler_list__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_list__bindgen_ty_1 {
    pub tqe_next: *mut eventhandler_list,
    pub tqe_prev: *mut *mut eventhandler_list,
}
#[test]
fn bindgen_test_layout_eventhandler_list__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<eventhandler_list__bindgen_ty_1>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_list__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<eventhandler_list__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_list__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_list__bindgen_ty_1 ) ) .
                tqe_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_list__bindgen_ty_1 ) , "::" , stringify ! (
                tqe_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_list__bindgen_ty_1 ) ) .
                tqe_prev as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_list__bindgen_ty_1 ) , "::" , stringify ! (
                tqe_prev ) ));
}
impl Clone for eventhandler_list__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_list__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_list__bindgen_ty_2 {
    pub tqh_first: *mut eventhandler_entry,
    pub tqh_last: *mut *mut eventhandler_entry,
}
#[test]
fn bindgen_test_layout_eventhandler_list__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<eventhandler_list__bindgen_ty_2>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_list__bindgen_ty_2 )
               ));
    assert_eq! (::std::mem::align_of::<eventhandler_list__bindgen_ty_2>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_list__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_list__bindgen_ty_2 ) ) .
                tqh_first as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_list__bindgen_ty_2 ) , "::" , stringify ! (
                tqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_list__bindgen_ty_2 ) ) .
                tqh_last as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_list__bindgen_ty_2 ) , "::" , stringify ! (
                tqh_last ) ));
}
impl Clone for eventhandler_list__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_list__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_eventhandler_list() {
    assert_eq!(::std::mem::size_of::<eventhandler_list>() , 80usize , concat !
               ( "Size of: " , stringify ! ( eventhandler_list ) ));
    assert_eq! (::std::mem::align_of::<eventhandler_list>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( eventhandler_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_list ) ) . el_name as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( eventhandler_list ) ,
                "::" , stringify ! ( el_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_list ) ) . el_flags as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( eventhandler_list ) ,
                "::" , stringify ! ( el_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_list ) ) . el_runcount as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( eventhandler_list ) ,
                "::" , stringify ! ( el_runcount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_list ) ) . el_lock as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( eventhandler_list ) ,
                "::" , stringify ! ( el_lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_list ) ) . el_link as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( eventhandler_list ) ,
                "::" , stringify ! ( el_link ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_list ) ) . el_entries as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( eventhandler_list ) ,
                "::" , stringify ! ( el_entries ) ));
}
impl Clone for eventhandler_list {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_list {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type eventhandler_tag = *mut eventhandler_entry;
extern "C" {
    pub fn eventhandler_register(list: *mut eventhandler_list,
                                 name: *const ::std::os::raw::c_char,
                                 func: *mut ::std::os::raw::c_void,
                                 arg: *mut ::std::os::raw::c_void,
                                 priority: ::std::os::raw::c_int)
     -> eventhandler_tag;
}
extern "C" {
    pub fn eventhandler_deregister(list: *mut eventhandler_list,
                                   tag: eventhandler_tag);
}
extern "C" {
    pub fn eventhandler_deregister_nowait(list: *mut eventhandler_list,
                                          tag: eventhandler_tag);
}
extern "C" {
    pub fn eventhandler_find_list(name: *const ::std::os::raw::c_char)
     -> *mut eventhandler_list;
}
extern "C" {
    pub fn eventhandler_prune_list(list: *mut eventhandler_list);
}
extern "C" {
    pub fn eventhandler_create_list(name: *const ::std::os::raw::c_char)
     -> *mut eventhandler_list;
}
pub type shutdown_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2: ::std::os::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_shutdown_pre_sync {
    pub ee: eventhandler_entry,
    pub eh_func: shutdown_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_shutdown_pre_sync() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_shutdown_pre_sync>() ,
               40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_shutdown_pre_sync ) ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_shutdown_pre_sync>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_shutdown_pre_sync ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_shutdown_pre_sync ) )
                . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_shutdown_pre_sync ) , "::" , stringify ! (
                ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_shutdown_pre_sync ) )
                . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_shutdown_pre_sync ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_shutdown_pre_sync {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_shutdown_pre_sync {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __hack {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_shutdown_post_sync {
    pub ee: eventhandler_entry,
    pub eh_func: shutdown_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_shutdown_post_sync() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_shutdown_post_sync>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_shutdown_post_sync ) ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_shutdown_post_sync>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_shutdown_post_sync ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_shutdown_post_sync ) )
                . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_shutdown_post_sync ) , "::" , stringify ! (
                ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_shutdown_post_sync ) )
                . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_shutdown_post_sync ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_shutdown_post_sync {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_shutdown_post_sync {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_shutdown_final {
    pub ee: eventhandler_entry,
    pub eh_func: shutdown_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_shutdown_final() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_shutdown_final>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_shutdown_final )
               ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_shutdown_final>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_shutdown_final ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_shutdown_final ) ) .
                ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_shutdown_final ) , "::" , stringify ! ( ee
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_shutdown_final ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_shutdown_final ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_shutdown_final {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_shutdown_final {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type power_change_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_power_resume {
    pub ee: eventhandler_entry,
    pub eh_func: power_change_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_power_resume() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_power_resume>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_power_resume )
               ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_power_resume>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_power_resume ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_power_resume ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_power_resume ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_power_resume ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_power_resume ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_power_resume {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_power_resume {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_power_suspend {
    pub ee: eventhandler_entry,
    pub eh_func: power_change_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_power_suspend() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_power_suspend>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_power_suspend )
               ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_power_suspend>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_power_suspend ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_power_suspend ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_power_suspend ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_power_suspend ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_power_suspend ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_power_suspend {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_power_suspend {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_power_suspend_early {
    pub ee: eventhandler_entry,
    pub eh_func: power_change_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_power_suspend_early() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_power_suspend_early>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_power_suspend_early ) ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_power_suspend_early>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_power_suspend_early ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_power_suspend_early )
                ) . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_power_suspend_early ) , "::" , stringify !
                ( ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_power_suspend_early )
                ) . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_power_suspend_early ) , "::" , stringify !
                ( eh_func ) ));
}
impl Clone for eventhandler_entry_power_suspend_early {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_power_suspend_early {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type vm_lowmem_handler_t =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2: ::std::os::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_vm_lowmem {
    pub ee: eventhandler_entry,
    pub eh_func: vm_lowmem_handler_t,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_vm_lowmem() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_vm_lowmem>() , 40usize
               , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_vm_lowmem ) ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_vm_lowmem>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_vm_lowmem )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_vm_lowmem ) ) . ee as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_vm_lowmem ) , "::" , stringify ! ( ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_vm_lowmem ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_vm_lowmem ) , "::" , stringify ! ( eh_func
                ) ));
}
impl Clone for eventhandler_entry_vm_lowmem {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_vm_lowmem {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type mountroot_handler_t =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_mountroot {
    pub ee: eventhandler_entry,
    pub eh_func: mountroot_handler_t,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_mountroot() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_mountroot>() , 40usize
               , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_mountroot ) ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_mountroot>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_mountroot )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_mountroot ) ) . ee as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_mountroot ) , "::" , stringify ! ( ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_mountroot ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_mountroot ) , "::" , stringify ! ( eh_func
                ) ));
}
impl Clone for eventhandler_entry_mountroot {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_mountroot {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mount {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnode {
    _unused: [u8; 0],
}
pub type vfs_mounted_notify_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2: *mut mount,
                                               arg3: *mut vnode,
                                               arg4: *mut thread)>;
pub type vfs_unmounted_notify_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2: *mut mount,
                                               arg3: *mut thread)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_vfs_mounted {
    pub ee: eventhandler_entry,
    pub eh_func: vfs_mounted_notify_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_vfs_mounted() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_vfs_mounted>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_vfs_mounted )
               ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_vfs_mounted>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_vfs_mounted
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_vfs_mounted ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_vfs_mounted ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_vfs_mounted ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_vfs_mounted ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_vfs_mounted {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_vfs_mounted {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_vfs_unmounted {
    pub ee: eventhandler_entry,
    pub eh_func: vfs_unmounted_notify_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_vfs_unmounted() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_vfs_unmounted>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_vfs_unmounted )
               ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_vfs_unmounted>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_vfs_unmounted ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_vfs_unmounted ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_vfs_unmounted ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_vfs_unmounted ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_vfs_unmounted ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_vfs_unmounted {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_vfs_unmounted {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct image_params {
    _unused: [u8; 0],
}
pub type exitlist_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2: *mut proc_)>;
pub type forklist_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2: *mut proc_,
                                               arg3: *mut proc_,
                                               arg4: ::std::os::raw::c_int)>;
pub type execlist_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2: *mut proc_,
                                               arg3: *mut image_params)>;
pub type proc_ctor_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2: *mut proc_)>;
pub type proc_dtor_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2: *mut proc_)>;
pub type proc_init_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2: *mut proc_)>;
pub type proc_fini_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2: *mut proc_)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_process_ctor {
    pub ee: eventhandler_entry,
    pub eh_func: proc_ctor_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_process_ctor() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_process_ctor>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_process_ctor )
               ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_process_ctor>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_process_ctor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_ctor ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_ctor ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_ctor ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_ctor ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_process_ctor {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_process_ctor {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_process_dtor {
    pub ee: eventhandler_entry,
    pub eh_func: proc_dtor_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_process_dtor() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_process_dtor>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_process_dtor )
               ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_process_dtor>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_process_dtor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_dtor ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_dtor ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_dtor ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_dtor ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_process_dtor {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_process_dtor {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_process_init {
    pub ee: eventhandler_entry,
    pub eh_func: proc_init_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_process_init() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_process_init>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_process_init )
               ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_process_init>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_process_init ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_init ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_init ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_init ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_init ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_process_init {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_process_init {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_process_fini {
    pub ee: eventhandler_entry,
    pub eh_func: proc_fini_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_process_fini() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_process_fini>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_process_fini )
               ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_process_fini>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_process_fini ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_fini ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_fini ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_fini ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_fini ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_process_fini {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_process_fini {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_process_exit {
    pub ee: eventhandler_entry,
    pub eh_func: exitlist_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_process_exit() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_process_exit>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_process_exit )
               ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_process_exit>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_process_exit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_exit ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_exit ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_exit ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_exit ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_process_exit {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_process_exit {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_process_fork {
    pub ee: eventhandler_entry,
    pub eh_func: forklist_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_process_fork() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_process_fork>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_process_fork )
               ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_process_fork>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_process_fork ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_fork ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_fork ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_fork ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_fork ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_process_fork {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_process_fork {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_process_exec {
    pub ee: eventhandler_entry,
    pub eh_func: execlist_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_process_exec() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_process_exec>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_process_exec )
               ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_process_exec>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_process_exec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_exec ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_exec ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_exec ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_exec ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_process_exec {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_process_exec {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type app_coredump_start_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2: *mut thread,
                                               name:
                                                   *mut ::std::os::raw::c_char)>;
pub type app_coredump_progress_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               td: *mut thread,
                                               byte_count:
                                                   ::std::os::raw::c_int)>;
pub type app_coredump_finish_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               td: *mut thread)>;
pub type app_coredump_error_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               td: *mut thread,
                                               msg:
                                                   *mut ::std::os::raw::c_char, ...)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_app_coredump_start {
    pub ee: eventhandler_entry,
    pub eh_func: app_coredump_start_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_app_coredump_start() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_app_coredump_start>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_app_coredump_start ) ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_app_coredump_start>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_app_coredump_start ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_app_coredump_start ) )
                . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_app_coredump_start ) , "::" , stringify ! (
                ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_app_coredump_start ) )
                . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_app_coredump_start ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_app_coredump_start {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_app_coredump_start {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_app_coredump_progress {
    pub ee: eventhandler_entry,
    pub eh_func: app_coredump_progress_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_app_coredump_progress() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_app_coredump_progress>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_app_coredump_progress ) ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_app_coredump_progress>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_app_coredump_progress ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const eventhandler_entry_app_coredump_progress ) )
                . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_app_coredump_progress ) , "::" , stringify
                ! ( ee ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const eventhandler_entry_app_coredump_progress ) )
                . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_app_coredump_progress ) , "::" , stringify
                ! ( eh_func ) ));
}
impl Clone for eventhandler_entry_app_coredump_progress {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_app_coredump_progress {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_app_coredump_finish {
    pub ee: eventhandler_entry,
    pub eh_func: app_coredump_finish_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_app_coredump_finish() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_app_coredump_finish>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_app_coredump_finish ) ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_app_coredump_finish>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_app_coredump_finish ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_app_coredump_finish )
                ) . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_app_coredump_finish ) , "::" , stringify !
                ( ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_app_coredump_finish )
                ) . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_app_coredump_finish ) , "::" , stringify !
                ( eh_func ) ));
}
impl Clone for eventhandler_entry_app_coredump_finish {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_app_coredump_finish {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_app_coredump_error {
    pub ee: eventhandler_entry,
    pub eh_func: app_coredump_error_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_app_coredump_error() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_app_coredump_error>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_app_coredump_error ) ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_app_coredump_error>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_app_coredump_error ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_app_coredump_error ) )
                . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_app_coredump_error ) , "::" , stringify ! (
                ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_app_coredump_error ) )
                . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_app_coredump_error ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_app_coredump_error {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_app_coredump_error {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type thread_ctor_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2: *mut thread)>;
pub type thread_dtor_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2: *mut thread)>;
pub type thread_fini_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2: *mut thread)>;
pub type thread_init_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2: *mut thread)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_thread_ctor {
    pub ee: eventhandler_entry,
    pub eh_func: thread_ctor_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_thread_ctor() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_thread_ctor>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_thread_ctor )
               ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_thread_ctor>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_thread_ctor
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_thread_ctor ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_thread_ctor ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_thread_ctor ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_thread_ctor ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_thread_ctor {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_thread_ctor {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_thread_dtor {
    pub ee: eventhandler_entry,
    pub eh_func: thread_dtor_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_thread_dtor() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_thread_dtor>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_thread_dtor )
               ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_thread_dtor>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_thread_dtor
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_thread_dtor ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_thread_dtor ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_thread_dtor ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_thread_dtor ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_thread_dtor {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_thread_dtor {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_thread_init {
    pub ee: eventhandler_entry,
    pub eh_func: thread_init_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_thread_init() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_thread_init>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_thread_init )
               ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_thread_init>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_thread_init
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_thread_init ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_thread_init ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_thread_init ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_thread_init ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_thread_init {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_thread_init {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_thread_fini {
    pub ee: eventhandler_entry,
    pub eh_func: thread_fini_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_thread_fini() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_thread_fini>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_thread_fini )
               ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_thread_fini>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_thread_fini
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_thread_fini ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_thread_fini ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_thread_fini ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_thread_fini ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_thread_fini {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_thread_fini {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type uma_zone_chfn =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_nmbclusters_change {
    pub ee: eventhandler_entry,
    pub eh_func: uma_zone_chfn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_nmbclusters_change() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_nmbclusters_change>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_nmbclusters_change ) ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_nmbclusters_change>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_nmbclusters_change ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_nmbclusters_change ) )
                . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_nmbclusters_change ) , "::" , stringify ! (
                ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_nmbclusters_change ) )
                . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_nmbclusters_change ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_nmbclusters_change {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_nmbclusters_change {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_nmbufs_change {
    pub ee: eventhandler_entry,
    pub eh_func: uma_zone_chfn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_nmbufs_change() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_nmbufs_change>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_nmbufs_change )
               ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_nmbufs_change>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_nmbufs_change ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_nmbufs_change ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_nmbufs_change ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_nmbufs_change ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_nmbufs_change ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_nmbufs_change {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_nmbufs_change {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_maxsockets_change {
    pub ee: eventhandler_entry,
    pub eh_func: uma_zone_chfn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_maxsockets_change() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_maxsockets_change>() ,
               40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_maxsockets_change ) ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_maxsockets_change>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_maxsockets_change ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_maxsockets_change ) )
                . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_maxsockets_change ) , "::" , stringify ! (
                ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_maxsockets_change ) )
                . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_maxsockets_change ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_maxsockets_change {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_maxsockets_change {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type kld_load_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2: *mut linker_file)>;
pub type kld_unload_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2:
                                                   *const ::std::os::raw::c_char,
                                               arg3: caddr_t, arg4: usize)>;
pub type kld_unload_try_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2: *mut linker_file,
                                               arg3:
                                                   *mut ::std::os::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_kld_load {
    pub ee: eventhandler_entry,
    pub eh_func: kld_load_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_kld_load() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_kld_load>() , 40usize
               , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_kld_load ) ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_kld_load>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_kld_load )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_kld_load ) ) . ee as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_kld_load ) , "::" , stringify ! ( ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_kld_load ) ) . eh_func
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_kld_load ) , "::" , stringify ! ( eh_func )
                ));
}
impl Clone for eventhandler_entry_kld_load {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_kld_load {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_kld_unload {
    pub ee: eventhandler_entry,
    pub eh_func: kld_unload_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_kld_unload() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_kld_unload>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_kld_unload ) ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_kld_unload>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_kld_unload
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_kld_unload ) ) . ee as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_kld_unload ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_kld_unload ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_kld_unload ) , "::" , stringify ! ( eh_func
                ) ));
}
impl Clone for eventhandler_entry_kld_unload {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_kld_unload {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_kld_unload_try {
    pub ee: eventhandler_entry,
    pub eh_func: kld_unload_try_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_kld_unload_try() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_kld_unload_try>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_kld_unload_try )
               ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_kld_unload_try>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_kld_unload_try ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_kld_unload_try ) ) .
                ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_kld_unload_try ) , "::" , stringify ! ( ee
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_kld_unload_try ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_kld_unload_try ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_kld_unload_try {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_kld_unload_try {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fb_info {
    _unused: [u8; 0],
}
pub type register_framebuffer_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2: *mut fb_info)>;
pub type unregister_framebuffer_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2: *mut fb_info)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_register_framebuffer {
    pub ee: eventhandler_entry,
    pub eh_func: register_framebuffer_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_register_framebuffer() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_register_framebuffer>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_register_framebuffer ) ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_register_framebuffer>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_register_framebuffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_register_framebuffer )
                ) . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_register_framebuffer ) , "::" , stringify !
                ( ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_register_framebuffer )
                ) . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_register_framebuffer ) , "::" , stringify !
                ( eh_func ) ));
}
impl Clone for eventhandler_entry_register_framebuffer {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_register_framebuffer {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_unregister_framebuffer {
    pub ee: eventhandler_entry,
    pub eh_func: unregister_framebuffer_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_unregister_framebuffer() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_unregister_framebuffer>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_unregister_framebuffer ) ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_unregister_framebuffer>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_unregister_framebuffer ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const eventhandler_entry_unregister_framebuffer ) )
                . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_unregister_framebuffer ) , "::" , stringify
                ! ( ee ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const eventhandler_entry_unregister_framebuffer ) )
                . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_unregister_framebuffer ) , "::" , stringify
                ! ( eh_func ) ));
}
impl Clone for eventhandler_entry_unregister_framebuffer {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_unregister_framebuffer {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cam_path {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ata_params {
    _unused: [u8; 0],
}
pub type ada_probe_veto_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2: *mut cam_path,
                                               arg3: *mut ata_params,
                                               arg4:
                                                   *mut ::std::os::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_ada_probe_veto {
    pub ee: eventhandler_entry,
    pub eh_func: ada_probe_veto_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_ada_probe_veto() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_ada_probe_veto>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_ada_probe_veto )
               ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_ada_probe_veto>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_ada_probe_veto ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_ada_probe_veto ) ) .
                ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_ada_probe_veto ) , "::" , stringify ! ( ee
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_ada_probe_veto ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_ada_probe_veto ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_ada_probe_veto {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_ada_probe_veto {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct swdevt {
    _unused: [u8; 0],
}
pub type swapon_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2: *mut swdevt)>;
pub type swapoff_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2: *mut swdevt)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_swapon {
    pub ee: eventhandler_entry,
    pub eh_func: swapon_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_swapon() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_swapon>() , 40usize ,
               concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_swapon ) ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_swapon>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_swapon )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_swapon ) ) . ee as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_swapon ) , "::" , stringify ! ( ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_swapon ) ) . eh_func
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_swapon ) , "::" , stringify ! ( eh_func )
                ));
}
impl Clone for eventhandler_entry_swapon {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_swapon {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_swapoff {
    pub ee: eventhandler_entry,
    pub eh_func: swapoff_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_swapoff() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_swapoff>() , 40usize ,
               concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_swapoff ) ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_swapoff>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_swapoff )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_swapoff ) ) . ee as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_swapoff ) , "::" , stringify ! ( ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_swapoff ) ) . eh_func
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_swapoff ) , "::" , stringify ! ( eh_func )
                ));
}
impl Clone for eventhandler_entry_swapoff {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_swapoff {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum evhdev_detach {
    EVHDEV_DETACH_BEGIN = 0,
    EVHDEV_DETACH_COMPLETE = 1,
    EVHDEV_DETACH_FAILED = 2,
}
pub type device_attach_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2: device_t)>;
pub type device_detach_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2: device_t,
                                               arg3: evhdev_detach)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_device_attach {
    pub ee: eventhandler_entry,
    pub eh_func: device_attach_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_device_attach() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_device_attach>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_device_attach )
               ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_device_attach>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_device_attach ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_device_attach ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_device_attach ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_device_attach ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_device_attach ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_device_attach {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_device_attach {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_device_detach {
    pub ee: eventhandler_entry,
    pub eh_func: device_detach_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_device_detach() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_device_detach>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_device_detach )
               ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_device_detach>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_device_detach ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_device_detach ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_device_detach ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_device_detach ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_device_detach ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_device_detach {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_device_detach {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
extern "C" {
    /// devctl hooks.  Typically one should use the devctl_notify
/// hook to send the message.  However, devctl_queue_data is also
/// included in case devctl_notify isn't sufficiently general.
    pub fn devctl_process_running() -> boolean_t;
}
extern "C" {
    pub fn devctl_notify_f(__system: *const ::std::os::raw::c_char,
                           __subsystem: *const ::std::os::raw::c_char,
                           __type: *const ::std::os::raw::c_char,
                           __data: *const ::std::os::raw::c_char,
                           __flags: ::std::os::raw::c_int);
}
extern "C" {
    pub fn devctl_notify(__system: *const ::std::os::raw::c_char,
                         __subsystem: *const ::std::os::raw::c_char,
                         __type: *const ::std::os::raw::c_char,
                         __data: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn devctl_queue_data_f(__data: *mut ::std::os::raw::c_char,
                               __flags: ::std::os::raw::c_int);
}
extern "C" {
    pub fn devctl_queue_data(__data: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn devctl_safe_quote(__dst: *mut ::std::os::raw::c_char,
                             __src: *const ::std::os::raw::c_char,
                             len: usize);
}
/// Device name parsers.  Hook to allow device enumerators to map
/// scheme-specific names to a device.
pub type dev_lookup_fn =
    ::std::option::Option<unsafe extern "C" fn(arg:
                                                   *mut ::std::os::raw::c_void,
                                               name:
                                                   *const ::std::os::raw::c_char,
                                               result: *mut device_t)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_dev_lookup {
    pub ee: eventhandler_entry,
    pub eh_func: dev_lookup_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_dev_lookup() {
    assert_eq!(::std::mem::size_of::<eventhandler_entry_dev_lookup>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_dev_lookup ) ));
    assert_eq! (::std::mem::align_of::<eventhandler_entry_dev_lookup>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_dev_lookup
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_dev_lookup ) ) . ee as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_dev_lookup ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_dev_lookup ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_dev_lookup ) , "::" , stringify ! ( eh_func
                ) ));
}
impl Clone for eventhandler_entry_dev_lookup {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_dev_lookup {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
/// @brief A device driver (included mainly for compatibility with
/// FreeBSD 4.x).
pub type driver_t = kobj_class;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct devclass {
    _unused: [u8; 0],
}
/// @brief A device class
///
/// The devclass object has two main functions in the system. The first
/// is to manage the allocation of unit numbers for device instances
/// and the second is to hold the list of device drivers for a
/// particular bus type. Each devclass has a name and there cannot be
/// two devclasses with the same name. This ensures that unique unit
/// numbers are allocated to device instances.
///
/// Drivers that support several different bus attachments (e.g. isa,
/// pci, pccard) should all use the same devclass to ensure that unit
/// numbers do not conflict.
///
/// Each devclass may also have a parent devclass. This is used when
/// searching for device drivers to allow a form of inheritance. When
/// matching drivers with devices, first the driver list of the parent
/// device's devclass is searched. If no driver is found in that list,
/// the search continues in the parent devclass (if any).
pub type devclass_t = *mut devclass;
/// @brief Driver interrupt service routines
///
/// The filter routine is run in primary interrupt context and may not
/// block or use regular mutexes.  It may only use spin mutexes for
/// synchronization.  The filter may either completely handle the
/// interrupt or it may perform some of the work and defer more
/// expensive work to the regular interrupt handler.  If a filter
/// routine is not registered by the driver, then the regular interrupt
/// handler is always used to handle interrupts from this device.
///
/// The regular interrupt handler executes in its own thread context
/// and may use regular mutexes.  However, it is prohibited from
/// sleeping on a sleep queue.
pub type driver_filter_t =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
pub type driver_intr_t =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void)>;
#[repr(u32)]
/// @brief Interrupt type bits.
///
/// These flags are used both by newbus interrupt
/// registration (nexus.c) and also in struct intrec, which defines
/// interrupt properties.
///
/// XXX We should probably revisit this and remove the vestiges of the
/// spls implicit in names like INTR_TYPE_TTY. In the meantime, don't
/// confuse things by renaming them (Grog, 18 July 2000).
///
/// Buses which do interrupt remapping will want to change their type
/// to reflect what sort of devices are underneath.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum intr_type {
    INTR_TYPE_TTY = 1,
    INTR_TYPE_BIO = 2,
    INTR_TYPE_NET = 4,
    INTR_TYPE_CAM = 8,
    INTR_TYPE_MISC = 16,
    INTR_TYPE_CLK = 32,
    INTR_TYPE_AV = 64,
    INTR_EXCL = 256,
    INTR_MPSAFE = 512,
    INTR_ENTROPY = 1024,
    INTR_MD1 = 4096,
    INTR_MD2 = 8192,
    INTR_MD3 = 16384,
    INTR_MD4 = 32768,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum intr_trigger {
    INTR_TRIGGER_INVALID = -1,
    INTR_TRIGGER_CONFORM = 0,
    INTR_TRIGGER_EDGE = 1,
    INTR_TRIGGER_LEVEL = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum intr_polarity {
    INTR_POLARITY_CONFORM = 0,
    INTR_POLARITY_HIGH = 1,
    INTR_POLARITY_LOW = 2,
}
#[repr(u32)]
/// CPU sets supported by bus_get_cpus().  Note that not all sets may be
/// supported for a given device.  If a request is not supported by a
/// device (or its parents), then bus_get_cpus() will fail with EINVAL.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum cpu_sets { LOCAL_CPUS = 0, INTR_CPUS = 1, }
pub type devop_t =
    ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>;
/// @brief This structure is deprecated.
///
/// Use the kobj(9) macro DEFINE_CLASS to
/// declare classes which implement device drivers.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct driver {
    pub name: *const ::std::os::raw::c_char,
    pub methods: *mut kobj_method_t,
    pub size: usize,
    pub baseclasses: *mut kobj_class_t,
    pub refs: u_int,
    pub ops: kobj_ops_t,
}
#[test]
fn bindgen_test_layout_driver() {
    assert_eq!(::std::mem::size_of::<driver>() , 48usize , concat ! (
               "Size of: " , stringify ! ( driver ) ));
    assert_eq! (::std::mem::align_of::<driver>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( driver ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const driver ) ) . name as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( driver ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const driver ) ) . methods as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( driver ) , "::" ,
                stringify ! ( methods ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const driver ) ) . size as * const _ as usize }
                , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( driver ) , "::" ,
                stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const driver ) ) . baseclasses as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( driver ) , "::" ,
                stringify ! ( baseclasses ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const driver ) ) . refs as * const _ as usize }
                , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( driver ) , "::" ,
                stringify ! ( refs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const driver ) ) . ops as * const _ as usize }
                , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( driver ) , "::" ,
                stringify ! ( ops ) ));
}
impl Clone for driver {
    fn clone(&self) -> Self { *self }
}
impl Default for driver {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
/// @brief A resource mapping.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct resource_map {
    pub r_bustag: bus_space_tag_t,
    pub r_bushandle: bus_space_handle_t,
    pub r_size: bus_size_t,
    pub r_vaddr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_resource_map() {
    assert_eq!(::std::mem::size_of::<resource_map>() , 32usize , concat ! (
               "Size of: " , stringify ! ( resource_map ) ));
    assert_eq! (::std::mem::align_of::<resource_map>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( resource_map ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_map ) ) . r_bustag as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_map ) , "::" ,
                stringify ! ( r_bustag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_map ) ) . r_bushandle as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_map ) , "::" ,
                stringify ! ( r_bushandle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_map ) ) . r_size as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_map ) , "::" ,
                stringify ! ( r_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_map ) ) . r_vaddr as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_map ) , "::" ,
                stringify ! ( r_vaddr ) ));
}
impl Clone for resource_map {
    fn clone(&self) -> Self { *self }
}
impl Default for resource_map {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
/// @brief Optional properties of a resource mapping request.
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct resource_map_request {
    pub size: usize,
    pub offset: rman_res_t,
    pub length: rman_res_t,
    pub memattr: vm_memattr_t,
}
#[test]
fn bindgen_test_layout_resource_map_request() {
    assert_eq!(::std::mem::size_of::<resource_map_request>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( resource_map_request )
               ));
    assert_eq! (::std::mem::align_of::<resource_map_request>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( resource_map_request ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_map_request ) ) . size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_map_request )
                , "::" , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_map_request ) ) . offset as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_map_request )
                , "::" , stringify ! ( offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_map_request ) ) . length as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_map_request )
                , "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_map_request ) ) . memattr as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_map_request )
                , "::" , stringify ! ( memattr ) ));
}
impl Clone for resource_map_request {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn resource_init_map_request_impl(_args: *mut resource_map_request,
                                          _sz: usize);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct resource {
    _unused: [u8; 0],
}
/// @brief An entry for a single resource in a resource list.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct resource_list_entry {
    pub link: resource_list_entry__bindgen_ty_1,
    /// < @brief type argument to alloc_resource
    pub type_: ::std::os::raw::c_int,
    /// < @brief resource identifier
    pub rid: ::std::os::raw::c_int,
    /// < @brief resource flags
    pub flags: ::std::os::raw::c_int,
    /// < @brief the real resource when allocated
    pub res: *mut resource,
    /// < @brief start of resource range
    pub start: rman_res_t,
    /// < @brief end of resource range
    pub end: rman_res_t,
    /// < @brief count within range
    pub count: rman_res_t,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct resource_list_entry__bindgen_ty_1 {
    pub stqe_next: *mut resource_list_entry,
}
#[test]
fn bindgen_test_layout_resource_list_entry__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<resource_list_entry__bindgen_ty_1>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( resource_list_entry__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<resource_list_entry__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                resource_list_entry__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_list_entry__bindgen_ty_1 ) ) .
                stqe_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                resource_list_entry__bindgen_ty_1 ) , "::" , stringify ! (
                stqe_next ) ));
}
impl Clone for resource_list_entry__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for resource_list_entry__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_resource_list_entry() {
    assert_eq!(::std::mem::size_of::<resource_list_entry>() , 56usize , concat
               ! ( "Size of: " , stringify ! ( resource_list_entry ) ));
    assert_eq! (::std::mem::align_of::<resource_list_entry>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( resource_list_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_list_entry ) ) . link as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_list_entry ) ,
                "::" , stringify ! ( link ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_list_entry ) ) . type_ as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_list_entry ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_list_entry ) ) . rid as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_list_entry ) ,
                "::" , stringify ! ( rid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_list_entry ) ) . flags as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_list_entry ) ,
                "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_list_entry ) ) . res as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_list_entry ) ,
                "::" , stringify ! ( res ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_list_entry ) ) . start as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_list_entry ) ,
                "::" , stringify ! ( start ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_list_entry ) ) . end as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_list_entry ) ,
                "::" , stringify ! ( end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_list_entry ) ) . count as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_list_entry ) ,
                "::" , stringify ! ( count ) ));
}
impl Clone for resource_list_entry {
    fn clone(&self) -> Self { *self }
}
impl Default for resource_list_entry {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct resource_list {
    pub stqh_first: *mut resource_list_entry,
    pub stqh_last: *mut *mut resource_list_entry,
}
#[test]
fn bindgen_test_layout_resource_list() {
    assert_eq!(::std::mem::size_of::<resource_list>() , 16usize , concat ! (
               "Size of: " , stringify ! ( resource_list ) ));
    assert_eq! (::std::mem::align_of::<resource_list>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( resource_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_list ) ) . stqh_first as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_list ) , "::"
                , stringify ! ( stqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_list ) ) . stqh_last as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_list ) , "::"
                , stringify ! ( stqh_last ) ));
}
impl Clone for resource_list {
    fn clone(&self) -> Self { *self }
}
impl Default for resource_list {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
extern "C" {
    pub fn resource_list_init(rl: *mut resource_list);
}
extern "C" {
    pub fn resource_list_free(rl: *mut resource_list);
}
extern "C" {
    pub fn resource_list_add(rl: *mut resource_list,
                             type_: ::std::os::raw::c_int,
                             rid: ::std::os::raw::c_int, start: rman_res_t,
                             end: rman_res_t, count: rman_res_t)
     -> *mut resource_list_entry;
}
extern "C" {
    pub fn resource_list_add_next(rl: *mut resource_list,
                                  type_: ::std::os::raw::c_int,
                                  start: rman_res_t, end: rman_res_t,
                                  count: rman_res_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn resource_list_busy(rl: *mut resource_list,
                              type_: ::std::os::raw::c_int,
                              rid: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn resource_list_reserved(rl: *mut resource_list,
                                  type_: ::std::os::raw::c_int,
                                  rid: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn resource_list_find(rl: *mut resource_list,
                              type_: ::std::os::raw::c_int,
                              rid: ::std::os::raw::c_int)
     -> *mut resource_list_entry;
}
extern "C" {
    pub fn resource_list_delete(rl: *mut resource_list,
                                type_: ::std::os::raw::c_int,
                                rid: ::std::os::raw::c_int);
}
extern "C" {
    pub fn resource_list_alloc(rl: *mut resource_list, bus: device_t,
                               child: device_t, type_: ::std::os::raw::c_int,
                               rid: *mut ::std::os::raw::c_int,
                               start: rman_res_t, end: rman_res_t,
                               count: rman_res_t, flags: u_int)
     -> *mut resource;
}
extern "C" {
    pub fn resource_list_release(rl: *mut resource_list, bus: device_t,
                                 child: device_t,
                                 type_: ::std::os::raw::c_int,
                                 rid: ::std::os::raw::c_int,
                                 res: *mut resource) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn resource_list_release_active(rl: *mut resource_list, bus: device_t,
                                        child: device_t,
                                        type_: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn resource_list_reserve(rl: *mut resource_list, bus: device_t,
                                 child: device_t,
                                 type_: ::std::os::raw::c_int,
                                 rid: *mut ::std::os::raw::c_int,
                                 start: rman_res_t, end: rman_res_t,
                                 count: rman_res_t, flags: u_int)
     -> *mut resource;
}
extern "C" {
    pub fn resource_list_unreserve(rl: *mut resource_list, bus: device_t,
                                   child: device_t,
                                   type_: ::std::os::raw::c_int,
                                   rid: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn resource_list_purge(rl: *mut resource_list);
}
extern "C" {
    pub fn resource_list_print_type(rl: *mut resource_list,
                                    name: *const ::std::os::raw::c_char,
                                    type_: ::std::os::raw::c_int,
                                    format: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "root_bus"]
    pub static mut root_bus: device_t;
}
extern "C" {
    #[link_name = "root_devclass"]
    pub static mut root_devclass: devclass_t;
}
extern "C" {
    pub fn root_bus_configure();
}
extern "C" {
    pub fn bus_generic_activate_resource(dev: device_t, child: device_t,
                                         type_: ::std::os::raw::c_int,
                                         rid: ::std::os::raw::c_int,
                                         r: *mut resource)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bus_generic_add_child(dev: device_t, order: u_int,
                                 name: *const ::std::os::raw::c_char,
                                 unit: ::std::os::raw::c_int) -> device_t;
}
extern "C" {
    pub fn bus_generic_adjust_resource(bus: device_t, child: device_t,
                                       type_: ::std::os::raw::c_int,
                                       r: *mut resource, start: rman_res_t,
                                       end: rman_res_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bus_generic_alloc_resource(bus: device_t, child: device_t,
                                      type_: ::std::os::raw::c_int,
                                      rid: *mut ::std::os::raw::c_int,
                                      start: rman_res_t, end: rman_res_t,
                                      count: rman_res_t, flags: u_int)
     -> *mut resource;
}
extern "C" {
    pub fn bus_generic_attach(dev: device_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bus_generic_bind_intr(dev: device_t, child: device_t,
                                 irq: *mut resource,
                                 cpu: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bus_generic_child_present(dev: device_t, child: device_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bus_generic_config_intr(arg1: device_t,
                                   arg2: ::std::os::raw::c_int,
                                   arg3: intr_trigger, arg4: intr_polarity)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bus_generic_describe_intr(dev: device_t, child: device_t,
                                     irq: *mut resource,
                                     cookie: *mut ::std::os::raw::c_void,
                                     descr: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bus_generic_deactivate_resource(dev: device_t, child: device_t,
                                           type_: ::std::os::raw::c_int,
                                           rid: ::std::os::raw::c_int,
                                           r: *mut resource)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bus_generic_detach(dev: device_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bus_generic_driver_added(dev: device_t, driver: *mut driver_t);
}
extern "C" {
    pub fn bus_generic_get_cpus(dev: device_t, child: device_t, op: cpu_sets,
                                setsize: usize, cpuset: *mut _cpuset)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bus_generic_get_dma_tag(dev: device_t, child: device_t)
     -> bus_dma_tag_t;
}
extern "C" {
    pub fn bus_generic_get_bus_tag(dev: device_t, child: device_t)
     -> bus_space_tag_t;
}
extern "C" {
    pub fn bus_generic_get_domain(dev: device_t, child: device_t,
                                  domain: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bus_generic_get_resource_list(arg1: device_t, arg2: device_t)
     -> *mut resource_list;
}
extern "C" {
    pub fn bus_generic_map_resource(dev: device_t, child: device_t,
                                    type_: ::std::os::raw::c_int,
                                    r: *mut resource,
                                    args: *mut resource_map_request,
                                    map: *mut resource_map)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bus_generic_new_pass(dev: device_t);
}
extern "C" {
    pub fn bus_print_child_header(dev: device_t, child: device_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bus_print_child_domain(dev: device_t, child: device_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bus_print_child_footer(dev: device_t, child: device_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bus_generic_print_child(dev: device_t, child: device_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bus_generic_probe(dev: device_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bus_generic_read_ivar(dev: device_t, child: device_t,
                                 which: ::std::os::raw::c_int,
                                 result: *mut usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bus_generic_release_resource(bus: device_t, child: device_t,
                                        type_: ::std::os::raw::c_int,
                                        rid: ::std::os::raw::c_int,
                                        r: *mut resource)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bus_generic_resume(dev: device_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bus_generic_resume_child(dev: device_t, child: device_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bus_generic_setup_intr(dev: device_t, child: device_t,
                                  irq: *mut resource,
                                  flags: ::std::os::raw::c_int,
                                  filter: driver_filter_t,
                                  intr: driver_intr_t,
                                  arg: *mut ::std::os::raw::c_void,
                                  cookiep: *mut *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bus_generic_rl_alloc_resource(arg1: device_t, arg2: device_t,
                                         arg3: ::std::os::raw::c_int,
                                         arg4: *mut ::std::os::raw::c_int,
                                         arg5: rman_res_t, arg6: rman_res_t,
                                         arg7: rman_res_t, arg8: u_int)
     -> *mut resource;
}
extern "C" {
    pub fn bus_generic_rl_delete_resource(arg1: device_t, arg2: device_t,
                                          arg3: ::std::os::raw::c_int,
                                          arg4: ::std::os::raw::c_int);
}
extern "C" {
    pub fn bus_generic_rl_get_resource(arg1: device_t, arg2: device_t,
                                       arg3: ::std::os::raw::c_int,
                                       arg4: ::std::os::raw::c_int,
                                       arg5: *mut rman_res_t,
                                       arg6: *mut rman_res_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bus_generic_rl_set_resource(arg1: device_t, arg2: device_t,
                                       arg3: ::std::os::raw::c_int,
                                       arg4: ::std::os::raw::c_int,
                                       arg5: rman_res_t, arg6: rman_res_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bus_generic_rl_release_resource(arg1: device_t, arg2: device_t,
                                           arg3: ::std::os::raw::c_int,
                                           arg4: ::std::os::raw::c_int,
                                           arg5: *mut resource)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bus_generic_shutdown(dev: device_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bus_generic_suspend(dev: device_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bus_generic_suspend_child(dev: device_t, child: device_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bus_generic_teardown_intr(dev: device_t, child: device_t,
                                     irq: *mut resource,
                                     cookie: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bus_generic_unmap_resource(dev: device_t, child: device_t,
                                      type_: ::std::os::raw::c_int,
                                      r: *mut resource,
                                      map: *mut resource_map)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bus_generic_write_ivar(dev: device_t, child: device_t,
                                  which: ::std::os::raw::c_int, value: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bus_null_rescan(dev: device_t) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct resource_spec {
    pub type_: ::std::os::raw::c_int,
    pub rid: ::std::os::raw::c_int,
    pub flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_resource_spec() {
    assert_eq!(::std::mem::size_of::<resource_spec>() , 12usize , concat ! (
               "Size of: " , stringify ! ( resource_spec ) ));
    assert_eq! (::std::mem::align_of::<resource_spec>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( resource_spec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_spec ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_spec ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_spec ) ) . rid as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_spec ) , "::"
                , stringify ! ( rid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_spec ) ) . flags as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_spec ) , "::"
                , stringify ! ( flags ) ));
}
impl Clone for resource_spec {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn bus_alloc_resources(dev: device_t, rs: *mut resource_spec,
                               res: *mut *mut resource)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bus_release_resources(dev: device_t, rs: *const resource_spec,
                                 res: *mut *mut resource);
}
extern "C" {
    pub fn bus_adjust_resource(child: device_t, type_: ::std::os::raw::c_int,
                               r: *mut resource, start: rman_res_t,
                               end: rman_res_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bus_alloc_resource(dev: device_t, type_: ::std::os::raw::c_int,
                              rid: *mut ::std::os::raw::c_int,
                              start: rman_res_t, end: rman_res_t,
                              count: rman_res_t, flags: u_int)
     -> *mut resource;
}
extern "C" {
    pub fn bus_activate_resource(dev: device_t, type_: ::std::os::raw::c_int,
                                 rid: ::std::os::raw::c_int, r: *mut resource)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bus_deactivate_resource(dev: device_t,
                                   type_: ::std::os::raw::c_int,
                                   rid: ::std::os::raw::c_int,
                                   r: *mut resource) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bus_map_resource(dev: device_t, type_: ::std::os::raw::c_int,
                            r: *mut resource, args: *mut resource_map_request,
                            map: *mut resource_map) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bus_unmap_resource(dev: device_t, type_: ::std::os::raw::c_int,
                              r: *mut resource, map: *mut resource_map)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bus_get_cpus(dev: device_t, op: cpu_sets, setsize: usize,
                        cpuset: *mut _cpuset) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bus_get_dma_tag(dev: device_t) -> bus_dma_tag_t;
}
extern "C" {
    pub fn bus_get_bus_tag(dev: device_t) -> bus_space_tag_t;
}
extern "C" {
    pub fn bus_get_domain(dev: device_t, domain: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bus_release_resource(dev: device_t, type_: ::std::os::raw::c_int,
                                rid: ::std::os::raw::c_int, r: *mut resource)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bus_free_resource(dev: device_t, type_: ::std::os::raw::c_int,
                             r: *mut resource) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bus_setup_intr(dev: device_t, r: *mut resource,
                          flags: ::std::os::raw::c_int,
                          filter: driver_filter_t, handler: driver_intr_t,
                          arg: *mut ::std::os::raw::c_void,
                          cookiep: *mut *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bus_teardown_intr(dev: device_t, r: *mut resource,
                             cookie: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bus_bind_intr(dev: device_t, r: *mut resource,
                         cpu: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bus_describe_intr(dev: device_t, irq: *mut resource,
                             cookie: *mut ::std::os::raw::c_void,
                             fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bus_set_resource(dev: device_t, type_: ::std::os::raw::c_int,
                            rid: ::std::os::raw::c_int, start: rman_res_t,
                            count: rman_res_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bus_get_resource(dev: device_t, type_: ::std::os::raw::c_int,
                            rid: ::std::os::raw::c_int,
                            startp: *mut rman_res_t, countp: *mut rman_res_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bus_get_resource_start(dev: device_t, type_: ::std::os::raw::c_int,
                                  rid: ::std::os::raw::c_int) -> rman_res_t;
}
extern "C" {
    pub fn bus_get_resource_count(dev: device_t, type_: ::std::os::raw::c_int,
                                  rid: ::std::os::raw::c_int) -> rman_res_t;
}
extern "C" {
    pub fn bus_delete_resource(dev: device_t, type_: ::std::os::raw::c_int,
                               rid: ::std::os::raw::c_int);
}
extern "C" {
    pub fn bus_child_present(child: device_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bus_child_pnpinfo_str(child: device_t,
                                 buf: *mut ::std::os::raw::c_char,
                                 buflen: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bus_child_location_str(child: device_t,
                                  buf: *mut ::std::os::raw::c_char,
                                  buflen: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bus_enumerate_hinted_children(bus: device_t);
}
extern "C" {
    pub fn device_add_child(dev: device_t,
                            name: *const ::std::os::raw::c_char,
                            unit: ::std::os::raw::c_int) -> device_t;
}
extern "C" {
    pub fn device_add_child_ordered(dev: device_t, order: u_int,
                                    name: *const ::std::os::raw::c_char,
                                    unit: ::std::os::raw::c_int) -> device_t;
}
extern "C" {
    pub fn device_busy(dev: device_t);
}
extern "C" {
    pub fn device_delete_child(dev: device_t, child: device_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn device_delete_children(dev: device_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn device_attach(dev: device_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn device_detach(dev: device_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn device_disable(dev: device_t);
}
extern "C" {
    pub fn device_enable(dev: device_t);
}
extern "C" {
    pub fn device_find_child(dev: device_t,
                             classname: *const ::std::os::raw::c_char,
                             unit: ::std::os::raw::c_int) -> device_t;
}
extern "C" {
    pub fn device_get_desc(dev: device_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn device_get_devclass(dev: device_t) -> devclass_t;
}
extern "C" {
    pub fn device_get_driver(dev: device_t) -> *mut driver_t;
}
extern "C" {
    pub fn device_get_flags(dev: device_t) -> u_int32_t;
}
extern "C" {
    pub fn device_get_parent(dev: device_t) -> device_t;
}
extern "C" {
    pub fn device_get_children(dev: device_t, listp: *mut *mut device_t,
                               countp: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn device_get_ivars(dev: device_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn device_set_ivars(dev: device_t,
                            ivars: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn device_get_name(dev: device_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn device_get_nameunit(dev: device_t)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn device_get_softc(dev: device_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn device_get_state(dev: device_t) -> device_state_t;
}
extern "C" {
    pub fn device_get_unit(dev: device_t) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sysctl_ctx_list {
    _unused: [u8; 0],
}
extern "C" {
    pub fn device_get_sysctl_ctx(dev: device_t) -> *mut sysctl_ctx_list;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sysctl_oid {
    _unused: [u8; 0],
}
extern "C" {
    pub fn device_get_sysctl_tree(dev: device_t) -> *mut sysctl_oid;
}
extern "C" {
    pub fn device_is_alive(dev: device_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn device_is_attached(dev: device_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn device_is_enabled(dev: device_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn device_is_suspended(dev: device_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn device_is_quiet(dev: device_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn device_lookup_by_name(name: *const ::std::os::raw::c_char)
     -> device_t;
}
extern "C" {
    pub fn device_print_prettyname(dev: device_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn device_printf(dev: device_t,
                         arg1: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn device_probe(dev: device_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn device_probe_and_attach(dev: device_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn device_probe_child(bus: device_t, dev: device_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn device_quiesce(dev: device_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn device_quiet(dev: device_t);
}
extern "C" {
    pub fn device_set_desc(dev: device_t,
                           desc: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn device_set_desc_copy(dev: device_t,
                                desc: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn device_set_devclass(dev: device_t,
                               classname: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn device_set_devclass_fixed(dev: device_t,
                                     classname: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn device_set_driver(dev: device_t, driver: *mut driver_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn device_set_flags(dev: device_t, flags: u_int32_t);
}
extern "C" {
    pub fn device_set_softc(dev: device_t,
                            softc: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn device_free_softc(softc: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn device_claim_softc(dev: device_t);
}
extern "C" {
    pub fn device_set_unit(dev: device_t, unit: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn device_shutdown(dev: device_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn device_unbusy(dev: device_t);
}
extern "C" {
    pub fn device_verbose(dev: device_t);
}
extern "C" {
    pub fn devclass_add_driver(dc: devclass_t, driver: *mut driver_t,
                               pass: ::std::os::raw::c_int,
                               dcp: *mut devclass_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn devclass_create(classname: *const ::std::os::raw::c_char)
     -> devclass_t;
}
extern "C" {
    pub fn devclass_delete_driver(busclass: devclass_t, driver: *mut driver_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn devclass_find(classname: *const ::std::os::raw::c_char)
     -> devclass_t;
}
extern "C" {
    pub fn devclass_get_name(dc: devclass_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn devclass_get_device(dc: devclass_t, unit: ::std::os::raw::c_int)
     -> device_t;
}
extern "C" {
    pub fn devclass_get_softc(dc: devclass_t, unit: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn devclass_get_devices(dc: devclass_t, listp: *mut *mut device_t,
                                countp: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn devclass_get_drivers(dc: devclass_t,
                                listp: *mut *mut *mut driver_t,
                                countp: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn devclass_get_count(dc: devclass_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn devclass_get_maxunit(dc: devclass_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn devclass_find_free_unit(dc: devclass_t,
                                   unit: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn devclass_set_parent(dc: devclass_t, pdc: devclass_t);
}
extern "C" {
    pub fn devclass_get_parent(dc: devclass_t) -> devclass_t;
}
extern "C" {
    pub fn devclass_get_sysctl_ctx(dc: devclass_t) -> *mut sysctl_ctx_list;
}
extern "C" {
    pub fn devclass_get_sysctl_tree(dc: devclass_t) -> *mut sysctl_oid;
}
extern "C" {
    pub fn resource_int_value(name: *const ::std::os::raw::c_char,
                              unit: ::std::os::raw::c_int,
                              resname: *const ::std::os::raw::c_char,
                              result: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn resource_long_value(name: *const ::std::os::raw::c_char,
                               unit: ::std::os::raw::c_int,
                               resname: *const ::std::os::raw::c_char,
                               result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn resource_string_value(name: *const ::std::os::raw::c_char,
                                 unit: ::std::os::raw::c_int,
                                 resname: *const ::std::os::raw::c_char,
                                 result: *mut *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn resource_disabled(name: *const ::std::os::raw::c_char,
                             unit: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn resource_find_match(anchor: *mut ::std::os::raw::c_int,
                               name: *mut *const ::std::os::raw::c_char,
                               unit: *mut ::std::os::raw::c_int,
                               resname: *const ::std::os::raw::c_char,
                               value: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn resource_find_dev(anchor: *mut ::std::os::raw::c_int,
                             name: *const ::std::os::raw::c_char,
                             unit: *mut ::std::os::raw::c_int,
                             resname: *const ::std::os::raw::c_char,
                             value: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn resource_unset_value(name: *const ::std::os::raw::c_char,
                                unit: ::std::os::raw::c_int,
                                resname: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bus_data_generation_check(generation: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bus_data_generation_update();
}
extern "C" {
    #[link_name = "bus_current_pass"]
    pub static mut bus_current_pass: ::std::os::raw::c_int;
}
extern "C" {
    pub fn bus_set_pass(pass: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "device_probe_desc"]
    pub static mut device_probe_desc: kobjop_desc;
}
/// @brief A function implementing the DEVICE_PROBE() method
pub type device_probe_t =
    ::std::option::Option<unsafe extern "C" fn(dev: device_t)
                              -> ::std::os::raw::c_int>;
extern "C" {
    #[link_name = "device_identify_desc"]
    pub static mut device_identify_desc: kobjop_desc;
}
/// @brief A function implementing the DEVICE_IDENTIFY() method
pub type device_identify_t =
    ::std::option::Option<unsafe extern "C" fn(driver: *mut driver_t,
                                               parent: device_t)>;
extern "C" {
    #[link_name = "device_attach_desc"]
    pub static mut device_attach_desc: kobjop_desc;
}
/// @brief A function implementing the DEVICE_ATTACH() method
pub type device_attach_t =
    ::std::option::Option<unsafe extern "C" fn(dev: device_t)
                              -> ::std::os::raw::c_int>;
extern "C" {
    #[link_name = "device_detach_desc"]
    pub static mut device_detach_desc: kobjop_desc;
}
/// @brief A function implementing the DEVICE_DETACH() method
pub type device_detach_t =
    ::std::option::Option<unsafe extern "C" fn(dev: device_t)
                              -> ::std::os::raw::c_int>;
extern "C" {
    #[link_name = "device_shutdown_desc"]
    pub static mut device_shutdown_desc: kobjop_desc;
}
/// @brief A function implementing the DEVICE_SHUTDOWN() method
pub type device_shutdown_t =
    ::std::option::Option<unsafe extern "C" fn(dev: device_t)
                              -> ::std::os::raw::c_int>;
extern "C" {
    #[link_name = "device_suspend_desc"]
    pub static mut device_suspend_desc: kobjop_desc;
}
/// @brief A function implementing the DEVICE_SUSPEND() method
pub type device_suspend_t =
    ::std::option::Option<unsafe extern "C" fn(dev: device_t)
                              -> ::std::os::raw::c_int>;
extern "C" {
    #[link_name = "device_resume_desc"]
    pub static mut device_resume_desc: kobjop_desc;
}
/// @brief A function implementing the DEVICE_RESUME() method
pub type device_resume_t =
    ::std::option::Option<unsafe extern "C" fn(dev: device_t)
                              -> ::std::os::raw::c_int>;
extern "C" {
    #[link_name = "device_quiesce_desc"]
    pub static mut device_quiesce_desc: kobjop_desc;
}
/// @brief A function implementing the DEVICE_QUIESCE() method
pub type device_quiesce_t =
    ::std::option::Option<unsafe extern "C" fn(dev: device_t)
                              -> ::std::os::raw::c_int>;
extern "C" {
    #[link_name = "device_register_desc"]
    pub static mut device_register_desc: kobjop_desc;
}
/// @brief A function implementing the DEVICE_REGISTER() method
pub type device_register_t =
    ::std::option::Option<unsafe extern "C" fn(dev: device_t)
                              -> *mut ::std::os::raw::c_void>;
extern "C" {
    #[link_name = "bus_print_child_desc"]
    pub static mut bus_print_child_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_PRINT_CHILD() method
pub type bus_print_child_t =
    ::std::option::Option<unsafe extern "C" fn(_dev: device_t,
                                               _child: device_t)
                              -> ::std::os::raw::c_int>;
extern "C" {
    #[link_name = "bus_probe_nomatch_desc"]
    pub static mut bus_probe_nomatch_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_PROBE_NOMATCH() method
pub type bus_probe_nomatch_t =
    ::std::option::Option<unsafe extern "C" fn(_dev: device_t,
                                               _child: device_t)>;
extern "C" {
    #[link_name = "bus_read_ivar_desc"]
    pub static mut bus_read_ivar_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_READ_IVAR() method
pub type bus_read_ivar_t =
    ::std::option::Option<unsafe extern "C" fn(_dev: device_t,
                                               _child: device_t,
                                               _index: ::std::os::raw::c_int,
                                               _result: *mut usize)
                              -> ::std::os::raw::c_int>;
extern "C" {
    #[link_name = "bus_write_ivar_desc"]
    pub static mut bus_write_ivar_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_WRITE_IVAR() method
pub type bus_write_ivar_t =
    ::std::option::Option<unsafe extern "C" fn(_dev: device_t,
                                               _child: device_t,
                                               _indx: ::std::os::raw::c_int,
                                               _value: usize)
                              -> ::std::os::raw::c_int>;
extern "C" {
    #[link_name = "bus_child_deleted_desc"]
    pub static mut bus_child_deleted_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_CHILD_DELETED() method
pub type bus_child_deleted_t =
    ::std::option::Option<unsafe extern "C" fn(_dev: device_t,
                                               _child: device_t)>;
extern "C" {
    #[link_name = "bus_child_detached_desc"]
    pub static mut bus_child_detached_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_CHILD_DETACHED() method
pub type bus_child_detached_t =
    ::std::option::Option<unsafe extern "C" fn(_dev: device_t,
                                               _child: device_t)>;
extern "C" {
    #[link_name = "bus_driver_added_desc"]
    pub static mut bus_driver_added_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_DRIVER_ADDED() method
pub type bus_driver_added_t =
    ::std::option::Option<unsafe extern "C" fn(_dev: device_t,
                                               _driver: *mut driver_t)>;
extern "C" {
    #[link_name = "bus_add_child_desc"]
    pub static mut bus_add_child_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_ADD_CHILD() method
pub type bus_add_child_t =
    ::std::option::Option<unsafe extern "C" fn(_dev: device_t, _order: u_int,
                                               _name:
                                                   *const ::std::os::raw::c_char,
                                               _unit: ::std::os::raw::c_int)
                              -> device_t>;
extern "C" {
    #[link_name = "bus_rescan_desc"]
    pub static mut bus_rescan_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_RESCAN() method
pub type bus_rescan_t =
    ::std::option::Option<unsafe extern "C" fn(_dev: device_t)
                              -> ::std::os::raw::c_int>;
extern "C" {
    #[link_name = "bus_alloc_resource_desc"]
    pub static mut bus_alloc_resource_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_ALLOC_RESOURCE() method
pub type bus_alloc_resource_t =
    ::std::option::Option<unsafe extern "C" fn(_dev: device_t,
                                               _child: device_t,
                                               _type: ::std::os::raw::c_int,
                                               _rid:
                                                   *mut ::std::os::raw::c_int,
                                               _start: rman_res_t,
                                               _end: rman_res_t,
                                               _count: rman_res_t,
                                               _flags: u_int)
                              -> *mut resource>;
extern "C" {
    #[link_name = "bus_activate_resource_desc"]
    pub static mut bus_activate_resource_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_ACTIVATE_RESOURCE() method
pub type bus_activate_resource_t =
    ::std::option::Option<unsafe extern "C" fn(_dev: device_t,
                                               _child: device_t,
                                               _type: ::std::os::raw::c_int,
                                               _rid: ::std::os::raw::c_int,
                                               _r: *mut resource)
                              -> ::std::os::raw::c_int>;
extern "C" {
    #[link_name = "bus_map_resource_desc"]
    pub static mut bus_map_resource_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_MAP_RESOURCE() method
pub type bus_map_resource_t =
    ::std::option::Option<unsafe extern "C" fn(_dev: device_t,
                                               _child: device_t,
                                               _type: ::std::os::raw::c_int,
                                               _r: *mut resource,
                                               _args:
                                                   *mut resource_map_request,
                                               _map: *mut resource_map)
                              -> ::std::os::raw::c_int>;
extern "C" {
    #[link_name = "bus_unmap_resource_desc"]
    pub static mut bus_unmap_resource_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_UNMAP_RESOURCE() method
pub type bus_unmap_resource_t =
    ::std::option::Option<unsafe extern "C" fn(_dev: device_t,
                                               _child: device_t,
                                               _type: ::std::os::raw::c_int,
                                               _r: *mut resource,
                                               _map: *mut resource_map)
                              -> ::std::os::raw::c_int>;
extern "C" {
    #[link_name = "bus_deactivate_resource_desc"]
    pub static mut bus_deactivate_resource_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_DEACTIVATE_RESOURCE() method
pub type bus_deactivate_resource_t =
    ::std::option::Option<unsafe extern "C" fn(_dev: device_t,
                                               _child: device_t,
                                               _type: ::std::os::raw::c_int,
                                               _rid: ::std::os::raw::c_int,
                                               _r: *mut resource)
                              -> ::std::os::raw::c_int>;
extern "C" {
    #[link_name = "bus_adjust_resource_desc"]
    pub static mut bus_adjust_resource_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_ADJUST_RESOURCE() method
pub type bus_adjust_resource_t =
    ::std::option::Option<unsafe extern "C" fn(_dev: device_t,
                                               _child: device_t,
                                               _type: ::std::os::raw::c_int,
                                               _res: *mut resource,
                                               _start: rman_res_t,
                                               _end: rman_res_t)
                              -> ::std::os::raw::c_int>;
extern "C" {
    #[link_name = "bus_release_resource_desc"]
    pub static mut bus_release_resource_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_RELEASE_RESOURCE() method
pub type bus_release_resource_t =
    ::std::option::Option<unsafe extern "C" fn(_dev: device_t,
                                               _child: device_t,
                                               _type: ::std::os::raw::c_int,
                                               _rid: ::std::os::raw::c_int,
                                               _res: *mut resource)
                              -> ::std::os::raw::c_int>;
extern "C" {
    #[link_name = "bus_setup_intr_desc"]
    pub static mut bus_setup_intr_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_SETUP_INTR() method
pub type bus_setup_intr_t =
    ::std::option::Option<unsafe extern "C" fn(_dev: device_t,
                                               _child: device_t,
                                               _irq: *mut resource,
                                               _flags: ::std::os::raw::c_int,
                                               _filter: driver_filter_t,
                                               _intr: driver_intr_t,
                                               _arg:
                                                   *mut ::std::os::raw::c_void,
                                               _cookiep:
                                                   *mut *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
extern "C" {
    #[link_name = "bus_teardown_intr_desc"]
    pub static mut bus_teardown_intr_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_TEARDOWN_INTR() method
pub type bus_teardown_intr_t =
    ::std::option::Option<unsafe extern "C" fn(_dev: device_t,
                                               _child: device_t,
                                               _irq: *mut resource,
                                               _cookie:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
extern "C" {
    #[link_name = "bus_set_resource_desc"]
    pub static mut bus_set_resource_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_SET_RESOURCE() method
pub type bus_set_resource_t =
    ::std::option::Option<unsafe extern "C" fn(_dev: device_t,
                                               _child: device_t,
                                               _type: ::std::os::raw::c_int,
                                               _rid: ::std::os::raw::c_int,
                                               _start: rman_res_t,
                                               _count: rman_res_t)
                              -> ::std::os::raw::c_int>;
extern "C" {
    #[link_name = "bus_get_resource_desc"]
    pub static mut bus_get_resource_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_GET_RESOURCE() method
pub type bus_get_resource_t =
    ::std::option::Option<unsafe extern "C" fn(_dev: device_t,
                                               _child: device_t,
                                               _type: ::std::os::raw::c_int,
                                               _rid: ::std::os::raw::c_int,
                                               _startp: *mut rman_res_t,
                                               _countp: *mut rman_res_t)
                              -> ::std::os::raw::c_int>;
extern "C" {
    #[link_name = "bus_delete_resource_desc"]
    pub static mut bus_delete_resource_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_DELETE_RESOURCE() method
pub type bus_delete_resource_t =
    ::std::option::Option<unsafe extern "C" fn(_dev: device_t,
                                               _child: device_t,
                                               _type: ::std::os::raw::c_int,
                                               _rid: ::std::os::raw::c_int)>;
extern "C" {
    #[link_name = "bus_get_resource_list_desc"]
    pub static mut bus_get_resource_list_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_GET_RESOURCE_LIST() method
pub type bus_get_resource_list_t =
    ::std::option::Option<unsafe extern "C" fn(_dev: device_t,
                                               _child: device_t)
                              -> *mut resource_list>;
extern "C" {
    #[link_name = "bus_child_present_desc"]
    pub static mut bus_child_present_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_CHILD_PRESENT() method
pub type bus_child_present_t =
    ::std::option::Option<unsafe extern "C" fn(_dev: device_t,
                                               _child: device_t)
                              -> ::std::os::raw::c_int>;
extern "C" {
    #[link_name = "bus_child_pnpinfo_str_desc"]
    pub static mut bus_child_pnpinfo_str_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_CHILD_PNPINFO_STR() method
pub type bus_child_pnpinfo_str_t =
    ::std::option::Option<unsafe extern "C" fn(_dev: device_t,
                                               _child: device_t,
                                               _buf:
                                                   *mut ::std::os::raw::c_char,
                                               _buflen: usize)
                              -> ::std::os::raw::c_int>;
extern "C" {
    #[link_name = "bus_child_location_str_desc"]
    pub static mut bus_child_location_str_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_CHILD_LOCATION_STR() method
pub type bus_child_location_str_t =
    ::std::option::Option<unsafe extern "C" fn(_dev: device_t,
                                               _child: device_t,
                                               _buf:
                                                   *mut ::std::os::raw::c_char,
                                               _buflen: usize)
                              -> ::std::os::raw::c_int>;
extern "C" {
    #[link_name = "bus_bind_intr_desc"]
    pub static mut bus_bind_intr_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_BIND_INTR() method
pub type bus_bind_intr_t =
    ::std::option::Option<unsafe extern "C" fn(_dev: device_t,
                                               _child: device_t,
                                               _irq: *mut resource,
                                               _cpu: ::std::os::raw::c_int)
                              -> ::std::os::raw::c_int>;
extern "C" {
    #[link_name = "bus_config_intr_desc"]
    pub static mut bus_config_intr_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_CONFIG_INTR() method
pub type bus_config_intr_t =
    ::std::option::Option<unsafe extern "C" fn(_dev: device_t,
                                               _irq: ::std::os::raw::c_int,
                                               _trig: intr_trigger,
                                               _pol: intr_polarity)
                              -> ::std::os::raw::c_int>;
extern "C" {
    #[link_name = "bus_describe_intr_desc"]
    pub static mut bus_describe_intr_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_DESCRIBE_INTR() method
pub type bus_describe_intr_t =
    ::std::option::Option<unsafe extern "C" fn(_dev: device_t,
                                               _child: device_t,
                                               _irq: *mut resource,
                                               _cookie:
                                                   *mut ::std::os::raw::c_void,
                                               _descr:
                                                   *const ::std::os::raw::c_char)
                              -> ::std::os::raw::c_int>;
extern "C" {
    #[link_name = "bus_hinted_child_desc"]
    pub static mut bus_hinted_child_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_HINTED_CHILD() method
pub type bus_hinted_child_t =
    ::std::option::Option<unsafe extern "C" fn(_dev: device_t,
                                               _dname:
                                                   *const ::std::os::raw::c_char,
                                               _dunit:
                                                   ::std::os::raw::c_int)>;
extern "C" {
    #[link_name = "bus_get_dma_tag_desc"]
    pub static mut bus_get_dma_tag_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_GET_DMA_TAG() method
pub type bus_get_dma_tag_t =
    ::std::option::Option<unsafe extern "C" fn(_dev: device_t,
                                               _child: device_t)
                              -> bus_dma_tag_t>;
extern "C" {
    #[link_name = "bus_get_bus_tag_desc"]
    pub static mut bus_get_bus_tag_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_GET_BUS_TAG() method
pub type bus_get_bus_tag_t =
    ::std::option::Option<unsafe extern "C" fn(_dev: device_t,
                                               _child: device_t)
                              -> bus_space_tag_t>;
extern "C" {
    #[link_name = "bus_hint_device_unit_desc"]
    pub static mut bus_hint_device_unit_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_HINT_DEVICE_UNIT() method
pub type bus_hint_device_unit_t =
    ::std::option::Option<unsafe extern "C" fn(_dev: device_t,
                                               _child: device_t,
                                               _name:
                                                   *const ::std::os::raw::c_char,
                                               _unitp:
                                                   *mut ::std::os::raw::c_int)>;
extern "C" {
    #[link_name = "bus_new_pass_desc"]
    pub static mut bus_new_pass_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_NEW_PASS() method
pub type bus_new_pass_t =
    ::std::option::Option<unsafe extern "C" fn(_dev: device_t)>;
extern "C" {
    #[link_name = "bus_remap_intr_desc"]
    pub static mut bus_remap_intr_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_REMAP_INTR() method
pub type bus_remap_intr_t =
    ::std::option::Option<unsafe extern "C" fn(_dev: device_t,
                                               _child: device_t, _irq: u_int)
                              -> ::std::os::raw::c_int>;
extern "C" {
    #[link_name = "bus_suspend_child_desc"]
    pub static mut bus_suspend_child_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_SUSPEND_CHILD() method
pub type bus_suspend_child_t =
    ::std::option::Option<unsafe extern "C" fn(_dev: device_t,
                                               _child: device_t)
                              -> ::std::os::raw::c_int>;
extern "C" {
    #[link_name = "bus_resume_child_desc"]
    pub static mut bus_resume_child_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_RESUME_CHILD() method
pub type bus_resume_child_t =
    ::std::option::Option<unsafe extern "C" fn(_dev: device_t,
                                               _child: device_t)
                              -> ::std::os::raw::c_int>;
extern "C" {
    #[link_name = "bus_get_domain_desc"]
    pub static mut bus_get_domain_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_GET_DOMAIN() method
pub type bus_get_domain_t =
    ::std::option::Option<unsafe extern "C" fn(_dev: device_t,
                                               _child: device_t,
                                               _domain:
                                                   *mut ::std::os::raw::c_int)
                              -> ::std::os::raw::c_int>;
extern "C" {
    #[link_name = "bus_get_cpus_desc"]
    pub static mut bus_get_cpus_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_GET_CPUS() method
pub type bus_get_cpus_t =
    ::std::option::Option<unsafe extern "C" fn(_dev: device_t,
                                               _child: device_t,
                                               _op: cpu_sets, _setsize: usize,
                                               _cpuset: *mut cpuset_t)
                              -> ::std::os::raw::c_int>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct module {
    _unused: [u8; 0],
}
extern "C" {
    pub fn driver_module_handler(arg1: *mut module,
                                 arg2: ::std::os::raw::c_int,
                                 arg3: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
/// Module support for automatically adding drivers to buses.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct driver_module_data {
    pub dmd_chainevh: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                     *mut module,
                                                                 arg2:
                                                                     ::std::os::raw::c_int,
                                                                 arg3:
                                                                     *mut ::std::os::raw::c_void)
                                                -> ::std::os::raw::c_int>,
    pub dmd_chainarg: *mut ::std::os::raw::c_void,
    pub dmd_busname: *const ::std::os::raw::c_char,
    pub dmd_driver: kobj_class_t,
    pub dmd_devclass: *mut devclass_t,
    pub dmd_pass: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_driver_module_data() {
    assert_eq!(::std::mem::size_of::<driver_module_data>() , 48usize , concat
               ! ( "Size of: " , stringify ! ( driver_module_data ) ));
    assert_eq! (::std::mem::align_of::<driver_module_data>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( driver_module_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const driver_module_data ) ) . dmd_chainevh as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( driver_module_data ) ,
                "::" , stringify ! ( dmd_chainevh ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const driver_module_data ) ) . dmd_chainarg as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( driver_module_data ) ,
                "::" , stringify ! ( dmd_chainarg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const driver_module_data ) ) . dmd_busname as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( driver_module_data ) ,
                "::" , stringify ! ( dmd_busname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const driver_module_data ) ) . dmd_driver as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( driver_module_data ) ,
                "::" , stringify ! ( dmd_driver ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const driver_module_data ) ) . dmd_devclass as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( driver_module_data ) ,
                "::" , stringify ! ( dmd_devclass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const driver_module_data ) ) . dmd_pass as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( driver_module_data ) ,
                "::" , stringify ! ( dmd_pass ) ));
}
impl Clone for driver_module_data {
    fn clone(&self) -> Self { *self }
}
impl Default for driver_module_data {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct setlist {
    pub lh_first: *mut cpuset,
}
#[test]
fn bindgen_test_layout_setlist() {
    assert_eq!(::std::mem::size_of::<setlist>() , 8usize , concat ! (
               "Size of: " , stringify ! ( setlist ) ));
    assert_eq! (::std::mem::align_of::<setlist>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( setlist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const setlist ) ) . lh_first as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( setlist ) , "::" ,
                stringify ! ( lh_first ) ));
}
impl Clone for setlist {
    fn clone(&self) -> Self { *self }
}
impl Default for setlist {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cpuset {
    pub cs_mask: cpuset_t,
    pub cs_domain: *mut domainset,
    pub cs_ref: u_int,
    pub cs_flags: ::std::os::raw::c_int,
    pub cs_id: cpusetid_t,
    pub cs_parent: *mut cpuset,
    pub cs_link: cpuset__bindgen_ty_1,
    pub cs_siblings: cpuset__bindgen_ty_2,
    pub cs_children: setlist,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cpuset__bindgen_ty_1 {
    pub le_next: *mut cpuset,
    pub le_prev: *mut *mut cpuset,
}
#[test]
fn bindgen_test_layout_cpuset__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<cpuset__bindgen_ty_1>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( cpuset__bindgen_ty_1 )
               ));
    assert_eq! (::std::mem::align_of::<cpuset__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( cpuset__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuset__bindgen_ty_1 ) ) . le_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuset__bindgen_ty_1 )
                , "::" , stringify ! ( le_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuset__bindgen_ty_1 ) ) . le_prev as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuset__bindgen_ty_1 )
                , "::" , stringify ! ( le_prev ) ));
}
impl Clone for cpuset__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for cpuset__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cpuset__bindgen_ty_2 {
    pub le_next: *mut cpuset,
    pub le_prev: *mut *mut cpuset,
}
#[test]
fn bindgen_test_layout_cpuset__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<cpuset__bindgen_ty_2>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( cpuset__bindgen_ty_2 )
               ));
    assert_eq! (::std::mem::align_of::<cpuset__bindgen_ty_2>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( cpuset__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuset__bindgen_ty_2 ) ) . le_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuset__bindgen_ty_2 )
                , "::" , stringify ! ( le_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuset__bindgen_ty_2 ) ) . le_prev as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuset__bindgen_ty_2 )
                , "::" , stringify ! ( le_prev ) ));
}
impl Clone for cpuset__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for cpuset__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_cpuset() {
    assert_eq!(::std::mem::size_of::<cpuset>() , 104usize , concat ! (
               "Size of: " , stringify ! ( cpuset ) ));
    assert_eq! (::std::mem::align_of::<cpuset>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( cpuset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuset ) ) . cs_mask as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuset ) , "::" ,
                stringify ! ( cs_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuset ) ) . cs_domain as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuset ) , "::" ,
                stringify ! ( cs_domain ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuset ) ) . cs_ref as * const _ as usize
                } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuset ) , "::" ,
                stringify ! ( cs_ref ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuset ) ) . cs_flags as * const _ as
                usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuset ) , "::" ,
                stringify ! ( cs_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuset ) ) . cs_id as * const _ as usize
                } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuset ) , "::" ,
                stringify ! ( cs_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuset ) ) . cs_parent as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuset ) , "::" ,
                stringify ! ( cs_parent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuset ) ) . cs_link as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuset ) , "::" ,
                stringify ! ( cs_link ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuset ) ) . cs_siblings as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuset ) , "::" ,
                stringify ! ( cs_siblings ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuset ) ) . cs_children as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuset ) , "::" ,
                stringify ! ( cs_children ) ));
}
impl Clone for cpuset {
    fn clone(&self) -> Self { *self }
}
impl Default for cpuset {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
extern "C" {
    #[link_name = "cpuset_root"]
    pub static mut cpuset_root: *mut cpuset_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct prison {
    _unused: [u8; 0],
}
extern "C" {
    pub fn cpuset_thread0() -> *mut cpuset;
}
extern "C" {
    pub fn cpuset_ref(arg1: *mut cpuset) -> *mut cpuset;
}
extern "C" {
    pub fn cpuset_rel(arg1: *mut cpuset);
}
extern "C" {
    pub fn cpuset_setthread(id: lwpid_t, arg1: *mut cpuset_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cpuset_setithread(id: lwpid_t, cpu: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cpuset_create_root(arg1: *mut prison, arg2: *mut *mut cpuset)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cpuset_setproc_update_set(arg1: *mut proc_, arg2: *mut cpuset)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cpuset_which(arg1: cpuwhich_t, arg2: id_t, arg3: *mut *mut proc_,
                        arg4: *mut *mut thread, arg5: *mut *mut cpuset)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cpusetobj_strprint(arg1: *mut ::std::os::raw::c_char,
                              arg2: *const cpuset_t)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn cpusetobj_strscan(arg1: *mut cpuset_t,
                             arg2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bus_space_map(tag: bus_space_tag_t, addr: bus_addr_t,
                         size: bus_size_t, flags: ::std::os::raw::c_int,
                         bshp: *mut bus_space_handle_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bus_space_unmap(tag: bus_space_tag_t, bsh: bus_space_handle_t,
                           size: bus_size_t);
}
extern "C" {
    pub fn bus_space_alloc(t: bus_space_tag_t, rstart: bus_addr_t,
                           rend: bus_addr_t, size: bus_size_t,
                           align: bus_size_t, boundary: bus_size_t,
                           flags: ::std::os::raw::c_int,
                           addrp: *mut bus_addr_t,
                           bshp: *mut bus_space_handle_t)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ccb {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bio {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct memdesc {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pmap {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct bus_dma_segment {
    pub ds_addr: bus_addr_t,
    pub ds_len: bus_size_t,
}
#[test]
fn bindgen_test_layout_bus_dma_segment() {
    assert_eq!(::std::mem::size_of::<bus_dma_segment>() , 16usize , concat ! (
               "Size of: " , stringify ! ( bus_dma_segment ) ));
    assert_eq! (::std::mem::align_of::<bus_dma_segment>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( bus_dma_segment ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_segment ) ) . ds_addr as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_segment ) ,
                "::" , stringify ! ( ds_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_segment ) ) . ds_len as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_segment ) ,
                "::" , stringify ! ( ds_len ) ));
}
impl Clone for bus_dma_segment {
    fn clone(&self) -> Self { *self }
}
pub type bus_dma_segment_t = bus_dma_segment;
pub type bus_dma_filter_t =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2: bus_addr_t)
                              -> ::std::os::raw::c_int>;
extern "C" {
    pub fn busdma_lock_mutex(arg: *mut ::std::os::raw::c_void,
                             op: bus_dma_lock_op_t);
}
extern "C" {
    pub fn bus_dma_tag_create(parent: bus_dma_tag_t, alignment: bus_size_t,
                              boundary: bus_addr_t, lowaddr: bus_addr_t,
                              highaddr: bus_addr_t,
                              filtfunc: bus_dma_filter_t,
                              filtfuncarg: *mut ::std::os::raw::c_void,
                              maxsize: bus_size_t,
                              nsegments: ::std::os::raw::c_int,
                              maxsegsz: bus_size_t,
                              flags: ::std::os::raw::c_int,
                              lockfunc: bus_dma_lock_t,
                              lockfuncarg: *mut ::std::os::raw::c_void,
                              dmat: *mut bus_dma_tag_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bus_dma_tag_set_domain(dmat: bus_dma_tag_t,
                                  domain: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bus_dma_tag_destroy(dmat: bus_dma_tag_t) -> ::std::os::raw::c_int;
}
pub type bus_dmamap_callback_t =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2: *mut bus_dma_segment_t,
                                               arg3: ::std::os::raw::c_int,
                                               arg4: ::std::os::raw::c_int)>;
pub type bus_dmamap_callback2_t =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *mut ::std::os::raw::c_void,
                                               arg2: *mut bus_dma_segment_t,
                                               arg3: ::std::os::raw::c_int,
                                               arg4: bus_size_t,
                                               arg5: ::std::os::raw::c_int)>;
extern "C" {
    pub fn bus_dmamap_load(dmat: bus_dma_tag_t, map: bus_dmamap_t,
                           buf: *mut ::std::os::raw::c_void,
                           buflen: bus_size_t,
                           callback: bus_dmamap_callback_t,
                           callback_arg: *mut ::std::os::raw::c_void,
                           flags: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bus_dmamap_load_mbuf(dmat: bus_dma_tag_t, map: bus_dmamap_t,
                                mbuf: *mut mbuf,
                                callback: bus_dmamap_callback2_t,
                                callback_arg: *mut ::std::os::raw::c_void,
                                flags: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bus_dmamap_load_mbuf_sg(dmat: bus_dma_tag_t, map: bus_dmamap_t,
                                   mbuf: *mut mbuf,
                                   segs: *mut bus_dma_segment_t,
                                   nsegs: *mut ::std::os::raw::c_int,
                                   flags: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bus_dmamap_load_uio(dmat: bus_dma_tag_t, map: bus_dmamap_t,
                               ui: *mut uio, callback: bus_dmamap_callback2_t,
                               callback_arg: *mut ::std::os::raw::c_void,
                               flags: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bus_dmamap_load_ccb(dmat: bus_dma_tag_t, map: bus_dmamap_t,
                               ccb: *mut ccb, callback: bus_dmamap_callback_t,
                               callback_arg: *mut ::std::os::raw::c_void,
                               flags: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bus_dmamap_load_bio(dmat: bus_dma_tag_t, map: bus_dmamap_t,
                               bio: *mut bio, callback: bus_dmamap_callback_t,
                               callback_arg: *mut ::std::os::raw::c_void,
                               flags: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bus_dmamap_load_mem(dmat: bus_dma_tag_t, map: bus_dmamap_t,
                               mem: *mut memdesc,
                               callback: bus_dmamap_callback_t,
                               callback_arg: *mut ::std::os::raw::c_void,
                               flags: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bus_dmamap_load_ma_triv(dmat: bus_dma_tag_t, map: bus_dmamap_t,
                                   ma: *mut *mut vm_page, tlen: bus_size_t,
                                   ma_offs: ::std::os::raw::c_int,
                                   flags: ::std::os::raw::c_int,
                                   segs: *mut bus_dma_segment_t,
                                   segp: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct bus_dma_tag_common {
    pub impl_: *mut bus_dma_impl,
    pub parent: *mut bus_dma_tag_common,
    pub alignment: bus_size_t,
    pub boundary: bus_addr_t,
    pub lowaddr: bus_addr_t,
    pub highaddr: bus_addr_t,
    pub filter: bus_dma_filter_t,
    pub filterarg: *mut ::std::os::raw::c_void,
    pub maxsize: bus_size_t,
    pub nsegments: u_int,
    pub maxsegsz: bus_size_t,
    pub flags: ::std::os::raw::c_int,
    pub lockfunc: bus_dma_lock_t,
    pub lockfuncarg: *mut ::std::os::raw::c_void,
    pub ref_count: ::std::os::raw::c_int,
    pub domain: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_bus_dma_tag_common() {
    assert_eq!(::std::mem::size_of::<bus_dma_tag_common>() , 120usize , concat
               ! ( "Size of: " , stringify ! ( bus_dma_tag_common ) ));
    assert_eq! (::std::mem::align_of::<bus_dma_tag_common>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( bus_dma_tag_common ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_tag_common ) ) . impl_ as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_tag_common ) ,
                "::" , stringify ! ( impl_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_tag_common ) ) . parent as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_tag_common ) ,
                "::" , stringify ! ( parent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_tag_common ) ) . alignment as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_tag_common ) ,
                "::" , stringify ! ( alignment ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_tag_common ) ) . boundary as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_tag_common ) ,
                "::" , stringify ! ( boundary ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_tag_common ) ) . lowaddr as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_tag_common ) ,
                "::" , stringify ! ( lowaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_tag_common ) ) . highaddr as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_tag_common ) ,
                "::" , stringify ! ( highaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_tag_common ) ) . filter as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_tag_common ) ,
                "::" , stringify ! ( filter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_tag_common ) ) . filterarg as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_tag_common ) ,
                "::" , stringify ! ( filterarg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_tag_common ) ) . maxsize as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_tag_common ) ,
                "::" , stringify ! ( maxsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_tag_common ) ) . nsegments as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_tag_common ) ,
                "::" , stringify ! ( nsegments ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_tag_common ) ) . maxsegsz as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_tag_common ) ,
                "::" , stringify ! ( maxsegsz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_tag_common ) ) . flags as * const
                _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_tag_common ) ,
                "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_tag_common ) ) . lockfunc as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_tag_common ) ,
                "::" , stringify ! ( lockfunc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_tag_common ) ) . lockfuncarg as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_tag_common ) ,
                "::" , stringify ! ( lockfuncarg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_tag_common ) ) . ref_count as *
                const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_tag_common ) ,
                "::" , stringify ! ( ref_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_tag_common ) ) . domain as *
                const _ as usize } , 116usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_tag_common ) ,
                "::" , stringify ! ( domain ) ));
}
impl Clone for bus_dma_tag_common {
    fn clone(&self) -> Self { *self }
}
impl Default for bus_dma_tag_common {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct bus_dma_impl {
    pub tag_create: ::std::option::Option<unsafe extern "C" fn(parent:
                                                                   bus_dma_tag_t,
                                                               alignment:
                                                                   bus_size_t,
                                                               boundary:
                                                                   bus_addr_t,
                                                               lowaddr:
                                                                   bus_addr_t,
                                                               highaddr:
                                                                   bus_addr_t,
                                                               filter:
                                                                   bus_dma_filter_t,
                                                               filterarg:
                                                                   *mut ::std::os::raw::c_void,
                                                               maxsize:
                                                                   bus_size_t,
                                                               nsegments:
                                                                   ::std::os::raw::c_int,
                                                               maxsegsz:
                                                                   bus_size_t,
                                                               flags:
                                                                   ::std::os::raw::c_int,
                                                               lockfunc:
                                                                   bus_dma_lock_t,
                                                               lockfuncarg:
                                                                   *mut ::std::os::raw::c_void,
                                                               dmat:
                                                                   *mut bus_dma_tag_t)
                                              -> ::std::os::raw::c_int>,
    pub tag_destroy: ::std::option::Option<unsafe extern "C" fn(dmat:
                                                                    bus_dma_tag_t)
                                               -> ::std::os::raw::c_int>,
    pub tag_set_domain: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                       bus_dma_tag_t)
                                                  -> ::std::os::raw::c_int>,
    pub map_create: ::std::option::Option<unsafe extern "C" fn(dmat:
                                                                   bus_dma_tag_t,
                                                               flags:
                                                                   ::std::os::raw::c_int,
                                                               mapp:
                                                                   *mut bus_dmamap_t)
                                              -> ::std::os::raw::c_int>,
    pub map_destroy: ::std::option::Option<unsafe extern "C" fn(dmat:
                                                                    bus_dma_tag_t,
                                                                map:
                                                                    bus_dmamap_t)
                                               -> ::std::os::raw::c_int>,
    pub mem_alloc: ::std::option::Option<unsafe extern "C" fn(dmat:
                                                                  bus_dma_tag_t,
                                                              vaddr:
                                                                  *mut *mut ::std::os::raw::c_void,
                                                              flags:
                                                                  ::std::os::raw::c_int,
                                                              mapp:
                                                                  *mut bus_dmamap_t)
                                             -> ::std::os::raw::c_int>,
    pub mem_free: ::std::option::Option<unsafe extern "C" fn(dmat:
                                                                 bus_dma_tag_t,
                                                             vaddr:
                                                                 *mut ::std::os::raw::c_void,
                                                             map:
                                                                 bus_dmamap_t)>,
    pub load_ma: ::std::option::Option<unsafe extern "C" fn(dmat:
                                                                bus_dma_tag_t,
                                                            map: bus_dmamap_t,
                                                            ma:
                                                                *mut *mut vm_page,
                                                            tlen: bus_size_t,
                                                            ma_offs:
                                                                ::std::os::raw::c_int,
                                                            flags:
                                                                ::std::os::raw::c_int,
                                                            segs:
                                                                *mut bus_dma_segment_t,
                                                            segp:
                                                                *mut ::std::os::raw::c_int)
                                           -> ::std::os::raw::c_int>,
    pub load_phys: ::std::option::Option<unsafe extern "C" fn(dmat:
                                                                  bus_dma_tag_t,
                                                              map:
                                                                  bus_dmamap_t,
                                                              buf: vm_paddr_t,
                                                              buflen:
                                                                  bus_size_t,
                                                              flags:
                                                                  ::std::os::raw::c_int,
                                                              segs:
                                                                  *mut bus_dma_segment_t,
                                                              segp:
                                                                  *mut ::std::os::raw::c_int)
                                             -> ::std::os::raw::c_int>,
    pub load_buffer: ::std::option::Option<unsafe extern "C" fn(dmat:
                                                                    bus_dma_tag_t,
                                                                map:
                                                                    bus_dmamap_t,
                                                                buf:
                                                                    *mut ::std::os::raw::c_void,
                                                                buflen:
                                                                    bus_size_t,
                                                                pmap:
                                                                    *mut pmap,
                                                                flags:
                                                                    ::std::os::raw::c_int,
                                                                segs:
                                                                    *mut bus_dma_segment_t,
                                                                segp:
                                                                    *mut ::std::os::raw::c_int)
                                               -> ::std::os::raw::c_int>,
    pub map_waitok: ::std::option::Option<unsafe extern "C" fn(dmat:
                                                                   bus_dma_tag_t,
                                                               map:
                                                                   bus_dmamap_t,
                                                               mem:
                                                                   *mut memdesc,
                                                               callback:
                                                                   bus_dmamap_callback_t,
                                                               callback_arg:
                                                                   *mut ::std::os::raw::c_void)>,
    pub map_complete: ::std::option::Option<unsafe extern "C" fn(dmat:
                                                                     bus_dma_tag_t,
                                                                 map:
                                                                     bus_dmamap_t,
                                                                 segs:
                                                                     *mut bus_dma_segment_t,
                                                                 nsegs:
                                                                     ::std::os::raw::c_int,
                                                                 error:
                                                                     ::std::os::raw::c_int)
                                                -> *mut bus_dma_segment_t>,
    pub map_unload: ::std::option::Option<unsafe extern "C" fn(dmat:
                                                                   bus_dma_tag_t,
                                                               map:
                                                                   bus_dmamap_t)>,
    pub map_sync: ::std::option::Option<unsafe extern "C" fn(dmat:
                                                                 bus_dma_tag_t,
                                                             map:
                                                                 bus_dmamap_t,
                                                             op:
                                                                 bus_dmasync_op_t)>,
}
#[test]
fn bindgen_test_layout_bus_dma_impl() {
    assert_eq!(::std::mem::size_of::<bus_dma_impl>() , 112usize , concat ! (
               "Size of: " , stringify ! ( bus_dma_impl ) ));
    assert_eq! (::std::mem::align_of::<bus_dma_impl>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( bus_dma_impl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_impl ) ) . tag_create as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_impl ) , "::" ,
                stringify ! ( tag_create ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_impl ) ) . tag_destroy as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_impl ) , "::" ,
                stringify ! ( tag_destroy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_impl ) ) . tag_set_domain as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_impl ) , "::" ,
                stringify ! ( tag_set_domain ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_impl ) ) . map_create as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_impl ) , "::" ,
                stringify ! ( map_create ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_impl ) ) . map_destroy as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_impl ) , "::" ,
                stringify ! ( map_destroy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_impl ) ) . mem_alloc as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_impl ) , "::" ,
                stringify ! ( mem_alloc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_impl ) ) . mem_free as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_impl ) , "::" ,
                stringify ! ( mem_free ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_impl ) ) . load_ma as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_impl ) , "::" ,
                stringify ! ( load_ma ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_impl ) ) . load_phys as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_impl ) , "::" ,
                stringify ! ( load_phys ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_impl ) ) . load_buffer as * const
                _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_impl ) , "::" ,
                stringify ! ( load_buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_impl ) ) . map_waitok as * const
                _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_impl ) , "::" ,
                stringify ! ( map_waitok ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_impl ) ) . map_complete as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_impl ) , "::" ,
                stringify ! ( map_complete ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_impl ) ) . map_unload as * const
                _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_impl ) , "::" ,
                stringify ! ( map_unload ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_impl ) ) . map_sync as * const _
                as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_impl ) , "::" ,
                stringify ! ( map_sync ) ));
}
impl Clone for bus_dma_impl {
    fn clone(&self) -> Self { *self }
}
impl Default for bus_dma_impl {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl ::std::fmt::Debug for bus_dma_impl {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f ,
               "bus_dma_impl {{ tag_create: FunctionPointer, tag_destroy: {:?}, tag_set_domain: {:?}, map_create: {:?}, map_destroy: {:?}, mem_alloc: {:?}, mem_free: {:?}, load_ma: {:?}, load_phys: {:?}, load_buffer: {:?}, map_waitok: {:?}, map_complete: {:?}, map_unload: {:?}, map_sync: {:?} }}"
               , self . tag_destroy , self . tag_set_domain , self .
               map_create , self . map_destroy , self . mem_alloc , self .
               mem_free , self . load_ma , self . load_phys , self .
               load_buffer , self . map_waitok , self . map_complete , self .
               map_unload , self . map_sync)
    }
}
extern "C" {
    pub fn bus_dma_dflt_lock(arg: *mut ::std::os::raw::c_void,
                             op: bus_dma_lock_op_t);
}
extern "C" {
    pub fn bus_dma_run_filter(dmat: *mut bus_dma_tag_common,
                              paddr: bus_addr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn common_bus_dma_tag_create(parent: *mut bus_dma_tag_common,
                                     alignment: bus_size_t,
                                     boundary: bus_addr_t,
                                     lowaddr: bus_addr_t,
                                     highaddr: bus_addr_t,
                                     filter: bus_dma_filter_t,
                                     filterarg: *mut ::std::os::raw::c_void,
                                     maxsize: bus_size_t,
                                     nsegments: ::std::os::raw::c_int,
                                     maxsegsz: bus_size_t,
                                     flags: ::std::os::raw::c_int,
                                     lockfunc: bus_dma_lock_t,
                                     lockfuncarg: *mut ::std::os::raw::c_void,
                                     sz: usize,
                                     dmat: *mut *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "bus_dma_bounce_impl"]
    pub static mut bus_dma_bounce_impl: bus_dma_impl;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvlist {
    _unused: [u8; 0],
}
pub type nvlist_t = nvlist;
extern "C" {
    #[link_name = "M_NVLIST"]
    pub static mut M_NVLIST: [malloc_type; 1usize];
}
extern "C" {
    pub fn nvlist_create(flags: ::std::os::raw::c_int) -> *mut nvlist_t;
}
extern "C" {
    pub fn nvlist_destroy(nvl: *mut nvlist_t);
}
extern "C" {
    pub fn nvlist_error(nvl: *const nvlist_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nvlist_empty(nvl: *const nvlist_t) -> bool_;
}
extern "C" {
    pub fn nvlist_flags(nvl: *const nvlist_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nvlist_set_error(nvl: *mut nvlist_t, error: ::std::os::raw::c_int);
}
extern "C" {
    pub fn nvlist_clone(nvl: *const nvlist_t) -> *mut nvlist_t;
}
extern "C" {
    pub fn nvlist_size(nvl: *const nvlist_t) -> usize;
}
extern "C" {
    pub fn nvlist_pack(nvl: *const nvlist_t, sizep: *mut usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn nvlist_unpack(buf: *const ::std::os::raw::c_void, size: usize,
                         flags: ::std::os::raw::c_int) -> *mut nvlist_t;
}
extern "C" {
    pub fn nvlist_send(sock: ::std::os::raw::c_int, nvl: *const nvlist_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nvlist_recv(sock: ::std::os::raw::c_int,
                       flags: ::std::os::raw::c_int) -> *mut nvlist_t;
}
extern "C" {
    pub fn nvlist_xfer(sock: ::std::os::raw::c_int, nvl: *mut nvlist_t,
                       flags: ::std::os::raw::c_int) -> *mut nvlist_t;
}
extern "C" {
    pub fn nvlist_next(nvl: *const nvlist_t,
                       typep: *mut ::std::os::raw::c_int,
                       cookiep: *mut *mut ::std::os::raw::c_void)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nvlist_get_parent(nvl: *const nvlist_t,
                             cookiep: *mut *mut ::std::os::raw::c_void)
     -> *const nvlist_t;
}
extern "C" {
    pub fn nvlist_get_array_next(nvl: *const nvlist_t) -> *const nvlist_t;
}
extern "C" {
    pub fn nvlist_in_array(nvl: *const nvlist_t) -> bool_;
}
extern "C" {
    pub fn nvlist_get_pararr(nvl: *const nvlist_t,
                             cookiep: *mut *mut ::std::os::raw::c_void)
     -> *const nvlist_t;
}
extern "C" {
    pub fn nvlist_exists(nvl: *const nvlist_t,
                         name: *const ::std::os::raw::c_char) -> bool_;
}
extern "C" {
    pub fn nvlist_exists_type(nvl: *const nvlist_t,
                              name: *const ::std::os::raw::c_char,
                              type_: ::std::os::raw::c_int) -> bool_;
}
extern "C" {
    pub fn nvlist_exists_null(nvl: *const nvlist_t,
                              name: *const ::std::os::raw::c_char) -> bool_;
}
extern "C" {
    pub fn nvlist_exists_bool(nvl: *const nvlist_t,
                              name: *const ::std::os::raw::c_char) -> bool_;
}
extern "C" {
    pub fn nvlist_exists_number(nvl: *const nvlist_t,
                                name: *const ::std::os::raw::c_char) -> bool_;
}
extern "C" {
    pub fn nvlist_exists_string(nvl: *const nvlist_t,
                                name: *const ::std::os::raw::c_char) -> bool_;
}
extern "C" {
    pub fn nvlist_exists_nvlist(nvl: *const nvlist_t,
                                name: *const ::std::os::raw::c_char) -> bool_;
}
extern "C" {
    pub fn nvlist_exists_binary(nvl: *const nvlist_t,
                                name: *const ::std::os::raw::c_char) -> bool_;
}
extern "C" {
    pub fn nvlist_exists_bool_array(nvl: *const nvlist_t,
                                    name: *const ::std::os::raw::c_char)
     -> bool_;
}
extern "C" {
    pub fn nvlist_exists_number_array(nvl: *const nvlist_t,
                                      name: *const ::std::os::raw::c_char)
     -> bool_;
}
extern "C" {
    pub fn nvlist_exists_string_array(nvl: *const nvlist_t,
                                      name: *const ::std::os::raw::c_char)
     -> bool_;
}
extern "C" {
    pub fn nvlist_exists_nvlist_array(nvl: *const nvlist_t,
                                      name: *const ::std::os::raw::c_char)
     -> bool_;
}
extern "C" {
    pub fn nvlist_add_null(nvl: *mut nvlist_t,
                           name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn nvlist_add_bool(nvl: *mut nvlist_t,
                           name: *const ::std::os::raw::c_char, value: bool_);
}
extern "C" {
    pub fn nvlist_add_number(nvl: *mut nvlist_t,
                             name: *const ::std::os::raw::c_char, value: u64);
}
extern "C" {
    pub fn nvlist_add_string(nvl: *mut nvlist_t,
                             name: *const ::std::os::raw::c_char,
                             value: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn nvlist_add_stringf(nvl: *mut nvlist_t,
                              name: *const ::std::os::raw::c_char,
                              valuefmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn nvlist_add_nvlist(nvl: *mut nvlist_t,
                             name: *const ::std::os::raw::c_char,
                             value: *const nvlist_t);
}
extern "C" {
    pub fn nvlist_add_binary(nvl: *mut nvlist_t,
                             name: *const ::std::os::raw::c_char,
                             value: *const ::std::os::raw::c_void,
                             size: usize);
}
extern "C" {
    pub fn nvlist_add_bool_array(nvl: *mut nvlist_t,
                                 name: *const ::std::os::raw::c_char,
                                 value: *const bool_, nitems: usize);
}
extern "C" {
    pub fn nvlist_add_number_array(nvl: *mut nvlist_t,
                                   name: *const ::std::os::raw::c_char,
                                   value: *const u64, nitems: usize);
}
extern "C" {
    pub fn nvlist_add_string_array(nvl: *mut nvlist_t,
                                   name: *const ::std::os::raw::c_char,
                                   value:
                                       *const *const ::std::os::raw::c_char,
                                   nitems: usize);
}
extern "C" {
    pub fn nvlist_add_nvlist_array(nvl: *mut nvlist_t,
                                   name: *const ::std::os::raw::c_char,
                                   value: *const *const nvlist_t,
                                   nitems: usize);
}
extern "C" {
    pub fn nvlist_move_string(nvl: *mut nvlist_t,
                              name: *const ::std::os::raw::c_char,
                              value: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn nvlist_move_nvlist(nvl: *mut nvlist_t,
                              name: *const ::std::os::raw::c_char,
                              value: *mut nvlist_t);
}
extern "C" {
    pub fn nvlist_move_binary(nvl: *mut nvlist_t,
                              name: *const ::std::os::raw::c_char,
                              value: *mut ::std::os::raw::c_void,
                              size: usize);
}
extern "C" {
    pub fn nvlist_move_bool_array(nvl: *mut nvlist_t,
                                  name: *const ::std::os::raw::c_char,
                                  value: *mut bool_, nitems: usize);
}
extern "C" {
    pub fn nvlist_move_string_array(nvl: *mut nvlist_t,
                                    name: *const ::std::os::raw::c_char,
                                    value: *mut *mut ::std::os::raw::c_char,
                                    nitems: usize);
}
extern "C" {
    pub fn nvlist_move_nvlist_array(nvl: *mut nvlist_t,
                                    name: *const ::std::os::raw::c_char,
                                    value: *mut *mut nvlist_t, nitems: usize);
}
extern "C" {
    pub fn nvlist_move_number_array(nvl: *mut nvlist_t,
                                    name: *const ::std::os::raw::c_char,
                                    value: *mut u64, nitems: usize);
}
extern "C" {
    pub fn nvlist_get_bool(nvl: *const nvlist_t,
                           name: *const ::std::os::raw::c_char) -> bool_;
}
extern "C" {
    pub fn nvlist_get_number(nvl: *const nvlist_t,
                             name: *const ::std::os::raw::c_char) -> u64;
}
extern "C" {
    pub fn nvlist_get_string(nvl: *const nvlist_t,
                             name: *const ::std::os::raw::c_char)
     -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nvlist_get_nvlist(nvl: *const nvlist_t,
                             name: *const ::std::os::raw::c_char)
     -> *const nvlist_t;
}
extern "C" {
    pub fn nvlist_get_binary(nvl: *const nvlist_t,
                             name: *const ::std::os::raw::c_char,
                             sizep: *mut usize)
     -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn nvlist_get_bool_array(nvl: *const nvlist_t,
                                 name: *const ::std::os::raw::c_char,
                                 nitemsp: *mut usize) -> *const bool_;
}
extern "C" {
    pub fn nvlist_get_number_array(nvl: *const nvlist_t,
                                   name: *const ::std::os::raw::c_char,
                                   nitemsp: *mut usize) -> *const u64;
}
extern "C" {
    pub fn nvlist_get_string_array(nvl: *const nvlist_t,
                                   name: *const ::std::os::raw::c_char,
                                   nitemsp: *mut usize)
     -> *const *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn nvlist_get_nvlist_array(nvl: *const nvlist_t,
                                   name: *const ::std::os::raw::c_char,
                                   nitemsp: *mut usize)
     -> *const *const nvlist_t;
}
extern "C" {
    pub fn nvlist_take_bool(nvl: *mut nvlist_t,
                            name: *const ::std::os::raw::c_char) -> bool_;
}
extern "C" {
    pub fn nvlist_take_number(nvl: *mut nvlist_t,
                              name: *const ::std::os::raw::c_char) -> u64;
}
extern "C" {
    pub fn nvlist_take_string(nvl: *mut nvlist_t,
                              name: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn nvlist_take_nvlist(nvl: *mut nvlist_t,
                              name: *const ::std::os::raw::c_char)
     -> *mut nvlist_t;
}
extern "C" {
    pub fn nvlist_take_binary(nvl: *mut nvlist_t,
                              name: *const ::std::os::raw::c_char,
                              sizep: *mut usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn nvlist_take_bool_array(nvl: *mut nvlist_t,
                                  name: *const ::std::os::raw::c_char,
                                  nitemsp: *mut usize) -> *mut bool_;
}
extern "C" {
    pub fn nvlist_take_number_array(nvl: *mut nvlist_t,
                                    name: *const ::std::os::raw::c_char,
                                    nitemsp: *mut usize) -> *mut u64;
}
extern "C" {
    pub fn nvlist_take_string_array(nvl: *mut nvlist_t,
                                    name: *const ::std::os::raw::c_char,
                                    nitemsp: *mut usize)
     -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn nvlist_take_nvlist_array(nvl: *mut nvlist_t,
                                    name: *const ::std::os::raw::c_char,
                                    nitemsp: *mut usize)
     -> *mut *mut nvlist_t;
}
extern "C" {
    pub fn nvlist_free(nvl: *mut nvlist_t,
                       name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn nvlist_free_type(nvl: *mut nvlist_t,
                            name: *const ::std::os::raw::c_char,
                            type_: ::std::os::raw::c_int);
}
extern "C" {
    pub fn nvlist_free_null(nvl: *mut nvlist_t,
                            name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn nvlist_free_bool(nvl: *mut nvlist_t,
                            name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn nvlist_free_number(nvl: *mut nvlist_t,
                              name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn nvlist_free_string(nvl: *mut nvlist_t,
                              name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn nvlist_free_nvlist(nvl: *mut nvlist_t,
                              name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn nvlist_free_binary(nvl: *mut nvlist_t,
                              name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn nvlist_free_bool_array(nvl: *mut nvlist_t,
                                  name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn nvlist_free_number_array(nvl: *mut nvlist_t,
                                    name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn nvlist_free_string_array(nvl: *mut nvlist_t,
                                    name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn nvlist_free_nvlist_array(nvl: *mut nvlist_t,
                                    name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn nvlist_free_binary_array(nvl: *mut nvlist_t,
                                    name: *const ::std::os::raw::c_char);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct taskqueue {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct taskqgroup {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy)]
pub struct timeout_task {
    pub q: *mut taskqueue,
    pub t: task,
    pub c: callout,
    pub f: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_timeout_task() {
    assert_eq!(::std::mem::size_of::<timeout_task>() , 112usize , concat ! (
               "Size of: " , stringify ! ( timeout_task ) ));
    assert_eq! (::std::mem::align_of::<timeout_task>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timeout_task ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeout_task ) ) . q as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timeout_task ) , "::" ,
                stringify ! ( q ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeout_task ) ) . t as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timeout_task ) , "::" ,
                stringify ! ( t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeout_task ) ) . c as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( timeout_task ) , "::" ,
                stringify ! ( c ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeout_task ) ) . f as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( timeout_task ) , "::" ,
                stringify ! ( f ) ));
}
impl Clone for timeout_task {
    fn clone(&self) -> Self { *self }
}
impl Default for timeout_task {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl ::std::fmt::Debug for timeout_task {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f , "timeout_task {{ q: {:?}, t: {:?}, c: {:?}, f: {:?} }}" ,
               self . q , self . t , self . c , self . f)
    }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum taskqueue_callback_type {
    TASKQUEUE_CALLBACK_TYPE_INIT = 0,
    TASKQUEUE_CALLBACK_TYPE_SHUTDOWN = 1,
}
pub type taskqueue_callback_fn =
    ::std::option::Option<unsafe extern "C" fn(context:
                                                   *mut ::std::os::raw::c_void)>;
pub type taskqueue_enqueue_fn =
    ::std::option::Option<unsafe extern "C" fn(context:
                                                   *mut ::std::os::raw::c_void)>;
extern "C" {
    pub fn taskqueue_create(name: *const ::std::os::raw::c_char,
                            mflags: ::std::os::raw::c_int,
                            enqueue: taskqueue_enqueue_fn,
                            context: *mut ::std::os::raw::c_void)
     -> *mut taskqueue;
}
extern "C" {
    pub fn taskqueue_start_threads(tqp: *mut *mut taskqueue,
                                   count: ::std::os::raw::c_int,
                                   pri: ::std::os::raw::c_int,
                                   name: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn taskqueue_start_threads_cpuset(tqp: *mut *mut taskqueue,
                                          count: ::std::os::raw::c_int,
                                          pri: ::std::os::raw::c_int,
                                          mask: *mut cpuset_t,
                                          name:
                                              *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn taskqueue_enqueue(queue: *mut taskqueue, task: *mut task)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn taskqueue_enqueue_timeout(queue: *mut taskqueue,
                                     timeout_task: *mut timeout_task,
                                     ticks: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn taskqueue_enqueue_timeout_sbt(queue: *mut taskqueue,
                                         timeout_task: *mut timeout_task,
                                         sbt: sbintime_t, pr: sbintime_t,
                                         flags: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn taskqueue_poll_is_busy(queue: *mut taskqueue, task: *mut task)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn taskqueue_cancel(queue: *mut taskqueue, task: *mut task,
                            pendp: *mut u_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn taskqueue_cancel_timeout(queue: *mut taskqueue,
                                    timeout_task: *mut timeout_task,
                                    pendp: *mut u_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn taskqueue_drain(queue: *mut taskqueue, task: *mut task);
}
extern "C" {
    pub fn taskqueue_drain_timeout(queue: *mut taskqueue,
                                   timeout_task: *mut timeout_task);
}
extern "C" {
    pub fn taskqueue_drain_all(queue: *mut taskqueue);
}
extern "C" {
    pub fn taskqueue_free(queue: *mut taskqueue);
}
extern "C" {
    pub fn taskqueue_run(queue: *mut taskqueue);
}
extern "C" {
    pub fn taskqueue_block(queue: *mut taskqueue);
}
extern "C" {
    pub fn taskqueue_unblock(queue: *mut taskqueue);
}
extern "C" {
    pub fn taskqueue_member(queue: *mut taskqueue, td: *mut thread)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn taskqueue_set_callback(queue: *mut taskqueue,
                                  cb_type: taskqueue_callback_type,
                                  callback: taskqueue_callback_fn,
                                  context: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn taskqueue_thread_loop(arg: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn taskqueue_thread_enqueue(context: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _timeout_task_init(queue: *mut taskqueue,
                              timeout_task: *mut timeout_task,
                              priority: ::std::os::raw::c_int,
                              func: task_fn_t,
                              context: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "taskqueue_swi_giant"]
    pub static mut taskqueue_swi_giant: *mut taskqueue;
}
extern "C" {
    #[link_name = "taskqueue_swi"]
    pub static mut taskqueue_swi: *mut taskqueue;
}
extern "C" {
    #[link_name = "taskqueue_thread"]
    pub static mut taskqueue_thread: *mut taskqueue;
}
extern "C" {
    #[link_name = "taskqueue_fast"]
    pub static mut taskqueue_fast: *mut taskqueue;
}
extern "C" {
    pub fn taskqueue_create_fast(name: *const ::std::os::raw::c_char,
                                 mflags: ::std::os::raw::c_int,
                                 enqueue: taskqueue_enqueue_fn,
                                 context: *mut ::std::os::raw::c_void)
     -> *mut taskqueue;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gtaskqueue {
    _unused: [u8; 0],
}
pub type gtaskqueue_enqueue_fn =
    ::std::option::Option<unsafe extern "C" fn(context:
                                                   *mut ::std::os::raw::c_void)>;
extern "C" {
    pub fn gtaskqueue_block(queue: *mut gtaskqueue);
}
extern "C" {
    pub fn gtaskqueue_unblock(queue: *mut gtaskqueue);
}
extern "C" {
    pub fn gtaskqueue_cancel(queue: *mut gtaskqueue, gtask: *mut gtask)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gtaskqueue_drain(queue: *mut gtaskqueue, task: *mut gtask);
}
extern "C" {
    pub fn gtaskqueue_drain_all(queue: *mut gtaskqueue);
}
extern "C" {
    pub fn grouptaskqueue_enqueue(queue: *mut gtaskqueue, task: *mut gtask)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn taskqgroup_attach(qgroup: *mut taskqgroup, grptask: *mut grouptask,
                             uniq: *mut ::std::os::raw::c_void,
                             irq: ::std::os::raw::c_int,
                             name: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn taskqgroup_attach_cpu(qgroup: *mut taskqgroup,
                                 grptask: *mut grouptask,
                                 uniq: *mut ::std::os::raw::c_void,
                                 cpu: ::std::os::raw::c_int,
                                 irq: ::std::os::raw::c_int,
                                 name: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn taskqgroup_detach(qgroup: *mut taskqgroup, gtask: *mut grouptask);
}
extern "C" {
    pub fn taskqgroup_create(name: *mut ::std::os::raw::c_char)
     -> *mut taskqgroup;
}
extern "C" {
    pub fn taskqgroup_destroy(qgroup: *mut taskqgroup);
}
extern "C" {
    pub fn taskqgroup_adjust(qgroup: *mut taskqgroup,
                             cnt: ::std::os::raw::c_int,
                             stride: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "qgroup_net"]
    pub static mut qgroup_net: *mut taskqgroup;
}
extern "C" {
    #[link_name = "qgroup_softirq"]
    pub static mut qgroup_softirq: *mut taskqgroup;
}
pub type qidx_t = u16;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iflib_ctx {
    _unused: [u8; 0],
}
pub type if_ctx_t = *mut iflib_ctx;
#[repr(C)]
#[derive(Copy)]
pub struct if_shared_ctx {
    pub isc_magic: ::std::os::raw::c_int,
    pub isc_driver: *mut driver_t,
    pub isc_q_align: bus_size_t,
    pub isc_tx_maxsize: bus_size_t,
    pub isc_tx_maxsegsize: bus_size_t,
    pub isc_rx_maxsize: bus_size_t,
    pub isc_rx_maxsegsize: bus_size_t,
    pub isc_rx_nsegments: ::std::os::raw::c_int,
    pub isc_admin_intrcnt: ::std::os::raw::c_int,
    pub isc_vendor_info: *mut pci_vendor_info_t,
    pub isc_driver_version: *mut ::std::os::raw::c_char,
    pub isc_parse_devinfo: ::std::option::Option<unsafe extern "C" fn(device_id:
                                                                          *mut u16,
                                                                      subvendor_id:
                                                                          *mut u16,
                                                                      subdevice_id:
                                                                          *mut u16,
                                                                      rev_id:
                                                                          *mut u16)>,
    pub isc_nrxd_min: [::std::os::raw::c_int; 8usize],
    pub isc_nrxd_default: [::std::os::raw::c_int; 8usize],
    pub isc_nrxd_max: [::std::os::raw::c_int; 8usize],
    pub isc_ntxd_min: [::std::os::raw::c_int; 8usize],
    pub isc_ntxd_default: [::std::os::raw::c_int; 8usize],
    pub isc_ntxd_max: [::std::os::raw::c_int; 8usize],
    pub __bindgen_padding_0: [u32; 10usize],
    pub isc_nfl: ::std::os::raw::c_int,
    pub isc_ntxqs: ::std::os::raw::c_int,
    pub isc_nrxqs: ::std::os::raw::c_int,
    pub isc_rx_process_limit: ::std::os::raw::c_int,
    pub isc_tx_reclaim_thresh: ::std::os::raw::c_int,
    pub isc_flags: ::std::os::raw::c_int,
    pub __bindgen_padding_1: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_if_shared_ctx() {
    assert_eq!(::std::mem::size_of::<if_shared_ctx>() , 384usize , concat ! (
               "Size of: " , stringify ! ( if_shared_ctx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_magic as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_magic ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_driver as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_driver ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_q_align as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_q_align ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_tx_maxsize as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_tx_maxsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_tx_maxsegsize as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_tx_maxsegsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_rx_maxsize as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_rx_maxsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_rx_maxsegsize as
                * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_rx_maxsegsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_rx_nsegments as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_rx_nsegments ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_admin_intrcnt as
                * const _ as usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_admin_intrcnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_vendor_info as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_vendor_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_driver_version as
                * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_driver_version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_parse_devinfo as
                * const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_parse_devinfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_nrxd_min as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_nrxd_min ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_nrxd_default as *
                const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_nrxd_default ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_nrxd_max as *
                const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_nrxd_max ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_ntxd_min as *
                const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_ntxd_min ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_ntxd_default as *
                const _ as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_ntxd_default ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_ntxd_max as *
                const _ as usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_ntxd_max ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_nfl as * const _
                as usize } , 320usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_nfl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_ntxqs as * const
                _ as usize } , 324usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_ntxqs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_nrxqs as * const
                _ as usize } , 328usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_nrxqs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_rx_process_limit
                as * const _ as usize } , 332usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_rx_process_limit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_tx_reclaim_thresh
                as * const _ as usize } , 336usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_tx_reclaim_thresh ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_flags as * const
                _ as usize } , 340usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_flags ) ));
}
impl Clone for if_shared_ctx {
    fn clone(&self) -> Self { *self }
}
impl Default for if_shared_ctx {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
impl ::std::fmt::Debug for if_shared_ctx {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f ,
               "if_shared_ctx {{ isc_magic: {:?}, isc_driver: {:?}, isc_q_align: {:?}, isc_tx_maxsize: {:?}, isc_tx_maxsegsize: {:?}, isc_rx_maxsize: {:?}, isc_rx_maxsegsize: {:?}, isc_rx_nsegments: {:?}, isc_admin_intrcnt: {:?}, isc_vendor_info: {:?}, isc_driver_version: {:?}, isc_parse_devinfo: {:?}, isc_nrxd_min: {:?}, isc_nrxd_default: {:?}, isc_nrxd_max: {:?}, isc_ntxd_min: {:?}, isc_ntxd_default: {:?}, isc_ntxd_max: {:?}, isc_nfl: {:?}, isc_ntxqs: {:?}, isc_nrxqs: {:?}, isc_rx_process_limit: {:?}, isc_tx_reclaim_thresh: {:?}, isc_flags: {:?} }}"
               , self . isc_magic , self . isc_driver , self . isc_q_align ,
               self . isc_tx_maxsize , self . isc_tx_maxsegsize , self .
               isc_rx_maxsize , self . isc_rx_maxsegsize , self .
               isc_rx_nsegments , self . isc_admin_intrcnt , self .
               isc_vendor_info , self . isc_driver_version , self .
               isc_parse_devinfo , self . isc_nrxd_min , self .
               isc_nrxd_default , self . isc_nrxd_max , self . isc_ntxd_min ,
               self . isc_ntxd_default , self . isc_ntxd_max , self . isc_nfl
               , self . isc_ntxqs , self . isc_nrxqs , self .
               isc_rx_process_limit , self . isc_tx_reclaim_thresh , self .
               isc_flags)
    }
}
pub type if_shared_ctx_t = *mut if_shared_ctx;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct if_int_delay_info {
    pub iidi_ctx: if_ctx_t,
    pub iidi_offset: ::std::os::raw::c_int,
    pub iidi_value: ::std::os::raw::c_int,
    pub iidi_oidp: *mut sysctl_oid,
    pub iidi_req: *mut sysctl_req,
}
#[test]
fn bindgen_test_layout_if_int_delay_info() {
    assert_eq!(::std::mem::size_of::<if_int_delay_info>() , 32usize , concat !
               ( "Size of: " , stringify ! ( if_int_delay_info ) ));
    assert_eq! (::std::mem::align_of::<if_int_delay_info>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( if_int_delay_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_int_delay_info ) ) . iidi_ctx as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_int_delay_info ) ,
                "::" , stringify ! ( iidi_ctx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_int_delay_info ) ) . iidi_offset as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( if_int_delay_info ) ,
                "::" , stringify ! ( iidi_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_int_delay_info ) ) . iidi_value as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( if_int_delay_info ) ,
                "::" , stringify ! ( iidi_value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_int_delay_info ) ) . iidi_oidp as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( if_int_delay_info ) ,
                "::" , stringify ! ( iidi_oidp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_int_delay_info ) ) . iidi_req as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( if_int_delay_info ) ,
                "::" , stringify ! ( iidi_req ) ));
}
impl Clone for if_int_delay_info {
    fn clone(&self) -> Self { *self }
}
impl Default for if_int_delay_info {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type if_int_delay_info_t = *mut if_int_delay_info;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct if_rxd_frag {
    pub irf_flid: u8,
    pub irf_idx: qidx_t,
    pub irf_len: u16,
}
#[test]
fn bindgen_test_layout_if_rxd_frag() {
    assert_eq!(::std::mem::size_of::<if_rxd_frag>() , 6usize , concat ! (
               "Size of: " , stringify ! ( if_rxd_frag ) ));
    assert_eq! (::std::mem::align_of::<if_rxd_frag>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( if_rxd_frag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_frag ) ) . irf_flid as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_frag ) , "::" ,
                stringify ! ( irf_flid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_frag ) ) . irf_idx as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_frag ) , "::" ,
                stringify ! ( irf_idx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_frag ) ) . irf_len as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_frag ) , "::" ,
                stringify ! ( irf_len ) ));
}
impl Clone for if_rxd_frag {
    fn clone(&self) -> Self { *self }
}
pub type if_rxd_frag_t = *mut if_rxd_frag;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct if_rxd_info {
    pub iri_qsidx: u16,
    pub iri_vtag: u16,
    pub iri_len: u16,
    pub iri_cidx: qidx_t,
    pub iri_ifp: *mut ifnet,
    pub iri_frags: if_rxd_frag_t,
    pub iri_flowid: u32,
    pub iri_csum_flags: u32,
    pub iri_csum_data: u32,
    pub iri_flags: u8,
    pub iri_nfrags: u8,
    pub iri_rsstype: u8,
    pub iri_pad: u8,
}
#[test]
fn bindgen_test_layout_if_rxd_info() {
    assert_eq!(::std::mem::size_of::<if_rxd_info>() , 40usize , concat ! (
               "Size of: " , stringify ! ( if_rxd_info ) ));
    assert_eq! (::std::mem::align_of::<if_rxd_info>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( if_rxd_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_info ) ) . iri_qsidx as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_info ) , "::" ,
                stringify ! ( iri_qsidx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_info ) ) . iri_vtag as * const _
                as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_info ) , "::" ,
                stringify ! ( iri_vtag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_info ) ) . iri_len as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_info ) , "::" ,
                stringify ! ( iri_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_info ) ) . iri_cidx as * const _
                as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_info ) , "::" ,
                stringify ! ( iri_cidx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_info ) ) . iri_ifp as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_info ) , "::" ,
                stringify ! ( iri_ifp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_info ) ) . iri_frags as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_info ) , "::" ,
                stringify ! ( iri_frags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_info ) ) . iri_flowid as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_info ) , "::" ,
                stringify ! ( iri_flowid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_info ) ) . iri_csum_flags as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_info ) , "::" ,
                stringify ! ( iri_csum_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_info ) ) . iri_csum_data as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_info ) , "::" ,
                stringify ! ( iri_csum_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_info ) ) . iri_flags as * const _
                as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_info ) , "::" ,
                stringify ! ( iri_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_info ) ) . iri_nfrags as * const _
                as usize } , 37usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_info ) , "::" ,
                stringify ! ( iri_nfrags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_info ) ) . iri_rsstype as * const
                _ as usize } , 38usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_info ) , "::" ,
                stringify ! ( iri_rsstype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_info ) ) . iri_pad as * const _ as
                usize } , 39usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_info ) , "::" ,
                stringify ! ( iri_pad ) ));
}
impl Clone for if_rxd_info {
    fn clone(&self) -> Self { *self }
}
impl Default for if_rxd_info {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type if_rxd_info_t = *mut if_rxd_info;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct if_rxd_update {
    pub iru_paddrs: *mut u64,
    pub iru_vaddrs: *mut caddr_t,
    pub iru_idxs: *mut qidx_t,
    pub iru_pidx: qidx_t,
    pub iru_qsidx: u16,
    pub iru_count: u16,
    pub iru_buf_size: u16,
    pub iru_flidx: u8,
}
#[test]
fn bindgen_test_layout_if_rxd_update() {
    assert_eq!(::std::mem::size_of::<if_rxd_update>() , 40usize , concat ! (
               "Size of: " , stringify ! ( if_rxd_update ) ));
    assert_eq! (::std::mem::align_of::<if_rxd_update>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( if_rxd_update ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_update ) ) . iru_paddrs as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_update ) , "::"
                , stringify ! ( iru_paddrs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_update ) ) . iru_vaddrs as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_update ) , "::"
                , stringify ! ( iru_vaddrs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_update ) ) . iru_idxs as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_update ) , "::"
                , stringify ! ( iru_idxs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_update ) ) . iru_pidx as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_update ) , "::"
                , stringify ! ( iru_pidx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_update ) ) . iru_qsidx as * const
                _ as usize } , 26usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_update ) , "::"
                , stringify ! ( iru_qsidx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_update ) ) . iru_count as * const
                _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_update ) , "::"
                , stringify ! ( iru_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_update ) ) . iru_buf_size as *
                const _ as usize } , 30usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_update ) , "::"
                , stringify ! ( iru_buf_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_update ) ) . iru_flidx as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_update ) , "::"
                , stringify ! ( iru_flidx ) ));
}
impl Clone for if_rxd_update {
    fn clone(&self) -> Self { *self }
}
impl Default for if_rxd_update {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type if_rxd_update_t = *mut if_rxd_update;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct if_pkt_info {
    pub ipi_segs: *mut bus_dma_segment_t,
    pub ipi_len: u32,
    pub ipi_qsidx: u16,
    pub ipi_nsegs: qidx_t,
    pub ipi_ndescs: qidx_t,
    pub ipi_flags: u16,
    pub ipi_pidx: qidx_t,
    pub ipi_new_pidx: qidx_t,
    pub ipi_ehdrlen: u8,
    pub ipi_ip_hlen: u8,
    pub ipi_tcp_hlen: u8,
    pub ipi_ipproto: u8,
    pub ipi_csum_flags: u32,
    pub ipi_tso_segsz: u16,
    pub ipi_vtag: u16,
    pub ipi_etype: u16,
    pub ipi_tcp_hflags: u8,
    pub ipi_mflags: u8,
    pub ipi_tcp_seq: u32,
    pub ipi_tcp_sum: u32,
}
#[test]
fn bindgen_test_layout_if_pkt_info() {
    assert_eq!(::std::mem::size_of::<if_pkt_info>() , 48usize , concat ! (
               "Size of: " , stringify ! ( if_pkt_info ) ));
    assert_eq! (::std::mem::align_of::<if_pkt_info>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( if_pkt_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_pkt_info ) ) . ipi_segs as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_pkt_info ) , "::" ,
                stringify ! ( ipi_segs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_pkt_info ) ) . ipi_len as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( if_pkt_info ) , "::" ,
                stringify ! ( ipi_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_pkt_info ) ) . ipi_qsidx as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( if_pkt_info ) , "::" ,
                stringify ! ( ipi_qsidx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_pkt_info ) ) . ipi_nsegs as * const _
                as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( if_pkt_info ) , "::" ,
                stringify ! ( ipi_nsegs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_pkt_info ) ) . ipi_ndescs as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( if_pkt_info ) , "::" ,
                stringify ! ( ipi_ndescs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_pkt_info ) ) . ipi_flags as * const _
                as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( if_pkt_info ) , "::" ,
                stringify ! ( ipi_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_pkt_info ) ) . ipi_pidx as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( if_pkt_info ) , "::" ,
                stringify ! ( ipi_pidx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_pkt_info ) ) . ipi_new_pidx as * const
                _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! ( if_pkt_info ) , "::" ,
                stringify ! ( ipi_new_pidx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_pkt_info ) ) . ipi_ehdrlen as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( if_pkt_info ) , "::" ,
                stringify ! ( ipi_ehdrlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_pkt_info ) ) . ipi_ip_hlen as * const
                _ as usize } , 25usize , concat ! (
                "Alignment of field: " , stringify ! ( if_pkt_info ) , "::" ,
                stringify ! ( ipi_ip_hlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_pkt_info ) ) . ipi_tcp_hlen as * const
                _ as usize } , 26usize , concat ! (
                "Alignment of field: " , stringify ! ( if_pkt_info ) , "::" ,
                stringify ! ( ipi_tcp_hlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_pkt_info ) ) . ipi_ipproto as * const
                _ as usize } , 27usize , concat ! (
                "Alignment of field: " , stringify ! ( if_pkt_info ) , "::" ,
                stringify ! ( ipi_ipproto ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_pkt_info ) ) . ipi_csum_flags as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( if_pkt_info ) , "::" ,
                stringify ! ( ipi_csum_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_pkt_info ) ) . ipi_tso_segsz as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( if_pkt_info ) , "::" ,
                stringify ! ( ipi_tso_segsz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_pkt_info ) ) . ipi_vtag as * const _
                as usize } , 34usize , concat ! (
                "Alignment of field: " , stringify ! ( if_pkt_info ) , "::" ,
                stringify ! ( ipi_vtag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_pkt_info ) ) . ipi_etype as * const _
                as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( if_pkt_info ) , "::" ,
                stringify ! ( ipi_etype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_pkt_info ) ) . ipi_tcp_hflags as *
                const _ as usize } , 38usize , concat ! (
                "Alignment of field: " , stringify ! ( if_pkt_info ) , "::" ,
                stringify ! ( ipi_tcp_hflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_pkt_info ) ) . ipi_mflags as * const _
                as usize } , 39usize , concat ! (
                "Alignment of field: " , stringify ! ( if_pkt_info ) , "::" ,
                stringify ! ( ipi_mflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_pkt_info ) ) . ipi_tcp_seq as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( if_pkt_info ) , "::" ,
                stringify ! ( ipi_tcp_seq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_pkt_info ) ) . ipi_tcp_sum as * const
                _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( if_pkt_info ) , "::" ,
                stringify ! ( ipi_tcp_sum ) ));
}
impl Clone for if_pkt_info {
    fn clone(&self) -> Self { *self }
}
impl Default for if_pkt_info {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type if_pkt_info_t = *mut if_pkt_info;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct if_irq {
    pub ii_res: *mut resource,
    pub ii_rid: ::std::os::raw::c_int,
    pub ii_tag: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_if_irq() {
    assert_eq!(::std::mem::size_of::<if_irq>() , 24usize , concat ! (
               "Size of: " , stringify ! ( if_irq ) ));
    assert_eq! (::std::mem::align_of::<if_irq>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( if_irq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_irq ) ) . ii_res as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_irq ) , "::" ,
                stringify ! ( ii_res ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_irq ) ) . ii_rid as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( if_irq ) , "::" ,
                stringify ! ( ii_rid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_irq ) ) . ii_tag as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( if_irq ) , "::" ,
                stringify ! ( ii_tag ) ));
}
impl Clone for if_irq {
    fn clone(&self) -> Self { *self }
}
impl Default for if_irq {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type if_irq_t = *mut if_irq;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum iflib_intr_mode_t {
    IFLIB_INTR_LEGACY = 0,
    IFLIB_INTR_MSI = 1,
    IFLIB_INTR_MSIX = 2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pci_vendor_info {
    pub pvi_vendor_id: u32,
    pub pvi_device_id: u32,
    pub pvi_subvendor_id: u32,
    pub pvi_subdevice_id: u32,
    pub pvi_rev_id: u32,
    pub pvi_class_mask: u32,
    pub pvi_name: caddr_t,
}
#[test]
fn bindgen_test_layout_pci_vendor_info() {
    assert_eq!(::std::mem::size_of::<pci_vendor_info>() , 32usize , concat ! (
               "Size of: " , stringify ! ( pci_vendor_info ) ));
    assert_eq! (::std::mem::align_of::<pci_vendor_info>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( pci_vendor_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_vendor_info ) ) . pvi_vendor_id as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pci_vendor_info ) ,
                "::" , stringify ! ( pvi_vendor_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_vendor_info ) ) . pvi_device_id as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( pci_vendor_info ) ,
                "::" , stringify ! ( pvi_device_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_vendor_info ) ) . pvi_subvendor_id as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pci_vendor_info ) ,
                "::" , stringify ! ( pvi_subvendor_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_vendor_info ) ) . pvi_subdevice_id as
                * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( pci_vendor_info ) ,
                "::" , stringify ! ( pvi_subdevice_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_vendor_info ) ) . pvi_rev_id as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( pci_vendor_info ) ,
                "::" , stringify ! ( pvi_rev_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_vendor_info ) ) . pvi_class_mask as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( pci_vendor_info ) ,
                "::" , stringify ! ( pvi_class_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_vendor_info ) ) . pvi_name as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( pci_vendor_info ) ,
                "::" , stringify ! ( pvi_name ) ));
}
impl Clone for pci_vendor_info {
    fn clone(&self) -> Self { *self }
}
impl Default for pci_vendor_info {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type pci_vendor_info_t = pci_vendor_info;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct if_txrx {
    pub ift_txd_encap: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ::std::os::raw::c_void,
                                                                  arg2:
                                                                      if_pkt_info_t)
                                                 -> ::std::os::raw::c_int>,
    pub ift_txd_flush: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ::std::os::raw::c_void,
                                                                  arg2: u16,
                                                                  pidx:
                                                                      qidx_t)>,
    pub ift_txd_credits_update: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                               *mut ::std::os::raw::c_void,
                                                                           qsidx:
                                                                               u16,
                                                                           clear:
                                                                               bool_)
                                                          ->
                                                              ::std::os::raw::c_int>,
    pub ift_rxd_available: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                          *mut ::std::os::raw::c_void,
                                                                      qsidx:
                                                                          u16,
                                                                      pidx:
                                                                          qidx_t,
                                                                      budget:
                                                                          qidx_t)
                                                     ->
                                                         ::std::os::raw::c_int>,
    pub ift_rxd_pkt_get: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                        *mut ::std::os::raw::c_void,
                                                                    ri:
                                                                        if_rxd_info_t)
                                                   -> ::std::os::raw::c_int>,
    pub ift_rxd_refill: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                       *mut ::std::os::raw::c_void,
                                                                   iru:
                                                                       if_rxd_update_t)>,
    pub ift_rxd_flush: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ::std::os::raw::c_void,
                                                                  qsidx: u16,
                                                                  flidx: u8,
                                                                  pidx:
                                                                      qidx_t)>,
    pub ift_legacy_intr: ::std::option::Option<unsafe extern "C" fn(arg1:
                                                                        *mut ::std::os::raw::c_void)
                                                   -> ::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout_if_txrx() {
    assert_eq!(::std::mem::size_of::<if_txrx>() , 64usize , concat ! (
               "Size of: " , stringify ! ( if_txrx ) ));
    assert_eq! (::std::mem::align_of::<if_txrx>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( if_txrx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_txrx ) ) . ift_txd_encap as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_txrx ) , "::" ,
                stringify ! ( ift_txd_encap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_txrx ) ) . ift_txd_flush as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( if_txrx ) , "::" ,
                stringify ! ( ift_txd_flush ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_txrx ) ) . ift_txd_credits_update as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( if_txrx ) , "::" ,
                stringify ! ( ift_txd_credits_update ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_txrx ) ) . ift_rxd_available as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( if_txrx ) , "::" ,
                stringify ! ( ift_rxd_available ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_txrx ) ) . ift_rxd_pkt_get as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( if_txrx ) , "::" ,
                stringify ! ( ift_rxd_pkt_get ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_txrx ) ) . ift_rxd_refill as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( if_txrx ) , "::" ,
                stringify ! ( ift_rxd_refill ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_txrx ) ) . ift_rxd_flush as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( if_txrx ) , "::" ,
                stringify ! ( ift_rxd_flush ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_txrx ) ) . ift_legacy_intr as * const
                _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( if_txrx ) , "::" ,
                stringify ! ( ift_legacy_intr ) ));
}
impl Clone for if_txrx {
    fn clone(&self) -> Self { *self }
}
impl Default for if_txrx {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type if_txrx_t = *mut if_txrx;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct if_softc_ctx {
    pub isc_vectors: ::std::os::raw::c_int,
    pub isc_nrxqsets: ::std::os::raw::c_int,
    pub isc_ntxqsets: ::std::os::raw::c_int,
    pub isc_msix_bar: ::std::os::raw::c_int,
    pub isc_tx_nsegments: ::std::os::raw::c_int,
    pub isc_ntxd: [::std::os::raw::c_int; 8usize],
    pub isc_nrxd: [::std::os::raw::c_int; 8usize],
    pub isc_txqsizes: [u32; 8usize],
    pub isc_rxqsizes: [u32; 8usize],
    pub isc_txd_size: [u8; 8usize],
    pub isc_rxd_size: [u8; 8usize],
    pub isc_tx_tso_segments_max: ::std::os::raw::c_int,
    pub isc_tx_tso_size_max: ::std::os::raw::c_int,
    pub isc_tx_tso_segsize_max: ::std::os::raw::c_int,
    pub isc_tx_csum_flags: ::std::os::raw::c_int,
    pub isc_capenable: ::std::os::raw::c_int,
    pub isc_rss_table_size: ::std::os::raw::c_int,
    pub isc_rss_table_mask: ::std::os::raw::c_int,
    pub isc_nrxqsets_max: ::std::os::raw::c_int,
    pub isc_ntxqsets_max: ::std::os::raw::c_int,
    pub isc_intr: iflib_intr_mode_t,
    pub isc_max_frame_size: u16,
    pub isc_min_frame_size: u16,
    pub isc_pause_frames: u32,
    pub isc_vendor_info: pci_vendor_info_t,
    pub isc_disable_msix: ::std::os::raw::c_int,
    pub isc_txrx: if_txrx_t,
}
#[test]
fn bindgen_test_layout_if_softc_ctx() {
    assert_eq!(::std::mem::size_of::<if_softc_ctx>() , 264usize , concat ! (
               "Size of: " , stringify ! ( if_softc_ctx ) ));
    assert_eq! (::std::mem::align_of::<if_softc_ctx>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( if_softc_ctx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_vectors as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_vectors ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_nrxqsets as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_nrxqsets ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_ntxqsets as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_ntxqsets ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_msix_bar as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_msix_bar ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_tx_nsegments as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_tx_nsegments ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_ntxd as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_ntxd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_nrxd as * const _
                as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_nrxd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_txqsizes as *
                const _ as usize } , 84usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_txqsizes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_rxqsizes as *
                const _ as usize } , 116usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_rxqsizes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_txd_size as *
                const _ as usize } , 148usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_txd_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_rxd_size as *
                const _ as usize } , 156usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_rxd_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) .
                isc_tx_tso_segments_max as * const _ as usize } , 164usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_tx_tso_segments_max ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_tx_tso_size_max as
                * const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_tx_tso_size_max ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_tx_tso_segsize_max
                as * const _ as usize } , 172usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_tx_tso_segsize_max ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_tx_csum_flags as *
                const _ as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_tx_csum_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_capenable as *
                const _ as usize } , 180usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_capenable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_rss_table_size as
                * const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_rss_table_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_rss_table_mask as
                * const _ as usize } , 188usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_rss_table_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_nrxqsets_max as *
                const _ as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_nrxqsets_max ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_ntxqsets_max as *
                const _ as usize } , 196usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_ntxqsets_max ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_intr as * const _
                as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_intr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_max_frame_size as
                * const _ as usize } , 204usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_max_frame_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_min_frame_size as
                * const _ as usize } , 206usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_min_frame_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_pause_frames as *
                const _ as usize } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_pause_frames ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_vendor_info as *
                const _ as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_vendor_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_disable_msix as *
                const _ as usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_disable_msix ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_txrx as * const _
                as usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_txrx ) ));
}
impl Clone for if_softc_ctx {
    fn clone(&self) -> Self { *self }
}
impl Default for if_softc_ctx {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type if_softc_ctx_t = *mut if_softc_ctx;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct iflib_dma_info {
    pub idi_paddr: bus_addr_t,
    pub idi_vaddr: caddr_t,
    pub idi_tag: bus_dma_tag_t,
    pub idi_map: bus_dmamap_t,
    pub idi_size: u32,
}
#[test]
fn bindgen_test_layout_iflib_dma_info() {
    assert_eq!(::std::mem::size_of::<iflib_dma_info>() , 40usize , concat ! (
               "Size of: " , stringify ! ( iflib_dma_info ) ));
    assert_eq! (::std::mem::align_of::<iflib_dma_info>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( iflib_dma_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const iflib_dma_info ) ) . idi_paddr as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( iflib_dma_info ) , "::"
                , stringify ! ( idi_paddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const iflib_dma_info ) ) . idi_vaddr as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( iflib_dma_info ) , "::"
                , stringify ! ( idi_vaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const iflib_dma_info ) ) . idi_tag as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( iflib_dma_info ) , "::"
                , stringify ! ( idi_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const iflib_dma_info ) ) . idi_map as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( iflib_dma_info ) , "::"
                , stringify ! ( idi_map ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const iflib_dma_info ) ) . idi_size as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( iflib_dma_info ) , "::"
                , stringify ! ( idi_size ) ));
}
impl Clone for iflib_dma_info {
    fn clone(&self) -> Self { *self }
}
impl Default for iflib_dma_info {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type iflib_dma_info_t = *mut iflib_dma_info;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum iflib_intr_type_t {
    IFLIB_INTR_RX = 0,
    IFLIB_INTR_TX = 1,
    IFLIB_INTR_RXTX = 2,
    IFLIB_INTR_ADMIN = 3,
    IFLIB_INTR_IOV = 4,
}
extern "C" {
    pub fn iflib_get_softc(ctx: if_ctx_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn iflib_get_dev(ctx: if_ctx_t) -> device_t;
}
extern "C" {
    pub fn iflib_get_ifp(ctx: if_ctx_t) -> if_t;
}
extern "C" {
    pub fn iflib_get_media(ctx: if_ctx_t) -> *mut ifmedia;
}
extern "C" {
    pub fn iflib_get_softc_ctx(ctx: if_ctx_t) -> if_softc_ctx_t;
}
extern "C" {
    pub fn iflib_get_sctx(ctx: if_ctx_t) -> if_shared_ctx_t;
}
extern "C" {
    pub fn iflib_set_mac(ctx: if_ctx_t, mac: *mut u8);
}
extern "C" {
    pub fn iflib_device_probe(arg1: device_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iflib_device_attach(arg1: device_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iflib_device_detach(arg1: device_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iflib_device_suspend(arg1: device_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iflib_device_resume(arg1: device_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iflib_device_shutdown(arg1: device_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iflib_device_iov_init(arg1: device_t, arg2: u16,
                                 arg3: *const nvlist_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iflib_device_iov_uninit(arg1: device_t);
}
extern "C" {
    pub fn iflib_device_iov_add_vf(arg1: device_t, arg2: u16,
                                   arg3: *const nvlist_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iflib_device_register(dev: device_t,
                                 softc: *mut ::std::os::raw::c_void,
                                 sctx: if_shared_ctx_t, ctxp: *mut if_ctx_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iflib_device_deregister(arg1: if_ctx_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iflib_irq_alloc(arg1: if_ctx_t, arg2: if_irq_t,
                           arg3: ::std::os::raw::c_int, arg4: driver_filter_t,
                           filter_arg: *mut ::std::os::raw::c_void,
                           arg5: driver_intr_t,
                           arg: *mut ::std::os::raw::c_void,
                           name: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iflib_irq_alloc_generic(ctx: if_ctx_t, irq: if_irq_t,
                                   rid: ::std::os::raw::c_int,
                                   type_: iflib_intr_type_t,
                                   filter: driver_filter_t,
                                   filter_arg: *mut ::std::os::raw::c_void,
                                   qid: ::std::os::raw::c_int,
                                   name: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iflib_softirq_alloc_generic(ctx: if_ctx_t, irq: if_irq_t,
                                       type_: iflib_intr_type_t,
                                       arg: *mut ::std::os::raw::c_void,
                                       qid: ::std::os::raw::c_int,
                                       name: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn iflib_irq_free(ctx: if_ctx_t, irq: if_irq_t);
}
extern "C" {
    pub fn iflib_io_tqg_attach(gt: *mut grouptask,
                               uniq: *mut ::std::os::raw::c_void,
                               cpu: ::std::os::raw::c_int,
                               name: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn iflib_config_gtask_init(ctx: if_ctx_t, gtask: *mut grouptask,
                                   fn_: gtask_fn_t,
                                   name: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn iflib_config_gtask_deinit(gtask: *mut grouptask);
}
extern "C" {
    pub fn iflib_tx_intr_deferred(ctx: if_ctx_t,
                                  txqid: ::std::os::raw::c_int);
}
extern "C" {
    pub fn iflib_rx_intr_deferred(ctx: if_ctx_t,
                                  rxqid: ::std::os::raw::c_int);
}
extern "C" {
    pub fn iflib_admin_intr_deferred(ctx: if_ctx_t);
}
extern "C" {
    pub fn iflib_iov_intr_deferred(ctx: if_ctx_t);
}
extern "C" {
    pub fn iflib_link_state_change(ctx: if_ctx_t,
                                   linkstate: ::std::os::raw::c_int,
                                   baudrate: u64);
}
extern "C" {
    pub fn iflib_dma_alloc(ctx: if_ctx_t, size: ::std::os::raw::c_int,
                           dma: iflib_dma_info_t,
                           mapflags: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iflib_dma_free(dma: iflib_dma_info_t);
}
extern "C" {
    pub fn iflib_dma_alloc_multi(ctx: if_ctx_t,
                                 sizes: *mut ::std::os::raw::c_int,
                                 dmalist: *mut iflib_dma_info_t,
                                 mapflags: ::std::os::raw::c_int,
                                 count: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iflib_dma_free_multi(dmalist: *mut iflib_dma_info_t,
                                count: ::std::os::raw::c_int);
}
extern "C" {
    pub fn iflib_ctx_lock_get(arg1: if_ctx_t) -> *mut mtx;
}
extern "C" {
    pub fn iflib_qset_lock_get(arg1: if_ctx_t, arg2: u16) -> *mut mtx;
}
extern "C" {
    pub fn iflib_led_create(ctx: if_ctx_t);
}
extern "C" {
    pub fn iflib_add_int_delay_sysctl(arg1: if_ctx_t,
                                      arg2: *const ::std::os::raw::c_char,
                                      arg3: *const ::std::os::raw::c_char,
                                      arg4: if_int_delay_info_t,
                                      arg5: ::std::os::raw::c_int,
                                      arg6: ::std::os::raw::c_int);
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(::std::mem::size_of::<__va_list_tag>() , 24usize , concat ! (
               "Size of: " , stringify ! ( __va_list_tag ) ));
    assert_eq! (::std::mem::align_of::<__va_list_tag>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __va_list_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . gp_offset as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( gp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . fp_offset as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( fp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . overflow_arg_area as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( overflow_arg_area ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . reg_save_area as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( reg_save_area ) ));
}
impl Clone for __va_list_tag {
    fn clone(&self) -> Self { *self }
}
impl Default for __va_list_tag {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct witness {
    pub _address: u8,
}
impl Clone for witness {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct amd64tss {
    pub _address: u8,
}
impl Clone for amd64tss {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct file {
    pub _address: u8,
}
impl Clone for file {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kaiocb {
    pub _address: u8,
}
impl Clone for kaiocb {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct aioliojob {
    pub _address: u8,
}
impl Clone for aioliojob {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct label {
    pub _address: u8,
}
impl Clone for label {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct domainset {
    pub _address: u8,
}
impl Clone for domainset {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct sysctl_req {
    pub _address: u8,
}
impl Clone for sysctl_req {
    fn clone(&self) -> Self { *self }
}
