/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>);
impl <T> __IncompleteArrayField<T> {
    #[inline]
    pub fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ptr(&self) -> *const T { ::core::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut_ptr(&mut self) -> *mut T {
        ::core::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl <T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
impl <T> ::core::clone::Clone for __IncompleteArrayField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::core::marker::Copy for __IncompleteArrayField<T> { }
#[repr(C)]
pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
impl <T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self { __BindgenUnionField(::core::marker::PhantomData) }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T { ::core::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T { ::core::mem::transmute(self) }
}
impl <T> ::core::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self { Self::new() }
}
impl <T> ::core::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::core::marker::Copy for __BindgenUnionField<T> { }
impl <T> ::core::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl <T> ::core::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) { }
}
impl <T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool { true }
}
impl <T> ::core::cmp::Eq for __BindgenUnionField<T> { }
pub const INET: ::kernel::sys::raw::c_uint = 1;
pub const TCP_OFFLOAD: ::kernel::sys::raw::c_uint = 1;
pub const INET6: ::kernel::sys::raw::c_uint = 1;
pub const BSD: ::kernel::sys::raw::c_uint = 199506;
pub const BSD4_3: ::kernel::sys::raw::c_uint = 1;
pub const BSD4_4: ::kernel::sys::raw::c_uint = 1;
pub const __FreeBSD_version: ::kernel::sys::raw::c_uint = 1200064;
pub const P_OSREL_SIGWAIT: ::kernel::sys::raw::c_uint = 700000;
pub const P_OSREL_SIGSEGV: ::kernel::sys::raw::c_uint = 700004;
pub const P_OSREL_MAP_ANON: ::kernel::sys::raw::c_uint = 800104;
pub const P_OSREL_MAP_FSTRICT: ::kernel::sys::raw::c_uint = 1100036;
pub const P_OSREL_SHUTDOWN_ENOTCONN: ::kernel::sys::raw::c_uint = 1100077;
pub const P_OSREL_MAP_GUARD: ::kernel::sys::raw::c_uint = 1200035;
pub const P_OSREL_WRFSBASE: ::kernel::sys::raw::c_uint = 1200041;
pub const P_OSREL_CK_CYLGRP: ::kernel::sys::raw::c_uint = 1200046;
pub const P_OSREL_VMTOTAL64: ::kernel::sys::raw::c_uint = 1200054;
pub const __GNUCLIKE_ASM: ::kernel::sys::raw::c_uint = 3;
pub const __GNUCLIKE___TYPEOF: ::kernel::sys::raw::c_uint = 1;
pub const __GNUCLIKE___OFFSETOF: ::kernel::sys::raw::c_uint = 1;
pub const __GNUCLIKE___SECTION: ::kernel::sys::raw::c_uint = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: ::kernel::sys::raw::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: ::kernel::sys::raw::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: ::kernel::sys::raw::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: ::kernel::sys::raw::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: ::kernel::sys::raw::c_uint = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: ::kernel::sys::raw::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: ::kernel::sys::raw::c_uint = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: ::kernel::sys::raw::c_uint = 1;
pub const __CC_SUPPORTS_INLINE: ::kernel::sys::raw::c_uint = 1;
pub const __CC_SUPPORTS___INLINE: ::kernel::sys::raw::c_uint = 1;
pub const __CC_SUPPORTS___INLINE__: ::kernel::sys::raw::c_uint = 1;
pub const __CC_SUPPORTS___FUNC__: ::kernel::sys::raw::c_uint = 1;
pub const __CC_SUPPORTS_WARNING: ::kernel::sys::raw::c_uint = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: ::kernel::sys::raw::c_uint = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: ::kernel::sys::raw::c_uint = 1;
pub const __POSIX_VISIBLE: ::kernel::sys::raw::c_uint = 200809;
pub const __XSI_VISIBLE: ::kernel::sys::raw::c_uint = 700;
pub const __BSD_VISIBLE: ::kernel::sys::raw::c_uint = 1;
pub const __ISO_C_VISIBLE: ::kernel::sys::raw::c_uint = 2011;
pub const __EXT1_VISIBLE: ::kernel::sys::raw::c_uint = 1;
pub const __CHAR_BIT: ::kernel::sys::raw::c_uint = 8;
pub const __SCHAR_MAX: ::kernel::sys::raw::c_uint = 127;
pub const __SCHAR_MIN: ::kernel::sys::raw::c_int = -128;
pub const __UCHAR_MAX: ::kernel::sys::raw::c_uint = 255;
pub const __USHRT_MAX: ::kernel::sys::raw::c_uint = 65535;
pub const __SHRT_MAX: ::kernel::sys::raw::c_uint = 32767;
pub const __SHRT_MIN: ::kernel::sys::raw::c_int = -32768;
pub const __UINT_MAX: ::kernel::sys::raw::c_uint = 4294967295;
pub const __INT_MAX: ::kernel::sys::raw::c_uint = 2147483647;
pub const __INT_MIN: ::kernel::sys::raw::c_int = -2147483648;
pub const __ULONG_MAX: ::kernel::sys::raw::c_int = -1;
pub const __LONG_MAX: ::kernel::sys::raw::c_ulonglong = 9223372036854775807;
pub const __LONG_MIN: ::kernel::sys::raw::c_longlong = -9223372036854775808;
pub const __ULLONG_MAX: ::kernel::sys::raw::c_int = -1;
pub const __LLONG_MAX: ::kernel::sys::raw::c_ulonglong = 9223372036854775807;
pub const __LLONG_MIN: ::kernel::sys::raw::c_longlong = -9223372036854775808;
pub const __SSIZE_MAX: ::kernel::sys::raw::c_ulonglong = 9223372036854775807;
pub const __SIZE_T_MAX: ::kernel::sys::raw::c_int = -1;
pub const __OFF_MAX: ::kernel::sys::raw::c_ulonglong = 9223372036854775807;
pub const __OFF_MIN: ::kernel::sys::raw::c_longlong = -9223372036854775808;
pub const __UQUAD_MAX: ::kernel::sys::raw::c_int = -1;
pub const __QUAD_MAX: ::kernel::sys::raw::c_ulonglong = 9223372036854775807;
pub const __QUAD_MIN: ::kernel::sys::raw::c_longlong = -9223372036854775808;
pub const __LONG_BIT: ::kernel::sys::raw::c_uint = 64;
pub const __WORD_BIT: ::kernel::sys::raw::c_uint = 32;
pub const __MINSIGSTKSZ: ::kernel::sys::raw::c_uint = 2048;
pub const __WCHAR_MIN: ::kernel::sys::raw::c_int = -2147483648;
pub const __WCHAR_MAX: ::kernel::sys::raw::c_uint = 2147483647;
pub const _QUAD_HIGHWORD: ::kernel::sys::raw::c_uint = 1;
pub const _QUAD_LOWWORD: ::kernel::sys::raw::c_uint = 0;
pub const _LITTLE_ENDIAN: ::kernel::sys::raw::c_uint = 1234;
pub const _BIG_ENDIAN: ::kernel::sys::raw::c_uint = 4321;
pub const _PDP_ENDIAN: ::kernel::sys::raw::c_uint = 3412;
pub const _BYTE_ORDER: ::kernel::sys::raw::c_uint = 1234;
pub const LITTLE_ENDIAN: ::kernel::sys::raw::c_uint = 1234;
pub const BIG_ENDIAN: ::kernel::sys::raw::c_uint = 4321;
pub const PDP_ENDIAN: ::kernel::sys::raw::c_uint = 3412;
pub const BYTE_ORDER: ::kernel::sys::raw::c_uint = 1234;
pub const __bool_true_false_are_defined: ::kernel::sys::raw::c_uint = 1;
pub const false_: ::kernel::sys::raw::c_uint = 0;
pub const true_: ::kernel::sys::raw::c_uint = 1;
pub const _SIG_WORDS: ::kernel::sys::raw::c_uint = 4;
pub const _SIG_MAXSIG: ::kernel::sys::raw::c_uint = 128;
pub const FD_SETSIZE: ::kernel::sys::raw::c_uint = 1024;
pub const ARG_MAX: ::kernel::sys::raw::c_uint = 262144;
pub const CHILD_MAX: ::kernel::sys::raw::c_uint = 40;
pub const MAX_CANON: ::kernel::sys::raw::c_uint = 255;
pub const MAX_INPUT: ::kernel::sys::raw::c_uint = 255;
pub const NAME_MAX: ::kernel::sys::raw::c_uint = 255;
pub const NGROUPS_MAX: ::kernel::sys::raw::c_uint = 1023;
pub const OPEN_MAX: ::kernel::sys::raw::c_uint = 64;
pub const PATH_MAX: ::kernel::sys::raw::c_uint = 1024;
pub const PIPE_BUF: ::kernel::sys::raw::c_uint = 512;
pub const IOV_MAX: ::kernel::sys::raw::c_uint = 1024;
pub const MAXCOMLEN: ::kernel::sys::raw::c_uint = 19;
pub const MAXINTERP: ::kernel::sys::raw::c_uint = 1024;
pub const MAXLOGNAME: ::kernel::sys::raw::c_uint = 33;
pub const MAXUPRC: ::kernel::sys::raw::c_uint = 40;
pub const NCARGS: ::kernel::sys::raw::c_uint = 262144;
pub const NGROUPS: ::kernel::sys::raw::c_uint = 1024;
pub const NOFILE: ::kernel::sys::raw::c_uint = 64;
pub const NOGROUP: ::kernel::sys::raw::c_uint = 65535;
pub const MAXHOSTNAMELEN: ::kernel::sys::raw::c_uint = 256;
pub const SPECNAMELEN: ::kernel::sys::raw::c_uint = 63;
pub const EPERM: ::kernel::sys::raw::c_uint = 1;
pub const ENOENT: ::kernel::sys::raw::c_uint = 2;
pub const ESRCH: ::kernel::sys::raw::c_uint = 3;
pub const EINTR: ::kernel::sys::raw::c_uint = 4;
pub const EIO: ::kernel::sys::raw::c_uint = 5;
pub const ENXIO: ::kernel::sys::raw::c_uint = 6;
pub const E2BIG: ::kernel::sys::raw::c_uint = 7;
pub const ENOEXEC: ::kernel::sys::raw::c_uint = 8;
pub const EBADF: ::kernel::sys::raw::c_uint = 9;
pub const ECHILD: ::kernel::sys::raw::c_uint = 10;
pub const EDEADLK: ::kernel::sys::raw::c_uint = 11;
pub const ENOMEM: ::kernel::sys::raw::c_uint = 12;
pub const EACCES: ::kernel::sys::raw::c_uint = 13;
pub const EFAULT: ::kernel::sys::raw::c_uint = 14;
pub const ENOTBLK: ::kernel::sys::raw::c_uint = 15;
pub const EBUSY: ::kernel::sys::raw::c_uint = 16;
pub const EEXIST: ::kernel::sys::raw::c_uint = 17;
pub const EXDEV: ::kernel::sys::raw::c_uint = 18;
pub const ENODEV: ::kernel::sys::raw::c_uint = 19;
pub const ENOTDIR: ::kernel::sys::raw::c_uint = 20;
pub const EISDIR: ::kernel::sys::raw::c_uint = 21;
pub const EINVAL: ::kernel::sys::raw::c_uint = 22;
pub const ENFILE: ::kernel::sys::raw::c_uint = 23;
pub const EMFILE: ::kernel::sys::raw::c_uint = 24;
pub const ENOTTY: ::kernel::sys::raw::c_uint = 25;
pub const ETXTBSY: ::kernel::sys::raw::c_uint = 26;
pub const EFBIG: ::kernel::sys::raw::c_uint = 27;
pub const ENOSPC: ::kernel::sys::raw::c_uint = 28;
pub const ESPIPE: ::kernel::sys::raw::c_uint = 29;
pub const EROFS: ::kernel::sys::raw::c_uint = 30;
pub const EMLINK: ::kernel::sys::raw::c_uint = 31;
pub const EPIPE: ::kernel::sys::raw::c_uint = 32;
pub const EDOM: ::kernel::sys::raw::c_uint = 33;
pub const ERANGE: ::kernel::sys::raw::c_uint = 34;
pub const EAGAIN: ::kernel::sys::raw::c_uint = 35;
pub const EWOULDBLOCK: ::kernel::sys::raw::c_uint = 35;
pub const EINPROGRESS: ::kernel::sys::raw::c_uint = 36;
pub const EALREADY: ::kernel::sys::raw::c_uint = 37;
pub const ENOTSOCK: ::kernel::sys::raw::c_uint = 38;
pub const EDESTADDRREQ: ::kernel::sys::raw::c_uint = 39;
pub const EMSGSIZE: ::kernel::sys::raw::c_uint = 40;
pub const EPROTOTYPE: ::kernel::sys::raw::c_uint = 41;
pub const ENOPROTOOPT: ::kernel::sys::raw::c_uint = 42;
pub const EPROTONOSUPPORT: ::kernel::sys::raw::c_uint = 43;
pub const ESOCKTNOSUPPORT: ::kernel::sys::raw::c_uint = 44;
pub const EOPNOTSUPP: ::kernel::sys::raw::c_uint = 45;
pub const ENOTSUP: ::kernel::sys::raw::c_uint = 45;
pub const EPFNOSUPPORT: ::kernel::sys::raw::c_uint = 46;
pub const EAFNOSUPPORT: ::kernel::sys::raw::c_uint = 47;
pub const EADDRINUSE: ::kernel::sys::raw::c_uint = 48;
pub const EADDRNOTAVAIL: ::kernel::sys::raw::c_uint = 49;
pub const ENETDOWN: ::kernel::sys::raw::c_uint = 50;
pub const ENETUNREACH: ::kernel::sys::raw::c_uint = 51;
pub const ENETRESET: ::kernel::sys::raw::c_uint = 52;
pub const ECONNABORTED: ::kernel::sys::raw::c_uint = 53;
pub const ECONNRESET: ::kernel::sys::raw::c_uint = 54;
pub const ENOBUFS: ::kernel::sys::raw::c_uint = 55;
pub const EISCONN: ::kernel::sys::raw::c_uint = 56;
pub const ENOTCONN: ::kernel::sys::raw::c_uint = 57;
pub const ESHUTDOWN: ::kernel::sys::raw::c_uint = 58;
pub const ETOOMANYREFS: ::kernel::sys::raw::c_uint = 59;
pub const ETIMEDOUT: ::kernel::sys::raw::c_uint = 60;
pub const ECONNREFUSED: ::kernel::sys::raw::c_uint = 61;
pub const ELOOP: ::kernel::sys::raw::c_uint = 62;
pub const ENAMETOOLONG: ::kernel::sys::raw::c_uint = 63;
pub const EHOSTDOWN: ::kernel::sys::raw::c_uint = 64;
pub const EHOSTUNREACH: ::kernel::sys::raw::c_uint = 65;
pub const ENOTEMPTY: ::kernel::sys::raw::c_uint = 66;
pub const EPROCLIM: ::kernel::sys::raw::c_uint = 67;
pub const EUSERS: ::kernel::sys::raw::c_uint = 68;
pub const EDQUOT: ::kernel::sys::raw::c_uint = 69;
pub const ESTALE: ::kernel::sys::raw::c_uint = 70;
pub const EREMOTE: ::kernel::sys::raw::c_uint = 71;
pub const EBADRPC: ::kernel::sys::raw::c_uint = 72;
pub const ERPCMISMATCH: ::kernel::sys::raw::c_uint = 73;
pub const EPROGUNAVAIL: ::kernel::sys::raw::c_uint = 74;
pub const EPROGMISMATCH: ::kernel::sys::raw::c_uint = 75;
pub const EPROCUNAVAIL: ::kernel::sys::raw::c_uint = 76;
pub const ENOLCK: ::kernel::sys::raw::c_uint = 77;
pub const ENOSYS: ::kernel::sys::raw::c_uint = 78;
pub const EFTYPE: ::kernel::sys::raw::c_uint = 79;
pub const EAUTH: ::kernel::sys::raw::c_uint = 80;
pub const ENEEDAUTH: ::kernel::sys::raw::c_uint = 81;
pub const EIDRM: ::kernel::sys::raw::c_uint = 82;
pub const ENOMSG: ::kernel::sys::raw::c_uint = 83;
pub const EOVERFLOW: ::kernel::sys::raw::c_uint = 84;
pub const ECANCELED: ::kernel::sys::raw::c_uint = 85;
pub const EILSEQ: ::kernel::sys::raw::c_uint = 86;
pub const ENOATTR: ::kernel::sys::raw::c_uint = 87;
pub const EDOOFUS: ::kernel::sys::raw::c_uint = 88;
pub const EBADMSG: ::kernel::sys::raw::c_uint = 89;
pub const EMULTIHOP: ::kernel::sys::raw::c_uint = 90;
pub const ENOLINK: ::kernel::sys::raw::c_uint = 91;
pub const EPROTO: ::kernel::sys::raw::c_uint = 92;
pub const ENOTCAPABLE: ::kernel::sys::raw::c_uint = 93;
pub const ECAPMODE: ::kernel::sys::raw::c_uint = 94;
pub const ENOTRECOVERABLE: ::kernel::sys::raw::c_uint = 95;
pub const EOWNERDEAD: ::kernel::sys::raw::c_uint = 96;
pub const ELAST: ::kernel::sys::raw::c_uint = 96;
pub const ERESTART: ::kernel::sys::raw::c_int = -1;
pub const EJUSTRETURN: ::kernel::sys::raw::c_int = -2;
pub const ENOIOCTL: ::kernel::sys::raw::c_int = -3;
pub const EDIRIOCTL: ::kernel::sys::raw::c_int = -4;
pub const ERELOOKUP: ::kernel::sys::raw::c_int = -5;
pub const DST_NONE: ::kernel::sys::raw::c_uint = 0;
pub const DST_USA: ::kernel::sys::raw::c_uint = 1;
pub const DST_AUST: ::kernel::sys::raw::c_uint = 2;
pub const DST_WET: ::kernel::sys::raw::c_uint = 3;
pub const DST_MET: ::kernel::sys::raw::c_uint = 4;
pub const DST_EET: ::kernel::sys::raw::c_uint = 5;
pub const DST_CAN: ::kernel::sys::raw::c_uint = 6;
pub const SBT_MAX: ::kernel::sys::raw::c_ulonglong = 9223372036854775807;
pub const ITIMER_REAL: ::kernel::sys::raw::c_uint = 0;
pub const ITIMER_VIRTUAL: ::kernel::sys::raw::c_uint = 1;
pub const ITIMER_PROF: ::kernel::sys::raw::c_uint = 2;
pub const CLOCK_REALTIME: ::kernel::sys::raw::c_uint = 0;
pub const CLOCK_VIRTUAL: ::kernel::sys::raw::c_uint = 1;
pub const CLOCK_PROF: ::kernel::sys::raw::c_uint = 2;
pub const CLOCK_MONOTONIC: ::kernel::sys::raw::c_uint = 4;
pub const CLOCK_UPTIME: ::kernel::sys::raw::c_uint = 5;
pub const CLOCK_UPTIME_PRECISE: ::kernel::sys::raw::c_uint = 7;
pub const CLOCK_UPTIME_FAST: ::kernel::sys::raw::c_uint = 8;
pub const CLOCK_REALTIME_PRECISE: ::kernel::sys::raw::c_uint = 9;
pub const CLOCK_REALTIME_FAST: ::kernel::sys::raw::c_uint = 10;
pub const CLOCK_MONOTONIC_PRECISE: ::kernel::sys::raw::c_uint = 11;
pub const CLOCK_MONOTONIC_FAST: ::kernel::sys::raw::c_uint = 12;
pub const CLOCK_SECOND: ::kernel::sys::raw::c_uint = 13;
pub const CLOCK_THREAD_CPUTIME_ID: ::kernel::sys::raw::c_uint = 14;
pub const CLOCK_PROCESS_CPUTIME_ID: ::kernel::sys::raw::c_uint = 15;
pub const TIMER_RELTIME: ::kernel::sys::raw::c_uint = 0;
pub const TIMER_ABSTIME: ::kernel::sys::raw::c_uint = 1;
pub const CPUCLOCK_WHICH_PID: ::kernel::sys::raw::c_uint = 0;
pub const CPUCLOCK_WHICH_TID: ::kernel::sys::raw::c_uint = 1;
pub const TC_DEFAULTPERC: ::kernel::sys::raw::c_uint = 5;
pub const PRI_ITHD: ::kernel::sys::raw::c_uint = 1;
pub const PRI_REALTIME: ::kernel::sys::raw::c_uint = 2;
pub const PRI_TIMESHARE: ::kernel::sys::raw::c_uint = 3;
pub const PRI_IDLE: ::kernel::sys::raw::c_uint = 4;
pub const PRI_FIFO_BIT: ::kernel::sys::raw::c_uint = 8;
pub const PRI_FIFO: ::kernel::sys::raw::c_uint = 10;
pub const PRI_MIN: ::kernel::sys::raw::c_uint = 0;
pub const PRI_MAX: ::kernel::sys::raw::c_uint = 255;
pub const PRI_MIN_ITHD: ::kernel::sys::raw::c_uint = 0;
pub const PI_REALTIME: ::kernel::sys::raw::c_uint = 0;
pub const PI_AV: ::kernel::sys::raw::c_uint = 4;
pub const PI_NET: ::kernel::sys::raw::c_uint = 8;
pub const PI_DISK: ::kernel::sys::raw::c_uint = 12;
pub const PI_TTY: ::kernel::sys::raw::c_uint = 16;
pub const PI_DULL: ::kernel::sys::raw::c_uint = 20;
pub const PI_SOFT: ::kernel::sys::raw::c_uint = 24;
pub const PRI_MIN_REALTIME: ::kernel::sys::raw::c_uint = 48;
pub const PRI_MIN_KERN: ::kernel::sys::raw::c_uint = 80;
pub const PSWP: ::kernel::sys::raw::c_uint = 80;
pub const PVM: ::kernel::sys::raw::c_uint = 84;
pub const PINOD: ::kernel::sys::raw::c_uint = 88;
pub const PRIBIO: ::kernel::sys::raw::c_uint = 92;
pub const PVFS: ::kernel::sys::raw::c_uint = 96;
pub const PZERO: ::kernel::sys::raw::c_uint = 100;
pub const PSOCK: ::kernel::sys::raw::c_uint = 104;
pub const PWAIT: ::kernel::sys::raw::c_uint = 108;
pub const PLOCK: ::kernel::sys::raw::c_uint = 112;
pub const PPAUSE: ::kernel::sys::raw::c_uint = 116;
pub const PRI_MIN_TIMESHARE: ::kernel::sys::raw::c_uint = 120;
pub const PUSER: ::kernel::sys::raw::c_uint = 120;
pub const PRI_MIN_IDLE: ::kernel::sys::raw::c_uint = 224;
pub const PRI_MAX_IDLE: ::kernel::sys::raw::c_uint = 255;
pub const PRI_USER: ::kernel::sys::raw::c_int = -2;
pub const PRI_UNCHANGED: ::kernel::sys::raw::c_int = -1;
pub const FALSE: ::kernel::sys::raw::c_uint = 0;
pub const TRUE: ::kernel::sys::raw::c_uint = 1;
pub const MACHINE: &'static [u8; 6usize] = b"amd64\x00";
pub const MACHINE_ARCH: &'static [u8; 6usize] = b"amd64\x00";
pub const MACHINE_ARCH32: &'static [u8; 5usize] = b"i386\x00";
pub const MAXCPU: ::kernel::sys::raw::c_uint = 256;
pub const MAXMEMDOM: ::kernel::sys::raw::c_uint = 8;
pub const CACHE_LINE_SHIFT: ::kernel::sys::raw::c_uint = 6;
pub const CACHE_LINE_SIZE: ::kernel::sys::raw::c_uint = 64;
pub const NPTEPGSHIFT: ::kernel::sys::raw::c_uint = 9;
pub const PAGE_SHIFT: ::kernel::sys::raw::c_uint = 12;
pub const PAGE_SIZE: ::kernel::sys::raw::c_uint = 4096;
pub const PAGE_MASK: ::kernel::sys::raw::c_uint = 4095;
pub const NPDEPGSHIFT: ::kernel::sys::raw::c_uint = 9;
pub const PDRSHIFT: ::kernel::sys::raw::c_uint = 21;
pub const NBPDR: ::kernel::sys::raw::c_uint = 2097152;
pub const PDRMASK: ::kernel::sys::raw::c_uint = 2097151;
pub const NPDPEPGSHIFT: ::kernel::sys::raw::c_uint = 9;
pub const PDPSHIFT: ::kernel::sys::raw::c_uint = 30;
pub const NBPDP: ::kernel::sys::raw::c_uint = 1073741824;
pub const PDPMASK: ::kernel::sys::raw::c_uint = 1073741823;
pub const NPML4EPGSHIFT: ::kernel::sys::raw::c_uint = 9;
pub const PML4SHIFT: ::kernel::sys::raw::c_uint = 39;
pub const NBPML4: ::kernel::sys::raw::c_ulonglong = 549755813888;
pub const PML4MASK: ::kernel::sys::raw::c_ulonglong = 549755813887;
pub const MAXPAGESIZES: ::kernel::sys::raw::c_uint = 3;
pub const IOPAGES: ::kernel::sys::raw::c_uint = 2;
pub const IOPERM_BITMAP_SIZE: ::kernel::sys::raw::c_uint = 8193;
pub const KSTACK_PAGES: ::kernel::sys::raw::c_uint = 4;
pub const KSTACK_GUARD_PAGES: ::kernel::sys::raw::c_uint = 1;
pub const DEV_BSHIFT: ::kernel::sys::raw::c_uint = 9;
pub const DEV_BSIZE: ::kernel::sys::raw::c_uint = 512;
pub const BLKDEV_IOSIZE: ::kernel::sys::raw::c_uint = 4096;
pub const DFLTPHYS: ::kernel::sys::raw::c_uint = 65536;
pub const MAXPHYS: ::kernel::sys::raw::c_uint = 131072;
pub const MAXDUMPPGS: ::kernel::sys::raw::c_uint = 16;
pub const MSIZE: ::kernel::sys::raw::c_uint = 256;
pub const MCLSHIFT: ::kernel::sys::raw::c_uint = 11;
pub const MCLBYTES: ::kernel::sys::raw::c_uint = 2048;
pub const MJUMPAGESIZE: ::kernel::sys::raw::c_uint = 4096;
pub const MJUM9BYTES: ::kernel::sys::raw::c_uint = 9216;
pub const MJUM16BYTES: ::kernel::sys::raw::c_uint = 16384;
pub const PRIMASK: ::kernel::sys::raw::c_uint = 255;
pub const PCATCH: ::kernel::sys::raw::c_uint = 256;
pub const PDROP: ::kernel::sys::raw::c_uint = 512;
pub const NZERO: ::kernel::sys::raw::c_uint = 0;
pub const NBBY: ::kernel::sys::raw::c_uint = 8;
pub const CMASK: ::kernel::sys::raw::c_uint = 18;
pub const MAXBSIZE: ::kernel::sys::raw::c_uint = 65536;
pub const MAXBCACHEBUF: ::kernel::sys::raw::c_uint = 65536;
pub const BKVASIZE: ::kernel::sys::raw::c_uint = 16384;
pub const BKVAMASK: ::kernel::sys::raw::c_uint = 16383;
pub const MAXPATHLEN: ::kernel::sys::raw::c_uint = 1024;
pub const MAXSYMLINKS: ::kernel::sys::raw::c_uint = 32;
pub const FSHIFT: ::kernel::sys::raw::c_uint = 11;
pub const FSCALE: ::kernel::sys::raw::c_uint = 2048;
pub const CR4_PGE: ::kernel::sys::raw::c_uint = 128;
pub const INVPCID_ADDR: ::kernel::sys::raw::c_uint = 0;
pub const INVPCID_CTX: ::kernel::sys::raw::c_uint = 1;
pub const INVPCID_CTXGLOB: ::kernel::sys::raw::c_uint = 2;
pub const INVPCID_ALLCTX: ::kernel::sys::raw::c_uint = 3;
pub const MSR_FSBASE: ::kernel::sys::raw::c_uint = 3221225728;
pub const MSR_GSBASE: ::kernel::sys::raw::c_uint = 3221225729;
pub const CALLOUT_LOCAL_ALLOC: ::kernel::sys::raw::c_uint = 1;
pub const CALLOUT_ACTIVE: ::kernel::sys::raw::c_uint = 2;
pub const CALLOUT_PENDING: ::kernel::sys::raw::c_uint = 4;
pub const CALLOUT_MPSAFE: ::kernel::sys::raw::c_uint = 8;
pub const CALLOUT_RETURNUNLOCKED: ::kernel::sys::raw::c_uint = 16;
pub const CALLOUT_SHAREDLOCK: ::kernel::sys::raw::c_uint = 32;
pub const CALLOUT_DFRMIGRATION: ::kernel::sys::raw::c_uint = 64;
pub const CALLOUT_PROCESSED: ::kernel::sys::raw::c_uint = 128;
pub const CALLOUT_DIRECT: ::kernel::sys::raw::c_uint = 256;
pub const C_DIRECT_EXEC: ::kernel::sys::raw::c_uint = 1;
pub const C_PRELBITS: ::kernel::sys::raw::c_uint = 7;
pub const C_PRELRANGE: ::kernel::sys::raw::c_uint = 127;
pub const C_HARDCLOCK: ::kernel::sys::raw::c_uint = 256;
pub const C_ABSOLUTE: ::kernel::sys::raw::c_uint = 512;
pub const C_PRECALC: ::kernel::sys::raw::c_uint = 1024;
pub const C_CATCH: ::kernel::sys::raw::c_uint = 2048;
pub const CS_DRAIN: ::kernel::sys::raw::c_uint = 1;
pub const CS_EXECUTING: ::kernel::sys::raw::c_uint = 2;
pub const INT8_MIN: ::kernel::sys::raw::c_int = -128;
pub const INT16_MIN: ::kernel::sys::raw::c_int = -32768;
pub const INT32_MIN: ::kernel::sys::raw::c_int = -2147483648;
pub const INT8_MAX: ::kernel::sys::raw::c_uint = 127;
pub const INT16_MAX: ::kernel::sys::raw::c_uint = 32767;
pub const INT32_MAX: ::kernel::sys::raw::c_uint = 2147483647;
pub const UINT8_MAX: ::kernel::sys::raw::c_uint = 255;
pub const UINT16_MAX: ::kernel::sys::raw::c_uint = 65535;
pub const UINT32_MAX: ::kernel::sys::raw::c_uint = 4294967295;
pub const INT64_MIN: ::kernel::sys::raw::c_longlong = -9223372036854775808;
pub const INT64_MAX: ::kernel::sys::raw::c_ulonglong = 9223372036854775807;
pub const UINT64_MAX: ::kernel::sys::raw::c_int = -1;
pub const INT_LEAST8_MIN: ::kernel::sys::raw::c_int = -128;
pub const INT_LEAST16_MIN: ::kernel::sys::raw::c_int = -32768;
pub const INT_LEAST32_MIN: ::kernel::sys::raw::c_int = -2147483648;
pub const INT_LEAST64_MIN: ::kernel::sys::raw::c_longlong =
    -9223372036854775808;
pub const INT_LEAST8_MAX: ::kernel::sys::raw::c_uint = 127;
pub const INT_LEAST16_MAX: ::kernel::sys::raw::c_uint = 32767;
pub const INT_LEAST32_MAX: ::kernel::sys::raw::c_uint = 2147483647;
pub const INT_LEAST64_MAX: ::kernel::sys::raw::c_ulonglong =
    9223372036854775807;
pub const UINT_LEAST8_MAX: ::kernel::sys::raw::c_uint = 255;
pub const UINT_LEAST16_MAX: ::kernel::sys::raw::c_uint = 65535;
pub const UINT_LEAST32_MAX: ::kernel::sys::raw::c_uint = 4294967295;
pub const UINT_LEAST64_MAX: ::kernel::sys::raw::c_int = -1;
pub const INT_FAST8_MIN: ::kernel::sys::raw::c_int = -2147483648;
pub const INT_FAST16_MIN: ::kernel::sys::raw::c_int = -2147483648;
pub const INT_FAST32_MIN: ::kernel::sys::raw::c_int = -2147483648;
pub const INT_FAST64_MIN: ::kernel::sys::raw::c_longlong =
    -9223372036854775808;
pub const INT_FAST8_MAX: ::kernel::sys::raw::c_uint = 2147483647;
pub const INT_FAST16_MAX: ::kernel::sys::raw::c_uint = 2147483647;
pub const INT_FAST32_MAX: ::kernel::sys::raw::c_uint = 2147483647;
pub const INT_FAST64_MAX: ::kernel::sys::raw::c_ulonglong =
    9223372036854775807;
pub const UINT_FAST8_MAX: ::kernel::sys::raw::c_uint = 4294967295;
pub const UINT_FAST16_MAX: ::kernel::sys::raw::c_uint = 4294967295;
pub const UINT_FAST32_MAX: ::kernel::sys::raw::c_uint = 4294967295;
pub const UINT_FAST64_MAX: ::kernel::sys::raw::c_int = -1;
pub const INTPTR_MIN: ::kernel::sys::raw::c_longlong = -9223372036854775808;
pub const INTPTR_MAX: ::kernel::sys::raw::c_ulonglong = 9223372036854775807;
pub const UINTPTR_MAX: ::kernel::sys::raw::c_int = -1;
pub const INTMAX_MIN: ::kernel::sys::raw::c_longlong = -9223372036854775808;
pub const INTMAX_MAX: ::kernel::sys::raw::c_ulonglong = 9223372036854775807;
pub const UINTMAX_MAX: ::kernel::sys::raw::c_int = -1;
pub const PTRDIFF_MIN: ::kernel::sys::raw::c_longlong = -9223372036854775808;
pub const PTRDIFF_MAX: ::kernel::sys::raw::c_ulonglong = 9223372036854775807;
pub const SIG_ATOMIC_MIN: ::kernel::sys::raw::c_longlong =
    -9223372036854775808;
pub const SIG_ATOMIC_MAX: ::kernel::sys::raw::c_ulonglong =
    9223372036854775807;
pub const SIZE_MAX: ::kernel::sys::raw::c_int = -1;
pub const WINT_MIN: ::kernel::sys::raw::c_int = -2147483648;
pub const WINT_MAX: ::kernel::sys::raw::c_uint = 2147483647;
pub const __WORDSIZE: ::kernel::sys::raw::c_uint = 64;
pub const WCHAR_MIN: ::kernel::sys::raw::c_int = -2147483648;
pub const WCHAR_MAX: ::kernel::sys::raw::c_uint = 2147483647;
pub const RSIZE_MAX: ::kernel::sys::raw::c_int = -1;
pub const HASH_NOWAIT: ::kernel::sys::raw::c_uint = 1;
pub const HASH_WAITOK: ::kernel::sys::raw::c_uint = 2;
pub const HD_COLUMN_MASK: ::kernel::sys::raw::c_uint = 255;
pub const HD_DELIM_MASK: ::kernel::sys::raw::c_uint = 65280;
pub const HD_OMIT_COUNT: ::kernel::sys::raw::c_uint = 65536;
pub const HD_OMIT_HEX: ::kernel::sys::raw::c_uint = 131072;
pub const HD_OMIT_CHARS: ::kernel::sys::raw::c_uint = 262144;
pub const LIBKERN_LEN_BCD2BIN: ::kernel::sys::raw::c_uint = 154;
pub const LIBKERN_LEN_BIN2BCD: ::kernel::sys::raw::c_uint = 100;
pub const LIBKERN_LEN_HEX2ASCII: ::kernel::sys::raw::c_uint = 36;
pub const ARC4_ENTR_NONE: ::kernel::sys::raw::c_uint = 0;
pub const ARC4_ENTR_HAVE: ::kernel::sys::raw::c_uint = 1;
pub const ARC4_ENTR_SEED: ::kernel::sys::raw::c_uint = 2;
pub const FNM_NOMATCH: ::kernel::sys::raw::c_uint = 1;
pub const FNM_NOESCAPE: ::kernel::sys::raw::c_uint = 1;
pub const FNM_PATHNAME: ::kernel::sys::raw::c_uint = 2;
pub const FNM_PERIOD: ::kernel::sys::raw::c_uint = 4;
pub const FNM_LEADING_DIR: ::kernel::sys::raw::c_uint = 8;
pub const FNM_CASEFOLD: ::kernel::sys::raw::c_uint = 16;
pub const FNM_IGNORECASE: ::kernel::sys::raw::c_uint = 16;
pub const FNM_FILE_NAME: ::kernel::sys::raw::c_uint = 2;
pub const PSL_C: ::kernel::sys::raw::c_uint = 1;
pub const PSL_PF: ::kernel::sys::raw::c_uint = 4;
pub const PSL_AF: ::kernel::sys::raw::c_uint = 16;
pub const PSL_Z: ::kernel::sys::raw::c_uint = 64;
pub const PSL_N: ::kernel::sys::raw::c_uint = 128;
pub const PSL_T: ::kernel::sys::raw::c_uint = 256;
pub const PSL_I: ::kernel::sys::raw::c_uint = 512;
pub const PSL_D: ::kernel::sys::raw::c_uint = 1024;
pub const PSL_V: ::kernel::sys::raw::c_uint = 2048;
pub const PSL_IOPL: ::kernel::sys::raw::c_uint = 12288;
pub const PSL_NT: ::kernel::sys::raw::c_uint = 16384;
pub const PSL_RF: ::kernel::sys::raw::c_uint = 65536;
pub const PSL_VM: ::kernel::sys::raw::c_uint = 131072;
pub const PSL_AC: ::kernel::sys::raw::c_uint = 262144;
pub const PSL_VIF: ::kernel::sys::raw::c_uint = 524288;
pub const PSL_VIP: ::kernel::sys::raw::c_uint = 1048576;
pub const PSL_ID: ::kernel::sys::raw::c_uint = 2097152;
pub const PSL_RESERVED_DEFAULT: ::kernel::sys::raw::c_uint = 2;
pub const PSL_KERNEL: ::kernel::sys::raw::c_uint = 2;
pub const PSL_USER: ::kernel::sys::raw::c_uint = 514;
pub const PSL_USERCHANGE: ::kernel::sys::raw::c_uint = 2444757;
pub const _MACHINE_FRAME_H_: ::kernel::sys::raw::c_uint = 1;
pub const TF_HASSEGS: ::kernel::sys::raw::c_uint = 1;
pub const TF_HASBASES: ::kernel::sys::raw::c_uint = 2;
pub const TF_HASFPXSTATE: ::kernel::sys::raw::c_uint = 4;
pub const SEL_RPL_MASK: ::kernel::sys::raw::c_uint = 3;
pub const SEL_KPL: ::kernel::sys::raw::c_uint = 0;
pub const SEL_UPL: ::kernel::sys::raw::c_uint = 3;
pub const SEL_LDT: ::kernel::sys::raw::c_uint = 4;
pub const SDT_SYSNULL: ::kernel::sys::raw::c_uint = 0;
pub const SDT_SYS286TSS: ::kernel::sys::raw::c_uint = 1;
pub const SDT_SYSLDT: ::kernel::sys::raw::c_uint = 2;
pub const SDT_SYS286BSY: ::kernel::sys::raw::c_uint = 3;
pub const SDT_SYS286CGT: ::kernel::sys::raw::c_uint = 4;
pub const SDT_SYSTASKGT: ::kernel::sys::raw::c_uint = 5;
pub const SDT_SYS286IGT: ::kernel::sys::raw::c_uint = 6;
pub const SDT_SYS286TGT: ::kernel::sys::raw::c_uint = 7;
pub const SDT_SYSNULL2: ::kernel::sys::raw::c_uint = 8;
pub const SDT_SYS386TSS: ::kernel::sys::raw::c_uint = 9;
pub const SDT_SYSTSS: ::kernel::sys::raw::c_uint = 9;
pub const SDT_SYSNULL3: ::kernel::sys::raw::c_uint = 10;
pub const SDT_SYS386BSY: ::kernel::sys::raw::c_uint = 11;
pub const SDT_SYSBSY: ::kernel::sys::raw::c_uint = 11;
pub const SDT_SYS386CGT: ::kernel::sys::raw::c_uint = 12;
pub const SDT_SYSCGT: ::kernel::sys::raw::c_uint = 12;
pub const SDT_SYSNULL4: ::kernel::sys::raw::c_uint = 13;
pub const SDT_SYS386IGT: ::kernel::sys::raw::c_uint = 14;
pub const SDT_SYSIGT: ::kernel::sys::raw::c_uint = 14;
pub const SDT_SYS386TGT: ::kernel::sys::raw::c_uint = 15;
pub const SDT_SYSTGT: ::kernel::sys::raw::c_uint = 15;
pub const SDT_MEMRO: ::kernel::sys::raw::c_uint = 16;
pub const SDT_MEMROA: ::kernel::sys::raw::c_uint = 17;
pub const SDT_MEMRW: ::kernel::sys::raw::c_uint = 18;
pub const SDT_MEMRWA: ::kernel::sys::raw::c_uint = 19;
pub const SDT_MEMROD: ::kernel::sys::raw::c_uint = 20;
pub const SDT_MEMRODA: ::kernel::sys::raw::c_uint = 21;
pub const SDT_MEMRWD: ::kernel::sys::raw::c_uint = 22;
pub const SDT_MEMRWDA: ::kernel::sys::raw::c_uint = 23;
pub const SDT_MEME: ::kernel::sys::raw::c_uint = 24;
pub const SDT_MEMEA: ::kernel::sys::raw::c_uint = 25;
pub const SDT_MEMER: ::kernel::sys::raw::c_uint = 26;
pub const SDT_MEMERA: ::kernel::sys::raw::c_uint = 27;
pub const SDT_MEMEC: ::kernel::sys::raw::c_uint = 28;
pub const SDT_MEMEAC: ::kernel::sys::raw::c_uint = 29;
pub const SDT_MEMERC: ::kernel::sys::raw::c_uint = 30;
pub const SDT_MEMERAC: ::kernel::sys::raw::c_uint = 31;
pub const NIDT: ::kernel::sys::raw::c_uint = 256;
pub const NRSVIDT: ::kernel::sys::raw::c_uint = 32;
pub const IDT_DE: ::kernel::sys::raw::c_uint = 0;
pub const IDT_DB: ::kernel::sys::raw::c_uint = 1;
pub const IDT_NMI: ::kernel::sys::raw::c_uint = 2;
pub const IDT_BP: ::kernel::sys::raw::c_uint = 3;
pub const IDT_OF: ::kernel::sys::raw::c_uint = 4;
pub const IDT_BR: ::kernel::sys::raw::c_uint = 5;
pub const IDT_UD: ::kernel::sys::raw::c_uint = 6;
pub const IDT_NM: ::kernel::sys::raw::c_uint = 7;
pub const IDT_DF: ::kernel::sys::raw::c_uint = 8;
pub const IDT_FPUGP: ::kernel::sys::raw::c_uint = 9;
pub const IDT_TS: ::kernel::sys::raw::c_uint = 10;
pub const IDT_NP: ::kernel::sys::raw::c_uint = 11;
pub const IDT_SS: ::kernel::sys::raw::c_uint = 12;
pub const IDT_GP: ::kernel::sys::raw::c_uint = 13;
pub const IDT_PF: ::kernel::sys::raw::c_uint = 14;
pub const IDT_MF: ::kernel::sys::raw::c_uint = 16;
pub const IDT_AC: ::kernel::sys::raw::c_uint = 17;
pub const IDT_MC: ::kernel::sys::raw::c_uint = 18;
pub const IDT_XF: ::kernel::sys::raw::c_uint = 19;
pub const IDT_IO_INTS: ::kernel::sys::raw::c_uint = 32;
pub const IDT_SYSCALL: ::kernel::sys::raw::c_uint = 128;
pub const IDT_DTRACE_RET: ::kernel::sys::raw::c_uint = 146;
pub const IDT_EVTCHN: ::kernel::sys::raw::c_uint = 147;
pub const GNULL_SEL: ::kernel::sys::raw::c_uint = 0;
pub const GNULL2_SEL: ::kernel::sys::raw::c_uint = 1;
pub const GUFS32_SEL: ::kernel::sys::raw::c_uint = 2;
pub const GUGS32_SEL: ::kernel::sys::raw::c_uint = 3;
pub const GCODE_SEL: ::kernel::sys::raw::c_uint = 4;
pub const GDATA_SEL: ::kernel::sys::raw::c_uint = 5;
pub const GUCODE32_SEL: ::kernel::sys::raw::c_uint = 6;
pub const GUDATA_SEL: ::kernel::sys::raw::c_uint = 7;
pub const GUCODE_SEL: ::kernel::sys::raw::c_uint = 8;
pub const GPROC0_SEL: ::kernel::sys::raw::c_uint = 9;
pub const GUSERLDT_SEL: ::kernel::sys::raw::c_uint = 11;
pub const NGDT: ::kernel::sys::raw::c_uint = 13;
pub const IOCPARM_SHIFT: ::kernel::sys::raw::c_uint = 13;
pub const IOCPARM_MASK: ::kernel::sys::raw::c_uint = 8191;
pub const IOCPARM_MAX: ::kernel::sys::raw::c_uint = 8192;
pub const IOC_VOID: ::kernel::sys::raw::c_uint = 536870912;
pub const IOC_OUT: ::kernel::sys::raw::c_uint = 1073741824;
pub const IOC_IN: ::kernel::sys::raw::c_uint = 2147483648;
pub const IOC_INOUT: ::kernel::sys::raw::c_uint = 3221225472;
pub const IOC_DIRMASK: ::kernel::sys::raw::c_uint = 3758096384;
pub const BUS_USER_VERSION: ::kernel::sys::raw::c_uint = 1;
pub const DF_ENABLED: ::kernel::sys::raw::c_uint = 1;
pub const DF_FIXEDCLASS: ::kernel::sys::raw::c_uint = 2;
pub const DF_WILDCARD: ::kernel::sys::raw::c_uint = 4;
pub const DF_DESCMALLOCED: ::kernel::sys::raw::c_uint = 8;
pub const DF_QUIET: ::kernel::sys::raw::c_uint = 16;
pub const DF_DONENOMATCH: ::kernel::sys::raw::c_uint = 32;
pub const DF_EXTERNALSOFTC: ::kernel::sys::raw::c_uint = 64;
pub const DF_REBID: ::kernel::sys::raw::c_uint = 128;
pub const DF_SUSPENDED: ::kernel::sys::raw::c_uint = 256;
pub const DF_QUIET_CHILDREN: ::kernel::sys::raw::c_uint = 512;
pub const DEVF_FORCE_DETACH: ::kernel::sys::raw::c_uint = 1;
pub const DEVF_SET_DRIVER_DETACH: ::kernel::sys::raw::c_uint = 1;
pub const DEVF_CLEAR_DRIVER_DETACH: ::kernel::sys::raw::c_uint = 1;
pub const DEVF_FORCE_DELETE: ::kernel::sys::raw::c_uint = 1;
pub const KTR_GEN: ::kernel::sys::raw::c_uint = 1;
pub const KTR_NET: ::kernel::sys::raw::c_uint = 2;
pub const KTR_DEV: ::kernel::sys::raw::c_uint = 4;
pub const KTR_LOCK: ::kernel::sys::raw::c_uint = 8;
pub const KTR_SMP: ::kernel::sys::raw::c_uint = 16;
pub const KTR_SUBSYS: ::kernel::sys::raw::c_uint = 32;
pub const KTR_PMAP: ::kernel::sys::raw::c_uint = 64;
pub const KTR_MALLOC: ::kernel::sys::raw::c_uint = 128;
pub const KTR_TRAP: ::kernel::sys::raw::c_uint = 256;
pub const KTR_INTR: ::kernel::sys::raw::c_uint = 512;
pub const KTR_SIG: ::kernel::sys::raw::c_uint = 1024;
pub const KTR_SPARE2: ::kernel::sys::raw::c_uint = 2048;
pub const KTR_PROC: ::kernel::sys::raw::c_uint = 4096;
pub const KTR_SYSC: ::kernel::sys::raw::c_uint = 8192;
pub const KTR_INIT: ::kernel::sys::raw::c_uint = 16384;
pub const KTR_SPARE3: ::kernel::sys::raw::c_uint = 32768;
pub const KTR_SPARE4: ::kernel::sys::raw::c_uint = 65536;
pub const KTR_EVH: ::kernel::sys::raw::c_uint = 131072;
pub const KTR_VFS: ::kernel::sys::raw::c_uint = 262144;
pub const KTR_VOP: ::kernel::sys::raw::c_uint = 524288;
pub const KTR_VM: ::kernel::sys::raw::c_uint = 1048576;
pub const KTR_INET: ::kernel::sys::raw::c_uint = 2097152;
pub const KTR_RUNQ: ::kernel::sys::raw::c_uint = 4194304;
pub const KTR_SPARE5: ::kernel::sys::raw::c_uint = 8388608;
pub const KTR_UMA: ::kernel::sys::raw::c_uint = 16777216;
pub const KTR_CALLOUT: ::kernel::sys::raw::c_uint = 33554432;
pub const KTR_GEOM: ::kernel::sys::raw::c_uint = 67108864;
pub const KTR_BUSDMA: ::kernel::sys::raw::c_uint = 134217728;
pub const KTR_INET6: ::kernel::sys::raw::c_uint = 268435456;
pub const KTR_SCHED: ::kernel::sys::raw::c_uint = 536870912;
pub const KTR_BUF: ::kernel::sys::raw::c_uint = 1073741824;
pub const KTR_PTRACE: ::kernel::sys::raw::c_uint = 2147483648;
pub const KTR_ALL: ::kernel::sys::raw::c_uint = 4294967295;
pub const KTR_COMPILE: ::kernel::sys::raw::c_uint = 0;
pub const LC_SLEEPLOCK: ::kernel::sys::raw::c_uint = 1;
pub const LC_SPINLOCK: ::kernel::sys::raw::c_uint = 2;
pub const LC_SLEEPABLE: ::kernel::sys::raw::c_uint = 4;
pub const LC_RECURSABLE: ::kernel::sys::raw::c_uint = 8;
pub const LC_UPGRADABLE: ::kernel::sys::raw::c_uint = 16;
pub const LO_CLASSFLAGS: ::kernel::sys::raw::c_uint = 65535;
pub const LO_INITIALIZED: ::kernel::sys::raw::c_uint = 65536;
pub const LO_WITNESS: ::kernel::sys::raw::c_uint = 131072;
pub const LO_QUIET: ::kernel::sys::raw::c_uint = 262144;
pub const LO_RECURSABLE: ::kernel::sys::raw::c_uint = 524288;
pub const LO_SLEEPABLE: ::kernel::sys::raw::c_uint = 1048576;
pub const LO_UPGRADABLE: ::kernel::sys::raw::c_uint = 2097152;
pub const LO_DUPOK: ::kernel::sys::raw::c_uint = 4194304;
pub const LO_IS_VNODE: ::kernel::sys::raw::c_uint = 8388608;
pub const LO_CLASSMASK: ::kernel::sys::raw::c_uint = 251658240;
pub const LO_NOPROFILE: ::kernel::sys::raw::c_uint = 268435456;
pub const LO_NEW: ::kernel::sys::raw::c_uint = 536870912;
pub const LO_CLASSSHIFT: ::kernel::sys::raw::c_uint = 24;
pub const LOCK_CLASS_MAX: ::kernel::sys::raw::c_uint = 15;
pub const LOP_NEWORDER: ::kernel::sys::raw::c_uint = 1;
pub const LOP_QUIET: ::kernel::sys::raw::c_uint = 2;
pub const LOP_TRYLOCK: ::kernel::sys::raw::c_uint = 4;
pub const LOP_EXCLUSIVE: ::kernel::sys::raw::c_uint = 8;
pub const LOP_DUPOK: ::kernel::sys::raw::c_uint = 16;
pub const LA_MASKASSERT: ::kernel::sys::raw::c_uint = 255;
pub const LA_UNLOCKED: ::kernel::sys::raw::c_uint = 0;
pub const LA_LOCKED: ::kernel::sys::raw::c_uint = 1;
pub const LA_SLOCKED: ::kernel::sys::raw::c_uint = 2;
pub const LA_XLOCKED: ::kernel::sys::raw::c_uint = 4;
pub const LA_RECURSED: ::kernel::sys::raw::c_uint = 8;
pub const LA_NOTRECURSED: ::kernel::sys::raw::c_uint = 16;
pub const LOCK_DEBUG: ::kernel::sys::raw::c_uint = 1;
pub const KTR_VERSION: ::kernel::sys::raw::c_uint = 2;
pub const KTR_PARMS: ::kernel::sys::raw::c_uint = 6;
pub const CPU_SETSIZE: ::kernel::sys::raw::c_uint = 256;
pub const CPU_MAXSIZE: ::kernel::sys::raw::c_uint = 256;
pub const PRIO_MIN: ::kernel::sys::raw::c_int = -20;
pub const PRIO_MAX: ::kernel::sys::raw::c_uint = 20;
pub const PRIO_PROCESS: ::kernel::sys::raw::c_uint = 0;
pub const PRIO_PGRP: ::kernel::sys::raw::c_uint = 1;
pub const PRIO_USER: ::kernel::sys::raw::c_uint = 2;
pub const RUSAGE_SELF: ::kernel::sys::raw::c_uint = 0;
pub const RUSAGE_CHILDREN: ::kernel::sys::raw::c_int = -1;
pub const RUSAGE_THREAD: ::kernel::sys::raw::c_uint = 1;
pub const RLIMIT_CPU: ::kernel::sys::raw::c_uint = 0;
pub const RLIMIT_FSIZE: ::kernel::sys::raw::c_uint = 1;
pub const RLIMIT_DATA: ::kernel::sys::raw::c_uint = 2;
pub const RLIMIT_STACK: ::kernel::sys::raw::c_uint = 3;
pub const RLIMIT_CORE: ::kernel::sys::raw::c_uint = 4;
pub const RLIMIT_RSS: ::kernel::sys::raw::c_uint = 5;
pub const RLIMIT_MEMLOCK: ::kernel::sys::raw::c_uint = 6;
pub const RLIMIT_NPROC: ::kernel::sys::raw::c_uint = 7;
pub const RLIMIT_NOFILE: ::kernel::sys::raw::c_uint = 8;
pub const RLIMIT_SBSIZE: ::kernel::sys::raw::c_uint = 9;
pub const RLIMIT_VMEM: ::kernel::sys::raw::c_uint = 10;
pub const RLIMIT_AS: ::kernel::sys::raw::c_uint = 10;
pub const RLIMIT_NPTS: ::kernel::sys::raw::c_uint = 11;
pub const RLIMIT_SWAP: ::kernel::sys::raw::c_uint = 12;
pub const RLIMIT_KQUEUES: ::kernel::sys::raw::c_uint = 13;
pub const RLIMIT_UMTXP: ::kernel::sys::raw::c_uint = 14;
pub const RLIM_NLIMITS: ::kernel::sys::raw::c_uint = 15;
pub const CP_USER: ::kernel::sys::raw::c_uint = 0;
pub const CP_NICE: ::kernel::sys::raw::c_uint = 1;
pub const CP_SYS: ::kernel::sys::raw::c_uint = 2;
pub const CP_INTR: ::kernel::sys::raw::c_uint = 3;
pub const CP_IDLE: ::kernel::sys::raw::c_uint = 4;
pub const CPUSTATES: ::kernel::sys::raw::c_uint = 5;
pub const PC_PTI_STACK_SZ: ::kernel::sys::raw::c_uint = 16;
pub const PC_DBREG_CMD_NONE: ::kernel::sys::raw::c_uint = 0;
pub const PC_DBREG_CMD_LOAD: ::kernel::sys::raw::c_uint = 1;
pub const OFFSETOF_CURTHREAD: ::kernel::sys::raw::c_uint = 0;
pub const OFFSETOF_CURPCB: ::kernel::sys::raw::c_uint = 32;
pub const DPCPU_SETNAME: &'static [u8; 9usize] = b"set_pcpu\x00";
pub const DPCPU_SYMPREFIX: &'static [u8; 12usize] = b"pcpu_entry_\x00";
pub const DPCPU_MODMIN: ::kernel::sys::raw::c_uint = 2048;
pub const LOCKSTAT_WRITER: ::kernel::sys::raw::c_uint = 0;
pub const LOCKSTAT_READER: ::kernel::sys::raw::c_uint = 1;
pub const MTX_DEF: ::kernel::sys::raw::c_uint = 0;
pub const MTX_SPIN: ::kernel::sys::raw::c_uint = 1;
pub const MTX_RECURSE: ::kernel::sys::raw::c_uint = 4;
pub const MTX_NOWITNESS: ::kernel::sys::raw::c_uint = 8;
pub const MTX_NOPROFILE: ::kernel::sys::raw::c_uint = 32;
pub const MTX_NEW: ::kernel::sys::raw::c_uint = 64;
pub const MTX_QUIET: ::kernel::sys::raw::c_uint = 2;
pub const MTX_DUPOK: ::kernel::sys::raw::c_uint = 16;
pub const MTX_UNOWNED: ::kernel::sys::raw::c_uint = 0;
pub const MTX_RECURSED: ::kernel::sys::raw::c_uint = 1;
pub const MTX_CONTESTED: ::kernel::sys::raw::c_uint = 2;
pub const MTX_DESTROYED: ::kernel::sys::raw::c_uint = 4;
pub const MTX_FLAGMASK: ::kernel::sys::raw::c_uint = 7;
pub const MTX_NETWORK_LOCK: &'static [u8; 15usize] = b"network driver\x00";
pub const EHE_DEAD_PRIORITY: ::kernel::sys::raw::c_int = -1;
pub const EVENTHANDLER_PRI_FIRST: ::kernel::sys::raw::c_uint = 0;
pub const EVENTHANDLER_PRI_ANY: ::kernel::sys::raw::c_uint = 10000;
pub const EVENTHANDLER_PRI_LAST: ::kernel::sys::raw::c_uint = 20000;
pub const SHUTDOWN_PRI_FIRST: ::kernel::sys::raw::c_uint = 0;
pub const SHUTDOWN_PRI_DEFAULT: ::kernel::sys::raw::c_uint = 10000;
pub const SHUTDOWN_PRI_LAST: ::kernel::sys::raw::c_uint = 20000;
pub const LOWMEM_PRI_DEFAULT: ::kernel::sys::raw::c_uint = 0;
pub const KOBJ_CACHE_SIZE: ::kernel::sys::raw::c_uint = 256;
pub const FILTER_STRAY: ::kernel::sys::raw::c_uint = 1;
pub const FILTER_HANDLED: ::kernel::sys::raw::c_uint = 2;
pub const FILTER_SCHEDULE_THREAD: ::kernel::sys::raw::c_uint = 4;
pub const RLE_RESERVED: ::kernel::sys::raw::c_uint = 1;
pub const RLE_ALLOCATED: ::kernel::sys::raw::c_uint = 2;
pub const RLE_PREFETCH: ::kernel::sys::raw::c_uint = 4;
pub const BUS_PROBE_SPECIFIC: ::kernel::sys::raw::c_uint = 0;
pub const BUS_PROBE_VENDOR: ::kernel::sys::raw::c_int = -10;
pub const BUS_PROBE_DEFAULT: ::kernel::sys::raw::c_int = -20;
pub const BUS_PROBE_LOW_PRIORITY: ::kernel::sys::raw::c_int = -40;
pub const BUS_PROBE_GENERIC: ::kernel::sys::raw::c_int = -100;
pub const BUS_PROBE_HOOVER: ::kernel::sys::raw::c_int = -1000000;
pub const BUS_PROBE_NOWILDCARD: ::kernel::sys::raw::c_int = -2000000000;
pub const BUS_PASS_ROOT: ::kernel::sys::raw::c_uint = 0;
pub const BUS_PASS_BUS: ::kernel::sys::raw::c_uint = 10;
pub const BUS_PASS_CPU: ::kernel::sys::raw::c_uint = 20;
pub const BUS_PASS_RESOURCE: ::kernel::sys::raw::c_uint = 30;
pub const BUS_PASS_INTERRUPT: ::kernel::sys::raw::c_uint = 40;
pub const BUS_PASS_TIMER: ::kernel::sys::raw::c_uint = 50;
pub const BUS_PASS_SCHEDULER: ::kernel::sys::raw::c_uint = 60;
pub const BUS_PASS_SUPPORTDEV: ::kernel::sys::raw::c_uint = 100000;
pub const BUS_PASS_DEFAULT: ::kernel::sys::raw::c_uint = 2147483647;
pub const BUS_PASS_ORDER_FIRST: ::kernel::sys::raw::c_uint = 0;
pub const BUS_PASS_ORDER_EARLY: ::kernel::sys::raw::c_uint = 2;
pub const BUS_PASS_ORDER_MIDDLE: ::kernel::sys::raw::c_uint = 5;
pub const BUS_PASS_ORDER_LATE: ::kernel::sys::raw::c_uint = 7;
pub const BUS_PASS_ORDER_LAST: ::kernel::sys::raw::c_uint = 9;
pub const TS_ENTER: ::kernel::sys::raw::c_uint = 0;
pub const TS_EXIT: ::kernel::sys::raw::c_uint = 1;
pub const TS_THREAD: ::kernel::sys::raw::c_uint = 2;
pub const TS_EVENT: ::kernel::sys::raw::c_uint = 3;
pub const M_NOWAIT: ::kernel::sys::raw::c_uint = 1;
pub const M_WAITOK: ::kernel::sys::raw::c_uint = 2;
pub const M_ZERO: ::kernel::sys::raw::c_uint = 256;
pub const M_NOVM: ::kernel::sys::raw::c_uint = 512;
pub const M_USE_RESERVE: ::kernel::sys::raw::c_uint = 1024;
pub const M_NODUMP: ::kernel::sys::raw::c_uint = 2048;
pub const M_FIRSTFIT: ::kernel::sys::raw::c_uint = 4096;
pub const M_BESTFIT: ::kernel::sys::raw::c_uint = 8192;
pub const M_MAGIC: ::kernel::sys::raw::c_uint = 877983977;
pub const M_ZERO_INVARIANTS: ::kernel::sys::raw::c_uint = 0;
pub const DTMALLOC_PROBE_MALLOC: ::kernel::sys::raw::c_uint = 0;
pub const DTMALLOC_PROBE_FREE: ::kernel::sys::raw::c_uint = 1;
pub const DTMALLOC_PROBE_MAX: ::kernel::sys::raw::c_uint = 2;
pub const MALLOC_TYPE_STREAM_VERSION: ::kernel::sys::raw::c_uint = 1;
pub const MALLOC_MAX_NAME: ::kernel::sys::raw::c_uint = 32;
pub const UMA_SMALLEST_UNIT: ::kernel::sys::raw::c_uint = 16;
pub const UMA_ZONE_PAGEABLE: ::kernel::sys::raw::c_uint = 1;
pub const UMA_ZONE_ZINIT: ::kernel::sys::raw::c_uint = 2;
pub const UMA_ZONE_STATIC: ::kernel::sys::raw::c_uint = 4;
pub const UMA_ZONE_OFFPAGE: ::kernel::sys::raw::c_uint = 8;
pub const UMA_ZONE_MALLOC: ::kernel::sys::raw::c_uint = 16;
pub const UMA_ZONE_NOFREE: ::kernel::sys::raw::c_uint = 32;
pub const UMA_ZONE_MTXCLASS: ::kernel::sys::raw::c_uint = 64;
pub const UMA_ZONE_VM: ::kernel::sys::raw::c_uint = 128;
pub const UMA_ZONE_HASH: ::kernel::sys::raw::c_uint = 256;
pub const UMA_ZONE_SECONDARY: ::kernel::sys::raw::c_uint = 512;
pub const UMA_ZONE_NOBUCKET: ::kernel::sys::raw::c_uint = 1024;
pub const UMA_ZONE_MAXBUCKET: ::kernel::sys::raw::c_uint = 2048;
pub const UMA_ZONE_CACHESPREAD: ::kernel::sys::raw::c_uint = 4096;
pub const UMA_ZONE_VTOSLAB: ::kernel::sys::raw::c_uint = 8192;
pub const UMA_ZONE_NODUMP: ::kernel::sys::raw::c_uint = 16384;
pub const UMA_ZONE_PCPU: ::kernel::sys::raw::c_uint = 32768;
pub const UMA_ZONE_NUMA: ::kernel::sys::raw::c_uint = 65536;
pub const UMA_ZONE_NOBUCKETCACHE: ::kernel::sys::raw::c_uint = 131072;
pub const UMA_ZONE_INHERIT: ::kernel::sys::raw::c_uint = 41272;
pub const UMA_ALIGN_CACHE: ::kernel::sys::raw::c_int = -1;
pub const UMA_SLAB_BOOT: ::kernel::sys::raw::c_uint = 1;
pub const UMA_SLAB_KERNEL: ::kernel::sys::raw::c_uint = 4;
pub const UMA_SLAB_PRIV: ::kernel::sys::raw::c_uint = 8;
pub const UMA_SLAB_OFFP: ::kernel::sys::raw::c_uint = 16;
pub const UMA_SLAB_MALLOC: ::kernel::sys::raw::c_uint = 32;
pub const UMA_STREAM_VERSION: ::kernel::sys::raw::c_uint = 1;
pub const UTH_MAX_NAME: ::kernel::sys::raw::c_uint = 32;
pub const UTH_ZONE_SECONDARY: ::kernel::sys::raw::c_uint = 1;
pub const M_EXT: ::kernel::sys::raw::c_uint = 1;
pub const M_PKTHDR: ::kernel::sys::raw::c_uint = 2;
pub const M_EOR: ::kernel::sys::raw::c_uint = 4;
pub const M_RDONLY: ::kernel::sys::raw::c_uint = 8;
pub const M_BCAST: ::kernel::sys::raw::c_uint = 16;
pub const M_MCAST: ::kernel::sys::raw::c_uint = 32;
pub const M_PROMISC: ::kernel::sys::raw::c_uint = 64;
pub const M_VLANTAG: ::kernel::sys::raw::c_uint = 128;
pub const M_UNUSED_8: ::kernel::sys::raw::c_uint = 256;
pub const M_NOFREE: ::kernel::sys::raw::c_uint = 512;
pub const M_TSTMP: ::kernel::sys::raw::c_uint = 1024;
pub const M_TSTMP_HPREC: ::kernel::sys::raw::c_uint = 2048;
pub const M_PROTO1: ::kernel::sys::raw::c_uint = 4096;
pub const M_PROTO2: ::kernel::sys::raw::c_uint = 8192;
pub const M_PROTO3: ::kernel::sys::raw::c_uint = 16384;
pub const M_PROTO4: ::kernel::sys::raw::c_uint = 32768;
pub const M_PROTO5: ::kernel::sys::raw::c_uint = 65536;
pub const M_PROTO6: ::kernel::sys::raw::c_uint = 131072;
pub const M_PROTO7: ::kernel::sys::raw::c_uint = 262144;
pub const M_PROTO8: ::kernel::sys::raw::c_uint = 524288;
pub const M_PROTO9: ::kernel::sys::raw::c_uint = 1048576;
pub const M_PROTO10: ::kernel::sys::raw::c_uint = 2097152;
pub const M_PROTO11: ::kernel::sys::raw::c_uint = 4194304;
pub const M_PROTO12: ::kernel::sys::raw::c_uint = 8388608;
pub const MB_DTOR_SKIP: ::kernel::sys::raw::c_uint = 1;
pub const M_PROTOFLAGS: ::kernel::sys::raw::c_uint = 16773120;
pub const M_COPYFLAGS: ::kernel::sys::raw::c_uint = 16776446;
pub const M_FLAG_BITS: &'static [u8; 101usize] =
    b"\x10\x01M_EXT\\2M_PKTHDR\\3M_EOR\\4M_RDONLY\\5M_BCAST\\6M_MCAST\x07M_PROMISC\\10M_VLANTAG\\13M_TSTMP\\14M_TSTMP_HPREC\x00";
pub const M_FLAG_PROTOBITS: &'static [u8; 130usize] =
    b"\rM_PROTO1\\16M_PROTO2\\17M_PROTO3\\20M_PROTO4\\21M_PROTO5\x12M_PROTO6\\23M_PROTO7\\24M_PROTO8\\25M_PROTO9\\26M_PROTO10\x17M_PROTO11\\30M_PROTO12\x00";
pub const M_FLAG_PRINTF: &'static [u8; 230usize] =
    b"\x10\x01M_EXT\\2M_PKTHDR\\3M_EOR\\4M_RDONLY\\5M_BCAST\\6M_MCAST\x07M_PROMISC\\10M_VLANTAG\\13M_TSTMP\\14M_TSTMP_HPREC\rM_PROTO1\\16M_PROTO2\\17M_PROTO3\\20M_PROTO4\\21M_PROTO5\x12M_PROTO6\\23M_PROTO7\\24M_PROTO8\\25M_PROTO9\\26M_PROTO10\x17M_PROTO11\\30M_PROTO12\x00";
pub const M_HASHTYPE_HASHPROP: ::kernel::sys::raw::c_uint = 128;
pub const M_HASHTYPE_NONE: ::kernel::sys::raw::c_uint = 0;
pub const M_HASHTYPE_OPAQUE: ::kernel::sys::raw::c_uint = 63;
pub const QOS_DSCP_CS0: ::kernel::sys::raw::c_uint = 0;
pub const QOS_DSCP_DEF: ::kernel::sys::raw::c_uint = 0;
pub const QOS_DSCP_CS1: ::kernel::sys::raw::c_uint = 32;
pub const QOS_DSCP_AF11: ::kernel::sys::raw::c_uint = 40;
pub const QOS_DSCP_AF12: ::kernel::sys::raw::c_uint = 48;
pub const QOS_DSCP_AF13: ::kernel::sys::raw::c_uint = 56;
pub const QOS_DSCP_CS2: ::kernel::sys::raw::c_uint = 64;
pub const QOS_DSCP_AF21: ::kernel::sys::raw::c_uint = 72;
pub const QOS_DSCP_AF22: ::kernel::sys::raw::c_uint = 80;
pub const QOS_DSCP_AF23: ::kernel::sys::raw::c_uint = 88;
pub const QOS_DSCP_CS3: ::kernel::sys::raw::c_uint = 96;
pub const QOS_DSCP_AF31: ::kernel::sys::raw::c_uint = 104;
pub const QOS_DSCP_AF32: ::kernel::sys::raw::c_uint = 112;
pub const QOS_DSCP_AF33: ::kernel::sys::raw::c_uint = 120;
pub const QOS_DSCP_CS4: ::kernel::sys::raw::c_uint = 128;
pub const QOS_DSCP_AF41: ::kernel::sys::raw::c_uint = 136;
pub const QOS_DSCP_AF42: ::kernel::sys::raw::c_uint = 144;
pub const QOS_DSCP_AF43: ::kernel::sys::raw::c_uint = 152;
pub const QOS_DSCP_CS5: ::kernel::sys::raw::c_uint = 160;
pub const QOS_DSCP_EF: ::kernel::sys::raw::c_uint = 184;
pub const QOS_DSCP_CS6: ::kernel::sys::raw::c_uint = 192;
pub const QOS_DSCP_CS7: ::kernel::sys::raw::c_uint = 224;
pub const EXT_CLUSTER: ::kernel::sys::raw::c_uint = 1;
pub const EXT_SFBUF: ::kernel::sys::raw::c_uint = 2;
pub const EXT_JUMBOP: ::kernel::sys::raw::c_uint = 3;
pub const EXT_JUMBO9: ::kernel::sys::raw::c_uint = 4;
pub const EXT_JUMBO16: ::kernel::sys::raw::c_uint = 5;
pub const EXT_PACKET: ::kernel::sys::raw::c_uint = 6;
pub const EXT_MBUF: ::kernel::sys::raw::c_uint = 7;
pub const EXT_VENDOR1: ::kernel::sys::raw::c_uint = 224;
pub const EXT_VENDOR2: ::kernel::sys::raw::c_uint = 225;
pub const EXT_VENDOR3: ::kernel::sys::raw::c_uint = 226;
pub const EXT_VENDOR4: ::kernel::sys::raw::c_uint = 227;
pub const EXT_EXP1: ::kernel::sys::raw::c_uint = 244;
pub const EXT_EXP2: ::kernel::sys::raw::c_uint = 245;
pub const EXT_EXP3: ::kernel::sys::raw::c_uint = 246;
pub const EXT_EXP4: ::kernel::sys::raw::c_uint = 247;
pub const EXT_NET_DRV: ::kernel::sys::raw::c_uint = 252;
pub const EXT_MOD_TYPE: ::kernel::sys::raw::c_uint = 253;
pub const EXT_DISPOSABLE: ::kernel::sys::raw::c_uint = 254;
pub const EXT_EXTREF: ::kernel::sys::raw::c_uint = 255;
pub const EXT_FLAG_EMBREF: ::kernel::sys::raw::c_uint = 1;
pub const EXT_FLAG_EXTREF: ::kernel::sys::raw::c_uint = 2;
pub const EXT_FLAG_NOFREE: ::kernel::sys::raw::c_uint = 16;
pub const EXT_FLAG_VENDOR1: ::kernel::sys::raw::c_uint = 65536;
pub const EXT_FLAG_VENDOR2: ::kernel::sys::raw::c_uint = 131072;
pub const EXT_FLAG_VENDOR3: ::kernel::sys::raw::c_uint = 262144;
pub const EXT_FLAG_VENDOR4: ::kernel::sys::raw::c_uint = 524288;
pub const EXT_FLAG_EXP1: ::kernel::sys::raw::c_uint = 1048576;
pub const EXT_FLAG_EXP2: ::kernel::sys::raw::c_uint = 2097152;
pub const EXT_FLAG_EXP3: ::kernel::sys::raw::c_uint = 4194304;
pub const EXT_FLAG_EXP4: ::kernel::sys::raw::c_uint = 8388608;
pub const EXT_FLAG_BITS: &'static [u8; 186usize] =
    b"\x10\x01EXT_FLAG_EMBREF\\2EXT_FLAG_EXTREF\\5EXT_FLAG_NOFREE\x11EXT_FLAG_VENDOR1\\22EXT_FLAG_VENDOR2\\23EXT_FLAG_VENDOR3\x14EXT_FLAG_VENDOR4\\25EXT_FLAG_EXP1\\26EXT_FLAG_EXP2\\27EXT_FLAG_EXP3\x18EXT_FLAG_EXP4\x00";
pub const CSUM_IP: ::kernel::sys::raw::c_uint = 1;
pub const CSUM_IP_UDP: ::kernel::sys::raw::c_uint = 2;
pub const CSUM_IP_TCP: ::kernel::sys::raw::c_uint = 4;
pub const CSUM_IP_SCTP: ::kernel::sys::raw::c_uint = 8;
pub const CSUM_IP_TSO: ::kernel::sys::raw::c_uint = 16;
pub const CSUM_IP_ISCSI: ::kernel::sys::raw::c_uint = 32;
pub const CSUM_IP6_UDP: ::kernel::sys::raw::c_uint = 512;
pub const CSUM_IP6_TCP: ::kernel::sys::raw::c_uint = 1024;
pub const CSUM_IP6_SCTP: ::kernel::sys::raw::c_uint = 2048;
pub const CSUM_IP6_TSO: ::kernel::sys::raw::c_uint = 4096;
pub const CSUM_IP6_ISCSI: ::kernel::sys::raw::c_uint = 8192;
pub const CSUM_L3_CALC: ::kernel::sys::raw::c_uint = 16777216;
pub const CSUM_L3_VALID: ::kernel::sys::raw::c_uint = 33554432;
pub const CSUM_L4_CALC: ::kernel::sys::raw::c_uint = 67108864;
pub const CSUM_L4_VALID: ::kernel::sys::raw::c_uint = 134217728;
pub const CSUM_L5_CALC: ::kernel::sys::raw::c_uint = 268435456;
pub const CSUM_L5_VALID: ::kernel::sys::raw::c_uint = 536870912;
pub const CSUM_COALESCED: ::kernel::sys::raw::c_uint = 1073741824;
pub const CSUM_BITS: &'static [u8; 257usize] =
    b"\x10\x01CSUM_IP\\2CSUM_IP_UDP\\3CSUM_IP_TCP\\4CSUM_IP_SCTP\\5CSUM_IP_TSO\x06CSUM_IP_ISCSI\nCSUM_IP6_UDP\\13CSUM_IP6_TCP\\14CSUM_IP6_SCTP\\15CSUM_IP6_TSO\x0eCSUM_IP6_ISCSI\x19CSUM_L3_CALC\\32CSUM_L3_VALID\\33CSUM_L4_CALC\\34CSUM_L4_VALID\x1dCSUM_L5_CALC\\36CSUM_L5_VALID\\37CSUM_COALESCED\x00";
pub const CSUM_IP_CHECKED: ::kernel::sys::raw::c_uint = 16777216;
pub const CSUM_IP_VALID: ::kernel::sys::raw::c_uint = 33554432;
pub const CSUM_DATA_VALID: ::kernel::sys::raw::c_uint = 134217728;
pub const CSUM_PSEUDO_HDR: ::kernel::sys::raw::c_uint = 67108864;
pub const CSUM_SCTP_VALID: ::kernel::sys::raw::c_uint = 134217728;
pub const CSUM_DELAY_IP: ::kernel::sys::raw::c_uint = 1;
pub const CSUM_DATA_VALID_IPV6: ::kernel::sys::raw::c_uint = 134217728;
pub const CSUM_TCP: ::kernel::sys::raw::c_uint = 4;
pub const CSUM_UDP: ::kernel::sys::raw::c_uint = 2;
pub const CSUM_SCTP: ::kernel::sys::raw::c_uint = 8;
pub const CSUM_TSO: ::kernel::sys::raw::c_uint = 4112;
pub const CSUM_UDP_IPV6: ::kernel::sys::raw::c_uint = 512;
pub const CSUM_TCP_IPV6: ::kernel::sys::raw::c_uint = 1024;
pub const CSUM_SCTP_IPV6: ::kernel::sys::raw::c_uint = 2048;
pub const MT_NOTMBUF: ::kernel::sys::raw::c_uint = 0;
pub const MT_DATA: ::kernel::sys::raw::c_uint = 1;
pub const MT_HEADER: ::kernel::sys::raw::c_uint = 1;
pub const MT_VENDOR1: ::kernel::sys::raw::c_uint = 4;
pub const MT_VENDOR2: ::kernel::sys::raw::c_uint = 5;
pub const MT_VENDOR3: ::kernel::sys::raw::c_uint = 6;
pub const MT_VENDOR4: ::kernel::sys::raw::c_uint = 7;
pub const MT_SONAME: ::kernel::sys::raw::c_uint = 8;
pub const MT_EXP1: ::kernel::sys::raw::c_uint = 9;
pub const MT_EXP2: ::kernel::sys::raw::c_uint = 10;
pub const MT_EXP3: ::kernel::sys::raw::c_uint = 11;
pub const MT_EXP4: ::kernel::sys::raw::c_uint = 12;
pub const MT_CONTROL: ::kernel::sys::raw::c_uint = 14;
pub const MT_OOBDATA: ::kernel::sys::raw::c_uint = 15;
pub const MT_NTYPES: ::kernel::sys::raw::c_uint = 16;
pub const MT_NOINIT: ::kernel::sys::raw::c_uint = 255;
pub const MBUF_MEM_NAME: &'static [u8; 5usize] = b"mbuf\x00";
pub const MBUF_CLUSTER_MEM_NAME: &'static [u8; 13usize] = b"mbuf_cluster\x00";
pub const MBUF_PACKET_MEM_NAME: &'static [u8; 12usize] = b"mbuf_packet\x00";
pub const MBUF_JUMBOP_MEM_NAME: &'static [u8; 16usize] =
    b"mbuf_jumbo_page\x00";
pub const MBUF_JUMBO9_MEM_NAME: &'static [u8; 14usize] = b"mbuf_jumbo_9k\x00";
pub const MBUF_JUMBO16_MEM_NAME: &'static [u8; 15usize] =
    b"mbuf_jumbo_16k\x00";
pub const MBUF_TAG_MEM_NAME: &'static [u8; 9usize] = b"mbuf_tag\x00";
pub const MBUF_EXTREFCNT_MEM_NAME: &'static [u8; 16usize] =
    b"mbuf_ext_refcnt\x00";
pub const M_COPYALL: ::kernel::sys::raw::c_uint = 1000000000;
pub const MTAG_PERSISTENT: ::kernel::sys::raw::c_uint = 2048;
pub const PACKET_TAG_NONE: ::kernel::sys::raw::c_uint = 0;
pub const PACKET_TAG_IPSEC_IN_DONE: ::kernel::sys::raw::c_uint = 1;
pub const PACKET_TAG_IPSEC_OUT_DONE: ::kernel::sys::raw::c_uint = 2;
pub const PACKET_TAG_IPSEC_IN_CRYPTO_DONE: ::kernel::sys::raw::c_uint = 3;
pub const PACKET_TAG_IPSEC_OUT_CRYPTO_NEEDED: ::kernel::sys::raw::c_uint = 4;
pub const PACKET_TAG_IPSEC_IN_COULD_DO_CRYPTO: ::kernel::sys::raw::c_uint = 5;
pub const PACKET_TAG_IPSEC_PENDING_TDB: ::kernel::sys::raw::c_uint = 6;
pub const PACKET_TAG_BRIDGE: ::kernel::sys::raw::c_uint = 7;
pub const PACKET_TAG_GIF: ::kernel::sys::raw::c_uint = 8;
pub const PACKET_TAG_GRE: ::kernel::sys::raw::c_uint = 9;
pub const PACKET_TAG_IN_PACKET_CHECKSUM: ::kernel::sys::raw::c_uint = 10;
pub const PACKET_TAG_ENCAP: ::kernel::sys::raw::c_uint = 11;
pub const PACKET_TAG_IPSEC_SOCKET: ::kernel::sys::raw::c_uint = 12;
pub const PACKET_TAG_IPSEC_HISTORY: ::kernel::sys::raw::c_uint = 13;
pub const PACKET_TAG_IPV6_INPUT: ::kernel::sys::raw::c_uint = 14;
pub const PACKET_TAG_DUMMYNET: ::kernel::sys::raw::c_uint = 15;
pub const PACKET_TAG_DIVERT: ::kernel::sys::raw::c_uint = 17;
pub const PACKET_TAG_IPFORWARD: ::kernel::sys::raw::c_uint = 18;
pub const PACKET_TAG_MACLABEL: ::kernel::sys::raw::c_uint = 2067;
pub const PACKET_TAG_PF: ::kernel::sys::raw::c_uint = 2069;
pub const PACKET_TAG_RTSOCKFAM: ::kernel::sys::raw::c_uint = 25;
pub const PACKET_TAG_IPOPTIONS: ::kernel::sys::raw::c_uint = 27;
pub const PACKET_TAG_CARP: ::kernel::sys::raw::c_uint = 28;
pub const PACKET_TAG_IPSEC_NAT_T_PORTS: ::kernel::sys::raw::c_uint = 29;
pub const PACKET_TAG_ND_OUTGOING: ::kernel::sys::raw::c_uint = 30;
pub const MTAG_ABI_COMPAT: ::kernel::sys::raw::c_uint = 0;
pub const MBUF_HASHFLAG_L2: ::kernel::sys::raw::c_uint = 4;
pub const MBUF_HASHFLAG_L3: ::kernel::sys::raw::c_uint = 8;
pub const MBUF_HASHFLAG_L4: ::kernel::sys::raw::c_uint = 16;
pub const MDT_DEPEND: ::kernel::sys::raw::c_uint = 1;
pub const MDT_MODULE: ::kernel::sys::raw::c_uint = 2;
pub const MDT_VERSION: ::kernel::sys::raw::c_uint = 3;
pub const MDT_PNP_INFO: ::kernel::sys::raw::c_uint = 4;
pub const MDT_STRUCT_VERSION: ::kernel::sys::raw::c_uint = 1;
pub const MDT_SETNAME: &'static [u8; 16usize] = b"modmetadata_set\x00";
pub const MAXMODNAME: ::kernel::sys::raw::c_uint = 32;
pub const _SYS_RMAN_H_: ::kernel::sys::raw::c_uint = 1;
pub const _MACHINE_RESOURCE_H_: ::kernel::sys::raw::c_uint = 1;
pub const SYS_RES_IRQ: ::kernel::sys::raw::c_uint = 1;
pub const SYS_RES_DRQ: ::kernel::sys::raw::c_uint = 2;
pub const SYS_RES_MEMORY: ::kernel::sys::raw::c_uint = 3;
pub const SYS_RES_IOPORT: ::kernel::sys::raw::c_uint = 4;
pub const RF_ALLOCATED: ::kernel::sys::raw::c_uint = 1;
pub const RF_ACTIVE: ::kernel::sys::raw::c_uint = 2;
pub const RF_SHAREABLE: ::kernel::sys::raw::c_uint = 4;
pub const RF_SPARE1: ::kernel::sys::raw::c_uint = 8;
pub const RF_SPARE2: ::kernel::sys::raw::c_uint = 16;
pub const RF_FIRSTSHARE: ::kernel::sys::raw::c_uint = 32;
pub const RF_PREFETCHABLE: ::kernel::sys::raw::c_uint = 64;
pub const RF_OPTIONAL: ::kernel::sys::raw::c_uint = 128;
pub const RF_UNMAPPED: ::kernel::sys::raw::c_uint = 256;
pub const RF_ALIGNMENT_SHIFT: ::kernel::sys::raw::c_uint = 10;
pub const RF_ALIGNMENT_MASK: ::kernel::sys::raw::c_uint = 64512;
pub const RM_TEXTLEN: ::kernel::sys::raw::c_uint = 32;
pub const CPU_LEVEL_ROOT: ::kernel::sys::raw::c_uint = 1;
pub const CPU_LEVEL_CPUSET: ::kernel::sys::raw::c_uint = 2;
pub const CPU_LEVEL_WHICH: ::kernel::sys::raw::c_uint = 3;
pub const CPU_WHICH_TID: ::kernel::sys::raw::c_uint = 1;
pub const CPU_WHICH_PID: ::kernel::sys::raw::c_uint = 2;
pub const CPU_WHICH_CPUSET: ::kernel::sys::raw::c_uint = 3;
pub const CPU_WHICH_IRQ: ::kernel::sys::raw::c_uint = 4;
pub const CPU_WHICH_JAIL: ::kernel::sys::raw::c_uint = 5;
pub const CPU_WHICH_DOMAIN: ::kernel::sys::raw::c_uint = 6;
pub const CPU_WHICH_INTRHANDLER: ::kernel::sys::raw::c_uint = 7;
pub const CPU_WHICH_ITHREAD: ::kernel::sys::raw::c_uint = 8;
pub const CPUSET_INVALID: ::kernel::sys::raw::c_int = -1;
pub const CPUSET_DEFAULT: ::kernel::sys::raw::c_uint = 0;
pub const CPU_SET_ROOT: ::kernel::sys::raw::c_uint = 1;
pub const CPU_SET_RDONLY: ::kernel::sys::raw::c_uint = 2;
pub const CG_SHARE_NONE: ::kernel::sys::raw::c_uint = 0;
pub const CG_SHARE_L1: ::kernel::sys::raw::c_uint = 1;
pub const CG_SHARE_L2: ::kernel::sys::raw::c_uint = 2;
pub const CG_SHARE_L3: ::kernel::sys::raw::c_uint = 3;
pub const MAX_CACHE_LEVELS: ::kernel::sys::raw::c_uint = 3;
pub const CG_FLAG_HTT: ::kernel::sys::raw::c_uint = 1;
pub const CG_FLAG_SMT: ::kernel::sys::raw::c_uint = 2;
pub const CG_FLAG_THREAD: ::kernel::sys::raw::c_uint = 3;
pub const SOCK_STREAM: ::kernel::sys::raw::c_uint = 1;
pub const SOCK_DGRAM: ::kernel::sys::raw::c_uint = 2;
pub const SOCK_RAW: ::kernel::sys::raw::c_uint = 3;
pub const SOCK_RDM: ::kernel::sys::raw::c_uint = 4;
pub const SOCK_SEQPACKET: ::kernel::sys::raw::c_uint = 5;
pub const SOCK_CLOEXEC: ::kernel::sys::raw::c_uint = 268435456;
pub const SOCK_NONBLOCK: ::kernel::sys::raw::c_uint = 536870912;
pub const ACCEPT4_INHERIT: ::kernel::sys::raw::c_uint = 1;
pub const ACCEPT4_COMPAT: ::kernel::sys::raw::c_uint = 2;
pub const SO_DEBUG: ::kernel::sys::raw::c_uint = 1;
pub const SO_ACCEPTCONN: ::kernel::sys::raw::c_uint = 2;
pub const SO_REUSEADDR: ::kernel::sys::raw::c_uint = 4;
pub const SO_KEEPALIVE: ::kernel::sys::raw::c_uint = 8;
pub const SO_DONTROUTE: ::kernel::sys::raw::c_uint = 16;
pub const SO_BROADCAST: ::kernel::sys::raw::c_uint = 32;
pub const SO_USELOOPBACK: ::kernel::sys::raw::c_uint = 64;
pub const SO_LINGER: ::kernel::sys::raw::c_uint = 128;
pub const SO_OOBINLINE: ::kernel::sys::raw::c_uint = 256;
pub const SO_REUSEPORT: ::kernel::sys::raw::c_uint = 512;
pub const SO_TIMESTAMP: ::kernel::sys::raw::c_uint = 1024;
pub const SO_NOSIGPIPE: ::kernel::sys::raw::c_uint = 2048;
pub const SO_ACCEPTFILTER: ::kernel::sys::raw::c_uint = 4096;
pub const SO_BINTIME: ::kernel::sys::raw::c_uint = 8192;
pub const SO_NO_OFFLOAD: ::kernel::sys::raw::c_uint = 16384;
pub const SO_NO_DDP: ::kernel::sys::raw::c_uint = 32768;
pub const SO_SNDBUF: ::kernel::sys::raw::c_uint = 4097;
pub const SO_RCVBUF: ::kernel::sys::raw::c_uint = 4098;
pub const SO_SNDLOWAT: ::kernel::sys::raw::c_uint = 4099;
pub const SO_RCVLOWAT: ::kernel::sys::raw::c_uint = 4100;
pub const SO_SNDTIMEO: ::kernel::sys::raw::c_uint = 4101;
pub const SO_RCVTIMEO: ::kernel::sys::raw::c_uint = 4102;
pub const SO_ERROR: ::kernel::sys::raw::c_uint = 4103;
pub const SO_TYPE: ::kernel::sys::raw::c_uint = 4104;
pub const SO_LABEL: ::kernel::sys::raw::c_uint = 4105;
pub const SO_PEERLABEL: ::kernel::sys::raw::c_uint = 4112;
pub const SO_LISTENQLIMIT: ::kernel::sys::raw::c_uint = 4113;
pub const SO_LISTENQLEN: ::kernel::sys::raw::c_uint = 4114;
pub const SO_LISTENINCQLEN: ::kernel::sys::raw::c_uint = 4115;
pub const SO_SETFIB: ::kernel::sys::raw::c_uint = 4116;
pub const SO_USER_COOKIE: ::kernel::sys::raw::c_uint = 4117;
pub const SO_PROTOCOL: ::kernel::sys::raw::c_uint = 4118;
pub const SO_PROTOTYPE: ::kernel::sys::raw::c_uint = 4118;
pub const SO_TS_CLOCK: ::kernel::sys::raw::c_uint = 4119;
pub const SO_MAX_PACING_RATE: ::kernel::sys::raw::c_uint = 4120;
pub const SO_TS_REALTIME_MICRO: ::kernel::sys::raw::c_uint = 0;
pub const SO_TS_BINTIME: ::kernel::sys::raw::c_uint = 1;
pub const SO_TS_REALTIME: ::kernel::sys::raw::c_uint = 2;
pub const SO_TS_MONOTONIC: ::kernel::sys::raw::c_uint = 3;
pub const SO_TS_DEFAULT: ::kernel::sys::raw::c_uint = 0;
pub const SO_TS_CLOCK_MAX: ::kernel::sys::raw::c_uint = 3;
pub const SO_VENDOR: ::kernel::sys::raw::c_uint = 2147483648;
pub const SOL_SOCKET: ::kernel::sys::raw::c_uint = 65535;
pub const AF_UNSPEC: ::kernel::sys::raw::c_uint = 0;
pub const AF_UNIX: ::kernel::sys::raw::c_uint = 1;
pub const AF_INET: ::kernel::sys::raw::c_uint = 2;
pub const AF_IMPLINK: ::kernel::sys::raw::c_uint = 3;
pub const AF_PUP: ::kernel::sys::raw::c_uint = 4;
pub const AF_CHAOS: ::kernel::sys::raw::c_uint = 5;
pub const AF_NETBIOS: ::kernel::sys::raw::c_uint = 6;
pub const AF_ISO: ::kernel::sys::raw::c_uint = 7;
pub const AF_OSI: ::kernel::sys::raw::c_uint = 7;
pub const AF_ECMA: ::kernel::sys::raw::c_uint = 8;
pub const AF_DATAKIT: ::kernel::sys::raw::c_uint = 9;
pub const AF_CCITT: ::kernel::sys::raw::c_uint = 10;
pub const AF_SNA: ::kernel::sys::raw::c_uint = 11;
pub const AF_DECnet: ::kernel::sys::raw::c_uint = 12;
pub const AF_DLI: ::kernel::sys::raw::c_uint = 13;
pub const AF_LAT: ::kernel::sys::raw::c_uint = 14;
pub const AF_HYLINK: ::kernel::sys::raw::c_uint = 15;
pub const AF_APPLETALK: ::kernel::sys::raw::c_uint = 16;
pub const AF_ROUTE: ::kernel::sys::raw::c_uint = 17;
pub const AF_LINK: ::kernel::sys::raw::c_uint = 18;
pub const pseudo_AF_XTP: ::kernel::sys::raw::c_uint = 19;
pub const AF_COIP: ::kernel::sys::raw::c_uint = 20;
pub const AF_CNT: ::kernel::sys::raw::c_uint = 21;
pub const pseudo_AF_RTIP: ::kernel::sys::raw::c_uint = 22;
pub const AF_IPX: ::kernel::sys::raw::c_uint = 23;
pub const AF_SIP: ::kernel::sys::raw::c_uint = 24;
pub const pseudo_AF_PIP: ::kernel::sys::raw::c_uint = 25;
pub const AF_ISDN: ::kernel::sys::raw::c_uint = 26;
pub const AF_E164: ::kernel::sys::raw::c_uint = 26;
pub const pseudo_AF_KEY: ::kernel::sys::raw::c_uint = 27;
pub const AF_INET6: ::kernel::sys::raw::c_uint = 28;
pub const AF_NATM: ::kernel::sys::raw::c_uint = 29;
pub const AF_ATM: ::kernel::sys::raw::c_uint = 30;
pub const pseudo_AF_HDRCMPLT: ::kernel::sys::raw::c_uint = 31;
pub const AF_NETGRAPH: ::kernel::sys::raw::c_uint = 32;
pub const AF_SLOW: ::kernel::sys::raw::c_uint = 33;
pub const AF_SCLUSTER: ::kernel::sys::raw::c_uint = 34;
pub const AF_ARP: ::kernel::sys::raw::c_uint = 35;
pub const AF_BLUETOOTH: ::kernel::sys::raw::c_uint = 36;
pub const AF_IEEE80211: ::kernel::sys::raw::c_uint = 37;
pub const AF_INET_SDP: ::kernel::sys::raw::c_uint = 40;
pub const AF_INET6_SDP: ::kernel::sys::raw::c_uint = 42;
pub const AF_MAX: ::kernel::sys::raw::c_uint = 42;
pub const AF_VENDOR00: ::kernel::sys::raw::c_uint = 39;
pub const AF_VENDOR01: ::kernel::sys::raw::c_uint = 41;
pub const AF_VENDOR02: ::kernel::sys::raw::c_uint = 43;
pub const AF_VENDOR03: ::kernel::sys::raw::c_uint = 45;
pub const AF_VENDOR04: ::kernel::sys::raw::c_uint = 47;
pub const AF_VENDOR05: ::kernel::sys::raw::c_uint = 49;
pub const AF_VENDOR06: ::kernel::sys::raw::c_uint = 51;
pub const AF_VENDOR07: ::kernel::sys::raw::c_uint = 53;
pub const AF_VENDOR08: ::kernel::sys::raw::c_uint = 55;
pub const AF_VENDOR09: ::kernel::sys::raw::c_uint = 57;
pub const AF_VENDOR10: ::kernel::sys::raw::c_uint = 59;
pub const AF_VENDOR11: ::kernel::sys::raw::c_uint = 61;
pub const AF_VENDOR12: ::kernel::sys::raw::c_uint = 63;
pub const AF_VENDOR13: ::kernel::sys::raw::c_uint = 65;
pub const AF_VENDOR14: ::kernel::sys::raw::c_uint = 67;
pub const AF_VENDOR15: ::kernel::sys::raw::c_uint = 69;
pub const AF_VENDOR16: ::kernel::sys::raw::c_uint = 71;
pub const AF_VENDOR17: ::kernel::sys::raw::c_uint = 73;
pub const AF_VENDOR18: ::kernel::sys::raw::c_uint = 75;
pub const AF_VENDOR19: ::kernel::sys::raw::c_uint = 77;
pub const AF_VENDOR20: ::kernel::sys::raw::c_uint = 79;
pub const AF_VENDOR21: ::kernel::sys::raw::c_uint = 81;
pub const AF_VENDOR22: ::kernel::sys::raw::c_uint = 83;
pub const AF_VENDOR23: ::kernel::sys::raw::c_uint = 85;
pub const AF_VENDOR24: ::kernel::sys::raw::c_uint = 87;
pub const AF_VENDOR25: ::kernel::sys::raw::c_uint = 89;
pub const AF_VENDOR26: ::kernel::sys::raw::c_uint = 91;
pub const AF_VENDOR27: ::kernel::sys::raw::c_uint = 93;
pub const AF_VENDOR28: ::kernel::sys::raw::c_uint = 95;
pub const AF_VENDOR29: ::kernel::sys::raw::c_uint = 97;
pub const AF_VENDOR30: ::kernel::sys::raw::c_uint = 99;
pub const AF_VENDOR31: ::kernel::sys::raw::c_uint = 101;
pub const AF_VENDOR32: ::kernel::sys::raw::c_uint = 103;
pub const AF_VENDOR33: ::kernel::sys::raw::c_uint = 105;
pub const AF_VENDOR34: ::kernel::sys::raw::c_uint = 107;
pub const AF_VENDOR35: ::kernel::sys::raw::c_uint = 109;
pub const AF_VENDOR36: ::kernel::sys::raw::c_uint = 111;
pub const AF_VENDOR37: ::kernel::sys::raw::c_uint = 113;
pub const AF_VENDOR38: ::kernel::sys::raw::c_uint = 115;
pub const AF_VENDOR39: ::kernel::sys::raw::c_uint = 117;
pub const AF_VENDOR40: ::kernel::sys::raw::c_uint = 119;
pub const AF_VENDOR41: ::kernel::sys::raw::c_uint = 121;
pub const AF_VENDOR42: ::kernel::sys::raw::c_uint = 123;
pub const AF_VENDOR43: ::kernel::sys::raw::c_uint = 125;
pub const AF_VENDOR44: ::kernel::sys::raw::c_uint = 127;
pub const AF_VENDOR45: ::kernel::sys::raw::c_uint = 129;
pub const AF_VENDOR46: ::kernel::sys::raw::c_uint = 131;
pub const AF_VENDOR47: ::kernel::sys::raw::c_uint = 133;
pub const SOCK_MAXADDRLEN: ::kernel::sys::raw::c_uint = 255;
pub const _SS_MAXSIZE: ::kernel::sys::raw::c_uint = 128;
pub const PF_UNSPEC: ::kernel::sys::raw::c_uint = 0;
pub const PF_INET: ::kernel::sys::raw::c_uint = 2;
pub const PF_IMPLINK: ::kernel::sys::raw::c_uint = 3;
pub const PF_PUP: ::kernel::sys::raw::c_uint = 4;
pub const PF_CHAOS: ::kernel::sys::raw::c_uint = 5;
pub const PF_NETBIOS: ::kernel::sys::raw::c_uint = 6;
pub const PF_ISO: ::kernel::sys::raw::c_uint = 7;
pub const PF_OSI: ::kernel::sys::raw::c_uint = 7;
pub const PF_ECMA: ::kernel::sys::raw::c_uint = 8;
pub const PF_DATAKIT: ::kernel::sys::raw::c_uint = 9;
pub const PF_CCITT: ::kernel::sys::raw::c_uint = 10;
pub const PF_SNA: ::kernel::sys::raw::c_uint = 11;
pub const PF_DECnet: ::kernel::sys::raw::c_uint = 12;
pub const PF_DLI: ::kernel::sys::raw::c_uint = 13;
pub const PF_LAT: ::kernel::sys::raw::c_uint = 14;
pub const PF_HYLINK: ::kernel::sys::raw::c_uint = 15;
pub const PF_APPLETALK: ::kernel::sys::raw::c_uint = 16;
pub const PF_ROUTE: ::kernel::sys::raw::c_uint = 17;
pub const PF_LINK: ::kernel::sys::raw::c_uint = 18;
pub const PF_XTP: ::kernel::sys::raw::c_uint = 19;
pub const PF_COIP: ::kernel::sys::raw::c_uint = 20;
pub const PF_CNT: ::kernel::sys::raw::c_uint = 21;
pub const PF_SIP: ::kernel::sys::raw::c_uint = 24;
pub const PF_IPX: ::kernel::sys::raw::c_uint = 23;
pub const PF_RTIP: ::kernel::sys::raw::c_uint = 22;
pub const PF_PIP: ::kernel::sys::raw::c_uint = 25;
pub const PF_ISDN: ::kernel::sys::raw::c_uint = 26;
pub const PF_KEY: ::kernel::sys::raw::c_uint = 27;
pub const PF_INET6: ::kernel::sys::raw::c_uint = 28;
pub const PF_NATM: ::kernel::sys::raw::c_uint = 29;
pub const PF_ATM: ::kernel::sys::raw::c_uint = 30;
pub const PF_NETGRAPH: ::kernel::sys::raw::c_uint = 32;
pub const PF_SLOW: ::kernel::sys::raw::c_uint = 33;
pub const PF_SCLUSTER: ::kernel::sys::raw::c_uint = 34;
pub const PF_ARP: ::kernel::sys::raw::c_uint = 35;
pub const PF_BLUETOOTH: ::kernel::sys::raw::c_uint = 36;
pub const PF_IEEE80211: ::kernel::sys::raw::c_uint = 37;
pub const PF_INET_SDP: ::kernel::sys::raw::c_uint = 40;
pub const PF_INET6_SDP: ::kernel::sys::raw::c_uint = 42;
pub const PF_MAX: ::kernel::sys::raw::c_uint = 42;
pub const NET_RT_DUMP: ::kernel::sys::raw::c_uint = 1;
pub const NET_RT_FLAGS: ::kernel::sys::raw::c_uint = 2;
pub const NET_RT_IFLIST: ::kernel::sys::raw::c_uint = 3;
pub const NET_RT_IFMALIST: ::kernel::sys::raw::c_uint = 4;
pub const NET_RT_IFLISTL: ::kernel::sys::raw::c_uint = 5;
pub const SOMAXCONN: ::kernel::sys::raw::c_uint = 128;
pub const MSG_OOB: ::kernel::sys::raw::c_uint = 1;
pub const MSG_PEEK: ::kernel::sys::raw::c_uint = 2;
pub const MSG_DONTROUTE: ::kernel::sys::raw::c_uint = 4;
pub const MSG_EOR: ::kernel::sys::raw::c_uint = 8;
pub const MSG_TRUNC: ::kernel::sys::raw::c_uint = 16;
pub const MSG_CTRUNC: ::kernel::sys::raw::c_uint = 32;
pub const MSG_WAITALL: ::kernel::sys::raw::c_uint = 64;
pub const MSG_DONTWAIT: ::kernel::sys::raw::c_uint = 128;
pub const MSG_EOF: ::kernel::sys::raw::c_uint = 256;
pub const MSG_NOTIFICATION: ::kernel::sys::raw::c_uint = 8192;
pub const MSG_NBIO: ::kernel::sys::raw::c_uint = 16384;
pub const MSG_COMPAT: ::kernel::sys::raw::c_uint = 32768;
pub const MSG_SOCALLBCK: ::kernel::sys::raw::c_uint = 65536;
pub const MSG_NOSIGNAL: ::kernel::sys::raw::c_uint = 131072;
pub const MSG_CMSG_CLOEXEC: ::kernel::sys::raw::c_uint = 262144;
pub const MSG_WAITFORONE: ::kernel::sys::raw::c_uint = 524288;
pub const MSG_MORETOCOME: ::kernel::sys::raw::c_uint = 1048576;
pub const CMGROUP_MAX: ::kernel::sys::raw::c_uint = 16;
pub const SCM_RIGHTS: ::kernel::sys::raw::c_uint = 1;
pub const SCM_TIMESTAMP: ::kernel::sys::raw::c_uint = 2;
pub const SCM_CREDS: ::kernel::sys::raw::c_uint = 3;
pub const SCM_BINTIME: ::kernel::sys::raw::c_uint = 4;
pub const SCM_REALTIME: ::kernel::sys::raw::c_uint = 5;
pub const SCM_MONOTONIC: ::kernel::sys::raw::c_uint = 6;
pub const SCM_TIME_INFO: ::kernel::sys::raw::c_uint = 7;
pub const ST_INFO_HW: ::kernel::sys::raw::c_uint = 1;
pub const ST_INFO_HW_HPREC: ::kernel::sys::raw::c_uint = 2;
pub const SHUT_RD: ::kernel::sys::raw::c_uint = 0;
pub const SHUT_WR: ::kernel::sys::raw::c_uint = 1;
pub const SHUT_RDWR: ::kernel::sys::raw::c_uint = 2;
pub const PRU_FLUSH_RD: ::kernel::sys::raw::c_uint = 0;
pub const PRU_FLUSH_WR: ::kernel::sys::raw::c_uint = 1;
pub const PRU_FLUSH_RDWR: ::kernel::sys::raw::c_uint = 2;
pub const SF_NODISKIO: ::kernel::sys::raw::c_uint = 1;
pub const SF_MNOWAIT: ::kernel::sys::raw::c_uint = 2;
pub const SF_SYNC: ::kernel::sys::raw::c_uint = 4;
pub const SF_USER_READAHEAD: ::kernel::sys::raw::c_uint = 8;
pub const SF_NOCACHE: ::kernel::sys::raw::c_uint = 16;
pub const CTL_MAXNAME: ::kernel::sys::raw::c_uint = 24;
pub const CTLTYPE: ::kernel::sys::raw::c_uint = 15;
pub const CTLTYPE_NODE: ::kernel::sys::raw::c_uint = 1;
pub const CTLTYPE_INT: ::kernel::sys::raw::c_uint = 2;
pub const CTLTYPE_STRING: ::kernel::sys::raw::c_uint = 3;
pub const CTLTYPE_S64: ::kernel::sys::raw::c_uint = 4;
pub const CTLTYPE_OPAQUE: ::kernel::sys::raw::c_uint = 5;
pub const CTLTYPE_STRUCT: ::kernel::sys::raw::c_uint = 5;
pub const CTLTYPE_UINT: ::kernel::sys::raw::c_uint = 6;
pub const CTLTYPE_LONG: ::kernel::sys::raw::c_uint = 7;
pub const CTLTYPE_ULONG: ::kernel::sys::raw::c_uint = 8;
pub const CTLTYPE_U64: ::kernel::sys::raw::c_uint = 9;
pub const CTLTYPE_U8: ::kernel::sys::raw::c_uint = 10;
pub const CTLTYPE_U16: ::kernel::sys::raw::c_uint = 11;
pub const CTLTYPE_S8: ::kernel::sys::raw::c_uint = 12;
pub const CTLTYPE_S16: ::kernel::sys::raw::c_uint = 13;
pub const CTLTYPE_S32: ::kernel::sys::raw::c_uint = 14;
pub const CTLTYPE_U32: ::kernel::sys::raw::c_uint = 15;
pub const CTLFLAG_RD: ::kernel::sys::raw::c_uint = 2147483648;
pub const CTLFLAG_WR: ::kernel::sys::raw::c_uint = 1073741824;
pub const CTLFLAG_RW: ::kernel::sys::raw::c_uint = 3221225472;
pub const CTLFLAG_DORMANT: ::kernel::sys::raw::c_uint = 536870912;
pub const CTLFLAG_ANYBODY: ::kernel::sys::raw::c_uint = 268435456;
pub const CTLFLAG_SECURE: ::kernel::sys::raw::c_uint = 134217728;
pub const CTLFLAG_PRISON: ::kernel::sys::raw::c_uint = 67108864;
pub const CTLFLAG_DYN: ::kernel::sys::raw::c_uint = 33554432;
pub const CTLFLAG_SKIP: ::kernel::sys::raw::c_uint = 16777216;
pub const CTLMASK_SECURE: ::kernel::sys::raw::c_uint = 15728640;
pub const CTLFLAG_TUN: ::kernel::sys::raw::c_uint = 524288;
pub const CTLFLAG_RDTUN: ::kernel::sys::raw::c_uint = 2148007936;
pub const CTLFLAG_RWTUN: ::kernel::sys::raw::c_uint = 3221749760;
pub const CTLFLAG_MPSAFE: ::kernel::sys::raw::c_uint = 262144;
pub const CTLFLAG_VNET: ::kernel::sys::raw::c_uint = 131072;
pub const CTLFLAG_DYING: ::kernel::sys::raw::c_uint = 65536;
pub const CTLFLAG_CAPRD: ::kernel::sys::raw::c_uint = 32768;
pub const CTLFLAG_CAPWR: ::kernel::sys::raw::c_uint = 16384;
pub const CTLFLAG_STATS: ::kernel::sys::raw::c_uint = 8192;
pub const CTLFLAG_NOFETCH: ::kernel::sys::raw::c_uint = 4096;
pub const CTLFLAG_CAPRW: ::kernel::sys::raw::c_uint = 49152;
pub const CTLSHIFT_SECURE: ::kernel::sys::raw::c_uint = 20;
pub const CTLFLAG_SECURE1: ::kernel::sys::raw::c_uint = 134217728;
pub const CTLFLAG_SECURE2: ::kernel::sys::raw::c_uint = 135266304;
pub const CTLFLAG_SECURE3: ::kernel::sys::raw::c_uint = 136314880;
pub const OID_AUTO: ::kernel::sys::raw::c_int = -1;
pub const CTL_AUTO_START: ::kernel::sys::raw::c_uint = 256;
pub const SYSCTL_CT_ASSERT_MASK: ::kernel::sys::raw::c_uint = 15;
pub const REQ_UNWIRED: ::kernel::sys::raw::c_uint = 1;
pub const REQ_WIRED: ::kernel::sys::raw::c_uint = 2;
pub const SCTL_MASK32: ::kernel::sys::raw::c_uint = 1;
pub const CTL_UNSPEC: ::kernel::sys::raw::c_uint = 0;
pub const CTL_KERN: ::kernel::sys::raw::c_uint = 1;
pub const CTL_VM: ::kernel::sys::raw::c_uint = 2;
pub const CTL_VFS: ::kernel::sys::raw::c_uint = 3;
pub const CTL_NET: ::kernel::sys::raw::c_uint = 4;
pub const CTL_DEBUG: ::kernel::sys::raw::c_uint = 5;
pub const CTL_HW: ::kernel::sys::raw::c_uint = 6;
pub const CTL_MACHDEP: ::kernel::sys::raw::c_uint = 7;
pub const CTL_USER: ::kernel::sys::raw::c_uint = 8;
pub const CTL_P1003_1B: ::kernel::sys::raw::c_uint = 9;
pub const KERN_OSTYPE: ::kernel::sys::raw::c_uint = 1;
pub const KERN_OSRELEASE: ::kernel::sys::raw::c_uint = 2;
pub const KERN_OSREV: ::kernel::sys::raw::c_uint = 3;
pub const KERN_VERSION: ::kernel::sys::raw::c_uint = 4;
pub const KERN_MAXVNODES: ::kernel::sys::raw::c_uint = 5;
pub const KERN_MAXPROC: ::kernel::sys::raw::c_uint = 6;
pub const KERN_MAXFILES: ::kernel::sys::raw::c_uint = 7;
pub const KERN_ARGMAX: ::kernel::sys::raw::c_uint = 8;
pub const KERN_SECURELVL: ::kernel::sys::raw::c_uint = 9;
pub const KERN_HOSTNAME: ::kernel::sys::raw::c_uint = 10;
pub const KERN_HOSTID: ::kernel::sys::raw::c_uint = 11;
pub const KERN_CLOCKRATE: ::kernel::sys::raw::c_uint = 12;
pub const KERN_VNODE: ::kernel::sys::raw::c_uint = 13;
pub const KERN_PROC: ::kernel::sys::raw::c_uint = 14;
pub const KERN_FILE: ::kernel::sys::raw::c_uint = 15;
pub const KERN_PROF: ::kernel::sys::raw::c_uint = 16;
pub const KERN_POSIX1: ::kernel::sys::raw::c_uint = 17;
pub const KERN_NGROUPS: ::kernel::sys::raw::c_uint = 18;
pub const KERN_JOB_CONTROL: ::kernel::sys::raw::c_uint = 19;
pub const KERN_SAVED_IDS: ::kernel::sys::raw::c_uint = 20;
pub const KERN_BOOTTIME: ::kernel::sys::raw::c_uint = 21;
pub const KERN_NISDOMAINNAME: ::kernel::sys::raw::c_uint = 22;
pub const KERN_UPDATEINTERVAL: ::kernel::sys::raw::c_uint = 23;
pub const KERN_OSRELDATE: ::kernel::sys::raw::c_uint = 24;
pub const KERN_NTP_PLL: ::kernel::sys::raw::c_uint = 25;
pub const KERN_BOOTFILE: ::kernel::sys::raw::c_uint = 26;
pub const KERN_MAXFILESPERPROC: ::kernel::sys::raw::c_uint = 27;
pub const KERN_MAXPROCPERUID: ::kernel::sys::raw::c_uint = 28;
pub const KERN_DUMPDEV: ::kernel::sys::raw::c_uint = 29;
pub const KERN_IPC: ::kernel::sys::raw::c_uint = 30;
pub const KERN_DUMMY: ::kernel::sys::raw::c_uint = 31;
pub const KERN_PS_STRINGS: ::kernel::sys::raw::c_uint = 32;
pub const KERN_USRSTACK: ::kernel::sys::raw::c_uint = 33;
pub const KERN_LOGSIGEXIT: ::kernel::sys::raw::c_uint = 34;
pub const KERN_IOV_MAX: ::kernel::sys::raw::c_uint = 35;
pub const KERN_HOSTUUID: ::kernel::sys::raw::c_uint = 36;
pub const KERN_ARND: ::kernel::sys::raw::c_uint = 37;
pub const KERN_MAXPHYS: ::kernel::sys::raw::c_uint = 38;
pub const KERN_PROC_ALL: ::kernel::sys::raw::c_uint = 0;
pub const KERN_PROC_PID: ::kernel::sys::raw::c_uint = 1;
pub const KERN_PROC_PGRP: ::kernel::sys::raw::c_uint = 2;
pub const KERN_PROC_SESSION: ::kernel::sys::raw::c_uint = 3;
pub const KERN_PROC_TTY: ::kernel::sys::raw::c_uint = 4;
pub const KERN_PROC_UID: ::kernel::sys::raw::c_uint = 5;
pub const KERN_PROC_RUID: ::kernel::sys::raw::c_uint = 6;
pub const KERN_PROC_ARGS: ::kernel::sys::raw::c_uint = 7;
pub const KERN_PROC_PROC: ::kernel::sys::raw::c_uint = 8;
pub const KERN_PROC_SV_NAME: ::kernel::sys::raw::c_uint = 9;
pub const KERN_PROC_RGID: ::kernel::sys::raw::c_uint = 10;
pub const KERN_PROC_GID: ::kernel::sys::raw::c_uint = 11;
pub const KERN_PROC_PATHNAME: ::kernel::sys::raw::c_uint = 12;
pub const KERN_PROC_OVMMAP: ::kernel::sys::raw::c_uint = 13;
pub const KERN_PROC_OFILEDESC: ::kernel::sys::raw::c_uint = 14;
pub const KERN_PROC_KSTACK: ::kernel::sys::raw::c_uint = 15;
pub const KERN_PROC_INC_THREAD: ::kernel::sys::raw::c_uint = 16;
pub const KERN_PROC_VMMAP: ::kernel::sys::raw::c_uint = 32;
pub const KERN_PROC_FILEDESC: ::kernel::sys::raw::c_uint = 33;
pub const KERN_PROC_GROUPS: ::kernel::sys::raw::c_uint = 34;
pub const KERN_PROC_ENV: ::kernel::sys::raw::c_uint = 35;
pub const KERN_PROC_AUXV: ::kernel::sys::raw::c_uint = 36;
pub const KERN_PROC_RLIMIT: ::kernel::sys::raw::c_uint = 37;
pub const KERN_PROC_PS_STRINGS: ::kernel::sys::raw::c_uint = 38;
pub const KERN_PROC_UMASK: ::kernel::sys::raw::c_uint = 39;
pub const KERN_PROC_OSREL: ::kernel::sys::raw::c_uint = 40;
pub const KERN_PROC_SIGTRAMP: ::kernel::sys::raw::c_uint = 41;
pub const KERN_PROC_CWD: ::kernel::sys::raw::c_uint = 42;
pub const KERN_PROC_NFDS: ::kernel::sys::raw::c_uint = 43;
pub const KIPC_MAXSOCKBUF: ::kernel::sys::raw::c_uint = 1;
pub const KIPC_SOCKBUF_WASTE: ::kernel::sys::raw::c_uint = 2;
pub const KIPC_SOMAXCONN: ::kernel::sys::raw::c_uint = 3;
pub const KIPC_MAX_LINKHDR: ::kernel::sys::raw::c_uint = 4;
pub const KIPC_MAX_PROTOHDR: ::kernel::sys::raw::c_uint = 5;
pub const KIPC_MAX_HDR: ::kernel::sys::raw::c_uint = 6;
pub const KIPC_MAX_DATALEN: ::kernel::sys::raw::c_uint = 7;
pub const HW_MACHINE: ::kernel::sys::raw::c_uint = 1;
pub const HW_MODEL: ::kernel::sys::raw::c_uint = 2;
pub const HW_NCPU: ::kernel::sys::raw::c_uint = 3;
pub const HW_BYTEORDER: ::kernel::sys::raw::c_uint = 4;
pub const HW_PHYSMEM: ::kernel::sys::raw::c_uint = 5;
pub const HW_USERMEM: ::kernel::sys::raw::c_uint = 6;
pub const HW_PAGESIZE: ::kernel::sys::raw::c_uint = 7;
pub const HW_DISKNAMES: ::kernel::sys::raw::c_uint = 8;
pub const HW_DISKSTATS: ::kernel::sys::raw::c_uint = 9;
pub const HW_FLOATINGPT: ::kernel::sys::raw::c_uint = 10;
pub const HW_MACHINE_ARCH: ::kernel::sys::raw::c_uint = 11;
pub const HW_REALMEM: ::kernel::sys::raw::c_uint = 12;
pub const USER_CS_PATH: ::kernel::sys::raw::c_uint = 1;
pub const USER_BC_BASE_MAX: ::kernel::sys::raw::c_uint = 2;
pub const USER_BC_DIM_MAX: ::kernel::sys::raw::c_uint = 3;
pub const USER_BC_SCALE_MAX: ::kernel::sys::raw::c_uint = 4;
pub const USER_BC_STRING_MAX: ::kernel::sys::raw::c_uint = 5;
pub const USER_COLL_WEIGHTS_MAX: ::kernel::sys::raw::c_uint = 6;
pub const USER_EXPR_NEST_MAX: ::kernel::sys::raw::c_uint = 7;
pub const USER_LINE_MAX: ::kernel::sys::raw::c_uint = 8;
pub const USER_RE_DUP_MAX: ::kernel::sys::raw::c_uint = 9;
pub const USER_POSIX2_VERSION: ::kernel::sys::raw::c_uint = 10;
pub const USER_POSIX2_C_BIND: ::kernel::sys::raw::c_uint = 11;
pub const USER_POSIX2_C_DEV: ::kernel::sys::raw::c_uint = 12;
pub const USER_POSIX2_CHAR_TERM: ::kernel::sys::raw::c_uint = 13;
pub const USER_POSIX2_FORT_DEV: ::kernel::sys::raw::c_uint = 14;
pub const USER_POSIX2_FORT_RUN: ::kernel::sys::raw::c_uint = 15;
pub const USER_POSIX2_LOCALEDEF: ::kernel::sys::raw::c_uint = 16;
pub const USER_POSIX2_SW_DEV: ::kernel::sys::raw::c_uint = 17;
pub const USER_POSIX2_UPE: ::kernel::sys::raw::c_uint = 18;
pub const USER_STREAM_MAX: ::kernel::sys::raw::c_uint = 19;
pub const USER_TZNAME_MAX: ::kernel::sys::raw::c_uint = 20;
pub const CTL_P1003_1B_ASYNCHRONOUS_IO: ::kernel::sys::raw::c_uint = 1;
pub const CTL_P1003_1B_MAPPED_FILES: ::kernel::sys::raw::c_uint = 2;
pub const CTL_P1003_1B_MEMLOCK: ::kernel::sys::raw::c_uint = 3;
pub const CTL_P1003_1B_MEMLOCK_RANGE: ::kernel::sys::raw::c_uint = 4;
pub const CTL_P1003_1B_MEMORY_PROTECTION: ::kernel::sys::raw::c_uint = 5;
pub const CTL_P1003_1B_MESSAGE_PASSING: ::kernel::sys::raw::c_uint = 6;
pub const CTL_P1003_1B_PRIORITIZED_IO: ::kernel::sys::raw::c_uint = 7;
pub const CTL_P1003_1B_PRIORITY_SCHEDULING: ::kernel::sys::raw::c_uint = 8;
pub const CTL_P1003_1B_REALTIME_SIGNALS: ::kernel::sys::raw::c_uint = 9;
pub const CTL_P1003_1B_SEMAPHORES: ::kernel::sys::raw::c_uint = 10;
pub const CTL_P1003_1B_FSYNC: ::kernel::sys::raw::c_uint = 11;
pub const CTL_P1003_1B_SHARED_MEMORY_OBJECTS: ::kernel::sys::raw::c_uint = 12;
pub const CTL_P1003_1B_SYNCHRONIZED_IO: ::kernel::sys::raw::c_uint = 13;
pub const CTL_P1003_1B_TIMERS: ::kernel::sys::raw::c_uint = 14;
pub const CTL_P1003_1B_AIO_LISTIO_MAX: ::kernel::sys::raw::c_uint = 15;
pub const CTL_P1003_1B_AIO_MAX: ::kernel::sys::raw::c_uint = 16;
pub const CTL_P1003_1B_AIO_PRIO_DELTA_MAX: ::kernel::sys::raw::c_uint = 17;
pub const CTL_P1003_1B_DELAYTIMER_MAX: ::kernel::sys::raw::c_uint = 18;
pub const CTL_P1003_1B_MQ_OPEN_MAX: ::kernel::sys::raw::c_uint = 19;
pub const CTL_P1003_1B_PAGESIZE: ::kernel::sys::raw::c_uint = 20;
pub const CTL_P1003_1B_RTSIG_MAX: ::kernel::sys::raw::c_uint = 21;
pub const CTL_P1003_1B_SEM_NSEMS_MAX: ::kernel::sys::raw::c_uint = 22;
pub const CTL_P1003_1B_SEM_VALUE_MAX: ::kernel::sys::raw::c_uint = 23;
pub const CTL_P1003_1B_SIGQUEUE_MAX: ::kernel::sys::raw::c_uint = 24;
pub const CTL_P1003_1B_TIMER_MAX: ::kernel::sys::raw::c_uint = 25;
pub const CTL_P1003_1B_MAXID: ::kernel::sys::raw::c_uint = 26;
pub const GROUPTASK_NAMELEN: ::kernel::sys::raw::c_uint = 32;
pub const TASKQUEUE_NAMELEN: ::kernel::sys::raw::c_uint = 32;
pub const X86_BUS_SPACE_IO: ::kernel::sys::raw::c_uint = 0;
pub const X86_BUS_SPACE_MEM: ::kernel::sys::raw::c_uint = 1;
pub const BUS_SPACE_MAXSIZE_24BIT: ::kernel::sys::raw::c_uint = 16777215;
pub const BUS_SPACE_MAXSIZE_32BIT: ::kernel::sys::raw::c_uint = 4294967295;
pub const BUS_SPACE_MAXSIZE: ::kernel::sys::raw::c_uint = 4294967295;
pub const BUS_SPACE_MAXADDR_24BIT: ::kernel::sys::raw::c_uint = 16777215;
pub const BUS_SPACE_MAXADDR_32BIT: ::kernel::sys::raw::c_uint = 4294967295;
pub const BUS_SPACE_MAXADDR_48BIT: ::kernel::sys::raw::c_ulonglong =
    281474976710655;
pub const BUS_SPACE_MAXADDR: ::kernel::sys::raw::c_int = -1;
pub const BUS_SPACE_INVALID_DATA: ::kernel::sys::raw::c_int = -1;
pub const BUS_SPACE_UNRESTRICTED: ::kernel::sys::raw::c_int = -1;
pub const BUS_SPACE_BARRIER_READ: ::kernel::sys::raw::c_uint = 1;
pub const BUS_SPACE_BARRIER_WRITE: ::kernel::sys::raw::c_uint = 2;
pub const BUS_DMA_WAITOK: ::kernel::sys::raw::c_uint = 0;
pub const BUS_DMA_NOWAIT: ::kernel::sys::raw::c_uint = 1;
pub const BUS_DMA_ALLOCNOW: ::kernel::sys::raw::c_uint = 2;
pub const BUS_DMA_COHERENT: ::kernel::sys::raw::c_uint = 4;
pub const BUS_DMA_ZERO: ::kernel::sys::raw::c_uint = 8;
pub const BUS_DMA_BUS1: ::kernel::sys::raw::c_uint = 16;
pub const BUS_DMA_BUS2: ::kernel::sys::raw::c_uint = 32;
pub const BUS_DMA_BUS3: ::kernel::sys::raw::c_uint = 64;
pub const BUS_DMA_BUS4: ::kernel::sys::raw::c_uint = 128;
pub const BUS_DMA_NOWRITE: ::kernel::sys::raw::c_uint = 256;
pub const BUS_DMA_NOCACHE: ::kernel::sys::raw::c_uint = 512;
pub const BUS_DMA_KEEP_PG_OFFSET: ::kernel::sys::raw::c_uint = 1024;
pub const BUS_DMA_LOAD_MBUF: ::kernel::sys::raw::c_uint = 2048;
pub const BUS_DMASYNC_PREREAD: ::kernel::sys::raw::c_uint = 1;
pub const BUS_DMASYNC_POSTREAD: ::kernel::sys::raw::c_uint = 2;
pub const BUS_DMASYNC_PREWRITE: ::kernel::sys::raw::c_uint = 4;
pub const BUS_DMASYNC_POSTWRITE: ::kernel::sys::raw::c_uint = 8;
pub const BPF_RELEASE: ::kernel::sys::raw::c_uint = 199606;
pub const BPF_MAXINSNS: ::kernel::sys::raw::c_uint = 512;
pub const BPF_MAXBUFSIZE: ::kernel::sys::raw::c_uint = 524288;
pub const BPF_MINBUFSIZE: ::kernel::sys::raw::c_uint = 32;
pub const BPF_MAJOR_VERSION: ::kernel::sys::raw::c_uint = 1;
pub const BPF_MINOR_VERSION: ::kernel::sys::raw::c_uint = 1;
pub const BPF_BUFMODE_BUFFER: ::kernel::sys::raw::c_uint = 1;
pub const BPF_BUFMODE_ZBUF: ::kernel::sys::raw::c_uint = 2;
pub const BPF_T_MICROTIME: ::kernel::sys::raw::c_uint = 0;
pub const BPF_T_NANOTIME: ::kernel::sys::raw::c_uint = 1;
pub const BPF_T_BINTIME: ::kernel::sys::raw::c_uint = 2;
pub const BPF_T_NONE: ::kernel::sys::raw::c_uint = 3;
pub const BPF_T_FORMAT_MASK: ::kernel::sys::raw::c_uint = 3;
pub const BPF_T_NORMAL: ::kernel::sys::raw::c_uint = 0;
pub const BPF_T_FAST: ::kernel::sys::raw::c_uint = 256;
pub const BPF_T_MONOTONIC: ::kernel::sys::raw::c_uint = 512;
pub const BPF_T_MONOTONIC_FAST: ::kernel::sys::raw::c_uint = 768;
pub const BPF_T_FLAG_MASK: ::kernel::sys::raw::c_uint = 768;
pub const BPF_T_MICROTIME_FAST: ::kernel::sys::raw::c_uint = 256;
pub const BPF_T_NANOTIME_FAST: ::kernel::sys::raw::c_uint = 257;
pub const BPF_T_BINTIME_FAST: ::kernel::sys::raw::c_uint = 258;
pub const BPF_T_MICROTIME_MONOTONIC: ::kernel::sys::raw::c_uint = 512;
pub const BPF_T_NANOTIME_MONOTONIC: ::kernel::sys::raw::c_uint = 513;
pub const BPF_T_BINTIME_MONOTONIC: ::kernel::sys::raw::c_uint = 514;
pub const BPF_T_MICROTIME_MONOTONIC_FAST: ::kernel::sys::raw::c_uint = 768;
pub const BPF_T_NANOTIME_MONOTONIC_FAST: ::kernel::sys::raw::c_uint = 769;
pub const BPF_T_BINTIME_MONOTONIC_FAST: ::kernel::sys::raw::c_uint = 770;
pub const MTAG_BPF: ::kernel::sys::raw::c_uint = 6451302;
pub const MTAG_BPF_TIMESTAMP: ::kernel::sys::raw::c_uint = 0;
pub const DLT_NULL: ::kernel::sys::raw::c_uint = 0;
pub const DLT_EN10MB: ::kernel::sys::raw::c_uint = 1;
pub const DLT_EN3MB: ::kernel::sys::raw::c_uint = 2;
pub const DLT_AX25: ::kernel::sys::raw::c_uint = 3;
pub const DLT_PRONET: ::kernel::sys::raw::c_uint = 4;
pub const DLT_CHAOS: ::kernel::sys::raw::c_uint = 5;
pub const DLT_IEEE802: ::kernel::sys::raw::c_uint = 6;
pub const DLT_ARCNET: ::kernel::sys::raw::c_uint = 7;
pub const DLT_SLIP: ::kernel::sys::raw::c_uint = 8;
pub const DLT_PPP: ::kernel::sys::raw::c_uint = 9;
pub const DLT_FDDI: ::kernel::sys::raw::c_uint = 10;
pub const DLT_ATM_RFC1483: ::kernel::sys::raw::c_uint = 11;
pub const DLT_RAW: ::kernel::sys::raw::c_uint = 12;
pub const DLT_SLIP_BSDOS: ::kernel::sys::raw::c_uint = 13;
pub const DLT_PPP_BSDOS: ::kernel::sys::raw::c_uint = 14;
pub const DLT_ATM_CLIP: ::kernel::sys::raw::c_uint = 19;
pub const DLT_REDBACK_SMARTEDGE: ::kernel::sys::raw::c_uint = 32;
pub const DLT_PPP_SERIAL: ::kernel::sys::raw::c_uint = 50;
pub const DLT_PPP_ETHER: ::kernel::sys::raw::c_uint = 51;
pub const DLT_SYMANTEC_FIREWALL: ::kernel::sys::raw::c_uint = 99;
pub const DLT_MATCHING_MIN: ::kernel::sys::raw::c_uint = 104;
pub const DLT_C_HDLC: ::kernel::sys::raw::c_uint = 104;
pub const DLT_CHDLC: ::kernel::sys::raw::c_uint = 104;
pub const DLT_IEEE802_11: ::kernel::sys::raw::c_uint = 105;
pub const DLT_FRELAY: ::kernel::sys::raw::c_uint = 107;
pub const DLT_LOOP: ::kernel::sys::raw::c_uint = 108;
pub const DLT_ENC: ::kernel::sys::raw::c_uint = 109;
pub const DLT_LINUX_SLL: ::kernel::sys::raw::c_uint = 113;
pub const DLT_LTALK: ::kernel::sys::raw::c_uint = 114;
pub const DLT_ECONET: ::kernel::sys::raw::c_uint = 115;
pub const DLT_IPFILTER: ::kernel::sys::raw::c_uint = 116;
pub const DLT_PFLOG: ::kernel::sys::raw::c_uint = 117;
pub const DLT_CISCO_IOS: ::kernel::sys::raw::c_uint = 118;
pub const DLT_PRISM_HEADER: ::kernel::sys::raw::c_uint = 119;
pub const DLT_AIRONET_HEADER: ::kernel::sys::raw::c_uint = 120;
pub const DLT_PFSYNC: ::kernel::sys::raw::c_uint = 121;
pub const DLT_IP_OVER_FC: ::kernel::sys::raw::c_uint = 122;
pub const DLT_SUNATM: ::kernel::sys::raw::c_uint = 123;
pub const DLT_RIO: ::kernel::sys::raw::c_uint = 124;
pub const DLT_PCI_EXP: ::kernel::sys::raw::c_uint = 125;
pub const DLT_AURORA: ::kernel::sys::raw::c_uint = 126;
pub const DLT_IEEE802_11_RADIO: ::kernel::sys::raw::c_uint = 127;
pub const DLT_TZSP: ::kernel::sys::raw::c_uint = 128;
pub const DLT_ARCNET_LINUX: ::kernel::sys::raw::c_uint = 129;
pub const DLT_JUNIPER_MLPPP: ::kernel::sys::raw::c_uint = 130;
pub const DLT_JUNIPER_MLFR: ::kernel::sys::raw::c_uint = 131;
pub const DLT_JUNIPER_ES: ::kernel::sys::raw::c_uint = 132;
pub const DLT_JUNIPER_GGSN: ::kernel::sys::raw::c_uint = 133;
pub const DLT_JUNIPER_MFR: ::kernel::sys::raw::c_uint = 134;
pub const DLT_JUNIPER_ATM2: ::kernel::sys::raw::c_uint = 135;
pub const DLT_JUNIPER_SERVICES: ::kernel::sys::raw::c_uint = 136;
pub const DLT_JUNIPER_ATM1: ::kernel::sys::raw::c_uint = 137;
pub const DLT_APPLE_IP_OVER_IEEE1394: ::kernel::sys::raw::c_uint = 138;
pub const DLT_MTP2_WITH_PHDR: ::kernel::sys::raw::c_uint = 139;
pub const DLT_MTP2: ::kernel::sys::raw::c_uint = 140;
pub const DLT_MTP3: ::kernel::sys::raw::c_uint = 141;
pub const DLT_SCCP: ::kernel::sys::raw::c_uint = 142;
pub const DLT_DOCSIS: ::kernel::sys::raw::c_uint = 143;
pub const DLT_LINUX_IRDA: ::kernel::sys::raw::c_uint = 144;
pub const DLT_IBM_SP: ::kernel::sys::raw::c_uint = 145;
pub const DLT_IBM_SN: ::kernel::sys::raw::c_uint = 146;
pub const DLT_USER0: ::kernel::sys::raw::c_uint = 147;
pub const DLT_USER1: ::kernel::sys::raw::c_uint = 148;
pub const DLT_USER2: ::kernel::sys::raw::c_uint = 149;
pub const DLT_USER3: ::kernel::sys::raw::c_uint = 150;
pub const DLT_USER4: ::kernel::sys::raw::c_uint = 151;
pub const DLT_USER5: ::kernel::sys::raw::c_uint = 152;
pub const DLT_USER6: ::kernel::sys::raw::c_uint = 153;
pub const DLT_USER7: ::kernel::sys::raw::c_uint = 154;
pub const DLT_USER8: ::kernel::sys::raw::c_uint = 155;
pub const DLT_USER9: ::kernel::sys::raw::c_uint = 156;
pub const DLT_USER10: ::kernel::sys::raw::c_uint = 157;
pub const DLT_USER11: ::kernel::sys::raw::c_uint = 158;
pub const DLT_USER12: ::kernel::sys::raw::c_uint = 159;
pub const DLT_USER13: ::kernel::sys::raw::c_uint = 160;
pub const DLT_USER14: ::kernel::sys::raw::c_uint = 161;
pub const DLT_USER15: ::kernel::sys::raw::c_uint = 162;
pub const DLT_IEEE802_11_RADIO_AVS: ::kernel::sys::raw::c_uint = 163;
pub const DLT_JUNIPER_MONITOR: ::kernel::sys::raw::c_uint = 164;
pub const DLT_BACNET_MS_TP: ::kernel::sys::raw::c_uint = 165;
pub const DLT_PPP_PPPD: ::kernel::sys::raw::c_uint = 166;
pub const DLT_PPP_WITH_DIRECTION: ::kernel::sys::raw::c_uint = 166;
pub const DLT_LINUX_PPP_WITHDIRECTION: ::kernel::sys::raw::c_uint = 166;
pub const DLT_JUNIPER_PPPOE: ::kernel::sys::raw::c_uint = 167;
pub const DLT_JUNIPER_PPPOE_ATM: ::kernel::sys::raw::c_uint = 168;
pub const DLT_GPRS_LLC: ::kernel::sys::raw::c_uint = 169;
pub const DLT_GPF_T: ::kernel::sys::raw::c_uint = 170;
pub const DLT_GPF_F: ::kernel::sys::raw::c_uint = 171;
pub const DLT_GCOM_T1E1: ::kernel::sys::raw::c_uint = 172;
pub const DLT_GCOM_SERIAL: ::kernel::sys::raw::c_uint = 173;
pub const DLT_JUNIPER_PIC_PEER: ::kernel::sys::raw::c_uint = 174;
pub const DLT_ERF_ETH: ::kernel::sys::raw::c_uint = 175;
pub const DLT_ERF_POS: ::kernel::sys::raw::c_uint = 176;
pub const DLT_LINUX_LAPD: ::kernel::sys::raw::c_uint = 177;
pub const DLT_JUNIPER_ETHER: ::kernel::sys::raw::c_uint = 178;
pub const DLT_JUNIPER_PPP: ::kernel::sys::raw::c_uint = 179;
pub const DLT_JUNIPER_FRELAY: ::kernel::sys::raw::c_uint = 180;
pub const DLT_JUNIPER_CHDLC: ::kernel::sys::raw::c_uint = 181;
pub const DLT_MFR: ::kernel::sys::raw::c_uint = 182;
pub const DLT_JUNIPER_VP: ::kernel::sys::raw::c_uint = 183;
pub const DLT_A429: ::kernel::sys::raw::c_uint = 184;
pub const DLT_A653_ICM: ::kernel::sys::raw::c_uint = 185;
pub const DLT_USB_FREEBSD: ::kernel::sys::raw::c_uint = 186;
pub const DLT_USB: ::kernel::sys::raw::c_uint = 186;
pub const DLT_BLUETOOTH_HCI_H4: ::kernel::sys::raw::c_uint = 187;
pub const DLT_IEEE802_16_MAC_CPS: ::kernel::sys::raw::c_uint = 188;
pub const DLT_USB_LINUX: ::kernel::sys::raw::c_uint = 189;
pub const DLT_CAN20B: ::kernel::sys::raw::c_uint = 190;
pub const DLT_IEEE802_15_4_LINUX: ::kernel::sys::raw::c_uint = 191;
pub const DLT_PPI: ::kernel::sys::raw::c_uint = 192;
pub const DLT_IEEE802_16_MAC_CPS_RADIO: ::kernel::sys::raw::c_uint = 193;
pub const DLT_JUNIPER_ISM: ::kernel::sys::raw::c_uint = 194;
pub const DLT_IEEE802_15_4: ::kernel::sys::raw::c_uint = 195;
pub const DLT_SITA: ::kernel::sys::raw::c_uint = 196;
pub const DLT_ERF: ::kernel::sys::raw::c_uint = 197;
pub const DLT_RAIF1: ::kernel::sys::raw::c_uint = 198;
pub const DLT_IPMB: ::kernel::sys::raw::c_uint = 199;
pub const DLT_JUNIPER_ST: ::kernel::sys::raw::c_uint = 200;
pub const DLT_BLUETOOTH_HCI_H4_WITH_PHDR: ::kernel::sys::raw::c_uint = 201;
pub const DLT_AX25_KISS: ::kernel::sys::raw::c_uint = 202;
pub const DLT_LAPD: ::kernel::sys::raw::c_uint = 203;
pub const DLT_PPP_WITH_DIR: ::kernel::sys::raw::c_uint = 204;
pub const DLT_C_HDLC_WITH_DIR: ::kernel::sys::raw::c_uint = 205;
pub const DLT_FRELAY_WITH_DIR: ::kernel::sys::raw::c_uint = 206;
pub const DLT_LAPB_WITH_DIR: ::kernel::sys::raw::c_uint = 207;
pub const DLT_IPMB_LINUX: ::kernel::sys::raw::c_uint = 209;
pub const DLT_FLEXRAY: ::kernel::sys::raw::c_uint = 210;
pub const DLT_MOST: ::kernel::sys::raw::c_uint = 211;
pub const DLT_LIN: ::kernel::sys::raw::c_uint = 212;
pub const DLT_X2E_SERIAL: ::kernel::sys::raw::c_uint = 213;
pub const DLT_X2E_XORAYA: ::kernel::sys::raw::c_uint = 214;
pub const DLT_IEEE802_15_4_NONASK_PHY: ::kernel::sys::raw::c_uint = 215;
pub const DLT_LINUX_EVDEV: ::kernel::sys::raw::c_uint = 216;
pub const DLT_GSMTAP_UM: ::kernel::sys::raw::c_uint = 217;
pub const DLT_GSMTAP_ABIS: ::kernel::sys::raw::c_uint = 218;
pub const DLT_MPLS: ::kernel::sys::raw::c_uint = 219;
pub const DLT_USB_LINUX_MMAPPED: ::kernel::sys::raw::c_uint = 220;
pub const DLT_DECT: ::kernel::sys::raw::c_uint = 221;
pub const DLT_AOS: ::kernel::sys::raw::c_uint = 222;
pub const DLT_WIHART: ::kernel::sys::raw::c_uint = 223;
pub const DLT_FC_2: ::kernel::sys::raw::c_uint = 224;
pub const DLT_FC_2_WITH_FRAME_DELIMS: ::kernel::sys::raw::c_uint = 225;
pub const DLT_IPNET: ::kernel::sys::raw::c_uint = 226;
pub const DLT_CAN_SOCKETCAN: ::kernel::sys::raw::c_uint = 227;
pub const DLT_IPV4: ::kernel::sys::raw::c_uint = 228;
pub const DLT_IPV6: ::kernel::sys::raw::c_uint = 229;
pub const DLT_IEEE802_15_4_NOFCS: ::kernel::sys::raw::c_uint = 230;
pub const DLT_DBUS: ::kernel::sys::raw::c_uint = 231;
pub const DLT_JUNIPER_VS: ::kernel::sys::raw::c_uint = 232;
pub const DLT_JUNIPER_SRX_E2E: ::kernel::sys::raw::c_uint = 233;
pub const DLT_JUNIPER_FIBRECHANNEL: ::kernel::sys::raw::c_uint = 234;
pub const DLT_DVB_CI: ::kernel::sys::raw::c_uint = 235;
pub const DLT_MUX27010: ::kernel::sys::raw::c_uint = 236;
pub const DLT_STANAG_5066_D_PDU: ::kernel::sys::raw::c_uint = 237;
pub const DLT_JUNIPER_ATM_CEMIC: ::kernel::sys::raw::c_uint = 238;
pub const DLT_NFLOG: ::kernel::sys::raw::c_uint = 239;
pub const DLT_NETANALYZER: ::kernel::sys::raw::c_uint = 240;
pub const DLT_NETANALYZER_TRANSPARENT: ::kernel::sys::raw::c_uint = 241;
pub const DLT_IPOIB: ::kernel::sys::raw::c_uint = 242;
pub const DLT_MPEG_2_TS: ::kernel::sys::raw::c_uint = 243;
pub const DLT_NG40: ::kernel::sys::raw::c_uint = 244;
pub const DLT_NFC_LLCP: ::kernel::sys::raw::c_uint = 245;
pub const DLT_INFINIBAND: ::kernel::sys::raw::c_uint = 247;
pub const DLT_SCTP: ::kernel::sys::raw::c_uint = 248;
pub const DLT_USBPCAP: ::kernel::sys::raw::c_uint = 249;
pub const DLT_RTAC_SERIAL: ::kernel::sys::raw::c_uint = 250;
pub const DLT_BLUETOOTH_LE_LL: ::kernel::sys::raw::c_uint = 251;
pub const DLT_WIRESHARK_UPPER_PDU: ::kernel::sys::raw::c_uint = 252;
pub const DLT_NETLINK: ::kernel::sys::raw::c_uint = 253;
pub const DLT_BLUETOOTH_LINUX_MONITOR: ::kernel::sys::raw::c_uint = 254;
pub const DLT_BLUETOOTH_BREDR_BB: ::kernel::sys::raw::c_uint = 255;
pub const DLT_BLUETOOTH_LE_LL_WITH_PHDR: ::kernel::sys::raw::c_uint = 256;
pub const DLT_PROFIBUS_DL: ::kernel::sys::raw::c_uint = 257;
pub const DLT_PKTAP: ::kernel::sys::raw::c_uint = 258;
pub const DLT_EPON: ::kernel::sys::raw::c_uint = 259;
pub const DLT_IPMI_HPM_2: ::kernel::sys::raw::c_uint = 260;
pub const DLT_ZWAVE_R1_R2: ::kernel::sys::raw::c_uint = 261;
pub const DLT_ZWAVE_R3: ::kernel::sys::raw::c_uint = 262;
pub const DLT_WATTSTOPPER_DLM: ::kernel::sys::raw::c_uint = 263;
pub const DLT_ISO_14443: ::kernel::sys::raw::c_uint = 264;
pub const DLT_RDS: ::kernel::sys::raw::c_uint = 265;
pub const DLT_MATCHING_MAX: ::kernel::sys::raw::c_uint = 265;
pub const DLT_CLASS_NETBSD_RAWAF: ::kernel::sys::raw::c_uint = 35913728;
pub const BPF_LD: ::kernel::sys::raw::c_uint = 0;
pub const BPF_LDX: ::kernel::sys::raw::c_uint = 1;
pub const BPF_ST: ::kernel::sys::raw::c_uint = 2;
pub const BPF_STX: ::kernel::sys::raw::c_uint = 3;
pub const BPF_ALU: ::kernel::sys::raw::c_uint = 4;
pub const BPF_JMP: ::kernel::sys::raw::c_uint = 5;
pub const BPF_RET: ::kernel::sys::raw::c_uint = 6;
pub const BPF_MISC: ::kernel::sys::raw::c_uint = 7;
pub const BPF_W: ::kernel::sys::raw::c_uint = 0;
pub const BPF_H: ::kernel::sys::raw::c_uint = 8;
pub const BPF_B: ::kernel::sys::raw::c_uint = 16;
pub const BPF_IMM: ::kernel::sys::raw::c_uint = 0;
pub const BPF_ABS: ::kernel::sys::raw::c_uint = 32;
pub const BPF_IND: ::kernel::sys::raw::c_uint = 64;
pub const BPF_MEM: ::kernel::sys::raw::c_uint = 96;
pub const BPF_LEN: ::kernel::sys::raw::c_uint = 128;
pub const BPF_MSH: ::kernel::sys::raw::c_uint = 160;
pub const BPF_ADD: ::kernel::sys::raw::c_uint = 0;
pub const BPF_SUB: ::kernel::sys::raw::c_uint = 16;
pub const BPF_MUL: ::kernel::sys::raw::c_uint = 32;
pub const BPF_DIV: ::kernel::sys::raw::c_uint = 48;
pub const BPF_OR: ::kernel::sys::raw::c_uint = 64;
pub const BPF_AND: ::kernel::sys::raw::c_uint = 80;
pub const BPF_LSH: ::kernel::sys::raw::c_uint = 96;
pub const BPF_RSH: ::kernel::sys::raw::c_uint = 112;
pub const BPF_NEG: ::kernel::sys::raw::c_uint = 128;
pub const BPF_MOD: ::kernel::sys::raw::c_uint = 144;
pub const BPF_XOR: ::kernel::sys::raw::c_uint = 160;
pub const BPF_JA: ::kernel::sys::raw::c_uint = 0;
pub const BPF_JEQ: ::kernel::sys::raw::c_uint = 16;
pub const BPF_JGT: ::kernel::sys::raw::c_uint = 32;
pub const BPF_JGE: ::kernel::sys::raw::c_uint = 48;
pub const BPF_JSET: ::kernel::sys::raw::c_uint = 64;
pub const BPF_K: ::kernel::sys::raw::c_uint = 0;
pub const BPF_X: ::kernel::sys::raw::c_uint = 8;
pub const BPF_A: ::kernel::sys::raw::c_uint = 16;
pub const BPF_TAX: ::kernel::sys::raw::c_uint = 0;
pub const BPF_TXA: ::kernel::sys::raw::c_uint = 128;
pub const BPF_MEMWORDS: ::kernel::sys::raw::c_uint = 16;
pub const ETHER_ADDR_LEN: ::kernel::sys::raw::c_uint = 6;
pub const ETHER_TYPE_LEN: ::kernel::sys::raw::c_uint = 2;
pub const ETHER_CRC_LEN: ::kernel::sys::raw::c_uint = 4;
pub const ETHER_HDR_LEN: ::kernel::sys::raw::c_uint = 14;
pub const ETHER_MIN_LEN: ::kernel::sys::raw::c_uint = 64;
pub const ETHER_MAX_LEN: ::kernel::sys::raw::c_uint = 1518;
pub const ETHER_MAX_LEN_JUMBO: ::kernel::sys::raw::c_uint = 9018;
pub const ETHER_VLAN_ENCAP_LEN: ::kernel::sys::raw::c_uint = 4;
pub const ETHER_ALIGN: ::kernel::sys::raw::c_uint = 2;
pub const M_HASFCS: ::kernel::sys::raw::c_uint = 65536;
pub const ETHER_CRC_POLY_LE: ::kernel::sys::raw::c_uint = 3988292384;
pub const ETHER_CRC_POLY_BE: ::kernel::sys::raw::c_uint = 79764918;
pub const EVL_VLID_MASK: ::kernel::sys::raw::c_uint = 4095;
pub const EVL_PRI_MASK: ::kernel::sys::raw::c_uint = 57344;
pub const ETHERTYPE_8023: ::kernel::sys::raw::c_uint = 4;
pub const ETHERTYPE_PUP: ::kernel::sys::raw::c_uint = 512;
pub const ETHERTYPE_PUPAT: ::kernel::sys::raw::c_uint = 512;
pub const ETHERTYPE_SPRITE: ::kernel::sys::raw::c_uint = 1280;
pub const ETHERTYPE_NS: ::kernel::sys::raw::c_uint = 1536;
pub const ETHERTYPE_NSAT: ::kernel::sys::raw::c_uint = 1537;
pub const ETHERTYPE_DLOG1: ::kernel::sys::raw::c_uint = 1632;
pub const ETHERTYPE_DLOG2: ::kernel::sys::raw::c_uint = 1633;
pub const ETHERTYPE_IP: ::kernel::sys::raw::c_uint = 2048;
pub const ETHERTYPE_X75: ::kernel::sys::raw::c_uint = 2049;
pub const ETHERTYPE_NBS: ::kernel::sys::raw::c_uint = 2050;
pub const ETHERTYPE_ECMA: ::kernel::sys::raw::c_uint = 2051;
pub const ETHERTYPE_CHAOS: ::kernel::sys::raw::c_uint = 2052;
pub const ETHERTYPE_X25: ::kernel::sys::raw::c_uint = 2053;
pub const ETHERTYPE_ARP: ::kernel::sys::raw::c_uint = 2054;
pub const ETHERTYPE_NSCOMPAT: ::kernel::sys::raw::c_uint = 2055;
pub const ETHERTYPE_FRARP: ::kernel::sys::raw::c_uint = 2056;
pub const ETHERTYPE_UBDEBUG: ::kernel::sys::raw::c_uint = 2304;
pub const ETHERTYPE_IEEEPUP: ::kernel::sys::raw::c_uint = 2560;
pub const ETHERTYPE_IEEEPUPAT: ::kernel::sys::raw::c_uint = 2561;
pub const ETHERTYPE_VINES: ::kernel::sys::raw::c_uint = 2989;
pub const ETHERTYPE_VINESLOOP: ::kernel::sys::raw::c_uint = 2990;
pub const ETHERTYPE_VINESECHO: ::kernel::sys::raw::c_uint = 2991;
pub const ETHERTYPE_TRAIL: ::kernel::sys::raw::c_uint = 4096;
pub const ETHERTYPE_NTRAILER: ::kernel::sys::raw::c_uint = 16;
pub const ETHERTYPE_DCA: ::kernel::sys::raw::c_uint = 4660;
pub const ETHERTYPE_VALID: ::kernel::sys::raw::c_uint = 5632;
pub const ETHERTYPE_DOGFIGHT: ::kernel::sys::raw::c_uint = 6537;
pub const ETHERTYPE_RCL: ::kernel::sys::raw::c_uint = 6549;
pub const ETHERTYPE_NBPVCD: ::kernel::sys::raw::c_uint = 15360;
pub const ETHERTYPE_NBPSCD: ::kernel::sys::raw::c_uint = 15361;
pub const ETHERTYPE_NBPCREQ: ::kernel::sys::raw::c_uint = 15362;
pub const ETHERTYPE_NBPCRSP: ::kernel::sys::raw::c_uint = 15363;
pub const ETHERTYPE_NBPCC: ::kernel::sys::raw::c_uint = 15364;
pub const ETHERTYPE_NBPCLREQ: ::kernel::sys::raw::c_uint = 15365;
pub const ETHERTYPE_NBPCLRSP: ::kernel::sys::raw::c_uint = 15366;
pub const ETHERTYPE_NBPDG: ::kernel::sys::raw::c_uint = 15367;
pub const ETHERTYPE_NBPDGB: ::kernel::sys::raw::c_uint = 15368;
pub const ETHERTYPE_NBPCLAIM: ::kernel::sys::raw::c_uint = 15369;
pub const ETHERTYPE_NBPDLTE: ::kernel::sys::raw::c_uint = 15370;
pub const ETHERTYPE_NBPRAS: ::kernel::sys::raw::c_uint = 15371;
pub const ETHERTYPE_NBPRAR: ::kernel::sys::raw::c_uint = 15372;
pub const ETHERTYPE_NBPRST: ::kernel::sys::raw::c_uint = 15373;
pub const ETHERTYPE_PCS: ::kernel::sys::raw::c_uint = 16962;
pub const ETHERTYPE_IMLBLDIAG: ::kernel::sys::raw::c_uint = 16972;
pub const ETHERTYPE_DIDDLE: ::kernel::sys::raw::c_uint = 17185;
pub const ETHERTYPE_IMLBL: ::kernel::sys::raw::c_uint = 19522;
pub const ETHERTYPE_SIMNET: ::kernel::sys::raw::c_uint = 21000;
pub const ETHERTYPE_DECEXPER: ::kernel::sys::raw::c_uint = 24576;
pub const ETHERTYPE_MOPDL: ::kernel::sys::raw::c_uint = 24577;
pub const ETHERTYPE_MOPRC: ::kernel::sys::raw::c_uint = 24578;
pub const ETHERTYPE_DECnet: ::kernel::sys::raw::c_uint = 24579;
pub const ETHERTYPE_DN: ::kernel::sys::raw::c_uint = 24579;
pub const ETHERTYPE_LAT: ::kernel::sys::raw::c_uint = 24580;
pub const ETHERTYPE_DECDIAG: ::kernel::sys::raw::c_uint = 24581;
pub const ETHERTYPE_DECCUST: ::kernel::sys::raw::c_uint = 24582;
pub const ETHERTYPE_SCA: ::kernel::sys::raw::c_uint = 24583;
pub const ETHERTYPE_AMBER: ::kernel::sys::raw::c_uint = 24584;
pub const ETHERTYPE_DECMUMPS: ::kernel::sys::raw::c_uint = 24585;
pub const ETHERTYPE_TRANSETHER: ::kernel::sys::raw::c_uint = 25944;
pub const ETHERTYPE_RAWFR: ::kernel::sys::raw::c_uint = 25945;
pub const ETHERTYPE_UBDL: ::kernel::sys::raw::c_uint = 28672;
pub const ETHERTYPE_UBNIU: ::kernel::sys::raw::c_uint = 28673;
pub const ETHERTYPE_UBDIAGLOOP: ::kernel::sys::raw::c_uint = 28674;
pub const ETHERTYPE_UBNMC: ::kernel::sys::raw::c_uint = 28675;
pub const ETHERTYPE_UBBST: ::kernel::sys::raw::c_uint = 28677;
pub const ETHERTYPE_OS9: ::kernel::sys::raw::c_uint = 28679;
pub const ETHERTYPE_OS9NET: ::kernel::sys::raw::c_uint = 28681;
pub const ETHERTYPE_RACAL: ::kernel::sys::raw::c_uint = 28720;
pub const ETHERTYPE_PRIMENTS: ::kernel::sys::raw::c_uint = 28721;
pub const ETHERTYPE_CABLETRON: ::kernel::sys::raw::c_uint = 28724;
pub const ETHERTYPE_CRONUSVLN: ::kernel::sys::raw::c_uint = 32771;
pub const ETHERTYPE_CRONUS: ::kernel::sys::raw::c_uint = 32772;
pub const ETHERTYPE_HP: ::kernel::sys::raw::c_uint = 32773;
pub const ETHERTYPE_NESTAR: ::kernel::sys::raw::c_uint = 32774;
pub const ETHERTYPE_ATTSTANFORD: ::kernel::sys::raw::c_uint = 32776;
pub const ETHERTYPE_EXCELAN: ::kernel::sys::raw::c_uint = 32784;
pub const ETHERTYPE_SG_DIAG: ::kernel::sys::raw::c_uint = 32787;
pub const ETHERTYPE_SG_NETGAMES: ::kernel::sys::raw::c_uint = 32788;
pub const ETHERTYPE_SG_RESV: ::kernel::sys::raw::c_uint = 32789;
pub const ETHERTYPE_SG_BOUNCE: ::kernel::sys::raw::c_uint = 32790;
pub const ETHERTYPE_APOLLODOMAIN: ::kernel::sys::raw::c_uint = 32793;
pub const ETHERTYPE_TYMSHARE: ::kernel::sys::raw::c_uint = 32814;
pub const ETHERTYPE_TIGAN: ::kernel::sys::raw::c_uint = 32815;
pub const ETHERTYPE_REVARP: ::kernel::sys::raw::c_uint = 32821;
pub const ETHERTYPE_AEONIC: ::kernel::sys::raw::c_uint = 32822;
pub const ETHERTYPE_IPXNEW: ::kernel::sys::raw::c_uint = 32823;
pub const ETHERTYPE_LANBRIDGE: ::kernel::sys::raw::c_uint = 32824;
pub const ETHERTYPE_DSMD: ::kernel::sys::raw::c_uint = 32825;
pub const ETHERTYPE_ARGONAUT: ::kernel::sys::raw::c_uint = 32826;
pub const ETHERTYPE_VAXELN: ::kernel::sys::raw::c_uint = 32827;
pub const ETHERTYPE_DECDNS: ::kernel::sys::raw::c_uint = 32828;
pub const ETHERTYPE_ENCRYPT: ::kernel::sys::raw::c_uint = 32829;
pub const ETHERTYPE_DECDTS: ::kernel::sys::raw::c_uint = 32830;
pub const ETHERTYPE_DECLTM: ::kernel::sys::raw::c_uint = 32831;
pub const ETHERTYPE_DECNETBIOS: ::kernel::sys::raw::c_uint = 32832;
pub const ETHERTYPE_DECLAST: ::kernel::sys::raw::c_uint = 32833;
pub const ETHERTYPE_PLANNING: ::kernel::sys::raw::c_uint = 32836;
pub const ETHERTYPE_DECAM: ::kernel::sys::raw::c_uint = 32840;
pub const ETHERTYPE_EXPERDATA: ::kernel::sys::raw::c_uint = 32841;
pub const ETHERTYPE_VEXP: ::kernel::sys::raw::c_uint = 32859;
pub const ETHERTYPE_VPROD: ::kernel::sys::raw::c_uint = 32860;
pub const ETHERTYPE_ES: ::kernel::sys::raw::c_uint = 32861;
pub const ETHERTYPE_LITTLE: ::kernel::sys::raw::c_uint = 32864;
pub const ETHERTYPE_COUNTERPOINT: ::kernel::sys::raw::c_uint = 32866;
pub const ETHERTYPE_VEECO: ::kernel::sys::raw::c_uint = 32871;
pub const ETHERTYPE_GENDYN: ::kernel::sys::raw::c_uint = 32872;
pub const ETHERTYPE_ATT: ::kernel::sys::raw::c_uint = 32873;
pub const ETHERTYPE_AUTOPHON: ::kernel::sys::raw::c_uint = 32874;
pub const ETHERTYPE_COMDESIGN: ::kernel::sys::raw::c_uint = 32876;
pub const ETHERTYPE_COMPUGRAPHIC: ::kernel::sys::raw::c_uint = 32877;
pub const ETHERTYPE_MATRA: ::kernel::sys::raw::c_uint = 32890;
pub const ETHERTYPE_DDE: ::kernel::sys::raw::c_uint = 32891;
pub const ETHERTYPE_MERIT: ::kernel::sys::raw::c_uint = 32892;
pub const ETHERTYPE_VLTLMAN: ::kernel::sys::raw::c_uint = 32896;
pub const ETHERTYPE_ATALK: ::kernel::sys::raw::c_uint = 32923;
pub const ETHERTYPE_AT: ::kernel::sys::raw::c_uint = 32923;
pub const ETHERTYPE_APPLETALK: ::kernel::sys::raw::c_uint = 32923;
pub const ETHERTYPE_SPIDER: ::kernel::sys::raw::c_uint = 32927;
pub const ETHERTYPE_PACER: ::kernel::sys::raw::c_uint = 32966;
pub const ETHERTYPE_APPLITEK: ::kernel::sys::raw::c_uint = 32967;
pub const ETHERTYPE_SNA: ::kernel::sys::raw::c_uint = 32981;
pub const ETHERTYPE_VARIAN: ::kernel::sys::raw::c_uint = 32989;
pub const ETHERTYPE_RETIX: ::kernel::sys::raw::c_uint = 33010;
pub const ETHERTYPE_AARP: ::kernel::sys::raw::c_uint = 33011;
pub const ETHERTYPE_APOLLO: ::kernel::sys::raw::c_uint = 33015;
pub const ETHERTYPE_VLAN: ::kernel::sys::raw::c_uint = 33024;
pub const ETHERTYPE_BOFL: ::kernel::sys::raw::c_uint = 33026;
pub const ETHERTYPE_WELLFLEET: ::kernel::sys::raw::c_uint = 33027;
pub const ETHERTYPE_TALARIS: ::kernel::sys::raw::c_uint = 33067;
pub const ETHERTYPE_WATERLOO: ::kernel::sys::raw::c_uint = 33072;
pub const ETHERTYPE_HAYES: ::kernel::sys::raw::c_uint = 33072;
pub const ETHERTYPE_VGLAB: ::kernel::sys::raw::c_uint = 33073;
pub const ETHERTYPE_IPX: ::kernel::sys::raw::c_uint = 33079;
pub const ETHERTYPE_NOVELL: ::kernel::sys::raw::c_uint = 33080;
pub const ETHERTYPE_MUMPS: ::kernel::sys::raw::c_uint = 33087;
pub const ETHERTYPE_AMOEBA: ::kernel::sys::raw::c_uint = 33093;
pub const ETHERTYPE_FLIP: ::kernel::sys::raw::c_uint = 33094;
pub const ETHERTYPE_VURESERVED: ::kernel::sys::raw::c_uint = 33095;
pub const ETHERTYPE_LOGICRAFT: ::kernel::sys::raw::c_uint = 33096;
pub const ETHERTYPE_NCD: ::kernel::sys::raw::c_uint = 33097;
pub const ETHERTYPE_ALPHA: ::kernel::sys::raw::c_uint = 33098;
pub const ETHERTYPE_SNMP: ::kernel::sys::raw::c_uint = 33100;
pub const ETHERTYPE_TEC: ::kernel::sys::raw::c_uint = 33103;
pub const ETHERTYPE_RATIONAL: ::kernel::sys::raw::c_uint = 33104;
pub const ETHERTYPE_XTP: ::kernel::sys::raw::c_uint = 33149;
pub const ETHERTYPE_SGITW: ::kernel::sys::raw::c_uint = 33150;
pub const ETHERTYPE_HIPPI_FP: ::kernel::sys::raw::c_uint = 33152;
pub const ETHERTYPE_STP: ::kernel::sys::raw::c_uint = 33153;
pub const ETHERTYPE_MOTOROLA: ::kernel::sys::raw::c_uint = 33165;
pub const ETHERTYPE_NETBEUI: ::kernel::sys::raw::c_uint = 33169;
pub const ETHERTYPE_ACCTON: ::kernel::sys::raw::c_uint = 33680;
pub const ETHERTYPE_TALARISMC: ::kernel::sys::raw::c_uint = 34091;
pub const ETHERTYPE_KALPANA: ::kernel::sys::raw::c_uint = 34178;
pub const ETHERTYPE_SECTRA: ::kernel::sys::raw::c_uint = 34523;
pub const ETHERTYPE_IPV6: ::kernel::sys::raw::c_uint = 34525;
pub const ETHERTYPE_DELTACON: ::kernel::sys::raw::c_uint = 34526;
pub const ETHERTYPE_ATOMIC: ::kernel::sys::raw::c_uint = 34527;
pub const ETHERTYPE_RDP: ::kernel::sys::raw::c_uint = 34617;
pub const ETHERTYPE_MICP: ::kernel::sys::raw::c_uint = 34618;
pub const ETHERTYPE_TCPCOMP: ::kernel::sys::raw::c_uint = 34667;
pub const ETHERTYPE_IPAS: ::kernel::sys::raw::c_uint = 34668;
pub const ETHERTYPE_SECUREDATA: ::kernel::sys::raw::c_uint = 34669;
pub const ETHERTYPE_FLOWCONTROL: ::kernel::sys::raw::c_uint = 34824;
pub const ETHERTYPE_SLOW: ::kernel::sys::raw::c_uint = 34825;
pub const ETHERTYPE_PPP: ::kernel::sys::raw::c_uint = 34827;
pub const ETHERTYPE_HITACHI: ::kernel::sys::raw::c_uint = 34848;
pub const ETHERTYPE_TEST: ::kernel::sys::raw::c_uint = 34850;
pub const ETHERTYPE_MPLS: ::kernel::sys::raw::c_uint = 34887;
pub const ETHERTYPE_MPLS_MCAST: ::kernel::sys::raw::c_uint = 34888;
pub const ETHERTYPE_AXIS: ::kernel::sys::raw::c_uint = 34902;
pub const ETHERTYPE_PPPOEDISC: ::kernel::sys::raw::c_uint = 34915;
pub const ETHERTYPE_PPPOE: ::kernel::sys::raw::c_uint = 34916;
pub const ETHERTYPE_LANPROBE: ::kernel::sys::raw::c_uint = 34952;
pub const ETHERTYPE_PAE: ::kernel::sys::raw::c_uint = 34958;
pub const ETHERTYPE_QINQ: ::kernel::sys::raw::c_uint = 34984;
pub const ETHERTYPE_LOOPBACK: ::kernel::sys::raw::c_uint = 36864;
pub const ETHERTYPE_LBACK: ::kernel::sys::raw::c_uint = 36864;
pub const ETHERTYPE_XNSSM: ::kernel::sys::raw::c_uint = 36865;
pub const ETHERTYPE_TCPSM: ::kernel::sys::raw::c_uint = 36866;
pub const ETHERTYPE_BCLOOP: ::kernel::sys::raw::c_uint = 36867;
pub const ETHERTYPE_DEBNI: ::kernel::sys::raw::c_uint = 43690;
pub const ETHERTYPE_SONIX: ::kernel::sys::raw::c_uint = 64245;
pub const ETHERTYPE_VITAL: ::kernel::sys::raw::c_uint = 65280;
pub const ETHERTYPE_MAX: ::kernel::sys::raw::c_uint = 65535;
pub const ETHERMTU: ::kernel::sys::raw::c_uint = 1500;
pub const ETHERMIN: ::kernel::sys::raw::c_uint = 46;
pub const ETHERMTU_JUMBO: ::kernel::sys::raw::c_uint = 9000;
pub const IEEE8021Q_PCP_BK: ::kernel::sys::raw::c_uint = 1;
pub const IEEE8021Q_PCP_BE: ::kernel::sys::raw::c_uint = 0;
pub const IEEE8021Q_PCP_EE: ::kernel::sys::raw::c_uint = 2;
pub const IEEE8021Q_PCP_CA: ::kernel::sys::raw::c_uint = 3;
pub const IEEE8021Q_PCP_VI: ::kernel::sys::raw::c_uint = 4;
pub const IEEE8021Q_PCP_VO: ::kernel::sys::raw::c_uint = 5;
pub const IEEE8021Q_PCP_IC: ::kernel::sys::raw::c_uint = 6;
pub const IEEE8021Q_PCP_NC: ::kernel::sys::raw::c_uint = 7;
pub const IF_NAMESIZE: ::kernel::sys::raw::c_uint = 16;
pub const IFNAMSIZ: ::kernel::sys::raw::c_uint = 16;
pub const IF_MAXUNIT: ::kernel::sys::raw::c_uint = 32767;
pub const IFF_UP: ::kernel::sys::raw::c_uint = 1;
pub const IFF_BROADCAST: ::kernel::sys::raw::c_uint = 2;
pub const IFF_DEBUG: ::kernel::sys::raw::c_uint = 4;
pub const IFF_LOOPBACK: ::kernel::sys::raw::c_uint = 8;
pub const IFF_POINTOPOINT: ::kernel::sys::raw::c_uint = 16;
pub const IFF_DRV_RUNNING: ::kernel::sys::raw::c_uint = 64;
pub const IFF_NOARP: ::kernel::sys::raw::c_uint = 128;
pub const IFF_PROMISC: ::kernel::sys::raw::c_uint = 256;
pub const IFF_ALLMULTI: ::kernel::sys::raw::c_uint = 512;
pub const IFF_DRV_OACTIVE: ::kernel::sys::raw::c_uint = 1024;
pub const IFF_SIMPLEX: ::kernel::sys::raw::c_uint = 2048;
pub const IFF_LINK0: ::kernel::sys::raw::c_uint = 4096;
pub const IFF_LINK1: ::kernel::sys::raw::c_uint = 8192;
pub const IFF_LINK2: ::kernel::sys::raw::c_uint = 16384;
pub const IFF_ALTPHYS: ::kernel::sys::raw::c_uint = 16384;
pub const IFF_MULTICAST: ::kernel::sys::raw::c_uint = 32768;
pub const IFF_CANTCONFIG: ::kernel::sys::raw::c_uint = 65536;
pub const IFF_PPROMISC: ::kernel::sys::raw::c_uint = 131072;
pub const IFF_MONITOR: ::kernel::sys::raw::c_uint = 262144;
pub const IFF_STATICARP: ::kernel::sys::raw::c_uint = 524288;
pub const IFF_DYING: ::kernel::sys::raw::c_uint = 2097152;
pub const IFF_RENAMING: ::kernel::sys::raw::c_uint = 4194304;
pub const IFF_NOGROUP: ::kernel::sys::raw::c_uint = 8388608;
pub const IFF_CANTCHANGE: ::kernel::sys::raw::c_uint = 2199378;
pub const LINK_STATE_UNKNOWN: ::kernel::sys::raw::c_uint = 0;
pub const LINK_STATE_DOWN: ::kernel::sys::raw::c_uint = 1;
pub const LINK_STATE_UP: ::kernel::sys::raw::c_uint = 2;
pub const IFCAP_RXCSUM: ::kernel::sys::raw::c_uint = 1;
pub const IFCAP_TXCSUM: ::kernel::sys::raw::c_uint = 2;
pub const IFCAP_NETCONS: ::kernel::sys::raw::c_uint = 4;
pub const IFCAP_VLAN_MTU: ::kernel::sys::raw::c_uint = 8;
pub const IFCAP_VLAN_HWTAGGING: ::kernel::sys::raw::c_uint = 16;
pub const IFCAP_JUMBO_MTU: ::kernel::sys::raw::c_uint = 32;
pub const IFCAP_POLLING: ::kernel::sys::raw::c_uint = 64;
pub const IFCAP_VLAN_HWCSUM: ::kernel::sys::raw::c_uint = 128;
pub const IFCAP_TSO4: ::kernel::sys::raw::c_uint = 256;
pub const IFCAP_TSO6: ::kernel::sys::raw::c_uint = 512;
pub const IFCAP_LRO: ::kernel::sys::raw::c_uint = 1024;
pub const IFCAP_WOL_UCAST: ::kernel::sys::raw::c_uint = 2048;
pub const IFCAP_WOL_MCAST: ::kernel::sys::raw::c_uint = 4096;
pub const IFCAP_WOL_MAGIC: ::kernel::sys::raw::c_uint = 8192;
pub const IFCAP_TOE4: ::kernel::sys::raw::c_uint = 16384;
pub const IFCAP_TOE6: ::kernel::sys::raw::c_uint = 32768;
pub const IFCAP_VLAN_HWFILTER: ::kernel::sys::raw::c_uint = 65536;
pub const IFCAP_VLAN_HWTSO: ::kernel::sys::raw::c_uint = 262144;
pub const IFCAP_LINKSTATE: ::kernel::sys::raw::c_uint = 524288;
pub const IFCAP_NETMAP: ::kernel::sys::raw::c_uint = 1048576;
pub const IFCAP_RXCSUM_IPV6: ::kernel::sys::raw::c_uint = 2097152;
pub const IFCAP_TXCSUM_IPV6: ::kernel::sys::raw::c_uint = 4194304;
pub const IFCAP_HWSTATS: ::kernel::sys::raw::c_uint = 8388608;
pub const IFCAP_TXRTLMT: ::kernel::sys::raw::c_uint = 16777216;
pub const IFCAP_HWRXTSTMP: ::kernel::sys::raw::c_uint = 33554432;
pub const IFCAP_HWCSUM_IPV6: ::kernel::sys::raw::c_uint = 6291456;
pub const IFCAP_HWCSUM: ::kernel::sys::raw::c_uint = 3;
pub const IFCAP_TSO: ::kernel::sys::raw::c_uint = 768;
pub const IFCAP_WOL: ::kernel::sys::raw::c_uint = 14336;
pub const IFCAP_TOE: ::kernel::sys::raw::c_uint = 49152;
pub const IFCAP_CANTCHANGE: ::kernel::sys::raw::c_uint = 1048576;
pub const IFQ_MAXLEN: ::kernel::sys::raw::c_uint = 50;
pub const IFNET_SLOWHZ: ::kernel::sys::raw::c_uint = 1;
pub const IFAN_ARRIVAL: ::kernel::sys::raw::c_uint = 0;
pub const IFAN_DEPARTURE: ::kernel::sys::raw::c_uint = 1;
pub const IFSTATMAX: ::kernel::sys::raw::c_uint = 800;
pub const IFG_ALL: &'static [u8; 4usize] = b"all\x00";
pub const IFG_EGRESS: &'static [u8; 7usize] = b"egress\x00";
pub const RSS_FUNC_NONE: ::kernel::sys::raw::c_uint = 0;
pub const RSS_FUNC_PRIVATE: ::kernel::sys::raw::c_uint = 1;
pub const RSS_FUNC_TOEPLITZ: ::kernel::sys::raw::c_uint = 2;
pub const RSS_TYPE_IPV4: ::kernel::sys::raw::c_uint = 1;
pub const RSS_TYPE_TCP_IPV4: ::kernel::sys::raw::c_uint = 2;
pub const RSS_TYPE_IPV6: ::kernel::sys::raw::c_uint = 4;
pub const RSS_TYPE_IPV6_EX: ::kernel::sys::raw::c_uint = 8;
pub const RSS_TYPE_TCP_IPV6: ::kernel::sys::raw::c_uint = 16;
pub const RSS_TYPE_TCP_IPV6_EX: ::kernel::sys::raw::c_uint = 32;
pub const RSS_TYPE_UDP_IPV4: ::kernel::sys::raw::c_uint = 64;
pub const RSS_TYPE_UDP_IPV6: ::kernel::sys::raw::c_uint = 128;
pub const RSS_TYPE_UDP_IPV6_EX: ::kernel::sys::raw::c_uint = 256;
pub const RSS_KEYLEN: ::kernel::sys::raw::c_uint = 128;
pub const IFNET_PCP_NONE: ::kernel::sys::raw::c_uint = 255;
pub const VNET_MAGIC_N: ::kernel::sys::raw::c_uint = 1041076009;
pub const VNET_SETNAME: &'static [u8; 9usize] = b"set_vnet\x00";
pub const VNET_SYMPREFIX: &'static [u8; 12usize] = b"vnet_entry_\x00";
pub const CK_MD_CACHELINE: ::kernel::sys::raw::c_uint = 64;
pub const CK_MD_PAGESIZE: ::kernel::sys::raw::c_uint = 4096;
pub const CK_MD_CC_BUILTIN_DISABLE: ::kernel::sys::raw::c_uint = 1;
pub const CK_VERSION: &'static [u8; 6usize] = b"0.7.0\x00";
pub const CK_GIT_SHA: &'static [u8; 8usize] = b"db5db44\x00";
pub const CK_CC_IMM: &'static [u8; 2usize] = b"i\x00";
pub const CK_CC_IMM_U32: &'static [u8; 2usize] = b"Z\x00";
pub const CK_CC_IMM_S32: &'static [u8; 2usize] = b"e\x00";
pub const CHAR_BIT: ::kernel::sys::raw::c_uint = 8;
pub const SCHAR_MAX: ::kernel::sys::raw::c_uint = 127;
pub const SCHAR_MIN: ::kernel::sys::raw::c_int = -128;
pub const UCHAR_MAX: ::kernel::sys::raw::c_uint = 255;
pub const CHAR_MAX: ::kernel::sys::raw::c_uint = 127;
pub const CHAR_MIN: ::kernel::sys::raw::c_int = -128;
pub const USHRT_MAX: ::kernel::sys::raw::c_uint = 65535;
pub const SHRT_MAX: ::kernel::sys::raw::c_uint = 32767;
pub const SHRT_MIN: ::kernel::sys::raw::c_int = -32768;
pub const UINT_MAX: ::kernel::sys::raw::c_uint = 4294967295;
pub const INT_MAX: ::kernel::sys::raw::c_uint = 2147483647;
pub const INT_MIN: ::kernel::sys::raw::c_int = -2147483648;
pub const ULONG_MAX: ::kernel::sys::raw::c_int = -1;
pub const LONG_MAX: ::kernel::sys::raw::c_ulonglong = 9223372036854775807;
pub const LONG_MIN: ::kernel::sys::raw::c_longlong = -9223372036854775808;
pub const ULLONG_MAX: ::kernel::sys::raw::c_int = -1;
pub const LLONG_MAX: ::kernel::sys::raw::c_ulonglong = 9223372036854775807;
pub const LLONG_MIN: ::kernel::sys::raw::c_longlong = -9223372036854775808;
pub const SSIZE_MAX: ::kernel::sys::raw::c_ulonglong = 9223372036854775807;
pub const SIZE_T_MAX: ::kernel::sys::raw::c_int = -1;
pub const OFF_MAX: ::kernel::sys::raw::c_ulonglong = 9223372036854775807;
pub const OFF_MIN: ::kernel::sys::raw::c_longlong = -9223372036854775808;
pub const GID_MAX: ::kernel::sys::raw::c_uint = 4294967295;
pub const UID_MAX: ::kernel::sys::raw::c_uint = 4294967295;
pub const UQUAD_MAX: ::kernel::sys::raw::c_int = -1;
pub const QUAD_MAX: ::kernel::sys::raw::c_ulonglong = 9223372036854775807;
pub const QUAD_MIN: ::kernel::sys::raw::c_longlong = -9223372036854775808;
pub const LONG_BIT: ::kernel::sys::raw::c_uint = 64;
pub const WORD_BIT: ::kernel::sys::raw::c_uint = 32;
pub const MQ_PRIO_MAX: ::kernel::sys::raw::c_uint = 64;
pub const CK_EPOCH_LENGTH: ::kernel::sys::raw::c_uint = 4;
pub const CK_EPOCH_SENSE: ::kernel::sys::raw::c_uint = 2;
pub const EVFILT_READ: ::kernel::sys::raw::c_int = -1;
pub const EVFILT_WRITE: ::kernel::sys::raw::c_int = -2;
pub const EVFILT_AIO: ::kernel::sys::raw::c_int = -3;
pub const EVFILT_VNODE: ::kernel::sys::raw::c_int = -4;
pub const EVFILT_PROC: ::kernel::sys::raw::c_int = -5;
pub const EVFILT_SIGNAL: ::kernel::sys::raw::c_int = -6;
pub const EVFILT_TIMER: ::kernel::sys::raw::c_int = -7;
pub const EVFILT_PROCDESC: ::kernel::sys::raw::c_int = -8;
pub const EVFILT_FS: ::kernel::sys::raw::c_int = -9;
pub const EVFILT_LIO: ::kernel::sys::raw::c_int = -10;
pub const EVFILT_USER: ::kernel::sys::raw::c_int = -11;
pub const EVFILT_SENDFILE: ::kernel::sys::raw::c_int = -12;
pub const EVFILT_EMPTY: ::kernel::sys::raw::c_int = -13;
pub const EVFILT_SYSCOUNT: ::kernel::sys::raw::c_uint = 13;
pub const EV_ADD: ::kernel::sys::raw::c_uint = 1;
pub const EV_DELETE: ::kernel::sys::raw::c_uint = 2;
pub const EV_ENABLE: ::kernel::sys::raw::c_uint = 4;
pub const EV_DISABLE: ::kernel::sys::raw::c_uint = 8;
pub const EV_FORCEONESHOT: ::kernel::sys::raw::c_uint = 256;
pub const EV_ONESHOT: ::kernel::sys::raw::c_uint = 16;
pub const EV_CLEAR: ::kernel::sys::raw::c_uint = 32;
pub const EV_RECEIPT: ::kernel::sys::raw::c_uint = 64;
pub const EV_DISPATCH: ::kernel::sys::raw::c_uint = 128;
pub const EV_SYSFLAGS: ::kernel::sys::raw::c_uint = 61440;
pub const EV_DROP: ::kernel::sys::raw::c_uint = 4096;
pub const EV_FLAG1: ::kernel::sys::raw::c_uint = 8192;
pub const EV_FLAG2: ::kernel::sys::raw::c_uint = 16384;
pub const EV_EOF: ::kernel::sys::raw::c_uint = 32768;
pub const EV_ERROR: ::kernel::sys::raw::c_uint = 16384;
pub const NOTE_FFNOP: ::kernel::sys::raw::c_uint = 0;
pub const NOTE_FFAND: ::kernel::sys::raw::c_uint = 1073741824;
pub const NOTE_FFOR: ::kernel::sys::raw::c_uint = 2147483648;
pub const NOTE_FFCOPY: ::kernel::sys::raw::c_uint = 3221225472;
pub const NOTE_FFCTRLMASK: ::kernel::sys::raw::c_uint = 3221225472;
pub const NOTE_FFLAGSMASK: ::kernel::sys::raw::c_uint = 16777215;
pub const NOTE_TRIGGER: ::kernel::sys::raw::c_uint = 16777216;
pub const NOTE_LOWAT: ::kernel::sys::raw::c_uint = 1;
pub const NOTE_FILE_POLL: ::kernel::sys::raw::c_uint = 2;
pub const NOTE_DELETE: ::kernel::sys::raw::c_uint = 1;
pub const NOTE_WRITE: ::kernel::sys::raw::c_uint = 2;
pub const NOTE_EXTEND: ::kernel::sys::raw::c_uint = 4;
pub const NOTE_ATTRIB: ::kernel::sys::raw::c_uint = 8;
pub const NOTE_LINK: ::kernel::sys::raw::c_uint = 16;
pub const NOTE_RENAME: ::kernel::sys::raw::c_uint = 32;
pub const NOTE_REVOKE: ::kernel::sys::raw::c_uint = 64;
pub const NOTE_OPEN: ::kernel::sys::raw::c_uint = 128;
pub const NOTE_CLOSE: ::kernel::sys::raw::c_uint = 256;
pub const NOTE_CLOSE_WRITE: ::kernel::sys::raw::c_uint = 512;
pub const NOTE_READ: ::kernel::sys::raw::c_uint = 1024;
pub const NOTE_EXIT: ::kernel::sys::raw::c_uint = 2147483648;
pub const NOTE_FORK: ::kernel::sys::raw::c_uint = 1073741824;
pub const NOTE_EXEC: ::kernel::sys::raw::c_uint = 536870912;
pub const NOTE_PCTRLMASK: ::kernel::sys::raw::c_uint = 4026531840;
pub const NOTE_PDATAMASK: ::kernel::sys::raw::c_uint = 1048575;
pub const NOTE_TRACK: ::kernel::sys::raw::c_uint = 1;
pub const NOTE_TRACKERR: ::kernel::sys::raw::c_uint = 2;
pub const NOTE_CHILD: ::kernel::sys::raw::c_uint = 4;
pub const NOTE_SECONDS: ::kernel::sys::raw::c_uint = 1;
pub const NOTE_MSECONDS: ::kernel::sys::raw::c_uint = 2;
pub const NOTE_USECONDS: ::kernel::sys::raw::c_uint = 4;
pub const NOTE_NSECONDS: ::kernel::sys::raw::c_uint = 8;
pub const NOTE_ABSTIME: ::kernel::sys::raw::c_uint = 16;
pub const KNF_LISTLOCKED: ::kernel::sys::raw::c_uint = 1;
pub const KNF_NOKQLOCK: ::kernel::sys::raw::c_uint = 2;
pub const NOTE_SIGNAL: ::kernel::sys::raw::c_uint = 134217728;
pub const EVENT_REGISTER: ::kernel::sys::raw::c_uint = 1;
pub const EVENT_PROCESS: ::kernel::sys::raw::c_uint = 2;
pub const KN_ACTIVE: ::kernel::sys::raw::c_uint = 1;
pub const KN_QUEUED: ::kernel::sys::raw::c_uint = 2;
pub const KN_DISABLED: ::kernel::sys::raw::c_uint = 4;
pub const KN_DETACHED: ::kernel::sys::raw::c_uint = 8;
pub const KN_MARKER: ::kernel::sys::raw::c_uint = 32;
pub const KN_KQUEUE: ::kernel::sys::raw::c_uint = 64;
pub const KN_HASKQLOCK: ::kernel::sys::raw::c_uint = 128;
pub const KN_SCAN: ::kernel::sys::raw::c_uint = 256;
pub const OSD_THREAD: ::kernel::sys::raw::c_uint = 0;
pub const OSD_JAIL: ::kernel::sys::raw::c_uint = 1;
pub const OSD_KHELP: ::kernel::sys::raw::c_uint = 2;
pub const OSD_FIRST: ::kernel::sys::raw::c_uint = 0;
pub const OSD_LAST: ::kernel::sys::raw::c_uint = 2;
pub const RTP_PRIO_REALTIME: ::kernel::sys::raw::c_uint = 2;
pub const RTP_PRIO_NORMAL: ::kernel::sys::raw::c_uint = 3;
pub const RTP_PRIO_IDLE: ::kernel::sys::raw::c_uint = 4;
pub const RTP_PRIO_FIFO_BIT: ::kernel::sys::raw::c_uint = 8;
pub const RTP_PRIO_FIFO: ::kernel::sys::raw::c_uint = 10;
pub const RTP_PRIO_MIN: ::kernel::sys::raw::c_uint = 0;
pub const RTP_PRIO_MAX: ::kernel::sys::raw::c_uint = 31;
pub const RTP_LOOKUP: ::kernel::sys::raw::c_uint = 0;
pub const RTP_SET: ::kernel::sys::raw::c_uint = 1;
pub const RQB_LEN: ::kernel::sys::raw::c_uint = 1;
pub const RQB_L2BPW: ::kernel::sys::raw::c_uint = 6;
pub const RQB_BPW: ::kernel::sys::raw::c_uint = 64;
pub const RQ_NQS: ::kernel::sys::raw::c_uint = 64;
pub const RQ_PPQ: ::kernel::sys::raw::c_uint = 4;
pub const _X86_SIGNAL_H: ::kernel::sys::raw::c_uint = 1;
pub const SIGHUP: ::kernel::sys::raw::c_uint = 1;
pub const SIGINT: ::kernel::sys::raw::c_uint = 2;
pub const SIGQUIT: ::kernel::sys::raw::c_uint = 3;
pub const SIGILL: ::kernel::sys::raw::c_uint = 4;
pub const SIGTRAP: ::kernel::sys::raw::c_uint = 5;
pub const SIGABRT: ::kernel::sys::raw::c_uint = 6;
pub const SIGIOT: ::kernel::sys::raw::c_uint = 6;
pub const SIGEMT: ::kernel::sys::raw::c_uint = 7;
pub const SIGFPE: ::kernel::sys::raw::c_uint = 8;
pub const SIGKILL: ::kernel::sys::raw::c_uint = 9;
pub const SIGBUS: ::kernel::sys::raw::c_uint = 10;
pub const SIGSEGV: ::kernel::sys::raw::c_uint = 11;
pub const SIGSYS: ::kernel::sys::raw::c_uint = 12;
pub const SIGPIPE: ::kernel::sys::raw::c_uint = 13;
pub const SIGALRM: ::kernel::sys::raw::c_uint = 14;
pub const SIGTERM: ::kernel::sys::raw::c_uint = 15;
pub const SIGURG: ::kernel::sys::raw::c_uint = 16;
pub const SIGSTOP: ::kernel::sys::raw::c_uint = 17;
pub const SIGTSTP: ::kernel::sys::raw::c_uint = 18;
pub const SIGCONT: ::kernel::sys::raw::c_uint = 19;
pub const SIGCHLD: ::kernel::sys::raw::c_uint = 20;
pub const SIGTTIN: ::kernel::sys::raw::c_uint = 21;
pub const SIGTTOU: ::kernel::sys::raw::c_uint = 22;
pub const SIGIO: ::kernel::sys::raw::c_uint = 23;
pub const SIGXCPU: ::kernel::sys::raw::c_uint = 24;
pub const SIGXFSZ: ::kernel::sys::raw::c_uint = 25;
pub const SIGVTALRM: ::kernel::sys::raw::c_uint = 26;
pub const SIGPROF: ::kernel::sys::raw::c_uint = 27;
pub const SIGWINCH: ::kernel::sys::raw::c_uint = 28;
pub const SIGINFO: ::kernel::sys::raw::c_uint = 29;
pub const SIGUSR1: ::kernel::sys::raw::c_uint = 30;
pub const SIGUSR2: ::kernel::sys::raw::c_uint = 31;
pub const SIGTHR: ::kernel::sys::raw::c_uint = 32;
pub const SIGLWP: ::kernel::sys::raw::c_uint = 32;
pub const SIGLIBRT: ::kernel::sys::raw::c_uint = 33;
pub const SIGRTMIN: ::kernel::sys::raw::c_uint = 65;
pub const SIGRTMAX: ::kernel::sys::raw::c_uint = 126;
pub const SIGEV_NONE: ::kernel::sys::raw::c_uint = 0;
pub const SIGEV_SIGNAL: ::kernel::sys::raw::c_uint = 1;
pub const SIGEV_THREAD: ::kernel::sys::raw::c_uint = 2;
pub const SIGEV_KEVENT: ::kernel::sys::raw::c_uint = 3;
pub const SIGEV_THREAD_ID: ::kernel::sys::raw::c_uint = 4;
pub const ILL_ILLOPC: ::kernel::sys::raw::c_uint = 1;
pub const ILL_ILLOPN: ::kernel::sys::raw::c_uint = 2;
pub const ILL_ILLADR: ::kernel::sys::raw::c_uint = 3;
pub const ILL_ILLTRP: ::kernel::sys::raw::c_uint = 4;
pub const ILL_PRVOPC: ::kernel::sys::raw::c_uint = 5;
pub const ILL_PRVREG: ::kernel::sys::raw::c_uint = 6;
pub const ILL_COPROC: ::kernel::sys::raw::c_uint = 7;
pub const ILL_BADSTK: ::kernel::sys::raw::c_uint = 8;
pub const BUS_ADRALN: ::kernel::sys::raw::c_uint = 1;
pub const BUS_ADRERR: ::kernel::sys::raw::c_uint = 2;
pub const BUS_OBJERR: ::kernel::sys::raw::c_uint = 3;
pub const SEGV_MAPERR: ::kernel::sys::raw::c_uint = 1;
pub const SEGV_ACCERR: ::kernel::sys::raw::c_uint = 2;
pub const FPE_INTOVF: ::kernel::sys::raw::c_uint = 1;
pub const FPE_INTDIV: ::kernel::sys::raw::c_uint = 2;
pub const FPE_FLTDIV: ::kernel::sys::raw::c_uint = 3;
pub const FPE_FLTOVF: ::kernel::sys::raw::c_uint = 4;
pub const FPE_FLTUND: ::kernel::sys::raw::c_uint = 5;
pub const FPE_FLTRES: ::kernel::sys::raw::c_uint = 6;
pub const FPE_FLTINV: ::kernel::sys::raw::c_uint = 7;
pub const FPE_FLTSUB: ::kernel::sys::raw::c_uint = 8;
pub const TRAP_BRKPT: ::kernel::sys::raw::c_uint = 1;
pub const TRAP_TRACE: ::kernel::sys::raw::c_uint = 2;
pub const TRAP_DTRACE: ::kernel::sys::raw::c_uint = 3;
pub const TRAP_CAP: ::kernel::sys::raw::c_uint = 4;
pub const CLD_EXITED: ::kernel::sys::raw::c_uint = 1;
pub const CLD_KILLED: ::kernel::sys::raw::c_uint = 2;
pub const CLD_DUMPED: ::kernel::sys::raw::c_uint = 3;
pub const CLD_TRAPPED: ::kernel::sys::raw::c_uint = 4;
pub const CLD_STOPPED: ::kernel::sys::raw::c_uint = 5;
pub const CLD_CONTINUED: ::kernel::sys::raw::c_uint = 6;
pub const POLL_IN: ::kernel::sys::raw::c_uint = 1;
pub const POLL_OUT: ::kernel::sys::raw::c_uint = 2;
pub const POLL_MSG: ::kernel::sys::raw::c_uint = 3;
pub const POLL_ERR: ::kernel::sys::raw::c_uint = 4;
pub const POLL_PRI: ::kernel::sys::raw::c_uint = 5;
pub const POLL_HUP: ::kernel::sys::raw::c_uint = 6;
pub const SA_NOCLDSTOP: ::kernel::sys::raw::c_uint = 8;
pub const SA_ONSTACK: ::kernel::sys::raw::c_uint = 1;
pub const SA_RESTART: ::kernel::sys::raw::c_uint = 2;
pub const SA_RESETHAND: ::kernel::sys::raw::c_uint = 4;
pub const SA_NODEFER: ::kernel::sys::raw::c_uint = 16;
pub const SA_NOCLDWAIT: ::kernel::sys::raw::c_uint = 32;
pub const SA_SIGINFO: ::kernel::sys::raw::c_uint = 64;
pub const NSIG: ::kernel::sys::raw::c_uint = 32;
pub const SI_NOINFO: ::kernel::sys::raw::c_uint = 0;
pub const SI_USER: ::kernel::sys::raw::c_uint = 65537;
pub const SI_QUEUE: ::kernel::sys::raw::c_uint = 65538;
pub const SI_TIMER: ::kernel::sys::raw::c_uint = 65539;
pub const SI_ASYNCIO: ::kernel::sys::raw::c_uint = 65540;
pub const SI_MESGQ: ::kernel::sys::raw::c_uint = 65541;
pub const SI_KERNEL: ::kernel::sys::raw::c_uint = 65542;
pub const SI_LWP: ::kernel::sys::raw::c_uint = 65543;
pub const SI_UNDEFINED: ::kernel::sys::raw::c_uint = 0;
pub const SS_ONSTACK: ::kernel::sys::raw::c_uint = 1;
pub const SS_DISABLE: ::kernel::sys::raw::c_uint = 4;
pub const MINSIGSTKSZ: ::kernel::sys::raw::c_uint = 2048;
pub const SIGSTKSZ: ::kernel::sys::raw::c_uint = 34816;
pub const SV_ONSTACK: ::kernel::sys::raw::c_uint = 1;
pub const SV_INTERRUPT: ::kernel::sys::raw::c_uint = 2;
pub const SV_RESETHAND: ::kernel::sys::raw::c_uint = 4;
pub const SV_NODEFER: ::kernel::sys::raw::c_uint = 16;
pub const SV_NOCLDSTOP: ::kernel::sys::raw::c_uint = 8;
pub const SV_SIGINFO: ::kernel::sys::raw::c_uint = 64;
pub const SIG_BLOCK: ::kernel::sys::raw::c_uint = 1;
pub const SIG_UNBLOCK: ::kernel::sys::raw::c_uint = 2;
pub const SIG_SETMASK: ::kernel::sys::raw::c_uint = 3;
pub const PS_NOCLDWAIT: ::kernel::sys::raw::c_uint = 1;
pub const PS_NOCLDSTOP: ::kernel::sys::raw::c_uint = 2;
pub const PS_CLDSIGIGN: ::kernel::sys::raw::c_uint = 4;
pub const KSI_TRAP: ::kernel::sys::raw::c_uint = 1;
pub const KSI_EXT: ::kernel::sys::raw::c_uint = 2;
pub const KSI_INS: ::kernel::sys::raw::c_uint = 4;
pub const KSI_SIGQ: ::kernel::sys::raw::c_uint = 8;
pub const KSI_HEAD: ::kernel::sys::raw::c_uint = 16;
pub const KSI_PTRACE: ::kernel::sys::raw::c_uint = 32;
pub const KSI_COPYMASK: ::kernel::sys::raw::c_uint = 41;
pub const SQ_INIT: ::kernel::sys::raw::c_uint = 1;
pub const SIGPROCMASK_OLD: ::kernel::sys::raw::c_uint = 1;
pub const SIGPROCMASK_PROC_LOCKED: ::kernel::sys::raw::c_uint = 2;
pub const SIGPROCMASK_PS_LOCKED: ::kernel::sys::raw::c_uint = 4;
pub const SIGDEFERSTOP_NOP: ::kernel::sys::raw::c_uint = 0;
pub const SIGDEFERSTOP_OFF: ::kernel::sys::raw::c_uint = 1;
pub const SIGDEFERSTOP_SILENT: ::kernel::sys::raw::c_uint = 2;
pub const SIGDEFERSTOP_EINTR: ::kernel::sys::raw::c_uint = 3;
pub const SIGDEFERSTOP_ERESTART: ::kernel::sys::raw::c_uint = 4;
pub const SIGDEFERSTOP_VAL_NCHG: ::kernel::sys::raw::c_int = -1;
pub const _MC_HASSEGS: ::kernel::sys::raw::c_uint = 1;
pub const _MC_HASBASES: ::kernel::sys::raw::c_uint = 2;
pub const _MC_HASFPXSTATE: ::kernel::sys::raw::c_uint = 4;
pub const _MC_FLAG_MASK: ::kernel::sys::raw::c_uint = 7;
pub const _MC_FPFMT_NODEV: ::kernel::sys::raw::c_uint = 65536;
pub const _MC_FPFMT_XMM: ::kernel::sys::raw::c_uint = 65538;
pub const _MC_FPOWNED_NONE: ::kernel::sys::raw::c_uint = 131072;
pub const _MC_FPOWNED_FPU: ::kernel::sys::raw::c_uint = 131073;
pub const _MC_FPOWNED_PCB: ::kernel::sys::raw::c_uint = 131074;
pub const UCF_SWAPPED: ::kernel::sys::raw::c_uint = 1;
pub const GET_MC_CLEAR_RET: ::kernel::sys::raw::c_uint = 1;
pub const AUDIT_RECORD_MAGIC: ::kernel::sys::raw::c_uint = 2190085915;
pub const MAX_AUDIT_RECORDS: ::kernel::sys::raw::c_uint = 20;
pub const MAXAUDITDATA: ::kernel::sys::raw::c_uint = 32767;
pub const MAX_AUDIT_RECORD_SIZE: ::kernel::sys::raw::c_uint = 32767;
pub const MIN_AUDIT_FILE_SIZE: ::kernel::sys::raw::c_uint = 524288;
pub const AUDIT_HARD_LIMIT_FREE_BLOCKS: ::kernel::sys::raw::c_uint = 4;
pub const AUDIT_TRIGGER_MIN: ::kernel::sys::raw::c_uint = 1;
pub const AUDIT_TRIGGER_LOW_SPACE: ::kernel::sys::raw::c_uint = 1;
pub const AUDIT_TRIGGER_ROTATE_KERNEL: ::kernel::sys::raw::c_uint = 2;
pub const AUDIT_TRIGGER_READ_FILE: ::kernel::sys::raw::c_uint = 3;
pub const AUDIT_TRIGGER_CLOSE_AND_DIE: ::kernel::sys::raw::c_uint = 4;
pub const AUDIT_TRIGGER_NO_SPACE: ::kernel::sys::raw::c_uint = 5;
pub const AUDIT_TRIGGER_ROTATE_USER: ::kernel::sys::raw::c_uint = 6;
pub const AUDIT_TRIGGER_INITIALIZE: ::kernel::sys::raw::c_uint = 7;
pub const AUDIT_TRIGGER_EXPIRE_TRAILS: ::kernel::sys::raw::c_uint = 8;
pub const AUDIT_TRIGGER_MAX: ::kernel::sys::raw::c_uint = 8;
pub const AUDITDEV_FILENAME: &'static [u8; 6usize] = b"audit\x00";
pub const AUDIT_TRIGGER_FILE: &'static [u8; 11usize] = b"/dev/audit\x00";
pub const AU_DEFAUDITSID: ::kernel::sys::raw::c_uint = 0;
pub const AU_ASSIGN_ASID: ::kernel::sys::raw::c_int = -1;
pub const AUC_UNSET: ::kernel::sys::raw::c_uint = 0;
pub const AUC_AUDITING: ::kernel::sys::raw::c_uint = 1;
pub const AUC_NOAUDIT: ::kernel::sys::raw::c_uint = 2;
pub const AUC_DISABLED: ::kernel::sys::raw::c_int = -1;
pub const A_OLDGETPOLICY: ::kernel::sys::raw::c_uint = 2;
pub const A_OLDSETPOLICY: ::kernel::sys::raw::c_uint = 3;
pub const A_GETKMASK: ::kernel::sys::raw::c_uint = 4;
pub const A_SETKMASK: ::kernel::sys::raw::c_uint = 5;
pub const A_OLDGETQCTRL: ::kernel::sys::raw::c_uint = 6;
pub const A_OLDSETQCTRL: ::kernel::sys::raw::c_uint = 7;
pub const A_GETCWD: ::kernel::sys::raw::c_uint = 8;
pub const A_GETCAR: ::kernel::sys::raw::c_uint = 9;
pub const A_GETSTAT: ::kernel::sys::raw::c_uint = 12;
pub const A_SETSTAT: ::kernel::sys::raw::c_uint = 13;
pub const A_SETUMASK: ::kernel::sys::raw::c_uint = 14;
pub const A_SETSMASK: ::kernel::sys::raw::c_uint = 15;
pub const A_OLDGETCOND: ::kernel::sys::raw::c_uint = 20;
pub const A_OLDSETCOND: ::kernel::sys::raw::c_uint = 21;
pub const A_GETCLASS: ::kernel::sys::raw::c_uint = 22;
pub const A_SETCLASS: ::kernel::sys::raw::c_uint = 23;
pub const A_GETPINFO: ::kernel::sys::raw::c_uint = 24;
pub const A_SETPMASK: ::kernel::sys::raw::c_uint = 25;
pub const A_SETFSIZE: ::kernel::sys::raw::c_uint = 26;
pub const A_GETFSIZE: ::kernel::sys::raw::c_uint = 27;
pub const A_GETPINFO_ADDR: ::kernel::sys::raw::c_uint = 28;
pub const A_GETKAUDIT: ::kernel::sys::raw::c_uint = 29;
pub const A_SETKAUDIT: ::kernel::sys::raw::c_uint = 30;
pub const A_SENDTRIGGER: ::kernel::sys::raw::c_uint = 31;
pub const A_GETSINFO_ADDR: ::kernel::sys::raw::c_uint = 32;
pub const A_GETPOLICY: ::kernel::sys::raw::c_uint = 33;
pub const A_SETPOLICY: ::kernel::sys::raw::c_uint = 34;
pub const A_GETQCTRL: ::kernel::sys::raw::c_uint = 35;
pub const A_SETQCTRL: ::kernel::sys::raw::c_uint = 36;
pub const A_GETCOND: ::kernel::sys::raw::c_uint = 37;
pub const A_SETCOND: ::kernel::sys::raw::c_uint = 38;
pub const A_GETEVENT: ::kernel::sys::raw::c_uint = 39;
pub const A_SETEVENT: ::kernel::sys::raw::c_uint = 40;
pub const AUDIT_CNT: ::kernel::sys::raw::c_uint = 1;
pub const AUDIT_AHLT: ::kernel::sys::raw::c_uint = 2;
pub const AUDIT_ARGV: ::kernel::sys::raw::c_uint = 4;
pub const AUDIT_ARGE: ::kernel::sys::raw::c_uint = 8;
pub const AUDIT_SEQ: ::kernel::sys::raw::c_uint = 16;
pub const AUDIT_WINDATA: ::kernel::sys::raw::c_uint = 32;
pub const AUDIT_USER: ::kernel::sys::raw::c_uint = 64;
pub const AUDIT_GROUP: ::kernel::sys::raw::c_uint = 128;
pub const AUDIT_TRAIL: ::kernel::sys::raw::c_uint = 256;
pub const AUDIT_PATH: ::kernel::sys::raw::c_uint = 512;
pub const AUDIT_SCNT: ::kernel::sys::raw::c_uint = 1024;
pub const AUDIT_PUBLIC: ::kernel::sys::raw::c_uint = 2048;
pub const AUDIT_ZONENAME: ::kernel::sys::raw::c_uint = 4096;
pub const AUDIT_PERZONE: ::kernel::sys::raw::c_uint = 8192;
pub const AQ_HIWATER: ::kernel::sys::raw::c_uint = 100;
pub const AQ_MAXHIGH: ::kernel::sys::raw::c_uint = 10000;
pub const AQ_LOWATER: ::kernel::sys::raw::c_uint = 10;
pub const AQ_BUFSZ: ::kernel::sys::raw::c_uint = 32767;
pub const AQ_MAXBUFSZ: ::kernel::sys::raw::c_uint = 1048576;
pub const AU_FS_MINFREE: ::kernel::sys::raw::c_uint = 20;
pub const AU_IPv4: ::kernel::sys::raw::c_uint = 4;
pub const AU_IPv6: ::kernel::sys::raw::c_uint = 16;
pub const EVNAMEMAP_NAME_SIZE: ::kernel::sys::raw::c_uint = 64;
pub const XU_NGROUPS: ::kernel::sys::raw::c_uint = 16;
pub const CRED_FLAG_CAPMODE: ::kernel::sys::raw::c_uint = 1;
pub const XUCRED_VERSION: ::kernel::sys::raw::c_uint = 0;
pub const DOMAINSET_SETSIZE: ::kernel::sys::raw::c_uint = 8;
pub const DOMAINSET_MAXSIZE: ::kernel::sys::raw::c_uint = 256;
pub const KINFO_PROC_SIZE: ::kernel::sys::raw::c_uint = 1088;
pub const KINFO_PROC32_SIZE: ::kernel::sys::raw::c_uint = 768;
pub const TDF_BORROWING: ::kernel::sys::raw::c_uint = 1;
pub const TDF_INPANIC: ::kernel::sys::raw::c_uint = 2;
pub const TDF_INMEM: ::kernel::sys::raw::c_uint = 4;
pub const TDF_SINTR: ::kernel::sys::raw::c_uint = 8;
pub const TDF_TIMEOUT: ::kernel::sys::raw::c_uint = 16;
pub const TDF_IDLETD: ::kernel::sys::raw::c_uint = 32;
pub const TDF_CANSWAP: ::kernel::sys::raw::c_uint = 64;
pub const TDF_SLEEPABORT: ::kernel::sys::raw::c_uint = 128;
pub const TDF_KTH_SUSP: ::kernel::sys::raw::c_uint = 256;
pub const TDF_ALLPROCSUSP: ::kernel::sys::raw::c_uint = 512;
pub const TDF_BOUNDARY: ::kernel::sys::raw::c_uint = 1024;
pub const TDF_ASTPENDING: ::kernel::sys::raw::c_uint = 2048;
pub const TDF_UNUSED12: ::kernel::sys::raw::c_uint = 4096;
pub const TDF_SBDRY: ::kernel::sys::raw::c_uint = 8192;
pub const TDF_UPIBLOCKED: ::kernel::sys::raw::c_uint = 16384;
pub const TDF_NEEDSUSPCHK: ::kernel::sys::raw::c_uint = 32768;
pub const TDF_NEEDRESCHED: ::kernel::sys::raw::c_uint = 65536;
pub const TDF_NEEDSIGCHK: ::kernel::sys::raw::c_uint = 131072;
pub const TDF_NOLOAD: ::kernel::sys::raw::c_uint = 262144;
pub const TDF_SERESTART: ::kernel::sys::raw::c_uint = 524288;
pub const TDF_THRWAKEUP: ::kernel::sys::raw::c_uint = 1048576;
pub const TDF_SEINTR: ::kernel::sys::raw::c_uint = 2097152;
pub const TDF_SWAPINREQ: ::kernel::sys::raw::c_uint = 4194304;
pub const TDF_UNUSED23: ::kernel::sys::raw::c_uint = 8388608;
pub const TDF_SCHED0: ::kernel::sys::raw::c_uint = 16777216;
pub const TDF_SCHED1: ::kernel::sys::raw::c_uint = 33554432;
pub const TDF_SCHED2: ::kernel::sys::raw::c_uint = 67108864;
pub const TDF_SCHED3: ::kernel::sys::raw::c_uint = 134217728;
pub const TDF_ALRMPEND: ::kernel::sys::raw::c_uint = 268435456;
pub const TDF_PROFPEND: ::kernel::sys::raw::c_uint = 536870912;
pub const TDF_MACPEND: ::kernel::sys::raw::c_uint = 1073741824;
pub const TDB_SUSPEND: ::kernel::sys::raw::c_uint = 1;
pub const TDB_XSIG: ::kernel::sys::raw::c_uint = 2;
pub const TDB_USERWR: ::kernel::sys::raw::c_uint = 4;
pub const TDB_SCE: ::kernel::sys::raw::c_uint = 8;
pub const TDB_SCX: ::kernel::sys::raw::c_uint = 16;
pub const TDB_EXEC: ::kernel::sys::raw::c_uint = 32;
pub const TDB_FORK: ::kernel::sys::raw::c_uint = 64;
pub const TDB_STOPATFORK: ::kernel::sys::raw::c_uint = 128;
pub const TDB_CHILD: ::kernel::sys::raw::c_uint = 256;
pub const TDB_BORN: ::kernel::sys::raw::c_uint = 512;
pub const TDB_EXIT: ::kernel::sys::raw::c_uint = 1024;
pub const TDB_VFORK: ::kernel::sys::raw::c_uint = 2048;
pub const TDB_FSTP: ::kernel::sys::raw::c_uint = 4096;
pub const TDB_STEP: ::kernel::sys::raw::c_uint = 8192;
pub const TDP_OLDMASK: ::kernel::sys::raw::c_uint = 1;
pub const TDP_INKTR: ::kernel::sys::raw::c_uint = 2;
pub const TDP_INKTRACE: ::kernel::sys::raw::c_uint = 4;
pub const TDP_BUFNEED: ::kernel::sys::raw::c_uint = 8;
pub const TDP_COWINPROGRESS: ::kernel::sys::raw::c_uint = 16;
pub const TDP_ALTSTACK: ::kernel::sys::raw::c_uint = 32;
pub const TDP_DEADLKTREAT: ::kernel::sys::raw::c_uint = 64;
pub const TDP_NOFAULTING: ::kernel::sys::raw::c_uint = 128;
pub const TDP_UNUSED9: ::kernel::sys::raw::c_uint = 256;
pub const TDP_OWEUPC: ::kernel::sys::raw::c_uint = 512;
pub const TDP_ITHREAD: ::kernel::sys::raw::c_uint = 1024;
pub const TDP_SYNCIO: ::kernel::sys::raw::c_uint = 2048;
pub const TDP_SCHED1: ::kernel::sys::raw::c_uint = 4096;
pub const TDP_SCHED2: ::kernel::sys::raw::c_uint = 8192;
pub const TDP_SCHED3: ::kernel::sys::raw::c_uint = 16384;
pub const TDP_SCHED4: ::kernel::sys::raw::c_uint = 32768;
pub const TDP_GEOM: ::kernel::sys::raw::c_uint = 65536;
pub const TDP_SOFTDEP: ::kernel::sys::raw::c_uint = 131072;
pub const TDP_NORUNNINGBUF: ::kernel::sys::raw::c_uint = 262144;
pub const TDP_WAKEUP: ::kernel::sys::raw::c_uint = 524288;
pub const TDP_INBDFLUSH: ::kernel::sys::raw::c_uint = 1048576;
pub const TDP_KTHREAD: ::kernel::sys::raw::c_uint = 2097152;
pub const TDP_CALLCHAIN: ::kernel::sys::raw::c_uint = 4194304;
pub const TDP_IGNSUSP: ::kernel::sys::raw::c_uint = 8388608;
pub const TDP_AUDITREC: ::kernel::sys::raw::c_uint = 16777216;
pub const TDP_RFPPWAIT: ::kernel::sys::raw::c_uint = 33554432;
pub const TDP_RESETSPUR: ::kernel::sys::raw::c_uint = 67108864;
pub const TDP_NERRNO: ::kernel::sys::raw::c_uint = 134217728;
pub const TDP_UIOHELD: ::kernel::sys::raw::c_uint = 268435456;
pub const TDP_FORKING: ::kernel::sys::raw::c_uint = 536870912;
pub const TDP_EXECVMSPC: ::kernel::sys::raw::c_uint = 1073741824;
pub const TDI_SUSPENDED: ::kernel::sys::raw::c_uint = 1;
pub const TDI_SLEEPING: ::kernel::sys::raw::c_uint = 2;
pub const TDI_SWAPPED: ::kernel::sys::raw::c_uint = 4;
pub const TDI_LOCK: ::kernel::sys::raw::c_uint = 8;
pub const TDI_IWAIT: ::kernel::sys::raw::c_uint = 16;
pub const NOCPU: ::kernel::sys::raw::c_int = -1;
pub const NOCPU_OLD: ::kernel::sys::raw::c_uint = 255;
pub const MAXCPU_OLD: ::kernel::sys::raw::c_uint = 254;
pub const P_ADVLOCK: ::kernel::sys::raw::c_uint = 1;
pub const P_CONTROLT: ::kernel::sys::raw::c_uint = 2;
pub const P_KPROC: ::kernel::sys::raw::c_uint = 4;
pub const P_UNUSED3: ::kernel::sys::raw::c_uint = 8;
pub const P_PPWAIT: ::kernel::sys::raw::c_uint = 16;
pub const P_PROFIL: ::kernel::sys::raw::c_uint = 32;
pub const P_STOPPROF: ::kernel::sys::raw::c_uint = 64;
pub const P_HADTHREADS: ::kernel::sys::raw::c_uint = 128;
pub const P_SUGID: ::kernel::sys::raw::c_uint = 256;
pub const P_SYSTEM: ::kernel::sys::raw::c_uint = 512;
pub const P_SINGLE_EXIT: ::kernel::sys::raw::c_uint = 1024;
pub const P_TRACED: ::kernel::sys::raw::c_uint = 2048;
pub const P_WAITED: ::kernel::sys::raw::c_uint = 4096;
pub const P_WEXIT: ::kernel::sys::raw::c_uint = 8192;
pub const P_EXEC: ::kernel::sys::raw::c_uint = 16384;
pub const P_WKILLED: ::kernel::sys::raw::c_uint = 32768;
pub const P_CONTINUED: ::kernel::sys::raw::c_uint = 65536;
pub const P_STOPPED_SIG: ::kernel::sys::raw::c_uint = 131072;
pub const P_STOPPED_TRACE: ::kernel::sys::raw::c_uint = 262144;
pub const P_STOPPED_SINGLE: ::kernel::sys::raw::c_uint = 524288;
pub const P_PROTECTED: ::kernel::sys::raw::c_uint = 1048576;
pub const P_SIGEVENT: ::kernel::sys::raw::c_uint = 2097152;
pub const P_SINGLE_BOUNDARY: ::kernel::sys::raw::c_uint = 4194304;
pub const P_HWPMC: ::kernel::sys::raw::c_uint = 8388608;
pub const P_JAILED: ::kernel::sys::raw::c_uint = 16777216;
pub const P_TOTAL_STOP: ::kernel::sys::raw::c_uint = 33554432;
pub const P_INEXEC: ::kernel::sys::raw::c_uint = 67108864;
pub const P_STATCHILD: ::kernel::sys::raw::c_uint = 134217728;
pub const P_INMEM: ::kernel::sys::raw::c_uint = 268435456;
pub const P_SWAPPINGOUT: ::kernel::sys::raw::c_uint = 536870912;
pub const P_SWAPPINGIN: ::kernel::sys::raw::c_uint = 1073741824;
pub const P_PPTRACE: ::kernel::sys::raw::c_uint = 2147483648;
pub const P_STOPPED: ::kernel::sys::raw::c_uint = 917504;
pub const P2_INHERIT_PROTECTED: ::kernel::sys::raw::c_uint = 1;
pub const P2_NOTRACE: ::kernel::sys::raw::c_uint = 2;
pub const P2_NOTRACE_EXEC: ::kernel::sys::raw::c_uint = 4;
pub const P2_AST_SU: ::kernel::sys::raw::c_uint = 8;
pub const P2_PTRACE_FSTP: ::kernel::sys::raw::c_uint = 16;
pub const P2_TRAPCAP: ::kernel::sys::raw::c_uint = 32;
pub const P_TREE_ORPHANED: ::kernel::sys::raw::c_uint = 1;
pub const P_TREE_FIRST_ORPHAN: ::kernel::sys::raw::c_uint = 2;
pub const P_TREE_REAPER: ::kernel::sys::raw::c_uint = 4;
pub const SIDL: ::kernel::sys::raw::c_uint = 1;
pub const SRUN: ::kernel::sys::raw::c_uint = 2;
pub const SSLEEP: ::kernel::sys::raw::c_uint = 3;
pub const SSTOP: ::kernel::sys::raw::c_uint = 4;
pub const SZOMB: ::kernel::sys::raw::c_uint = 5;
pub const SWAIT: ::kernel::sys::raw::c_uint = 6;
pub const SLOCK: ::kernel::sys::raw::c_uint = 7;
pub const P_MAGIC: ::kernel::sys::raw::c_uint = 3203398350;
pub const SW_TYPE_MASK: ::kernel::sys::raw::c_uint = 255;
pub const SWT_NONE: ::kernel::sys::raw::c_uint = 0;
pub const SWT_PREEMPT: ::kernel::sys::raw::c_uint = 1;
pub const SWT_OWEPREEMPT: ::kernel::sys::raw::c_uint = 2;
pub const SWT_TURNSTILE: ::kernel::sys::raw::c_uint = 3;
pub const SWT_SLEEPQ: ::kernel::sys::raw::c_uint = 4;
pub const SWT_SLEEPQTIMO: ::kernel::sys::raw::c_uint = 5;
pub const SWT_RELINQUISH: ::kernel::sys::raw::c_uint = 6;
pub const SWT_NEEDRESCHED: ::kernel::sys::raw::c_uint = 7;
pub const SWT_IDLE: ::kernel::sys::raw::c_uint = 8;
pub const SWT_IWAIT: ::kernel::sys::raw::c_uint = 9;
pub const SWT_SUSPEND: ::kernel::sys::raw::c_uint = 10;
pub const SWT_REMOTEPREEMPT: ::kernel::sys::raw::c_uint = 11;
pub const SWT_REMOTEWAKEIDLE: ::kernel::sys::raw::c_uint = 12;
pub const SWT_COUNT: ::kernel::sys::raw::c_uint = 13;
pub const SW_VOL: ::kernel::sys::raw::c_uint = 256;
pub const SW_INVOL: ::kernel::sys::raw::c_uint = 512;
pub const SW_PREEMPT: ::kernel::sys::raw::c_uint = 1024;
pub const SINGLE_NO_EXIT: ::kernel::sys::raw::c_uint = 0;
pub const SINGLE_EXIT: ::kernel::sys::raw::c_uint = 1;
pub const SINGLE_BOUNDARY: ::kernel::sys::raw::c_uint = 2;
pub const SINGLE_ALLPROC: ::kernel::sys::raw::c_uint = 3;
pub const PID_MAX: ::kernel::sys::raw::c_uint = 99999;
pub const NO_PID: ::kernel::sys::raw::c_uint = 100000;
pub const PGET_HOLD: ::kernel::sys::raw::c_uint = 1;
pub const PGET_CANSEE: ::kernel::sys::raw::c_uint = 2;
pub const PGET_CANDEBUG: ::kernel::sys::raw::c_uint = 4;
pub const PGET_ISCURRENT: ::kernel::sys::raw::c_uint = 8;
pub const PGET_NOTWEXIT: ::kernel::sys::raw::c_uint = 16;
pub const PGET_NOTINEXEC: ::kernel::sys::raw::c_uint = 32;
pub const PGET_NOTID: ::kernel::sys::raw::c_uint = 64;
pub const PGET_WANTREAD: ::kernel::sys::raw::c_uint = 21;
pub const EPOCH_PREEMPT: ::kernel::sys::raw::c_uint = 1;
pub const RW_LOCK_READ: ::kernel::sys::raw::c_uint = 1;
pub const RW_LOCK_READ_WAITERS: ::kernel::sys::raw::c_uint = 2;
pub const RW_LOCK_WRITE_WAITERS: ::kernel::sys::raw::c_uint = 4;
pub const RW_LOCK_WRITE_SPINNER: ::kernel::sys::raw::c_uint = 8;
pub const RW_LOCK_WRITER_RECURSED: ::kernel::sys::raw::c_uint = 16;
pub const RW_LOCK_FLAGMASK: ::kernel::sys::raw::c_uint = 31;
pub const RW_LOCK_WAITERS: ::kernel::sys::raw::c_uint = 6;
pub const RW_READERS_SHIFT: ::kernel::sys::raw::c_uint = 5;
pub const RW_ONE_READER: ::kernel::sys::raw::c_uint = 32;
pub const RW_DESTROYED: ::kernel::sys::raw::c_uint = 6;
pub const RW_DUPOK: ::kernel::sys::raw::c_uint = 1;
pub const RW_NOPROFILE: ::kernel::sys::raw::c_uint = 2;
pub const RW_NOWITNESS: ::kernel::sys::raw::c_uint = 4;
pub const RW_QUIET: ::kernel::sys::raw::c_uint = 8;
pub const RW_RECURSE: ::kernel::sys::raw::c_uint = 16;
pub const RW_NEW: ::kernel::sys::raw::c_uint = 32;
pub const SX_LOCK_SHARED: ::kernel::sys::raw::c_uint = 1;
pub const SX_LOCK_SHARED_WAITERS: ::kernel::sys::raw::c_uint = 2;
pub const SX_LOCK_EXCLUSIVE_WAITERS: ::kernel::sys::raw::c_uint = 4;
pub const SX_LOCK_RECURSED: ::kernel::sys::raw::c_uint = 8;
pub const SX_LOCK_WRITE_SPINNER: ::kernel::sys::raw::c_uint = 16;
pub const SX_LOCK_FLAGMASK: ::kernel::sys::raw::c_uint = 31;
pub const SX_LOCK_WAITERS: ::kernel::sys::raw::c_uint = 6;
pub const SX_SHARERS_SHIFT: ::kernel::sys::raw::c_uint = 5;
pub const SX_ONE_SHARER: ::kernel::sys::raw::c_uint = 32;
pub const SX_LOCK_DESTROYED: ::kernel::sys::raw::c_uint = 6;
pub const SX_DUPOK: ::kernel::sys::raw::c_uint = 1;
pub const SX_NOPROFILE: ::kernel::sys::raw::c_uint = 2;
pub const SX_NOWITNESS: ::kernel::sys::raw::c_uint = 4;
pub const SX_QUIET: ::kernel::sys::raw::c_uint = 8;
pub const SX_NOADAPTIVE: ::kernel::sys::raw::c_uint = 16;
pub const SX_RECURSE: ::kernel::sys::raw::c_uint = 32;
pub const SX_NEW: ::kernel::sys::raw::c_uint = 64;
pub const SX_INTERRUPTIBLE: ::kernel::sys::raw::c_uint = 64;
pub const IF_DUNIT_NONE: ::kernel::sys::raw::c_int = -1;
pub const ALTQF_READY: ::kernel::sys::raw::c_uint = 1;
pub const ALTQF_ENABLED: ::kernel::sys::raw::c_uint = 2;
pub const ALTQF_CLASSIFY: ::kernel::sys::raw::c_uint = 4;
pub const ALTQF_CNDTNING: ::kernel::sys::raw::c_uint = 8;
pub const ALTQF_DRIVER1: ::kernel::sys::raw::c_uint = 64;
pub const ALTQF_CANTCHANGE: ::kernel::sys::raw::c_uint = 1;
pub const ALTDQ_REMOVE: ::kernel::sys::raw::c_uint = 1;
pub const ALTDQ_POLL: ::kernel::sys::raw::c_uint = 2;
pub const ALTRQ_PURGE: ::kernel::sys::raw::c_uint = 1;
pub const HHOOK_IPSEC_INET: ::kernel::sys::raw::c_uint = 0;
pub const HHOOK_IPSEC_INET6: ::kernel::sys::raw::c_uint = 1;
pub const HHOOK_IPSEC_COUNT: ::kernel::sys::raw::c_uint = 2;
pub const IFENCAP_FLAG_BROADCAST: ::kernel::sys::raw::c_uint = 2;
pub const IF_SND_TAG_TYPE_RATE_LIMIT: ::kernel::sys::raw::c_uint = 0;
pub const IF_SND_TAG_TYPE_UNLIMITED: ::kernel::sys::raw::c_uint = 1;
pub const IF_SND_TAG_TYPE_MAX: ::kernel::sys::raw::c_uint = 2;
pub const IF_SND_QUEUE_LEVEL_MIN: ::kernel::sys::raw::c_uint = 0;
pub const IF_SND_QUEUE_LEVEL_MAX: ::kernel::sys::raw::c_uint = 65535;
pub const IFNET_EVENT_UP: ::kernel::sys::raw::c_uint = 0;
pub const IFNET_EVENT_DOWN: ::kernel::sys::raw::c_uint = 1;
pub const IFNET_EVENT_PCP: ::kernel::sys::raw::c_uint = 2;
pub const IF_MINMTU: ::kernel::sys::raw::c_uint = 72;
pub const IF_MAXMTU: ::kernel::sys::raw::c_uint = 65535;
pub const ARPHRD_ETHER: ::kernel::sys::raw::c_uint = 1;
pub const ARPHRD_IEEE802: ::kernel::sys::raw::c_uint = 6;
pub const ARPHRD_FRELAY: ::kernel::sys::raw::c_uint = 15;
pub const ARPHRD_IEEE1394: ::kernel::sys::raw::c_uint = 24;
pub const ARPHRD_INFINIBAND: ::kernel::sys::raw::c_uint = 32;
pub const ARPOP_REQUEST: ::kernel::sys::raw::c_uint = 1;
pub const ARPOP_REPLY: ::kernel::sys::raw::c_uint = 2;
pub const ARPOP_REVREQUEST: ::kernel::sys::raw::c_uint = 3;
pub const ARPOP_REVREPLY: ::kernel::sys::raw::c_uint = 4;
pub const ARPOP_INVREQUEST: ::kernel::sys::raw::c_uint = 8;
pub const ARPOP_INVREPLY: ::kernel::sys::raw::c_uint = 9;
pub const ATF_INUSE: ::kernel::sys::raw::c_uint = 1;
pub const ATF_COM: ::kernel::sys::raw::c_uint = 2;
pub const ATF_PERM: ::kernel::sys::raw::c_uint = 4;
pub const ATF_PUBL: ::kernel::sys::raw::c_uint = 8;
pub const ATF_USETRAILERS: ::kernel::sys::raw::c_uint = 16;
pub const IFM_ETHER: ::kernel::sys::raw::c_uint = 32;
pub const IFM_10_T: ::kernel::sys::raw::c_uint = 3;
pub const IFM_10_2: ::kernel::sys::raw::c_uint = 4;
pub const IFM_10_5: ::kernel::sys::raw::c_uint = 5;
pub const IFM_100_TX: ::kernel::sys::raw::c_uint = 6;
pub const IFM_100_FX: ::kernel::sys::raw::c_uint = 7;
pub const IFM_100_T4: ::kernel::sys::raw::c_uint = 8;
pub const IFM_100_VG: ::kernel::sys::raw::c_uint = 9;
pub const IFM_100_T2: ::kernel::sys::raw::c_uint = 10;
pub const IFM_1000_SX: ::kernel::sys::raw::c_uint = 11;
pub const IFM_10_STP: ::kernel::sys::raw::c_uint = 12;
pub const IFM_10_FL: ::kernel::sys::raw::c_uint = 13;
pub const IFM_1000_LX: ::kernel::sys::raw::c_uint = 14;
pub const IFM_1000_CX: ::kernel::sys::raw::c_uint = 15;
pub const IFM_1000_T: ::kernel::sys::raw::c_uint = 16;
pub const IFM_HPNA_1: ::kernel::sys::raw::c_uint = 17;
pub const IFM_10G_LR: ::kernel::sys::raw::c_uint = 18;
pub const IFM_10G_SR: ::kernel::sys::raw::c_uint = 19;
pub const IFM_10G_CX4: ::kernel::sys::raw::c_uint = 20;
pub const IFM_2500_SX: ::kernel::sys::raw::c_uint = 21;
pub const IFM_10G_TWINAX: ::kernel::sys::raw::c_uint = 22;
pub const IFM_10G_TWINAX_LONG: ::kernel::sys::raw::c_uint = 23;
pub const IFM_10G_LRM: ::kernel::sys::raw::c_uint = 24;
pub const IFM_UNKNOWN: ::kernel::sys::raw::c_uint = 25;
pub const IFM_10G_T: ::kernel::sys::raw::c_uint = 26;
pub const IFM_40G_CR4: ::kernel::sys::raw::c_uint = 27;
pub const IFM_40G_SR4: ::kernel::sys::raw::c_uint = 28;
pub const IFM_40G_LR4: ::kernel::sys::raw::c_uint = 29;
pub const IFM_1000_KX: ::kernel::sys::raw::c_uint = 30;
pub const IFM_OTHER: ::kernel::sys::raw::c_uint = 31;
pub const IFM_ETH_MASTER: ::kernel::sys::raw::c_uint = 256;
pub const IFM_ETH_RXPAUSE: ::kernel::sys::raw::c_uint = 512;
pub const IFM_ETH_TXPAUSE: ::kernel::sys::raw::c_uint = 1024;
pub const IFM_ETH_XTYPE: ::kernel::sys::raw::c_uint = 30720;
pub const IFM_ETH_XSHIFT: ::kernel::sys::raw::c_uint = 6;
pub const IFM_IEEE80211: ::kernel::sys::raw::c_uint = 128;
pub const IFM_IEEE80211_FH1: ::kernel::sys::raw::c_uint = 3;
pub const IFM_IEEE80211_FH2: ::kernel::sys::raw::c_uint = 4;
pub const IFM_IEEE80211_DS1: ::kernel::sys::raw::c_uint = 5;
pub const IFM_IEEE80211_DS2: ::kernel::sys::raw::c_uint = 6;
pub const IFM_IEEE80211_DS5: ::kernel::sys::raw::c_uint = 7;
pub const IFM_IEEE80211_DS11: ::kernel::sys::raw::c_uint = 8;
pub const IFM_IEEE80211_DS22: ::kernel::sys::raw::c_uint = 9;
pub const IFM_IEEE80211_OFDM6: ::kernel::sys::raw::c_uint = 10;
pub const IFM_IEEE80211_OFDM9: ::kernel::sys::raw::c_uint = 11;
pub const IFM_IEEE80211_OFDM12: ::kernel::sys::raw::c_uint = 12;
pub const IFM_IEEE80211_OFDM18: ::kernel::sys::raw::c_uint = 13;
pub const IFM_IEEE80211_OFDM24: ::kernel::sys::raw::c_uint = 14;
pub const IFM_IEEE80211_OFDM36: ::kernel::sys::raw::c_uint = 15;
pub const IFM_IEEE80211_OFDM48: ::kernel::sys::raw::c_uint = 16;
pub const IFM_IEEE80211_OFDM54: ::kernel::sys::raw::c_uint = 17;
pub const IFM_IEEE80211_OFDM72: ::kernel::sys::raw::c_uint = 18;
pub const IFM_IEEE80211_DS354k: ::kernel::sys::raw::c_uint = 19;
pub const IFM_IEEE80211_DS512k: ::kernel::sys::raw::c_uint = 20;
pub const IFM_IEEE80211_OFDM3: ::kernel::sys::raw::c_uint = 21;
pub const IFM_IEEE80211_OFDM4: ::kernel::sys::raw::c_uint = 22;
pub const IFM_IEEE80211_OFDM27: ::kernel::sys::raw::c_uint = 23;
pub const IFM_IEEE80211_MCS: ::kernel::sys::raw::c_uint = 24;
pub const IFM_IEEE80211_VHT: ::kernel::sys::raw::c_uint = 25;
pub const IFM_IEEE80211_ADHOC: ::kernel::sys::raw::c_uint = 256;
pub const IFM_IEEE80211_HOSTAP: ::kernel::sys::raw::c_uint = 512;
pub const IFM_IEEE80211_IBSS: ::kernel::sys::raw::c_uint = 1024;
pub const IFM_IEEE80211_WDS: ::kernel::sys::raw::c_uint = 2048;
pub const IFM_IEEE80211_TURBO: ::kernel::sys::raw::c_uint = 4096;
pub const IFM_IEEE80211_MONITOR: ::kernel::sys::raw::c_uint = 8192;
pub const IFM_IEEE80211_MBSS: ::kernel::sys::raw::c_uint = 16384;
pub const IFM_IEEE80211_11A: ::kernel::sys::raw::c_uint = 65536;
pub const IFM_IEEE80211_11B: ::kernel::sys::raw::c_uint = 131072;
pub const IFM_IEEE80211_11G: ::kernel::sys::raw::c_uint = 196608;
pub const IFM_IEEE80211_FH: ::kernel::sys::raw::c_uint = 262144;
pub const IFM_IEEE80211_11NA: ::kernel::sys::raw::c_uint = 327680;
pub const IFM_IEEE80211_11NG: ::kernel::sys::raw::c_uint = 393216;
pub const IFM_IEEE80211_VHT5G: ::kernel::sys::raw::c_uint = 458752;
pub const IFM_IEEE80211_VHT2G: ::kernel::sys::raw::c_uint = 524288;
pub const IFM_ATM: ::kernel::sys::raw::c_uint = 160;
pub const IFM_ATM_UNKNOWN: ::kernel::sys::raw::c_uint = 3;
pub const IFM_ATM_UTP_25: ::kernel::sys::raw::c_uint = 4;
pub const IFM_ATM_TAXI_100: ::kernel::sys::raw::c_uint = 5;
pub const IFM_ATM_TAXI_140: ::kernel::sys::raw::c_uint = 6;
pub const IFM_ATM_MM_155: ::kernel::sys::raw::c_uint = 7;
pub const IFM_ATM_SM_155: ::kernel::sys::raw::c_uint = 8;
pub const IFM_ATM_UTP_155: ::kernel::sys::raw::c_uint = 9;
pub const IFM_ATM_MM_622: ::kernel::sys::raw::c_uint = 10;
pub const IFM_ATM_SM_622: ::kernel::sys::raw::c_uint = 11;
pub const IFM_ATM_VIRTUAL: ::kernel::sys::raw::c_uint = 12;
pub const IFM_ATM_SDH: ::kernel::sys::raw::c_uint = 256;
pub const IFM_ATM_NOSCRAMB: ::kernel::sys::raw::c_uint = 512;
pub const IFM_ATM_UNASSIGNED: ::kernel::sys::raw::c_uint = 1024;
pub const IFM_AUTO: ::kernel::sys::raw::c_uint = 0;
pub const IFM_MANUAL: ::kernel::sys::raw::c_uint = 1;
pub const IFM_NONE: ::kernel::sys::raw::c_uint = 2;
pub const IFM_FDX: ::kernel::sys::raw::c_uint = 1048576;
pub const IFM_HDX: ::kernel::sys::raw::c_uint = 2097152;
pub const IFM_FLOW: ::kernel::sys::raw::c_uint = 4194304;
pub const IFM_FLAG0: ::kernel::sys::raw::c_uint = 16777216;
pub const IFM_FLAG1: ::kernel::sys::raw::c_uint = 33554432;
pub const IFM_FLAG2: ::kernel::sys::raw::c_uint = 67108864;
pub const IFM_LOOP: ::kernel::sys::raw::c_uint = 134217728;
pub const IFM_NMASK: ::kernel::sys::raw::c_uint = 224;
pub const IFM_TMASK: ::kernel::sys::raw::c_uint = 31;
pub const IFM_IMASK: ::kernel::sys::raw::c_uint = 4026531840;
pub const IFM_ISHIFT: ::kernel::sys::raw::c_uint = 28;
pub const IFM_OMASK: ::kernel::sys::raw::c_uint = 65280;
pub const IFM_MMASK: ::kernel::sys::raw::c_uint = 458752;
pub const IFM_MSHIFT: ::kernel::sys::raw::c_uint = 16;
pub const IFM_GMASK: ::kernel::sys::raw::c_uint = 267386880;
pub const IFM_ETH_FMASK: ::kernel::sys::raw::c_uint = 4195840;
pub const IFM_AVALID: ::kernel::sys::raw::c_uint = 1;
pub const IFM_ACTIVE: ::kernel::sys::raw::c_uint = 2;
pub const IFM_STATUS_VALID: ::kernel::sys::raw::c_uint = 1;
pub const NV_NAME_MAX: ::kernel::sys::raw::c_uint = 2048;
pub const NV_TYPE_NONE: ::kernel::sys::raw::c_uint = 0;
pub const NV_TYPE_NULL: ::kernel::sys::raw::c_uint = 1;
pub const NV_TYPE_BOOL: ::kernel::sys::raw::c_uint = 2;
pub const NV_TYPE_NUMBER: ::kernel::sys::raw::c_uint = 3;
pub const NV_TYPE_STRING: ::kernel::sys::raw::c_uint = 4;
pub const NV_TYPE_NVLIST: ::kernel::sys::raw::c_uint = 5;
pub const NV_TYPE_DESCRIPTOR: ::kernel::sys::raw::c_uint = 6;
pub const NV_TYPE_BINARY: ::kernel::sys::raw::c_uint = 7;
pub const NV_TYPE_BOOL_ARRAY: ::kernel::sys::raw::c_uint = 8;
pub const NV_TYPE_NUMBER_ARRAY: ::kernel::sys::raw::c_uint = 9;
pub const NV_TYPE_STRING_ARRAY: ::kernel::sys::raw::c_uint = 10;
pub const NV_TYPE_NVLIST_ARRAY: ::kernel::sys::raw::c_uint = 11;
pub const NV_TYPE_DESCRIPTOR_ARRAY: ::kernel::sys::raw::c_uint = 12;
pub const NV_FLAG_IGNORE_CASE: ::kernel::sys::raw::c_uint = 1;
pub const NV_FLAG_NO_UNIQUE: ::kernel::sys::raw::c_uint = 2;
pub const TASK_ENQUEUED: ::kernel::sys::raw::c_uint = 1;
pub const TASK_SKIP_WAKEUP: ::kernel::sys::raw::c_uint = 2;
pub const QIDX_INVALID: ::kernel::sys::raw::c_uint = 65535;
pub const FREEBSD_TSO_SIZE_MAX: ::kernel::sys::raw::c_uint = 65518;
pub const IPI_TX_INTR: ::kernel::sys::raw::c_uint = 1;
pub const IPI_TX_IPV4: ::kernel::sys::raw::c_uint = 2;
pub const IPI_TX_IPV6: ::kernel::sys::raw::c_uint = 4;
pub const IFLIB_PNP_DESCR: &'static [u8; 77usize] =
    b"U32:vendor;U32:device;U32:subvendor;U32:subdevice;U32:revision;U32:class;D:#\x00";
pub const IFLIB_MAGIC: ::kernel::sys::raw::c_uint = 3405705229;
pub const ETH_ADDR_LEN: ::kernel::sys::raw::c_uint = 6;
pub const IFLIB_HAS_RXCQ: ::kernel::sys::raw::c_uint = 1;
pub const IFLIB_SKIP_MSIX: ::kernel::sys::raw::c_uint = 2;
pub const IFLIB_IS_VF: ::kernel::sys::raw::c_uint = 4;
pub const IFLIB_HAS_TXCQ: ::kernel::sys::raw::c_uint = 8;
pub const IFLIB_NEED_SCRATCH: ::kernel::sys::raw::c_uint = 16;
pub const IFLIB_TSO_INIT_IP: ::kernel::sys::raw::c_uint = 32;
pub const IFLIB_DO_RX_FIXUP: ::kernel::sys::raw::c_uint = 64;
pub const IFLIB_NEED_ZERO_CSUM: ::kernel::sys::raw::c_uint = 128;
pub const IFLIB_NEED_ETHER_PAD: ::kernel::sys::raw::c_uint = 256;
pub const IFLIB_TXD_ENCAP_PIO: ::kernel::sys::raw::c_uint = 512;
pub const IFLIB_RX_COMPLETION: ::kernel::sys::raw::c_uint = 1024;
pub const IFLIB_SKIP_CLREFILL: ::kernel::sys::raw::c_uint = 2048;
pub const IFLIB_NO_HANG_RESET: ::kernel::sys::raw::c_uint = 4096;
pub const IFLIB_PSEUDO: ::kernel::sys::raw::c_uint = 8192;
pub const IFLIB_VIRTUAL: ::kernel::sys::raw::c_uint = 16384;
pub const IFLIB_GEN_MAC: ::kernel::sys::raw::c_uint = 32768;
pub const IFLIB_ADMIN_ALWAYS_RUN: ::kernel::sys::raw::c_uint = 65536;
pub const _NET_IF_VLAN_VAR_H_: ::kernel::sys::raw::c_uint = 1;
pub const VLANCTL_PROTO: ::kernel::sys::raw::c_uint = 1;
pub const VLANCTL_MAX: ::kernel::sys::raw::c_uint = 2;
pub const MTAG_8021Q: ::kernel::sys::raw::c_uint = 1326104895;
pub const MTAG_8021Q_PCP_IN: ::kernel::sys::raw::c_uint = 0;
pub const MTAG_8021Q_PCP_OUT: ::kernel::sys::raw::c_uint = 1;
pub const IPPROTO_IP: ::kernel::sys::raw::c_uint = 0;
pub const IPPROTO_ICMP: ::kernel::sys::raw::c_uint = 1;
pub const IPPROTO_TCP: ::kernel::sys::raw::c_uint = 6;
pub const IPPROTO_UDP: ::kernel::sys::raw::c_uint = 17;
pub const IPPROTO_IPV6: ::kernel::sys::raw::c_uint = 41;
pub const IPPROTO_RAW: ::kernel::sys::raw::c_uint = 255;
pub const INET_ADDRSTRLEN: ::kernel::sys::raw::c_uint = 16;
pub const IPPROTO_HOPOPTS: ::kernel::sys::raw::c_uint = 0;
pub const IPPROTO_IGMP: ::kernel::sys::raw::c_uint = 2;
pub const IPPROTO_GGP: ::kernel::sys::raw::c_uint = 3;
pub const IPPROTO_IPV4: ::kernel::sys::raw::c_uint = 4;
pub const IPPROTO_IPIP: ::kernel::sys::raw::c_uint = 4;
pub const IPPROTO_ST: ::kernel::sys::raw::c_uint = 7;
pub const IPPROTO_EGP: ::kernel::sys::raw::c_uint = 8;
pub const IPPROTO_PIGP: ::kernel::sys::raw::c_uint = 9;
pub const IPPROTO_RCCMON: ::kernel::sys::raw::c_uint = 10;
pub const IPPROTO_NVPII: ::kernel::sys::raw::c_uint = 11;
pub const IPPROTO_PUP: ::kernel::sys::raw::c_uint = 12;
pub const IPPROTO_ARGUS: ::kernel::sys::raw::c_uint = 13;
pub const IPPROTO_EMCON: ::kernel::sys::raw::c_uint = 14;
pub const IPPROTO_XNET: ::kernel::sys::raw::c_uint = 15;
pub const IPPROTO_CHAOS: ::kernel::sys::raw::c_uint = 16;
pub const IPPROTO_MUX: ::kernel::sys::raw::c_uint = 18;
pub const IPPROTO_MEAS: ::kernel::sys::raw::c_uint = 19;
pub const IPPROTO_HMP: ::kernel::sys::raw::c_uint = 20;
pub const IPPROTO_PRM: ::kernel::sys::raw::c_uint = 21;
pub const IPPROTO_IDP: ::kernel::sys::raw::c_uint = 22;
pub const IPPROTO_TRUNK1: ::kernel::sys::raw::c_uint = 23;
pub const IPPROTO_TRUNK2: ::kernel::sys::raw::c_uint = 24;
pub const IPPROTO_LEAF1: ::kernel::sys::raw::c_uint = 25;
pub const IPPROTO_LEAF2: ::kernel::sys::raw::c_uint = 26;
pub const IPPROTO_RDP: ::kernel::sys::raw::c_uint = 27;
pub const IPPROTO_IRTP: ::kernel::sys::raw::c_uint = 28;
pub const IPPROTO_TP: ::kernel::sys::raw::c_uint = 29;
pub const IPPROTO_BLT: ::kernel::sys::raw::c_uint = 30;
pub const IPPROTO_NSP: ::kernel::sys::raw::c_uint = 31;
pub const IPPROTO_INP: ::kernel::sys::raw::c_uint = 32;
pub const IPPROTO_SEP: ::kernel::sys::raw::c_uint = 33;
pub const IPPROTO_3PC: ::kernel::sys::raw::c_uint = 34;
pub const IPPROTO_IDPR: ::kernel::sys::raw::c_uint = 35;
pub const IPPROTO_XTP: ::kernel::sys::raw::c_uint = 36;
pub const IPPROTO_DDP: ::kernel::sys::raw::c_uint = 37;
pub const IPPROTO_CMTP: ::kernel::sys::raw::c_uint = 38;
pub const IPPROTO_TPXX: ::kernel::sys::raw::c_uint = 39;
pub const IPPROTO_IL: ::kernel::sys::raw::c_uint = 40;
pub const IPPROTO_SDRP: ::kernel::sys::raw::c_uint = 42;
pub const IPPROTO_ROUTING: ::kernel::sys::raw::c_uint = 43;
pub const IPPROTO_FRAGMENT: ::kernel::sys::raw::c_uint = 44;
pub const IPPROTO_IDRP: ::kernel::sys::raw::c_uint = 45;
pub const IPPROTO_RSVP: ::kernel::sys::raw::c_uint = 46;
pub const IPPROTO_GRE: ::kernel::sys::raw::c_uint = 47;
pub const IPPROTO_MHRP: ::kernel::sys::raw::c_uint = 48;
pub const IPPROTO_BHA: ::kernel::sys::raw::c_uint = 49;
pub const IPPROTO_ESP: ::kernel::sys::raw::c_uint = 50;
pub const IPPROTO_AH: ::kernel::sys::raw::c_uint = 51;
pub const IPPROTO_INLSP: ::kernel::sys::raw::c_uint = 52;
pub const IPPROTO_SWIPE: ::kernel::sys::raw::c_uint = 53;
pub const IPPROTO_NHRP: ::kernel::sys::raw::c_uint = 54;
pub const IPPROTO_MOBILE: ::kernel::sys::raw::c_uint = 55;
pub const IPPROTO_TLSP: ::kernel::sys::raw::c_uint = 56;
pub const IPPROTO_SKIP: ::kernel::sys::raw::c_uint = 57;
pub const IPPROTO_ICMPV6: ::kernel::sys::raw::c_uint = 58;
pub const IPPROTO_NONE: ::kernel::sys::raw::c_uint = 59;
pub const IPPROTO_DSTOPTS: ::kernel::sys::raw::c_uint = 60;
pub const IPPROTO_AHIP: ::kernel::sys::raw::c_uint = 61;
pub const IPPROTO_CFTP: ::kernel::sys::raw::c_uint = 62;
pub const IPPROTO_HELLO: ::kernel::sys::raw::c_uint = 63;
pub const IPPROTO_SATEXPAK: ::kernel::sys::raw::c_uint = 64;
pub const IPPROTO_KRYPTOLAN: ::kernel::sys::raw::c_uint = 65;
pub const IPPROTO_RVD: ::kernel::sys::raw::c_uint = 66;
pub const IPPROTO_IPPC: ::kernel::sys::raw::c_uint = 67;
pub const IPPROTO_ADFS: ::kernel::sys::raw::c_uint = 68;
pub const IPPROTO_SATMON: ::kernel::sys::raw::c_uint = 69;
pub const IPPROTO_VISA: ::kernel::sys::raw::c_uint = 70;
pub const IPPROTO_IPCV: ::kernel::sys::raw::c_uint = 71;
pub const IPPROTO_CPNX: ::kernel::sys::raw::c_uint = 72;
pub const IPPROTO_CPHB: ::kernel::sys::raw::c_uint = 73;
pub const IPPROTO_WSN: ::kernel::sys::raw::c_uint = 74;
pub const IPPROTO_PVP: ::kernel::sys::raw::c_uint = 75;
pub const IPPROTO_BRSATMON: ::kernel::sys::raw::c_uint = 76;
pub const IPPROTO_ND: ::kernel::sys::raw::c_uint = 77;
pub const IPPROTO_WBMON: ::kernel::sys::raw::c_uint = 78;
pub const IPPROTO_WBEXPAK: ::kernel::sys::raw::c_uint = 79;
pub const IPPROTO_EON: ::kernel::sys::raw::c_uint = 80;
pub const IPPROTO_VMTP: ::kernel::sys::raw::c_uint = 81;
pub const IPPROTO_SVMTP: ::kernel::sys::raw::c_uint = 82;
pub const IPPROTO_VINES: ::kernel::sys::raw::c_uint = 83;
pub const IPPROTO_TTP: ::kernel::sys::raw::c_uint = 84;
pub const IPPROTO_IGP: ::kernel::sys::raw::c_uint = 85;
pub const IPPROTO_DGP: ::kernel::sys::raw::c_uint = 86;
pub const IPPROTO_TCF: ::kernel::sys::raw::c_uint = 87;
pub const IPPROTO_IGRP: ::kernel::sys::raw::c_uint = 88;
pub const IPPROTO_OSPFIGP: ::kernel::sys::raw::c_uint = 89;
pub const IPPROTO_SRPC: ::kernel::sys::raw::c_uint = 90;
pub const IPPROTO_LARP: ::kernel::sys::raw::c_uint = 91;
pub const IPPROTO_MTP: ::kernel::sys::raw::c_uint = 92;
pub const IPPROTO_AX25: ::kernel::sys::raw::c_uint = 93;
pub const IPPROTO_IPEIP: ::kernel::sys::raw::c_uint = 94;
pub const IPPROTO_MICP: ::kernel::sys::raw::c_uint = 95;
pub const IPPROTO_SCCSP: ::kernel::sys::raw::c_uint = 96;
pub const IPPROTO_ETHERIP: ::kernel::sys::raw::c_uint = 97;
pub const IPPROTO_ENCAP: ::kernel::sys::raw::c_uint = 98;
pub const IPPROTO_APES: ::kernel::sys::raw::c_uint = 99;
pub const IPPROTO_GMTP: ::kernel::sys::raw::c_uint = 100;
pub const IPPROTO_IPCOMP: ::kernel::sys::raw::c_uint = 108;
pub const IPPROTO_SCTP: ::kernel::sys::raw::c_uint = 132;
pub const IPPROTO_MH: ::kernel::sys::raw::c_uint = 135;
pub const IPPROTO_UDPLITE: ::kernel::sys::raw::c_uint = 136;
pub const IPPROTO_HIP: ::kernel::sys::raw::c_uint = 139;
pub const IPPROTO_SHIM6: ::kernel::sys::raw::c_uint = 140;
pub const IPPROTO_PIM: ::kernel::sys::raw::c_uint = 103;
pub const IPPROTO_CARP: ::kernel::sys::raw::c_uint = 112;
pub const IPPROTO_PGM: ::kernel::sys::raw::c_uint = 113;
pub const IPPROTO_MPLS: ::kernel::sys::raw::c_uint = 137;
pub const IPPROTO_PFSYNC: ::kernel::sys::raw::c_uint = 240;
pub const IPPROTO_RESERVED_253: ::kernel::sys::raw::c_uint = 253;
pub const IPPROTO_RESERVED_254: ::kernel::sys::raw::c_uint = 254;
pub const IPPROTO_OLD_DIVERT: ::kernel::sys::raw::c_uint = 254;
pub const IPPROTO_MAX: ::kernel::sys::raw::c_uint = 256;
pub const IPPROTO_DONE: ::kernel::sys::raw::c_uint = 257;
pub const IPPROTO_DIVERT: ::kernel::sys::raw::c_uint = 258;
pub const IPPROTO_SEND: ::kernel::sys::raw::c_uint = 259;
pub const IPPROTO_SPACER: ::kernel::sys::raw::c_uint = 32767;
pub const IPPORT_RESERVED: ::kernel::sys::raw::c_uint = 1024;
pub const IPPORT_EPHEMERALFIRST: ::kernel::sys::raw::c_uint = 10000;
pub const IPPORT_EPHEMERALLAST: ::kernel::sys::raw::c_uint = 65535;
pub const IPPORT_HIFIRSTAUTO: ::kernel::sys::raw::c_uint = 49152;
pub const IPPORT_HILASTAUTO: ::kernel::sys::raw::c_uint = 65535;
pub const IPPORT_RESERVEDSTART: ::kernel::sys::raw::c_uint = 600;
pub const IPPORT_MAX: ::kernel::sys::raw::c_uint = 65535;
pub const IN_CLASSA_NET: ::kernel::sys::raw::c_uint = 4278190080;
pub const IN_CLASSA_NSHIFT: ::kernel::sys::raw::c_uint = 24;
pub const IN_CLASSA_HOST: ::kernel::sys::raw::c_uint = 16777215;
pub const IN_CLASSA_MAX: ::kernel::sys::raw::c_uint = 128;
pub const IN_CLASSB_NET: ::kernel::sys::raw::c_uint = 4294901760;
pub const IN_CLASSB_NSHIFT: ::kernel::sys::raw::c_uint = 16;
pub const IN_CLASSB_HOST: ::kernel::sys::raw::c_uint = 65535;
pub const IN_CLASSB_MAX: ::kernel::sys::raw::c_uint = 65536;
pub const IN_CLASSC_NET: ::kernel::sys::raw::c_uint = 4294967040;
pub const IN_CLASSC_NSHIFT: ::kernel::sys::raw::c_uint = 8;
pub const IN_CLASSC_HOST: ::kernel::sys::raw::c_uint = 255;
pub const IN_CLASSD_NET: ::kernel::sys::raw::c_uint = 4026531840;
pub const IN_CLASSD_NSHIFT: ::kernel::sys::raw::c_uint = 28;
pub const IN_CLASSD_HOST: ::kernel::sys::raw::c_uint = 268435455;
pub const IN_LOOPBACKNET: ::kernel::sys::raw::c_uint = 127;
pub const IP_OPTIONS: ::kernel::sys::raw::c_uint = 1;
pub const IP_HDRINCL: ::kernel::sys::raw::c_uint = 2;
pub const IP_TOS: ::kernel::sys::raw::c_uint = 3;
pub const IP_TTL: ::kernel::sys::raw::c_uint = 4;
pub const IP_RECVOPTS: ::kernel::sys::raw::c_uint = 5;
pub const IP_RECVRETOPTS: ::kernel::sys::raw::c_uint = 6;
pub const IP_RECVDSTADDR: ::kernel::sys::raw::c_uint = 7;
pub const IP_SENDSRCADDR: ::kernel::sys::raw::c_uint = 7;
pub const IP_RETOPTS: ::kernel::sys::raw::c_uint = 8;
pub const IP_MULTICAST_IF: ::kernel::sys::raw::c_uint = 9;
pub const IP_MULTICAST_TTL: ::kernel::sys::raw::c_uint = 10;
pub const IP_MULTICAST_LOOP: ::kernel::sys::raw::c_uint = 11;
pub const IP_ADD_MEMBERSHIP: ::kernel::sys::raw::c_uint = 12;
pub const IP_DROP_MEMBERSHIP: ::kernel::sys::raw::c_uint = 13;
pub const IP_MULTICAST_VIF: ::kernel::sys::raw::c_uint = 14;
pub const IP_RSVP_ON: ::kernel::sys::raw::c_uint = 15;
pub const IP_RSVP_OFF: ::kernel::sys::raw::c_uint = 16;
pub const IP_RSVP_VIF_ON: ::kernel::sys::raw::c_uint = 17;
pub const IP_RSVP_VIF_OFF: ::kernel::sys::raw::c_uint = 18;
pub const IP_PORTRANGE: ::kernel::sys::raw::c_uint = 19;
pub const IP_RECVIF: ::kernel::sys::raw::c_uint = 20;
pub const IP_IPSEC_POLICY: ::kernel::sys::raw::c_uint = 21;
pub const IP_ONESBCAST: ::kernel::sys::raw::c_uint = 23;
pub const IP_BINDANY: ::kernel::sys::raw::c_uint = 24;
pub const IP_BINDMULTI: ::kernel::sys::raw::c_uint = 25;
pub const IP_RSS_LISTEN_BUCKET: ::kernel::sys::raw::c_uint = 26;
pub const IP_ORIGDSTADDR: ::kernel::sys::raw::c_uint = 27;
pub const IP_RECVORIGDSTADDR: ::kernel::sys::raw::c_uint = 27;
pub const IP_FW_TABLE_ADD: ::kernel::sys::raw::c_uint = 40;
pub const IP_FW_TABLE_DEL: ::kernel::sys::raw::c_uint = 41;
pub const IP_FW_TABLE_FLUSH: ::kernel::sys::raw::c_uint = 42;
pub const IP_FW_TABLE_GETSIZE: ::kernel::sys::raw::c_uint = 43;
pub const IP_FW_TABLE_LIST: ::kernel::sys::raw::c_uint = 44;
pub const IP_FW3: ::kernel::sys::raw::c_uint = 48;
pub const IP_DUMMYNET3: ::kernel::sys::raw::c_uint = 49;
pub const IP_FW_ADD: ::kernel::sys::raw::c_uint = 50;
pub const IP_FW_DEL: ::kernel::sys::raw::c_uint = 51;
pub const IP_FW_FLUSH: ::kernel::sys::raw::c_uint = 52;
pub const IP_FW_ZERO: ::kernel::sys::raw::c_uint = 53;
pub const IP_FW_GET: ::kernel::sys::raw::c_uint = 54;
pub const IP_FW_RESETLOG: ::kernel::sys::raw::c_uint = 55;
pub const IP_FW_NAT_CFG: ::kernel::sys::raw::c_uint = 56;
pub const IP_FW_NAT_DEL: ::kernel::sys::raw::c_uint = 57;
pub const IP_FW_NAT_GET_CONFIG: ::kernel::sys::raw::c_uint = 58;
pub const IP_FW_NAT_GET_LOG: ::kernel::sys::raw::c_uint = 59;
pub const IP_DUMMYNET_CONFIGURE: ::kernel::sys::raw::c_uint = 60;
pub const IP_DUMMYNET_DEL: ::kernel::sys::raw::c_uint = 61;
pub const IP_DUMMYNET_FLUSH: ::kernel::sys::raw::c_uint = 62;
pub const IP_DUMMYNET_GET: ::kernel::sys::raw::c_uint = 64;
pub const IP_RECVTTL: ::kernel::sys::raw::c_uint = 65;
pub const IP_MINTTL: ::kernel::sys::raw::c_uint = 66;
pub const IP_DONTFRAG: ::kernel::sys::raw::c_uint = 67;
pub const IP_RECVTOS: ::kernel::sys::raw::c_uint = 68;
pub const IP_ADD_SOURCE_MEMBERSHIP: ::kernel::sys::raw::c_uint = 70;
pub const IP_DROP_SOURCE_MEMBERSHIP: ::kernel::sys::raw::c_uint = 71;
pub const IP_BLOCK_SOURCE: ::kernel::sys::raw::c_uint = 72;
pub const IP_UNBLOCK_SOURCE: ::kernel::sys::raw::c_uint = 73;
pub const IP_MSFILTER: ::kernel::sys::raw::c_uint = 74;
pub const MCAST_JOIN_GROUP: ::kernel::sys::raw::c_uint = 80;
pub const MCAST_LEAVE_GROUP: ::kernel::sys::raw::c_uint = 81;
pub const MCAST_JOIN_SOURCE_GROUP: ::kernel::sys::raw::c_uint = 82;
pub const MCAST_LEAVE_SOURCE_GROUP: ::kernel::sys::raw::c_uint = 83;
pub const MCAST_BLOCK_SOURCE: ::kernel::sys::raw::c_uint = 84;
pub const MCAST_UNBLOCK_SOURCE: ::kernel::sys::raw::c_uint = 85;
pub const IP_FLOWID: ::kernel::sys::raw::c_uint = 90;
pub const IP_FLOWTYPE: ::kernel::sys::raw::c_uint = 91;
pub const IP_RSSBUCKETID: ::kernel::sys::raw::c_uint = 92;
pub const IP_RECVFLOWID: ::kernel::sys::raw::c_uint = 93;
pub const IP_RECVRSSBUCKETID: ::kernel::sys::raw::c_uint = 94;
pub const IP_DEFAULT_MULTICAST_TTL: ::kernel::sys::raw::c_uint = 1;
pub const IP_DEFAULT_MULTICAST_LOOP: ::kernel::sys::raw::c_uint = 1;
pub const IP_MIN_MEMBERSHIPS: ::kernel::sys::raw::c_uint = 31;
pub const IP_MAX_MEMBERSHIPS: ::kernel::sys::raw::c_uint = 4095;
pub const IP_MAX_SOURCE_FILTER: ::kernel::sys::raw::c_uint = 1024;
pub const IP_MAX_GROUP_SRC_FILTER: ::kernel::sys::raw::c_uint = 512;
pub const IP_MAX_SOCK_SRC_FILTER: ::kernel::sys::raw::c_uint = 128;
pub const IP_MAX_SOCK_MUTE_FILTER: ::kernel::sys::raw::c_uint = 128;
pub const MCAST_UNDEFINED: ::kernel::sys::raw::c_uint = 0;
pub const MCAST_INCLUDE: ::kernel::sys::raw::c_uint = 1;
pub const MCAST_EXCLUDE: ::kernel::sys::raw::c_uint = 2;
pub const IP_PORTRANGE_DEFAULT: ::kernel::sys::raw::c_uint = 0;
pub const IP_PORTRANGE_HIGH: ::kernel::sys::raw::c_uint = 1;
pub const IP_PORTRANGE_LOW: ::kernel::sys::raw::c_uint = 2;
pub const IPCTL_FORWARDING: ::kernel::sys::raw::c_uint = 1;
pub const IPCTL_SENDREDIRECTS: ::kernel::sys::raw::c_uint = 2;
pub const IPCTL_DEFTTL: ::kernel::sys::raw::c_uint = 3;
pub const IPCTL_SOURCEROUTE: ::kernel::sys::raw::c_uint = 8;
pub const IPCTL_DIRECTEDBROADCAST: ::kernel::sys::raw::c_uint = 9;
pub const IPCTL_INTRQMAXLEN: ::kernel::sys::raw::c_uint = 10;
pub const IPCTL_INTRQDROPS: ::kernel::sys::raw::c_uint = 11;
pub const IPCTL_STATS: ::kernel::sys::raw::c_uint = 12;
pub const IPCTL_ACCEPTSOURCEROUTE: ::kernel::sys::raw::c_uint = 13;
pub const IPCTL_FASTFORWARDING: ::kernel::sys::raw::c_uint = 14;
pub const IPCTL_GIF_TTL: ::kernel::sys::raw::c_uint = 16;
pub const IPCTL_INTRDQMAXLEN: ::kernel::sys::raw::c_uint = 17;
pub const IPCTL_INTRDQDROPS: ::kernel::sys::raw::c_uint = 18;
pub const __KAME_VERSION: &'static [u8; 8usize] = b"FreeBSD\x00";
pub const IPV6PORT_RESERVED: ::kernel::sys::raw::c_uint = 1024;
pub const IPV6PORT_ANONMIN: ::kernel::sys::raw::c_uint = 49152;
pub const IPV6PORT_ANONMAX: ::kernel::sys::raw::c_uint = 65535;
pub const IPV6PORT_RESERVEDMIN: ::kernel::sys::raw::c_uint = 600;
pub const IPV6PORT_RESERVEDMAX: ::kernel::sys::raw::c_uint = 1023;
pub const INET6_ADDRSTRLEN: ::kernel::sys::raw::c_uint = 46;
pub const IPV6_ADDR_INT32_ONE: ::kernel::sys::raw::c_uint = 16777216;
pub const IPV6_ADDR_INT32_TWO: ::kernel::sys::raw::c_uint = 33554432;
pub const IPV6_ADDR_INT32_MNL: ::kernel::sys::raw::c_uint = 511;
pub const IPV6_ADDR_INT32_MLL: ::kernel::sys::raw::c_uint = 767;
pub const IPV6_ADDR_INT32_SMP: ::kernel::sys::raw::c_uint = 4294901760;
pub const IPV6_ADDR_INT16_ULL: ::kernel::sys::raw::c_uint = 33022;
pub const IPV6_ADDR_INT16_USL: ::kernel::sys::raw::c_uint = 49406;
pub const IPV6_ADDR_INT16_MLL: ::kernel::sys::raw::c_uint = 767;
pub const IPV6_ADDR_SCOPE_NODELOCAL: ::kernel::sys::raw::c_uint = 1;
pub const IPV6_ADDR_SCOPE_INTFACELOCAL: ::kernel::sys::raw::c_uint = 1;
pub const IPV6_ADDR_SCOPE_LINKLOCAL: ::kernel::sys::raw::c_uint = 2;
pub const IPV6_ADDR_SCOPE_SITELOCAL: ::kernel::sys::raw::c_uint = 5;
pub const IPV6_ADDR_SCOPE_ORGLOCAL: ::kernel::sys::raw::c_uint = 8;
pub const IPV6_ADDR_SCOPE_GLOBAL: ::kernel::sys::raw::c_uint = 14;
pub const MTAG_ABI_IPV6: ::kernel::sys::raw::c_uint = 1444287380;
pub const IPV6_TAG_DIRECT: ::kernel::sys::raw::c_uint = 0;
pub const IPV6_SOCKOPT_RESERVED1: ::kernel::sys::raw::c_uint = 3;
pub const IPV6_UNICAST_HOPS: ::kernel::sys::raw::c_uint = 4;
pub const IPV6_MULTICAST_IF: ::kernel::sys::raw::c_uint = 9;
pub const IPV6_MULTICAST_HOPS: ::kernel::sys::raw::c_uint = 10;
pub const IPV6_MULTICAST_LOOP: ::kernel::sys::raw::c_uint = 11;
pub const IPV6_JOIN_GROUP: ::kernel::sys::raw::c_uint = 12;
pub const IPV6_LEAVE_GROUP: ::kernel::sys::raw::c_uint = 13;
pub const IPV6_PORTRANGE: ::kernel::sys::raw::c_uint = 14;
pub const ICMP6_FILTER: ::kernel::sys::raw::c_uint = 18;
pub const IPV6_2292PKTINFO: ::kernel::sys::raw::c_uint = 19;
pub const IPV6_2292HOPLIMIT: ::kernel::sys::raw::c_uint = 20;
pub const IPV6_2292NEXTHOP: ::kernel::sys::raw::c_uint = 21;
pub const IPV6_2292HOPOPTS: ::kernel::sys::raw::c_uint = 22;
pub const IPV6_2292DSTOPTS: ::kernel::sys::raw::c_uint = 23;
pub const IPV6_2292RTHDR: ::kernel::sys::raw::c_uint = 24;
pub const IPV6_2292PKTOPTIONS: ::kernel::sys::raw::c_uint = 25;
pub const IPV6_CHECKSUM: ::kernel::sys::raw::c_uint = 26;
pub const IPV6_V6ONLY: ::kernel::sys::raw::c_uint = 27;
pub const IPV6_IPSEC_POLICY: ::kernel::sys::raw::c_uint = 28;
pub const IPV6_FW_ADD: ::kernel::sys::raw::c_uint = 30;
pub const IPV6_FW_DEL: ::kernel::sys::raw::c_uint = 31;
pub const IPV6_FW_FLUSH: ::kernel::sys::raw::c_uint = 32;
pub const IPV6_FW_ZERO: ::kernel::sys::raw::c_uint = 33;
pub const IPV6_FW_GET: ::kernel::sys::raw::c_uint = 34;
pub const IPV6_RTHDRDSTOPTS: ::kernel::sys::raw::c_uint = 35;
pub const IPV6_RECVPKTINFO: ::kernel::sys::raw::c_uint = 36;
pub const IPV6_RECVHOPLIMIT: ::kernel::sys::raw::c_uint = 37;
pub const IPV6_RECVRTHDR: ::kernel::sys::raw::c_uint = 38;
pub const IPV6_RECVHOPOPTS: ::kernel::sys::raw::c_uint = 39;
pub const IPV6_RECVDSTOPTS: ::kernel::sys::raw::c_uint = 40;
pub const IPV6_RECVRTHDRDSTOPTS: ::kernel::sys::raw::c_uint = 41;
pub const IPV6_USE_MIN_MTU: ::kernel::sys::raw::c_uint = 42;
pub const IPV6_RECVPATHMTU: ::kernel::sys::raw::c_uint = 43;
pub const IPV6_PATHMTU: ::kernel::sys::raw::c_uint = 44;
pub const IPV6_PKTINFO: ::kernel::sys::raw::c_uint = 46;
pub const IPV6_HOPLIMIT: ::kernel::sys::raw::c_uint = 47;
pub const IPV6_NEXTHOP: ::kernel::sys::raw::c_uint = 48;
pub const IPV6_HOPOPTS: ::kernel::sys::raw::c_uint = 49;
pub const IPV6_DSTOPTS: ::kernel::sys::raw::c_uint = 50;
pub const IPV6_RTHDR: ::kernel::sys::raw::c_uint = 51;
pub const IPV6_RECVTCLASS: ::kernel::sys::raw::c_uint = 57;
pub const IPV6_AUTOFLOWLABEL: ::kernel::sys::raw::c_uint = 59;
pub const IPV6_TCLASS: ::kernel::sys::raw::c_uint = 61;
pub const IPV6_DONTFRAG: ::kernel::sys::raw::c_uint = 62;
pub const IPV6_PREFER_TEMPADDR: ::kernel::sys::raw::c_uint = 63;
pub const IPV6_BINDANY: ::kernel::sys::raw::c_uint = 64;
pub const IPV6_BINDMULTI: ::kernel::sys::raw::c_uint = 65;
pub const IPV6_RSS_LISTEN_BUCKET: ::kernel::sys::raw::c_uint = 66;
pub const IPV6_FLOWID: ::kernel::sys::raw::c_uint = 67;
pub const IPV6_FLOWTYPE: ::kernel::sys::raw::c_uint = 68;
pub const IPV6_RSSBUCKETID: ::kernel::sys::raw::c_uint = 69;
pub const IPV6_RECVFLOWID: ::kernel::sys::raw::c_uint = 70;
pub const IPV6_RECVRSSBUCKETID: ::kernel::sys::raw::c_uint = 71;
pub const IPV6_ORIGDSTADDR: ::kernel::sys::raw::c_uint = 72;
pub const IPV6_RECVORIGDSTADDR: ::kernel::sys::raw::c_uint = 72;
pub const IPV6_MSFILTER: ::kernel::sys::raw::c_uint = 74;
pub const IPV6_RTHDR_LOOSE: ::kernel::sys::raw::c_uint = 0;
pub const IPV6_RTHDR_STRICT: ::kernel::sys::raw::c_uint = 1;
pub const IPV6_RTHDR_TYPE_0: ::kernel::sys::raw::c_uint = 0;
pub const IPV6_DEFAULT_MULTICAST_HOPS: ::kernel::sys::raw::c_uint = 1;
pub const IPV6_DEFAULT_MULTICAST_LOOP: ::kernel::sys::raw::c_uint = 1;
pub const IPV6_MIN_MEMBERSHIPS: ::kernel::sys::raw::c_uint = 31;
pub const IPV6_MAX_MEMBERSHIPS: ::kernel::sys::raw::c_uint = 4095;
pub const IPV6_MAX_GROUP_SRC_FILTER: ::kernel::sys::raw::c_uint = 512;
pub const IPV6_MAX_SOCK_SRC_FILTER: ::kernel::sys::raw::c_uint = 128;
pub const IPV6_PORTRANGE_DEFAULT: ::kernel::sys::raw::c_uint = 0;
pub const IPV6_PORTRANGE_HIGH: ::kernel::sys::raw::c_uint = 1;
pub const IPV6_PORTRANGE_LOW: ::kernel::sys::raw::c_uint = 2;
pub const IPV6PROTO_MAXID: ::kernel::sys::raw::c_uint = 104;
pub const IPV6CTL_FORWARDING: ::kernel::sys::raw::c_uint = 1;
pub const IPV6CTL_SENDREDIRECTS: ::kernel::sys::raw::c_uint = 2;
pub const IPV6CTL_DEFHLIM: ::kernel::sys::raw::c_uint = 3;
pub const IPV6CTL_FORWSRCRT: ::kernel::sys::raw::c_uint = 5;
pub const IPV6CTL_STATS: ::kernel::sys::raw::c_uint = 6;
pub const IPV6CTL_MRTSTATS: ::kernel::sys::raw::c_uint = 7;
pub const IPV6CTL_MRTPROTO: ::kernel::sys::raw::c_uint = 8;
pub const IPV6CTL_MAXFRAGPACKETS: ::kernel::sys::raw::c_uint = 9;
pub const IPV6CTL_SOURCECHECK: ::kernel::sys::raw::c_uint = 10;
pub const IPV6CTL_SOURCECHECK_LOGINT: ::kernel::sys::raw::c_uint = 11;
pub const IPV6CTL_ACCEPT_RTADV: ::kernel::sys::raw::c_uint = 12;
pub const IPV6CTL_LOG_INTERVAL: ::kernel::sys::raw::c_uint = 14;
pub const IPV6CTL_HDRNESTLIMIT: ::kernel::sys::raw::c_uint = 15;
pub const IPV6CTL_DAD_COUNT: ::kernel::sys::raw::c_uint = 16;
pub const IPV6CTL_AUTO_FLOWLABEL: ::kernel::sys::raw::c_uint = 17;
pub const IPV6CTL_DEFMCASTHLIM: ::kernel::sys::raw::c_uint = 18;
pub const IPV6CTL_GIF_HLIM: ::kernel::sys::raw::c_uint = 19;
pub const IPV6CTL_KAME_VERSION: ::kernel::sys::raw::c_uint = 20;
pub const IPV6CTL_USE_DEPRECATED: ::kernel::sys::raw::c_uint = 21;
pub const IPV6CTL_RR_PRUNE: ::kernel::sys::raw::c_uint = 22;
pub const IPV6CTL_V6ONLY: ::kernel::sys::raw::c_uint = 24;
pub const IPV6CTL_USETEMPADDR: ::kernel::sys::raw::c_uint = 32;
pub const IPV6CTL_TEMPPLTIME: ::kernel::sys::raw::c_uint = 33;
pub const IPV6CTL_TEMPVLTIME: ::kernel::sys::raw::c_uint = 34;
pub const IPV6CTL_AUTO_LINKLOCAL: ::kernel::sys::raw::c_uint = 35;
pub const IPV6CTL_RIP6STATS: ::kernel::sys::raw::c_uint = 36;
pub const IPV6CTL_PREFER_TEMPADDR: ::kernel::sys::raw::c_uint = 37;
pub const IPV6CTL_ADDRCTLPOLICY: ::kernel::sys::raw::c_uint = 38;
pub const IPV6CTL_USE_DEFAULTZONE: ::kernel::sys::raw::c_uint = 39;
pub const IPV6CTL_MAXFRAGS: ::kernel::sys::raw::c_uint = 41;
pub const IPV6CTL_MCAST_PMTU: ::kernel::sys::raw::c_uint = 44;
pub const IPV6CTL_STEALTH: ::kernel::sys::raw::c_uint = 45;
pub const ICMPV6CTL_ND6_ONLINKNSRFC4861: ::kernel::sys::raw::c_uint = 47;
pub const IPV6CTL_NO_RADR: ::kernel::sys::raw::c_uint = 48;
pub const IPV6CTL_NORBIT_RAIF: ::kernel::sys::raw::c_uint = 49;
pub const IPV6CTL_RFC6204W3: ::kernel::sys::raw::c_uint = 50;
pub const IPV6CTL_INTRQMAXLEN: ::kernel::sys::raw::c_uint = 51;
pub const IPV6CTL_INTRDQMAXLEN: ::kernel::sys::raw::c_uint = 52;
pub const IPV6CTL_MAXID: ::kernel::sys::raw::c_uint = 53;
pub const M_FASTFWD_OURS: ::kernel::sys::raw::c_uint = 4096;
pub const M_IP6_NEXTHOP: ::kernel::sys::raw::c_uint = 8192;
pub const M_IP_NEXTHOP: ::kernel::sys::raw::c_uint = 8192;
pub const M_SKIP_FIREWALL: ::kernel::sys::raw::c_uint = 16384;
pub const M_AUTHIPHDR: ::kernel::sys::raw::c_uint = 32768;
pub const M_DECRYPTED: ::kernel::sys::raw::c_uint = 65536;
pub const M_LOOP: ::kernel::sys::raw::c_uint = 131072;
pub const M_AUTHIPDGM: ::kernel::sys::raw::c_uint = 262144;
pub const M_RTALERT_MLD: ::kernel::sys::raw::c_uint = 524288;
pub const M_FRAGMENTED: ::kernel::sys::raw::c_uint = 1048576;
pub const SIN_PROXY: ::kernel::sys::raw::c_uint = 1;
pub const IPVERSION: ::kernel::sys::raw::c_uint = 4;
pub const IP_RF: ::kernel::sys::raw::c_uint = 32768;
pub const IP_DF: ::kernel::sys::raw::c_uint = 16384;
pub const IP_MF: ::kernel::sys::raw::c_uint = 8192;
pub const IP_OFFMASK: ::kernel::sys::raw::c_uint = 8191;
pub const IP_MAXPACKET: ::kernel::sys::raw::c_uint = 65535;
pub const IPTOS_LOWDELAY: ::kernel::sys::raw::c_uint = 16;
pub const IPTOS_THROUGHPUT: ::kernel::sys::raw::c_uint = 8;
pub const IPTOS_RELIABILITY: ::kernel::sys::raw::c_uint = 4;
pub const IPTOS_MINCOST: ::kernel::sys::raw::c_uint = 2;
pub const IPTOS_DSCP_CS0: ::kernel::sys::raw::c_uint = 0;
pub const IPTOS_DSCP_CS1: ::kernel::sys::raw::c_uint = 32;
pub const IPTOS_DSCP_AF11: ::kernel::sys::raw::c_uint = 40;
pub const IPTOS_DSCP_AF12: ::kernel::sys::raw::c_uint = 48;
pub const IPTOS_DSCP_AF13: ::kernel::sys::raw::c_uint = 56;
pub const IPTOS_DSCP_CS2: ::kernel::sys::raw::c_uint = 64;
pub const IPTOS_DSCP_AF21: ::kernel::sys::raw::c_uint = 72;
pub const IPTOS_DSCP_AF22: ::kernel::sys::raw::c_uint = 80;
pub const IPTOS_DSCP_AF23: ::kernel::sys::raw::c_uint = 88;
pub const IPTOS_DSCP_CS3: ::kernel::sys::raw::c_uint = 96;
pub const IPTOS_DSCP_AF31: ::kernel::sys::raw::c_uint = 104;
pub const IPTOS_DSCP_AF32: ::kernel::sys::raw::c_uint = 112;
pub const IPTOS_DSCP_AF33: ::kernel::sys::raw::c_uint = 120;
pub const IPTOS_DSCP_CS4: ::kernel::sys::raw::c_uint = 128;
pub const IPTOS_DSCP_AF41: ::kernel::sys::raw::c_uint = 136;
pub const IPTOS_DSCP_AF42: ::kernel::sys::raw::c_uint = 144;
pub const IPTOS_DSCP_AF43: ::kernel::sys::raw::c_uint = 152;
pub const IPTOS_DSCP_CS5: ::kernel::sys::raw::c_uint = 160;
pub const IPTOS_DSCP_VA: ::kernel::sys::raw::c_uint = 176;
pub const IPTOS_DSCP_EF: ::kernel::sys::raw::c_uint = 184;
pub const IPTOS_DSCP_CS6: ::kernel::sys::raw::c_uint = 192;
pub const IPTOS_DSCP_CS7: ::kernel::sys::raw::c_uint = 224;
pub const IPTOS_ECN_NOTECT: ::kernel::sys::raw::c_uint = 0;
pub const IPTOS_ECN_ECT1: ::kernel::sys::raw::c_uint = 1;
pub const IPTOS_ECN_ECT0: ::kernel::sys::raw::c_uint = 2;
pub const IPTOS_ECN_CE: ::kernel::sys::raw::c_uint = 3;
pub const IPTOS_ECN_MASK: ::kernel::sys::raw::c_uint = 3;
pub const IPOPT_CONTROL: ::kernel::sys::raw::c_uint = 0;
pub const IPOPT_RESERVED1: ::kernel::sys::raw::c_uint = 32;
pub const IPOPT_DEBMEAS: ::kernel::sys::raw::c_uint = 64;
pub const IPOPT_RESERVED2: ::kernel::sys::raw::c_uint = 96;
pub const IPOPT_EOL: ::kernel::sys::raw::c_uint = 0;
pub const IPOPT_NOP: ::kernel::sys::raw::c_uint = 1;
pub const IPOPT_RR: ::kernel::sys::raw::c_uint = 7;
pub const IPOPT_TS: ::kernel::sys::raw::c_uint = 68;
pub const IPOPT_SECURITY: ::kernel::sys::raw::c_uint = 130;
pub const IPOPT_LSRR: ::kernel::sys::raw::c_uint = 131;
pub const IPOPT_ESO: ::kernel::sys::raw::c_uint = 133;
pub const IPOPT_CIPSO: ::kernel::sys::raw::c_uint = 134;
pub const IPOPT_SATID: ::kernel::sys::raw::c_uint = 136;
pub const IPOPT_SSRR: ::kernel::sys::raw::c_uint = 137;
pub const IPOPT_RA: ::kernel::sys::raw::c_uint = 148;
pub const IPOPT_OPTVAL: ::kernel::sys::raw::c_uint = 0;
pub const IPOPT_OLEN: ::kernel::sys::raw::c_uint = 1;
pub const IPOPT_OFFSET: ::kernel::sys::raw::c_uint = 2;
pub const IPOPT_MINOFF: ::kernel::sys::raw::c_uint = 4;
pub const IPOPT_TS_TSONLY: ::kernel::sys::raw::c_uint = 0;
pub const IPOPT_TS_TSANDADDR: ::kernel::sys::raw::c_uint = 1;
pub const IPOPT_TS_PRESPEC: ::kernel::sys::raw::c_uint = 3;
pub const IPOPT_SECUR_UNCLASS: ::kernel::sys::raw::c_uint = 0;
pub const IPOPT_SECUR_CONFID: ::kernel::sys::raw::c_uint = 61749;
pub const IPOPT_SECUR_EFTO: ::kernel::sys::raw::c_uint = 30874;
pub const IPOPT_SECUR_MMMM: ::kernel::sys::raw::c_uint = 48205;
pub const IPOPT_SECUR_RESTR: ::kernel::sys::raw::c_uint = 44819;
pub const IPOPT_SECUR_SECRET: ::kernel::sys::raw::c_uint = 55176;
pub const IPOPT_SECUR_TOPSECRET: ::kernel::sys::raw::c_uint = 27589;
pub const MAXTTL: ::kernel::sys::raw::c_uint = 255;
pub const IPDEFTTL: ::kernel::sys::raw::c_uint = 64;
pub const IPFRAGTTL: ::kernel::sys::raw::c_uint = 60;
pub const IPTTLDEC: ::kernel::sys::raw::c_uint = 1;
pub const IP_MSS: ::kernel::sys::raw::c_uint = 576;
pub const IPV6_VERSION: ::kernel::sys::raw::c_uint = 96;
pub const IPV6_VERSION_MASK: ::kernel::sys::raw::c_uint = 240;
pub const IPV6_FLOWINFO_MASK: ::kernel::sys::raw::c_uint = 4294967055;
pub const IPV6_FLOWLABEL_MASK: ::kernel::sys::raw::c_uint = 4294905600;
pub const IP6TOS_CE: ::kernel::sys::raw::c_uint = 1;
pub const IP6TOS_ECT: ::kernel::sys::raw::c_uint = 2;
pub const IP6OPT_PAD1: ::kernel::sys::raw::c_uint = 0;
pub const IP6OPT_PADN: ::kernel::sys::raw::c_uint = 1;
pub const IP6OPT_JUMBO: ::kernel::sys::raw::c_uint = 194;
pub const IP6OPT_NSAP_ADDR: ::kernel::sys::raw::c_uint = 195;
pub const IP6OPT_TUNNEL_LIMIT: ::kernel::sys::raw::c_uint = 4;
pub const IP6OPT_ROUTER_ALERT: ::kernel::sys::raw::c_uint = 5;
pub const IP6OPT_RTALERT_LEN: ::kernel::sys::raw::c_uint = 4;
pub const IP6OPT_RTALERT_MLD: ::kernel::sys::raw::c_uint = 0;
pub const IP6OPT_RTALERT_RSVP: ::kernel::sys::raw::c_uint = 1;
pub const IP6OPT_RTALERT_ACTNET: ::kernel::sys::raw::c_uint = 2;
pub const IP6OPT_MINLEN: ::kernel::sys::raw::c_uint = 2;
pub const IP6OPT_EID: ::kernel::sys::raw::c_uint = 138;
pub const IP6OPT_TYPE_SKIP: ::kernel::sys::raw::c_uint = 0;
pub const IP6OPT_TYPE_DISCARD: ::kernel::sys::raw::c_uint = 64;
pub const IP6OPT_TYPE_FORCEICMP: ::kernel::sys::raw::c_uint = 128;
pub const IP6OPT_TYPE_ICMP: ::kernel::sys::raw::c_uint = 192;
pub const IP6OPT_MUTABLE: ::kernel::sys::raw::c_uint = 32;
pub const IP6OPT_JUMBO_LEN: ::kernel::sys::raw::c_uint = 6;
pub const IP6_ALERT_MLD: ::kernel::sys::raw::c_uint = 0;
pub const IP6_ALERT_RSVP: ::kernel::sys::raw::c_uint = 256;
pub const IP6_ALERT_AN: ::kernel::sys::raw::c_uint = 512;
pub const IP6F_OFF_MASK: ::kernel::sys::raw::c_uint = 63743;
pub const IP6F_RESERVED_MASK: ::kernel::sys::raw::c_uint = 1536;
pub const IP6F_MORE_FRAG: ::kernel::sys::raw::c_uint = 256;
pub const IPV6_MAXHLIM: ::kernel::sys::raw::c_uint = 255;
pub const IPV6_DEFHLIM: ::kernel::sys::raw::c_uint = 64;
pub const IPV6_FRAGTTL: ::kernel::sys::raw::c_uint = 120;
pub const IPV6_HLIMDEC: ::kernel::sys::raw::c_uint = 1;
pub const IPV6_MMTU: ::kernel::sys::raw::c_uint = 1280;
pub const IPV6_MAXPACKET: ::kernel::sys::raw::c_uint = 65535;
pub const IPV6_MAXOPTHDR: ::kernel::sys::raw::c_uint = 2048;
pub const TH_FIN: ::kernel::sys::raw::c_uint = 1;
pub const TH_SYN: ::kernel::sys::raw::c_uint = 2;
pub const TH_RST: ::kernel::sys::raw::c_uint = 4;
pub const TH_PUSH: ::kernel::sys::raw::c_uint = 8;
pub const TH_ACK: ::kernel::sys::raw::c_uint = 16;
pub const TH_URG: ::kernel::sys::raw::c_uint = 32;
pub const TH_ECE: ::kernel::sys::raw::c_uint = 64;
pub const TH_CWR: ::kernel::sys::raw::c_uint = 128;
pub const TH_FLAGS: ::kernel::sys::raw::c_uint = 255;
pub const PRINT_TH_FLAGS: &'static [u8; 43usize] =
    b"\x10\x01FIN\\2SYN\\3RST\\4PUSH\\5ACK\\6URG\\7ECE\\10CWR\x00";
pub const TCPOPT_EOL: ::kernel::sys::raw::c_uint = 0;
pub const TCPOLEN_EOL: ::kernel::sys::raw::c_uint = 1;
pub const TCPOPT_PAD: ::kernel::sys::raw::c_uint = 0;
pub const TCPOLEN_PAD: ::kernel::sys::raw::c_uint = 1;
pub const TCPOPT_NOP: ::kernel::sys::raw::c_uint = 1;
pub const TCPOLEN_NOP: ::kernel::sys::raw::c_uint = 1;
pub const TCPOPT_MAXSEG: ::kernel::sys::raw::c_uint = 2;
pub const TCPOLEN_MAXSEG: ::kernel::sys::raw::c_uint = 4;
pub const TCPOPT_WINDOW: ::kernel::sys::raw::c_uint = 3;
pub const TCPOLEN_WINDOW: ::kernel::sys::raw::c_uint = 3;
pub const TCPOPT_SACK_PERMITTED: ::kernel::sys::raw::c_uint = 4;
pub const TCPOLEN_SACK_PERMITTED: ::kernel::sys::raw::c_uint = 2;
pub const TCPOPT_SACK: ::kernel::sys::raw::c_uint = 5;
pub const TCPOLEN_SACKHDR: ::kernel::sys::raw::c_uint = 2;
pub const TCPOLEN_SACK: ::kernel::sys::raw::c_uint = 8;
pub const TCPOPT_TIMESTAMP: ::kernel::sys::raw::c_uint = 8;
pub const TCPOLEN_TIMESTAMP: ::kernel::sys::raw::c_uint = 10;
pub const TCPOLEN_TSTAMP_APPA: ::kernel::sys::raw::c_uint = 12;
pub const TCPOPT_SIGNATURE: ::kernel::sys::raw::c_uint = 19;
pub const TCPOLEN_SIGNATURE: ::kernel::sys::raw::c_uint = 18;
pub const TCPOPT_FAST_OPEN: ::kernel::sys::raw::c_uint = 34;
pub const TCPOLEN_FAST_OPEN_EMPTY: ::kernel::sys::raw::c_uint = 2;
pub const MAX_SACK_BLKS: ::kernel::sys::raw::c_uint = 6;
pub const TCP_MAX_SACK: ::kernel::sys::raw::c_uint = 4;
pub const TCP_MSS: ::kernel::sys::raw::c_uint = 536;
pub const TCP6_MSS: ::kernel::sys::raw::c_uint = 1220;
pub const TCP_MINMSS: ::kernel::sys::raw::c_uint = 216;
pub const TCP_MAXWIN: ::kernel::sys::raw::c_uint = 65535;
pub const TTCP_CLIENT_SND_WND: ::kernel::sys::raw::c_uint = 4096;
pub const TCP_MAX_WINSHIFT: ::kernel::sys::raw::c_uint = 14;
pub const TCP_MAXBURST: ::kernel::sys::raw::c_uint = 4;
pub const TCP_MAXHLEN: ::kernel::sys::raw::c_uint = 60;
pub const TCP_FASTOPEN_MIN_COOKIE_LEN: ::kernel::sys::raw::c_uint = 4;
pub const TCP_FASTOPEN_MAX_COOKIE_LEN: ::kernel::sys::raw::c_uint = 16;
pub const TCP_FASTOPEN_PSK_LEN: ::kernel::sys::raw::c_uint = 16;
pub const TCP_NODELAY: ::kernel::sys::raw::c_uint = 1;
pub const TCP_MAXSEG: ::kernel::sys::raw::c_uint = 2;
pub const TCP_NOPUSH: ::kernel::sys::raw::c_uint = 4;
pub const TCP_NOOPT: ::kernel::sys::raw::c_uint = 8;
pub const TCP_MD5SIG: ::kernel::sys::raw::c_uint = 16;
pub const TCP_INFO: ::kernel::sys::raw::c_uint = 32;
pub const TCP_LOG: ::kernel::sys::raw::c_uint = 34;
pub const TCP_LOGBUF: ::kernel::sys::raw::c_uint = 35;
pub const TCP_LOGID: ::kernel::sys::raw::c_uint = 36;
pub const TCP_LOGDUMP: ::kernel::sys::raw::c_uint = 37;
pub const TCP_LOGDUMPID: ::kernel::sys::raw::c_uint = 38;
pub const TCP_CONGESTION: ::kernel::sys::raw::c_uint = 64;
pub const TCP_CCALGOOPT: ::kernel::sys::raw::c_uint = 65;
pub const TCP_KEEPINIT: ::kernel::sys::raw::c_uint = 128;
pub const TCP_KEEPIDLE: ::kernel::sys::raw::c_uint = 256;
pub const TCP_KEEPINTVL: ::kernel::sys::raw::c_uint = 512;
pub const TCP_KEEPCNT: ::kernel::sys::raw::c_uint = 1024;
pub const TCP_FASTOPEN: ::kernel::sys::raw::c_uint = 1025;
pub const TCP_PCAP_OUT: ::kernel::sys::raw::c_uint = 2048;
pub const TCP_PCAP_IN: ::kernel::sys::raw::c_uint = 4096;
pub const TCP_FUNCTION_BLK: ::kernel::sys::raw::c_uint = 8192;
pub const TCP_VENDOR: ::kernel::sys::raw::c_uint = 2147483648;
pub const TCP_CA_NAME_MAX: ::kernel::sys::raw::c_uint = 16;
pub const TCPI_OPT_TIMESTAMPS: ::kernel::sys::raw::c_uint = 1;
pub const TCPI_OPT_SACK: ::kernel::sys::raw::c_uint = 2;
pub const TCPI_OPT_WSCALE: ::kernel::sys::raw::c_uint = 4;
pub const TCPI_OPT_ECN: ::kernel::sys::raw::c_uint = 8;
pub const TCPI_OPT_TOE: ::kernel::sys::raw::c_uint = 16;
pub const TCP_LOG_ID_LEN: ::kernel::sys::raw::c_uint = 64;
pub const TCP_FUNCTION_NAME_LEN_MAX: ::kernel::sys::raw::c_uint = 32;
pub const UDP_ENCAP: ::kernel::sys::raw::c_uint = 1;
pub const UDP_VENDOR: ::kernel::sys::raw::c_uint = 2147483648;
pub const UDP_ENCAP_ESPINUDP_NON_IKE: ::kernel::sys::raw::c_uint = 1;
pub const UDP_ENCAP_ESPINUDP: ::kernel::sys::raw::c_uint = 2;
pub const UDP_ENCAP_ESPINUDP_PORT: ::kernel::sys::raw::c_uint = 500;
pub const UDP_ENCAP_ESPINUDP_MAXFRAGLEN: ::kernel::sys::raw::c_uint = 552;
pub const _MACHINE_IN_CKSUM_H_: ::kernel::sys::raw::c_uint = 1;
pub const PCI_MAXMAPS_0: ::kernel::sys::raw::c_uint = 6;
pub const PCI_MAXMAPS_1: ::kernel::sys::raw::c_uint = 2;
pub const PCI_MAXMAPS_2: ::kernel::sys::raw::c_uint = 1;
pub const PCICFG_VF: ::kernel::sys::raw::c_uint = 1;
pub const PCI_INVALID_IRQ: ::kernel::sys::raw::c_uint = 255;
pub const PCI_POWERSTATE_D0: ::kernel::sys::raw::c_uint = 0;
pub const PCI_POWERSTATE_D1: ::kernel::sys::raw::c_uint = 1;
pub const PCI_POWERSTATE_D2: ::kernel::sys::raw::c_uint = 2;
pub const PCI_POWERSTATE_D3: ::kernel::sys::raw::c_uint = 3;
pub const PCI_POWERSTATE_UNKNOWN: ::kernel::sys::raw::c_int = -1;
pub const PCI_DMA_BOUNDARY: ::kernel::sys::raw::c_ulonglong = 4294967296;
pub const VGA_PCI_BIOS_SHADOW_ADDR: ::kernel::sys::raw::c_uint = 786432;
pub const VGA_PCI_BIOS_SHADOW_SIZE: ::kernel::sys::raw::c_uint = 131072;
pub const PCI_DOMAINMAX: ::kernel::sys::raw::c_uint = 65535;
pub const PCI_BUSMAX: ::kernel::sys::raw::c_uint = 255;
pub const PCI_SLOTMAX: ::kernel::sys::raw::c_uint = 31;
pub const PCI_FUNCMAX: ::kernel::sys::raw::c_uint = 7;
pub const PCI_REGMAX: ::kernel::sys::raw::c_uint = 255;
pub const PCIE_REGMAX: ::kernel::sys::raw::c_uint = 4095;
pub const PCI_MAXHDRTYPE: ::kernel::sys::raw::c_uint = 2;
pub const PCIE_ARI_SLOTMAX: ::kernel::sys::raw::c_uint = 0;
pub const PCIE_ARI_FUNCMAX: ::kernel::sys::raw::c_uint = 255;
pub const PCI_RID_DOMAIN_SHIFT: ::kernel::sys::raw::c_uint = 16;
pub const PCI_RID_BUS_SHIFT: ::kernel::sys::raw::c_uint = 8;
pub const PCI_RID_SLOT_SHIFT: ::kernel::sys::raw::c_uint = 3;
pub const PCI_RID_FUNC_SHIFT: ::kernel::sys::raw::c_uint = 0;
pub const PCIR_DEVVENDOR: ::kernel::sys::raw::c_uint = 0;
pub const PCIR_VENDOR: ::kernel::sys::raw::c_uint = 0;
pub const PCIR_DEVICE: ::kernel::sys::raw::c_uint = 2;
pub const PCIR_COMMAND: ::kernel::sys::raw::c_uint = 4;
pub const PCIM_CMD_PORTEN: ::kernel::sys::raw::c_uint = 1;
pub const PCIM_CMD_MEMEN: ::kernel::sys::raw::c_uint = 2;
pub const PCIM_CMD_BUSMASTEREN: ::kernel::sys::raw::c_uint = 4;
pub const PCIM_CMD_SPECIALEN: ::kernel::sys::raw::c_uint = 8;
pub const PCIM_CMD_MWRICEN: ::kernel::sys::raw::c_uint = 16;
pub const PCIM_CMD_PERRESPEN: ::kernel::sys::raw::c_uint = 64;
pub const PCIM_CMD_SERRESPEN: ::kernel::sys::raw::c_uint = 256;
pub const PCIM_CMD_BACKTOBACK: ::kernel::sys::raw::c_uint = 512;
pub const PCIM_CMD_INTxDIS: ::kernel::sys::raw::c_uint = 1024;
pub const PCIR_STATUS: ::kernel::sys::raw::c_uint = 6;
pub const PCIM_STATUS_INTxSTATE: ::kernel::sys::raw::c_uint = 8;
pub const PCIM_STATUS_CAPPRESENT: ::kernel::sys::raw::c_uint = 16;
pub const PCIM_STATUS_66CAPABLE: ::kernel::sys::raw::c_uint = 32;
pub const PCIM_STATUS_BACKTOBACK: ::kernel::sys::raw::c_uint = 128;
pub const PCIM_STATUS_MDPERR: ::kernel::sys::raw::c_uint = 256;
pub const PCIM_STATUS_SEL_FAST: ::kernel::sys::raw::c_uint = 0;
pub const PCIM_STATUS_SEL_MEDIMUM: ::kernel::sys::raw::c_uint = 512;
pub const PCIM_STATUS_SEL_SLOW: ::kernel::sys::raw::c_uint = 1024;
pub const PCIM_STATUS_SEL_MASK: ::kernel::sys::raw::c_uint = 1536;
pub const PCIM_STATUS_STABORT: ::kernel::sys::raw::c_uint = 2048;
pub const PCIM_STATUS_RTABORT: ::kernel::sys::raw::c_uint = 4096;
pub const PCIM_STATUS_RMABORT: ::kernel::sys::raw::c_uint = 8192;
pub const PCIM_STATUS_SERR: ::kernel::sys::raw::c_uint = 16384;
pub const PCIM_STATUS_PERR: ::kernel::sys::raw::c_uint = 32768;
pub const PCIR_REVID: ::kernel::sys::raw::c_uint = 8;
pub const PCIR_PROGIF: ::kernel::sys::raw::c_uint = 9;
pub const PCIR_SUBCLASS: ::kernel::sys::raw::c_uint = 10;
pub const PCIR_CLASS: ::kernel::sys::raw::c_uint = 11;
pub const PCIR_CACHELNSZ: ::kernel::sys::raw::c_uint = 12;
pub const PCIR_LATTIMER: ::kernel::sys::raw::c_uint = 13;
pub const PCIR_HDRTYPE: ::kernel::sys::raw::c_uint = 14;
pub const PCIM_HDRTYPE: ::kernel::sys::raw::c_uint = 127;
pub const PCIM_HDRTYPE_NORMAL: ::kernel::sys::raw::c_uint = 0;
pub const PCIM_HDRTYPE_BRIDGE: ::kernel::sys::raw::c_uint = 1;
pub const PCIM_HDRTYPE_CARDBUS: ::kernel::sys::raw::c_uint = 2;
pub const PCIM_MFDEV: ::kernel::sys::raw::c_uint = 128;
pub const PCIR_BIST: ::kernel::sys::raw::c_uint = 15;
pub const PCICAP_ID: ::kernel::sys::raw::c_uint = 0;
pub const PCICAP_NEXTPTR: ::kernel::sys::raw::c_uint = 1;
pub const PCIY_PMG: ::kernel::sys::raw::c_uint = 1;
pub const PCIY_AGP: ::kernel::sys::raw::c_uint = 2;
pub const PCIY_VPD: ::kernel::sys::raw::c_uint = 3;
pub const PCIY_SLOTID: ::kernel::sys::raw::c_uint = 4;
pub const PCIY_MSI: ::kernel::sys::raw::c_uint = 5;
pub const PCIY_CHSWP: ::kernel::sys::raw::c_uint = 6;
pub const PCIY_PCIX: ::kernel::sys::raw::c_uint = 7;
pub const PCIY_HT: ::kernel::sys::raw::c_uint = 8;
pub const PCIY_VENDOR: ::kernel::sys::raw::c_uint = 9;
pub const PCIY_DEBUG: ::kernel::sys::raw::c_uint = 10;
pub const PCIY_CRES: ::kernel::sys::raw::c_uint = 11;
pub const PCIY_HOTPLUG: ::kernel::sys::raw::c_uint = 12;
pub const PCIY_SUBVENDOR: ::kernel::sys::raw::c_uint = 13;
pub const PCIY_AGP8X: ::kernel::sys::raw::c_uint = 14;
pub const PCIY_SECDEV: ::kernel::sys::raw::c_uint = 15;
pub const PCIY_EXPRESS: ::kernel::sys::raw::c_uint = 16;
pub const PCIY_MSIX: ::kernel::sys::raw::c_uint = 17;
pub const PCIY_SATA: ::kernel::sys::raw::c_uint = 18;
pub const PCIY_PCIAF: ::kernel::sys::raw::c_uint = 19;
pub const PCIY_EA: ::kernel::sys::raw::c_uint = 20;
pub const PCIR_EXTCAP: ::kernel::sys::raw::c_uint = 256;
pub const PCIM_EXTCAP_ID: ::kernel::sys::raw::c_uint = 65535;
pub const PCIM_EXTCAP_VER: ::kernel::sys::raw::c_uint = 983040;
pub const PCIM_EXTCAP_NEXTPTR: ::kernel::sys::raw::c_uint = 4293918720;
pub const PCIZ_AER: ::kernel::sys::raw::c_uint = 1;
pub const PCIZ_VC: ::kernel::sys::raw::c_uint = 2;
pub const PCIZ_SERNUM: ::kernel::sys::raw::c_uint = 3;
pub const PCIZ_PWRBDGT: ::kernel::sys::raw::c_uint = 4;
pub const PCIZ_RCLINK_DCL: ::kernel::sys::raw::c_uint = 5;
pub const PCIZ_RCLINK_CTL: ::kernel::sys::raw::c_uint = 6;
pub const PCIZ_RCEC_ASSOC: ::kernel::sys::raw::c_uint = 7;
pub const PCIZ_MFVC: ::kernel::sys::raw::c_uint = 8;
pub const PCIZ_VC2: ::kernel::sys::raw::c_uint = 9;
pub const PCIZ_RCRB: ::kernel::sys::raw::c_uint = 10;
pub const PCIZ_VENDOR: ::kernel::sys::raw::c_uint = 11;
pub const PCIZ_CAC: ::kernel::sys::raw::c_uint = 12;
pub const PCIZ_ACS: ::kernel::sys::raw::c_uint = 13;
pub const PCIZ_ARI: ::kernel::sys::raw::c_uint = 14;
pub const PCIZ_ATS: ::kernel::sys::raw::c_uint = 15;
pub const PCIZ_SRIOV: ::kernel::sys::raw::c_uint = 16;
pub const PCIZ_MRIOV: ::kernel::sys::raw::c_uint = 17;
pub const PCIZ_MULTICAST: ::kernel::sys::raw::c_uint = 18;
pub const PCIZ_PAGE_REQ: ::kernel::sys::raw::c_uint = 19;
pub const PCIZ_AMD: ::kernel::sys::raw::c_uint = 20;
pub const PCIZ_RESIZE_BAR: ::kernel::sys::raw::c_uint = 21;
pub const PCIZ_DPA: ::kernel::sys::raw::c_uint = 22;
pub const PCIZ_TPH_REQ: ::kernel::sys::raw::c_uint = 23;
pub const PCIZ_LTR: ::kernel::sys::raw::c_uint = 24;
pub const PCIZ_SEC_PCIE: ::kernel::sys::raw::c_uint = 25;
pub const PCIZ_PMUX: ::kernel::sys::raw::c_uint = 26;
pub const PCIZ_PASID: ::kernel::sys::raw::c_uint = 27;
pub const PCIZ_LN_REQ: ::kernel::sys::raw::c_uint = 28;
pub const PCIZ_DPC: ::kernel::sys::raw::c_uint = 29;
pub const PCIZ_L1PM: ::kernel::sys::raw::c_uint = 30;
pub const PCIR_BARS: ::kernel::sys::raw::c_uint = 16;
pub const PCIR_MAX_BAR_0: ::kernel::sys::raw::c_uint = 5;
pub const PCIM_BAR_SPACE: ::kernel::sys::raw::c_uint = 1;
pub const PCIM_BAR_MEM_SPACE: ::kernel::sys::raw::c_uint = 0;
pub const PCIM_BAR_IO_SPACE: ::kernel::sys::raw::c_uint = 1;
pub const PCIM_BAR_MEM_TYPE: ::kernel::sys::raw::c_uint = 6;
pub const PCIM_BAR_MEM_32: ::kernel::sys::raw::c_uint = 0;
pub const PCIM_BAR_MEM_1MB: ::kernel::sys::raw::c_uint = 2;
pub const PCIM_BAR_MEM_64: ::kernel::sys::raw::c_uint = 4;
pub const PCIM_BAR_MEM_PREFETCH: ::kernel::sys::raw::c_uint = 8;
pub const PCIM_BAR_MEM_BASE: ::kernel::sys::raw::c_int = -16;
pub const PCIM_BAR_IO_RESERVED: ::kernel::sys::raw::c_uint = 2;
pub const PCIM_BAR_IO_BASE: ::kernel::sys::raw::c_uint = 4294967292;
pub const PCIR_CIS: ::kernel::sys::raw::c_uint = 40;
pub const PCIM_CIS_ASI_MASK: ::kernel::sys::raw::c_uint = 7;
pub const PCIM_CIS_ASI_CONFIG: ::kernel::sys::raw::c_uint = 0;
pub const PCIM_CIS_ASI_BAR0: ::kernel::sys::raw::c_uint = 1;
pub const PCIM_CIS_ASI_BAR1: ::kernel::sys::raw::c_uint = 2;
pub const PCIM_CIS_ASI_BAR2: ::kernel::sys::raw::c_uint = 3;
pub const PCIM_CIS_ASI_BAR3: ::kernel::sys::raw::c_uint = 4;
pub const PCIM_CIS_ASI_BAR4: ::kernel::sys::raw::c_uint = 5;
pub const PCIM_CIS_ASI_BAR5: ::kernel::sys::raw::c_uint = 6;
pub const PCIM_CIS_ASI_ROM: ::kernel::sys::raw::c_uint = 7;
pub const PCIM_CIS_ADDR_MASK: ::kernel::sys::raw::c_uint = 268435448;
pub const PCIM_CIS_ROM_MASK: ::kernel::sys::raw::c_uint = 4026531840;
pub const PCIM_CIS_CONFIG_MASK: ::kernel::sys::raw::c_uint = 255;
pub const PCIR_SUBVEND_0: ::kernel::sys::raw::c_uint = 44;
pub const PCIR_SUBDEV_0: ::kernel::sys::raw::c_uint = 46;
pub const PCIR_BIOS: ::kernel::sys::raw::c_uint = 48;
pub const PCIM_BIOS_ENABLE: ::kernel::sys::raw::c_uint = 1;
pub const PCIM_BIOS_ADDR_MASK: ::kernel::sys::raw::c_uint = 4294965248;
pub const PCIR_CAP_PTR: ::kernel::sys::raw::c_uint = 52;
pub const PCIR_INTLINE: ::kernel::sys::raw::c_uint = 60;
pub const PCIR_INTPIN: ::kernel::sys::raw::c_uint = 61;
pub const PCIR_MINGNT: ::kernel::sys::raw::c_uint = 62;
pub const PCIR_MAXLAT: ::kernel::sys::raw::c_uint = 63;
pub const PCIR_MAX_BAR_1: ::kernel::sys::raw::c_uint = 1;
pub const PCIR_SECSTAT_1: ::kernel::sys::raw::c_uint = 30;
pub const PCIR_PRIBUS_1: ::kernel::sys::raw::c_uint = 24;
pub const PCIR_SECBUS_1: ::kernel::sys::raw::c_uint = 25;
pub const PCIR_SUBBUS_1: ::kernel::sys::raw::c_uint = 26;
pub const PCIR_SECLAT_1: ::kernel::sys::raw::c_uint = 27;
pub const PCIR_IOBASEL_1: ::kernel::sys::raw::c_uint = 28;
pub const PCIR_IOLIMITL_1: ::kernel::sys::raw::c_uint = 29;
pub const PCIR_IOBASEH_1: ::kernel::sys::raw::c_uint = 48;
pub const PCIR_IOLIMITH_1: ::kernel::sys::raw::c_uint = 50;
pub const PCIM_BRIO_16: ::kernel::sys::raw::c_uint = 0;
pub const PCIM_BRIO_32: ::kernel::sys::raw::c_uint = 1;
pub const PCIM_BRIO_MASK: ::kernel::sys::raw::c_uint = 15;
pub const PCIR_MEMBASE_1: ::kernel::sys::raw::c_uint = 32;
pub const PCIR_MEMLIMIT_1: ::kernel::sys::raw::c_uint = 34;
pub const PCIR_PMBASEL_1: ::kernel::sys::raw::c_uint = 36;
pub const PCIR_PMLIMITL_1: ::kernel::sys::raw::c_uint = 38;
pub const PCIR_PMBASEH_1: ::kernel::sys::raw::c_uint = 40;
pub const PCIR_PMLIMITH_1: ::kernel::sys::raw::c_uint = 44;
pub const PCIM_BRPM_32: ::kernel::sys::raw::c_uint = 0;
pub const PCIM_BRPM_64: ::kernel::sys::raw::c_uint = 1;
pub const PCIM_BRPM_MASK: ::kernel::sys::raw::c_uint = 15;
pub const PCIR_BIOS_1: ::kernel::sys::raw::c_uint = 56;
pub const PCIR_BRIDGECTL_1: ::kernel::sys::raw::c_uint = 62;
pub const PCIR_MAX_BAR_2: ::kernel::sys::raw::c_uint = 0;
pub const PCIR_CAP_PTR_2: ::kernel::sys::raw::c_uint = 20;
pub const PCIR_SECSTAT_2: ::kernel::sys::raw::c_uint = 22;
pub const PCIR_PRIBUS_2: ::kernel::sys::raw::c_uint = 24;
pub const PCIR_SECBUS_2: ::kernel::sys::raw::c_uint = 25;
pub const PCIR_SUBBUS_2: ::kernel::sys::raw::c_uint = 26;
pub const PCIR_SECLAT_2: ::kernel::sys::raw::c_uint = 27;
pub const PCIR_MEMBASE0_2: ::kernel::sys::raw::c_uint = 28;
pub const PCIR_MEMLIMIT0_2: ::kernel::sys::raw::c_uint = 32;
pub const PCIR_MEMBASE1_2: ::kernel::sys::raw::c_uint = 36;
pub const PCIR_MEMLIMIT1_2: ::kernel::sys::raw::c_uint = 40;
pub const PCIR_IOBASE0_2: ::kernel::sys::raw::c_uint = 44;
pub const PCIR_IOLIMIT0_2: ::kernel::sys::raw::c_uint = 48;
pub const PCIR_IOBASE1_2: ::kernel::sys::raw::c_uint = 52;
pub const PCIR_IOLIMIT1_2: ::kernel::sys::raw::c_uint = 56;
pub const PCIM_CBBIO_16: ::kernel::sys::raw::c_uint = 0;
pub const PCIM_CBBIO_32: ::kernel::sys::raw::c_uint = 1;
pub const PCIM_CBBIO_MASK: ::kernel::sys::raw::c_uint = 3;
pub const PCIR_BRIDGECTL_2: ::kernel::sys::raw::c_uint = 62;
pub const PCIR_SUBVEND_2: ::kernel::sys::raw::c_uint = 64;
pub const PCIR_SUBDEV_2: ::kernel::sys::raw::c_uint = 66;
pub const PCIR_PCCARDIF_2: ::kernel::sys::raw::c_uint = 68;
pub const PCIC_OLD: ::kernel::sys::raw::c_uint = 0;
pub const PCIS_OLD_NONVGA: ::kernel::sys::raw::c_uint = 0;
pub const PCIS_OLD_VGA: ::kernel::sys::raw::c_uint = 1;
pub const PCIC_STORAGE: ::kernel::sys::raw::c_uint = 1;
pub const PCIS_STORAGE_SCSI: ::kernel::sys::raw::c_uint = 0;
pub const PCIS_STORAGE_IDE: ::kernel::sys::raw::c_uint = 1;
pub const PCIP_STORAGE_IDE_MODEPRIM: ::kernel::sys::raw::c_uint = 1;
pub const PCIP_STORAGE_IDE_PROGINDPRIM: ::kernel::sys::raw::c_uint = 2;
pub const PCIP_STORAGE_IDE_MODESEC: ::kernel::sys::raw::c_uint = 4;
pub const PCIP_STORAGE_IDE_PROGINDSEC: ::kernel::sys::raw::c_uint = 8;
pub const PCIP_STORAGE_IDE_MASTERDEV: ::kernel::sys::raw::c_uint = 128;
pub const PCIS_STORAGE_FLOPPY: ::kernel::sys::raw::c_uint = 2;
pub const PCIS_STORAGE_IPI: ::kernel::sys::raw::c_uint = 3;
pub const PCIS_STORAGE_RAID: ::kernel::sys::raw::c_uint = 4;
pub const PCIS_STORAGE_ATA_ADMA: ::kernel::sys::raw::c_uint = 5;
pub const PCIS_STORAGE_SATA: ::kernel::sys::raw::c_uint = 6;
pub const PCIP_STORAGE_SATA_AHCI_1_0: ::kernel::sys::raw::c_uint = 1;
pub const PCIS_STORAGE_SAS: ::kernel::sys::raw::c_uint = 7;
pub const PCIS_STORAGE_NVM: ::kernel::sys::raw::c_uint = 8;
pub const PCIP_STORAGE_NVM_NVMHCI_1_0: ::kernel::sys::raw::c_uint = 1;
pub const PCIP_STORAGE_NVM_ENTERPRISE_NVMHCI_1_0: ::kernel::sys::raw::c_uint =
    2;
pub const PCIS_STORAGE_OTHER: ::kernel::sys::raw::c_uint = 128;
pub const PCIC_NETWORK: ::kernel::sys::raw::c_uint = 2;
pub const PCIS_NETWORK_ETHERNET: ::kernel::sys::raw::c_uint = 0;
pub const PCIS_NETWORK_TOKENRING: ::kernel::sys::raw::c_uint = 1;
pub const PCIS_NETWORK_FDDI: ::kernel::sys::raw::c_uint = 2;
pub const PCIS_NETWORK_ATM: ::kernel::sys::raw::c_uint = 3;
pub const PCIS_NETWORK_ISDN: ::kernel::sys::raw::c_uint = 4;
pub const PCIS_NETWORK_WORLDFIP: ::kernel::sys::raw::c_uint = 5;
pub const PCIS_NETWORK_PICMG: ::kernel::sys::raw::c_uint = 6;
pub const PCIS_NETWORK_OTHER: ::kernel::sys::raw::c_uint = 128;
pub const PCIC_DISPLAY: ::kernel::sys::raw::c_uint = 3;
pub const PCIS_DISPLAY_VGA: ::kernel::sys::raw::c_uint = 0;
pub const PCIS_DISPLAY_XGA: ::kernel::sys::raw::c_uint = 1;
pub const PCIS_DISPLAY_3D: ::kernel::sys::raw::c_uint = 2;
pub const PCIS_DISPLAY_OTHER: ::kernel::sys::raw::c_uint = 128;
pub const PCIC_MULTIMEDIA: ::kernel::sys::raw::c_uint = 4;
pub const PCIS_MULTIMEDIA_VIDEO: ::kernel::sys::raw::c_uint = 0;
pub const PCIS_MULTIMEDIA_AUDIO: ::kernel::sys::raw::c_uint = 1;
pub const PCIS_MULTIMEDIA_TELE: ::kernel::sys::raw::c_uint = 2;
pub const PCIS_MULTIMEDIA_HDA: ::kernel::sys::raw::c_uint = 3;
pub const PCIS_MULTIMEDIA_OTHER: ::kernel::sys::raw::c_uint = 128;
pub const PCIC_MEMORY: ::kernel::sys::raw::c_uint = 5;
pub const PCIS_MEMORY_RAM: ::kernel::sys::raw::c_uint = 0;
pub const PCIS_MEMORY_FLASH: ::kernel::sys::raw::c_uint = 1;
pub const PCIS_MEMORY_OTHER: ::kernel::sys::raw::c_uint = 128;
pub const PCIC_BRIDGE: ::kernel::sys::raw::c_uint = 6;
pub const PCIS_BRIDGE_HOST: ::kernel::sys::raw::c_uint = 0;
pub const PCIS_BRIDGE_ISA: ::kernel::sys::raw::c_uint = 1;
pub const PCIS_BRIDGE_EISA: ::kernel::sys::raw::c_uint = 2;
pub const PCIS_BRIDGE_MCA: ::kernel::sys::raw::c_uint = 3;
pub const PCIS_BRIDGE_PCI: ::kernel::sys::raw::c_uint = 4;
pub const PCIP_BRIDGE_PCI_SUBTRACTIVE: ::kernel::sys::raw::c_uint = 1;
pub const PCIS_BRIDGE_PCMCIA: ::kernel::sys::raw::c_uint = 5;
pub const PCIS_BRIDGE_NUBUS: ::kernel::sys::raw::c_uint = 6;
pub const PCIS_BRIDGE_CARDBUS: ::kernel::sys::raw::c_uint = 7;
pub const PCIS_BRIDGE_RACEWAY: ::kernel::sys::raw::c_uint = 8;
pub const PCIS_BRIDGE_PCI_TRANSPARENT: ::kernel::sys::raw::c_uint = 9;
pub const PCIS_BRIDGE_INFINIBAND: ::kernel::sys::raw::c_uint = 10;
pub const PCIS_BRIDGE_OTHER: ::kernel::sys::raw::c_uint = 128;
pub const PCIC_SIMPLECOMM: ::kernel::sys::raw::c_uint = 7;
pub const PCIS_SIMPLECOMM_UART: ::kernel::sys::raw::c_uint = 0;
pub const PCIP_SIMPLECOMM_UART_8250: ::kernel::sys::raw::c_uint = 0;
pub const PCIP_SIMPLECOMM_UART_16450A: ::kernel::sys::raw::c_uint = 1;
pub const PCIP_SIMPLECOMM_UART_16550A: ::kernel::sys::raw::c_uint = 2;
pub const PCIP_SIMPLECOMM_UART_16650A: ::kernel::sys::raw::c_uint = 3;
pub const PCIP_SIMPLECOMM_UART_16750A: ::kernel::sys::raw::c_uint = 4;
pub const PCIP_SIMPLECOMM_UART_16850A: ::kernel::sys::raw::c_uint = 5;
pub const PCIP_SIMPLECOMM_UART_16950A: ::kernel::sys::raw::c_uint = 6;
pub const PCIS_SIMPLECOMM_PAR: ::kernel::sys::raw::c_uint = 1;
pub const PCIS_SIMPLECOMM_MULSER: ::kernel::sys::raw::c_uint = 2;
pub const PCIS_SIMPLECOMM_MODEM: ::kernel::sys::raw::c_uint = 3;
pub const PCIS_SIMPLECOMM_GPIB: ::kernel::sys::raw::c_uint = 4;
pub const PCIS_SIMPLECOMM_SMART_CARD: ::kernel::sys::raw::c_uint = 5;
pub const PCIS_SIMPLECOMM_OTHER: ::kernel::sys::raw::c_uint = 128;
pub const PCIC_BASEPERIPH: ::kernel::sys::raw::c_uint = 8;
pub const PCIS_BASEPERIPH_PIC: ::kernel::sys::raw::c_uint = 0;
pub const PCIP_BASEPERIPH_PIC_8259A: ::kernel::sys::raw::c_uint = 0;
pub const PCIP_BASEPERIPH_PIC_ISA: ::kernel::sys::raw::c_uint = 1;
pub const PCIP_BASEPERIPH_PIC_EISA: ::kernel::sys::raw::c_uint = 2;
pub const PCIP_BASEPERIPH_PIC_IO_APIC: ::kernel::sys::raw::c_uint = 16;
pub const PCIP_BASEPERIPH_PIC_IOX_APIC: ::kernel::sys::raw::c_uint = 32;
pub const PCIS_BASEPERIPH_DMA: ::kernel::sys::raw::c_uint = 1;
pub const PCIS_BASEPERIPH_TIMER: ::kernel::sys::raw::c_uint = 2;
pub const PCIS_BASEPERIPH_RTC: ::kernel::sys::raw::c_uint = 3;
pub const PCIS_BASEPERIPH_PCIHOT: ::kernel::sys::raw::c_uint = 4;
pub const PCIS_BASEPERIPH_SDHC: ::kernel::sys::raw::c_uint = 5;
pub const PCIS_BASEPERIPH_IOMMU: ::kernel::sys::raw::c_uint = 6;
pub const PCIS_BASEPERIPH_OTHER: ::kernel::sys::raw::c_uint = 128;
pub const PCIC_INPUTDEV: ::kernel::sys::raw::c_uint = 9;
pub const PCIS_INPUTDEV_KEYBOARD: ::kernel::sys::raw::c_uint = 0;
pub const PCIS_INPUTDEV_DIGITIZER: ::kernel::sys::raw::c_uint = 1;
pub const PCIS_INPUTDEV_MOUSE: ::kernel::sys::raw::c_uint = 2;
pub const PCIS_INPUTDEV_SCANNER: ::kernel::sys::raw::c_uint = 3;
pub const PCIS_INPUTDEV_GAMEPORT: ::kernel::sys::raw::c_uint = 4;
pub const PCIS_INPUTDEV_OTHER: ::kernel::sys::raw::c_uint = 128;
pub const PCIC_DOCKING: ::kernel::sys::raw::c_uint = 10;
pub const PCIS_DOCKING_GENERIC: ::kernel::sys::raw::c_uint = 0;
pub const PCIS_DOCKING_OTHER: ::kernel::sys::raw::c_uint = 128;
pub const PCIC_PROCESSOR: ::kernel::sys::raw::c_uint = 11;
pub const PCIS_PROCESSOR_386: ::kernel::sys::raw::c_uint = 0;
pub const PCIS_PROCESSOR_486: ::kernel::sys::raw::c_uint = 1;
pub const PCIS_PROCESSOR_PENTIUM: ::kernel::sys::raw::c_uint = 2;
pub const PCIS_PROCESSOR_ALPHA: ::kernel::sys::raw::c_uint = 16;
pub const PCIS_PROCESSOR_POWERPC: ::kernel::sys::raw::c_uint = 32;
pub const PCIS_PROCESSOR_MIPS: ::kernel::sys::raw::c_uint = 48;
pub const PCIS_PROCESSOR_COPROC: ::kernel::sys::raw::c_uint = 64;
pub const PCIC_SERIALBUS: ::kernel::sys::raw::c_uint = 12;
pub const PCIS_SERIALBUS_FW: ::kernel::sys::raw::c_uint = 0;
pub const PCIS_SERIALBUS_ACCESS: ::kernel::sys::raw::c_uint = 1;
pub const PCIS_SERIALBUS_SSA: ::kernel::sys::raw::c_uint = 2;
pub const PCIS_SERIALBUS_USB: ::kernel::sys::raw::c_uint = 3;
pub const PCIP_SERIALBUS_USB_UHCI: ::kernel::sys::raw::c_uint = 0;
pub const PCIP_SERIALBUS_USB_OHCI: ::kernel::sys::raw::c_uint = 16;
pub const PCIP_SERIALBUS_USB_EHCI: ::kernel::sys::raw::c_uint = 32;
pub const PCIP_SERIALBUS_USB_XHCI: ::kernel::sys::raw::c_uint = 48;
pub const PCIP_SERIALBUS_USB_DEVICE: ::kernel::sys::raw::c_uint = 254;
pub const PCIS_SERIALBUS_FC: ::kernel::sys::raw::c_uint = 4;
pub const PCIS_SERIALBUS_SMBUS: ::kernel::sys::raw::c_uint = 5;
pub const PCIS_SERIALBUS_INFINIBAND: ::kernel::sys::raw::c_uint = 6;
pub const PCIS_SERIALBUS_IPMI: ::kernel::sys::raw::c_uint = 7;
pub const PCIP_SERIALBUS_IPMI_SMIC: ::kernel::sys::raw::c_uint = 0;
pub const PCIP_SERIALBUS_IPMI_KCS: ::kernel::sys::raw::c_uint = 1;
pub const PCIP_SERIALBUS_IPMI_BT: ::kernel::sys::raw::c_uint = 2;
pub const PCIS_SERIALBUS_SERCOS: ::kernel::sys::raw::c_uint = 8;
pub const PCIS_SERIALBUS_CANBUS: ::kernel::sys::raw::c_uint = 9;
pub const PCIC_WIRELESS: ::kernel::sys::raw::c_uint = 13;
pub const PCIS_WIRELESS_IRDA: ::kernel::sys::raw::c_uint = 0;
pub const PCIS_WIRELESS_IR: ::kernel::sys::raw::c_uint = 1;
pub const PCIS_WIRELESS_RF: ::kernel::sys::raw::c_uint = 16;
pub const PCIS_WIRELESS_BLUETOOTH: ::kernel::sys::raw::c_uint = 17;
pub const PCIS_WIRELESS_BROADBAND: ::kernel::sys::raw::c_uint = 18;
pub const PCIS_WIRELESS_80211A: ::kernel::sys::raw::c_uint = 32;
pub const PCIS_WIRELESS_80211B: ::kernel::sys::raw::c_uint = 33;
pub const PCIS_WIRELESS_OTHER: ::kernel::sys::raw::c_uint = 128;
pub const PCIC_INTELLIIO: ::kernel::sys::raw::c_uint = 14;
pub const PCIS_INTELLIIO_I2O: ::kernel::sys::raw::c_uint = 0;
pub const PCIC_SATCOM: ::kernel::sys::raw::c_uint = 15;
pub const PCIS_SATCOM_TV: ::kernel::sys::raw::c_uint = 1;
pub const PCIS_SATCOM_AUDIO: ::kernel::sys::raw::c_uint = 2;
pub const PCIS_SATCOM_VOICE: ::kernel::sys::raw::c_uint = 3;
pub const PCIS_SATCOM_DATA: ::kernel::sys::raw::c_uint = 4;
pub const PCIC_CRYPTO: ::kernel::sys::raw::c_uint = 16;
pub const PCIS_CRYPTO_NETCOMP: ::kernel::sys::raw::c_uint = 0;
pub const PCIS_CRYPTO_ENTERTAIN: ::kernel::sys::raw::c_uint = 16;
pub const PCIS_CRYPTO_OTHER: ::kernel::sys::raw::c_uint = 128;
pub const PCIC_DASP: ::kernel::sys::raw::c_uint = 17;
pub const PCIS_DASP_DPIO: ::kernel::sys::raw::c_uint = 0;
pub const PCIS_DASP_PERFCNTRS: ::kernel::sys::raw::c_uint = 1;
pub const PCIS_DASP_COMM_SYNC: ::kernel::sys::raw::c_uint = 16;
pub const PCIS_DASP_MGMT_CARD: ::kernel::sys::raw::c_uint = 32;
pub const PCIS_DASP_OTHER: ::kernel::sys::raw::c_uint = 128;
pub const PCIC_ACCEL: ::kernel::sys::raw::c_uint = 18;
pub const PCIS_ACCEL_PROCESSING: ::kernel::sys::raw::c_uint = 0;
pub const PCIC_INSTRUMENT: ::kernel::sys::raw::c_uint = 19;
pub const PCIC_OTHER: ::kernel::sys::raw::c_uint = 255;
pub const PCIB_BCR_PERR_ENABLE: ::kernel::sys::raw::c_uint = 1;
pub const PCIB_BCR_SERR_ENABLE: ::kernel::sys::raw::c_uint = 2;
pub const PCIB_BCR_ISA_ENABLE: ::kernel::sys::raw::c_uint = 4;
pub const PCIB_BCR_VGA_ENABLE: ::kernel::sys::raw::c_uint = 8;
pub const PCIB_BCR_MASTER_ABORT_MODE: ::kernel::sys::raw::c_uint = 32;
pub const PCIB_BCR_SECBUS_RESET: ::kernel::sys::raw::c_uint = 64;
pub const PCIB_BCR_SECBUS_BACKTOBACK: ::kernel::sys::raw::c_uint = 128;
pub const PCIB_BCR_PRI_DISCARD_TIMEOUT: ::kernel::sys::raw::c_uint = 256;
pub const PCIB_BCR_SEC_DISCARD_TIMEOUT: ::kernel::sys::raw::c_uint = 512;
pub const PCIB_BCR_DISCARD_TIMER_STATUS: ::kernel::sys::raw::c_uint = 1024;
pub const PCIB_BCR_DISCARD_TIMER_SERREN: ::kernel::sys::raw::c_uint = 2048;
pub const CBB_BCR_PERR_ENABLE: ::kernel::sys::raw::c_uint = 1;
pub const CBB_BCR_SERR_ENABLE: ::kernel::sys::raw::c_uint = 2;
pub const CBB_BCR_ISA_ENABLE: ::kernel::sys::raw::c_uint = 4;
pub const CBB_BCR_VGA_ENABLE: ::kernel::sys::raw::c_uint = 8;
pub const CBB_BCR_MASTER_ABORT_MODE: ::kernel::sys::raw::c_uint = 32;
pub const CBB_BCR_CARDBUS_RESET: ::kernel::sys::raw::c_uint = 64;
pub const CBB_BCR_IREQ_INT_ENABLE: ::kernel::sys::raw::c_uint = 128;
pub const CBB_BCR_PREFETCH_0_ENABLE: ::kernel::sys::raw::c_uint = 256;
pub const CBB_BCR_PREFETCH_1_ENABLE: ::kernel::sys::raw::c_uint = 512;
pub const CBB_BCR_WRITE_POSTING_ENABLE: ::kernel::sys::raw::c_uint = 1024;
pub const PCIR_POWER_CAP: ::kernel::sys::raw::c_uint = 2;
pub const PCIM_PCAP_SPEC: ::kernel::sys::raw::c_uint = 7;
pub const PCIM_PCAP_PMEREQCLK: ::kernel::sys::raw::c_uint = 8;
pub const PCIM_PCAP_DEVSPECINIT: ::kernel::sys::raw::c_uint = 32;
pub const PCIM_PCAP_AUXPWR_0: ::kernel::sys::raw::c_uint = 0;
pub const PCIM_PCAP_AUXPWR_55: ::kernel::sys::raw::c_uint = 64;
pub const PCIM_PCAP_AUXPWR_100: ::kernel::sys::raw::c_uint = 128;
pub const PCIM_PCAP_AUXPWR_160: ::kernel::sys::raw::c_uint = 192;
pub const PCIM_PCAP_AUXPWR_220: ::kernel::sys::raw::c_uint = 256;
pub const PCIM_PCAP_AUXPWR_270: ::kernel::sys::raw::c_uint = 320;
pub const PCIM_PCAP_AUXPWR_320: ::kernel::sys::raw::c_uint = 384;
pub const PCIM_PCAP_AUXPWR_375: ::kernel::sys::raw::c_uint = 448;
pub const PCIM_PCAP_AUXPWRMASK: ::kernel::sys::raw::c_uint = 448;
pub const PCIM_PCAP_D1SUPP: ::kernel::sys::raw::c_uint = 512;
pub const PCIM_PCAP_D2SUPP: ::kernel::sys::raw::c_uint = 1024;
pub const PCIM_PCAP_D0PME: ::kernel::sys::raw::c_uint = 2048;
pub const PCIM_PCAP_D1PME: ::kernel::sys::raw::c_uint = 4096;
pub const PCIM_PCAP_D2PME: ::kernel::sys::raw::c_uint = 8192;
pub const PCIM_PCAP_D3PME_HOT: ::kernel::sys::raw::c_uint = 16384;
pub const PCIM_PCAP_D3PME_COLD: ::kernel::sys::raw::c_uint = 32768;
pub const PCIR_POWER_STATUS: ::kernel::sys::raw::c_uint = 4;
pub const PCIM_PSTAT_D0: ::kernel::sys::raw::c_uint = 0;
pub const PCIM_PSTAT_D1: ::kernel::sys::raw::c_uint = 1;
pub const PCIM_PSTAT_D2: ::kernel::sys::raw::c_uint = 2;
pub const PCIM_PSTAT_D3: ::kernel::sys::raw::c_uint = 3;
pub const PCIM_PSTAT_DMASK: ::kernel::sys::raw::c_uint = 3;
pub const PCIM_PSTAT_NOSOFTRESET: ::kernel::sys::raw::c_uint = 8;
pub const PCIM_PSTAT_PMEENABLE: ::kernel::sys::raw::c_uint = 256;
pub const PCIM_PSTAT_D0POWER: ::kernel::sys::raw::c_uint = 0;
pub const PCIM_PSTAT_D1POWER: ::kernel::sys::raw::c_uint = 512;
pub const PCIM_PSTAT_D2POWER: ::kernel::sys::raw::c_uint = 1024;
pub const PCIM_PSTAT_D3POWER: ::kernel::sys::raw::c_uint = 1536;
pub const PCIM_PSTAT_D0HEAT: ::kernel::sys::raw::c_uint = 2048;
pub const PCIM_PSTAT_D1HEAT: ::kernel::sys::raw::c_uint = 2560;
pub const PCIM_PSTAT_D2HEAT: ::kernel::sys::raw::c_uint = 3072;
pub const PCIM_PSTAT_D3HEAT: ::kernel::sys::raw::c_uint = 3584;
pub const PCIM_PSTAT_DATASELMASK: ::kernel::sys::raw::c_uint = 7680;
pub const PCIM_PSTAT_DATAUNKN: ::kernel::sys::raw::c_uint = 0;
pub const PCIM_PSTAT_DATADIV10: ::kernel::sys::raw::c_uint = 8192;
pub const PCIM_PSTAT_DATADIV100: ::kernel::sys::raw::c_uint = 16384;
pub const PCIM_PSTAT_DATADIV1000: ::kernel::sys::raw::c_uint = 24576;
pub const PCIM_PSTAT_DATADIVMASK: ::kernel::sys::raw::c_uint = 24576;
pub const PCIM_PSTAT_PME: ::kernel::sys::raw::c_uint = 32768;
pub const PCIR_POWER_BSE: ::kernel::sys::raw::c_uint = 6;
pub const PCIM_PMCSR_BSE_D3B3: ::kernel::sys::raw::c_uint = 0;
pub const PCIM_PMCSR_BSE_D3B2: ::kernel::sys::raw::c_uint = 64;
pub const PCIM_PMCSR_BSE_BPCCE: ::kernel::sys::raw::c_uint = 128;
pub const PCIR_POWER_DATA: ::kernel::sys::raw::c_uint = 7;
pub const PCIR_VPD_ADDR: ::kernel::sys::raw::c_uint = 2;
pub const PCIR_VPD_DATA: ::kernel::sys::raw::c_uint = 4;
pub const PCIR_MSI_CTRL: ::kernel::sys::raw::c_uint = 2;
pub const PCIM_MSICTRL_VECTOR: ::kernel::sys::raw::c_uint = 256;
pub const PCIM_MSICTRL_64BIT: ::kernel::sys::raw::c_uint = 128;
pub const PCIM_MSICTRL_MME_MASK: ::kernel::sys::raw::c_uint = 112;
pub const PCIM_MSICTRL_MME_1: ::kernel::sys::raw::c_uint = 0;
pub const PCIM_MSICTRL_MME_2: ::kernel::sys::raw::c_uint = 16;
pub const PCIM_MSICTRL_MME_4: ::kernel::sys::raw::c_uint = 32;
pub const PCIM_MSICTRL_MME_8: ::kernel::sys::raw::c_uint = 48;
pub const PCIM_MSICTRL_MME_16: ::kernel::sys::raw::c_uint = 64;
pub const PCIM_MSICTRL_MME_32: ::kernel::sys::raw::c_uint = 80;
pub const PCIM_MSICTRL_MMC_MASK: ::kernel::sys::raw::c_uint = 14;
pub const PCIM_MSICTRL_MMC_1: ::kernel::sys::raw::c_uint = 0;
pub const PCIM_MSICTRL_MMC_2: ::kernel::sys::raw::c_uint = 2;
pub const PCIM_MSICTRL_MMC_4: ::kernel::sys::raw::c_uint = 4;
pub const PCIM_MSICTRL_MMC_8: ::kernel::sys::raw::c_uint = 6;
pub const PCIM_MSICTRL_MMC_16: ::kernel::sys::raw::c_uint = 8;
pub const PCIM_MSICTRL_MMC_32: ::kernel::sys::raw::c_uint = 10;
pub const PCIM_MSICTRL_MSI_ENABLE: ::kernel::sys::raw::c_uint = 1;
pub const PCIR_MSI_ADDR: ::kernel::sys::raw::c_uint = 4;
pub const PCIR_MSI_ADDR_HIGH: ::kernel::sys::raw::c_uint = 8;
pub const PCIR_MSI_DATA: ::kernel::sys::raw::c_uint = 8;
pub const PCIR_MSI_DATA_64BIT: ::kernel::sys::raw::c_uint = 12;
pub const PCIR_MSI_MASK: ::kernel::sys::raw::c_uint = 16;
pub const PCIR_MSI_PENDING: ::kernel::sys::raw::c_uint = 20;
pub const PCIR_EA_NUM_ENT: ::kernel::sys::raw::c_uint = 2;
pub const PCIM_EA_NUM_ENT_MASK: ::kernel::sys::raw::c_uint = 63;
pub const PCIR_EA_FIRST_ENT: ::kernel::sys::raw::c_uint = 4;
pub const PCIR_EA_FIRST_ENT_BRIDGE: ::kernel::sys::raw::c_uint = 8;
pub const PCIM_EA_ES: ::kernel::sys::raw::c_uint = 7;
pub const PCIM_EA_BEI: ::kernel::sys::raw::c_uint = 240;
pub const PCIM_EA_BEI_OFFSET: ::kernel::sys::raw::c_uint = 4;
pub const PCIM_EA_BEI_BAR_0: ::kernel::sys::raw::c_uint = 0;
pub const PCIM_EA_BEI_BAR_5: ::kernel::sys::raw::c_uint = 5;
pub const PCIM_EA_BEI_BRIDGE: ::kernel::sys::raw::c_uint = 6;
pub const PCIM_EA_BEI_ENI: ::kernel::sys::raw::c_uint = 7;
pub const PCIM_EA_BEI_ROM: ::kernel::sys::raw::c_uint = 8;
pub const PCIM_EA_BEI_VF_BAR_0: ::kernel::sys::raw::c_uint = 9;
pub const PCIM_EA_BEI_VF_BAR_5: ::kernel::sys::raw::c_uint = 14;
pub const PCIM_EA_BEI_RESERVED: ::kernel::sys::raw::c_uint = 15;
pub const PCIM_EA_PP: ::kernel::sys::raw::c_uint = 65280;
pub const PCIM_EA_PP_OFFSET: ::kernel::sys::raw::c_uint = 8;
pub const PCIM_EA_SP_OFFSET: ::kernel::sys::raw::c_uint = 16;
pub const PCIM_EA_SP: ::kernel::sys::raw::c_uint = 16711680;
pub const PCIM_EA_P_MEM: ::kernel::sys::raw::c_uint = 0;
pub const PCIM_EA_P_MEM_PREFETCH: ::kernel::sys::raw::c_uint = 1;
pub const PCIM_EA_P_IO: ::kernel::sys::raw::c_uint = 2;
pub const PCIM_EA_P_VF_MEM_PREFETCH: ::kernel::sys::raw::c_uint = 3;
pub const PCIM_EA_P_VF_MEM: ::kernel::sys::raw::c_uint = 4;
pub const PCIM_EA_P_BRIDGE_MEM: ::kernel::sys::raw::c_uint = 5;
pub const PCIM_EA_P_BRIDGE_MEM_PREFETCH: ::kernel::sys::raw::c_uint = 6;
pub const PCIM_EA_P_BRIDGE_IO: ::kernel::sys::raw::c_uint = 7;
pub const PCIM_EA_P_MEM_RESERVED: ::kernel::sys::raw::c_uint = 253;
pub const PCIM_EA_P_IO_RESERVED: ::kernel::sys::raw::c_uint = 254;
pub const PCIM_EA_P_UNAVAILABLE: ::kernel::sys::raw::c_uint = 255;
pub const PCIM_EA_WRITABLE: ::kernel::sys::raw::c_uint = 1073741824;
pub const PCIM_EA_ENABLE: ::kernel::sys::raw::c_uint = 2147483648;
pub const PCIM_EA_BASE: ::kernel::sys::raw::c_uint = 4;
pub const PCIM_EA_MAX_OFFSET: ::kernel::sys::raw::c_uint = 8;
pub const PCIM_EA_IS_64: ::kernel::sys::raw::c_uint = 2;
pub const PCIM_EA_FIELD_MASK: ::kernel::sys::raw::c_uint = 4294967292;
pub const PCIXR_COMMAND: ::kernel::sys::raw::c_uint = 2;
pub const PCIXM_COMMAND_DPERR_E: ::kernel::sys::raw::c_uint = 1;
pub const PCIXM_COMMAND_ERO: ::kernel::sys::raw::c_uint = 2;
pub const PCIXM_COMMAND_MAX_READ: ::kernel::sys::raw::c_uint = 12;
pub const PCIXM_COMMAND_MAX_READ_512: ::kernel::sys::raw::c_uint = 0;
pub const PCIXM_COMMAND_MAX_READ_1024: ::kernel::sys::raw::c_uint = 4;
pub const PCIXM_COMMAND_MAX_READ_2048: ::kernel::sys::raw::c_uint = 8;
pub const PCIXM_COMMAND_MAX_READ_4096: ::kernel::sys::raw::c_uint = 12;
pub const PCIXM_COMMAND_MAX_SPLITS: ::kernel::sys::raw::c_uint = 112;
pub const PCIXM_COMMAND_MAX_SPLITS_1: ::kernel::sys::raw::c_uint = 0;
pub const PCIXM_COMMAND_MAX_SPLITS_2: ::kernel::sys::raw::c_uint = 16;
pub const PCIXM_COMMAND_MAX_SPLITS_3: ::kernel::sys::raw::c_uint = 32;
pub const PCIXM_COMMAND_MAX_SPLITS_4: ::kernel::sys::raw::c_uint = 48;
pub const PCIXM_COMMAND_MAX_SPLITS_8: ::kernel::sys::raw::c_uint = 64;
pub const PCIXM_COMMAND_MAX_SPLITS_12: ::kernel::sys::raw::c_uint = 80;
pub const PCIXM_COMMAND_MAX_SPLITS_16: ::kernel::sys::raw::c_uint = 96;
pub const PCIXM_COMMAND_MAX_SPLITS_32: ::kernel::sys::raw::c_uint = 112;
pub const PCIXM_COMMAND_VERSION: ::kernel::sys::raw::c_uint = 12288;
pub const PCIXR_STATUS: ::kernel::sys::raw::c_uint = 4;
pub const PCIXM_STATUS_DEVFN: ::kernel::sys::raw::c_uint = 255;
pub const PCIXM_STATUS_BUS: ::kernel::sys::raw::c_uint = 65280;
pub const PCIXM_STATUS_64BIT: ::kernel::sys::raw::c_uint = 65536;
pub const PCIXM_STATUS_133CAP: ::kernel::sys::raw::c_uint = 131072;
pub const PCIXM_STATUS_SC_DISCARDED: ::kernel::sys::raw::c_uint = 262144;
pub const PCIXM_STATUS_UNEXP_SC: ::kernel::sys::raw::c_uint = 524288;
pub const PCIXM_STATUS_COMPLEX_DEV: ::kernel::sys::raw::c_uint = 1048576;
pub const PCIXM_STATUS_MAX_READ: ::kernel::sys::raw::c_uint = 6291456;
pub const PCIXM_STATUS_MAX_READ_512: ::kernel::sys::raw::c_uint = 0;
pub const PCIXM_STATUS_MAX_READ_1024: ::kernel::sys::raw::c_uint = 2097152;
pub const PCIXM_STATUS_MAX_READ_2048: ::kernel::sys::raw::c_uint = 4194304;
pub const PCIXM_STATUS_MAX_READ_4096: ::kernel::sys::raw::c_uint = 6291456;
pub const PCIXM_STATUS_MAX_SPLITS: ::kernel::sys::raw::c_uint = 58720256;
pub const PCIXM_STATUS_MAX_SPLITS_1: ::kernel::sys::raw::c_uint = 0;
pub const PCIXM_STATUS_MAX_SPLITS_2: ::kernel::sys::raw::c_uint = 8388608;
pub const PCIXM_STATUS_MAX_SPLITS_3: ::kernel::sys::raw::c_uint = 16777216;
pub const PCIXM_STATUS_MAX_SPLITS_4: ::kernel::sys::raw::c_uint = 25165824;
pub const PCIXM_STATUS_MAX_SPLITS_8: ::kernel::sys::raw::c_uint = 33554432;
pub const PCIXM_STATUS_MAX_SPLITS_12: ::kernel::sys::raw::c_uint = 41943040;
pub const PCIXM_STATUS_MAX_SPLITS_16: ::kernel::sys::raw::c_uint = 50331648;
pub const PCIXM_STATUS_MAX_SPLITS_32: ::kernel::sys::raw::c_uint = 58720256;
pub const PCIXM_STATUS_MAX_CUM_READ: ::kernel::sys::raw::c_uint = 469762048;
pub const PCIXM_STATUS_RCVD_SC_ERR: ::kernel::sys::raw::c_uint = 536870912;
pub const PCIXM_STATUS_266CAP: ::kernel::sys::raw::c_uint = 1073741824;
pub const PCIXM_STATUS_533CAP: ::kernel::sys::raw::c_uint = 2147483648;
pub const PCIXR_SEC_STATUS: ::kernel::sys::raw::c_uint = 2;
pub const PCIXM_SEC_STATUS_64BIT: ::kernel::sys::raw::c_uint = 1;
pub const PCIXM_SEC_STATUS_133CAP: ::kernel::sys::raw::c_uint = 2;
pub const PCIXM_SEC_STATUS_SC_DISC: ::kernel::sys::raw::c_uint = 4;
pub const PCIXM_SEC_STATUS_UNEXP_SC: ::kernel::sys::raw::c_uint = 8;
pub const PCIXM_SEC_STATUS_SC_OVERRUN: ::kernel::sys::raw::c_uint = 16;
pub const PCIXM_SEC_STATUS_SR_DELAYED: ::kernel::sys::raw::c_uint = 32;
pub const PCIXM_SEC_STATUS_BUS_MODE: ::kernel::sys::raw::c_uint = 960;
pub const PCIXM_SEC_STATUS_VERSION: ::kernel::sys::raw::c_uint = 12288;
pub const PCIXM_SEC_STATUS_266CAP: ::kernel::sys::raw::c_uint = 16384;
pub const PCIXM_SEC_STATUS_533CAP: ::kernel::sys::raw::c_uint = 32768;
pub const PCIXR_BRIDGE_STATUS: ::kernel::sys::raw::c_uint = 4;
pub const PCIXM_BRIDGE_STATUS_DEVFN: ::kernel::sys::raw::c_uint = 255;
pub const PCIXM_BRIDGE_STATUS_BUS: ::kernel::sys::raw::c_uint = 65280;
pub const PCIXM_BRIDGE_STATUS_64BIT: ::kernel::sys::raw::c_uint = 65536;
pub const PCIXM_BRIDGE_STATUS_133CAP: ::kernel::sys::raw::c_uint = 131072;
pub const PCIXM_BRIDGE_STATUS_SC_DISCARDED: ::kernel::sys::raw::c_uint =
    262144;
pub const PCIXM_BRIDGE_STATUS_UNEXP_SC: ::kernel::sys::raw::c_uint = 524288;
pub const PCIXM_BRIDGE_STATUS_SC_OVERRUN: ::kernel::sys::raw::c_uint =
    1048576;
pub const PCIXM_BRIDGE_STATUS_SR_DELAYED: ::kernel::sys::raw::c_uint =
    2097152;
pub const PCIXM_BRIDGE_STATUS_DEVID_MSGCAP: ::kernel::sys::raw::c_uint =
    536870912;
pub const PCIXM_BRIDGE_STATUS_266CAP: ::kernel::sys::raw::c_uint = 1073741824;
pub const PCIXM_BRIDGE_STATUS_533CAP: ::kernel::sys::raw::c_uint = 2147483648;
pub const PCIR_HT_COMMAND: ::kernel::sys::raw::c_uint = 2;
pub const PCIM_HTCMD_CAP_MASK: ::kernel::sys::raw::c_uint = 63488;
pub const PCIM_HTCAP_SLAVE: ::kernel::sys::raw::c_uint = 0;
pub const PCIM_HTCAP_HOST: ::kernel::sys::raw::c_uint = 8192;
pub const PCIM_HTCAP_SWITCH: ::kernel::sys::raw::c_uint = 16384;
pub const PCIM_HTCAP_INTERRUPT: ::kernel::sys::raw::c_uint = 32768;
pub const PCIM_HTCAP_REVISION_ID: ::kernel::sys::raw::c_uint = 34816;
pub const PCIM_HTCAP_UNITID_CLUMPING: ::kernel::sys::raw::c_uint = 36864;
pub const PCIM_HTCAP_EXT_CONFIG_SPACE: ::kernel::sys::raw::c_uint = 38912;
pub const PCIM_HTCAP_ADDRESS_MAPPING: ::kernel::sys::raw::c_uint = 40960;
pub const PCIM_HTCAP_MSI_MAPPING: ::kernel::sys::raw::c_uint = 43008;
pub const PCIM_HTCAP_DIRECT_ROUTE: ::kernel::sys::raw::c_uint = 45056;
pub const PCIM_HTCAP_VCSET: ::kernel::sys::raw::c_uint = 47104;
pub const PCIM_HTCAP_RETRY_MODE: ::kernel::sys::raw::c_uint = 49152;
pub const PCIM_HTCAP_X86_ENCODING: ::kernel::sys::raw::c_uint = 51200;
pub const PCIM_HTCAP_GEN3: ::kernel::sys::raw::c_uint = 53248;
pub const PCIM_HTCAP_FLE: ::kernel::sys::raw::c_uint = 55296;
pub const PCIM_HTCAP_PM: ::kernel::sys::raw::c_uint = 57344;
pub const PCIM_HTCAP_HIGH_NODE_COUNT: ::kernel::sys::raw::c_uint = 59392;
pub const PCIM_HTCMD_MSI_ENABLE: ::kernel::sys::raw::c_uint = 1;
pub const PCIM_HTCMD_MSI_FIXED: ::kernel::sys::raw::c_uint = 2;
pub const PCIR_HTMSI_ADDRESS_LO: ::kernel::sys::raw::c_uint = 4;
pub const PCIR_HTMSI_ADDRESS_HI: ::kernel::sys::raw::c_uint = 8;
pub const PCIR_VENDOR_LENGTH: ::kernel::sys::raw::c_uint = 2;
pub const PCIR_VENDOR_DATA: ::kernel::sys::raw::c_uint = 3;
pub const PCIR_DEVICE_LENGTH: ::kernel::sys::raw::c_uint = 2;
pub const PCIR_DEBUG_PORT: ::kernel::sys::raw::c_uint = 2;
pub const PCIM_DEBUG_PORT_OFFSET: ::kernel::sys::raw::c_uint = 8191;
pub const PCIM_DEBUG_PORT_BAR: ::kernel::sys::raw::c_uint = 57344;
pub const PCIR_SUBVENDCAP_ID: ::kernel::sys::raw::c_uint = 4;
pub const PCIER_FLAGS: ::kernel::sys::raw::c_uint = 2;
pub const PCIEM_FLAGS_VERSION: ::kernel::sys::raw::c_uint = 15;
pub const PCIEM_FLAGS_TYPE: ::kernel::sys::raw::c_uint = 240;
pub const PCIEM_TYPE_ENDPOINT: ::kernel::sys::raw::c_uint = 0;
pub const PCIEM_TYPE_LEGACY_ENDPOINT: ::kernel::sys::raw::c_uint = 16;
pub const PCIEM_TYPE_ROOT_PORT: ::kernel::sys::raw::c_uint = 64;
pub const PCIEM_TYPE_UPSTREAM_PORT: ::kernel::sys::raw::c_uint = 80;
pub const PCIEM_TYPE_DOWNSTREAM_PORT: ::kernel::sys::raw::c_uint = 96;
pub const PCIEM_TYPE_PCI_BRIDGE: ::kernel::sys::raw::c_uint = 112;
pub const PCIEM_TYPE_PCIE_BRIDGE: ::kernel::sys::raw::c_uint = 128;
pub const PCIEM_TYPE_ROOT_INT_EP: ::kernel::sys::raw::c_uint = 144;
pub const PCIEM_TYPE_ROOT_EC: ::kernel::sys::raw::c_uint = 160;
pub const PCIEM_FLAGS_SLOT: ::kernel::sys::raw::c_uint = 256;
pub const PCIEM_FLAGS_IRQ: ::kernel::sys::raw::c_uint = 15872;
pub const PCIER_DEVICE_CAP: ::kernel::sys::raw::c_uint = 4;
pub const PCIEM_CAP_MAX_PAYLOAD: ::kernel::sys::raw::c_uint = 7;
pub const PCIEM_CAP_PHANTHOM_FUNCS: ::kernel::sys::raw::c_uint = 24;
pub const PCIEM_CAP_EXT_TAG_FIELD: ::kernel::sys::raw::c_uint = 32;
pub const PCIEM_CAP_L0S_LATENCY: ::kernel::sys::raw::c_uint = 448;
pub const PCIEM_CAP_L1_LATENCY: ::kernel::sys::raw::c_uint = 3584;
pub const PCIEM_CAP_ROLE_ERR_RPT: ::kernel::sys::raw::c_uint = 32768;
pub const PCIEM_CAP_SLOT_PWR_LIM_VAL: ::kernel::sys::raw::c_uint = 66846720;
pub const PCIEM_CAP_SLOT_PWR_LIM_SCALE: ::kernel::sys::raw::c_uint =
    201326592;
pub const PCIEM_CAP_FLR: ::kernel::sys::raw::c_uint = 268435456;
pub const PCIER_DEVICE_CTL: ::kernel::sys::raw::c_uint = 8;
pub const PCIEM_CTL_COR_ENABLE: ::kernel::sys::raw::c_uint = 1;
pub const PCIEM_CTL_NFER_ENABLE: ::kernel::sys::raw::c_uint = 2;
pub const PCIEM_CTL_FER_ENABLE: ::kernel::sys::raw::c_uint = 4;
pub const PCIEM_CTL_URR_ENABLE: ::kernel::sys::raw::c_uint = 8;
pub const PCIEM_CTL_RELAXED_ORD_ENABLE: ::kernel::sys::raw::c_uint = 16;
pub const PCIEM_CTL_MAX_PAYLOAD: ::kernel::sys::raw::c_uint = 224;
pub const PCIEM_CTL_EXT_TAG_FIELD: ::kernel::sys::raw::c_uint = 256;
pub const PCIEM_CTL_PHANTHOM_FUNCS: ::kernel::sys::raw::c_uint = 512;
pub const PCIEM_CTL_AUX_POWER_PM: ::kernel::sys::raw::c_uint = 1024;
pub const PCIEM_CTL_NOSNOOP_ENABLE: ::kernel::sys::raw::c_uint = 2048;
pub const PCIEM_CTL_MAX_READ_REQUEST: ::kernel::sys::raw::c_uint = 28672;
pub const PCIEM_CTL_BRDG_CFG_RETRY: ::kernel::sys::raw::c_uint = 32768;
pub const PCIEM_CTL_INITIATE_FLR: ::kernel::sys::raw::c_uint = 32768;
pub const PCIER_DEVICE_STA: ::kernel::sys::raw::c_uint = 10;
pub const PCIEM_STA_CORRECTABLE_ERROR: ::kernel::sys::raw::c_uint = 1;
pub const PCIEM_STA_NON_FATAL_ERROR: ::kernel::sys::raw::c_uint = 2;
pub const PCIEM_STA_FATAL_ERROR: ::kernel::sys::raw::c_uint = 4;
pub const PCIEM_STA_UNSUPPORTED_REQ: ::kernel::sys::raw::c_uint = 8;
pub const PCIEM_STA_AUX_POWER: ::kernel::sys::raw::c_uint = 16;
pub const PCIEM_STA_TRANSACTION_PND: ::kernel::sys::raw::c_uint = 32;
pub const PCIER_LINK_CAP: ::kernel::sys::raw::c_uint = 12;
pub const PCIEM_LINK_CAP_MAX_SPEED: ::kernel::sys::raw::c_uint = 15;
pub const PCIEM_LINK_CAP_MAX_WIDTH: ::kernel::sys::raw::c_uint = 1008;
pub const PCIEM_LINK_CAP_ASPM: ::kernel::sys::raw::c_uint = 3072;
pub const PCIEM_LINK_CAP_L0S_EXIT: ::kernel::sys::raw::c_uint = 28672;
pub const PCIEM_LINK_CAP_L1_EXIT: ::kernel::sys::raw::c_uint = 229376;
pub const PCIEM_LINK_CAP_CLOCK_PM: ::kernel::sys::raw::c_uint = 262144;
pub const PCIEM_LINK_CAP_SURPRISE_DOWN: ::kernel::sys::raw::c_uint = 524288;
pub const PCIEM_LINK_CAP_DL_ACTIVE: ::kernel::sys::raw::c_uint = 1048576;
pub const PCIEM_LINK_CAP_LINK_BW_NOTIFY: ::kernel::sys::raw::c_uint = 2097152;
pub const PCIEM_LINK_CAP_ASPM_COMPLIANCE: ::kernel::sys::raw::c_uint =
    4194304;
pub const PCIEM_LINK_CAP_PORT: ::kernel::sys::raw::c_uint = 4278190080;
pub const PCIER_LINK_CTL: ::kernel::sys::raw::c_uint = 16;
pub const PCIEM_LINK_CTL_ASPMC_DIS: ::kernel::sys::raw::c_uint = 0;
pub const PCIEM_LINK_CTL_ASPMC_L0S: ::kernel::sys::raw::c_uint = 1;
pub const PCIEM_LINK_CTL_ASPMC_L1: ::kernel::sys::raw::c_uint = 2;
pub const PCIEM_LINK_CTL_ASPMC: ::kernel::sys::raw::c_uint = 3;
pub const PCIEM_LINK_CTL_RCB: ::kernel::sys::raw::c_uint = 8;
pub const PCIEM_LINK_CTL_LINK_DIS: ::kernel::sys::raw::c_uint = 16;
pub const PCIEM_LINK_CTL_RETRAIN_LINK: ::kernel::sys::raw::c_uint = 32;
pub const PCIEM_LINK_CTL_COMMON_CLOCK: ::kernel::sys::raw::c_uint = 64;
pub const PCIEM_LINK_CTL_EXTENDED_SYNC: ::kernel::sys::raw::c_uint = 128;
pub const PCIEM_LINK_CTL_ECPM: ::kernel::sys::raw::c_uint = 256;
pub const PCIEM_LINK_CTL_HAWD: ::kernel::sys::raw::c_uint = 512;
pub const PCIEM_LINK_CTL_LBMIE: ::kernel::sys::raw::c_uint = 1024;
pub const PCIEM_LINK_CTL_LABIE: ::kernel::sys::raw::c_uint = 2048;
pub const PCIER_LINK_STA: ::kernel::sys::raw::c_uint = 18;
pub const PCIEM_LINK_STA_SPEED: ::kernel::sys::raw::c_uint = 15;
pub const PCIEM_LINK_STA_WIDTH: ::kernel::sys::raw::c_uint = 1008;
pub const PCIEM_LINK_STA_TRAINING_ERROR: ::kernel::sys::raw::c_uint = 1024;
pub const PCIEM_LINK_STA_TRAINING: ::kernel::sys::raw::c_uint = 2048;
pub const PCIEM_LINK_STA_SLOT_CLOCK: ::kernel::sys::raw::c_uint = 4096;
pub const PCIEM_LINK_STA_DL_ACTIVE: ::kernel::sys::raw::c_uint = 8192;
pub const PCIEM_LINK_STA_LINK_BW_MGMT: ::kernel::sys::raw::c_uint = 16384;
pub const PCIEM_LINK_STA_LINK_AUTO_BW: ::kernel::sys::raw::c_uint = 32768;
pub const PCIER_SLOT_CAP: ::kernel::sys::raw::c_uint = 20;
pub const PCIEM_SLOT_CAP_APB: ::kernel::sys::raw::c_uint = 1;
pub const PCIEM_SLOT_CAP_PCP: ::kernel::sys::raw::c_uint = 2;
pub const PCIEM_SLOT_CAP_MRLSP: ::kernel::sys::raw::c_uint = 4;
pub const PCIEM_SLOT_CAP_AIP: ::kernel::sys::raw::c_uint = 8;
pub const PCIEM_SLOT_CAP_PIP: ::kernel::sys::raw::c_uint = 16;
pub const PCIEM_SLOT_CAP_HPS: ::kernel::sys::raw::c_uint = 32;
pub const PCIEM_SLOT_CAP_HPC: ::kernel::sys::raw::c_uint = 64;
pub const PCIEM_SLOT_CAP_SPLV: ::kernel::sys::raw::c_uint = 32640;
pub const PCIEM_SLOT_CAP_SPLS: ::kernel::sys::raw::c_uint = 98304;
pub const PCIEM_SLOT_CAP_EIP: ::kernel::sys::raw::c_uint = 131072;
pub const PCIEM_SLOT_CAP_NCCS: ::kernel::sys::raw::c_uint = 262144;
pub const PCIEM_SLOT_CAP_PSN: ::kernel::sys::raw::c_uint = 4294443008;
pub const PCIER_SLOT_CTL: ::kernel::sys::raw::c_uint = 24;
pub const PCIEM_SLOT_CTL_ABPE: ::kernel::sys::raw::c_uint = 1;
pub const PCIEM_SLOT_CTL_PFDE: ::kernel::sys::raw::c_uint = 2;
pub const PCIEM_SLOT_CTL_MRLSCE: ::kernel::sys::raw::c_uint = 4;
pub const PCIEM_SLOT_CTL_PDCE: ::kernel::sys::raw::c_uint = 8;
pub const PCIEM_SLOT_CTL_CCIE: ::kernel::sys::raw::c_uint = 16;
pub const PCIEM_SLOT_CTL_HPIE: ::kernel::sys::raw::c_uint = 32;
pub const PCIEM_SLOT_CTL_AIC: ::kernel::sys::raw::c_uint = 192;
pub const PCIEM_SLOT_CTL_AI_ON: ::kernel::sys::raw::c_uint = 64;
pub const PCIEM_SLOT_CTL_AI_BLINK: ::kernel::sys::raw::c_uint = 128;
pub const PCIEM_SLOT_CTL_AI_OFF: ::kernel::sys::raw::c_uint = 192;
pub const PCIEM_SLOT_CTL_PIC: ::kernel::sys::raw::c_uint = 768;
pub const PCIEM_SLOT_CTL_PI_ON: ::kernel::sys::raw::c_uint = 256;
pub const PCIEM_SLOT_CTL_PI_BLINK: ::kernel::sys::raw::c_uint = 512;
pub const PCIEM_SLOT_CTL_PI_OFF: ::kernel::sys::raw::c_uint = 768;
pub const PCIEM_SLOT_CTL_PCC: ::kernel::sys::raw::c_uint = 1024;
pub const PCIEM_SLOT_CTL_PC_ON: ::kernel::sys::raw::c_uint = 0;
pub const PCIEM_SLOT_CTL_PC_OFF: ::kernel::sys::raw::c_uint = 1024;
pub const PCIEM_SLOT_CTL_EIC: ::kernel::sys::raw::c_uint = 2048;
pub const PCIEM_SLOT_CTL_DLLSCE: ::kernel::sys::raw::c_uint = 4096;
pub const PCIER_SLOT_STA: ::kernel::sys::raw::c_uint = 26;
pub const PCIEM_SLOT_STA_ABP: ::kernel::sys::raw::c_uint = 1;
pub const PCIEM_SLOT_STA_PFD: ::kernel::sys::raw::c_uint = 2;
pub const PCIEM_SLOT_STA_MRLSC: ::kernel::sys::raw::c_uint = 4;
pub const PCIEM_SLOT_STA_PDC: ::kernel::sys::raw::c_uint = 8;
pub const PCIEM_SLOT_STA_CC: ::kernel::sys::raw::c_uint = 16;
pub const PCIEM_SLOT_STA_MRLSS: ::kernel::sys::raw::c_uint = 32;
pub const PCIEM_SLOT_STA_PDS: ::kernel::sys::raw::c_uint = 64;
pub const PCIEM_SLOT_STA_EIS: ::kernel::sys::raw::c_uint = 128;
pub const PCIEM_SLOT_STA_DLLSC: ::kernel::sys::raw::c_uint = 256;
pub const PCIER_ROOT_CTL: ::kernel::sys::raw::c_uint = 28;
pub const PCIEM_ROOT_CTL_SERR_CORR: ::kernel::sys::raw::c_uint = 1;
pub const PCIEM_ROOT_CTL_SERR_NONFATAL: ::kernel::sys::raw::c_uint = 2;
pub const PCIEM_ROOT_CTL_SERR_FATAL: ::kernel::sys::raw::c_uint = 4;
pub const PCIEM_ROOT_CTL_PME: ::kernel::sys::raw::c_uint = 8;
pub const PCIEM_ROOT_CTL_CRS_VIS: ::kernel::sys::raw::c_uint = 16;
pub const PCIER_ROOT_CAP: ::kernel::sys::raw::c_uint = 30;
pub const PCIEM_ROOT_CAP_CRS_VIS: ::kernel::sys::raw::c_uint = 1;
pub const PCIER_ROOT_STA: ::kernel::sys::raw::c_uint = 32;
pub const PCIEM_ROOT_STA_PME_REQID_MASK: ::kernel::sys::raw::c_uint = 65535;
pub const PCIEM_ROOT_STA_PME_STATUS: ::kernel::sys::raw::c_uint = 65536;
pub const PCIEM_ROOT_STA_PME_PEND: ::kernel::sys::raw::c_uint = 131072;
pub const PCIER_DEVICE_CAP2: ::kernel::sys::raw::c_uint = 36;
pub const PCIEM_CAP2_COMP_TIMO_RANGES: ::kernel::sys::raw::c_uint = 15;
pub const PCIEM_CAP2_COMP_TIMO_RANGE_A: ::kernel::sys::raw::c_uint = 1;
pub const PCIEM_CAP2_COMP_TIMO_RANGE_B: ::kernel::sys::raw::c_uint = 2;
pub const PCIEM_CAP2_COMP_TIMO_RANGE_C: ::kernel::sys::raw::c_uint = 4;
pub const PCIEM_CAP2_COMP_TIMO_RANGE_D: ::kernel::sys::raw::c_uint = 8;
pub const PCIEM_CAP2_COMP_TIMO_DISABLE: ::kernel::sys::raw::c_uint = 16;
pub const PCIEM_CAP2_ARI: ::kernel::sys::raw::c_uint = 32;
pub const PCIER_DEVICE_CTL2: ::kernel::sys::raw::c_uint = 40;
pub const PCIEM_CTL2_COMP_TIMO_VAL: ::kernel::sys::raw::c_uint = 15;
pub const PCIEM_CTL2_COMP_TIMO_50MS: ::kernel::sys::raw::c_uint = 0;
pub const PCIEM_CTL2_COMP_TIMO_100US: ::kernel::sys::raw::c_uint = 1;
pub const PCIEM_CTL2_COMP_TIMO_10MS: ::kernel::sys::raw::c_uint = 2;
pub const PCIEM_CTL2_COMP_TIMO_55MS: ::kernel::sys::raw::c_uint = 5;
pub const PCIEM_CTL2_COMP_TIMO_210MS: ::kernel::sys::raw::c_uint = 6;
pub const PCIEM_CTL2_COMP_TIMO_900MS: ::kernel::sys::raw::c_uint = 9;
pub const PCIEM_CTL2_COMP_TIMO_3500MS: ::kernel::sys::raw::c_uint = 10;
pub const PCIEM_CTL2_COMP_TIMO_13S: ::kernel::sys::raw::c_uint = 13;
pub const PCIEM_CTL2_COMP_TIMO_64S: ::kernel::sys::raw::c_uint = 14;
pub const PCIEM_CTL2_COMP_TIMO_DISABLE: ::kernel::sys::raw::c_uint = 16;
pub const PCIEM_CTL2_ARI: ::kernel::sys::raw::c_uint = 32;
pub const PCIEM_CTL2_ATOMIC_REQ_ENABLE: ::kernel::sys::raw::c_uint = 64;
pub const PCIEM_CTL2_ATOMIC_EGR_BLOCK: ::kernel::sys::raw::c_uint = 128;
pub const PCIEM_CTL2_ID_ORDERED_REQ_EN: ::kernel::sys::raw::c_uint = 256;
pub const PCIEM_CTL2_ID_ORDERED_CMP_EN: ::kernel::sys::raw::c_uint = 512;
pub const PCIEM_CTL2_LTR_ENABLE: ::kernel::sys::raw::c_uint = 1024;
pub const PCIEM_CTL2_OBFF: ::kernel::sys::raw::c_uint = 24576;
pub const PCIEM_OBFF_DISABLE: ::kernel::sys::raw::c_uint = 0;
pub const PCIEM_OBFF_MSGA_ENABLE: ::kernel::sys::raw::c_uint = 8192;
pub const PCIEM_OBFF_MSGB_ENABLE: ::kernel::sys::raw::c_uint = 16384;
pub const PCIEM_OBFF_WAKE_ENABLE: ::kernel::sys::raw::c_uint = 24576;
pub const PCIEM_CTL2_END2END_TLP: ::kernel::sys::raw::c_uint = 32768;
pub const PCIER_DEVICE_STA2: ::kernel::sys::raw::c_uint = 42;
pub const PCIER_LINK_CAP2: ::kernel::sys::raw::c_uint = 44;
pub const PCIER_LINK_CTL2: ::kernel::sys::raw::c_uint = 48;
pub const PCIER_LINK_STA2: ::kernel::sys::raw::c_uint = 50;
pub const PCIER_SLOT_CAP2: ::kernel::sys::raw::c_uint = 52;
pub const PCIER_SLOT_CTL2: ::kernel::sys::raw::c_uint = 56;
pub const PCIER_SLOT_STA2: ::kernel::sys::raw::c_uint = 58;
pub const PCIR_MSIX_CTRL: ::kernel::sys::raw::c_uint = 2;
pub const PCIM_MSIXCTRL_MSIX_ENABLE: ::kernel::sys::raw::c_uint = 32768;
pub const PCIM_MSIXCTRL_FUNCTION_MASK: ::kernel::sys::raw::c_uint = 16384;
pub const PCIM_MSIXCTRL_TABLE_SIZE: ::kernel::sys::raw::c_uint = 2047;
pub const PCIR_MSIX_TABLE: ::kernel::sys::raw::c_uint = 4;
pub const PCIR_MSIX_PBA: ::kernel::sys::raw::c_uint = 8;
pub const PCIM_MSIX_BIR_MASK: ::kernel::sys::raw::c_uint = 7;
pub const PCIM_MSIX_BIR_BAR_10: ::kernel::sys::raw::c_uint = 0;
pub const PCIM_MSIX_BIR_BAR_14: ::kernel::sys::raw::c_uint = 1;
pub const PCIM_MSIX_BIR_BAR_18: ::kernel::sys::raw::c_uint = 2;
pub const PCIM_MSIX_BIR_BAR_1C: ::kernel::sys::raw::c_uint = 3;
pub const PCIM_MSIX_BIR_BAR_20: ::kernel::sys::raw::c_uint = 4;
pub const PCIM_MSIX_BIR_BAR_24: ::kernel::sys::raw::c_uint = 5;
pub const PCIM_MSIX_VCTRL_MASK: ::kernel::sys::raw::c_uint = 1;
pub const PCIR_PCIAF_CAP: ::kernel::sys::raw::c_uint = 3;
pub const PCIM_PCIAFCAP_TP: ::kernel::sys::raw::c_uint = 1;
pub const PCIM_PCIAFCAP_FLR: ::kernel::sys::raw::c_uint = 2;
pub const PCIR_PCIAF_CTRL: ::kernel::sys::raw::c_uint = 4;
pub const PCIR_PCIAFCTRL_FLR: ::kernel::sys::raw::c_uint = 1;
pub const PCIR_PCIAF_STATUS: ::kernel::sys::raw::c_uint = 5;
pub const PCIR_PCIAFSTATUS_TP: ::kernel::sys::raw::c_uint = 1;
pub const PCIR_AER_UC_STATUS: ::kernel::sys::raw::c_uint = 4;
pub const PCIM_AER_UC_TRAINING_ERROR: ::kernel::sys::raw::c_uint = 1;
pub const PCIM_AER_UC_DL_PROTOCOL_ERROR: ::kernel::sys::raw::c_uint = 16;
pub const PCIM_AER_UC_SURPRISE_LINK_DOWN: ::kernel::sys::raw::c_uint = 32;
pub const PCIM_AER_UC_POISONED_TLP: ::kernel::sys::raw::c_uint = 4096;
pub const PCIM_AER_UC_FC_PROTOCOL_ERROR: ::kernel::sys::raw::c_uint = 8192;
pub const PCIM_AER_UC_COMPLETION_TIMEOUT: ::kernel::sys::raw::c_uint = 16384;
pub const PCIM_AER_UC_COMPLETER_ABORT: ::kernel::sys::raw::c_uint = 32768;
pub const PCIM_AER_UC_UNEXPECTED_COMPLETION: ::kernel::sys::raw::c_uint =
    65536;
pub const PCIM_AER_UC_RECEIVER_OVERFLOW: ::kernel::sys::raw::c_uint = 131072;
pub const PCIM_AER_UC_MALFORMED_TLP: ::kernel::sys::raw::c_uint = 262144;
pub const PCIM_AER_UC_ECRC_ERROR: ::kernel::sys::raw::c_uint = 524288;
pub const PCIM_AER_UC_UNSUPPORTED_REQUEST: ::kernel::sys::raw::c_uint =
    1048576;
pub const PCIM_AER_UC_ACS_VIOLATION: ::kernel::sys::raw::c_uint = 2097152;
pub const PCIM_AER_UC_INTERNAL_ERROR: ::kernel::sys::raw::c_uint = 4194304;
pub const PCIM_AER_UC_MC_BLOCKED_TLP: ::kernel::sys::raw::c_uint = 8388608;
pub const PCIM_AER_UC_ATOMIC_EGRESS_BLK: ::kernel::sys::raw::c_uint =
    16777216;
pub const PCIM_AER_UC_TLP_PREFIX_BLOCKED: ::kernel::sys::raw::c_uint =
    33554432;
pub const PCIR_AER_UC_MASK: ::kernel::sys::raw::c_uint = 8;
pub const PCIR_AER_UC_SEVERITY: ::kernel::sys::raw::c_uint = 12;
pub const PCIR_AER_COR_STATUS: ::kernel::sys::raw::c_uint = 16;
pub const PCIM_AER_COR_RECEIVER_ERROR: ::kernel::sys::raw::c_uint = 1;
pub const PCIM_AER_COR_BAD_TLP: ::kernel::sys::raw::c_uint = 64;
pub const PCIM_AER_COR_BAD_DLLP: ::kernel::sys::raw::c_uint = 128;
pub const PCIM_AER_COR_REPLAY_ROLLOVER: ::kernel::sys::raw::c_uint = 256;
pub const PCIM_AER_COR_REPLAY_TIMEOUT: ::kernel::sys::raw::c_uint = 4096;
pub const PCIM_AER_COR_ADVISORY_NF_ERROR: ::kernel::sys::raw::c_uint = 8192;
pub const PCIM_AER_COR_INTERNAL_ERROR: ::kernel::sys::raw::c_uint = 16384;
pub const PCIM_AER_COR_HEADER_LOG_OVFLOW: ::kernel::sys::raw::c_uint = 32768;
pub const PCIR_AER_COR_MASK: ::kernel::sys::raw::c_uint = 20;
pub const PCIR_AER_CAP_CONTROL: ::kernel::sys::raw::c_uint = 24;
pub const PCIM_AER_FIRST_ERROR_PTR: ::kernel::sys::raw::c_uint = 31;
pub const PCIM_AER_ECRC_GEN_CAPABLE: ::kernel::sys::raw::c_uint = 32;
pub const PCIM_AER_ECRC_GEN_ENABLE: ::kernel::sys::raw::c_uint = 64;
pub const PCIM_AER_ECRC_CHECK_CAPABLE: ::kernel::sys::raw::c_uint = 128;
pub const PCIM_AER_ECRC_CHECK_ENABLE: ::kernel::sys::raw::c_uint = 256;
pub const PCIM_AER_MULT_HDR_CAPABLE: ::kernel::sys::raw::c_uint = 512;
pub const PCIM_AER_MULT_HDR_ENABLE: ::kernel::sys::raw::c_uint = 1024;
pub const PCIM_AER_TLP_PREFIX_LOG_PRESENT: ::kernel::sys::raw::c_uint = 2048;
pub const PCIR_AER_HEADER_LOG: ::kernel::sys::raw::c_uint = 28;
pub const PCIR_AER_ROOTERR_CMD: ::kernel::sys::raw::c_uint = 44;
pub const PCIM_AER_ROOTERR_COR_ENABLE: ::kernel::sys::raw::c_uint = 1;
pub const PCIM_AER_ROOTERR_NF_ENABLE: ::kernel::sys::raw::c_uint = 2;
pub const PCIM_AER_ROOTERR_F_ENABLE: ::kernel::sys::raw::c_uint = 4;
pub const PCIR_AER_ROOTERR_STATUS: ::kernel::sys::raw::c_uint = 48;
pub const PCIM_AER_ROOTERR_COR_ERR: ::kernel::sys::raw::c_uint = 1;
pub const PCIM_AER_ROOTERR_MULTI_COR_ERR: ::kernel::sys::raw::c_uint = 2;
pub const PCIM_AER_ROOTERR_UC_ERR: ::kernel::sys::raw::c_uint = 4;
pub const PCIM_AER_ROOTERR_MULTI_UC_ERR: ::kernel::sys::raw::c_uint = 8;
pub const PCIM_AER_ROOTERR_FIRST_UC_FATAL: ::kernel::sys::raw::c_uint = 16;
pub const PCIM_AER_ROOTERR_NF_ERR: ::kernel::sys::raw::c_uint = 32;
pub const PCIM_AER_ROOTERR_F_ERR: ::kernel::sys::raw::c_uint = 64;
pub const PCIM_AER_ROOTERR_INT_MESSAGE: ::kernel::sys::raw::c_uint =
    4160749568;
pub const PCIR_AER_COR_SOURCE_ID: ::kernel::sys::raw::c_uint = 52;
pub const PCIR_AER_ERR_SOURCE_ID: ::kernel::sys::raw::c_uint = 54;
pub const PCIR_AER_TLP_PREFIX_LOG: ::kernel::sys::raw::c_uint = 56;
pub const PCIR_VC_CAP1: ::kernel::sys::raw::c_uint = 4;
pub const PCIM_VC_CAP1_EXT_COUNT: ::kernel::sys::raw::c_uint = 7;
pub const PCIM_VC_CAP1_LOWPRI_EXT_COUNT: ::kernel::sys::raw::c_uint = 112;
pub const PCIR_VC_CAP2: ::kernel::sys::raw::c_uint = 8;
pub const PCIR_VC_CONTROL: ::kernel::sys::raw::c_uint = 12;
pub const PCIR_VC_STATUS: ::kernel::sys::raw::c_uint = 14;
pub const PCIR_SERIAL_LOW: ::kernel::sys::raw::c_uint = 4;
pub const PCIR_SERIAL_HIGH: ::kernel::sys::raw::c_uint = 8;
pub const PCIR_SRIOV_CTL: ::kernel::sys::raw::c_uint = 8;
pub const PCIM_SRIOV_VF_EN: ::kernel::sys::raw::c_uint = 1;
pub const PCIM_SRIOV_VF_MSE: ::kernel::sys::raw::c_uint = 8;
pub const PCIM_SRIOV_ARI_EN: ::kernel::sys::raw::c_uint = 16;
pub const PCIR_SRIOV_TOTAL_VFS: ::kernel::sys::raw::c_uint = 14;
pub const PCIR_SRIOV_NUM_VFS: ::kernel::sys::raw::c_uint = 16;
pub const PCIR_SRIOV_VF_OFF: ::kernel::sys::raw::c_uint = 20;
pub const PCIR_SRIOV_VF_STRIDE: ::kernel::sys::raw::c_uint = 22;
pub const PCIR_SRIOV_VF_DID: ::kernel::sys::raw::c_uint = 26;
pub const PCIR_SRIOV_PAGE_CAP: ::kernel::sys::raw::c_uint = 28;
pub const PCIR_SRIOV_PAGE_SIZE: ::kernel::sys::raw::c_uint = 32;
pub const PCI_SRIOV_BASE_PAGE_SHIFT: ::kernel::sys::raw::c_uint = 12;
pub const PCIR_SRIOV_BARS: ::kernel::sys::raw::c_uint = 36;
pub const PCI_OSC_STATUS: ::kernel::sys::raw::c_uint = 0;
pub const PCI_OSC_SUPPORT: ::kernel::sys::raw::c_uint = 1;
pub const PCIM_OSC_SUPPORT_EXT_PCI_CONF: ::kernel::sys::raw::c_uint = 1;
pub const PCIM_OSC_SUPPORT_ASPM: ::kernel::sys::raw::c_uint = 2;
pub const PCIM_OSC_SUPPORT_CPMC: ::kernel::sys::raw::c_uint = 4;
pub const PCIM_OSC_SUPPORT_SEG_GROUP: ::kernel::sys::raw::c_uint = 8;
pub const PCIM_OSC_SUPPORT_MSI: ::kernel::sys::raw::c_uint = 16;
pub const PCI_OSC_CTL: ::kernel::sys::raw::c_uint = 2;
pub const PCIM_OSC_CTL_PCIE_HP: ::kernel::sys::raw::c_uint = 1;
pub const PCIM_OSC_CTL_SHPC_HP: ::kernel::sys::raw::c_uint = 2;
pub const PCIM_OSC_CTL_PCIE_PME: ::kernel::sys::raw::c_uint = 4;
pub const PCIM_OSC_CTL_PCIE_AER: ::kernel::sys::raw::c_uint = 8;
pub const PCIM_OSC_CTL_PCIE_CAP_STRUCT: ::kernel::sys::raw::c_uint = 16;
pub const PR_SLOWHZ: ::kernel::sys::raw::c_uint = 2;
pub const PR_FASTHZ: ::kernel::sys::raw::c_uint = 5;
pub const PROTO_SPACER: ::kernel::sys::raw::c_uint = 32767;
pub const PR_ATOMIC: ::kernel::sys::raw::c_uint = 1;
pub const PR_ADDR: ::kernel::sys::raw::c_uint = 2;
pub const PR_CONNREQUIRED: ::kernel::sys::raw::c_uint = 4;
pub const PR_WANTRCVD: ::kernel::sys::raw::c_uint = 8;
pub const PR_RIGHTS: ::kernel::sys::raw::c_uint = 16;
pub const PR_IMPLOPCL: ::kernel::sys::raw::c_uint = 32;
pub const PR_LASTHDR: ::kernel::sys::raw::c_uint = 64;
pub const PRU_ATTACH: ::kernel::sys::raw::c_uint = 0;
pub const PRU_DETACH: ::kernel::sys::raw::c_uint = 1;
pub const PRU_BIND: ::kernel::sys::raw::c_uint = 2;
pub const PRU_LISTEN: ::kernel::sys::raw::c_uint = 3;
pub const PRU_CONNECT: ::kernel::sys::raw::c_uint = 4;
pub const PRU_ACCEPT: ::kernel::sys::raw::c_uint = 5;
pub const PRU_DISCONNECT: ::kernel::sys::raw::c_uint = 6;
pub const PRU_SHUTDOWN: ::kernel::sys::raw::c_uint = 7;
pub const PRU_RCVD: ::kernel::sys::raw::c_uint = 8;
pub const PRU_SEND: ::kernel::sys::raw::c_uint = 9;
pub const PRU_ABORT: ::kernel::sys::raw::c_uint = 10;
pub const PRU_CONTROL: ::kernel::sys::raw::c_uint = 11;
pub const PRU_SENSE: ::kernel::sys::raw::c_uint = 12;
pub const PRU_RCVOOB: ::kernel::sys::raw::c_uint = 13;
pub const PRU_SENDOOB: ::kernel::sys::raw::c_uint = 14;
pub const PRU_SOCKADDR: ::kernel::sys::raw::c_uint = 15;
pub const PRU_PEERADDR: ::kernel::sys::raw::c_uint = 16;
pub const PRU_CONNECT2: ::kernel::sys::raw::c_uint = 17;
pub const PRU_FASTTIMO: ::kernel::sys::raw::c_uint = 18;
pub const PRU_SLOWTIMO: ::kernel::sys::raw::c_uint = 19;
pub const PRU_PROTORCV: ::kernel::sys::raw::c_uint = 20;
pub const PRU_PROTOSEND: ::kernel::sys::raw::c_uint = 21;
pub const PRU_SEND_EOF: ::kernel::sys::raw::c_uint = 22;
pub const PRU_SOSETLABEL: ::kernel::sys::raw::c_uint = 23;
pub const PRU_CLOSE: ::kernel::sys::raw::c_uint = 24;
pub const PRU_FLUSH: ::kernel::sys::raw::c_uint = 25;
pub const PRU_NREQ: ::kernel::sys::raw::c_uint = 25;
pub const PRUS_OOB: ::kernel::sys::raw::c_uint = 1;
pub const PRUS_EOF: ::kernel::sys::raw::c_uint = 2;
pub const PRUS_MORETOCOME: ::kernel::sys::raw::c_uint = 4;
pub const PRUS_NOTREADY: ::kernel::sys::raw::c_uint = 8;
pub const PRC_IFDOWN: ::kernel::sys::raw::c_uint = 0;
pub const PRC_ROUTEDEAD: ::kernel::sys::raw::c_uint = 1;
pub const PRC_IFUP: ::kernel::sys::raw::c_uint = 2;
pub const PRC_MSGSIZE: ::kernel::sys::raw::c_uint = 5;
pub const PRC_HOSTDEAD: ::kernel::sys::raw::c_uint = 6;
pub const PRC_HOSTUNREACH: ::kernel::sys::raw::c_uint = 7;
pub const PRC_UNREACH_NET: ::kernel::sys::raw::c_uint = 8;
pub const PRC_UNREACH_HOST: ::kernel::sys::raw::c_uint = 9;
pub const PRC_UNREACH_PROTOCOL: ::kernel::sys::raw::c_uint = 10;
pub const PRC_UNREACH_PORT: ::kernel::sys::raw::c_uint = 11;
pub const PRC_UNREACH_SRCFAIL: ::kernel::sys::raw::c_uint = 13;
pub const PRC_REDIRECT_NET: ::kernel::sys::raw::c_uint = 14;
pub const PRC_REDIRECT_HOST: ::kernel::sys::raw::c_uint = 15;
pub const PRC_REDIRECT_TOSNET: ::kernel::sys::raw::c_uint = 16;
pub const PRC_REDIRECT_TOSHOST: ::kernel::sys::raw::c_uint = 17;
pub const PRC_TIMXCEED_INTRANS: ::kernel::sys::raw::c_uint = 18;
pub const PRC_TIMXCEED_REASS: ::kernel::sys::raw::c_uint = 19;
pub const PRC_PARAMPROB: ::kernel::sys::raw::c_uint = 20;
pub const PRC_UNREACH_ADMIN_PROHIB: ::kernel::sys::raw::c_uint = 21;
pub const PRC_NCMDS: ::kernel::sys::raw::c_uint = 22;
pub const PRCO_GETOPT: ::kernel::sys::raw::c_uint = 0;
pub const PRCO_SETOPT: ::kernel::sys::raw::c_uint = 1;
pub const PRCO_NCMDS: ::kernel::sys::raw::c_uint = 2;
pub const CR0_PE: ::kernel::sys::raw::c_uint = 1;
pub const CR0_MP: ::kernel::sys::raw::c_uint = 2;
pub const CR0_EM: ::kernel::sys::raw::c_uint = 4;
pub const CR0_TS: ::kernel::sys::raw::c_uint = 8;
pub const CR0_PG: ::kernel::sys::raw::c_uint = 2147483648;
pub const CR0_NE: ::kernel::sys::raw::c_uint = 32;
pub const CR0_WP: ::kernel::sys::raw::c_uint = 65536;
pub const CR0_AM: ::kernel::sys::raw::c_uint = 262144;
pub const CR0_NW: ::kernel::sys::raw::c_uint = 536870912;
pub const CR0_CD: ::kernel::sys::raw::c_uint = 1073741824;
pub const CR3_PCID_SAVE: ::kernel::sys::raw::c_longlong =
    -9223372036854775808;
pub const CR3_PCID_MASK: ::kernel::sys::raw::c_uint = 4095;
pub const CR4_VME: ::kernel::sys::raw::c_uint = 1;
pub const CR4_PVI: ::kernel::sys::raw::c_uint = 2;
pub const CR4_TSD: ::kernel::sys::raw::c_uint = 4;
pub const CR4_DE: ::kernel::sys::raw::c_uint = 8;
pub const CR4_PSE: ::kernel::sys::raw::c_uint = 16;
pub const CR4_PAE: ::kernel::sys::raw::c_uint = 32;
pub const CR4_MCE: ::kernel::sys::raw::c_uint = 64;
pub const CR4_PCE: ::kernel::sys::raw::c_uint = 256;
pub const CR4_FXSR: ::kernel::sys::raw::c_uint = 512;
pub const CR4_XMM: ::kernel::sys::raw::c_uint = 1024;
pub const CR4_VMXE: ::kernel::sys::raw::c_uint = 8192;
pub const CR4_FSGSBASE: ::kernel::sys::raw::c_uint = 65536;
pub const CR4_PCIDE: ::kernel::sys::raw::c_uint = 131072;
pub const CR4_XSAVE: ::kernel::sys::raw::c_uint = 262144;
pub const CR4_SMEP: ::kernel::sys::raw::c_uint = 1048576;
pub const CR4_SMAP: ::kernel::sys::raw::c_uint = 2097152;
pub const EFER_SCE: ::kernel::sys::raw::c_uint = 1;
pub const EFER_LME: ::kernel::sys::raw::c_uint = 256;
pub const EFER_LMA: ::kernel::sys::raw::c_uint = 1024;
pub const EFER_NXE: ::kernel::sys::raw::c_uint = 2048;
pub const EFER_SVM: ::kernel::sys::raw::c_uint = 4096;
pub const EFER_LMSLE: ::kernel::sys::raw::c_uint = 8192;
pub const EFER_FFXSR: ::kernel::sys::raw::c_uint = 16384;
pub const EFER_TCE: ::kernel::sys::raw::c_uint = 32768;
pub const XCR0: ::kernel::sys::raw::c_uint = 0;
pub const XFEATURE_ENABLED_X87: ::kernel::sys::raw::c_uint = 1;
pub const XFEATURE_ENABLED_SSE: ::kernel::sys::raw::c_uint = 2;
pub const XFEATURE_ENABLED_YMM_HI128: ::kernel::sys::raw::c_uint = 4;
pub const XFEATURE_ENABLED_AVX: ::kernel::sys::raw::c_uint = 4;
pub const XFEATURE_ENABLED_BNDREGS: ::kernel::sys::raw::c_uint = 8;
pub const XFEATURE_ENABLED_BNDCSR: ::kernel::sys::raw::c_uint = 16;
pub const XFEATURE_ENABLED_OPMASK: ::kernel::sys::raw::c_uint = 32;
pub const XFEATURE_ENABLED_ZMM_HI256: ::kernel::sys::raw::c_uint = 64;
pub const XFEATURE_ENABLED_HI16_ZMM: ::kernel::sys::raw::c_uint = 128;
pub const XFEATURE_AVX: ::kernel::sys::raw::c_uint = 7;
pub const XFEATURE_AVX512: ::kernel::sys::raw::c_uint = 224;
pub const XFEATURE_MPX: ::kernel::sys::raw::c_uint = 24;
pub const CPUID_FPU: ::kernel::sys::raw::c_uint = 1;
pub const CPUID_VME: ::kernel::sys::raw::c_uint = 2;
pub const CPUID_DE: ::kernel::sys::raw::c_uint = 4;
pub const CPUID_PSE: ::kernel::sys::raw::c_uint = 8;
pub const CPUID_TSC: ::kernel::sys::raw::c_uint = 16;
pub const CPUID_MSR: ::kernel::sys::raw::c_uint = 32;
pub const CPUID_PAE: ::kernel::sys::raw::c_uint = 64;
pub const CPUID_MCE: ::kernel::sys::raw::c_uint = 128;
pub const CPUID_CX8: ::kernel::sys::raw::c_uint = 256;
pub const CPUID_APIC: ::kernel::sys::raw::c_uint = 512;
pub const CPUID_B10: ::kernel::sys::raw::c_uint = 1024;
pub const CPUID_SEP: ::kernel::sys::raw::c_uint = 2048;
pub const CPUID_MTRR: ::kernel::sys::raw::c_uint = 4096;
pub const CPUID_PGE: ::kernel::sys::raw::c_uint = 8192;
pub const CPUID_MCA: ::kernel::sys::raw::c_uint = 16384;
pub const CPUID_CMOV: ::kernel::sys::raw::c_uint = 32768;
pub const CPUID_PAT: ::kernel::sys::raw::c_uint = 65536;
pub const CPUID_PSE36: ::kernel::sys::raw::c_uint = 131072;
pub const CPUID_PSN: ::kernel::sys::raw::c_uint = 262144;
pub const CPUID_CLFSH: ::kernel::sys::raw::c_uint = 524288;
pub const CPUID_B20: ::kernel::sys::raw::c_uint = 1048576;
pub const CPUID_DS: ::kernel::sys::raw::c_uint = 2097152;
pub const CPUID_ACPI: ::kernel::sys::raw::c_uint = 4194304;
pub const CPUID_MMX: ::kernel::sys::raw::c_uint = 8388608;
pub const CPUID_FXSR: ::kernel::sys::raw::c_uint = 16777216;
pub const CPUID_SSE: ::kernel::sys::raw::c_uint = 33554432;
pub const CPUID_XMM: ::kernel::sys::raw::c_uint = 33554432;
pub const CPUID_SSE2: ::kernel::sys::raw::c_uint = 67108864;
pub const CPUID_SS: ::kernel::sys::raw::c_uint = 134217728;
pub const CPUID_HTT: ::kernel::sys::raw::c_uint = 268435456;
pub const CPUID_TM: ::kernel::sys::raw::c_uint = 536870912;
pub const CPUID_IA64: ::kernel::sys::raw::c_uint = 1073741824;
pub const CPUID_PBE: ::kernel::sys::raw::c_uint = 2147483648;
pub const CPUID2_SSE3: ::kernel::sys::raw::c_uint = 1;
pub const CPUID2_PCLMULQDQ: ::kernel::sys::raw::c_uint = 2;
pub const CPUID2_DTES64: ::kernel::sys::raw::c_uint = 4;
pub const CPUID2_MON: ::kernel::sys::raw::c_uint = 8;
pub const CPUID2_DS_CPL: ::kernel::sys::raw::c_uint = 16;
pub const CPUID2_VMX: ::kernel::sys::raw::c_uint = 32;
pub const CPUID2_SMX: ::kernel::sys::raw::c_uint = 64;
pub const CPUID2_EST: ::kernel::sys::raw::c_uint = 128;
pub const CPUID2_TM2: ::kernel::sys::raw::c_uint = 256;
pub const CPUID2_SSSE3: ::kernel::sys::raw::c_uint = 512;
pub const CPUID2_CNXTID: ::kernel::sys::raw::c_uint = 1024;
pub const CPUID2_SDBG: ::kernel::sys::raw::c_uint = 2048;
pub const CPUID2_FMA: ::kernel::sys::raw::c_uint = 4096;
pub const CPUID2_CX16: ::kernel::sys::raw::c_uint = 8192;
pub const CPUID2_XTPR: ::kernel::sys::raw::c_uint = 16384;
pub const CPUID2_PDCM: ::kernel::sys::raw::c_uint = 32768;
pub const CPUID2_PCID: ::kernel::sys::raw::c_uint = 131072;
pub const CPUID2_DCA: ::kernel::sys::raw::c_uint = 262144;
pub const CPUID2_SSE41: ::kernel::sys::raw::c_uint = 524288;
pub const CPUID2_SSE42: ::kernel::sys::raw::c_uint = 1048576;
pub const CPUID2_X2APIC: ::kernel::sys::raw::c_uint = 2097152;
pub const CPUID2_MOVBE: ::kernel::sys::raw::c_uint = 4194304;
pub const CPUID2_POPCNT: ::kernel::sys::raw::c_uint = 8388608;
pub const CPUID2_TSCDLT: ::kernel::sys::raw::c_uint = 16777216;
pub const CPUID2_AESNI: ::kernel::sys::raw::c_uint = 33554432;
pub const CPUID2_XSAVE: ::kernel::sys::raw::c_uint = 67108864;
pub const CPUID2_OSXSAVE: ::kernel::sys::raw::c_uint = 134217728;
pub const CPUID2_AVX: ::kernel::sys::raw::c_uint = 268435456;
pub const CPUID2_F16C: ::kernel::sys::raw::c_uint = 536870912;
pub const CPUID2_RDRAND: ::kernel::sys::raw::c_uint = 1073741824;
pub const CPUID2_HV: ::kernel::sys::raw::c_uint = 2147483648;
pub const CPUTPM1_SENSOR: ::kernel::sys::raw::c_uint = 1;
pub const CPUTPM1_TURBO: ::kernel::sys::raw::c_uint = 2;
pub const CPUTPM1_ARAT: ::kernel::sys::raw::c_uint = 4;
pub const CPUTPM2_EFFREQ: ::kernel::sys::raw::c_uint = 1;
pub const CPUPT_CR3: ::kernel::sys::raw::c_uint = 1;
pub const CPUPT_PSB: ::kernel::sys::raw::c_uint = 2;
pub const CPUPT_IPF: ::kernel::sys::raw::c_uint = 4;
pub const CPUPT_MTC: ::kernel::sys::raw::c_uint = 8;
pub const CPUPT_PRW: ::kernel::sys::raw::c_uint = 16;
pub const CPUPT_PWR: ::kernel::sys::raw::c_uint = 32;
pub const CPUPT_TOPA: ::kernel::sys::raw::c_uint = 1;
pub const CPUPT_TOPA_MULTI: ::kernel::sys::raw::c_uint = 2;
pub const CPUPT_SINGLE: ::kernel::sys::raw::c_uint = 4;
pub const CPUPT_TT_OUT: ::kernel::sys::raw::c_uint = 8;
pub const CPUPT_LINEAR_IP: ::kernel::sys::raw::c_uint = 2147483648;
pub const CPUPT_NADDR_S: ::kernel::sys::raw::c_uint = 0;
pub const CPUPT_NADDR_M: ::kernel::sys::raw::c_uint = 7;
pub const CPUPT_MTC_BITMAP_S: ::kernel::sys::raw::c_uint = 16;
pub const CPUPT_MTC_BITMAP_M: ::kernel::sys::raw::c_uint = 4294901760;
pub const CPUPT_CT_BITMAP_S: ::kernel::sys::raw::c_uint = 0;
pub const CPUPT_CT_BITMAP_M: ::kernel::sys::raw::c_uint = 65535;
pub const CPUPT_PFE_BITMAP_S: ::kernel::sys::raw::c_uint = 16;
pub const CPUPT_PFE_BITMAP_M: ::kernel::sys::raw::c_uint = 4294901760;
pub const AMDID_SYSCALL: ::kernel::sys::raw::c_uint = 2048;
pub const AMDID_MP: ::kernel::sys::raw::c_uint = 524288;
pub const AMDID_NX: ::kernel::sys::raw::c_uint = 1048576;
pub const AMDID_EXT_MMX: ::kernel::sys::raw::c_uint = 4194304;
pub const AMDID_FFXSR: ::kernel::sys::raw::c_uint = 33554432;
pub const AMDID_PAGE1GB: ::kernel::sys::raw::c_uint = 67108864;
pub const AMDID_RDTSCP: ::kernel::sys::raw::c_uint = 134217728;
pub const AMDID_LM: ::kernel::sys::raw::c_uint = 536870912;
pub const AMDID_EXT_3DNOW: ::kernel::sys::raw::c_uint = 1073741824;
pub const AMDID_3DNOW: ::kernel::sys::raw::c_uint = 2147483648;
pub const AMDID2_LAHF: ::kernel::sys::raw::c_uint = 1;
pub const AMDID2_CMP: ::kernel::sys::raw::c_uint = 2;
pub const AMDID2_SVM: ::kernel::sys::raw::c_uint = 4;
pub const AMDID2_EXT_APIC: ::kernel::sys::raw::c_uint = 8;
pub const AMDID2_CR8: ::kernel::sys::raw::c_uint = 16;
pub const AMDID2_ABM: ::kernel::sys::raw::c_uint = 32;
pub const AMDID2_SSE4A: ::kernel::sys::raw::c_uint = 64;
pub const AMDID2_MAS: ::kernel::sys::raw::c_uint = 128;
pub const AMDID2_PREFETCH: ::kernel::sys::raw::c_uint = 256;
pub const AMDID2_OSVW: ::kernel::sys::raw::c_uint = 512;
pub const AMDID2_IBS: ::kernel::sys::raw::c_uint = 1024;
pub const AMDID2_XOP: ::kernel::sys::raw::c_uint = 2048;
pub const AMDID2_SKINIT: ::kernel::sys::raw::c_uint = 4096;
pub const AMDID2_WDT: ::kernel::sys::raw::c_uint = 8192;
pub const AMDID2_LWP: ::kernel::sys::raw::c_uint = 32768;
pub const AMDID2_FMA4: ::kernel::sys::raw::c_uint = 65536;
pub const AMDID2_TCE: ::kernel::sys::raw::c_uint = 131072;
pub const AMDID2_NODE_ID: ::kernel::sys::raw::c_uint = 524288;
pub const AMDID2_TBM: ::kernel::sys::raw::c_uint = 2097152;
pub const AMDID2_TOPOLOGY: ::kernel::sys::raw::c_uint = 4194304;
pub const AMDID2_PCXC: ::kernel::sys::raw::c_uint = 8388608;
pub const AMDID2_PNXC: ::kernel::sys::raw::c_uint = 16777216;
pub const AMDID2_DBE: ::kernel::sys::raw::c_uint = 67108864;
pub const AMDID2_PTSC: ::kernel::sys::raw::c_uint = 134217728;
pub const AMDID2_PTSCEL2I: ::kernel::sys::raw::c_uint = 268435456;
pub const AMDID2_MWAITX: ::kernel::sys::raw::c_uint = 536870912;
pub const CPUID_STEPPING: ::kernel::sys::raw::c_uint = 15;
pub const CPUID_MODEL: ::kernel::sys::raw::c_uint = 240;
pub const CPUID_FAMILY: ::kernel::sys::raw::c_uint = 3840;
pub const CPUID_EXT_MODEL: ::kernel::sys::raw::c_uint = 983040;
pub const CPUID_EXT_FAMILY: ::kernel::sys::raw::c_uint = 267386880;
pub const CPUID_BRAND_INDEX: ::kernel::sys::raw::c_uint = 255;
pub const CPUID_CLFUSH_SIZE: ::kernel::sys::raw::c_uint = 65280;
pub const CPUID_HTT_CORES: ::kernel::sys::raw::c_uint = 16711680;
pub const CPUID_LOCAL_APIC_ID: ::kernel::sys::raw::c_uint = 4278190080;
pub const CPUID5_MON_MIN_SIZE: ::kernel::sys::raw::c_uint = 65535;
pub const CPUID5_MON_MAX_SIZE: ::kernel::sys::raw::c_uint = 65535;
pub const CPUID5_MON_MWAIT_EXT: ::kernel::sys::raw::c_uint = 1;
pub const CPUID5_MWAIT_INTRBREAK: ::kernel::sys::raw::c_uint = 2;
pub const MWAIT_C0: ::kernel::sys::raw::c_uint = 240;
pub const MWAIT_C1: ::kernel::sys::raw::c_uint = 0;
pub const MWAIT_C2: ::kernel::sys::raw::c_uint = 16;
pub const MWAIT_C3: ::kernel::sys::raw::c_uint = 32;
pub const MWAIT_C4: ::kernel::sys::raw::c_uint = 48;
pub const MWAIT_INTRBREAK: ::kernel::sys::raw::c_uint = 1;
pub const CPUID_PERF_STAT: ::kernel::sys::raw::c_uint = 1;
pub const CPUID_PERF_BIAS: ::kernel::sys::raw::c_uint = 8;
pub const CPUID_TYPE_INVAL: ::kernel::sys::raw::c_uint = 0;
pub const CPUID_TYPE_SMT: ::kernel::sys::raw::c_uint = 1;
pub const CPUID_TYPE_CORE: ::kernel::sys::raw::c_uint = 2;
pub const CPUID_EXTSTATE_XSAVEOPT: ::kernel::sys::raw::c_uint = 1;
pub const CPUID_EXTSTATE_XSAVEC: ::kernel::sys::raw::c_uint = 2;
pub const CPUID_EXTSTATE_XINUSE: ::kernel::sys::raw::c_uint = 4;
pub const CPUID_EXTSTATE_XSAVES: ::kernel::sys::raw::c_uint = 8;
pub const AMDRAS_MCA_OF_RECOV: ::kernel::sys::raw::c_uint = 1;
pub const AMDRAS_SUCCOR: ::kernel::sys::raw::c_uint = 2;
pub const AMDRAS_HW_ASSERT: ::kernel::sys::raw::c_uint = 4;
pub const AMDRAS_SCALABLE_MCA: ::kernel::sys::raw::c_uint = 8;
pub const AMDRAS_PFEH_SUPPORT: ::kernel::sys::raw::c_uint = 16;
pub const AMDPM_TS: ::kernel::sys::raw::c_uint = 1;
pub const AMDPM_FID: ::kernel::sys::raw::c_uint = 2;
pub const AMDPM_VID: ::kernel::sys::raw::c_uint = 4;
pub const AMDPM_TTP: ::kernel::sys::raw::c_uint = 8;
pub const AMDPM_TM: ::kernel::sys::raw::c_uint = 16;
pub const AMDPM_STC: ::kernel::sys::raw::c_uint = 32;
pub const AMDPM_100MHZ_STEPS: ::kernel::sys::raw::c_uint = 64;
pub const AMDPM_HW_PSTATE: ::kernel::sys::raw::c_uint = 128;
pub const AMDPM_TSC_INVARIANT: ::kernel::sys::raw::c_uint = 256;
pub const AMDPM_CPB: ::kernel::sys::raw::c_uint = 512;
pub const AMDFEID_CLZERO: ::kernel::sys::raw::c_uint = 1;
pub const AMDFEID_IRPERF: ::kernel::sys::raw::c_uint = 2;
pub const AMDFEID_XSAVEERPTR: ::kernel::sys::raw::c_uint = 4;
pub const AMDID_CMP_CORES: ::kernel::sys::raw::c_uint = 255;
pub const AMDID_COREID_SIZE: ::kernel::sys::raw::c_uint = 61440;
pub const AMDID_COREID_SIZE_SHIFT: ::kernel::sys::raw::c_uint = 12;
pub const CPUID_STDEXT_FSGSBASE: ::kernel::sys::raw::c_uint = 1;
pub const CPUID_STDEXT_TSC_ADJUST: ::kernel::sys::raw::c_uint = 2;
pub const CPUID_STDEXT_SGX: ::kernel::sys::raw::c_uint = 4;
pub const CPUID_STDEXT_BMI1: ::kernel::sys::raw::c_uint = 8;
pub const CPUID_STDEXT_HLE: ::kernel::sys::raw::c_uint = 16;
pub const CPUID_STDEXT_AVX2: ::kernel::sys::raw::c_uint = 32;
pub const CPUID_STDEXT_FDP_EXC: ::kernel::sys::raw::c_uint = 64;
pub const CPUID_STDEXT_SMEP: ::kernel::sys::raw::c_uint = 128;
pub const CPUID_STDEXT_BMI2: ::kernel::sys::raw::c_uint = 256;
pub const CPUID_STDEXT_ERMS: ::kernel::sys::raw::c_uint = 512;
pub const CPUID_STDEXT_INVPCID: ::kernel::sys::raw::c_uint = 1024;
pub const CPUID_STDEXT_RTM: ::kernel::sys::raw::c_uint = 2048;
pub const CPUID_STDEXT_PQM: ::kernel::sys::raw::c_uint = 4096;
pub const CPUID_STDEXT_NFPUSG: ::kernel::sys::raw::c_uint = 8192;
pub const CPUID_STDEXT_MPX: ::kernel::sys::raw::c_uint = 16384;
pub const CPUID_STDEXT_PQE: ::kernel::sys::raw::c_uint = 32768;
pub const CPUID_STDEXT_AVX512F: ::kernel::sys::raw::c_uint = 65536;
pub const CPUID_STDEXT_AVX512DQ: ::kernel::sys::raw::c_uint = 131072;
pub const CPUID_STDEXT_RDSEED: ::kernel::sys::raw::c_uint = 262144;
pub const CPUID_STDEXT_ADX: ::kernel::sys::raw::c_uint = 524288;
pub const CPUID_STDEXT_SMAP: ::kernel::sys::raw::c_uint = 1048576;
pub const CPUID_STDEXT_AVX512IFMA: ::kernel::sys::raw::c_uint = 2097152;
pub const CPUID_STDEXT_PCOMMIT: ::kernel::sys::raw::c_uint = 4194304;
pub const CPUID_STDEXT_CLFLUSHOPT: ::kernel::sys::raw::c_uint = 8388608;
pub const CPUID_STDEXT_CLWB: ::kernel::sys::raw::c_uint = 16777216;
pub const CPUID_STDEXT_PROCTRACE: ::kernel::sys::raw::c_uint = 33554432;
pub const CPUID_STDEXT_AVX512PF: ::kernel::sys::raw::c_uint = 67108864;
pub const CPUID_STDEXT_AVX512ER: ::kernel::sys::raw::c_uint = 134217728;
pub const CPUID_STDEXT_AVX512CD: ::kernel::sys::raw::c_uint = 268435456;
pub const CPUID_STDEXT_SHA: ::kernel::sys::raw::c_uint = 536870912;
pub const CPUID_STDEXT_AVX512BW: ::kernel::sys::raw::c_uint = 1073741824;
pub const CPUID_STDEXT_AVX512VL: ::kernel::sys::raw::c_uint = 2147483648;
pub const CPUID_STDEXT2_PREFETCHWT1: ::kernel::sys::raw::c_uint = 1;
pub const CPUID_STDEXT2_UMIP: ::kernel::sys::raw::c_uint = 4;
pub const CPUID_STDEXT2_PKU: ::kernel::sys::raw::c_uint = 8;
pub const CPUID_STDEXT2_OSPKE: ::kernel::sys::raw::c_uint = 16;
pub const CPUID_STDEXT2_RDPID: ::kernel::sys::raw::c_uint = 4194304;
pub const CPUID_STDEXT2_SGXLC: ::kernel::sys::raw::c_uint = 1073741824;
pub const CPUID_STDEXT3_IBPB: ::kernel::sys::raw::c_uint = 67108864;
pub const CPUID_STDEXT3_STIBP: ::kernel::sys::raw::c_uint = 134217728;
pub const CPUID_STDEXT3_ARCH_CAP: ::kernel::sys::raw::c_uint = 536870912;
pub const CPUID_STDEXT3_SSBD: ::kernel::sys::raw::c_uint = 2147483648;
pub const IA32_ARCH_CAP_RDCL_NO: ::kernel::sys::raw::c_uint = 1;
pub const IA32_ARCH_CAP_IBRS_ALL: ::kernel::sys::raw::c_uint = 2;
pub const IA32_ARCH_CAP_SSBD_NO: ::kernel::sys::raw::c_uint = 4;
pub const AMD_VENDOR_ID: &'static [u8; 13usize] = b"AuthenticAMD\x00";
pub const CENTAUR_VENDOR_ID: &'static [u8; 13usize] = b"CentaurHauls\x00";
pub const CYRIX_VENDOR_ID: &'static [u8; 13usize] = b"CyrixInstead\x00";
pub const INTEL_VENDOR_ID: &'static [u8; 13usize] = b"GenuineIntel\x00";
pub const NEXGEN_VENDOR_ID: &'static [u8; 13usize] = b"NexGenDriven\x00";
pub const NSC_VENDOR_ID: &'static [u8; 13usize] = b"Geode by NSC\x00";
pub const RISE_VENDOR_ID: &'static [u8; 13usize] = b"RiseRiseRise\x00";
pub const SIS_VENDOR_ID: &'static [u8; 13usize] = b"SiS SiS SiS \x00";
pub const TRANSMETA_VENDOR_ID: &'static [u8; 13usize] = b"GenuineTMx86\x00";
pub const UMC_VENDOR_ID: &'static [u8; 13usize] = b"UMC UMC UMC \x00";
pub const MSR_P5_MC_ADDR: ::kernel::sys::raw::c_uint = 0;
pub const MSR_P5_MC_TYPE: ::kernel::sys::raw::c_uint = 1;
pub const MSR_TSC: ::kernel::sys::raw::c_uint = 16;
pub const MSR_P5_CESR: ::kernel::sys::raw::c_uint = 17;
pub const MSR_P5_CTR0: ::kernel::sys::raw::c_uint = 18;
pub const MSR_P5_CTR1: ::kernel::sys::raw::c_uint = 19;
pub const MSR_IA32_PLATFORM_ID: ::kernel::sys::raw::c_uint = 23;
pub const MSR_APICBASE: ::kernel::sys::raw::c_uint = 27;
pub const MSR_EBL_CR_POWERON: ::kernel::sys::raw::c_uint = 42;
pub const MSR_TEST_CTL: ::kernel::sys::raw::c_uint = 51;
pub const MSR_IA32_FEATURE_CONTROL: ::kernel::sys::raw::c_uint = 58;
pub const MSR_IA32_SPEC_CTRL: ::kernel::sys::raw::c_uint = 72;
pub const MSR_IA32_PRED_CMD: ::kernel::sys::raw::c_uint = 73;
pub const MSR_BIOS_UPDT_TRIG: ::kernel::sys::raw::c_uint = 121;
pub const MSR_BBL_CR_D0: ::kernel::sys::raw::c_uint = 136;
pub const MSR_BBL_CR_D1: ::kernel::sys::raw::c_uint = 137;
pub const MSR_BBL_CR_D2: ::kernel::sys::raw::c_uint = 138;
pub const MSR_BIOS_SIGN: ::kernel::sys::raw::c_uint = 139;
pub const MSR_PERFCTR0: ::kernel::sys::raw::c_uint = 193;
pub const MSR_PERFCTR1: ::kernel::sys::raw::c_uint = 194;
pub const MSR_PLATFORM_INFO: ::kernel::sys::raw::c_uint = 206;
pub const MSR_MPERF: ::kernel::sys::raw::c_uint = 231;
pub const MSR_APERF: ::kernel::sys::raw::c_uint = 232;
pub const MSR_IA32_EXT_CONFIG: ::kernel::sys::raw::c_uint = 238;
pub const MSR_MTRRcap: ::kernel::sys::raw::c_uint = 254;
pub const MSR_IA32_ARCH_CAP: ::kernel::sys::raw::c_uint = 266;
pub const MSR_BBL_CR_ADDR: ::kernel::sys::raw::c_uint = 278;
pub const MSR_BBL_CR_DECC: ::kernel::sys::raw::c_uint = 280;
pub const MSR_BBL_CR_CTL: ::kernel::sys::raw::c_uint = 281;
pub const MSR_BBL_CR_TRIG: ::kernel::sys::raw::c_uint = 282;
pub const MSR_BBL_CR_BUSY: ::kernel::sys::raw::c_uint = 283;
pub const MSR_BBL_CR_CTL3: ::kernel::sys::raw::c_uint = 286;
pub const MSR_SYSENTER_CS_MSR: ::kernel::sys::raw::c_uint = 372;
pub const MSR_SYSENTER_ESP_MSR: ::kernel::sys::raw::c_uint = 373;
pub const MSR_SYSENTER_EIP_MSR: ::kernel::sys::raw::c_uint = 374;
pub const MSR_MCG_CAP: ::kernel::sys::raw::c_uint = 377;
pub const MSR_MCG_STATUS: ::kernel::sys::raw::c_uint = 378;
pub const MSR_MCG_CTL: ::kernel::sys::raw::c_uint = 379;
pub const MSR_EVNTSEL0: ::kernel::sys::raw::c_uint = 390;
pub const MSR_EVNTSEL1: ::kernel::sys::raw::c_uint = 391;
pub const MSR_THERM_CONTROL: ::kernel::sys::raw::c_uint = 410;
pub const MSR_THERM_INTERRUPT: ::kernel::sys::raw::c_uint = 411;
pub const MSR_THERM_STATUS: ::kernel::sys::raw::c_uint = 412;
pub const MSR_IA32_MISC_ENABLE: ::kernel::sys::raw::c_uint = 416;
pub const MSR_IA32_TEMPERATURE_TARGET: ::kernel::sys::raw::c_uint = 418;
pub const MSR_TURBO_RATIO_LIMIT: ::kernel::sys::raw::c_uint = 429;
pub const MSR_TURBO_RATIO_LIMIT1: ::kernel::sys::raw::c_uint = 430;
pub const MSR_DEBUGCTLMSR: ::kernel::sys::raw::c_uint = 473;
pub const MSR_LASTBRANCHFROMIP: ::kernel::sys::raw::c_uint = 475;
pub const MSR_LASTBRANCHTOIP: ::kernel::sys::raw::c_uint = 476;
pub const MSR_LASTINTFROMIP: ::kernel::sys::raw::c_uint = 477;
pub const MSR_LASTINTTOIP: ::kernel::sys::raw::c_uint = 478;
pub const MSR_ROB_CR_BKUPTMPDR6: ::kernel::sys::raw::c_uint = 480;
pub const MSR_MTRRVarBase: ::kernel::sys::raw::c_uint = 512;
pub const MSR_MTRR64kBase: ::kernel::sys::raw::c_uint = 592;
pub const MSR_MTRR16kBase: ::kernel::sys::raw::c_uint = 600;
pub const MSR_MTRR4kBase: ::kernel::sys::raw::c_uint = 616;
pub const MSR_PAT: ::kernel::sys::raw::c_uint = 631;
pub const MSR_MC0_CTL2: ::kernel::sys::raw::c_uint = 640;
pub const MSR_MTRRdefType: ::kernel::sys::raw::c_uint = 767;
pub const MSR_MC0_CTL: ::kernel::sys::raw::c_uint = 1024;
pub const MSR_MC0_STATUS: ::kernel::sys::raw::c_uint = 1025;
pub const MSR_MC0_ADDR: ::kernel::sys::raw::c_uint = 1026;
pub const MSR_MC0_MISC: ::kernel::sys::raw::c_uint = 1027;
pub const MSR_MC1_CTL: ::kernel::sys::raw::c_uint = 1028;
pub const MSR_MC1_STATUS: ::kernel::sys::raw::c_uint = 1029;
pub const MSR_MC1_ADDR: ::kernel::sys::raw::c_uint = 1030;
pub const MSR_MC1_MISC: ::kernel::sys::raw::c_uint = 1031;
pub const MSR_MC2_CTL: ::kernel::sys::raw::c_uint = 1032;
pub const MSR_MC2_STATUS: ::kernel::sys::raw::c_uint = 1033;
pub const MSR_MC2_ADDR: ::kernel::sys::raw::c_uint = 1034;
pub const MSR_MC2_MISC: ::kernel::sys::raw::c_uint = 1035;
pub const MSR_MC3_CTL: ::kernel::sys::raw::c_uint = 1036;
pub const MSR_MC3_STATUS: ::kernel::sys::raw::c_uint = 1037;
pub const MSR_MC3_ADDR: ::kernel::sys::raw::c_uint = 1038;
pub const MSR_MC3_MISC: ::kernel::sys::raw::c_uint = 1039;
pub const MSR_MC4_CTL: ::kernel::sys::raw::c_uint = 1040;
pub const MSR_MC4_STATUS: ::kernel::sys::raw::c_uint = 1041;
pub const MSR_MC4_ADDR: ::kernel::sys::raw::c_uint = 1042;
pub const MSR_MC4_MISC: ::kernel::sys::raw::c_uint = 1043;
pub const MSR_RAPL_POWER_UNIT: ::kernel::sys::raw::c_uint = 1542;
pub const MSR_PKG_ENERGY_STATUS: ::kernel::sys::raw::c_uint = 1553;
pub const MSR_DRAM_ENERGY_STATUS: ::kernel::sys::raw::c_uint = 1561;
pub const MSR_PP0_ENERGY_STATUS: ::kernel::sys::raw::c_uint = 1593;
pub const MSR_PP1_ENERGY_STATUS: ::kernel::sys::raw::c_uint = 1601;
pub const MSR_TSC_DEADLINE: ::kernel::sys::raw::c_uint = 1760;
pub const MSR_VMX_BASIC: ::kernel::sys::raw::c_uint = 1152;
pub const MSR_VMX_PINBASED_CTLS: ::kernel::sys::raw::c_uint = 1153;
pub const MSR_VMX_PROCBASED_CTLS: ::kernel::sys::raw::c_uint = 1154;
pub const MSR_VMX_EXIT_CTLS: ::kernel::sys::raw::c_uint = 1155;
pub const MSR_VMX_ENTRY_CTLS: ::kernel::sys::raw::c_uint = 1156;
pub const MSR_VMX_CR0_FIXED0: ::kernel::sys::raw::c_uint = 1158;
pub const MSR_VMX_CR0_FIXED1: ::kernel::sys::raw::c_uint = 1159;
pub const MSR_VMX_CR4_FIXED0: ::kernel::sys::raw::c_uint = 1160;
pub const MSR_VMX_CR4_FIXED1: ::kernel::sys::raw::c_uint = 1161;
pub const MSR_VMX_PROCBASED_CTLS2: ::kernel::sys::raw::c_uint = 1163;
pub const MSR_VMX_EPT_VPID_CAP: ::kernel::sys::raw::c_uint = 1164;
pub const MSR_VMX_TRUE_PINBASED_CTLS: ::kernel::sys::raw::c_uint = 1165;
pub const MSR_VMX_TRUE_PROCBASED_CTLS: ::kernel::sys::raw::c_uint = 1166;
pub const MSR_VMX_TRUE_EXIT_CTLS: ::kernel::sys::raw::c_uint = 1167;
pub const MSR_VMX_TRUE_ENTRY_CTLS: ::kernel::sys::raw::c_uint = 1168;
pub const MSR_APIC_000: ::kernel::sys::raw::c_uint = 2048;
pub const MSR_APIC_ID: ::kernel::sys::raw::c_uint = 2050;
pub const MSR_APIC_VERSION: ::kernel::sys::raw::c_uint = 2051;
pub const MSR_APIC_TPR: ::kernel::sys::raw::c_uint = 2056;
pub const MSR_APIC_EOI: ::kernel::sys::raw::c_uint = 2059;
pub const MSR_APIC_LDR: ::kernel::sys::raw::c_uint = 2061;
pub const MSR_APIC_SVR: ::kernel::sys::raw::c_uint = 2063;
pub const MSR_APIC_ISR0: ::kernel::sys::raw::c_uint = 2064;
pub const MSR_APIC_ISR1: ::kernel::sys::raw::c_uint = 2065;
pub const MSR_APIC_ISR2: ::kernel::sys::raw::c_uint = 2066;
pub const MSR_APIC_ISR3: ::kernel::sys::raw::c_uint = 2067;
pub const MSR_APIC_ISR4: ::kernel::sys::raw::c_uint = 2068;
pub const MSR_APIC_ISR5: ::kernel::sys::raw::c_uint = 2069;
pub const MSR_APIC_ISR6: ::kernel::sys::raw::c_uint = 2070;
pub const MSR_APIC_ISR7: ::kernel::sys::raw::c_uint = 2071;
pub const MSR_APIC_TMR0: ::kernel::sys::raw::c_uint = 2072;
pub const MSR_APIC_IRR0: ::kernel::sys::raw::c_uint = 2080;
pub const MSR_APIC_ESR: ::kernel::sys::raw::c_uint = 2088;
pub const MSR_APIC_LVT_CMCI: ::kernel::sys::raw::c_uint = 2095;
pub const MSR_APIC_ICR: ::kernel::sys::raw::c_uint = 2096;
pub const MSR_APIC_LVT_TIMER: ::kernel::sys::raw::c_uint = 2098;
pub const MSR_APIC_LVT_THERMAL: ::kernel::sys::raw::c_uint = 2099;
pub const MSR_APIC_LVT_PCINT: ::kernel::sys::raw::c_uint = 2100;
pub const MSR_APIC_LVT_LINT0: ::kernel::sys::raw::c_uint = 2101;
pub const MSR_APIC_LVT_LINT1: ::kernel::sys::raw::c_uint = 2102;
pub const MSR_APIC_LVT_ERROR: ::kernel::sys::raw::c_uint = 2103;
pub const MSR_APIC_ICR_TIMER: ::kernel::sys::raw::c_uint = 2104;
pub const MSR_APIC_CCR_TIMER: ::kernel::sys::raw::c_uint = 2105;
pub const MSR_APIC_DCR_TIMER: ::kernel::sys::raw::c_uint = 2110;
pub const MSR_APIC_SELF_IPI: ::kernel::sys::raw::c_uint = 2111;
pub const MSR_IA32_XSS: ::kernel::sys::raw::c_uint = 3488;
pub const MSR_IA32_RTIT_OUTPUT_BASE: ::kernel::sys::raw::c_uint = 1376;
pub const MSR_IA32_RTIT_OUTPUT_MASK_PTRS: ::kernel::sys::raw::c_uint = 1377;
pub const MSR_IA32_RTIT_CTL: ::kernel::sys::raw::c_uint = 1392;
pub const RTIT_CTL_TRACEEN: ::kernel::sys::raw::c_uint = 1;
pub const RTIT_CTL_CYCEN: ::kernel::sys::raw::c_uint = 2;
pub const RTIT_CTL_OS: ::kernel::sys::raw::c_uint = 4;
pub const RTIT_CTL_USER: ::kernel::sys::raw::c_uint = 8;
pub const RTIT_CTL_PWREVTEN: ::kernel::sys::raw::c_uint = 16;
pub const RTIT_CTL_FUPONPTW: ::kernel::sys::raw::c_uint = 32;
pub const RTIT_CTL_FABRICEN: ::kernel::sys::raw::c_uint = 64;
pub const RTIT_CTL_CR3FILTER: ::kernel::sys::raw::c_uint = 128;
pub const RTIT_CTL_TOPA: ::kernel::sys::raw::c_uint = 256;
pub const RTIT_CTL_MTCEN: ::kernel::sys::raw::c_uint = 512;
pub const RTIT_CTL_TSCEN: ::kernel::sys::raw::c_uint = 1024;
pub const RTIT_CTL_DISRETC: ::kernel::sys::raw::c_uint = 2048;
pub const RTIT_CTL_PTWEN: ::kernel::sys::raw::c_uint = 4096;
pub const RTIT_CTL_BRANCHEN: ::kernel::sys::raw::c_uint = 8192;
pub const RTIT_CTL_MTC_FREQ_S: ::kernel::sys::raw::c_uint = 14;
pub const RTIT_CTL_MTC_FREQ_M: ::kernel::sys::raw::c_uint = 245760;
pub const RTIT_CTL_CYC_THRESH_S: ::kernel::sys::raw::c_uint = 19;
pub const RTIT_CTL_CYC_THRESH_M: ::kernel::sys::raw::c_uint = 7864320;
pub const RTIT_CTL_PSB_FREQ_S: ::kernel::sys::raw::c_uint = 24;
pub const RTIT_CTL_PSB_FREQ_M: ::kernel::sys::raw::c_uint = 251658240;
pub const RTIT_CTL_ADDR0_CFG_S: ::kernel::sys::raw::c_uint = 32;
pub const RTIT_CTL_ADDR0_CFG_M: ::kernel::sys::raw::c_ulonglong = 64424509440;
pub const RTIT_CTL_ADDR1_CFG_S: ::kernel::sys::raw::c_uint = 36;
pub const RTIT_CTL_ADDR1_CFG_M: ::kernel::sys::raw::c_ulonglong =
    1030792151040;
pub const RTIT_CTL_ADDR2_CFG_S: ::kernel::sys::raw::c_uint = 40;
pub const RTIT_CTL_ADDR2_CFG_M: ::kernel::sys::raw::c_ulonglong =
    16492674416640;
pub const RTIT_CTL_ADDR3_CFG_S: ::kernel::sys::raw::c_uint = 44;
pub const RTIT_CTL_ADDR3_CFG_M: ::kernel::sys::raw::c_ulonglong =
    263882790666240;
pub const MSR_IA32_RTIT_STATUS: ::kernel::sys::raw::c_uint = 1393;
pub const RTIT_STATUS_FILTEREN: ::kernel::sys::raw::c_uint = 1;
pub const RTIT_STATUS_CONTEXTEN: ::kernel::sys::raw::c_uint = 2;
pub const RTIT_STATUS_TRIGGEREN: ::kernel::sys::raw::c_uint = 4;
pub const RTIT_STATUS_ERROR: ::kernel::sys::raw::c_uint = 16;
pub const RTIT_STATUS_STOPPED: ::kernel::sys::raw::c_uint = 32;
pub const RTIT_STATUS_PACKETBYTECNT_S: ::kernel::sys::raw::c_uint = 32;
pub const RTIT_STATUS_PACKETBYTECNT_M: ::kernel::sys::raw::c_ulonglong =
    562945658454016;
pub const MSR_IA32_RTIT_CR3_MATCH: ::kernel::sys::raw::c_uint = 1394;
pub const MSR_IA32_RTIT_ADDR0_A: ::kernel::sys::raw::c_uint = 1408;
pub const MSR_IA32_RTIT_ADDR0_B: ::kernel::sys::raw::c_uint = 1409;
pub const MSR_IA32_RTIT_ADDR1_A: ::kernel::sys::raw::c_uint = 1410;
pub const MSR_IA32_RTIT_ADDR1_B: ::kernel::sys::raw::c_uint = 1411;
pub const MSR_IA32_RTIT_ADDR2_A: ::kernel::sys::raw::c_uint = 1412;
pub const MSR_IA32_RTIT_ADDR2_B: ::kernel::sys::raw::c_uint = 1413;
pub const MSR_IA32_RTIT_ADDR3_A: ::kernel::sys::raw::c_uint = 1414;
pub const MSR_IA32_RTIT_ADDR3_B: ::kernel::sys::raw::c_uint = 1415;
pub const TOPA_SIZE_S: ::kernel::sys::raw::c_uint = 6;
pub const TOPA_SIZE_M: ::kernel::sys::raw::c_uint = 960;
pub const TOPA_SIZE_4K: ::kernel::sys::raw::c_uint = 0;
pub const TOPA_SIZE_8K: ::kernel::sys::raw::c_uint = 64;
pub const TOPA_SIZE_16K: ::kernel::sys::raw::c_uint = 128;
pub const TOPA_SIZE_32K: ::kernel::sys::raw::c_uint = 192;
pub const TOPA_SIZE_64K: ::kernel::sys::raw::c_uint = 256;
pub const TOPA_SIZE_128K: ::kernel::sys::raw::c_uint = 320;
pub const TOPA_SIZE_256K: ::kernel::sys::raw::c_uint = 384;
pub const TOPA_SIZE_512K: ::kernel::sys::raw::c_uint = 448;
pub const TOPA_SIZE_1M: ::kernel::sys::raw::c_uint = 512;
pub const TOPA_SIZE_2M: ::kernel::sys::raw::c_uint = 576;
pub const TOPA_SIZE_4M: ::kernel::sys::raw::c_uint = 640;
pub const TOPA_SIZE_8M: ::kernel::sys::raw::c_uint = 704;
pub const TOPA_SIZE_16M: ::kernel::sys::raw::c_uint = 768;
pub const TOPA_SIZE_32M: ::kernel::sys::raw::c_uint = 832;
pub const TOPA_SIZE_64M: ::kernel::sys::raw::c_uint = 896;
pub const TOPA_SIZE_128M: ::kernel::sys::raw::c_uint = 960;
pub const TOPA_STOP: ::kernel::sys::raw::c_uint = 16;
pub const TOPA_INT: ::kernel::sys::raw::c_uint = 4;
pub const TOPA_END: ::kernel::sys::raw::c_uint = 1;
pub const APICBASE_RESERVED: ::kernel::sys::raw::c_uint = 767;
pub const APICBASE_BSP: ::kernel::sys::raw::c_uint = 256;
pub const APICBASE_X2APIC: ::kernel::sys::raw::c_uint = 1024;
pub const APICBASE_ENABLED: ::kernel::sys::raw::c_uint = 2048;
pub const APICBASE_ADDRESS: ::kernel::sys::raw::c_uint = 4294963200;
pub const IA32_FEATURE_CONTROL_LOCK: ::kernel::sys::raw::c_uint = 1;
pub const IA32_FEATURE_CONTROL_SMX_EN: ::kernel::sys::raw::c_uint = 2;
pub const IA32_FEATURE_CONTROL_VMX_EN: ::kernel::sys::raw::c_uint = 4;
pub const IA32_MISC_EN_FASTSTR: ::kernel::sys::raw::c_uint = 1;
pub const IA32_MISC_EN_ATCCE: ::kernel::sys::raw::c_uint = 8;
pub const IA32_MISC_EN_PERFMON: ::kernel::sys::raw::c_uint = 128;
pub const IA32_MISC_EN_PEBSU: ::kernel::sys::raw::c_uint = 4096;
pub const IA32_MISC_EN_ESSTE: ::kernel::sys::raw::c_uint = 65536;
pub const IA32_MISC_EN_MONE: ::kernel::sys::raw::c_uint = 262144;
pub const IA32_MISC_EN_LIMCPUID: ::kernel::sys::raw::c_uint = 4194304;
pub const IA32_MISC_EN_xTPRD: ::kernel::sys::raw::c_uint = 8388608;
pub const IA32_MISC_EN_XDD: ::kernel::sys::raw::c_ulonglong = 17179869184;
pub const IA32_SPEC_CTRL_IBRS: ::kernel::sys::raw::c_uint = 1;
pub const IA32_SPEC_CTRL_STIBP: ::kernel::sys::raw::c_uint = 2;
pub const IA32_SPEC_CTRL_SSBD: ::kernel::sys::raw::c_uint = 4;
pub const IA32_PRED_CMD_IBPB_BARRIER: ::kernel::sys::raw::c_uint = 1;
pub const PAT_UNCACHEABLE: ::kernel::sys::raw::c_uint = 0;
pub const PAT_WRITE_COMBINING: ::kernel::sys::raw::c_uint = 1;
pub const PAT_WRITE_THROUGH: ::kernel::sys::raw::c_uint = 4;
pub const PAT_WRITE_PROTECTED: ::kernel::sys::raw::c_uint = 5;
pub const PAT_WRITE_BACK: ::kernel::sys::raw::c_uint = 6;
pub const PAT_UNCACHED: ::kernel::sys::raw::c_uint = 7;
pub const MTRR_UNCACHEABLE: ::kernel::sys::raw::c_uint = 0;
pub const MTRR_WRITE_COMBINING: ::kernel::sys::raw::c_uint = 1;
pub const MTRR_WRITE_THROUGH: ::kernel::sys::raw::c_uint = 4;
pub const MTRR_WRITE_PROTECTED: ::kernel::sys::raw::c_uint = 5;
pub const MTRR_WRITE_BACK: ::kernel::sys::raw::c_uint = 6;
pub const MTRR_N64K: ::kernel::sys::raw::c_uint = 8;
pub const MTRR_N16K: ::kernel::sys::raw::c_uint = 16;
pub const MTRR_N4K: ::kernel::sys::raw::c_uint = 64;
pub const MTRR_CAP_WC: ::kernel::sys::raw::c_uint = 1024;
pub const MTRR_CAP_FIXED: ::kernel::sys::raw::c_uint = 256;
pub const MTRR_CAP_VCNT: ::kernel::sys::raw::c_uint = 255;
pub const MTRR_DEF_ENABLE: ::kernel::sys::raw::c_uint = 2048;
pub const MTRR_DEF_FIXED_ENABLE: ::kernel::sys::raw::c_uint = 1024;
pub const MTRR_DEF_TYPE: ::kernel::sys::raw::c_uint = 255;
pub const MTRR_PHYSBASE_PHYSBASE: ::kernel::sys::raw::c_ulonglong =
    4503599627366400;
pub const MTRR_PHYSBASE_TYPE: ::kernel::sys::raw::c_uint = 255;
pub const MTRR_PHYSMASK_PHYSMASK: ::kernel::sys::raw::c_ulonglong =
    4503599627366400;
pub const MTRR_PHYSMASK_VALID: ::kernel::sys::raw::c_uint = 2048;
pub const CCR0: ::kernel::sys::raw::c_uint = 192;
pub const CCR0_NC0: ::kernel::sys::raw::c_uint = 1;
pub const CCR0_NC1: ::kernel::sys::raw::c_uint = 2;
pub const CCR0_A20M: ::kernel::sys::raw::c_uint = 4;
pub const CCR0_KEN: ::kernel::sys::raw::c_uint = 8;
pub const CCR0_FLUSH: ::kernel::sys::raw::c_uint = 16;
pub const CCR0_BARB: ::kernel::sys::raw::c_uint = 32;
pub const CCR0_CO: ::kernel::sys::raw::c_uint = 64;
pub const CCR0_SUSPEND: ::kernel::sys::raw::c_uint = 128;
pub const CCR1: ::kernel::sys::raw::c_uint = 193;
pub const CCR1_RPL: ::kernel::sys::raw::c_uint = 1;
pub const CCR1_SMI: ::kernel::sys::raw::c_uint = 2;
pub const CCR1_SMAC: ::kernel::sys::raw::c_uint = 4;
pub const CCR1_MMAC: ::kernel::sys::raw::c_uint = 8;
pub const CCR1_NO_LOCK: ::kernel::sys::raw::c_uint = 16;
pub const CCR1_SM3: ::kernel::sys::raw::c_uint = 128;
pub const CCR2: ::kernel::sys::raw::c_uint = 194;
pub const CCR2_WB: ::kernel::sys::raw::c_uint = 2;
pub const CCR2_SADS: ::kernel::sys::raw::c_uint = 2;
pub const CCR2_LOCK_NW: ::kernel::sys::raw::c_uint = 4;
pub const CCR2_SUSP_HLT: ::kernel::sys::raw::c_uint = 8;
pub const CCR2_WT1: ::kernel::sys::raw::c_uint = 16;
pub const CCR2_WPR1: ::kernel::sys::raw::c_uint = 16;
pub const CCR2_BARB: ::kernel::sys::raw::c_uint = 32;
pub const CCR2_BWRT: ::kernel::sys::raw::c_uint = 64;
pub const CCR2_USE_SUSP: ::kernel::sys::raw::c_uint = 128;
pub const CCR3: ::kernel::sys::raw::c_uint = 195;
pub const CCR3_SMILOCK: ::kernel::sys::raw::c_uint = 1;
pub const CCR3_NMI: ::kernel::sys::raw::c_uint = 2;
pub const CCR3_LINBRST: ::kernel::sys::raw::c_uint = 4;
pub const CCR3_SMMMODE: ::kernel::sys::raw::c_uint = 8;
pub const CCR3_MAPEN0: ::kernel::sys::raw::c_uint = 16;
pub const CCR3_MAPEN1: ::kernel::sys::raw::c_uint = 32;
pub const CCR3_MAPEN2: ::kernel::sys::raw::c_uint = 64;
pub const CCR3_MAPEN3: ::kernel::sys::raw::c_uint = 128;
pub const CCR4: ::kernel::sys::raw::c_uint = 232;
pub const CCR4_IOMASK: ::kernel::sys::raw::c_uint = 7;
pub const CCR4_MEM: ::kernel::sys::raw::c_uint = 8;
pub const CCR4_DTE: ::kernel::sys::raw::c_uint = 16;
pub const CCR4_FASTFPE: ::kernel::sys::raw::c_uint = 32;
pub const CCR4_CPUID: ::kernel::sys::raw::c_uint = 128;
pub const CCR5: ::kernel::sys::raw::c_uint = 233;
pub const CCR5_WT_ALLOC: ::kernel::sys::raw::c_uint = 1;
pub const CCR5_SLOP: ::kernel::sys::raw::c_uint = 2;
pub const CCR5_LBR1: ::kernel::sys::raw::c_uint = 16;
pub const CCR5_ARREN: ::kernel::sys::raw::c_uint = 32;
pub const CCR6: ::kernel::sys::raw::c_uint = 234;
pub const CCR7: ::kernel::sys::raw::c_uint = 235;
pub const PCR0: ::kernel::sys::raw::c_uint = 32;
pub const PCR0_RSTK: ::kernel::sys::raw::c_uint = 1;
pub const PCR0_BTB: ::kernel::sys::raw::c_uint = 2;
pub const PCR0_LOOP: ::kernel::sys::raw::c_uint = 4;
pub const PCR0_AIS: ::kernel::sys::raw::c_uint = 8;
pub const PCR0_MLR: ::kernel::sys::raw::c_uint = 16;
pub const PCR0_BTBRT: ::kernel::sys::raw::c_uint = 64;
pub const PCR0_LSSER: ::kernel::sys::raw::c_uint = 128;
pub const DIR0: ::kernel::sys::raw::c_uint = 254;
pub const DIR1: ::kernel::sys::raw::c_uint = 255;
pub const MCG_CAP_COUNT: ::kernel::sys::raw::c_uint = 255;
pub const MCG_CAP_CTL_P: ::kernel::sys::raw::c_uint = 256;
pub const MCG_CAP_EXT_P: ::kernel::sys::raw::c_uint = 512;
pub const MCG_CAP_CMCI_P: ::kernel::sys::raw::c_uint = 1024;
pub const MCG_CAP_TES_P: ::kernel::sys::raw::c_uint = 2048;
pub const MCG_CAP_EXT_CNT: ::kernel::sys::raw::c_uint = 16711680;
pub const MCG_CAP_SER_P: ::kernel::sys::raw::c_uint = 16777216;
pub const MCG_STATUS_RIPV: ::kernel::sys::raw::c_uint = 1;
pub const MCG_STATUS_EIPV: ::kernel::sys::raw::c_uint = 2;
pub const MCG_STATUS_MCIP: ::kernel::sys::raw::c_uint = 4;
pub const MCG_CTL_ENABLE: ::kernel::sys::raw::c_int = -1;
pub const MCG_CTL_DISABLE: ::kernel::sys::raw::c_uint = 0;
pub const MC_STATUS_MCA_ERROR: ::kernel::sys::raw::c_uint = 65535;
pub const MC_STATUS_MODEL_ERROR: ::kernel::sys::raw::c_uint = 4294901760;
pub const MC_STATUS_OTHER_INFO: ::kernel::sys::raw::c_ulonglong =
    144115183780888576;
pub const MC_STATUS_COR_COUNT: ::kernel::sys::raw::c_ulonglong =
    9006924376834048;
pub const MC_STATUS_TES_STATUS: ::kernel::sys::raw::c_ulonglong =
    27021597764222976;
pub const MC_STATUS_AR: ::kernel::sys::raw::c_ulonglong = 36028797018963968;
pub const MC_STATUS_S: ::kernel::sys::raw::c_ulonglong = 72057594037927936;
pub const MC_STATUS_PCC: ::kernel::sys::raw::c_ulonglong = 144115188075855872;
pub const MC_STATUS_ADDRV: ::kernel::sys::raw::c_ulonglong =
    288230376151711744;
pub const MC_STATUS_MISCV: ::kernel::sys::raw::c_ulonglong =
    576460752303423488;
pub const MC_STATUS_EN: ::kernel::sys::raw::c_ulonglong = 1152921504606846976;
pub const MC_STATUS_UC: ::kernel::sys::raw::c_ulonglong = 2305843009213693952;
pub const MC_STATUS_OVER: ::kernel::sys::raw::c_ulonglong =
    4611686018427387904;
pub const MC_STATUS_VAL: ::kernel::sys::raw::c_longlong =
    -9223372036854775808;
pub const MC_MISC_RA_LSB: ::kernel::sys::raw::c_uint = 63;
pub const MC_MISC_ADDRESS_MODE: ::kernel::sys::raw::c_uint = 448;
pub const MC_CTL2_THRESHOLD: ::kernel::sys::raw::c_uint = 32767;
pub const MC_CTL2_CMCI_EN: ::kernel::sys::raw::c_uint = 1073741824;
pub const MC_AMDNB_BANK: ::kernel::sys::raw::c_uint = 4;
pub const MC_MISC_AMD_VAL: ::kernel::sys::raw::c_longlong =
    -9223372036854775808;
pub const MC_MISC_AMD_CNTP: ::kernel::sys::raw::c_ulonglong =
    4611686018427387904;
pub const MC_MISC_AMD_LOCK: ::kernel::sys::raw::c_ulonglong =
    2305843009213693952;
pub const MC_MISC_AMD_INTP: ::kernel::sys::raw::c_ulonglong =
    1152921504606846976;
pub const MC_MISC_AMD_LVT_MASK: ::kernel::sys::raw::c_ulonglong =
    67553994410557440;
pub const MC_MISC_AMD_LVT_SHIFT: ::kernel::sys::raw::c_uint = 52;
pub const MC_MISC_AMD_CNTEN: ::kernel::sys::raw::c_ulonglong =
    2251799813685248;
pub const MC_MISC_AMD_INT_MASK: ::kernel::sys::raw::c_ulonglong =
    1688849860263936;
pub const MC_MISC_AMD_INT_LVT: ::kernel::sys::raw::c_ulonglong =
    562949953421312;
pub const MC_MISC_AMD_INT_SMI: ::kernel::sys::raw::c_ulonglong =
    1125899906842624;
pub const MC_MISC_AMD_OVERFLOW: ::kernel::sys::raw::c_ulonglong =
    281474976710656;
pub const MC_MISC_AMD_CNT_MASK: ::kernel::sys::raw::c_ulonglong =
    17587891077120;
pub const MC_MISC_AMD_CNT_SHIFT: ::kernel::sys::raw::c_uint = 32;
pub const MC_MISC_AMD_CNT_MAX: ::kernel::sys::raw::c_uint = 4095;
pub const MC_MISC_AMD_PTR_MASK: ::kernel::sys::raw::c_uint = 4278190080;
pub const MC_MISC_AMD_PTR_SHIFT: ::kernel::sys::raw::c_uint = 24;
pub const NCR1: ::kernel::sys::raw::c_uint = 196;
pub const NCR2: ::kernel::sys::raw::c_uint = 199;
pub const NCR3: ::kernel::sys::raw::c_uint = 202;
pub const NCR4: ::kernel::sys::raw::c_uint = 205;
pub const NCR_SIZE_0K: ::kernel::sys::raw::c_uint = 0;
pub const NCR_SIZE_4K: ::kernel::sys::raw::c_uint = 1;
pub const NCR_SIZE_8K: ::kernel::sys::raw::c_uint = 2;
pub const NCR_SIZE_16K: ::kernel::sys::raw::c_uint = 3;
pub const NCR_SIZE_32K: ::kernel::sys::raw::c_uint = 4;
pub const NCR_SIZE_64K: ::kernel::sys::raw::c_uint = 5;
pub const NCR_SIZE_128K: ::kernel::sys::raw::c_uint = 6;
pub const NCR_SIZE_256K: ::kernel::sys::raw::c_uint = 7;
pub const NCR_SIZE_512K: ::kernel::sys::raw::c_uint = 8;
pub const NCR_SIZE_1M: ::kernel::sys::raw::c_uint = 9;
pub const NCR_SIZE_2M: ::kernel::sys::raw::c_uint = 10;
pub const NCR_SIZE_4M: ::kernel::sys::raw::c_uint = 11;
pub const NCR_SIZE_8M: ::kernel::sys::raw::c_uint = 12;
pub const NCR_SIZE_16M: ::kernel::sys::raw::c_uint = 13;
pub const NCR_SIZE_32M: ::kernel::sys::raw::c_uint = 14;
pub const NCR_SIZE_4G: ::kernel::sys::raw::c_uint = 15;
pub const ARR0: ::kernel::sys::raw::c_uint = 196;
pub const ARR1: ::kernel::sys::raw::c_uint = 199;
pub const ARR2: ::kernel::sys::raw::c_uint = 202;
pub const ARR3: ::kernel::sys::raw::c_uint = 205;
pub const ARR4: ::kernel::sys::raw::c_uint = 208;
pub const ARR5: ::kernel::sys::raw::c_uint = 211;
pub const ARR6: ::kernel::sys::raw::c_uint = 214;
pub const ARR7: ::kernel::sys::raw::c_uint = 217;
pub const ARR_SIZE_0K: ::kernel::sys::raw::c_uint = 0;
pub const ARR_SIZE_4K: ::kernel::sys::raw::c_uint = 1;
pub const ARR_SIZE_8K: ::kernel::sys::raw::c_uint = 2;
pub const ARR_SIZE_16K: ::kernel::sys::raw::c_uint = 3;
pub const ARR_SIZE_32K: ::kernel::sys::raw::c_uint = 4;
pub const ARR_SIZE_64K: ::kernel::sys::raw::c_uint = 5;
pub const ARR_SIZE_128K: ::kernel::sys::raw::c_uint = 6;
pub const ARR_SIZE_256K: ::kernel::sys::raw::c_uint = 7;
pub const ARR_SIZE_512K: ::kernel::sys::raw::c_uint = 8;
pub const ARR_SIZE_1M: ::kernel::sys::raw::c_uint = 9;
pub const ARR_SIZE_2M: ::kernel::sys::raw::c_uint = 10;
pub const ARR_SIZE_4M: ::kernel::sys::raw::c_uint = 11;
pub const ARR_SIZE_8M: ::kernel::sys::raw::c_uint = 12;
pub const ARR_SIZE_16M: ::kernel::sys::raw::c_uint = 13;
pub const ARR_SIZE_32M: ::kernel::sys::raw::c_uint = 14;
pub const ARR_SIZE_4G: ::kernel::sys::raw::c_uint = 15;
pub const RCR0: ::kernel::sys::raw::c_uint = 220;
pub const RCR1: ::kernel::sys::raw::c_uint = 221;
pub const RCR2: ::kernel::sys::raw::c_uint = 222;
pub const RCR3: ::kernel::sys::raw::c_uint = 223;
pub const RCR4: ::kernel::sys::raw::c_uint = 224;
pub const RCR5: ::kernel::sys::raw::c_uint = 225;
pub const RCR6: ::kernel::sys::raw::c_uint = 226;
pub const RCR7: ::kernel::sys::raw::c_uint = 227;
pub const RCR_RCD: ::kernel::sys::raw::c_uint = 1;
pub const RCR_RCE: ::kernel::sys::raw::c_uint = 1;
pub const RCR_WWO: ::kernel::sys::raw::c_uint = 2;
pub const RCR_WL: ::kernel::sys::raw::c_uint = 4;
pub const RCR_WG: ::kernel::sys::raw::c_uint = 8;
pub const RCR_WT: ::kernel::sys::raw::c_uint = 16;
pub const RCR_NLB: ::kernel::sys::raw::c_uint = 32;
pub const AMD_WT_ALLOC_TME: ::kernel::sys::raw::c_uint = 262144;
pub const AMD_WT_ALLOC_PRE: ::kernel::sys::raw::c_uint = 131072;
pub const AMD_WT_ALLOC_FRE: ::kernel::sys::raw::c_uint = 65536;
pub const MSR_EFER: ::kernel::sys::raw::c_uint = 3221225600;
pub const MSR_STAR: ::kernel::sys::raw::c_uint = 3221225601;
pub const MSR_LSTAR: ::kernel::sys::raw::c_uint = 3221225602;
pub const MSR_CSTAR: ::kernel::sys::raw::c_uint = 3221225603;
pub const MSR_SF_MASK: ::kernel::sys::raw::c_uint = 3221225604;
pub const MSR_KGSBASE: ::kernel::sys::raw::c_uint = 3221225730;
pub const MSR_PERFEVSEL0: ::kernel::sys::raw::c_uint = 3221291008;
pub const MSR_PERFEVSEL1: ::kernel::sys::raw::c_uint = 3221291009;
pub const MSR_PERFEVSEL2: ::kernel::sys::raw::c_uint = 3221291010;
pub const MSR_PERFEVSEL3: ::kernel::sys::raw::c_uint = 3221291011;
pub const MSR_K7_PERFCTR0: ::kernel::sys::raw::c_uint = 3221291012;
pub const MSR_K7_PERFCTR1: ::kernel::sys::raw::c_uint = 3221291013;
pub const MSR_K7_PERFCTR2: ::kernel::sys::raw::c_uint = 3221291014;
pub const MSR_K7_PERFCTR3: ::kernel::sys::raw::c_uint = 3221291015;
pub const MSR_SYSCFG: ::kernel::sys::raw::c_uint = 3221291024;
pub const MSR_HWCR: ::kernel::sys::raw::c_uint = 3221291029;
pub const MSR_IORRBASE0: ::kernel::sys::raw::c_uint = 3221291030;
pub const MSR_IORRMASK0: ::kernel::sys::raw::c_uint = 3221291031;
pub const MSR_IORRBASE1: ::kernel::sys::raw::c_uint = 3221291032;
pub const MSR_IORRMASK1: ::kernel::sys::raw::c_uint = 3221291033;
pub const MSR_TOP_MEM: ::kernel::sys::raw::c_uint = 3221291034;
pub const MSR_TOP_MEM2: ::kernel::sys::raw::c_uint = 3221291037;
pub const MSR_NB_CFG1: ::kernel::sys::raw::c_uint = 3221291039;
pub const MSR_P_STATE_LIMIT: ::kernel::sys::raw::c_uint = 3221291105;
pub const MSR_P_STATE_CONTROL: ::kernel::sys::raw::c_uint = 3221291106;
pub const MSR_P_STATE_STATUS: ::kernel::sys::raw::c_uint = 3221291107;
pub const MSR_SMM_ADDR: ::kernel::sys::raw::c_uint = 3221291282;
pub const MSR_SMM_MASK: ::kernel::sys::raw::c_uint = 3221291283;
pub const MSR_EXTFEATURES: ::kernel::sys::raw::c_uint = 3221295109;
pub const MSR_IC_CFG: ::kernel::sys::raw::c_uint = 3221295137;
pub const MSR_K8_UCODE_UPDATE: ::kernel::sys::raw::c_uint = 3221291040;
pub const MSR_MC0_CTL_MASK: ::kernel::sys::raw::c_uint = 3221291076;
pub const MSR_VM_CR: ::kernel::sys::raw::c_uint = 3221291284;
pub const MSR_VM_HSAVE_PA: ::kernel::sys::raw::c_uint = 3221291287;
pub const VM_CR_SVMDIS: ::kernel::sys::raw::c_uint = 16;
pub const VIA_HAS_RNG: ::kernel::sys::raw::c_uint = 1;
pub const VIA_HAS_AES: ::kernel::sys::raw::c_uint = 1;
pub const VIA_HAS_SHA: ::kernel::sys::raw::c_uint = 2;
pub const VIA_HAS_MM: ::kernel::sys::raw::c_uint = 4;
pub const VIA_HAS_AESCTR: ::kernel::sys::raw::c_uint = 8;
pub const VIA_CPUID_HAS_RNG: ::kernel::sys::raw::c_uint = 4;
pub const VIA_CPUID_DO_RNG: ::kernel::sys::raw::c_uint = 8;
pub const VIA_CPUID_HAS_ACE: ::kernel::sys::raw::c_uint = 64;
pub const VIA_CPUID_DO_ACE: ::kernel::sys::raw::c_uint = 128;
pub const VIA_CPUID_HAS_ACE2: ::kernel::sys::raw::c_uint = 256;
pub const VIA_CPUID_DO_ACE2: ::kernel::sys::raw::c_uint = 512;
pub const VIA_CPUID_HAS_PHE: ::kernel::sys::raw::c_uint = 1024;
pub const VIA_CPUID_DO_PHE: ::kernel::sys::raw::c_uint = 2048;
pub const VIA_CPUID_HAS_PMM: ::kernel::sys::raw::c_uint = 4096;
pub const VIA_CPUID_DO_PMM: ::kernel::sys::raw::c_uint = 8192;
pub const VIA_CRYPT_CWLO_ROUND_M: ::kernel::sys::raw::c_uint = 15;
pub const VIA_CRYPT_CWLO_ALG_M: ::kernel::sys::raw::c_uint = 112;
pub const VIA_CRYPT_CWLO_ALG_AES: ::kernel::sys::raw::c_uint = 0;
pub const VIA_CRYPT_CWLO_KEYGEN_M: ::kernel::sys::raw::c_uint = 128;
pub const VIA_CRYPT_CWLO_KEYGEN_HW: ::kernel::sys::raw::c_uint = 0;
pub const VIA_CRYPT_CWLO_KEYGEN_SW: ::kernel::sys::raw::c_uint = 128;
pub const VIA_CRYPT_CWLO_NORMAL: ::kernel::sys::raw::c_uint = 0;
pub const VIA_CRYPT_CWLO_INTERMEDIATE: ::kernel::sys::raw::c_uint = 256;
pub const VIA_CRYPT_CWLO_ENCRYPT: ::kernel::sys::raw::c_uint = 0;
pub const VIA_CRYPT_CWLO_DECRYPT: ::kernel::sys::raw::c_uint = 512;
pub const VIA_CRYPT_CWLO_KEY128: ::kernel::sys::raw::c_uint = 10;
pub const VIA_CRYPT_CWLO_KEY192: ::kernel::sys::raw::c_uint = 1036;
pub const VIA_CRYPT_CWLO_KEY256: ::kernel::sys::raw::c_uint = 2062;
pub const X86_PG_V: ::kernel::sys::raw::c_uint = 1;
pub const X86_PG_RW: ::kernel::sys::raw::c_uint = 2;
pub const X86_PG_U: ::kernel::sys::raw::c_uint = 4;
pub const X86_PG_NC_PWT: ::kernel::sys::raw::c_uint = 8;
pub const X86_PG_NC_PCD: ::kernel::sys::raw::c_uint = 16;
pub const X86_PG_A: ::kernel::sys::raw::c_uint = 32;
pub const X86_PG_M: ::kernel::sys::raw::c_uint = 64;
pub const X86_PG_PS: ::kernel::sys::raw::c_uint = 128;
pub const X86_PG_PTE_PAT: ::kernel::sys::raw::c_uint = 128;
pub const X86_PG_G: ::kernel::sys::raw::c_uint = 256;
pub const X86_PG_AVAIL1: ::kernel::sys::raw::c_uint = 512;
pub const X86_PG_AVAIL2: ::kernel::sys::raw::c_uint = 1024;
pub const X86_PG_AVAIL3: ::kernel::sys::raw::c_uint = 2048;
pub const X86_PG_PDE_PAT: ::kernel::sys::raw::c_uint = 4096;
pub const X86_PG_NX: ::kernel::sys::raw::c_longlong = -9223372036854775808;
pub const X86_PG_PDE_CACHE: ::kernel::sys::raw::c_uint = 4120;
pub const X86_PG_PTE_CACHE: ::kernel::sys::raw::c_uint = 152;
pub const EPT_PG_READ: ::kernel::sys::raw::c_uint = 1;
pub const EPT_PG_WRITE: ::kernel::sys::raw::c_uint = 2;
pub const EPT_PG_EXECUTE: ::kernel::sys::raw::c_uint = 4;
pub const EPT_PG_IGNORE_PAT: ::kernel::sys::raw::c_uint = 64;
pub const EPT_PG_PS: ::kernel::sys::raw::c_uint = 128;
pub const EPT_PG_A: ::kernel::sys::raw::c_uint = 256;
pub const EPT_PG_M: ::kernel::sys::raw::c_uint = 512;
pub const PG_V: ::kernel::sys::raw::c_uint = 1;
pub const PG_RW: ::kernel::sys::raw::c_uint = 2;
pub const PG_U: ::kernel::sys::raw::c_uint = 4;
pub const PG_NC_PWT: ::kernel::sys::raw::c_uint = 8;
pub const PG_NC_PCD: ::kernel::sys::raw::c_uint = 16;
pub const PG_A: ::kernel::sys::raw::c_uint = 32;
pub const PG_M: ::kernel::sys::raw::c_uint = 64;
pub const PG_PS: ::kernel::sys::raw::c_uint = 128;
pub const PG_PTE_PAT: ::kernel::sys::raw::c_uint = 128;
pub const PG_G: ::kernel::sys::raw::c_uint = 256;
pub const PG_AVAIL1: ::kernel::sys::raw::c_uint = 512;
pub const PG_AVAIL2: ::kernel::sys::raw::c_uint = 1024;
pub const PG_AVAIL3: ::kernel::sys::raw::c_uint = 2048;
pub const PG_PDE_PAT: ::kernel::sys::raw::c_uint = 4096;
pub const PG_NX: ::kernel::sys::raw::c_longlong = -9223372036854775808;
pub const PG_PDE_CACHE: ::kernel::sys::raw::c_uint = 4120;
pub const PG_PTE_CACHE: ::kernel::sys::raw::c_uint = 152;
pub const PG_W: ::kernel::sys::raw::c_uint = 2048;
pub const PG_MANAGED: ::kernel::sys::raw::c_uint = 1024;
pub const PG_FRAME: ::kernel::sys::raw::c_ulonglong = 4503599627366400;
pub const PG_PS_FRAME: ::kernel::sys::raw::c_ulonglong = 4503599625273344;
pub const PG_PTE_PROMOTE: ::kernel::sys::raw::c_longlong =
    -9223372036854772225;
pub const PGEX_P: ::kernel::sys::raw::c_uint = 1;
pub const PGEX_W: ::kernel::sys::raw::c_uint = 2;
pub const PGEX_U: ::kernel::sys::raw::c_uint = 4;
pub const PGEX_RSV: ::kernel::sys::raw::c_uint = 8;
pub const PGEX_I: ::kernel::sys::raw::c_uint = 16;
pub const NKPML4E: ::kernel::sys::raw::c_uint = 4;
pub const NDMPML4E: ::kernel::sys::raw::c_uint = 8;
pub const ISA_HOLE_START: ::kernel::sys::raw::c_uint = 655360;
pub const ISA_HOLE_LENGTH: ::kernel::sys::raw::c_uint = 393216;
pub const PMAP_PCID_NONE: ::kernel::sys::raw::c_uint = 4294967295;
pub const PMAP_PCID_KERN: ::kernel::sys::raw::c_uint = 0;
pub const PMAP_PCID_OVERMAX: ::kernel::sys::raw::c_uint = 4096;
pub const PMAP_PCID_OVERMAX_KERN: ::kernel::sys::raw::c_uint = 2048;
pub const PMAP_PCID_USER_PT: ::kernel::sys::raw::c_uint = 2048;
pub const PMAP_NO_CR3: ::kernel::sys::raw::c_int = -1;
pub const PMAP_NESTED_IPIMASK: ::kernel::sys::raw::c_uint = 255;
pub const PMAP_PDE_SUPERPAGE: ::kernel::sys::raw::c_uint = 256;
pub const PMAP_EMULATE_AD_BITS: ::kernel::sys::raw::c_uint = 512;
pub const PMAP_SUPPORTS_EXEC_ONLY: ::kernel::sys::raw::c_uint = 1024;
pub const _NPCM: ::kernel::sys::raw::c_uint = 3;
pub const _NPCPV: ::kernel::sys::raw::c_uint = 168;
pub const PMAP_ENTER_NOSLEEP: ::kernel::sys::raw::c_uint = 256;
pub const PMAP_ENTER_WIRED: ::kernel::sys::raw::c_uint = 512;
pub const PMAP_ENTER_RESERVED: ::kernel::sys::raw::c_uint = 4278190080;
pub const PMAP_TS_REFERENCED_MAX: ::kernel::sys::raw::c_uint = 5;
pub const HAS_TIMER_SPKR: ::kernel::sys::raw::c_uint = 1;
pub const DBG: ::kernel::sys::raw::c_uint = 0;
pub const CMD_MEM_WRT_INVALIDATE: ::kernel::sys::raw::c_uint = 16;
pub const PCI_COMMAND_REGISTER: ::kernel::sys::raw::c_uint = 4;
pub const E1000_CTRL: ::kernel::sys::raw::c_uint = 0;
pub const E1000_CTRL_DUP: ::kernel::sys::raw::c_uint = 4;
pub const E1000_STATUS: ::kernel::sys::raw::c_uint = 8;
pub const E1000_EECD: ::kernel::sys::raw::c_uint = 16;
pub const E1000_EERD: ::kernel::sys::raw::c_uint = 20;
pub const E1000_CTRL_EXT: ::kernel::sys::raw::c_uint = 24;
pub const E1000_FLA: ::kernel::sys::raw::c_uint = 28;
pub const E1000_MDIC: ::kernel::sys::raw::c_uint = 32;
pub const E1000_MDICNFG: ::kernel::sys::raw::c_uint = 3588;
pub const E1000_REGISTER_SET_SIZE: ::kernel::sys::raw::c_uint = 131072;
pub const E1000_EEPROM_INIT_CTRL_WORD_2: ::kernel::sys::raw::c_uint = 15;
pub const E1000_EEPROM_PCIE_CTRL_WORD_2: ::kernel::sys::raw::c_uint = 40;
pub const E1000_BARCTRL: ::kernel::sys::raw::c_uint = 23484;
pub const E1000_BARCTRL_FLSIZE: ::kernel::sys::raw::c_uint = 1792;
pub const E1000_BARCTRL_CSRSIZE: ::kernel::sys::raw::c_uint = 8192;
pub const E1000_MPHY_ADDR_CTRL: ::kernel::sys::raw::c_uint = 36;
pub const E1000_MPHY_DATA: ::kernel::sys::raw::c_uint = 3600;
pub const E1000_MPHY_STAT: ::kernel::sys::raw::c_uint = 3596;
pub const E1000_PPHY_CTRL: ::kernel::sys::raw::c_uint = 23368;
pub const E1000_I350_BARCTRL: ::kernel::sys::raw::c_uint = 23548;
pub const E1000_I350_DTXMXPKTSZ: ::kernel::sys::raw::c_uint = 13660;
pub const E1000_SCTL: ::kernel::sys::raw::c_uint = 36;
pub const E1000_FCAL: ::kernel::sys::raw::c_uint = 40;
pub const E1000_FCAH: ::kernel::sys::raw::c_uint = 44;
pub const E1000_FEXT: ::kernel::sys::raw::c_uint = 44;
pub const E1000_FEXTNVM: ::kernel::sys::raw::c_uint = 40;
pub const E1000_FEXTNVM3: ::kernel::sys::raw::c_uint = 60;
pub const E1000_FEXTNVM4: ::kernel::sys::raw::c_uint = 36;
pub const E1000_FEXTNVM6: ::kernel::sys::raw::c_uint = 16;
pub const E1000_FEXTNVM7: ::kernel::sys::raw::c_uint = 228;
pub const E1000_FEXTNVM9: ::kernel::sys::raw::c_uint = 23476;
pub const E1000_FEXTNVM11: ::kernel::sys::raw::c_uint = 23484;
pub const E1000_PCIEANACFG: ::kernel::sys::raw::c_uint = 3864;
pub const E1000_FCT: ::kernel::sys::raw::c_uint = 48;
pub const E1000_CONNSW: ::kernel::sys::raw::c_uint = 52;
pub const E1000_VET: ::kernel::sys::raw::c_uint = 56;
pub const E1000_ICR: ::kernel::sys::raw::c_uint = 192;
pub const E1000_ITR: ::kernel::sys::raw::c_uint = 196;
pub const E1000_ICS: ::kernel::sys::raw::c_uint = 200;
pub const E1000_IMS: ::kernel::sys::raw::c_uint = 208;
pub const E1000_IMC: ::kernel::sys::raw::c_uint = 216;
pub const E1000_IAM: ::kernel::sys::raw::c_uint = 224;
pub const E1000_IVAR: ::kernel::sys::raw::c_uint = 228;
pub const E1000_SVCR: ::kernel::sys::raw::c_uint = 240;
pub const E1000_SVT: ::kernel::sys::raw::c_uint = 244;
pub const E1000_LPIC: ::kernel::sys::raw::c_uint = 252;
pub const E1000_RCTL: ::kernel::sys::raw::c_uint = 256;
pub const E1000_FCTTV: ::kernel::sys::raw::c_uint = 368;
pub const E1000_TXCW: ::kernel::sys::raw::c_uint = 376;
pub const E1000_RXCW: ::kernel::sys::raw::c_uint = 384;
pub const E1000_PBA_ECC: ::kernel::sys::raw::c_uint = 4352;
pub const E1000_EICR: ::kernel::sys::raw::c_uint = 5504;
pub const E1000_EICS: ::kernel::sys::raw::c_uint = 5408;
pub const E1000_EIMS: ::kernel::sys::raw::c_uint = 5412;
pub const E1000_EIMC: ::kernel::sys::raw::c_uint = 5416;
pub const E1000_EIAC: ::kernel::sys::raw::c_uint = 5420;
pub const E1000_EIAM: ::kernel::sys::raw::c_uint = 5424;
pub const E1000_GPIE: ::kernel::sys::raw::c_uint = 5396;
pub const E1000_IVAR0: ::kernel::sys::raw::c_uint = 5888;
pub const E1000_IVAR_MISC: ::kernel::sys::raw::c_uint = 5952;
pub const E1000_TCTL: ::kernel::sys::raw::c_uint = 1024;
pub const E1000_TCTL_EXT: ::kernel::sys::raw::c_uint = 1028;
pub const E1000_TIPG: ::kernel::sys::raw::c_uint = 1040;
pub const E1000_TBT: ::kernel::sys::raw::c_uint = 1096;
pub const E1000_AIT: ::kernel::sys::raw::c_uint = 1112;
pub const E1000_LEDCTL: ::kernel::sys::raw::c_uint = 3584;
pub const E1000_LEDMUX: ::kernel::sys::raw::c_uint = 33072;
pub const E1000_EXTCNF_CTRL: ::kernel::sys::raw::c_uint = 3840;
pub const E1000_EXTCNF_SIZE: ::kernel::sys::raw::c_uint = 3848;
pub const E1000_PHY_CTRL: ::kernel::sys::raw::c_uint = 3856;
pub const E1000_POEMB: ::kernel::sys::raw::c_uint = 3856;
pub const E1000_PBA: ::kernel::sys::raw::c_uint = 4096;
pub const E1000_PBS: ::kernel::sys::raw::c_uint = 4104;
pub const E1000_PBECCSTS: ::kernel::sys::raw::c_uint = 4108;
pub const E1000_IOSFPC: ::kernel::sys::raw::c_uint = 3880;
pub const E1000_EEMNGCTL: ::kernel::sys::raw::c_uint = 4112;
pub const E1000_EEMNGCTL_I210: ::kernel::sys::raw::c_uint = 4112;
pub const E1000_EEARBC: ::kernel::sys::raw::c_uint = 4132;
pub const E1000_EEARBC_I210: ::kernel::sys::raw::c_uint = 73764;
pub const E1000_FLASHT: ::kernel::sys::raw::c_uint = 4136;
pub const E1000_EEWR: ::kernel::sys::raw::c_uint = 4140;
pub const E1000_FLSWCTL: ::kernel::sys::raw::c_uint = 4144;
pub const E1000_FLSWDATA: ::kernel::sys::raw::c_uint = 4148;
pub const E1000_FLSWCNT: ::kernel::sys::raw::c_uint = 4152;
pub const E1000_FLOP: ::kernel::sys::raw::c_uint = 4156;
pub const E1000_I2CCMD: ::kernel::sys::raw::c_uint = 4136;
pub const E1000_I2CPARAMS: ::kernel::sys::raw::c_uint = 4140;
pub const E1000_I2CBB_EN: ::kernel::sys::raw::c_uint = 256;
pub const E1000_I2C_CLK_OUT: ::kernel::sys::raw::c_uint = 512;
pub const E1000_I2C_DATA_OUT: ::kernel::sys::raw::c_uint = 1024;
pub const E1000_I2C_DATA_OE_N: ::kernel::sys::raw::c_uint = 2048;
pub const E1000_I2C_DATA_IN: ::kernel::sys::raw::c_uint = 4096;
pub const E1000_I2C_CLK_OE_N: ::kernel::sys::raw::c_uint = 8192;
pub const E1000_I2C_CLK_IN: ::kernel::sys::raw::c_uint = 16384;
pub const E1000_I2C_CLK_STRETCH_DIS: ::kernel::sys::raw::c_uint = 32768;
pub const E1000_WDSTP: ::kernel::sys::raw::c_uint = 4160;
pub const E1000_SWDSTS: ::kernel::sys::raw::c_uint = 4164;
pub const E1000_FRTIMER: ::kernel::sys::raw::c_uint = 4168;
pub const E1000_TCPTIMER: ::kernel::sys::raw::c_uint = 4172;
pub const E1000_VPDDIAG: ::kernel::sys::raw::c_uint = 4192;
pub const E1000_ICR_V2: ::kernel::sys::raw::c_uint = 5376;
pub const E1000_ICS_V2: ::kernel::sys::raw::c_uint = 5380;
pub const E1000_IMS_V2: ::kernel::sys::raw::c_uint = 5384;
pub const E1000_IMC_V2: ::kernel::sys::raw::c_uint = 5388;
pub const E1000_IAM_V2: ::kernel::sys::raw::c_uint = 5392;
pub const E1000_ERT: ::kernel::sys::raw::c_uint = 8200;
pub const E1000_FCRTL: ::kernel::sys::raw::c_uint = 8544;
pub const E1000_FCRTH: ::kernel::sys::raw::c_uint = 8552;
pub const E1000_PSRCTL: ::kernel::sys::raw::c_uint = 8560;
pub const E1000_RDFH: ::kernel::sys::raw::c_uint = 9232;
pub const E1000_RDFT: ::kernel::sys::raw::c_uint = 9240;
pub const E1000_RDFHS: ::kernel::sys::raw::c_uint = 9248;
pub const E1000_RDFTS: ::kernel::sys::raw::c_uint = 9256;
pub const E1000_RDFPC: ::kernel::sys::raw::c_uint = 9264;
pub const E1000_PBRTH: ::kernel::sys::raw::c_uint = 9304;
pub const E1000_FCRTV: ::kernel::sys::raw::c_uint = 9312;
pub const E1000_RDPUMB: ::kernel::sys::raw::c_uint = 9676;
pub const E1000_RDPUAD: ::kernel::sys::raw::c_uint = 9680;
pub const E1000_RDPUWD: ::kernel::sys::raw::c_uint = 9684;
pub const E1000_RDPURD: ::kernel::sys::raw::c_uint = 9688;
pub const E1000_RDPUCTL: ::kernel::sys::raw::c_uint = 9692;
pub const E1000_PBDIAG: ::kernel::sys::raw::c_uint = 9304;
pub const E1000_RXPBS: ::kernel::sys::raw::c_uint = 9220;
pub const E1000_IRPBS: ::kernel::sys::raw::c_uint = 9220;
pub const E1000_PBRWAC: ::kernel::sys::raw::c_uint = 9448;
pub const E1000_RDTR: ::kernel::sys::raw::c_uint = 10272;
pub const E1000_RADV: ::kernel::sys::raw::c_uint = 10284;
pub const E1000_EMIADD: ::kernel::sys::raw::c_uint = 16;
pub const E1000_EMIDATA: ::kernel::sys::raw::c_uint = 17;
pub const E1000_SRWR: ::kernel::sys::raw::c_uint = 73752;
pub const E1000_I210_FLMNGCTL: ::kernel::sys::raw::c_uint = 73784;
pub const E1000_I210_FLMNGDATA: ::kernel::sys::raw::c_uint = 73788;
pub const E1000_I210_FLMNGCNT: ::kernel::sys::raw::c_uint = 73792;
pub const E1000_I210_FLSWCTL: ::kernel::sys::raw::c_uint = 73800;
pub const E1000_I210_FLSWDATA: ::kernel::sys::raw::c_uint = 73804;
pub const E1000_I210_FLSWCNT: ::kernel::sys::raw::c_uint = 73808;
pub const E1000_I210_FLA: ::kernel::sys::raw::c_uint = 73756;
pub const E1000_INVM_SIZE: ::kernel::sys::raw::c_uint = 64;
pub const E1000_I210_TQAVCTRL: ::kernel::sys::raw::c_uint = 13680;
pub const E1000_TQAVCTRL_MODE: ::kernel::sys::raw::c_uint = 1;
pub const E1000_TQAVCTRL_FETCH_ARB: ::kernel::sys::raw::c_uint = 16;
pub const E1000_TQAVCTRL_FETCH_TIMER_ENABLE: ::kernel::sys::raw::c_uint = 32;
pub const E1000_TQAVCTRL_LAUNCH_ARB: ::kernel::sys::raw::c_uint = 256;
pub const E1000_TQAVCTRL_LAUNCH_TIMER_ENABLE: ::kernel::sys::raw::c_uint =
    512;
pub const E1000_TQAVCTRL_SP_WAIT_SR: ::kernel::sys::raw::c_uint = 1024;
pub const E1000_TQAVCTRL_FETCH_TIMER_DELTA_OFFSET: ::kernel::sys::raw::c_uint
          =
    16;
pub const E1000_TQAVCTRL_FETCH_TIMER_DELTA: ::kernel::sys::raw::c_uint =
    4294901760;
pub const E1000_I210_TQAVARBCTRL: ::kernel::sys::raw::c_uint = 13684;
pub const E1000_TQAVCC_IDLE_SLOPE: ::kernel::sys::raw::c_uint = 65535;
pub const E1000_TQAVCC_KEEP_CREDITS: ::kernel::sys::raw::c_uint = 1073741824;
pub const E1000_TQAVCC_QUEUE_MODE: ::kernel::sys::raw::c_uint = 2147483648;
pub const E1000_MMDAC: ::kernel::sys::raw::c_uint = 13;
pub const E1000_MMDAAD: ::kernel::sys::raw::c_uint = 14;
pub const E1000_RSRPD: ::kernel::sys::raw::c_uint = 11264;
pub const E1000_RAID: ::kernel::sys::raw::c_uint = 11272;
pub const E1000_TXDMAC: ::kernel::sys::raw::c_uint = 12288;
pub const E1000_KABGTXD: ::kernel::sys::raw::c_uint = 12292;
pub const E1000_PBSLAC: ::kernel::sys::raw::c_uint = 12544;
pub const E1000_TXPBS: ::kernel::sys::raw::c_uint = 13316;
pub const E1000_ITPBS: ::kernel::sys::raw::c_uint = 13316;
pub const E1000_TDFH: ::kernel::sys::raw::c_uint = 13328;
pub const E1000_TDFT: ::kernel::sys::raw::c_uint = 13336;
pub const E1000_TDFHS: ::kernel::sys::raw::c_uint = 13344;
pub const E1000_TDFTS: ::kernel::sys::raw::c_uint = 13352;
pub const E1000_TDFPC: ::kernel::sys::raw::c_uint = 13360;
pub const E1000_TDPUMB: ::kernel::sys::raw::c_uint = 13692;
pub const E1000_TDPUAD: ::kernel::sys::raw::c_uint = 13696;
pub const E1000_TDPUWD: ::kernel::sys::raw::c_uint = 13700;
pub const E1000_TDPURD: ::kernel::sys::raw::c_uint = 13704;
pub const E1000_TDPUCTL: ::kernel::sys::raw::c_uint = 13708;
pub const E1000_DTXCTL: ::kernel::sys::raw::c_uint = 13712;
pub const E1000_DTXTCPFLGL: ::kernel::sys::raw::c_uint = 13724;
pub const E1000_DTXTCPFLGH: ::kernel::sys::raw::c_uint = 13728;
pub const E1000_DTXMXSZRQ: ::kernel::sys::raw::c_uint = 13632;
pub const E1000_TIDV: ::kernel::sys::raw::c_uint = 14368;
pub const E1000_TADV: ::kernel::sys::raw::c_uint = 14380;
pub const E1000_TSPMT: ::kernel::sys::raw::c_uint = 14384;
pub const E1000_CRCERRS: ::kernel::sys::raw::c_uint = 16384;
pub const E1000_ALGNERRC: ::kernel::sys::raw::c_uint = 16388;
pub const E1000_SYMERRS: ::kernel::sys::raw::c_uint = 16392;
pub const E1000_RXERRC: ::kernel::sys::raw::c_uint = 16396;
pub const E1000_MPC: ::kernel::sys::raw::c_uint = 16400;
pub const E1000_SCC: ::kernel::sys::raw::c_uint = 16404;
pub const E1000_ECOL: ::kernel::sys::raw::c_uint = 16408;
pub const E1000_MCC: ::kernel::sys::raw::c_uint = 16412;
pub const E1000_LATECOL: ::kernel::sys::raw::c_uint = 16416;
pub const E1000_COLC: ::kernel::sys::raw::c_uint = 16424;
pub const E1000_DC: ::kernel::sys::raw::c_uint = 16432;
pub const E1000_TNCRS: ::kernel::sys::raw::c_uint = 16436;
pub const E1000_SEC: ::kernel::sys::raw::c_uint = 16440;
pub const E1000_CEXTERR: ::kernel::sys::raw::c_uint = 16444;
pub const E1000_RLEC: ::kernel::sys::raw::c_uint = 16448;
pub const E1000_XONRXC: ::kernel::sys::raw::c_uint = 16456;
pub const E1000_XONTXC: ::kernel::sys::raw::c_uint = 16460;
pub const E1000_XOFFRXC: ::kernel::sys::raw::c_uint = 16464;
pub const E1000_XOFFTXC: ::kernel::sys::raw::c_uint = 16468;
pub const E1000_FCRUC: ::kernel::sys::raw::c_uint = 16472;
pub const E1000_PRC64: ::kernel::sys::raw::c_uint = 16476;
pub const E1000_PRC127: ::kernel::sys::raw::c_uint = 16480;
pub const E1000_PRC255: ::kernel::sys::raw::c_uint = 16484;
pub const E1000_PRC511: ::kernel::sys::raw::c_uint = 16488;
pub const E1000_PRC1023: ::kernel::sys::raw::c_uint = 16492;
pub const E1000_PRC1522: ::kernel::sys::raw::c_uint = 16496;
pub const E1000_GPRC: ::kernel::sys::raw::c_uint = 16500;
pub const E1000_BPRC: ::kernel::sys::raw::c_uint = 16504;
pub const E1000_MPRC: ::kernel::sys::raw::c_uint = 16508;
pub const E1000_GPTC: ::kernel::sys::raw::c_uint = 16512;
pub const E1000_GORCL: ::kernel::sys::raw::c_uint = 16520;
pub const E1000_GORCH: ::kernel::sys::raw::c_uint = 16524;
pub const E1000_GOTCL: ::kernel::sys::raw::c_uint = 16528;
pub const E1000_GOTCH: ::kernel::sys::raw::c_uint = 16532;
pub const E1000_RNBC: ::kernel::sys::raw::c_uint = 16544;
pub const E1000_RUC: ::kernel::sys::raw::c_uint = 16548;
pub const E1000_RFC: ::kernel::sys::raw::c_uint = 16552;
pub const E1000_ROC: ::kernel::sys::raw::c_uint = 16556;
pub const E1000_RJC: ::kernel::sys::raw::c_uint = 16560;
pub const E1000_MGTPRC: ::kernel::sys::raw::c_uint = 16564;
pub const E1000_MGTPDC: ::kernel::sys::raw::c_uint = 16568;
pub const E1000_MGTPTC: ::kernel::sys::raw::c_uint = 16572;
pub const E1000_TORL: ::kernel::sys::raw::c_uint = 16576;
pub const E1000_TORH: ::kernel::sys::raw::c_uint = 16580;
pub const E1000_TOTL: ::kernel::sys::raw::c_uint = 16584;
pub const E1000_TOTH: ::kernel::sys::raw::c_uint = 16588;
pub const E1000_TPR: ::kernel::sys::raw::c_uint = 16592;
pub const E1000_TPT: ::kernel::sys::raw::c_uint = 16596;
pub const E1000_PTC64: ::kernel::sys::raw::c_uint = 16600;
pub const E1000_PTC127: ::kernel::sys::raw::c_uint = 16604;
pub const E1000_PTC255: ::kernel::sys::raw::c_uint = 16608;
pub const E1000_PTC511: ::kernel::sys::raw::c_uint = 16612;
pub const E1000_PTC1023: ::kernel::sys::raw::c_uint = 16616;
pub const E1000_PTC1522: ::kernel::sys::raw::c_uint = 16620;
pub const E1000_MPTC: ::kernel::sys::raw::c_uint = 16624;
pub const E1000_BPTC: ::kernel::sys::raw::c_uint = 16628;
pub const E1000_TSCTC: ::kernel::sys::raw::c_uint = 16632;
pub const E1000_TSCTFC: ::kernel::sys::raw::c_uint = 16636;
pub const E1000_IAC: ::kernel::sys::raw::c_uint = 16640;
pub const E1000_ICRXPTC: ::kernel::sys::raw::c_uint = 16644;
pub const E1000_ICRXATC: ::kernel::sys::raw::c_uint = 16648;
pub const E1000_ICTXPTC: ::kernel::sys::raw::c_uint = 16652;
pub const E1000_ICTXATC: ::kernel::sys::raw::c_uint = 16656;
pub const E1000_ICTXQEC: ::kernel::sys::raw::c_uint = 16664;
pub const E1000_ICTXQMTC: ::kernel::sys::raw::c_uint = 16668;
pub const E1000_ICRXDMTC: ::kernel::sys::raw::c_uint = 16672;
pub const E1000_ICRXOC: ::kernel::sys::raw::c_uint = 16676;
pub const E1000_CRC_OFFSET: ::kernel::sys::raw::c_uint = 24400;
pub const E1000_VFGPRC: ::kernel::sys::raw::c_uint = 3856;
pub const E1000_VFGORC: ::kernel::sys::raw::c_uint = 3864;
pub const E1000_VFMPRC: ::kernel::sys::raw::c_uint = 3900;
pub const E1000_VFGPTC: ::kernel::sys::raw::c_uint = 3860;
pub const E1000_VFGOTC: ::kernel::sys::raw::c_uint = 3892;
pub const E1000_VFGOTLBC: ::kernel::sys::raw::c_uint = 3920;
pub const E1000_VFGPTLBC: ::kernel::sys::raw::c_uint = 3908;
pub const E1000_VFGORLBC: ::kernel::sys::raw::c_uint = 3912;
pub const E1000_VFGPRLBC: ::kernel::sys::raw::c_uint = 3904;
pub const E1000_LSECTXUT: ::kernel::sys::raw::c_uint = 17152;
pub const E1000_LSECTXPKTE: ::kernel::sys::raw::c_uint = 17156;
pub const E1000_LSECTXPKTP: ::kernel::sys::raw::c_uint = 17160;
pub const E1000_LSECTXOCTE: ::kernel::sys::raw::c_uint = 17164;
pub const E1000_LSECTXOCTP: ::kernel::sys::raw::c_uint = 17168;
pub const E1000_LSECRXUT: ::kernel::sys::raw::c_uint = 17172;
pub const E1000_LSECRXOCTD: ::kernel::sys::raw::c_uint = 17180;
pub const E1000_LSECRXOCTV: ::kernel::sys::raw::c_uint = 17184;
pub const E1000_LSECRXBAD: ::kernel::sys::raw::c_uint = 17188;
pub const E1000_LSECRXNOSCI: ::kernel::sys::raw::c_uint = 17192;
pub const E1000_LSECRXUNSCI: ::kernel::sys::raw::c_uint = 17196;
pub const E1000_LSECRXUNCH: ::kernel::sys::raw::c_uint = 17200;
pub const E1000_LSECRXDELAY: ::kernel::sys::raw::c_uint = 17216;
pub const E1000_LSECRXLATE: ::kernel::sys::raw::c_uint = 17232;
pub const E1000_LSECRXUNSA: ::kernel::sys::raw::c_uint = 17344;
pub const E1000_LSECRXNUSA: ::kernel::sys::raw::c_uint = 17360;
pub const E1000_LSECTXCAP: ::kernel::sys::raw::c_uint = 45056;
pub const E1000_LSECRXCAP: ::kernel::sys::raw::c_uint = 45824;
pub const E1000_LSECTXCTRL: ::kernel::sys::raw::c_uint = 45060;
pub const E1000_LSECRXCTRL: ::kernel::sys::raw::c_uint = 45828;
pub const E1000_LSECTXSCL: ::kernel::sys::raw::c_uint = 45064;
pub const E1000_LSECTXSCH: ::kernel::sys::raw::c_uint = 45068;
pub const E1000_LSECTXSA: ::kernel::sys::raw::c_uint = 45072;
pub const E1000_LSECTXPN0: ::kernel::sys::raw::c_uint = 45080;
pub const E1000_LSECTXPN1: ::kernel::sys::raw::c_uint = 45084;
pub const E1000_LSECRXSCL: ::kernel::sys::raw::c_uint = 46032;
pub const E1000_LSECRXSCH: ::kernel::sys::raw::c_uint = 46048;
pub const E1000_SSVPC: ::kernel::sys::raw::c_uint = 16800;
pub const E1000_IPSCTRL: ::kernel::sys::raw::c_uint = 46128;
pub const E1000_IPSRXCMD: ::kernel::sys::raw::c_uint = 46088;
pub const E1000_IPSRXIDX: ::kernel::sys::raw::c_uint = 46080;
pub const E1000_IPSRXSALT: ::kernel::sys::raw::c_uint = 46084;
pub const E1000_IPSRXSPI: ::kernel::sys::raw::c_uint = 46092;
pub const E1000_IPSTXSALT: ::kernel::sys::raw::c_uint = 46164;
pub const E1000_IPSTXIDX: ::kernel::sys::raw::c_uint = 46160;
pub const E1000_PCS_CFG0: ::kernel::sys::raw::c_uint = 16896;
pub const E1000_PCS_LCTL: ::kernel::sys::raw::c_uint = 16904;
pub const E1000_PCS_LSTAT: ::kernel::sys::raw::c_uint = 16908;
pub const E1000_CBTMPC: ::kernel::sys::raw::c_uint = 16428;
pub const E1000_HTDPMC: ::kernel::sys::raw::c_uint = 16444;
pub const E1000_CBRDPC: ::kernel::sys::raw::c_uint = 16452;
pub const E1000_CBRMPC: ::kernel::sys::raw::c_uint = 16636;
pub const E1000_RPTHC: ::kernel::sys::raw::c_uint = 16644;
pub const E1000_HGPTC: ::kernel::sys::raw::c_uint = 16664;
pub const E1000_HTCBDPC: ::kernel::sys::raw::c_uint = 16676;
pub const E1000_HGORCL: ::kernel::sys::raw::c_uint = 16680;
pub const E1000_HGORCH: ::kernel::sys::raw::c_uint = 16684;
pub const E1000_HGOTCL: ::kernel::sys::raw::c_uint = 16688;
pub const E1000_HGOTCH: ::kernel::sys::raw::c_uint = 16692;
pub const E1000_LENERRS: ::kernel::sys::raw::c_uint = 16696;
pub const E1000_SCVPC: ::kernel::sys::raw::c_uint = 16936;
pub const E1000_HRMPC: ::kernel::sys::raw::c_uint = 40984;
pub const E1000_PCS_ANADV: ::kernel::sys::raw::c_uint = 16920;
pub const E1000_PCS_LPAB: ::kernel::sys::raw::c_uint = 16924;
pub const E1000_PCS_NPTX: ::kernel::sys::raw::c_uint = 16928;
pub const E1000_PCS_LPABNP: ::kernel::sys::raw::c_uint = 16932;
pub const E1000_RXCSUM: ::kernel::sys::raw::c_uint = 20480;
pub const E1000_RLPML: ::kernel::sys::raw::c_uint = 20484;
pub const E1000_RFCTL: ::kernel::sys::raw::c_uint = 20488;
pub const E1000_MTA: ::kernel::sys::raw::c_uint = 20992;
pub const E1000_RA: ::kernel::sys::raw::c_uint = 21504;
pub const E1000_RA2: ::kernel::sys::raw::c_uint = 21728;
pub const E1000_VFTA: ::kernel::sys::raw::c_uint = 22016;
pub const E1000_VT_CTL: ::kernel::sys::raw::c_uint = 22556;
pub const E1000_CIAA: ::kernel::sys::raw::c_uint = 23432;
pub const E1000_CIAD: ::kernel::sys::raw::c_uint = 23436;
pub const E1000_VFQA0: ::kernel::sys::raw::c_uint = 45056;
pub const E1000_VFQA1: ::kernel::sys::raw::c_uint = 45568;
pub const E1000_WUC: ::kernel::sys::raw::c_uint = 22528;
pub const E1000_WUFC: ::kernel::sys::raw::c_uint = 22536;
pub const E1000_WUS: ::kernel::sys::raw::c_uint = 22544;
pub const E1000_MANC: ::kernel::sys::raw::c_uint = 22560;
pub const E1000_IPAV: ::kernel::sys::raw::c_uint = 22584;
pub const E1000_IP4AT: ::kernel::sys::raw::c_uint = 22592;
pub const E1000_IP6AT: ::kernel::sys::raw::c_uint = 22656;
pub const E1000_WUPL: ::kernel::sys::raw::c_uint = 22784;
pub const E1000_WUPM: ::kernel::sys::raw::c_uint = 23040;
pub const E1000_PBACL: ::kernel::sys::raw::c_uint = 23400;
pub const E1000_FFLT: ::kernel::sys::raw::c_uint = 24320;
pub const E1000_HOST_IF: ::kernel::sys::raw::c_uint = 34816;
pub const E1000_HIBBA: ::kernel::sys::raw::c_uint = 36672;
pub const E1000_KMRNCTRLSTA: ::kernel::sys::raw::c_uint = 52;
pub const E1000_MANC2H: ::kernel::sys::raw::c_uint = 22624;
pub const E1000_SW_FW_SYNC: ::kernel::sys::raw::c_uint = 23388;
pub const E1000_CCMCTL: ::kernel::sys::raw::c_uint = 23368;
pub const E1000_GIOCTL: ::kernel::sys::raw::c_uint = 23364;
pub const E1000_SCCTL: ::kernel::sys::raw::c_uint = 23372;
pub const E1000_GCR: ::kernel::sys::raw::c_uint = 23296;
pub const E1000_GCR2: ::kernel::sys::raw::c_uint = 23396;
pub const E1000_GSCL_1: ::kernel::sys::raw::c_uint = 23312;
pub const E1000_GSCL_2: ::kernel::sys::raw::c_uint = 23316;
pub const E1000_GSCL_3: ::kernel::sys::raw::c_uint = 23320;
pub const E1000_GSCL_4: ::kernel::sys::raw::c_uint = 23324;
pub const E1000_FACTPS: ::kernel::sys::raw::c_uint = 23344;
pub const E1000_SWSM: ::kernel::sys::raw::c_uint = 23376;
pub const E1000_FWSM: ::kernel::sys::raw::c_uint = 23380;
pub const E1000_SWSM2: ::kernel::sys::raw::c_uint = 23384;
pub const E1000_DCA_ID: ::kernel::sys::raw::c_uint = 23408;
pub const E1000_DCA_CTRL: ::kernel::sys::raw::c_uint = 23412;
pub const E1000_UFUSE: ::kernel::sys::raw::c_uint = 23416;
pub const E1000_FFLT_DBG: ::kernel::sys::raw::c_uint = 24324;
pub const E1000_HICR: ::kernel::sys::raw::c_uint = 36608;
pub const E1000_FWSTS: ::kernel::sys::raw::c_uint = 36620;
pub const E1000_CPUVEC: ::kernel::sys::raw::c_uint = 11280;
pub const E1000_MRQC: ::kernel::sys::raw::c_uint = 22552;
pub const E1000_IMIRVP: ::kernel::sys::raw::c_uint = 23232;
pub const E1000_RSSIM: ::kernel::sys::raw::c_uint = 22628;
pub const E1000_RSSIR: ::kernel::sys::raw::c_uint = 22632;
pub const E1000_SWPBS: ::kernel::sys::raw::c_uint = 12292;
pub const E1000_MBVFICR: ::kernel::sys::raw::c_uint = 3200;
pub const E1000_MBVFIMR: ::kernel::sys::raw::c_uint = 3204;
pub const E1000_VFLRE: ::kernel::sys::raw::c_uint = 3208;
pub const E1000_VFRE: ::kernel::sys::raw::c_uint = 3212;
pub const E1000_VFTE: ::kernel::sys::raw::c_uint = 3216;
pub const E1000_QDE: ::kernel::sys::raw::c_uint = 9224;
pub const E1000_DTXSWC: ::kernel::sys::raw::c_uint = 13568;
pub const E1000_WVBR: ::kernel::sys::raw::c_uint = 13652;
pub const E1000_RPLOLR: ::kernel::sys::raw::c_uint = 23280;
pub const E1000_UTA: ::kernel::sys::raw::c_uint = 40960;
pub const E1000_IOVCTL: ::kernel::sys::raw::c_uint = 23484;
pub const E1000_VMRVLAN: ::kernel::sys::raw::c_uint = 23952;
pub const E1000_VMRVM: ::kernel::sys::raw::c_uint = 23968;
pub const E1000_MDFB: ::kernel::sys::raw::c_uint = 13656;
pub const E1000_LVMMC: ::kernel::sys::raw::c_uint = 13640;
pub const E1000_TXSWC: ::kernel::sys::raw::c_uint = 23244;
pub const E1000_SCCRL: ::kernel::sys::raw::c_uint = 23984;
pub const E1000_BSCTRH: ::kernel::sys::raw::c_uint = 23992;
pub const E1000_MSCTRH: ::kernel::sys::raw::c_uint = 23996;
pub const E1000_TSYNCRXCTL: ::kernel::sys::raw::c_uint = 46624;
pub const E1000_TSYNCTXCTL: ::kernel::sys::raw::c_uint = 46612;
pub const E1000_TSYNCRXCFG: ::kernel::sys::raw::c_uint = 24400;
pub const E1000_RXSTMPL: ::kernel::sys::raw::c_uint = 46628;
pub const E1000_RXSTMPH: ::kernel::sys::raw::c_uint = 46632;
pub const E1000_RXSATRL: ::kernel::sys::raw::c_uint = 46636;
pub const E1000_RXSATRH: ::kernel::sys::raw::c_uint = 46640;
pub const E1000_TXSTMPL: ::kernel::sys::raw::c_uint = 46616;
pub const E1000_TXSTMPH: ::kernel::sys::raw::c_uint = 46620;
pub const E1000_SYSTIML: ::kernel::sys::raw::c_uint = 46592;
pub const E1000_SYSTIMH: ::kernel::sys::raw::c_uint = 46596;
pub const E1000_TIMINCA: ::kernel::sys::raw::c_uint = 46600;
pub const E1000_TIMADJL: ::kernel::sys::raw::c_uint = 46604;
pub const E1000_TIMADJH: ::kernel::sys::raw::c_uint = 46608;
pub const E1000_TSAUXC: ::kernel::sys::raw::c_uint = 46656;
pub const E1000_SYSSTMPL: ::kernel::sys::raw::c_uint = 46664;
pub const E1000_SYSSTMPH: ::kernel::sys::raw::c_uint = 46668;
pub const E1000_PLTSTMPL: ::kernel::sys::raw::c_uint = 46656;
pub const E1000_PLTSTMPH: ::kernel::sys::raw::c_uint = 46660;
pub const E1000_SYSTIMR: ::kernel::sys::raw::c_uint = 46840;
pub const E1000_TSICR: ::kernel::sys::raw::c_uint = 46700;
pub const E1000_TSIM: ::kernel::sys::raw::c_uint = 46708;
pub const E1000_RXMTRL: ::kernel::sys::raw::c_uint = 46644;
pub const E1000_RXUDP: ::kernel::sys::raw::c_uint = 46648;
pub const E1000_RTTDCS: ::kernel::sys::raw::c_uint = 13824;
pub const E1000_RTTPCS: ::kernel::sys::raw::c_uint = 13428;
pub const E1000_RTRPCS: ::kernel::sys::raw::c_uint = 9332;
pub const E1000_RTRUP2TC: ::kernel::sys::raw::c_uint = 23236;
pub const E1000_RTTUP2TC: ::kernel::sys::raw::c_uint = 1048;
pub const E1000_RTTDQSEL: ::kernel::sys::raw::c_uint = 13828;
pub const E1000_RTTDVMRC: ::kernel::sys::raw::c_uint = 13832;
pub const E1000_RTTDVMRS: ::kernel::sys::raw::c_uint = 13836;
pub const E1000_RTTBCNRC: ::kernel::sys::raw::c_uint = 14000;
pub const E1000_RTTBCNRS: ::kernel::sys::raw::c_uint = 14004;
pub const E1000_RTTBCNCR: ::kernel::sys::raw::c_uint = 45568;
pub const E1000_RTTBCNTG: ::kernel::sys::raw::c_uint = 13732;
pub const E1000_RTTBCNCP: ::kernel::sys::raw::c_uint = 45576;
pub const E1000_RTRBCNCR: ::kernel::sys::raw::c_uint = 45580;
pub const E1000_RTTBCNRD: ::kernel::sys::raw::c_uint = 14008;
pub const E1000_PFCTOP: ::kernel::sys::raw::c_uint = 4224;
pub const E1000_RTTBCNIDX: ::kernel::sys::raw::c_uint = 45572;
pub const E1000_RTTBCNACH: ::kernel::sys::raw::c_uint = 45588;
pub const E1000_RTTBCNACL: ::kernel::sys::raw::c_uint = 45584;
pub const E1000_DMACR: ::kernel::sys::raw::c_uint = 9480;
pub const E1000_DMCTXTH: ::kernel::sys::raw::c_uint = 13648;
pub const E1000_DMCTLX: ::kernel::sys::raw::c_uint = 9492;
pub const E1000_DMCRTRH: ::kernel::sys::raw::c_uint = 24016;
pub const E1000_DMCCNT: ::kernel::sys::raw::c_uint = 24020;
pub const E1000_FCRTC: ::kernel::sys::raw::c_uint = 8560;
pub const E1000_PCIEMISC: ::kernel::sys::raw::c_uint = 23480;
pub const E1000_PCIEERRSTS: ::kernel::sys::raw::c_uint = 23464;
pub const E1000_PROXYS: ::kernel::sys::raw::c_uint = 24420;
pub const E1000_PROXYFC: ::kernel::sys::raw::c_uint = 24416;
pub const E1000_THMJT: ::kernel::sys::raw::c_uint = 33024;
pub const E1000_THLOWTC: ::kernel::sys::raw::c_uint = 33028;
pub const E1000_THMIDTC: ::kernel::sys::raw::c_uint = 33032;
pub const E1000_THHIGHTC: ::kernel::sys::raw::c_uint = 33036;
pub const E1000_THSTAT: ::kernel::sys::raw::c_uint = 33040;
pub const E1000_IPCNFG: ::kernel::sys::raw::c_uint = 3640;
pub const E1000_LTRC: ::kernel::sys::raw::c_uint = 416;
pub const E1000_EEER: ::kernel::sys::raw::c_uint = 3632;
pub const E1000_EEE_SU: ::kernel::sys::raw::c_uint = 3636;
pub const E1000_TLPIC: ::kernel::sys::raw::c_uint = 16712;
pub const E1000_RLPIC: ::kernel::sys::raw::c_uint = 16716;
pub const E1000_B2OSPC: ::kernel::sys::raw::c_uint = 36832;
pub const E1000_B2OGPRC: ::kernel::sys::raw::c_uint = 16728;
pub const E1000_O2BGPTC: ::kernel::sys::raw::c_uint = 36836;
pub const E1000_O2BSPC: ::kernel::sys::raw::c_uint = 16732;
pub const E1000_DOBFFCTL: ::kernel::sys::raw::c_uint = 16164;
pub const REQ_TX_DESCRIPTOR_MULTIPLE: ::kernel::sys::raw::c_uint = 8;
pub const REQ_RX_DESCRIPTOR_MULTIPLE: ::kernel::sys::raw::c_uint = 8;
pub const E1000_WUC_APME: ::kernel::sys::raw::c_uint = 1;
pub const E1000_WUC_PME_EN: ::kernel::sys::raw::c_uint = 2;
pub const E1000_WUC_PME_STATUS: ::kernel::sys::raw::c_uint = 4;
pub const E1000_WUC_APMPME: ::kernel::sys::raw::c_uint = 8;
pub const E1000_WUC_PHY_WAKE: ::kernel::sys::raw::c_uint = 256;
pub const E1000_WUFC_LNKC: ::kernel::sys::raw::c_uint = 1;
pub const E1000_WUFC_MAG: ::kernel::sys::raw::c_uint = 2;
pub const E1000_WUFC_EX: ::kernel::sys::raw::c_uint = 4;
pub const E1000_WUFC_MC: ::kernel::sys::raw::c_uint = 8;
pub const E1000_WUFC_BC: ::kernel::sys::raw::c_uint = 16;
pub const E1000_WUFC_ARP: ::kernel::sys::raw::c_uint = 32;
pub const E1000_WUFC_IPV4: ::kernel::sys::raw::c_uint = 64;
pub const E1000_WUFC_FLX0: ::kernel::sys::raw::c_uint = 65536;
pub const E1000_WUS_LNKC: ::kernel::sys::raw::c_uint = 1;
pub const E1000_WUS_MAG: ::kernel::sys::raw::c_uint = 2;
pub const E1000_WUS_EX: ::kernel::sys::raw::c_uint = 4;
pub const E1000_WUS_MC: ::kernel::sys::raw::c_uint = 8;
pub const E1000_WUS_BC: ::kernel::sys::raw::c_uint = 16;
pub const E1000_CTRL_EXT_LPCD: ::kernel::sys::raw::c_uint = 4;
pub const E1000_CTRL_EXT_SDP4_DATA: ::kernel::sys::raw::c_uint = 16;
pub const E1000_CTRL_EXT_SDP6_DATA: ::kernel::sys::raw::c_uint = 64;
pub const E1000_CTRL_EXT_SDP3_DATA: ::kernel::sys::raw::c_uint = 128;
pub const E1000_CTRL_EXT_SDP4_DIR: ::kernel::sys::raw::c_uint = 256;
pub const E1000_CTRL_EXT_SDP6_DIR: ::kernel::sys::raw::c_uint = 1024;
pub const E1000_CTRL_EXT_SDP3_DIR: ::kernel::sys::raw::c_uint = 2048;
pub const E1000_CTRL_EXT_FORCE_SMBUS: ::kernel::sys::raw::c_uint = 2048;
pub const E1000_CTRL_EXT_EE_RST: ::kernel::sys::raw::c_uint = 8192;
pub const E1000_CTRL_EXT_PFRSTD: ::kernel::sys::raw::c_uint = 16384;
pub const E1000_CTRL_EXT_SPD_BYPS: ::kernel::sys::raw::c_uint = 32768;
pub const E1000_CTRL_EXT_RO_DIS: ::kernel::sys::raw::c_uint = 131072;
pub const E1000_CTRL_EXT_DMA_DYN_CLK_EN: ::kernel::sys::raw::c_uint = 524288;
pub const E1000_CTRL_EXT_LINK_MODE_MASK: ::kernel::sys::raw::c_uint =
    12582912;
pub const E1000_CTRL_EXT_LINK_MODE_OFFSET: ::kernel::sys::raw::c_uint = 22;
pub const E1000_CTRL_EXT_LINK_MODE_1000BASE_KX: ::kernel::sys::raw::c_uint =
    4194304;
pub const E1000_CTRL_EXT_LINK_MODE_GMII: ::kernel::sys::raw::c_uint = 0;
pub const E1000_CTRL_EXT_LINK_MODE_PCIE_SERDES: ::kernel::sys::raw::c_uint =
    12582912;
pub const E1000_CTRL_EXT_LINK_MODE_SGMII: ::kernel::sys::raw::c_uint =
    8388608;
pub const E1000_CTRL_EXT_EIAME: ::kernel::sys::raw::c_uint = 16777216;
pub const E1000_CTRL_EXT_IRCA: ::kernel::sys::raw::c_uint = 1;
pub const E1000_CTRL_EXT_DRV_LOAD: ::kernel::sys::raw::c_uint = 268435456;
pub const E1000_CTRL_EXT_IAME: ::kernel::sys::raw::c_uint = 134217728;
pub const E1000_CTRL_EXT_PBA_CLR: ::kernel::sys::raw::c_uint = 2147483648;
pub const E1000_CTRL_EXT_LSECCK: ::kernel::sys::raw::c_uint = 4096;
pub const E1000_CTRL_EXT_PHYPDEN: ::kernel::sys::raw::c_uint = 1048576;
pub const E1000_I2CCMD_REG_ADDR_SHIFT: ::kernel::sys::raw::c_uint = 16;
pub const E1000_I2CCMD_PHY_ADDR_SHIFT: ::kernel::sys::raw::c_uint = 24;
pub const E1000_I2CCMD_OPCODE_READ: ::kernel::sys::raw::c_uint = 134217728;
pub const E1000_I2CCMD_OPCODE_WRITE: ::kernel::sys::raw::c_uint = 0;
pub const E1000_I2CCMD_READY: ::kernel::sys::raw::c_uint = 536870912;
pub const E1000_I2CCMD_ERROR: ::kernel::sys::raw::c_uint = 2147483648;
pub const E1000_MAX_SGMII_PHY_REG_ADDR: ::kernel::sys::raw::c_uint = 255;
pub const E1000_I2CCMD_PHY_TIMEOUT: ::kernel::sys::raw::c_uint = 200;
pub const E1000_IVAR_VALID: ::kernel::sys::raw::c_uint = 128;
pub const E1000_GPIE_NSICR: ::kernel::sys::raw::c_uint = 1;
pub const E1000_GPIE_MSIX_MODE: ::kernel::sys::raw::c_uint = 16;
pub const E1000_GPIE_EIAME: ::kernel::sys::raw::c_uint = 1073741824;
pub const E1000_GPIE_PBA: ::kernel::sys::raw::c_uint = 2147483648;
pub const E1000_RXD_STAT_DD: ::kernel::sys::raw::c_uint = 1;
pub const E1000_RXD_STAT_EOP: ::kernel::sys::raw::c_uint = 2;
pub const E1000_RXD_STAT_IXSM: ::kernel::sys::raw::c_uint = 4;
pub const E1000_RXD_STAT_VP: ::kernel::sys::raw::c_uint = 8;
pub const E1000_RXD_STAT_UDPCS: ::kernel::sys::raw::c_uint = 16;
pub const E1000_RXD_STAT_TCPCS: ::kernel::sys::raw::c_uint = 32;
pub const E1000_RXD_STAT_IPCS: ::kernel::sys::raw::c_uint = 64;
pub const E1000_RXD_STAT_PIF: ::kernel::sys::raw::c_uint = 128;
pub const E1000_RXD_STAT_IPIDV: ::kernel::sys::raw::c_uint = 512;
pub const E1000_RXD_STAT_UDPV: ::kernel::sys::raw::c_uint = 1024;
pub const E1000_RXD_STAT_DYNINT: ::kernel::sys::raw::c_uint = 2048;
pub const E1000_RXD_ERR_CE: ::kernel::sys::raw::c_uint = 1;
pub const E1000_RXD_ERR_SE: ::kernel::sys::raw::c_uint = 2;
pub const E1000_RXD_ERR_SEQ: ::kernel::sys::raw::c_uint = 4;
pub const E1000_RXD_ERR_CXE: ::kernel::sys::raw::c_uint = 16;
pub const E1000_RXD_ERR_TCPE: ::kernel::sys::raw::c_uint = 32;
pub const E1000_RXD_ERR_IPE: ::kernel::sys::raw::c_uint = 64;
pub const E1000_RXD_ERR_RXE: ::kernel::sys::raw::c_uint = 128;
pub const E1000_RXD_SPC_VLAN_MASK: ::kernel::sys::raw::c_uint = 4095;
pub const E1000_RXDEXT_STATERR_TST: ::kernel::sys::raw::c_uint = 256;
pub const E1000_RXDEXT_STATERR_LB: ::kernel::sys::raw::c_uint = 262144;
pub const E1000_RXDEXT_STATERR_CE: ::kernel::sys::raw::c_uint = 16777216;
pub const E1000_RXDEXT_STATERR_SE: ::kernel::sys::raw::c_uint = 33554432;
pub const E1000_RXDEXT_STATERR_SEQ: ::kernel::sys::raw::c_uint = 67108864;
pub const E1000_RXDEXT_STATERR_CXE: ::kernel::sys::raw::c_uint = 268435456;
pub const E1000_RXDEXT_STATERR_TCPE: ::kernel::sys::raw::c_uint = 536870912;
pub const E1000_RXDEXT_STATERR_IPE: ::kernel::sys::raw::c_uint = 1073741824;
pub const E1000_RXDEXT_STATERR_RXE: ::kernel::sys::raw::c_uint = 2147483648;
pub const E1000_RXD_ERR_FRAME_ERR_MASK: ::kernel::sys::raw::c_uint = 151;
pub const E1000_RXDEXT_ERR_FRAME_ERR_MASK: ::kernel::sys::raw::c_uint =
    2533359616;
pub const E1000_MRQC_RSS_ENABLE_2Q: ::kernel::sys::raw::c_uint = 1;
pub const E1000_MRQC_RSS_FIELD_MASK: ::kernel::sys::raw::c_uint = 4294901760;
pub const E1000_MRQC_RSS_FIELD_IPV4_TCP: ::kernel::sys::raw::c_uint = 65536;
pub const E1000_MRQC_RSS_FIELD_IPV4: ::kernel::sys::raw::c_uint = 131072;
pub const E1000_MRQC_RSS_FIELD_IPV6_TCP_EX: ::kernel::sys::raw::c_uint =
    262144;
pub const E1000_MRQC_RSS_FIELD_IPV6_EX: ::kernel::sys::raw::c_uint = 524288;
pub const E1000_MRQC_RSS_FIELD_IPV6: ::kernel::sys::raw::c_uint = 1048576;
pub const E1000_MRQC_RSS_FIELD_IPV6_TCP: ::kernel::sys::raw::c_uint = 2097152;
pub const E1000_RXDPS_HDRSTAT_HDRSP: ::kernel::sys::raw::c_uint = 32768;
pub const E1000_MANC_SMBUS_EN: ::kernel::sys::raw::c_uint = 1;
pub const E1000_MANC_ASF_EN: ::kernel::sys::raw::c_uint = 2;
pub const E1000_MANC_ARP_EN: ::kernel::sys::raw::c_uint = 8192;
pub const E1000_MANC_RCV_TCO_EN: ::kernel::sys::raw::c_uint = 131072;
pub const E1000_MANC_BLK_PHY_RST_ON_IDE: ::kernel::sys::raw::c_uint = 262144;
pub const E1000_MANC_EN_MAC_ADDR_FILTER: ::kernel::sys::raw::c_uint = 1048576;
pub const E1000_MANC_EN_MNG2HOST: ::kernel::sys::raw::c_uint = 2097152;
pub const E1000_MANC2H_PORT_623: ::kernel::sys::raw::c_uint = 32;
pub const E1000_MANC2H_PORT_664: ::kernel::sys::raw::c_uint = 64;
pub const E1000_MDEF_PORT_623: ::kernel::sys::raw::c_uint = 2048;
pub const E1000_MDEF_PORT_664: ::kernel::sys::raw::c_uint = 1024;
pub const E1000_RCTL_RST: ::kernel::sys::raw::c_uint = 1;
pub const E1000_RCTL_EN: ::kernel::sys::raw::c_uint = 2;
pub const E1000_RCTL_SBP: ::kernel::sys::raw::c_uint = 4;
pub const E1000_RCTL_UPE: ::kernel::sys::raw::c_uint = 8;
pub const E1000_RCTL_MPE: ::kernel::sys::raw::c_uint = 16;
pub const E1000_RCTL_LPE: ::kernel::sys::raw::c_uint = 32;
pub const E1000_RCTL_LBM_NO: ::kernel::sys::raw::c_uint = 0;
pub const E1000_RCTL_LBM_MAC: ::kernel::sys::raw::c_uint = 64;
pub const E1000_RCTL_LBM_TCVR: ::kernel::sys::raw::c_uint = 192;
pub const E1000_RCTL_DTYP_PS: ::kernel::sys::raw::c_uint = 1024;
pub const E1000_RCTL_RDMTS_HALF: ::kernel::sys::raw::c_uint = 0;
pub const E1000_RCTL_RDMTS_HEX: ::kernel::sys::raw::c_uint = 65536;
pub const E1000_RCTL_RDMTS1_HEX: ::kernel::sys::raw::c_uint = 65536;
pub const E1000_RCTL_MO_SHIFT: ::kernel::sys::raw::c_uint = 12;
pub const E1000_RCTL_MO_3: ::kernel::sys::raw::c_uint = 12288;
pub const E1000_RCTL_BAM: ::kernel::sys::raw::c_uint = 32768;
pub const E1000_RCTL_SZ_2048: ::kernel::sys::raw::c_uint = 0;
pub const E1000_RCTL_SZ_1024: ::kernel::sys::raw::c_uint = 65536;
pub const E1000_RCTL_SZ_512: ::kernel::sys::raw::c_uint = 131072;
pub const E1000_RCTL_SZ_256: ::kernel::sys::raw::c_uint = 196608;
pub const E1000_RCTL_SZ_16384: ::kernel::sys::raw::c_uint = 65536;
pub const E1000_RCTL_SZ_8192: ::kernel::sys::raw::c_uint = 131072;
pub const E1000_RCTL_SZ_4096: ::kernel::sys::raw::c_uint = 196608;
pub const E1000_RCTL_VFE: ::kernel::sys::raw::c_uint = 262144;
pub const E1000_RCTL_CFIEN: ::kernel::sys::raw::c_uint = 524288;
pub const E1000_RCTL_CFI: ::kernel::sys::raw::c_uint = 1048576;
pub const E1000_RCTL_DPF: ::kernel::sys::raw::c_uint = 4194304;
pub const E1000_RCTL_PMCF: ::kernel::sys::raw::c_uint = 8388608;
pub const E1000_RCTL_BSEX: ::kernel::sys::raw::c_uint = 33554432;
pub const E1000_RCTL_SECRC: ::kernel::sys::raw::c_uint = 67108864;
pub const E1000_PSRCTL_BSIZE0_MASK: ::kernel::sys::raw::c_uint = 127;
pub const E1000_PSRCTL_BSIZE1_MASK: ::kernel::sys::raw::c_uint = 16128;
pub const E1000_PSRCTL_BSIZE2_MASK: ::kernel::sys::raw::c_uint = 4128768;
pub const E1000_PSRCTL_BSIZE3_MASK: ::kernel::sys::raw::c_uint = 1056964608;
pub const E1000_PSRCTL_BSIZE0_SHIFT: ::kernel::sys::raw::c_uint = 7;
pub const E1000_PSRCTL_BSIZE1_SHIFT: ::kernel::sys::raw::c_uint = 2;
pub const E1000_PSRCTL_BSIZE2_SHIFT: ::kernel::sys::raw::c_uint = 6;
pub const E1000_PSRCTL_BSIZE3_SHIFT: ::kernel::sys::raw::c_uint = 14;
pub const E1000_SWFW_EEP_SM: ::kernel::sys::raw::c_uint = 1;
pub const E1000_SWFW_PHY0_SM: ::kernel::sys::raw::c_uint = 2;
pub const E1000_SWFW_PHY1_SM: ::kernel::sys::raw::c_uint = 4;
pub const E1000_SWFW_CSR_SM: ::kernel::sys::raw::c_uint = 8;
pub const E1000_SWFW_PHY2_SM: ::kernel::sys::raw::c_uint = 32;
pub const E1000_SWFW_PHY3_SM: ::kernel::sys::raw::c_uint = 64;
pub const E1000_SWFW_SW_MNG_SM: ::kernel::sys::raw::c_uint = 1024;
pub const E1000_CTRL_FD: ::kernel::sys::raw::c_uint = 1;
pub const E1000_CTRL_PRIOR: ::kernel::sys::raw::c_uint = 4;
pub const E1000_CTRL_GIO_MASTER_DISABLE: ::kernel::sys::raw::c_uint = 4;
pub const E1000_CTRL_LRST: ::kernel::sys::raw::c_uint = 8;
pub const E1000_CTRL_ASDE: ::kernel::sys::raw::c_uint = 32;
pub const E1000_CTRL_SLU: ::kernel::sys::raw::c_uint = 64;
pub const E1000_CTRL_ILOS: ::kernel::sys::raw::c_uint = 128;
pub const E1000_CTRL_SPD_SEL: ::kernel::sys::raw::c_uint = 768;
pub const E1000_CTRL_SPD_10: ::kernel::sys::raw::c_uint = 0;
pub const E1000_CTRL_SPD_100: ::kernel::sys::raw::c_uint = 256;
pub const E1000_CTRL_SPD_1000: ::kernel::sys::raw::c_uint = 512;
pub const E1000_CTRL_FRCSPD: ::kernel::sys::raw::c_uint = 2048;
pub const E1000_CTRL_FRCDPX: ::kernel::sys::raw::c_uint = 4096;
pub const E1000_CTRL_LANPHYPC_OVERRIDE: ::kernel::sys::raw::c_uint = 65536;
pub const E1000_CTRL_LANPHYPC_VALUE: ::kernel::sys::raw::c_uint = 131072;
pub const E1000_CTRL_MEHE: ::kernel::sys::raw::c_uint = 524288;
pub const E1000_CTRL_SWDPIN0: ::kernel::sys::raw::c_uint = 262144;
pub const E1000_CTRL_SWDPIN1: ::kernel::sys::raw::c_uint = 524288;
pub const E1000_CTRL_SWDPIN2: ::kernel::sys::raw::c_uint = 1048576;
pub const E1000_CTRL_ADVD3WUC: ::kernel::sys::raw::c_uint = 1048576;
pub const E1000_CTRL_EN_PHY_PWR_MGMT: ::kernel::sys::raw::c_uint = 2097152;
pub const E1000_CTRL_SWDPIN3: ::kernel::sys::raw::c_uint = 2097152;
pub const E1000_CTRL_SWDPIO0: ::kernel::sys::raw::c_uint = 4194304;
pub const E1000_CTRL_SWDPIO2: ::kernel::sys::raw::c_uint = 16777216;
pub const E1000_CTRL_SWDPIO3: ::kernel::sys::raw::c_uint = 33554432;
pub const E1000_CTRL_RST: ::kernel::sys::raw::c_uint = 67108864;
pub const E1000_CTRL_RFCE: ::kernel::sys::raw::c_uint = 134217728;
pub const E1000_CTRL_TFCE: ::kernel::sys::raw::c_uint = 268435456;
pub const E1000_CTRL_VME: ::kernel::sys::raw::c_uint = 1073741824;
pub const E1000_CTRL_PHY_RST: ::kernel::sys::raw::c_uint = 2147483648;
pub const E1000_CTRL_I2C_ENA: ::kernel::sys::raw::c_uint = 33554432;
pub const E1000_CTRL_MDIO_DIR: ::kernel::sys::raw::c_uint = 16777216;
pub const E1000_CTRL_MDIO: ::kernel::sys::raw::c_uint = 1048576;
pub const E1000_CTRL_MDC_DIR: ::kernel::sys::raw::c_uint = 33554432;
pub const E1000_CTRL_MDC: ::kernel::sys::raw::c_uint = 2097152;
pub const E1000_CONNSW_ENRGSRC: ::kernel::sys::raw::c_uint = 4;
pub const E1000_CONNSW_PHYSD: ::kernel::sys::raw::c_uint = 1024;
pub const E1000_CONNSW_PHY_PDN: ::kernel::sys::raw::c_uint = 2048;
pub const E1000_CONNSW_SERDESD: ::kernel::sys::raw::c_uint = 512;
pub const E1000_CONNSW_AUTOSENSE_CONF: ::kernel::sys::raw::c_uint = 2;
pub const E1000_CONNSW_AUTOSENSE_EN: ::kernel::sys::raw::c_uint = 1;
pub const E1000_PCS_CFG_PCS_EN: ::kernel::sys::raw::c_uint = 8;
pub const E1000_PCS_LCTL_FLV_LINK_UP: ::kernel::sys::raw::c_uint = 1;
pub const E1000_PCS_LCTL_FSV_10: ::kernel::sys::raw::c_uint = 0;
pub const E1000_PCS_LCTL_FSV_100: ::kernel::sys::raw::c_uint = 2;
pub const E1000_PCS_LCTL_FSV_1000: ::kernel::sys::raw::c_uint = 4;
pub const E1000_PCS_LCTL_FDV_FULL: ::kernel::sys::raw::c_uint = 8;
pub const E1000_PCS_LCTL_FSD: ::kernel::sys::raw::c_uint = 16;
pub const E1000_PCS_LCTL_FORCE_LINK: ::kernel::sys::raw::c_uint = 32;
pub const E1000_PCS_LCTL_FORCE_FCTRL: ::kernel::sys::raw::c_uint = 128;
pub const E1000_PCS_LCTL_AN_ENABLE: ::kernel::sys::raw::c_uint = 65536;
pub const E1000_PCS_LCTL_AN_RESTART: ::kernel::sys::raw::c_uint = 131072;
pub const E1000_PCS_LCTL_AN_TIMEOUT: ::kernel::sys::raw::c_uint = 262144;
pub const E1000_ENABLE_SERDES_LOOPBACK: ::kernel::sys::raw::c_uint = 1040;
pub const E1000_PCS_LSTS_LINK_OK: ::kernel::sys::raw::c_uint = 1;
pub const E1000_PCS_LSTS_SPEED_100: ::kernel::sys::raw::c_uint = 2;
pub const E1000_PCS_LSTS_SPEED_1000: ::kernel::sys::raw::c_uint = 4;
pub const E1000_PCS_LSTS_DUPLEX_FULL: ::kernel::sys::raw::c_uint = 8;
pub const E1000_PCS_LSTS_SYNK_OK: ::kernel::sys::raw::c_uint = 16;
pub const E1000_PCS_LSTS_AN_COMPLETE: ::kernel::sys::raw::c_uint = 65536;
pub const E1000_STATUS_FD: ::kernel::sys::raw::c_uint = 1;
pub const E1000_STATUS_LU: ::kernel::sys::raw::c_uint = 2;
pub const E1000_STATUS_FUNC_MASK: ::kernel::sys::raw::c_uint = 12;
pub const E1000_STATUS_FUNC_SHIFT: ::kernel::sys::raw::c_uint = 2;
pub const E1000_STATUS_FUNC_1: ::kernel::sys::raw::c_uint = 4;
pub const E1000_STATUS_TXOFF: ::kernel::sys::raw::c_uint = 16;
pub const E1000_STATUS_SPEED_MASK: ::kernel::sys::raw::c_uint = 192;
pub const E1000_STATUS_SPEED_10: ::kernel::sys::raw::c_uint = 0;
pub const E1000_STATUS_SPEED_100: ::kernel::sys::raw::c_uint = 64;
pub const E1000_STATUS_SPEED_1000: ::kernel::sys::raw::c_uint = 128;
pub const E1000_STATUS_LAN_INIT_DONE: ::kernel::sys::raw::c_uint = 512;
pub const E1000_STATUS_PHYRA: ::kernel::sys::raw::c_uint = 1024;
pub const E1000_STATUS_GIO_MASTER_ENABLE: ::kernel::sys::raw::c_uint = 524288;
pub const E1000_STATUS_PCI66: ::kernel::sys::raw::c_uint = 2048;
pub const E1000_STATUS_BUS64: ::kernel::sys::raw::c_uint = 4096;
pub const E1000_STATUS_2P5_SKU: ::kernel::sys::raw::c_uint = 4096;
pub const E1000_STATUS_2P5_SKU_OVER: ::kernel::sys::raw::c_uint = 8192;
pub const E1000_STATUS_PCIX_MODE: ::kernel::sys::raw::c_uint = 8192;
pub const E1000_STATUS_PCIX_SPEED: ::kernel::sys::raw::c_uint = 49152;
pub const E1000_STATUS_PCIX_SPEED_66: ::kernel::sys::raw::c_uint = 0;
pub const E1000_STATUS_PCIX_SPEED_100: ::kernel::sys::raw::c_uint = 16384;
pub const E1000_STATUS_PCIX_SPEED_133: ::kernel::sys::raw::c_uint = 32768;
pub const SPEED_10: ::kernel::sys::raw::c_uint = 10;
pub const SPEED_100: ::kernel::sys::raw::c_uint = 100;
pub const SPEED_1000: ::kernel::sys::raw::c_uint = 1000;
pub const SPEED_2500: ::kernel::sys::raw::c_uint = 2500;
pub const HALF_DUPLEX: ::kernel::sys::raw::c_uint = 1;
pub const FULL_DUPLEX: ::kernel::sys::raw::c_uint = 2;
pub const PHY_FORCE_TIME: ::kernel::sys::raw::c_uint = 20;
pub const ADVERTISE_10_HALF: ::kernel::sys::raw::c_uint = 1;
pub const ADVERTISE_10_FULL: ::kernel::sys::raw::c_uint = 2;
pub const ADVERTISE_100_HALF: ::kernel::sys::raw::c_uint = 4;
pub const ADVERTISE_100_FULL: ::kernel::sys::raw::c_uint = 8;
pub const ADVERTISE_1000_HALF: ::kernel::sys::raw::c_uint = 16;
pub const ADVERTISE_1000_FULL: ::kernel::sys::raw::c_uint = 32;
pub const E1000_ALL_SPEED_DUPLEX: ::kernel::sys::raw::c_uint = 47;
pub const E1000_ALL_NOT_GIG: ::kernel::sys::raw::c_uint = 15;
pub const E1000_ALL_100_SPEED: ::kernel::sys::raw::c_uint = 12;
pub const E1000_ALL_10_SPEED: ::kernel::sys::raw::c_uint = 3;
pub const E1000_ALL_HALF_DUPLEX: ::kernel::sys::raw::c_uint = 5;
pub const AUTONEG_ADVERTISE_SPEED_DEFAULT: ::kernel::sys::raw::c_uint = 47;
pub const E1000_PHY_LED0_MODE_MASK: ::kernel::sys::raw::c_uint = 7;
pub const E1000_PHY_LED0_IVRT: ::kernel::sys::raw::c_uint = 8;
pub const E1000_PHY_LED0_MASK: ::kernel::sys::raw::c_uint = 31;
pub const E1000_LEDCTL_LED0_MODE_MASK: ::kernel::sys::raw::c_uint = 15;
pub const E1000_LEDCTL_LED0_MODE_SHIFT: ::kernel::sys::raw::c_uint = 0;
pub const E1000_LEDCTL_LED0_IVRT: ::kernel::sys::raw::c_uint = 64;
pub const E1000_LEDCTL_LED0_BLINK: ::kernel::sys::raw::c_uint = 128;
pub const E1000_LEDCTL_MODE_LINK_UP: ::kernel::sys::raw::c_uint = 2;
pub const E1000_LEDCTL_MODE_LED_ON: ::kernel::sys::raw::c_uint = 14;
pub const E1000_LEDCTL_MODE_LED_OFF: ::kernel::sys::raw::c_uint = 15;
pub const E1000_TXD_DTYP_D: ::kernel::sys::raw::c_uint = 1048576;
pub const E1000_TXD_DTYP_C: ::kernel::sys::raw::c_uint = 0;
pub const E1000_TXD_POPTS_IXSM: ::kernel::sys::raw::c_uint = 1;
pub const E1000_TXD_POPTS_TXSM: ::kernel::sys::raw::c_uint = 2;
pub const E1000_TXD_CMD_EOP: ::kernel::sys::raw::c_uint = 16777216;
pub const E1000_TXD_CMD_IFCS: ::kernel::sys::raw::c_uint = 33554432;
pub const E1000_TXD_CMD_IC: ::kernel::sys::raw::c_uint = 67108864;
pub const E1000_TXD_CMD_RS: ::kernel::sys::raw::c_uint = 134217728;
pub const E1000_TXD_CMD_RPS: ::kernel::sys::raw::c_uint = 268435456;
pub const E1000_TXD_CMD_DEXT: ::kernel::sys::raw::c_uint = 536870912;
pub const E1000_TXD_CMD_VLE: ::kernel::sys::raw::c_uint = 1073741824;
pub const E1000_TXD_CMD_IDE: ::kernel::sys::raw::c_uint = 2147483648;
pub const E1000_TXD_STAT_DD: ::kernel::sys::raw::c_uint = 1;
pub const E1000_TXD_STAT_EC: ::kernel::sys::raw::c_uint = 2;
pub const E1000_TXD_STAT_LC: ::kernel::sys::raw::c_uint = 4;
pub const E1000_TXD_STAT_TU: ::kernel::sys::raw::c_uint = 8;
pub const E1000_TXD_CMD_TCP: ::kernel::sys::raw::c_uint = 16777216;
pub const E1000_TXD_CMD_IP: ::kernel::sys::raw::c_uint = 33554432;
pub const E1000_TXD_CMD_TSE: ::kernel::sys::raw::c_uint = 67108864;
pub const E1000_TXD_STAT_TC: ::kernel::sys::raw::c_uint = 4;
pub const E1000_TXD_EXTCMD_TSTAMP: ::kernel::sys::raw::c_uint = 16;
pub const E1000_TCTL_EN: ::kernel::sys::raw::c_uint = 2;
pub const E1000_TCTL_PSP: ::kernel::sys::raw::c_uint = 8;
pub const E1000_TCTL_CT: ::kernel::sys::raw::c_uint = 4080;
pub const E1000_TCTL_COLD: ::kernel::sys::raw::c_uint = 4190208;
pub const E1000_TCTL_RTLC: ::kernel::sys::raw::c_uint = 16777216;
pub const E1000_TCTL_MULR: ::kernel::sys::raw::c_uint = 268435456;
pub const E1000_TARC0_ENABLE: ::kernel::sys::raw::c_uint = 1024;
pub const E1000_SCTL_DISABLE_SERDES_LOOPBACK: ::kernel::sys::raw::c_uint =
    1024;
pub const E1000_SCTL_ENABLE_SERDES_LOOPBACK: ::kernel::sys::raw::c_uint =
    1040;
pub const E1000_RXCSUM_IPOFL: ::kernel::sys::raw::c_uint = 256;
pub const E1000_RXCSUM_TUOFL: ::kernel::sys::raw::c_uint = 512;
pub const E1000_RXCSUM_CRCOFL: ::kernel::sys::raw::c_uint = 2048;
pub const E1000_RXCSUM_IPPCSE: ::kernel::sys::raw::c_uint = 4096;
pub const E1000_RXCSUM_PCSD: ::kernel::sys::raw::c_uint = 8192;
pub const E1000_RFCTL_NFSW_DIS: ::kernel::sys::raw::c_uint = 64;
pub const E1000_RFCTL_NFSR_DIS: ::kernel::sys::raw::c_uint = 128;
pub const E1000_RFCTL_ACK_DIS: ::kernel::sys::raw::c_uint = 4096;
pub const E1000_RFCTL_EXTEN: ::kernel::sys::raw::c_uint = 32768;
pub const E1000_RFCTL_IPV6_EX_DIS: ::kernel::sys::raw::c_uint = 65536;
pub const E1000_RFCTL_NEW_IPV6_EXT_DIS: ::kernel::sys::raw::c_uint = 131072;
pub const E1000_RFCTL_LEF: ::kernel::sys::raw::c_uint = 262144;
pub const E1000_COLLISION_THRESHOLD: ::kernel::sys::raw::c_uint = 15;
pub const E1000_CT_SHIFT: ::kernel::sys::raw::c_uint = 4;
pub const E1000_COLLISION_DISTANCE: ::kernel::sys::raw::c_uint = 63;
pub const E1000_COLD_SHIFT: ::kernel::sys::raw::c_uint = 12;
pub const DEFAULT_82542_TIPG_IPGT: ::kernel::sys::raw::c_uint = 10;
pub const DEFAULT_82543_TIPG_IPGT_FIBER: ::kernel::sys::raw::c_uint = 9;
pub const DEFAULT_82543_TIPG_IPGT_COPPER: ::kernel::sys::raw::c_uint = 8;
pub const E1000_TIPG_IPGT_MASK: ::kernel::sys::raw::c_uint = 1023;
pub const DEFAULT_82542_TIPG_IPGR1: ::kernel::sys::raw::c_uint = 2;
pub const DEFAULT_82543_TIPG_IPGR1: ::kernel::sys::raw::c_uint = 8;
pub const E1000_TIPG_IPGR1_SHIFT: ::kernel::sys::raw::c_uint = 10;
pub const DEFAULT_82542_TIPG_IPGR2: ::kernel::sys::raw::c_uint = 10;
pub const DEFAULT_82543_TIPG_IPGR2: ::kernel::sys::raw::c_uint = 6;
pub const DEFAULT_80003ES2LAN_TIPG_IPGR2: ::kernel::sys::raw::c_uint = 7;
pub const E1000_TIPG_IPGR2_SHIFT: ::kernel::sys::raw::c_uint = 20;
pub const ETHERNET_IEEE_VLAN_TYPE: ::kernel::sys::raw::c_uint = 33024;
pub const ETHERNET_FCS_SIZE: ::kernel::sys::raw::c_uint = 4;
pub const MAX_JUMBO_FRAME_SIZE: ::kernel::sys::raw::c_uint = 16128;
pub const MAX_RX_JUMBO_FRAME_SIZE: ::kernel::sys::raw::c_uint = 9728;
pub const E1000_TX_PTR_GAP: ::kernel::sys::raw::c_uint = 31;
pub const E1000_EXTCNF_CTRL_MDIO_SW_OWNERSHIP: ::kernel::sys::raw::c_uint =
    32;
pub const E1000_EXTCNF_CTRL_LCD_WRITE_ENABLE: ::kernel::sys::raw::c_uint = 1;
pub const E1000_EXTCNF_CTRL_OEM_WRITE_ENABLE: ::kernel::sys::raw::c_uint = 8;
pub const E1000_EXTCNF_CTRL_SWFLAG: ::kernel::sys::raw::c_uint = 32;
pub const E1000_EXTCNF_CTRL_GATE_PHY_CFG: ::kernel::sys::raw::c_uint = 128;
pub const E1000_EXTCNF_SIZE_EXT_PCIE_LENGTH_MASK: ::kernel::sys::raw::c_uint =
    16711680;
pub const E1000_EXTCNF_SIZE_EXT_PCIE_LENGTH_SHIFT: ::kernel::sys::raw::c_uint
          =
    16;
pub const E1000_EXTCNF_CTRL_EXT_CNF_POINTER_MASK: ::kernel::sys::raw::c_uint =
    268369920;
pub const E1000_EXTCNF_CTRL_EXT_CNF_POINTER_SHIFT: ::kernel::sys::raw::c_uint
          =
    16;
pub const E1000_PHY_CTRL_D0A_LPLU: ::kernel::sys::raw::c_uint = 2;
pub const E1000_PHY_CTRL_NOND0A_LPLU: ::kernel::sys::raw::c_uint = 4;
pub const E1000_PHY_CTRL_NOND0A_GBE_DISABLE: ::kernel::sys::raw::c_uint = 8;
pub const E1000_PHY_CTRL_GBE_DISABLE: ::kernel::sys::raw::c_uint = 64;
pub const E1000_KABGTXD_BGSQLBIAS: ::kernel::sys::raw::c_uint = 327680;
pub const E1000_LPIC_LPIET_SHIFT: ::kernel::sys::raw::c_uint = 24;
pub const E1000_PBA_8K: ::kernel::sys::raw::c_uint = 8;
pub const E1000_PBA_10K: ::kernel::sys::raw::c_uint = 10;
pub const E1000_PBA_12K: ::kernel::sys::raw::c_uint = 12;
pub const E1000_PBA_14K: ::kernel::sys::raw::c_uint = 14;
pub const E1000_PBA_16K: ::kernel::sys::raw::c_uint = 16;
pub const E1000_PBA_18K: ::kernel::sys::raw::c_uint = 18;
pub const E1000_PBA_20K: ::kernel::sys::raw::c_uint = 20;
pub const E1000_PBA_22K: ::kernel::sys::raw::c_uint = 22;
pub const E1000_PBA_24K: ::kernel::sys::raw::c_uint = 24;
pub const E1000_PBA_26K: ::kernel::sys::raw::c_uint = 26;
pub const E1000_PBA_30K: ::kernel::sys::raw::c_uint = 30;
pub const E1000_PBA_32K: ::kernel::sys::raw::c_uint = 32;
pub const E1000_PBA_34K: ::kernel::sys::raw::c_uint = 34;
pub const E1000_PBA_35K: ::kernel::sys::raw::c_uint = 35;
pub const E1000_PBA_38K: ::kernel::sys::raw::c_uint = 38;
pub const E1000_PBA_40K: ::kernel::sys::raw::c_uint = 40;
pub const E1000_PBA_48K: ::kernel::sys::raw::c_uint = 48;
pub const E1000_PBA_64K: ::kernel::sys::raw::c_uint = 64;
pub const E1000_PBA_RXA_MASK: ::kernel::sys::raw::c_uint = 65535;
pub const E1000_PBS_16K: ::kernel::sys::raw::c_uint = 16;
pub const E1000_PBECCSTS_CORR_ERR_CNT_MASK: ::kernel::sys::raw::c_uint = 255;
pub const E1000_PBECCSTS_UNCORR_ERR_CNT_MASK: ::kernel::sys::raw::c_uint =
    65280;
pub const E1000_PBECCSTS_UNCORR_ERR_CNT_SHIFT: ::kernel::sys::raw::c_uint = 8;
pub const E1000_PBECCSTS_ECC_ENABLE: ::kernel::sys::raw::c_uint = 65536;
pub const IFS_MAX: ::kernel::sys::raw::c_uint = 80;
pub const IFS_MIN: ::kernel::sys::raw::c_uint = 40;
pub const IFS_RATIO: ::kernel::sys::raw::c_uint = 4;
pub const IFS_STEP: ::kernel::sys::raw::c_uint = 10;
pub const MIN_NUM_XMITS: ::kernel::sys::raw::c_uint = 1000;
pub const E1000_SWSM_SMBI: ::kernel::sys::raw::c_uint = 1;
pub const E1000_SWSM_SWESMBI: ::kernel::sys::raw::c_uint = 2;
pub const E1000_SWSM_DRV_LOAD: ::kernel::sys::raw::c_uint = 8;
pub const E1000_SWSM2_LOCK: ::kernel::sys::raw::c_uint = 2;
pub const E1000_ICR_TXDW: ::kernel::sys::raw::c_uint = 1;
pub const E1000_ICR_TXQE: ::kernel::sys::raw::c_uint = 2;
pub const E1000_ICR_LSC: ::kernel::sys::raw::c_uint = 4;
pub const E1000_ICR_RXSEQ: ::kernel::sys::raw::c_uint = 8;
pub const E1000_ICR_RXDMT0: ::kernel::sys::raw::c_uint = 16;
pub const E1000_ICR_RXO: ::kernel::sys::raw::c_uint = 64;
pub const E1000_ICR_RXT0: ::kernel::sys::raw::c_uint = 128;
pub const E1000_ICR_VMMB: ::kernel::sys::raw::c_uint = 256;
pub const E1000_ICR_RXCFG: ::kernel::sys::raw::c_uint = 1024;
pub const E1000_ICR_GPI_EN0: ::kernel::sys::raw::c_uint = 2048;
pub const E1000_ICR_GPI_EN1: ::kernel::sys::raw::c_uint = 4096;
pub const E1000_ICR_GPI_EN2: ::kernel::sys::raw::c_uint = 8192;
pub const E1000_ICR_GPI_EN3: ::kernel::sys::raw::c_uint = 16384;
pub const E1000_ICR_TXD_LOW: ::kernel::sys::raw::c_uint = 32768;
pub const E1000_ICR_MNG: ::kernel::sys::raw::c_uint = 262144;
pub const E1000_ICR_ECCER: ::kernel::sys::raw::c_uint = 4194304;
pub const E1000_ICR_TS: ::kernel::sys::raw::c_uint = 524288;
pub const E1000_ICR_DRSTA: ::kernel::sys::raw::c_uint = 1073741824;
pub const E1000_ICR_INT_ASSERTED: ::kernel::sys::raw::c_uint = 2147483648;
pub const E1000_ICR_DOUTSYNC: ::kernel::sys::raw::c_uint = 268435456;
pub const E1000_ICR_RXQ0: ::kernel::sys::raw::c_uint = 1048576;
pub const E1000_ICR_RXQ1: ::kernel::sys::raw::c_uint = 2097152;
pub const E1000_ICR_TXQ0: ::kernel::sys::raw::c_uint = 4194304;
pub const E1000_ICR_TXQ1: ::kernel::sys::raw::c_uint = 8388608;
pub const E1000_ICR_OTHER: ::kernel::sys::raw::c_uint = 16777216;
pub const E1000_ICR_FER: ::kernel::sys::raw::c_uint = 4194304;
pub const E1000_ICR_THS: ::kernel::sys::raw::c_uint = 8388608;
pub const E1000_ICR_MDDET: ::kernel::sys::raw::c_uint = 268435456;
pub const E1000_ITR_MASK: ::kernel::sys::raw::c_uint = 1048575;
pub const E1000_ITR_MULT: ::kernel::sys::raw::c_uint = 256;
pub const E1000_PBA_ECC_COUNTER_MASK: ::kernel::sys::raw::c_uint = 4293918720;
pub const E1000_PBA_ECC_COUNTER_SHIFT: ::kernel::sys::raw::c_uint = 20;
pub const E1000_PBA_ECC_CORR_EN: ::kernel::sys::raw::c_uint = 1;
pub const E1000_PBA_ECC_STAT_CLR: ::kernel::sys::raw::c_uint = 2;
pub const E1000_PBA_ECC_INT_EN: ::kernel::sys::raw::c_uint = 4;
pub const E1000_EICR_RX_QUEUE0: ::kernel::sys::raw::c_uint = 1;
pub const E1000_EICR_RX_QUEUE1: ::kernel::sys::raw::c_uint = 2;
pub const E1000_EICR_RX_QUEUE2: ::kernel::sys::raw::c_uint = 4;
pub const E1000_EICR_RX_QUEUE3: ::kernel::sys::raw::c_uint = 8;
pub const E1000_EICR_TX_QUEUE0: ::kernel::sys::raw::c_uint = 256;
pub const E1000_EICR_TX_QUEUE1: ::kernel::sys::raw::c_uint = 512;
pub const E1000_EICR_TX_QUEUE2: ::kernel::sys::raw::c_uint = 1024;
pub const E1000_EICR_TX_QUEUE3: ::kernel::sys::raw::c_uint = 2048;
pub const E1000_EICR_TCP_TIMER: ::kernel::sys::raw::c_uint = 1073741824;
pub const E1000_EICR_OTHER: ::kernel::sys::raw::c_uint = 2147483648;
pub const E1000_TCPTIMER_KS: ::kernel::sys::raw::c_uint = 256;
pub const E1000_TCPTIMER_COUNT_ENABLE: ::kernel::sys::raw::c_uint = 512;
pub const E1000_TCPTIMER_COUNT_FINISH: ::kernel::sys::raw::c_uint = 1024;
pub const E1000_TCPTIMER_LOOP: ::kernel::sys::raw::c_uint = 2048;
pub const E1000_IMS_TXDW: ::kernel::sys::raw::c_uint = 1;
pub const E1000_IMS_TXQE: ::kernel::sys::raw::c_uint = 2;
pub const E1000_IMS_LSC: ::kernel::sys::raw::c_uint = 4;
pub const E1000_IMS_VMMB: ::kernel::sys::raw::c_uint = 256;
pub const E1000_IMS_RXSEQ: ::kernel::sys::raw::c_uint = 8;
pub const E1000_IMS_RXDMT0: ::kernel::sys::raw::c_uint = 16;
pub const E1000_IMS_RXO: ::kernel::sys::raw::c_uint = 64;
pub const E1000_IMS_RXT0: ::kernel::sys::raw::c_uint = 128;
pub const E1000_IMS_TXD_LOW: ::kernel::sys::raw::c_uint = 32768;
pub const E1000_IMS_ECCER: ::kernel::sys::raw::c_uint = 4194304;
pub const E1000_IMS_TS: ::kernel::sys::raw::c_uint = 524288;
pub const E1000_IMS_DRSTA: ::kernel::sys::raw::c_uint = 1073741824;
pub const E1000_IMS_DOUTSYNC: ::kernel::sys::raw::c_uint = 268435456;
pub const E1000_IMS_RXQ0: ::kernel::sys::raw::c_uint = 1048576;
pub const E1000_IMS_RXQ1: ::kernel::sys::raw::c_uint = 2097152;
pub const E1000_IMS_TXQ0: ::kernel::sys::raw::c_uint = 4194304;
pub const E1000_IMS_TXQ1: ::kernel::sys::raw::c_uint = 8388608;
pub const E1000_IMS_OTHER: ::kernel::sys::raw::c_uint = 16777216;
pub const E1000_IMS_FER: ::kernel::sys::raw::c_uint = 4194304;
pub const E1000_IMS_THS: ::kernel::sys::raw::c_uint = 8388608;
pub const E1000_IMS_MDDET: ::kernel::sys::raw::c_uint = 268435456;
pub const E1000_EIMS_RX_QUEUE0: ::kernel::sys::raw::c_uint = 1;
pub const E1000_EIMS_RX_QUEUE1: ::kernel::sys::raw::c_uint = 2;
pub const E1000_EIMS_RX_QUEUE2: ::kernel::sys::raw::c_uint = 4;
pub const E1000_EIMS_RX_QUEUE3: ::kernel::sys::raw::c_uint = 8;
pub const E1000_EIMS_TX_QUEUE0: ::kernel::sys::raw::c_uint = 256;
pub const E1000_EIMS_TX_QUEUE1: ::kernel::sys::raw::c_uint = 512;
pub const E1000_EIMS_TX_QUEUE2: ::kernel::sys::raw::c_uint = 1024;
pub const E1000_EIMS_TX_QUEUE3: ::kernel::sys::raw::c_uint = 2048;
pub const E1000_EIMS_TCP_TIMER: ::kernel::sys::raw::c_uint = 1073741824;
pub const E1000_EIMS_OTHER: ::kernel::sys::raw::c_uint = 2147483648;
pub const E1000_ICS_LSC: ::kernel::sys::raw::c_uint = 4;
pub const E1000_ICS_RXSEQ: ::kernel::sys::raw::c_uint = 8;
pub const E1000_ICS_RXDMT0: ::kernel::sys::raw::c_uint = 16;
pub const E1000_EICS_RX_QUEUE0: ::kernel::sys::raw::c_uint = 1;
pub const E1000_EICS_RX_QUEUE1: ::kernel::sys::raw::c_uint = 2;
pub const E1000_EICS_RX_QUEUE2: ::kernel::sys::raw::c_uint = 4;
pub const E1000_EICS_RX_QUEUE3: ::kernel::sys::raw::c_uint = 8;
pub const E1000_EICS_TX_QUEUE0: ::kernel::sys::raw::c_uint = 256;
pub const E1000_EICS_TX_QUEUE1: ::kernel::sys::raw::c_uint = 512;
pub const E1000_EICS_TX_QUEUE2: ::kernel::sys::raw::c_uint = 1024;
pub const E1000_EICS_TX_QUEUE3: ::kernel::sys::raw::c_uint = 2048;
pub const E1000_EICS_TCP_TIMER: ::kernel::sys::raw::c_uint = 1073741824;
pub const E1000_EICS_OTHER: ::kernel::sys::raw::c_uint = 2147483648;
pub const E1000_EITR_ITR_INT_MASK: ::kernel::sys::raw::c_uint = 65535;
pub const E1000_EITR_CNT_IGNR: ::kernel::sys::raw::c_uint = 2147483648;
pub const E1000_EITR_INTERVAL: ::kernel::sys::raw::c_uint = 32764;
pub const E1000_TXDCTL_PTHRESH: ::kernel::sys::raw::c_uint = 63;
pub const E1000_TXDCTL_HTHRESH: ::kernel::sys::raw::c_uint = 16128;
pub const E1000_TXDCTL_WTHRESH: ::kernel::sys::raw::c_uint = 4128768;
pub const E1000_TXDCTL_GRAN: ::kernel::sys::raw::c_uint = 16777216;
pub const E1000_TXDCTL_FULL_TX_DESC_WB: ::kernel::sys::raw::c_uint = 16842752;
pub const E1000_TXDCTL_MAX_TX_DESC_PREFETCH: ::kernel::sys::raw::c_uint =
    16777247;
pub const E1000_TXDCTL_COUNT_DESC: ::kernel::sys::raw::c_uint = 4194304;
pub const FLOW_CONTROL_ADDRESS_LOW: ::kernel::sys::raw::c_uint = 12746753;
pub const FLOW_CONTROL_ADDRESS_HIGH: ::kernel::sys::raw::c_uint = 256;
pub const FLOW_CONTROL_TYPE: ::kernel::sys::raw::c_uint = 34824;
pub const VLAN_TAG_SIZE: ::kernel::sys::raw::c_uint = 4;
pub const E1000_VLAN_FILTER_TBL_SIZE: ::kernel::sys::raw::c_uint = 128;
pub const E1000_RAR_ENTRIES: ::kernel::sys::raw::c_uint = 15;
pub const E1000_RAH_AV: ::kernel::sys::raw::c_uint = 2147483648;
pub const E1000_RAL_MAC_ADDR_LEN: ::kernel::sys::raw::c_uint = 4;
pub const E1000_RAH_MAC_ADDR_LEN: ::kernel::sys::raw::c_uint = 2;
pub const E1000_RAH_QUEUE_MASK_82575: ::kernel::sys::raw::c_uint = 786432;
pub const E1000_RAH_POOL_1: ::kernel::sys::raw::c_uint = 262144;
pub const E1000_SUCCESS: ::kernel::sys::raw::c_uint = 0;
pub const E1000_ERR_NVM: ::kernel::sys::raw::c_uint = 1;
pub const E1000_ERR_PHY: ::kernel::sys::raw::c_uint = 2;
pub const E1000_ERR_CONFIG: ::kernel::sys::raw::c_uint = 3;
pub const E1000_ERR_PARAM: ::kernel::sys::raw::c_uint = 4;
pub const E1000_ERR_MAC_INIT: ::kernel::sys::raw::c_uint = 5;
pub const E1000_ERR_PHY_TYPE: ::kernel::sys::raw::c_uint = 6;
pub const E1000_ERR_RESET: ::kernel::sys::raw::c_uint = 9;
pub const E1000_ERR_MASTER_REQUESTS_PENDING: ::kernel::sys::raw::c_uint = 10;
pub const E1000_ERR_HOST_INTERFACE_COMMAND: ::kernel::sys::raw::c_uint = 11;
pub const E1000_BLK_PHY_RESET: ::kernel::sys::raw::c_uint = 12;
pub const E1000_ERR_SWFW_SYNC: ::kernel::sys::raw::c_uint = 13;
pub const E1000_NOT_IMPLEMENTED: ::kernel::sys::raw::c_uint = 14;
pub const E1000_ERR_MBX: ::kernel::sys::raw::c_uint = 15;
pub const E1000_ERR_INVALID_ARGUMENT: ::kernel::sys::raw::c_uint = 16;
pub const E1000_ERR_NO_SPACE: ::kernel::sys::raw::c_uint = 17;
pub const E1000_ERR_NVM_PBA_SECTION: ::kernel::sys::raw::c_uint = 18;
pub const E1000_ERR_I2C: ::kernel::sys::raw::c_uint = 19;
pub const E1000_ERR_INVM_VALUE_NOT_FOUND: ::kernel::sys::raw::c_uint = 20;
pub const FIBER_LINK_UP_LIMIT: ::kernel::sys::raw::c_uint = 50;
pub const COPPER_LINK_UP_LIMIT: ::kernel::sys::raw::c_uint = 10;
pub const PHY_AUTO_NEG_LIMIT: ::kernel::sys::raw::c_uint = 45;
pub const PHY_FORCE_LIMIT: ::kernel::sys::raw::c_uint = 20;
pub const MASTER_DISABLE_TIMEOUT: ::kernel::sys::raw::c_uint = 800;
pub const PHY_CFG_TIMEOUT: ::kernel::sys::raw::c_uint = 100;
pub const MDIO_OWNERSHIP_TIMEOUT: ::kernel::sys::raw::c_uint = 10;
pub const AUTO_READ_DONE_TIMEOUT: ::kernel::sys::raw::c_uint = 10;
pub const E1000_FCRTH_RTH: ::kernel::sys::raw::c_uint = 65528;
pub const E1000_FCRTL_RTL: ::kernel::sys::raw::c_uint = 65528;
pub const E1000_FCRTL_XONE: ::kernel::sys::raw::c_uint = 2147483648;
pub const E1000_TXCW_FD: ::kernel::sys::raw::c_uint = 32;
pub const E1000_TXCW_PAUSE: ::kernel::sys::raw::c_uint = 128;
pub const E1000_TXCW_ASM_DIR: ::kernel::sys::raw::c_uint = 256;
pub const E1000_TXCW_PAUSE_MASK: ::kernel::sys::raw::c_uint = 384;
pub const E1000_TXCW_ANE: ::kernel::sys::raw::c_uint = 2147483648;
pub const E1000_RXCW_CW: ::kernel::sys::raw::c_uint = 65535;
pub const E1000_RXCW_IV: ::kernel::sys::raw::c_uint = 134217728;
pub const E1000_RXCW_C: ::kernel::sys::raw::c_uint = 536870912;
pub const E1000_RXCW_SYNCH: ::kernel::sys::raw::c_uint = 1073741824;
pub const E1000_TSYNCTXCTL_VALID: ::kernel::sys::raw::c_uint = 1;
pub const E1000_TSYNCTXCTL_ENABLED: ::kernel::sys::raw::c_uint = 16;
pub const E1000_TSYNCTXCTL_MAX_ALLOWED_DLY_MASK: ::kernel::sys::raw::c_uint =
    61440;
pub const E1000_TSYNCTXCTL_SYNC_COMP_ERR: ::kernel::sys::raw::c_uint =
    536870912;
pub const E1000_TSYNCTXCTL_SYNC_COMP: ::kernel::sys::raw::c_uint = 1073741824;
pub const E1000_TSYNCTXCTL_START_SYNC: ::kernel::sys::raw::c_uint =
    2147483648;
pub const E1000_TSYNCRXCTL_VALID: ::kernel::sys::raw::c_uint = 1;
pub const E1000_TSYNCRXCTL_TYPE_MASK: ::kernel::sys::raw::c_uint = 14;
pub const E1000_TSYNCRXCTL_TYPE_L2_V2: ::kernel::sys::raw::c_uint = 0;
pub const E1000_TSYNCRXCTL_TYPE_L4_V1: ::kernel::sys::raw::c_uint = 2;
pub const E1000_TSYNCRXCTL_TYPE_L2_L4_V2: ::kernel::sys::raw::c_uint = 4;
pub const E1000_TSYNCRXCTL_TYPE_ALL: ::kernel::sys::raw::c_uint = 8;
pub const E1000_TSYNCRXCTL_TYPE_EVENT_V2: ::kernel::sys::raw::c_uint = 10;
pub const E1000_TSYNCRXCTL_ENABLED: ::kernel::sys::raw::c_uint = 16;
pub const E1000_TSYNCRXCTL_SYSCFI: ::kernel::sys::raw::c_uint = 32;
pub const E1000_RXMTRL_PTP_V1_SYNC_MESSAGE: ::kernel::sys::raw::c_uint = 0;
pub const E1000_RXMTRL_PTP_V1_DELAY_REQ_MESSAGE: ::kernel::sys::raw::c_uint =
    65536;
pub const E1000_RXMTRL_PTP_V2_SYNC_MESSAGE: ::kernel::sys::raw::c_uint = 0;
pub const E1000_RXMTRL_PTP_V2_DELAY_REQ_MESSAGE: ::kernel::sys::raw::c_uint =
    16777216;
pub const E1000_TSYNCRXCFG_PTP_V1_CTRLT_MASK: ::kernel::sys::raw::c_uint =
    255;
pub const E1000_TSYNCRXCFG_PTP_V1_SYNC_MESSAGE: ::kernel::sys::raw::c_uint =
    0;
pub const E1000_TSYNCRXCFG_PTP_V1_DELAY_REQ_MESSAGE:
          ::kernel::sys::raw::c_uint =
    1;
pub const E1000_TSYNCRXCFG_PTP_V1_FOLLOWUP_MESSAGE: ::kernel::sys::raw::c_uint
          =
    2;
pub const E1000_TSYNCRXCFG_PTP_V1_DELAY_RESP_MESSAGE:
          ::kernel::sys::raw::c_uint =
    3;
pub const E1000_TSYNCRXCFG_PTP_V1_MANAGEMENT_MESSAGE:
          ::kernel::sys::raw::c_uint =
    4;
pub const E1000_TSYNCRXCFG_PTP_V2_MSGID_MASK: ::kernel::sys::raw::c_uint =
    3840;
pub const E1000_TSYNCRXCFG_PTP_V2_SYNC_MESSAGE: ::kernel::sys::raw::c_uint =
    0;
pub const E1000_TSYNCRXCFG_PTP_V2_DELAY_REQ_MESSAGE:
          ::kernel::sys::raw::c_uint =
    256;
pub const E1000_TSYNCRXCFG_PTP_V2_PATH_DELAY_REQ_MESSAGE:
          ::kernel::sys::raw::c_uint =
    512;
pub const E1000_TSYNCRXCFG_PTP_V2_PATH_DELAY_RESP_MESSAGE:
          ::kernel::sys::raw::c_uint =
    768;
pub const E1000_TSYNCRXCFG_PTP_V2_FOLLOWUP_MESSAGE: ::kernel::sys::raw::c_uint
          =
    2048;
pub const E1000_TSYNCRXCFG_PTP_V2_DELAY_RESP_MESSAGE:
          ::kernel::sys::raw::c_uint =
    2304;
pub const E1000_TSYNCRXCFG_PTP_V2_PATH_DELAY_FOLLOWUP_MESSAGE:
          ::kernel::sys::raw::c_uint =
    2560;
pub const E1000_TSYNCRXCFG_PTP_V2_ANNOUNCE_MESSAGE: ::kernel::sys::raw::c_uint
          =
    2816;
pub const E1000_TSYNCRXCFG_PTP_V2_SIGNALLING_MESSAGE:
          ::kernel::sys::raw::c_uint =
    3072;
pub const E1000_TSYNCRXCFG_PTP_V2_MANAGEMENT_MESSAGE:
          ::kernel::sys::raw::c_uint =
    3328;
pub const E1000_TIMINCA_16NS_SHIFT: ::kernel::sys::raw::c_uint = 24;
pub const E1000_TIMINCA_INCPERIOD_SHIFT: ::kernel::sys::raw::c_uint = 24;
pub const E1000_TIMINCA_INCVALUE_MASK: ::kernel::sys::raw::c_uint = 16777215;
pub const E1000_TSICR_TXTS: ::kernel::sys::raw::c_uint = 2;
pub const E1000_TSIM_TXTS: ::kernel::sys::raw::c_uint = 2;
pub const E1000_TTQF_DISABLE_MASK: ::kernel::sys::raw::c_uint = 4026564608;
pub const E1000_TTQF_QUEUE_ENABLE: ::kernel::sys::raw::c_uint = 256;
pub const E1000_TTQF_PROTOCOL_MASK: ::kernel::sys::raw::c_uint = 255;
pub const E1000_TTQF_PROTOCOL_TCP: ::kernel::sys::raw::c_uint = 0;
pub const E1000_TTQF_PROTOCOL_UDP: ::kernel::sys::raw::c_uint = 1;
pub const E1000_TTQF_PROTOCOL_SCTP: ::kernel::sys::raw::c_uint = 2;
pub const E1000_TTQF_PROTOCOL_SHIFT: ::kernel::sys::raw::c_uint = 5;
pub const E1000_TTQF_QUEUE_SHIFT: ::kernel::sys::raw::c_uint = 16;
pub const E1000_TTQF_RX_QUEUE_MASK: ::kernel::sys::raw::c_uint = 458752;
pub const E1000_TTQF_MASK_ENABLE: ::kernel::sys::raw::c_uint = 268435456;
pub const E1000_IMIR_CLEAR_MASK: ::kernel::sys::raw::c_uint = 4026662911;
pub const E1000_IMIR_PORT_BYPASS: ::kernel::sys::raw::c_uint = 131072;
pub const E1000_IMIR_PRIORITY_SHIFT: ::kernel::sys::raw::c_uint = 29;
pub const E1000_IMIREXT_CLEAR_MASK: ::kernel::sys::raw::c_uint = 524287;
pub const E1000_MDICNFG_EXT_MDIO: ::kernel::sys::raw::c_uint = 2147483648;
pub const E1000_MDICNFG_COM_MDIO: ::kernel::sys::raw::c_uint = 1073741824;
pub const E1000_MDICNFG_PHY_MASK: ::kernel::sys::raw::c_uint = 65011712;
pub const E1000_MDICNFG_PHY_SHIFT: ::kernel::sys::raw::c_uint = 21;
pub const E1000_MEDIA_PORT_COPPER: ::kernel::sys::raw::c_uint = 1;
pub const E1000_MEDIA_PORT_OTHER: ::kernel::sys::raw::c_uint = 2;
pub const E1000_M88E1112_AUTO_COPPER_SGMII: ::kernel::sys::raw::c_uint = 2;
pub const E1000_M88E1112_AUTO_COPPER_BASEX: ::kernel::sys::raw::c_uint = 3;
pub const E1000_M88E1112_STATUS_LINK: ::kernel::sys::raw::c_uint = 4;
pub const E1000_M88E1112_MAC_CTRL_1: ::kernel::sys::raw::c_uint = 16;
pub const E1000_M88E1112_MAC_CTRL_1_MODE_MASK: ::kernel::sys::raw::c_uint =
    896;
pub const E1000_M88E1112_MAC_CTRL_1_MODE_SHIFT: ::kernel::sys::raw::c_uint =
    7;
pub const E1000_M88E1112_PAGE_ADDR: ::kernel::sys::raw::c_uint = 22;
pub const E1000_M88E1112_STATUS: ::kernel::sys::raw::c_uint = 1;
pub const E1000_THSTAT_LOW_EVENT: ::kernel::sys::raw::c_uint = 536870912;
pub const E1000_THSTAT_MID_EVENT: ::kernel::sys::raw::c_uint = 2097152;
pub const E1000_THSTAT_HIGH_EVENT: ::kernel::sys::raw::c_uint = 8192;
pub const E1000_THSTAT_PWR_DOWN: ::kernel::sys::raw::c_uint = 1;
pub const E1000_THSTAT_LINK_THROTTLE: ::kernel::sys::raw::c_uint = 2;
pub const E1000_IPCNFG_EEE_1G_AN: ::kernel::sys::raw::c_uint = 8;
pub const E1000_IPCNFG_EEE_100M_AN: ::kernel::sys::raw::c_uint = 4;
pub const E1000_EEER_TX_LPI_EN: ::kernel::sys::raw::c_uint = 65536;
pub const E1000_EEER_RX_LPI_EN: ::kernel::sys::raw::c_uint = 131072;
pub const E1000_EEER_LPI_FC: ::kernel::sys::raw::c_uint = 262144;
pub const E1000_EEER_EEE_NEG: ::kernel::sys::raw::c_uint = 536870912;
pub const E1000_EEER_RX_LPI_STATUS: ::kernel::sys::raw::c_uint = 1073741824;
pub const E1000_EEER_TX_LPI_STATUS: ::kernel::sys::raw::c_uint = 2147483648;
pub const E1000_EEE_LP_ADV_ADDR_I350: ::kernel::sys::raw::c_uint = 1039;
pub const E1000_M88E1543_PAGE_ADDR: ::kernel::sys::raw::c_uint = 22;
pub const E1000_M88E1543_EEE_CTRL_1: ::kernel::sys::raw::c_uint = 0;
pub const E1000_M88E1543_EEE_CTRL_1_MS: ::kernel::sys::raw::c_uint = 1;
pub const E1000_M88E1543_FIBER_CTRL: ::kernel::sys::raw::c_uint = 0;
pub const E1000_EEE_ADV_DEV_I354: ::kernel::sys::raw::c_uint = 7;
pub const E1000_EEE_ADV_ADDR_I354: ::kernel::sys::raw::c_uint = 60;
pub const E1000_EEE_ADV_100_SUPPORTED: ::kernel::sys::raw::c_uint = 2;
pub const E1000_EEE_ADV_1000_SUPPORTED: ::kernel::sys::raw::c_uint = 4;
pub const E1000_PCS_STATUS_DEV_I354: ::kernel::sys::raw::c_uint = 3;
pub const E1000_PCS_STATUS_ADDR_I354: ::kernel::sys::raw::c_uint = 1;
pub const E1000_PCS_STATUS_RX_LPI_RCVD: ::kernel::sys::raw::c_uint = 1024;
pub const E1000_PCS_STATUS_TX_LPI_RCVD: ::kernel::sys::raw::c_uint = 2048;
pub const E1000_M88E1512_CFG_REG_1: ::kernel::sys::raw::c_uint = 16;
pub const E1000_M88E1512_CFG_REG_2: ::kernel::sys::raw::c_uint = 17;
pub const E1000_M88E1512_CFG_REG_3: ::kernel::sys::raw::c_uint = 7;
pub const E1000_M88E1512_MODE: ::kernel::sys::raw::c_uint = 20;
pub const E1000_EEE_SU_LPI_CLK_STP: ::kernel::sys::raw::c_uint = 8388608;
pub const E1000_EEE_LP_ADV_DEV_I210: ::kernel::sys::raw::c_uint = 7;
pub const E1000_EEE_LP_ADV_ADDR_I210: ::kernel::sys::raw::c_uint = 61;
pub const E1000_GCR_RXD_NO_SNOOP: ::kernel::sys::raw::c_uint = 1;
pub const E1000_GCR_RXDSCW_NO_SNOOP: ::kernel::sys::raw::c_uint = 2;
pub const E1000_GCR_RXDSCR_NO_SNOOP: ::kernel::sys::raw::c_uint = 4;
pub const E1000_GCR_TXD_NO_SNOOP: ::kernel::sys::raw::c_uint = 8;
pub const E1000_GCR_TXDSCW_NO_SNOOP: ::kernel::sys::raw::c_uint = 16;
pub const E1000_GCR_TXDSCR_NO_SNOOP: ::kernel::sys::raw::c_uint = 32;
pub const E1000_GCR_CMPL_TMOUT_MASK: ::kernel::sys::raw::c_uint = 61440;
pub const E1000_GCR_CMPL_TMOUT_10ms: ::kernel::sys::raw::c_uint = 4096;
pub const E1000_GCR_CMPL_TMOUT_RESEND: ::kernel::sys::raw::c_uint = 65536;
pub const E1000_GCR_CAP_VER2: ::kernel::sys::raw::c_uint = 262144;
pub const PCIE_NO_SNOOP_ALL: ::kernel::sys::raw::c_uint = 63;
pub const E1000_MMDAC_FUNC_DATA: ::kernel::sys::raw::c_uint = 16384;
pub const E1000_MPHY_ADDR_CTL: ::kernel::sys::raw::c_uint = 36;
pub const E1000_MPHY_ADDR_CTL_OFFSET_MASK: ::kernel::sys::raw::c_uint =
    4294901760;
pub const E1000_MPHY_PCS_CLK_REG_OFFSET: ::kernel::sys::raw::c_uint = 4;
pub const E1000_MPHY_PCS_CLK_REG_DIGINELBEN: ::kernel::sys::raw::c_uint = 16;
pub const MII_CR_SPEED_SELECT_MSB: ::kernel::sys::raw::c_uint = 64;
pub const MII_CR_COLL_TEST_ENABLE: ::kernel::sys::raw::c_uint = 128;
pub const MII_CR_FULL_DUPLEX: ::kernel::sys::raw::c_uint = 256;
pub const MII_CR_RESTART_AUTO_NEG: ::kernel::sys::raw::c_uint = 512;
pub const MII_CR_ISOLATE: ::kernel::sys::raw::c_uint = 1024;
pub const MII_CR_POWER_DOWN: ::kernel::sys::raw::c_uint = 2048;
pub const MII_CR_AUTO_NEG_EN: ::kernel::sys::raw::c_uint = 4096;
pub const MII_CR_SPEED_SELECT_LSB: ::kernel::sys::raw::c_uint = 8192;
pub const MII_CR_LOOPBACK: ::kernel::sys::raw::c_uint = 16384;
pub const MII_CR_RESET: ::kernel::sys::raw::c_uint = 32768;
pub const MII_CR_SPEED_1000: ::kernel::sys::raw::c_uint = 64;
pub const MII_CR_SPEED_100: ::kernel::sys::raw::c_uint = 8192;
pub const MII_CR_SPEED_10: ::kernel::sys::raw::c_uint = 0;
pub const MII_SR_EXTENDED_CAPS: ::kernel::sys::raw::c_uint = 1;
pub const MII_SR_JABBER_DETECT: ::kernel::sys::raw::c_uint = 2;
pub const MII_SR_LINK_STATUS: ::kernel::sys::raw::c_uint = 4;
pub const MII_SR_AUTONEG_CAPS: ::kernel::sys::raw::c_uint = 8;
pub const MII_SR_REMOTE_FAULT: ::kernel::sys::raw::c_uint = 16;
pub const MII_SR_AUTONEG_COMPLETE: ::kernel::sys::raw::c_uint = 32;
pub const MII_SR_PREAMBLE_SUPPRESS: ::kernel::sys::raw::c_uint = 64;
pub const MII_SR_EXTENDED_STATUS: ::kernel::sys::raw::c_uint = 256;
pub const MII_SR_100T2_HD_CAPS: ::kernel::sys::raw::c_uint = 512;
pub const MII_SR_100T2_FD_CAPS: ::kernel::sys::raw::c_uint = 1024;
pub const MII_SR_10T_HD_CAPS: ::kernel::sys::raw::c_uint = 2048;
pub const MII_SR_10T_FD_CAPS: ::kernel::sys::raw::c_uint = 4096;
pub const MII_SR_100X_HD_CAPS: ::kernel::sys::raw::c_uint = 8192;
pub const MII_SR_100X_FD_CAPS: ::kernel::sys::raw::c_uint = 16384;
pub const MII_SR_100T4_CAPS: ::kernel::sys::raw::c_uint = 32768;
pub const NWAY_AR_SELECTOR_FIELD: ::kernel::sys::raw::c_uint = 1;
pub const NWAY_AR_10T_HD_CAPS: ::kernel::sys::raw::c_uint = 32;
pub const NWAY_AR_10T_FD_CAPS: ::kernel::sys::raw::c_uint = 64;
pub const NWAY_AR_100TX_HD_CAPS: ::kernel::sys::raw::c_uint = 128;
pub const NWAY_AR_100TX_FD_CAPS: ::kernel::sys::raw::c_uint = 256;
pub const NWAY_AR_100T4_CAPS: ::kernel::sys::raw::c_uint = 512;
pub const NWAY_AR_PAUSE: ::kernel::sys::raw::c_uint = 1024;
pub const NWAY_AR_ASM_DIR: ::kernel::sys::raw::c_uint = 2048;
pub const NWAY_AR_REMOTE_FAULT: ::kernel::sys::raw::c_uint = 8192;
pub const NWAY_AR_NEXT_PAGE: ::kernel::sys::raw::c_uint = 32768;
pub const NWAY_LPAR_SELECTOR_FIELD: ::kernel::sys::raw::c_uint = 0;
pub const NWAY_LPAR_10T_HD_CAPS: ::kernel::sys::raw::c_uint = 32;
pub const NWAY_LPAR_10T_FD_CAPS: ::kernel::sys::raw::c_uint = 64;
pub const NWAY_LPAR_100TX_HD_CAPS: ::kernel::sys::raw::c_uint = 128;
pub const NWAY_LPAR_100TX_FD_CAPS: ::kernel::sys::raw::c_uint = 256;
pub const NWAY_LPAR_100T4_CAPS: ::kernel::sys::raw::c_uint = 512;
pub const NWAY_LPAR_PAUSE: ::kernel::sys::raw::c_uint = 1024;
pub const NWAY_LPAR_ASM_DIR: ::kernel::sys::raw::c_uint = 2048;
pub const NWAY_LPAR_REMOTE_FAULT: ::kernel::sys::raw::c_uint = 8192;
pub const NWAY_LPAR_ACKNOWLEDGE: ::kernel::sys::raw::c_uint = 16384;
pub const NWAY_LPAR_NEXT_PAGE: ::kernel::sys::raw::c_uint = 32768;
pub const NWAY_ER_LP_NWAY_CAPS: ::kernel::sys::raw::c_uint = 1;
pub const NWAY_ER_PAGE_RXD: ::kernel::sys::raw::c_uint = 2;
pub const NWAY_ER_NEXT_PAGE_CAPS: ::kernel::sys::raw::c_uint = 4;
pub const NWAY_ER_LP_NEXT_PAGE_CAPS: ::kernel::sys::raw::c_uint = 8;
pub const NWAY_ER_PAR_DETECT_FAULT: ::kernel::sys::raw::c_uint = 16;
pub const CR_1000T_ASYM_PAUSE: ::kernel::sys::raw::c_uint = 128;
pub const CR_1000T_HD_CAPS: ::kernel::sys::raw::c_uint = 256;
pub const CR_1000T_FD_CAPS: ::kernel::sys::raw::c_uint = 512;
pub const CR_1000T_REPEATER_DTE: ::kernel::sys::raw::c_uint = 1024;
pub const CR_1000T_MS_VALUE: ::kernel::sys::raw::c_uint = 2048;
pub const CR_1000T_MS_ENABLE: ::kernel::sys::raw::c_uint = 4096;
pub const CR_1000T_TEST_MODE_NORMAL: ::kernel::sys::raw::c_uint = 0;
pub const CR_1000T_TEST_MODE_1: ::kernel::sys::raw::c_uint = 8192;
pub const CR_1000T_TEST_MODE_2: ::kernel::sys::raw::c_uint = 16384;
pub const CR_1000T_TEST_MODE_3: ::kernel::sys::raw::c_uint = 24576;
pub const CR_1000T_TEST_MODE_4: ::kernel::sys::raw::c_uint = 32768;
pub const SR_1000T_IDLE_ERROR_CNT: ::kernel::sys::raw::c_uint = 255;
pub const SR_1000T_ASYM_PAUSE_DIR: ::kernel::sys::raw::c_uint = 256;
pub const SR_1000T_LP_HD_CAPS: ::kernel::sys::raw::c_uint = 1024;
pub const SR_1000T_LP_FD_CAPS: ::kernel::sys::raw::c_uint = 2048;
pub const SR_1000T_REMOTE_RX_STATUS: ::kernel::sys::raw::c_uint = 4096;
pub const SR_1000T_LOCAL_RX_STATUS: ::kernel::sys::raw::c_uint = 8192;
pub const SR_1000T_MS_CONFIG_RES: ::kernel::sys::raw::c_uint = 16384;
pub const SR_1000T_MS_CONFIG_FAULT: ::kernel::sys::raw::c_uint = 32768;
pub const SR_1000T_PHY_EXCESSIVE_IDLE_ERR_COUNT: ::kernel::sys::raw::c_uint =
    5;
pub const PHY_CONTROL: ::kernel::sys::raw::c_uint = 0;
pub const PHY_STATUS: ::kernel::sys::raw::c_uint = 1;
pub const PHY_ID1: ::kernel::sys::raw::c_uint = 2;
pub const PHY_ID2: ::kernel::sys::raw::c_uint = 3;
pub const PHY_AUTONEG_ADV: ::kernel::sys::raw::c_uint = 4;
pub const PHY_LP_ABILITY: ::kernel::sys::raw::c_uint = 5;
pub const PHY_AUTONEG_EXP: ::kernel::sys::raw::c_uint = 6;
pub const PHY_NEXT_PAGE_TX: ::kernel::sys::raw::c_uint = 7;
pub const PHY_LP_NEXT_PAGE: ::kernel::sys::raw::c_uint = 8;
pub const PHY_1000T_CTRL: ::kernel::sys::raw::c_uint = 9;
pub const PHY_1000T_STATUS: ::kernel::sys::raw::c_uint = 10;
pub const PHY_EXT_STATUS: ::kernel::sys::raw::c_uint = 15;
pub const PHY_CONTROL_LB: ::kernel::sys::raw::c_uint = 16384;
pub const E1000_EECD_SK: ::kernel::sys::raw::c_uint = 1;
pub const E1000_EECD_CS: ::kernel::sys::raw::c_uint = 2;
pub const E1000_EECD_DI: ::kernel::sys::raw::c_uint = 4;
pub const E1000_EECD_DO: ::kernel::sys::raw::c_uint = 8;
pub const E1000_EECD_REQ: ::kernel::sys::raw::c_uint = 64;
pub const E1000_EECD_GNT: ::kernel::sys::raw::c_uint = 128;
pub const E1000_EECD_PRES: ::kernel::sys::raw::c_uint = 256;
pub const E1000_EECD_SIZE: ::kernel::sys::raw::c_uint = 512;
pub const E1000_EECD_BLOCKED: ::kernel::sys::raw::c_uint = 32768;
pub const E1000_EECD_ABORT: ::kernel::sys::raw::c_uint = 65536;
pub const E1000_EECD_TIMEOUT: ::kernel::sys::raw::c_uint = 131072;
pub const E1000_EECD_ERROR_CLR: ::kernel::sys::raw::c_uint = 262144;
pub const E1000_EECD_ADDR_BITS: ::kernel::sys::raw::c_uint = 1024;
pub const E1000_EECD_TYPE: ::kernel::sys::raw::c_uint = 8192;
pub const E1000_NVM_GRANT_ATTEMPTS: ::kernel::sys::raw::c_uint = 1000;
pub const E1000_EECD_AUTO_RD: ::kernel::sys::raw::c_uint = 512;
pub const E1000_EECD_SIZE_EX_MASK: ::kernel::sys::raw::c_uint = 30720;
pub const E1000_EECD_SIZE_EX_SHIFT: ::kernel::sys::raw::c_uint = 11;
pub const E1000_EECD_FLUPD: ::kernel::sys::raw::c_uint = 524288;
pub const E1000_EECD_AUPDEN: ::kernel::sys::raw::c_uint = 1048576;
pub const E1000_EECD_SEC1VAL: ::kernel::sys::raw::c_uint = 4194304;
pub const E1000_EECD_SEC1VAL_VALID_MASK: ::kernel::sys::raw::c_uint = 768;
pub const E1000_EECD_FLUPD_I210: ::kernel::sys::raw::c_uint = 8388608;
pub const E1000_EECD_FLUDONE_I210: ::kernel::sys::raw::c_uint = 67108864;
pub const E1000_EECD_FLASH_DETECTED_I210: ::kernel::sys::raw::c_uint = 524288;
pub const E1000_EECD_SEC1VAL_I210: ::kernel::sys::raw::c_uint = 33554432;
pub const E1000_FLUDONE_ATTEMPTS: ::kernel::sys::raw::c_uint = 20000;
pub const E1000_EERD_EEWR_MAX_COUNT: ::kernel::sys::raw::c_uint = 512;
pub const E1000_I210_FIFO_SEL_RX: ::kernel::sys::raw::c_uint = 0;
pub const E1000_I210_FIFO_SEL_BMC2OS_TX: ::kernel::sys::raw::c_uint = 6;
pub const E1000_I210_FIFO_SEL_BMC2OS_RX: ::kernel::sys::raw::c_uint = 1;
pub const E1000_I210_FLASH_SECTOR_SIZE: ::kernel::sys::raw::c_uint = 4096;
pub const E1000_I210_FW_PTR_MASK: ::kernel::sys::raw::c_uint = 32767;
pub const E1000_I210_FW_VER_OFFSET: ::kernel::sys::raw::c_uint = 328;
pub const E1000_NVM_RW_REG_DATA: ::kernel::sys::raw::c_uint = 16;
pub const E1000_NVM_RW_REG_DONE: ::kernel::sys::raw::c_uint = 2;
pub const E1000_NVM_RW_REG_START: ::kernel::sys::raw::c_uint = 1;
pub const E1000_NVM_RW_ADDR_SHIFT: ::kernel::sys::raw::c_uint = 2;
pub const E1000_NVM_POLL_WRITE: ::kernel::sys::raw::c_uint = 1;
pub const E1000_NVM_POLL_READ: ::kernel::sys::raw::c_uint = 0;
pub const E1000_FLASH_UPDATES: ::kernel::sys::raw::c_uint = 2000;
pub const NVM_COMPAT: ::kernel::sys::raw::c_uint = 3;
pub const NVM_ID_LED_SETTINGS: ::kernel::sys::raw::c_uint = 4;
pub const NVM_SERDES_AMPLITUDE: ::kernel::sys::raw::c_uint = 6;
pub const NVM_PHY_CLASS_WORD: ::kernel::sys::raw::c_uint = 7;
pub const E1000_I210_NVM_FW_MODULE_PTR: ::kernel::sys::raw::c_uint = 16;
pub const E1000_I350_NVM_FW_MODULE_PTR: ::kernel::sys::raw::c_uint = 81;
pub const NVM_FUTURE_INIT_WORD1: ::kernel::sys::raw::c_uint = 25;
pub const NVM_MAC_ADDR: ::kernel::sys::raw::c_uint = 0;
pub const NVM_SUB_DEV_ID: ::kernel::sys::raw::c_uint = 11;
pub const NVM_SUB_VEN_ID: ::kernel::sys::raw::c_uint = 12;
pub const NVM_DEV_ID: ::kernel::sys::raw::c_uint = 13;
pub const NVM_VEN_ID: ::kernel::sys::raw::c_uint = 14;
pub const NVM_INIT_CTRL_2: ::kernel::sys::raw::c_uint = 15;
pub const NVM_INIT_CTRL_4: ::kernel::sys::raw::c_uint = 19;
pub const NVM_LED_1_CFG: ::kernel::sys::raw::c_uint = 28;
pub const NVM_LED_0_2_CFG: ::kernel::sys::raw::c_uint = 31;
pub const NVM_COMPAT_VALID_CSUM: ::kernel::sys::raw::c_uint = 1;
pub const NVM_FUTURE_INIT_WORD1_VALID_CSUM: ::kernel::sys::raw::c_uint = 64;
pub const NVM_INIT_CONTROL2_REG: ::kernel::sys::raw::c_uint = 15;
pub const NVM_INIT_CONTROL3_PORT_B: ::kernel::sys::raw::c_uint = 20;
pub const NVM_INIT_3GIO_3: ::kernel::sys::raw::c_uint = 26;
pub const NVM_SWDEF_PINS_CTRL_PORT_0: ::kernel::sys::raw::c_uint = 32;
pub const NVM_INIT_CONTROL3_PORT_A: ::kernel::sys::raw::c_uint = 36;
pub const NVM_CFG: ::kernel::sys::raw::c_uint = 18;
pub const NVM_ALT_MAC_ADDR_PTR: ::kernel::sys::raw::c_uint = 55;
pub const NVM_CHECKSUM_REG: ::kernel::sys::raw::c_uint = 63;
pub const NVM_COMPATIBILITY_REG_3: ::kernel::sys::raw::c_uint = 3;
pub const NVM_COMPATIBILITY_BIT_MASK: ::kernel::sys::raw::c_uint = 32768;
pub const E1000_NVM_CFG_DONE_PORT_0: ::kernel::sys::raw::c_uint = 262144;
pub const E1000_NVM_CFG_DONE_PORT_1: ::kernel::sys::raw::c_uint = 524288;
pub const E1000_NVM_CFG_DONE_PORT_2: ::kernel::sys::raw::c_uint = 1048576;
pub const E1000_NVM_CFG_DONE_PORT_3: ::kernel::sys::raw::c_uint = 2097152;
pub const NVM_WORD24_COM_MDIO: ::kernel::sys::raw::c_uint = 8;
pub const NVM_WORD24_EXT_MDIO: ::kernel::sys::raw::c_uint = 4;
pub const NVM_WORD24_LNK_MODE_OFFSET: ::kernel::sys::raw::c_uint = 8;
pub const NVM_WORD24_82580_LNK_MODE_OFFSET: ::kernel::sys::raw::c_uint = 4;
pub const NVM_WORD0F_PAUSE_MASK: ::kernel::sys::raw::c_uint = 12288;
pub const NVM_WORD0F_PAUSE: ::kernel::sys::raw::c_uint = 4096;
pub const NVM_WORD0F_ASM_DIR: ::kernel::sys::raw::c_uint = 8192;
pub const NVM_WORD0F_SWPDIO_EXT_MASK: ::kernel::sys::raw::c_uint = 240;
pub const NVM_WORD1A_ASPM_MASK: ::kernel::sys::raw::c_uint = 12;
pub const NVM_COMPAT_LOM: ::kernel::sys::raw::c_uint = 2048;
pub const E1000_PBANUM_LENGTH: ::kernel::sys::raw::c_uint = 11;
pub const NVM_SUM: ::kernel::sys::raw::c_uint = 47802;
pub const NVM_PBA_OFFSET_0: ::kernel::sys::raw::c_uint = 8;
pub const NVM_PBA_OFFSET_1: ::kernel::sys::raw::c_uint = 9;
pub const NVM_PBA_PTR_GUARD: ::kernel::sys::raw::c_uint = 64250;
pub const NVM_RESERVED_WORD: ::kernel::sys::raw::c_uint = 65535;
pub const NVM_PHY_CLASS_A: ::kernel::sys::raw::c_uint = 32768;
pub const NVM_SERDES_AMPLITUDE_MASK: ::kernel::sys::raw::c_uint = 15;
pub const NVM_SIZE_MASK: ::kernel::sys::raw::c_uint = 7168;
pub const NVM_SIZE_SHIFT: ::kernel::sys::raw::c_uint = 10;
pub const NVM_WORD_SIZE_BASE_SHIFT: ::kernel::sys::raw::c_uint = 6;
pub const NVM_SWDPIO_EXT_SHIFT: ::kernel::sys::raw::c_uint = 4;
pub const NVM_READ_OPCODE_MICROWIRE: ::kernel::sys::raw::c_uint = 6;
pub const NVM_WRITE_OPCODE_MICROWIRE: ::kernel::sys::raw::c_uint = 5;
pub const NVM_ERASE_OPCODE_MICROWIRE: ::kernel::sys::raw::c_uint = 7;
pub const NVM_EWEN_OPCODE_MICROWIRE: ::kernel::sys::raw::c_uint = 19;
pub const NVM_EWDS_OPCODE_MICROWIRE: ::kernel::sys::raw::c_uint = 16;
pub const NVM_MAX_RETRY_SPI: ::kernel::sys::raw::c_uint = 5000;
pub const NVM_READ_OPCODE_SPI: ::kernel::sys::raw::c_uint = 3;
pub const NVM_WRITE_OPCODE_SPI: ::kernel::sys::raw::c_uint = 2;
pub const NVM_A8_OPCODE_SPI: ::kernel::sys::raw::c_uint = 8;
pub const NVM_WREN_OPCODE_SPI: ::kernel::sys::raw::c_uint = 6;
pub const NVM_RDSR_OPCODE_SPI: ::kernel::sys::raw::c_uint = 5;
pub const NVM_STATUS_RDY_SPI: ::kernel::sys::raw::c_uint = 1;
pub const ID_LED_RESERVED_0000: ::kernel::sys::raw::c_uint = 0;
pub const ID_LED_RESERVED_FFFF: ::kernel::sys::raw::c_uint = 65535;
pub const ID_LED_DEF1_DEF2: ::kernel::sys::raw::c_uint = 1;
pub const ID_LED_DEF1_ON2: ::kernel::sys::raw::c_uint = 2;
pub const ID_LED_DEF1_OFF2: ::kernel::sys::raw::c_uint = 3;
pub const ID_LED_ON1_DEF2: ::kernel::sys::raw::c_uint = 4;
pub const ID_LED_ON1_ON2: ::kernel::sys::raw::c_uint = 5;
pub const ID_LED_ON1_OFF2: ::kernel::sys::raw::c_uint = 6;
pub const ID_LED_OFF1_DEF2: ::kernel::sys::raw::c_uint = 7;
pub const ID_LED_OFF1_ON2: ::kernel::sys::raw::c_uint = 8;
pub const ID_LED_OFF1_OFF2: ::kernel::sys::raw::c_uint = 9;
pub const IGP_ACTIVITY_LED_MASK: ::kernel::sys::raw::c_uint = 4294963455;
pub const IGP_ACTIVITY_LED_ENABLE: ::kernel::sys::raw::c_uint = 768;
pub const IGP_LED3_MODE: ::kernel::sys::raw::c_uint = 117440512;
pub const PCIX_COMMAND_REGISTER: ::kernel::sys::raw::c_uint = 230;
pub const PCIX_STATUS_REGISTER_LO: ::kernel::sys::raw::c_uint = 232;
pub const PCIX_STATUS_REGISTER_HI: ::kernel::sys::raw::c_uint = 234;
pub const PCI_HEADER_TYPE_REGISTER: ::kernel::sys::raw::c_uint = 14;
pub const PCIE_LINK_STATUS: ::kernel::sys::raw::c_uint = 18;
pub const PCIE_DEVICE_CONTROL2: ::kernel::sys::raw::c_uint = 40;
pub const PCIX_COMMAND_MMRBC_MASK: ::kernel::sys::raw::c_uint = 12;
pub const PCIX_COMMAND_MMRBC_SHIFT: ::kernel::sys::raw::c_uint = 2;
pub const PCIX_STATUS_HI_MMRBC_MASK: ::kernel::sys::raw::c_uint = 96;
pub const PCIX_STATUS_HI_MMRBC_SHIFT: ::kernel::sys::raw::c_uint = 5;
pub const PCIX_STATUS_HI_MMRBC_4K: ::kernel::sys::raw::c_uint = 3;
pub const PCIX_STATUS_HI_MMRBC_2K: ::kernel::sys::raw::c_uint = 2;
pub const PCIX_STATUS_LO_FUNC_MASK: ::kernel::sys::raw::c_uint = 7;
pub const PCI_HEADER_TYPE_MULTIFUNC: ::kernel::sys::raw::c_uint = 128;
pub const PCIE_LINK_WIDTH_MASK: ::kernel::sys::raw::c_uint = 1008;
pub const PCIE_LINK_WIDTH_SHIFT: ::kernel::sys::raw::c_uint = 4;
pub const PCIE_LINK_SPEED_MASK: ::kernel::sys::raw::c_uint = 15;
pub const PCIE_LINK_SPEED_2500: ::kernel::sys::raw::c_uint = 1;
pub const PCIE_LINK_SPEED_5000: ::kernel::sys::raw::c_uint = 2;
pub const PCIE_DEVICE_CONTROL2_16ms: ::kernel::sys::raw::c_uint = 5;
pub const PHY_REVISION_MASK: ::kernel::sys::raw::c_uint = 4294967280;
pub const MAX_PHY_REG_ADDRESS: ::kernel::sys::raw::c_uint = 31;
pub const MAX_PHY_MULTI_PAGE_REG: ::kernel::sys::raw::c_uint = 15;
pub const M88E1000_E_PHY_ID: ::kernel::sys::raw::c_uint = 21040208;
pub const M88E1000_I_PHY_ID: ::kernel::sys::raw::c_uint = 21040176;
pub const M88E1011_I_PHY_ID: ::kernel::sys::raw::c_uint = 21040160;
pub const IGP01E1000_I_PHY_ID: ::kernel::sys::raw::c_uint = 44565376;
pub const M88E1111_I_PHY_ID: ::kernel::sys::raw::c_uint = 21040320;
pub const M88E1543_E_PHY_ID: ::kernel::sys::raw::c_uint = 21040800;
pub const M88E1512_E_PHY_ID: ::kernel::sys::raw::c_uint = 21040592;
pub const M88E1112_E_PHY_ID: ::kernel::sys::raw::c_uint = 21040272;
pub const I347AT4_E_PHY_ID: ::kernel::sys::raw::c_uint = 21040576;
pub const M88E1340M_E_PHY_ID: ::kernel::sys::raw::c_uint = 21040624;
pub const GG82563_E_PHY_ID: ::kernel::sys::raw::c_uint = 21040288;
pub const IGP03E1000_E_PHY_ID: ::kernel::sys::raw::c_uint = 44565392;
pub const IFE_E_PHY_ID: ::kernel::sys::raw::c_uint = 44565296;
pub const IFE_PLUS_E_PHY_ID: ::kernel::sys::raw::c_uint = 44565280;
pub const IFE_C_E_PHY_ID: ::kernel::sys::raw::c_uint = 44565264;
pub const BME1000_E_PHY_ID: ::kernel::sys::raw::c_uint = 21040304;
pub const BME1000_E_PHY_ID_R2: ::kernel::sys::raw::c_uint = 21040305;
pub const I82577_E_PHY_ID: ::kernel::sys::raw::c_uint = 22282320;
pub const I82578_E_PHY_ID: ::kernel::sys::raw::c_uint = 5099584;
pub const I82579_E_PHY_ID: ::kernel::sys::raw::c_uint = 22282384;
pub const I217_E_PHY_ID: ::kernel::sys::raw::c_uint = 22282400;
pub const I82580_I_PHY_ID: ::kernel::sys::raw::c_uint = 22283168;
pub const I350_I_PHY_ID: ::kernel::sys::raw::c_uint = 22283184;
pub const I210_I_PHY_ID: ::kernel::sys::raw::c_uint = 21040128;
pub const IGP04E1000_E_PHY_ID: ::kernel::sys::raw::c_uint = 44565393;
pub const M88_VENDOR: ::kernel::sys::raw::c_uint = 321;
pub const M88E1000_PHY_SPEC_CTRL: ::kernel::sys::raw::c_uint = 16;
pub const M88E1000_PHY_SPEC_STATUS: ::kernel::sys::raw::c_uint = 17;
pub const M88E1000_EXT_PHY_SPEC_CTRL: ::kernel::sys::raw::c_uint = 20;
pub const M88E1000_RX_ERR_CNTR: ::kernel::sys::raw::c_uint = 21;
pub const M88E1000_PHY_EXT_CTRL: ::kernel::sys::raw::c_uint = 26;
pub const M88E1000_PHY_PAGE_SELECT: ::kernel::sys::raw::c_uint = 29;
pub const M88E1000_PHY_GEN_CONTROL: ::kernel::sys::raw::c_uint = 30;
pub const M88E1000_PHY_VCO_REG_BIT8: ::kernel::sys::raw::c_uint = 256;
pub const M88E1000_PHY_VCO_REG_BIT11: ::kernel::sys::raw::c_uint = 2048;
pub const M88E1000_PSCR_POLARITY_REVERSAL: ::kernel::sys::raw::c_uint = 2;
pub const M88E1000_PSCR_MDI_MANUAL_MODE: ::kernel::sys::raw::c_uint = 0;
pub const M88E1000_PSCR_MDIX_MANUAL_MODE: ::kernel::sys::raw::c_uint = 32;
pub const M88E1000_PSCR_AUTO_X_1000T: ::kernel::sys::raw::c_uint = 64;
pub const M88E1000_PSCR_AUTO_X_MODE: ::kernel::sys::raw::c_uint = 96;
pub const M88E1000_PSCR_ASSERT_CRS_ON_TX: ::kernel::sys::raw::c_uint = 2048;
pub const M88E1000_PSSR_REV_POLARITY: ::kernel::sys::raw::c_uint = 2;
pub const M88E1000_PSSR_DOWNSHIFT: ::kernel::sys::raw::c_uint = 32;
pub const M88E1000_PSSR_MDIX: ::kernel::sys::raw::c_uint = 64;
pub const M88E1000_PSSR_CABLE_LENGTH: ::kernel::sys::raw::c_uint = 896;
pub const M88E1000_PSSR_LINK: ::kernel::sys::raw::c_uint = 1024;
pub const M88E1000_PSSR_SPD_DPLX_RESOLVED: ::kernel::sys::raw::c_uint = 2048;
pub const M88E1000_PSSR_DPLX: ::kernel::sys::raw::c_uint = 8192;
pub const M88E1000_PSSR_SPEED: ::kernel::sys::raw::c_uint = 49152;
pub const M88E1000_PSSR_100MBS: ::kernel::sys::raw::c_uint = 16384;
pub const M88E1000_PSSR_1000MBS: ::kernel::sys::raw::c_uint = 32768;
pub const M88E1000_PSSR_CABLE_LENGTH_SHIFT: ::kernel::sys::raw::c_uint = 7;
pub const M88E1000_EPSCR_MASTER_DOWNSHIFT_MASK: ::kernel::sys::raw::c_uint =
    3072;
pub const M88E1000_EPSCR_MASTER_DOWNSHIFT_1X: ::kernel::sys::raw::c_uint = 0;
pub const M88E1000_EPSCR_SLAVE_DOWNSHIFT_MASK: ::kernel::sys::raw::c_uint =
    768;
pub const M88E1000_EPSCR_SLAVE_DOWNSHIFT_1X: ::kernel::sys::raw::c_uint = 256;
pub const M88E1000_EPSCR_TX_CLK_25: ::kernel::sys::raw::c_uint = 112;
pub const I347AT4_PCDL: ::kernel::sys::raw::c_uint = 16;
pub const I347AT4_PCDC: ::kernel::sys::raw::c_uint = 21;
pub const I347AT4_PAGE_SELECT: ::kernel::sys::raw::c_uint = 22;
pub const I347AT4_PSCR_DOWNSHIFT_ENABLE: ::kernel::sys::raw::c_uint = 2048;
pub const I347AT4_PSCR_DOWNSHIFT_MASK: ::kernel::sys::raw::c_uint = 28672;
pub const I347AT4_PSCR_DOWNSHIFT_1X: ::kernel::sys::raw::c_uint = 0;
pub const I347AT4_PSCR_DOWNSHIFT_2X: ::kernel::sys::raw::c_uint = 4096;
pub const I347AT4_PSCR_DOWNSHIFT_3X: ::kernel::sys::raw::c_uint = 8192;
pub const I347AT4_PSCR_DOWNSHIFT_4X: ::kernel::sys::raw::c_uint = 12288;
pub const I347AT4_PSCR_DOWNSHIFT_5X: ::kernel::sys::raw::c_uint = 16384;
pub const I347AT4_PSCR_DOWNSHIFT_6X: ::kernel::sys::raw::c_uint = 20480;
pub const I347AT4_PSCR_DOWNSHIFT_7X: ::kernel::sys::raw::c_uint = 24576;
pub const I347AT4_PSCR_DOWNSHIFT_8X: ::kernel::sys::raw::c_uint = 28672;
pub const I347AT4_PCDC_CABLE_LENGTH_UNIT: ::kernel::sys::raw::c_uint = 1024;
pub const M88E1112_VCT_DSP_DISTANCE: ::kernel::sys::raw::c_uint = 26;
pub const M88EC018_EPSCR_DOWNSHIFT_COUNTER_MASK: ::kernel::sys::raw::c_uint =
    3584;
pub const M88EC018_EPSCR_DOWNSHIFT_COUNTER_5X: ::kernel::sys::raw::c_uint =
    2048;
pub const I82578_EPSCR_DOWNSHIFT_ENABLE: ::kernel::sys::raw::c_uint = 32;
pub const I82578_EPSCR_DOWNSHIFT_COUNTER_MASK: ::kernel::sys::raw::c_uint =
    28;
pub const BME1000_PSCR_ENABLE_DOWNSHIFT: ::kernel::sys::raw::c_uint = 2048;
pub const GG82563_PAGE_SHIFT: ::kernel::sys::raw::c_uint = 5;
pub const GG82563_MIN_ALT_REG: ::kernel::sys::raw::c_uint = 30;
pub const E1000_MDIC_REG_MASK: ::kernel::sys::raw::c_uint = 2031616;
pub const E1000_MDIC_REG_SHIFT: ::kernel::sys::raw::c_uint = 16;
pub const E1000_MDIC_PHY_MASK: ::kernel::sys::raw::c_uint = 65011712;
pub const E1000_MDIC_PHY_SHIFT: ::kernel::sys::raw::c_uint = 21;
pub const E1000_MDIC_OP_WRITE: ::kernel::sys::raw::c_uint = 67108864;
pub const E1000_MDIC_OP_READ: ::kernel::sys::raw::c_uint = 134217728;
pub const E1000_MDIC_READY: ::kernel::sys::raw::c_uint = 268435456;
pub const E1000_MDIC_ERROR: ::kernel::sys::raw::c_uint = 1073741824;
pub const E1000_MDIC_DEST: ::kernel::sys::raw::c_uint = 2147483648;
pub const E1000_GEN_CTL_READY: ::kernel::sys::raw::c_uint = 2147483648;
pub const E1000_GEN_CTL_ADDRESS_SHIFT: ::kernel::sys::raw::c_uint = 8;
pub const E1000_GEN_POLL_TIMEOUT: ::kernel::sys::raw::c_uint = 640;
pub const E1000_LSECTXCAP_SUM_MASK: ::kernel::sys::raw::c_uint = 16711680;
pub const E1000_LSECTXCAP_SUM_SHIFT: ::kernel::sys::raw::c_uint = 16;
pub const E1000_LSECRXCAP_SUM_MASK: ::kernel::sys::raw::c_uint = 16711680;
pub const E1000_LSECRXCAP_SUM_SHIFT: ::kernel::sys::raw::c_uint = 16;
pub const E1000_LSECTXCTRL_EN_MASK: ::kernel::sys::raw::c_uint = 3;
pub const E1000_LSECTXCTRL_DISABLE: ::kernel::sys::raw::c_uint = 0;
pub const E1000_LSECTXCTRL_AUTH: ::kernel::sys::raw::c_uint = 1;
pub const E1000_LSECTXCTRL_AUTH_ENCRYPT: ::kernel::sys::raw::c_uint = 2;
pub const E1000_LSECTXCTRL_AISCI: ::kernel::sys::raw::c_uint = 32;
pub const E1000_LSECTXCTRL_PNTHRSH_MASK: ::kernel::sys::raw::c_uint =
    4294967040;
pub const E1000_LSECTXCTRL_RSV_MASK: ::kernel::sys::raw::c_uint = 216;
pub const E1000_LSECRXCTRL_EN_MASK: ::kernel::sys::raw::c_uint = 12;
pub const E1000_LSECRXCTRL_EN_SHIFT: ::kernel::sys::raw::c_uint = 2;
pub const E1000_LSECRXCTRL_DISABLE: ::kernel::sys::raw::c_uint = 0;
pub const E1000_LSECRXCTRL_CHECK: ::kernel::sys::raw::c_uint = 1;
pub const E1000_LSECRXCTRL_STRICT: ::kernel::sys::raw::c_uint = 2;
pub const E1000_LSECRXCTRL_DROP: ::kernel::sys::raw::c_uint = 3;
pub const E1000_LSECRXCTRL_PLSH: ::kernel::sys::raw::c_uint = 64;
pub const E1000_LSECRXCTRL_RP: ::kernel::sys::raw::c_uint = 128;
pub const E1000_LSECRXCTRL_RSV_MASK: ::kernel::sys::raw::c_uint = 4294967091;
pub const E1000_RTTBCNRC_RS_ENA: ::kernel::sys::raw::c_uint = 2147483648;
pub const E1000_RTTBCNRC_RF_DEC_MASK: ::kernel::sys::raw::c_uint = 16383;
pub const E1000_RTTBCNRC_RF_INT_SHIFT: ::kernel::sys::raw::c_uint = 14;
pub const E1000_RTTBCNRC_RF_INT_MASK: ::kernel::sys::raw::c_uint = 268419072;
pub const E1000_DMACR_DMACWT_MASK: ::kernel::sys::raw::c_uint = 16383;
pub const E1000_DMACR_DMACTHR_MASK: ::kernel::sys::raw::c_uint = 16711680;
pub const E1000_DMACR_DMACTHR_SHIFT: ::kernel::sys::raw::c_uint = 16;
pub const E1000_DMACR_DMAC_LX_MASK: ::kernel::sys::raw::c_uint = 805306368;
pub const E1000_DMACR_DMAC_LX_SHIFT: ::kernel::sys::raw::c_uint = 28;
pub const E1000_DMACR_DMAC_EN: ::kernel::sys::raw::c_uint = 2147483648;
pub const E1000_DMACR_DC_BMC2OSW_EN: ::kernel::sys::raw::c_uint = 32768;
pub const E1000_DMCTXTH_DMCTTHR_MASK: ::kernel::sys::raw::c_uint = 4095;
pub const E1000_DMCTLX_TTLX_MASK: ::kernel::sys::raw::c_uint = 4095;
pub const E1000_DMCRTRH_UTRESH_MASK: ::kernel::sys::raw::c_uint = 524287;
pub const E1000_DMCRTRH_LRPRCW: ::kernel::sys::raw::c_uint = 2147483648;
pub const E1000_DMCCNT_CCOUNT_MASK: ::kernel::sys::raw::c_uint = 33554431;
pub const E1000_FCRTC_RTH_COAL_MASK: ::kernel::sys::raw::c_uint = 262128;
pub const E1000_FCRTC_RTH_COAL_SHIFT: ::kernel::sys::raw::c_uint = 4;
pub const E1000_PCIEMISC_LX_DECISION: ::kernel::sys::raw::c_uint = 128;
pub const E1000_RXPBS_CFG_TS_EN: ::kernel::sys::raw::c_uint = 2147483648;
pub const E1000_RXPBS_SIZE_I210_MASK: ::kernel::sys::raw::c_uint = 63;
pub const E1000_TXPB0S_SIZE_I210_MASK: ::kernel::sys::raw::c_uint = 63;
pub const I210_RXPBSIZE_DEFAULT: ::kernel::sys::raw::c_uint = 162;
pub const I210_TXPBSIZE_DEFAULT: ::kernel::sys::raw::c_uint = 67108884;
pub const E1000_DOBFFCTL_OBFFTHR_MASK: ::kernel::sys::raw::c_uint = 255;
pub const E1000_DOBFFCTL_EXIT_ACT_MASK: ::kernel::sys::raw::c_uint = 16777216;
pub const E1000_PROXYFC_D0: ::kernel::sys::raw::c_uint = 1;
pub const E1000_PROXYFC_EX: ::kernel::sys::raw::c_uint = 4;
pub const E1000_PROXYFC_MC: ::kernel::sys::raw::c_uint = 8;
pub const E1000_PROXYFC_BC: ::kernel::sys::raw::c_uint = 16;
pub const E1000_PROXYFC_ARP_DIRECTED: ::kernel::sys::raw::c_uint = 32;
pub const E1000_PROXYFC_IPV4: ::kernel::sys::raw::c_uint = 64;
pub const E1000_PROXYFC_IPV6: ::kernel::sys::raw::c_uint = 128;
pub const E1000_PROXYFC_NS: ::kernel::sys::raw::c_uint = 512;
pub const E1000_PROXYFC_ARP: ::kernel::sys::raw::c_uint = 2048;
pub const E1000_PROXYS_CLEAR: ::kernel::sys::raw::c_uint = 4294967295;
pub const E1000_FWSTS_FWRI: ::kernel::sys::raw::c_uint = 2147483648;
pub const E1000_VTCTRL_RST: ::kernel::sys::raw::c_uint = 67108864;
pub const E1000_STATUS_LAN_ID_MASK: ::kernel::sys::raw::c_uint = 12;
pub const E1000_STATUS_LAN_ID_OFFSET: ::kernel::sys::raw::c_uint = 2;
pub const E1000_VFTA_ENTRIES: ::kernel::sys::raw::c_uint = 128;
pub const E1000_DEV_ID_82542: ::kernel::sys::raw::c_uint = 4096;
pub const E1000_DEV_ID_82543GC_FIBER: ::kernel::sys::raw::c_uint = 4097;
pub const E1000_DEV_ID_82543GC_COPPER: ::kernel::sys::raw::c_uint = 4100;
pub const E1000_DEV_ID_82544EI_COPPER: ::kernel::sys::raw::c_uint = 4104;
pub const E1000_DEV_ID_82544EI_FIBER: ::kernel::sys::raw::c_uint = 4105;
pub const E1000_DEV_ID_82544GC_COPPER: ::kernel::sys::raw::c_uint = 4108;
pub const E1000_DEV_ID_82544GC_LOM: ::kernel::sys::raw::c_uint = 4109;
pub const E1000_DEV_ID_82540EM: ::kernel::sys::raw::c_uint = 4110;
pub const E1000_DEV_ID_82540EM_LOM: ::kernel::sys::raw::c_uint = 4117;
pub const E1000_DEV_ID_82540EP_LOM: ::kernel::sys::raw::c_uint = 4118;
pub const E1000_DEV_ID_82540EP: ::kernel::sys::raw::c_uint = 4119;
pub const E1000_DEV_ID_82540EP_LP: ::kernel::sys::raw::c_uint = 4126;
pub const E1000_DEV_ID_82545EM_COPPER: ::kernel::sys::raw::c_uint = 4111;
pub const E1000_DEV_ID_82545EM_FIBER: ::kernel::sys::raw::c_uint = 4113;
pub const E1000_DEV_ID_82545GM_COPPER: ::kernel::sys::raw::c_uint = 4134;
pub const E1000_DEV_ID_82545GM_FIBER: ::kernel::sys::raw::c_uint = 4135;
pub const E1000_DEV_ID_82545GM_SERDES: ::kernel::sys::raw::c_uint = 4136;
pub const E1000_DEV_ID_82546EB_COPPER: ::kernel::sys::raw::c_uint = 4112;
pub const E1000_DEV_ID_82546EB_FIBER: ::kernel::sys::raw::c_uint = 4114;
pub const E1000_DEV_ID_82546EB_QUAD_COPPER: ::kernel::sys::raw::c_uint = 4125;
pub const E1000_DEV_ID_82546GB_COPPER: ::kernel::sys::raw::c_uint = 4217;
pub const E1000_DEV_ID_82546GB_FIBER: ::kernel::sys::raw::c_uint = 4218;
pub const E1000_DEV_ID_82546GB_SERDES: ::kernel::sys::raw::c_uint = 4219;
pub const E1000_DEV_ID_82546GB_PCIE: ::kernel::sys::raw::c_uint = 4234;
pub const E1000_DEV_ID_82546GB_QUAD_COPPER: ::kernel::sys::raw::c_uint = 4249;
pub const E1000_DEV_ID_82546GB_QUAD_COPPER_KSP3: ::kernel::sys::raw::c_uint =
    4277;
pub const E1000_DEV_ID_82541EI: ::kernel::sys::raw::c_uint = 4115;
pub const E1000_DEV_ID_82541EI_MOBILE: ::kernel::sys::raw::c_uint = 4120;
pub const E1000_DEV_ID_82541ER_LOM: ::kernel::sys::raw::c_uint = 4116;
pub const E1000_DEV_ID_82541ER: ::kernel::sys::raw::c_uint = 4216;
pub const E1000_DEV_ID_82541GI: ::kernel::sys::raw::c_uint = 4214;
pub const E1000_DEV_ID_82541GI_LF: ::kernel::sys::raw::c_uint = 4220;
pub const E1000_DEV_ID_82541GI_MOBILE: ::kernel::sys::raw::c_uint = 4215;
pub const E1000_DEV_ID_82547EI: ::kernel::sys::raw::c_uint = 4121;
pub const E1000_DEV_ID_82547EI_MOBILE: ::kernel::sys::raw::c_uint = 4122;
pub const E1000_DEV_ID_82547GI: ::kernel::sys::raw::c_uint = 4213;
pub const E1000_DEV_ID_82571EB_COPPER: ::kernel::sys::raw::c_uint = 4190;
pub const E1000_DEV_ID_82571EB_FIBER: ::kernel::sys::raw::c_uint = 4191;
pub const E1000_DEV_ID_82571EB_SERDES: ::kernel::sys::raw::c_uint = 4192;
pub const E1000_DEV_ID_82571EB_SERDES_DUAL: ::kernel::sys::raw::c_uint = 4313;
pub const E1000_DEV_ID_82571EB_SERDES_QUAD: ::kernel::sys::raw::c_uint = 4314;
pub const E1000_DEV_ID_82571EB_QUAD_COPPER: ::kernel::sys::raw::c_uint = 4260;
pub const E1000_DEV_ID_82571PT_QUAD_COPPER: ::kernel::sys::raw::c_uint = 4309;
pub const E1000_DEV_ID_82571EB_QUAD_FIBER: ::kernel::sys::raw::c_uint = 4261;
pub const E1000_DEV_ID_82571EB_QUAD_COPPER_LP: ::kernel::sys::raw::c_uint =
    4284;
pub const E1000_DEV_ID_82572EI_COPPER: ::kernel::sys::raw::c_uint = 4221;
pub const E1000_DEV_ID_82572EI_FIBER: ::kernel::sys::raw::c_uint = 4222;
pub const E1000_DEV_ID_82572EI_SERDES: ::kernel::sys::raw::c_uint = 4223;
pub const E1000_DEV_ID_82572EI: ::kernel::sys::raw::c_uint = 4281;
pub const E1000_DEV_ID_82573E: ::kernel::sys::raw::c_uint = 4235;
pub const E1000_DEV_ID_82573E_IAMT: ::kernel::sys::raw::c_uint = 4236;
pub const E1000_DEV_ID_82573L: ::kernel::sys::raw::c_uint = 4250;
pub const E1000_DEV_ID_82574L: ::kernel::sys::raw::c_uint = 4307;
pub const E1000_DEV_ID_82574LA: ::kernel::sys::raw::c_uint = 4342;
pub const E1000_DEV_ID_82583V: ::kernel::sys::raw::c_uint = 5388;
pub const E1000_DEV_ID_80003ES2LAN_COPPER_DPT: ::kernel::sys::raw::c_uint =
    4246;
pub const E1000_DEV_ID_80003ES2LAN_SERDES_DPT: ::kernel::sys::raw::c_uint =
    4248;
pub const E1000_DEV_ID_80003ES2LAN_COPPER_SPT: ::kernel::sys::raw::c_uint =
    4282;
pub const E1000_DEV_ID_80003ES2LAN_SERDES_SPT: ::kernel::sys::raw::c_uint =
    4283;
pub const E1000_DEV_ID_ICH8_82567V_3: ::kernel::sys::raw::c_uint = 5377;
pub const E1000_DEV_ID_ICH8_IGP_M_AMT: ::kernel::sys::raw::c_uint = 4169;
pub const E1000_DEV_ID_ICH8_IGP_AMT: ::kernel::sys::raw::c_uint = 4170;
pub const E1000_DEV_ID_ICH8_IGP_C: ::kernel::sys::raw::c_uint = 4171;
pub const E1000_DEV_ID_ICH8_IFE: ::kernel::sys::raw::c_uint = 4172;
pub const E1000_DEV_ID_ICH8_IFE_GT: ::kernel::sys::raw::c_uint = 4292;
pub const E1000_DEV_ID_ICH8_IFE_G: ::kernel::sys::raw::c_uint = 4293;
pub const E1000_DEV_ID_ICH8_IGP_M: ::kernel::sys::raw::c_uint = 4173;
pub const E1000_DEV_ID_ICH9_IGP_M: ::kernel::sys::raw::c_uint = 4287;
pub const E1000_DEV_ID_ICH9_IGP_M_AMT: ::kernel::sys::raw::c_uint = 4341;
pub const E1000_DEV_ID_ICH9_IGP_M_V: ::kernel::sys::raw::c_uint = 4299;
pub const E1000_DEV_ID_ICH9_IGP_AMT: ::kernel::sys::raw::c_uint = 4285;
pub const E1000_DEV_ID_ICH9_BM: ::kernel::sys::raw::c_uint = 4325;
pub const E1000_DEV_ID_ICH9_IGP_C: ::kernel::sys::raw::c_uint = 10572;
pub const E1000_DEV_ID_ICH9_IFE: ::kernel::sys::raw::c_uint = 4288;
pub const E1000_DEV_ID_ICH9_IFE_GT: ::kernel::sys::raw::c_uint = 4291;
pub const E1000_DEV_ID_ICH9_IFE_G: ::kernel::sys::raw::c_uint = 4290;
pub const E1000_DEV_ID_ICH10_R_BM_LM: ::kernel::sys::raw::c_uint = 4300;
pub const E1000_DEV_ID_ICH10_R_BM_LF: ::kernel::sys::raw::c_uint = 4301;
pub const E1000_DEV_ID_ICH10_R_BM_V: ::kernel::sys::raw::c_uint = 4302;
pub const E1000_DEV_ID_ICH10_D_BM_LM: ::kernel::sys::raw::c_uint = 4318;
pub const E1000_DEV_ID_ICH10_D_BM_LF: ::kernel::sys::raw::c_uint = 4319;
pub const E1000_DEV_ID_ICH10_D_BM_V: ::kernel::sys::raw::c_uint = 5413;
pub const E1000_DEV_ID_PCH_M_HV_LM: ::kernel::sys::raw::c_uint = 4330;
pub const E1000_DEV_ID_PCH_M_HV_LC: ::kernel::sys::raw::c_uint = 4331;
pub const E1000_DEV_ID_PCH_D_HV_DM: ::kernel::sys::raw::c_uint = 4335;
pub const E1000_DEV_ID_PCH_D_HV_DC: ::kernel::sys::raw::c_uint = 4336;
pub const E1000_DEV_ID_PCH2_LV_LM: ::kernel::sys::raw::c_uint = 5378;
pub const E1000_DEV_ID_PCH2_LV_V: ::kernel::sys::raw::c_uint = 5379;
pub const E1000_DEV_ID_PCH_LPT_I217_LM: ::kernel::sys::raw::c_uint = 5434;
pub const E1000_DEV_ID_PCH_LPT_I217_V: ::kernel::sys::raw::c_uint = 5435;
pub const E1000_DEV_ID_PCH_LPTLP_I218_LM: ::kernel::sys::raw::c_uint = 5466;
pub const E1000_DEV_ID_PCH_LPTLP_I218_V: ::kernel::sys::raw::c_uint = 5465;
pub const E1000_DEV_ID_PCH_I218_LM2: ::kernel::sys::raw::c_uint = 5536;
pub const E1000_DEV_ID_PCH_I218_V2: ::kernel::sys::raw::c_uint = 5537;
pub const E1000_DEV_ID_PCH_I218_LM3: ::kernel::sys::raw::c_uint = 5538;
pub const E1000_DEV_ID_PCH_I218_V3: ::kernel::sys::raw::c_uint = 5539;
pub const E1000_DEV_ID_PCH_SPT_I219_LM: ::kernel::sys::raw::c_uint = 5487;
pub const E1000_DEV_ID_PCH_SPT_I219_V: ::kernel::sys::raw::c_uint = 5488;
pub const E1000_DEV_ID_PCH_SPT_I219_LM2: ::kernel::sys::raw::c_uint = 5559;
pub const E1000_DEV_ID_PCH_SPT_I219_V2: ::kernel::sys::raw::c_uint = 5560;
pub const E1000_DEV_ID_PCH_LBG_I219_LM3: ::kernel::sys::raw::c_uint = 5561;
pub const E1000_DEV_ID_PCH_SPT_I219_LM4: ::kernel::sys::raw::c_uint = 5591;
pub const E1000_DEV_ID_PCH_SPT_I219_V4: ::kernel::sys::raw::c_uint = 5592;
pub const E1000_DEV_ID_PCH_SPT_I219_LM5: ::kernel::sys::raw::c_uint = 5603;
pub const E1000_DEV_ID_PCH_SPT_I219_V5: ::kernel::sys::raw::c_uint = 5590;
pub const E1000_DEV_ID_PCH_CNP_I219_LM6: ::kernel::sys::raw::c_uint = 5565;
pub const E1000_DEV_ID_PCH_CNP_I219_V6: ::kernel::sys::raw::c_uint = 5566;
pub const E1000_DEV_ID_PCH_CNP_I219_LM7: ::kernel::sys::raw::c_uint = 5563;
pub const E1000_DEV_ID_PCH_CNP_I219_V7: ::kernel::sys::raw::c_uint = 5564;
pub const E1000_DEV_ID_PCH_ICP_I219_LM8: ::kernel::sys::raw::c_uint = 5599;
pub const E1000_DEV_ID_PCH_ICP_I219_V8: ::kernel::sys::raw::c_uint = 5600;
pub const E1000_DEV_ID_PCH_ICP_I219_LM9: ::kernel::sys::raw::c_uint = 5601;
pub const E1000_DEV_ID_PCH_ICP_I219_V9: ::kernel::sys::raw::c_uint = 5602;
pub const E1000_DEV_ID_82576: ::kernel::sys::raw::c_uint = 4297;
pub const E1000_DEV_ID_82576_FIBER: ::kernel::sys::raw::c_uint = 4326;
pub const E1000_DEV_ID_82576_SERDES: ::kernel::sys::raw::c_uint = 4327;
pub const E1000_DEV_ID_82576_QUAD_COPPER: ::kernel::sys::raw::c_uint = 4328;
pub const E1000_DEV_ID_82576_QUAD_COPPER_ET2: ::kernel::sys::raw::c_uint =
    5414;
pub const E1000_DEV_ID_82576_NS: ::kernel::sys::raw::c_uint = 5386;
pub const E1000_DEV_ID_82576_NS_SERDES: ::kernel::sys::raw::c_uint = 5400;
pub const E1000_DEV_ID_82576_SERDES_QUAD: ::kernel::sys::raw::c_uint = 5389;
pub const E1000_DEV_ID_82576_VF: ::kernel::sys::raw::c_uint = 4298;
pub const E1000_DEV_ID_82576_VF_HV: ::kernel::sys::raw::c_uint = 5421;
pub const E1000_DEV_ID_I350_VF: ::kernel::sys::raw::c_uint = 5408;
pub const E1000_DEV_ID_I350_VF_HV: ::kernel::sys::raw::c_uint = 5423;
pub const E1000_DEV_ID_82575EB_COPPER: ::kernel::sys::raw::c_uint = 4263;
pub const E1000_DEV_ID_82575EB_FIBER_SERDES: ::kernel::sys::raw::c_uint =
    4265;
pub const E1000_DEV_ID_82575GB_QUAD_COPPER: ::kernel::sys::raw::c_uint = 4310;
pub const E1000_DEV_ID_82580_COPPER: ::kernel::sys::raw::c_uint = 5390;
pub const E1000_DEV_ID_82580_FIBER: ::kernel::sys::raw::c_uint = 5391;
pub const E1000_DEV_ID_82580_SERDES: ::kernel::sys::raw::c_uint = 5392;
pub const E1000_DEV_ID_82580_SGMII: ::kernel::sys::raw::c_uint = 5393;
pub const E1000_DEV_ID_82580_COPPER_DUAL: ::kernel::sys::raw::c_uint = 5398;
pub const E1000_DEV_ID_82580_QUAD_FIBER: ::kernel::sys::raw::c_uint = 5415;
pub const E1000_DEV_ID_I350_COPPER: ::kernel::sys::raw::c_uint = 5409;
pub const E1000_DEV_ID_I350_FIBER: ::kernel::sys::raw::c_uint = 5410;
pub const E1000_DEV_ID_I350_SERDES: ::kernel::sys::raw::c_uint = 5411;
pub const E1000_DEV_ID_I350_SGMII: ::kernel::sys::raw::c_uint = 5412;
pub const E1000_DEV_ID_I350_DA4: ::kernel::sys::raw::c_uint = 5446;
pub const E1000_DEV_ID_I210_COPPER: ::kernel::sys::raw::c_uint = 5427;
pub const E1000_DEV_ID_I210_COPPER_OEM1: ::kernel::sys::raw::c_uint = 5428;
pub const E1000_DEV_ID_I210_COPPER_IT: ::kernel::sys::raw::c_uint = 5429;
pub const E1000_DEV_ID_I210_FIBER: ::kernel::sys::raw::c_uint = 5430;
pub const E1000_DEV_ID_I210_SERDES: ::kernel::sys::raw::c_uint = 5431;
pub const E1000_DEV_ID_I210_SGMII: ::kernel::sys::raw::c_uint = 5432;
pub const E1000_DEV_ID_I210_COPPER_FLASHLESS: ::kernel::sys::raw::c_uint =
    5499;
pub const E1000_DEV_ID_I210_SERDES_FLASHLESS: ::kernel::sys::raw::c_uint =
    5500;
pub const E1000_DEV_ID_I211_COPPER: ::kernel::sys::raw::c_uint = 5433;
pub const E1000_DEV_ID_I354_BACKPLANE_1GBPS: ::kernel::sys::raw::c_uint =
    8000;
pub const E1000_DEV_ID_I354_SGMII: ::kernel::sys::raw::c_uint = 8001;
pub const E1000_DEV_ID_I354_BACKPLANE_2_5GBPS: ::kernel::sys::raw::c_uint =
    8005;
pub const E1000_DEV_ID_DH89XXCC_SGMII: ::kernel::sys::raw::c_uint = 1080;
pub const E1000_DEV_ID_DH89XXCC_SERDES: ::kernel::sys::raw::c_uint = 1082;
pub const E1000_DEV_ID_DH89XXCC_BACKPLANE: ::kernel::sys::raw::c_uint = 1084;
pub const E1000_DEV_ID_DH89XXCC_SFP: ::kernel::sys::raw::c_uint = 1088;
pub const E1000_REVISION_0: ::kernel::sys::raw::c_uint = 0;
pub const E1000_REVISION_1: ::kernel::sys::raw::c_uint = 1;
pub const E1000_REVISION_2: ::kernel::sys::raw::c_uint = 2;
pub const E1000_REVISION_3: ::kernel::sys::raw::c_uint = 3;
pub const E1000_REVISION_4: ::kernel::sys::raw::c_uint = 4;
pub const E1000_FUNC_0: ::kernel::sys::raw::c_uint = 0;
pub const E1000_FUNC_1: ::kernel::sys::raw::c_uint = 1;
pub const E1000_FUNC_2: ::kernel::sys::raw::c_uint = 2;
pub const E1000_FUNC_3: ::kernel::sys::raw::c_uint = 3;
pub const E1000_ALT_MAC_ADDRESS_OFFSET_LAN0: ::kernel::sys::raw::c_uint = 0;
pub const E1000_ALT_MAC_ADDRESS_OFFSET_LAN1: ::kernel::sys::raw::c_uint = 3;
pub const E1000_ALT_MAC_ADDRESS_OFFSET_LAN2: ::kernel::sys::raw::c_uint = 6;
pub const E1000_ALT_MAC_ADDRESS_OFFSET_LAN3: ::kernel::sys::raw::c_uint = 9;
pub const MAX_PS_BUFFERS: ::kernel::sys::raw::c_uint = 4;
pub const PS_PAGE_BUFFERS: ::kernel::sys::raw::c_uint = 3;
pub const E1000_HI_MAX_DATA_LENGTH: ::kernel::sys::raw::c_uint = 252;
pub const E1000_HI_MAX_MNG_DATA_LENGTH: ::kernel::sys::raw::c_uint = 1784;
pub const E1000_MAX_PHY_ADDR: ::kernel::sys::raw::c_uint = 8;
pub const IGP01E1000_PHY_PORT_CONFIG: ::kernel::sys::raw::c_uint = 16;
pub const IGP01E1000_PHY_PORT_STATUS: ::kernel::sys::raw::c_uint = 17;
pub const IGP01E1000_PHY_PORT_CTRL: ::kernel::sys::raw::c_uint = 18;
pub const IGP01E1000_PHY_LINK_HEALTH: ::kernel::sys::raw::c_uint = 19;
pub const IGP01E1000_GMII_FIFO: ::kernel::sys::raw::c_uint = 20;
pub const IGP02E1000_PHY_POWER_MGMT: ::kernel::sys::raw::c_uint = 25;
pub const IGP01E1000_PHY_PAGE_SELECT: ::kernel::sys::raw::c_uint = 31;
pub const BM_PHY_PAGE_SELECT: ::kernel::sys::raw::c_uint = 22;
pub const IGP_PAGE_SHIFT: ::kernel::sys::raw::c_uint = 5;
pub const PHY_REG_MASK: ::kernel::sys::raw::c_uint = 31;
pub const GS40G_PAGE_SELECT: ::kernel::sys::raw::c_uint = 22;
pub const GS40G_PAGE_SHIFT: ::kernel::sys::raw::c_uint = 16;
pub const GS40G_OFFSET_MASK: ::kernel::sys::raw::c_uint = 65535;
pub const GS40G_PAGE_2: ::kernel::sys::raw::c_uint = 131072;
pub const GS40G_MAC_REG2: ::kernel::sys::raw::c_uint = 21;
pub const GS40G_MAC_LB: ::kernel::sys::raw::c_uint = 16704;
pub const GS40G_COPPER_SPEC: ::kernel::sys::raw::c_uint = 16;
pub const BM_PORT_CTRL_PAGE: ::kernel::sys::raw::c_uint = 769;
pub const BM_WUC_PAGE: ::kernel::sys::raw::c_uint = 800;
pub const BM_WUC_ADDRESS_OPCODE: ::kernel::sys::raw::c_uint = 17;
pub const BM_WUC_DATA_OPCODE: ::kernel::sys::raw::c_uint = 18;
pub const BM_WUC_ENABLE_PAGE: ::kernel::sys::raw::c_uint = 769;
pub const BM_WUC_ENABLE_REG: ::kernel::sys::raw::c_uint = 17;
pub const BM_WUC_ENABLE_BIT: ::kernel::sys::raw::c_uint = 4;
pub const BM_WUC_HOST_WU_BIT: ::kernel::sys::raw::c_uint = 16;
pub const BM_WUC_ME_WU_BIT: ::kernel::sys::raw::c_uint = 32;
pub const PHY_UPPER_SHIFT: ::kernel::sys::raw::c_uint = 21;
pub const HV_INTC_FC_PAGE_START: ::kernel::sys::raw::c_uint = 768;
pub const I82578_ADDR_REG: ::kernel::sys::raw::c_uint = 29;
pub const I82577_ADDR_REG: ::kernel::sys::raw::c_uint = 16;
pub const I82577_CFG_REG: ::kernel::sys::raw::c_uint = 22;
pub const I82577_CFG_ASSERT_CRS_ON_TX: ::kernel::sys::raw::c_uint = 32768;
pub const I82577_CFG_ENABLE_DOWNSHIFT: ::kernel::sys::raw::c_uint = 3072;
pub const I82577_CTRL_REG: ::kernel::sys::raw::c_uint = 23;
pub const I82577_PHY_CTRL_2: ::kernel::sys::raw::c_uint = 18;
pub const I82577_PHY_LBK_CTRL: ::kernel::sys::raw::c_uint = 19;
pub const I82577_PHY_STATUS_2: ::kernel::sys::raw::c_uint = 26;
pub const I82577_PHY_DIAG_STATUS: ::kernel::sys::raw::c_uint = 31;
pub const I82577_PHY_STATUS2_REV_POLARITY: ::kernel::sys::raw::c_uint = 1024;
pub const I82577_PHY_STATUS2_MDIX: ::kernel::sys::raw::c_uint = 2048;
pub const I82577_PHY_STATUS2_SPEED_MASK: ::kernel::sys::raw::c_uint = 768;
pub const I82577_PHY_STATUS2_SPEED_1000MBPS: ::kernel::sys::raw::c_uint = 512;
pub const I82577_PHY_CTRL2_MANUAL_MDIX: ::kernel::sys::raw::c_uint = 512;
pub const I82577_PHY_CTRL2_AUTO_MDI_MDIX: ::kernel::sys::raw::c_uint = 1024;
pub const I82577_PHY_CTRL2_MDIX_CFG_MASK: ::kernel::sys::raw::c_uint = 1536;
pub const I82577_DSTATUS_CABLE_LENGTH: ::kernel::sys::raw::c_uint = 1020;
pub const I82577_DSTATUS_CABLE_LENGTH_SHIFT: ::kernel::sys::raw::c_uint = 2;
pub const E1000_82580_PHY_POWER_MGMT: ::kernel::sys::raw::c_uint = 3604;
pub const E1000_82580_PM_SPD: ::kernel::sys::raw::c_uint = 1;
pub const E1000_82580_PM_D0_LPLU: ::kernel::sys::raw::c_uint = 2;
pub const E1000_82580_PM_D3_LPLU: ::kernel::sys::raw::c_uint = 4;
pub const E1000_82580_PM_GO_LINKD: ::kernel::sys::raw::c_uint = 32;
pub const E1000_MPHY_DIS_ACCESS: ::kernel::sys::raw::c_uint = 2147483648;
pub const E1000_MPHY_ENA_ACCESS: ::kernel::sys::raw::c_uint = 1073741824;
pub const E1000_MPHY_BUSY: ::kernel::sys::raw::c_uint = 65536;
pub const E1000_MPHY_ADDRESS_FNC_OVERRIDE: ::kernel::sys::raw::c_uint =
    536870912;
pub const E1000_MPHY_ADDRESS_MASK: ::kernel::sys::raw::c_uint = 65535;
pub const BM_CS_CTRL1: ::kernel::sys::raw::c_uint = 16;
pub const BM_CS_STATUS: ::kernel::sys::raw::c_uint = 17;
pub const BM_CS_STATUS_LINK_UP: ::kernel::sys::raw::c_uint = 1024;
pub const BM_CS_STATUS_RESOLVED: ::kernel::sys::raw::c_uint = 2048;
pub const BM_CS_STATUS_SPEED_MASK: ::kernel::sys::raw::c_uint = 49152;
pub const BM_CS_STATUS_SPEED_1000: ::kernel::sys::raw::c_uint = 32768;
pub const HV_M_STATUS: ::kernel::sys::raw::c_uint = 26;
pub const HV_M_STATUS_AUTONEG_COMPLETE: ::kernel::sys::raw::c_uint = 4096;
pub const HV_M_STATUS_SPEED_MASK: ::kernel::sys::raw::c_uint = 768;
pub const HV_M_STATUS_SPEED_1000: ::kernel::sys::raw::c_uint = 512;
pub const HV_M_STATUS_SPEED_100: ::kernel::sys::raw::c_uint = 256;
pub const HV_M_STATUS_LINK_UP: ::kernel::sys::raw::c_uint = 64;
pub const IGP01E1000_PHY_PCS_INIT_REG: ::kernel::sys::raw::c_uint = 180;
pub const IGP01E1000_PHY_POLARITY_MASK: ::kernel::sys::raw::c_uint = 120;
pub const IGP01E1000_PSCR_AUTO_MDIX: ::kernel::sys::raw::c_uint = 4096;
pub const IGP01E1000_PSCR_FORCE_MDI_MDIX: ::kernel::sys::raw::c_uint = 8192;
pub const IGP01E1000_PSCFR_SMART_SPEED: ::kernel::sys::raw::c_uint = 128;
pub const IGP01E1000_GMII_FLEX_SPD: ::kernel::sys::raw::c_uint = 16;
pub const IGP01E1000_GMII_SPD: ::kernel::sys::raw::c_uint = 32;
pub const IGP02E1000_PM_SPD: ::kernel::sys::raw::c_uint = 1;
pub const IGP02E1000_PM_D0_LPLU: ::kernel::sys::raw::c_uint = 2;
pub const IGP02E1000_PM_D3_LPLU: ::kernel::sys::raw::c_uint = 4;
pub const IGP01E1000_PLHR_SS_DOWNGRADE: ::kernel::sys::raw::c_uint = 32768;
pub const IGP01E1000_PSSR_POLARITY_REVERSED: ::kernel::sys::raw::c_uint = 2;
pub const IGP01E1000_PSSR_MDIX: ::kernel::sys::raw::c_uint = 2048;
pub const IGP01E1000_PSSR_SPEED_MASK: ::kernel::sys::raw::c_uint = 49152;
pub const IGP01E1000_PSSR_SPEED_1000MBPS: ::kernel::sys::raw::c_uint = 49152;
pub const IGP02E1000_PHY_CHANNEL_NUM: ::kernel::sys::raw::c_uint = 4;
pub const IGP02E1000_PHY_AGC_A: ::kernel::sys::raw::c_uint = 4529;
pub const IGP02E1000_PHY_AGC_B: ::kernel::sys::raw::c_uint = 4785;
pub const IGP02E1000_PHY_AGC_C: ::kernel::sys::raw::c_uint = 5297;
pub const IGP02E1000_PHY_AGC_D: ::kernel::sys::raw::c_uint = 6321;
pub const IGP02E1000_AGC_LENGTH_SHIFT: ::kernel::sys::raw::c_uint = 9;
pub const IGP02E1000_AGC_LENGTH_MASK: ::kernel::sys::raw::c_uint = 127;
pub const IGP02E1000_AGC_RANGE: ::kernel::sys::raw::c_uint = 15;
pub const E1000_CABLE_LENGTH_UNDEFINED: ::kernel::sys::raw::c_uint = 255;
pub const E1000_KMRNCTRLSTA_OFFSET: ::kernel::sys::raw::c_uint = 2031616;
pub const E1000_KMRNCTRLSTA_OFFSET_SHIFT: ::kernel::sys::raw::c_uint = 16;
pub const E1000_KMRNCTRLSTA_REN: ::kernel::sys::raw::c_uint = 2097152;
pub const E1000_KMRNCTRLSTA_CTRL_OFFSET: ::kernel::sys::raw::c_uint = 1;
pub const E1000_KMRNCTRLSTA_DIAG_OFFSET: ::kernel::sys::raw::c_uint = 3;
pub const E1000_KMRNCTRLSTA_TIMEOUTS: ::kernel::sys::raw::c_uint = 4;
pub const E1000_KMRNCTRLSTA_INBAND_PARAM: ::kernel::sys::raw::c_uint = 9;
pub const E1000_KMRNCTRLSTA_IBIST_DISABLE: ::kernel::sys::raw::c_uint = 512;
pub const E1000_KMRNCTRLSTA_DIAG_NELPBK: ::kernel::sys::raw::c_uint = 4096;
pub const E1000_KMRNCTRLSTA_K1_CONFIG: ::kernel::sys::raw::c_uint = 7;
pub const E1000_KMRNCTRLSTA_K1_ENABLE: ::kernel::sys::raw::c_uint = 2;
pub const E1000_KMRNCTRLSTA_HD_CTRL: ::kernel::sys::raw::c_uint = 16;
pub const IFE_PHY_EXTENDED_STATUS_CONTROL: ::kernel::sys::raw::c_uint = 16;
pub const IFE_PHY_SPECIAL_CONTROL: ::kernel::sys::raw::c_uint = 17;
pub const IFE_PHY_SPECIAL_CONTROL_LED: ::kernel::sys::raw::c_uint = 27;
pub const IFE_PHY_MDIX_CONTROL: ::kernel::sys::raw::c_uint = 28;
pub const IFE_PESC_POLARITY_REVERSED: ::kernel::sys::raw::c_uint = 256;
pub const IFE_PSC_AUTO_POLARITY_DISABLE: ::kernel::sys::raw::c_uint = 16;
pub const IFE_PSC_FORCE_POLARITY: ::kernel::sys::raw::c_uint = 32;
pub const IFE_PSCL_PROBE_MODE: ::kernel::sys::raw::c_uint = 32;
pub const IFE_PSCL_PROBE_LEDS_OFF: ::kernel::sys::raw::c_uint = 6;
pub const IFE_PSCL_PROBE_LEDS_ON: ::kernel::sys::raw::c_uint = 7;
pub const IFE_PMC_MDIX_STATUS: ::kernel::sys::raw::c_uint = 32;
pub const IFE_PMC_FORCE_MDIX: ::kernel::sys::raw::c_uint = 64;
pub const IFE_PMC_AUTO_MDIX: ::kernel::sys::raw::c_uint = 128;
pub const E1000_SFF_IDENTIFIER_OFFSET: ::kernel::sys::raw::c_uint = 0;
pub const E1000_SFF_IDENTIFIER_SFF: ::kernel::sys::raw::c_uint = 2;
pub const E1000_SFF_IDENTIFIER_SFP: ::kernel::sys::raw::c_uint = 3;
pub const E1000_SFF_ETH_FLAGS_OFFSET: ::kernel::sys::raw::c_uint = 6;
pub const E1000_SFF_VENDOR_OUI_TYCO: ::kernel::sys::raw::c_uint = 4224512;
pub const E1000_SFF_VENDOR_OUI_FTL: ::kernel::sys::raw::c_uint = 9463040;
pub const E1000_SFF_VENDOR_OUI_AVAGO: ::kernel::sys::raw::c_uint = 1534464;
pub const E1000_SFF_VENDOR_OUI_INTEL: ::kernel::sys::raw::c_uint = 1777920;
pub const E1000_STM_OPCODE: ::kernel::sys::raw::c_uint = 56064;
pub const E1000_FACTPS_MNGCG: ::kernel::sys::raw::c_uint = 536870912;
pub const E1000_FWSM_MODE_MASK: ::kernel::sys::raw::c_uint = 14;
pub const E1000_FWSM_MODE_SHIFT: ::kernel::sys::raw::c_uint = 1;
pub const E1000_FWSM_FW_VALID: ::kernel::sys::raw::c_uint = 32768;
pub const E1000_FWSM_HI_EN_ONLY_MODE: ::kernel::sys::raw::c_uint = 4;
pub const E1000_MNG_IAMT_MODE: ::kernel::sys::raw::c_uint = 3;
pub const E1000_MNG_DHCP_COOKIE_LENGTH: ::kernel::sys::raw::c_uint = 16;
pub const E1000_MNG_DHCP_COOKIE_OFFSET: ::kernel::sys::raw::c_uint = 1776;
pub const E1000_MNG_DHCP_COMMAND_TIMEOUT: ::kernel::sys::raw::c_uint = 10;
pub const E1000_MNG_DHCP_TX_PAYLOAD_CMD: ::kernel::sys::raw::c_uint = 64;
pub const E1000_MNG_DHCP_COOKIE_STATUS_PARSING: ::kernel::sys::raw::c_uint =
    1;
pub const E1000_MNG_DHCP_COOKIE_STATUS_VLAN: ::kernel::sys::raw::c_uint = 2;
pub const E1000_VFTA_ENTRY_SHIFT: ::kernel::sys::raw::c_uint = 5;
pub const E1000_VFTA_ENTRY_MASK: ::kernel::sys::raw::c_uint = 127;
pub const E1000_VFTA_ENTRY_BIT_SHIFT_MASK: ::kernel::sys::raw::c_uint = 31;
pub const E1000_HI_MAX_BLOCK_BYTE_LENGTH: ::kernel::sys::raw::c_uint = 1792;
pub const E1000_HI_MAX_BLOCK_DWORD_LENGTH: ::kernel::sys::raw::c_uint = 448;
pub const E1000_HI_COMMAND_TIMEOUT: ::kernel::sys::raw::c_uint = 500;
pub const E1000_HI_FW_BASE_ADDRESS: ::kernel::sys::raw::c_uint = 65536;
pub const E1000_HI_FW_MAX_LENGTH: ::kernel::sys::raw::c_uint = 65536;
pub const E1000_HI_FW_BLOCK_DWORD_LENGTH: ::kernel::sys::raw::c_uint = 256;
pub const E1000_HICR_MEMORY_BASE_EN: ::kernel::sys::raw::c_uint = 512;
pub const E1000_HICR_EN: ::kernel::sys::raw::c_uint = 1;
pub const E1000_HICR_C: ::kernel::sys::raw::c_uint = 2;
pub const E1000_HICR_SV: ::kernel::sys::raw::c_uint = 4;
pub const E1000_HICR_FW_RESET_ENABLE: ::kernel::sys::raw::c_uint = 64;
pub const E1000_HICR_FW_RESET: ::kernel::sys::raw::c_uint = 128;
pub const E1000_IAMT_SIGNATURE: ::kernel::sys::raw::c_uint = 1414349129;
pub const E1000_V2PMAILBOX_REQ: ::kernel::sys::raw::c_uint = 1;
pub const E1000_V2PMAILBOX_ACK: ::kernel::sys::raw::c_uint = 2;
pub const E1000_V2PMAILBOX_VFU: ::kernel::sys::raw::c_uint = 4;
pub const E1000_V2PMAILBOX_PFU: ::kernel::sys::raw::c_uint = 8;
pub const E1000_V2PMAILBOX_PFSTS: ::kernel::sys::raw::c_uint = 16;
pub const E1000_V2PMAILBOX_PFACK: ::kernel::sys::raw::c_uint = 32;
pub const E1000_V2PMAILBOX_RSTI: ::kernel::sys::raw::c_uint = 64;
pub const E1000_V2PMAILBOX_RSTD: ::kernel::sys::raw::c_uint = 128;
pub const E1000_V2PMAILBOX_R2C_BITS: ::kernel::sys::raw::c_uint = 176;
pub const E1000_P2VMAILBOX_STS: ::kernel::sys::raw::c_uint = 1;
pub const E1000_P2VMAILBOX_ACK: ::kernel::sys::raw::c_uint = 2;
pub const E1000_P2VMAILBOX_VFU: ::kernel::sys::raw::c_uint = 4;
pub const E1000_P2VMAILBOX_PFU: ::kernel::sys::raw::c_uint = 8;
pub const E1000_P2VMAILBOX_RVFU: ::kernel::sys::raw::c_uint = 16;
pub const E1000_MBVFICR_VFREQ_MASK: ::kernel::sys::raw::c_uint = 255;
pub const E1000_MBVFICR_VFREQ_VF1: ::kernel::sys::raw::c_uint = 1;
pub const E1000_MBVFICR_VFACK_MASK: ::kernel::sys::raw::c_uint = 16711680;
pub const E1000_MBVFICR_VFACK_VF1: ::kernel::sys::raw::c_uint = 65536;
pub const E1000_VFMAILBOX_SIZE: ::kernel::sys::raw::c_uint = 16;
pub const E1000_VT_MSGTYPE_ACK: ::kernel::sys::raw::c_uint = 2147483648;
pub const E1000_VT_MSGTYPE_NACK: ::kernel::sys::raw::c_uint = 1073741824;
pub const E1000_VT_MSGTYPE_CTS: ::kernel::sys::raw::c_uint = 536870912;
pub const E1000_VT_MSGINFO_SHIFT: ::kernel::sys::raw::c_uint = 16;
pub const E1000_VT_MSGINFO_MASK: ::kernel::sys::raw::c_uint = 16711680;
pub const E1000_VF_RESET: ::kernel::sys::raw::c_uint = 1;
pub const E1000_VF_SET_MAC_ADDR: ::kernel::sys::raw::c_uint = 2;
pub const E1000_VF_SET_MULTICAST: ::kernel::sys::raw::c_uint = 3;
pub const E1000_VF_SET_MULTICAST_COUNT_MASK: ::kernel::sys::raw::c_uint =
    2031616;
pub const E1000_VF_SET_MULTICAST_OVERFLOW: ::kernel::sys::raw::c_uint =
    8388608;
pub const E1000_VF_SET_VLAN: ::kernel::sys::raw::c_uint = 4;
pub const E1000_VF_SET_VLAN_ADD: ::kernel::sys::raw::c_uint = 65536;
pub const E1000_VF_SET_LPE: ::kernel::sys::raw::c_uint = 5;
pub const E1000_VF_SET_PROMISC: ::kernel::sys::raw::c_uint = 6;
pub const E1000_VF_SET_PROMISC_UNICAST: ::kernel::sys::raw::c_uint = 65536;
pub const E1000_VF_SET_PROMISC_MULTICAST: ::kernel::sys::raw::c_uint = 131072;
pub const E1000_PF_CONTROL_MSG: ::kernel::sys::raw::c_uint = 256;
pub const E1000_VF_MBX_INIT_TIMEOUT: ::kernel::sys::raw::c_uint = 2000;
pub const E1000_VF_MBX_INIT_DELAY: ::kernel::sys::raw::c_uint = 500;
pub const MAX_MTA_REG: ::kernel::sys::raw::c_uint = 128;
pub const E1000_SHADOW_RAM_WORDS: ::kernel::sys::raw::c_uint = 2048;
pub const NVM_WORD_SIZE_BASE_SHIFT_82541: ::kernel::sys::raw::c_uint = 7;
pub const IGP01E1000_PHY_CHANNEL_NUM: ::kernel::sys::raw::c_uint = 4;
pub const IGP01E1000_PHY_AGC_A: ::kernel::sys::raw::c_uint = 4466;
pub const IGP01E1000_PHY_AGC_B: ::kernel::sys::raw::c_uint = 4722;
pub const IGP01E1000_PHY_AGC_C: ::kernel::sys::raw::c_uint = 5234;
pub const IGP01E1000_PHY_AGC_D: ::kernel::sys::raw::c_uint = 6258;
pub const IGP01E1000_PHY_AGC_PARAM_A: ::kernel::sys::raw::c_uint = 4465;
pub const IGP01E1000_PHY_AGC_PARAM_B: ::kernel::sys::raw::c_uint = 4721;
pub const IGP01E1000_PHY_AGC_PARAM_C: ::kernel::sys::raw::c_uint = 5233;
pub const IGP01E1000_PHY_AGC_PARAM_D: ::kernel::sys::raw::c_uint = 6257;
pub const IGP01E1000_PHY_EDAC_MU_INDEX: ::kernel::sys::raw::c_uint = 49152;
pub const IGP01E1000_PHY_EDAC_SIGN_EXT_9_BITS: ::kernel::sys::raw::c_uint =
    32768;
pub const IGP01E1000_PHY_DSP_RESET: ::kernel::sys::raw::c_uint = 7987;
pub const IGP01E1000_PHY_DSP_FFE: ::kernel::sys::raw::c_uint = 7989;
pub const IGP01E1000_PHY_DSP_FFE_CM_CP: ::kernel::sys::raw::c_uint = 105;
pub const IGP01E1000_PHY_DSP_FFE_DEFAULT: ::kernel::sys::raw::c_uint = 42;
pub const IGP01E1000_IEEE_FORCE_GIG: ::kernel::sys::raw::c_uint = 320;
pub const IGP01E1000_IEEE_RESTART_AUTONEG: ::kernel::sys::raw::c_uint = 13056;
pub const IGP01E1000_AGC_LENGTH_SHIFT: ::kernel::sys::raw::c_uint = 7;
pub const IGP01E1000_AGC_RANGE: ::kernel::sys::raw::c_uint = 10;
pub const FFE_IDLE_ERR_COUNT_TIMEOUT_20: ::kernel::sys::raw::c_uint = 20;
pub const FFE_IDLE_ERR_COUNT_TIMEOUT_100: ::kernel::sys::raw::c_uint = 100;
pub const IGP01E1000_ANALOG_FUSE_STATUS: ::kernel::sys::raw::c_uint = 8400;
pub const IGP01E1000_ANALOG_SPARE_FUSE_STATUS: ::kernel::sys::raw::c_uint =
    8401;
pub const IGP01E1000_ANALOG_FUSE_CONTROL: ::kernel::sys::raw::c_uint = 8412;
pub const IGP01E1000_ANALOG_FUSE_BYPASS: ::kernel::sys::raw::c_uint = 8414;
pub const IGP01E1000_ANALOG_SPARE_FUSE_ENABLED: ::kernel::sys::raw::c_uint =
    256;
pub const IGP01E1000_ANALOG_FUSE_FINE_MASK: ::kernel::sys::raw::c_uint = 3968;
pub const IGP01E1000_ANALOG_FUSE_COARSE_MASK: ::kernel::sys::raw::c_uint =
    112;
pub const IGP01E1000_ANALOG_FUSE_COARSE_THRESH: ::kernel::sys::raw::c_uint =
    64;
pub const IGP01E1000_ANALOG_FUSE_COARSE_10: ::kernel::sys::raw::c_uint = 16;
pub const IGP01E1000_ANALOG_FUSE_FINE_1: ::kernel::sys::raw::c_uint = 128;
pub const IGP01E1000_ANALOG_FUSE_FINE_10: ::kernel::sys::raw::c_uint = 1280;
pub const IGP01E1000_ANALOG_FUSE_POLY_MASK: ::kernel::sys::raw::c_uint =
    61440;
pub const IGP01E1000_ANALOG_FUSE_ENABLE_SW_CONTROL: ::kernel::sys::raw::c_uint
          =
    2;
pub const IGP01E1000_MSE_CHANNEL_D: ::kernel::sys::raw::c_uint = 15;
pub const IGP01E1000_MSE_CHANNEL_C: ::kernel::sys::raw::c_uint = 240;
pub const IGP01E1000_MSE_CHANNEL_B: ::kernel::sys::raw::c_uint = 3840;
pub const IGP01E1000_MSE_CHANNEL_A: ::kernel::sys::raw::c_uint = 61440;
pub const PHY_PREAMBLE: ::kernel::sys::raw::c_uint = 4294967295;
pub const PHY_PREAMBLE_SIZE: ::kernel::sys::raw::c_uint = 32;
pub const PHY_SOF: ::kernel::sys::raw::c_uint = 1;
pub const PHY_OP_READ: ::kernel::sys::raw::c_uint = 2;
pub const PHY_OP_WRITE: ::kernel::sys::raw::c_uint = 1;
pub const PHY_TURNAROUND: ::kernel::sys::raw::c_uint = 2;
pub const TBI_COMPAT_ENABLED: ::kernel::sys::raw::c_uint = 1;
pub const TBI_SBP_ENABLED: ::kernel::sys::raw::c_uint = 2;
pub const ID_LED_RESERVED_F746: ::kernel::sys::raw::c_uint = 63302;
pub const ID_LED_DEFAULT_82573: ::kernel::sys::raw::c_uint = 6161;
pub const E1000_GCR_L1_ACT_WITHOUT_L0S_RX: ::kernel::sys::raw::c_uint =
    134217728;
pub const AN_RETRY_COUNT: ::kernel::sys::raw::c_uint = 5;
pub const E1000_EIAC_82574: ::kernel::sys::raw::c_uint = 220;
pub const E1000_EIAC_MASK_82574: ::kernel::sys::raw::c_uint = 32505856;
pub const E1000_IVAR_INT_ALLOC_VALID: ::kernel::sys::raw::c_uint = 8;
pub const E1000_NVM_INIT_CTRL2_MNGM: ::kernel::sys::raw::c_uint = 24576;
pub const E1000_BASE1000T_STATUS: ::kernel::sys::raw::c_uint = 10;
pub const E1000_IDLE_ERROR_COUNT_MASK: ::kernel::sys::raw::c_uint = 255;
pub const E1000_RECEIVE_ERROR_COUNTER: ::kernel::sys::raw::c_uint = 21;
pub const E1000_RECEIVE_ERROR_MAX: ::kernel::sys::raw::c_uint = 65535;
pub const E1000_KMRNCTRLSTA_OFFSET_FIFO_CTRL: ::kernel::sys::raw::c_uint = 0;
pub const E1000_KMRNCTRLSTA_OFFSET_INB_CTRL: ::kernel::sys::raw::c_uint = 2;
pub const E1000_KMRNCTRLSTA_OFFSET_HD_CTRL: ::kernel::sys::raw::c_uint = 16;
pub const E1000_KMRNCTRLSTA_OFFSET_MAC2PHY_OPMODE: ::kernel::sys::raw::c_uint
          =
    31;
pub const E1000_KMRNCTRLSTA_FIFO_CTRL_RX_BYPASS: ::kernel::sys::raw::c_uint =
    8;
pub const E1000_KMRNCTRLSTA_FIFO_CTRL_TX_BYPASS: ::kernel::sys::raw::c_uint =
    2048;
pub const E1000_KMRNCTRLSTA_INB_CTRL_DIS_PADDING: ::kernel::sys::raw::c_uint =
    16;
pub const E1000_KMRNCTRLSTA_HD_CTRL_10_100_DEFAULT: ::kernel::sys::raw::c_uint
          =
    4;
pub const E1000_KMRNCTRLSTA_HD_CTRL_1000_DEFAULT: ::kernel::sys::raw::c_uint =
    0;
pub const E1000_KMRNCTRLSTA_OPMODE_E_IDLE: ::kernel::sys::raw::c_uint = 8192;
pub const E1000_KMRNCTRLSTA_OPMODE_MASK: ::kernel::sys::raw::c_uint = 12;
pub const E1000_KMRNCTRLSTA_OPMODE_INBAND_MDIO: ::kernel::sys::raw::c_uint =
    4;
pub const E1000_TCTL_EXT_GCEX_MASK: ::kernel::sys::raw::c_uint = 1047552;
pub const DEFAULT_TCTL_EXT_GCEX_80003ES2LAN: ::kernel::sys::raw::c_uint =
    65536;
pub const DEFAULT_TIPG_IPGT_1000_80003ES2LAN: ::kernel::sys::raw::c_uint = 8;
pub const DEFAULT_TIPG_IPGT_10_100_80003ES2LAN: ::kernel::sys::raw::c_uint =
    9;
pub const GG82563_PSCR_POLARITY_REVERSAL_DISABLE: ::kernel::sys::raw::c_uint =
    2;
pub const GG82563_PSCR_CROSSOVER_MODE_MASK: ::kernel::sys::raw::c_uint = 96;
pub const GG82563_PSCR_CROSSOVER_MODE_MDI: ::kernel::sys::raw::c_uint = 0;
pub const GG82563_PSCR_CROSSOVER_MODE_MDIX: ::kernel::sys::raw::c_uint = 32;
pub const GG82563_PSCR_CROSSOVER_MODE_AUTO: ::kernel::sys::raw::c_uint = 96;
pub const GG82563_PSCR2_REVERSE_AUTO_NEG: ::kernel::sys::raw::c_uint = 8192;
pub const GG82563_MSCR_TX_CLK_MASK: ::kernel::sys::raw::c_uint = 7;
pub const GG82563_MSCR_TX_CLK_10MBPS_2_5: ::kernel::sys::raw::c_uint = 4;
pub const GG82563_MSCR_TX_CLK_100MBPS_25: ::kernel::sys::raw::c_uint = 5;
pub const GG82563_MSCR_TX_CLK_1000MBPS_25: ::kernel::sys::raw::c_uint = 7;
pub const GG82563_MSCR_ASSERT_CRS_ON_TX: ::kernel::sys::raw::c_uint = 16;
pub const GG82563_DSPD_CABLE_LENGTH: ::kernel::sys::raw::c_uint = 7;
pub const GG82563_KMCR_PASS_FALSE_CARRIER: ::kernel::sys::raw::c_uint = 2048;
pub const GG82563_MAX_KMRN_RETRY: ::kernel::sys::raw::c_uint = 5;
pub const GG82563_PMCR_ENABLE_ELECTRICAL_IDLE: ::kernel::sys::raw::c_uint = 1;
pub const GG82563_ICR_DIS_PADDING: ::kernel::sys::raw::c_uint = 16;
pub const ICH_FLASH_GFPREG: ::kernel::sys::raw::c_uint = 0;
pub const ICH_FLASH_HSFSTS: ::kernel::sys::raw::c_uint = 4;
pub const ICH_FLASH_HSFCTL: ::kernel::sys::raw::c_uint = 6;
pub const ICH_FLASH_FADDR: ::kernel::sys::raw::c_uint = 8;
pub const ICH_FLASH_FDATA0: ::kernel::sys::raw::c_uint = 16;
pub const ICH_FLASH_READ_COMMAND_TIMEOUT: ::kernel::sys::raw::c_uint =
    10000000;
pub const ICH_FLASH_WRITE_COMMAND_TIMEOUT: ::kernel::sys::raw::c_uint =
    10000000;
pub const ICH_FLASH_ERASE_COMMAND_TIMEOUT: ::kernel::sys::raw::c_uint =
    10000000;
pub const ICH_FLASH_LINEAR_ADDR_MASK: ::kernel::sys::raw::c_uint = 16777215;
pub const ICH_FLASH_CYCLE_REPEAT_COUNT: ::kernel::sys::raw::c_uint = 10;
pub const ICH_CYCLE_READ: ::kernel::sys::raw::c_uint = 0;
pub const ICH_CYCLE_WRITE: ::kernel::sys::raw::c_uint = 2;
pub const ICH_CYCLE_ERASE: ::kernel::sys::raw::c_uint = 3;
pub const FLASH_GFPREG_BASE_MASK: ::kernel::sys::raw::c_uint = 8191;
pub const FLASH_SECTOR_ADDR_SHIFT: ::kernel::sys::raw::c_uint = 12;
pub const ICH_FLASH_SEG_SIZE_256: ::kernel::sys::raw::c_uint = 256;
pub const ICH_FLASH_SEG_SIZE_4K: ::kernel::sys::raw::c_uint = 4096;
pub const ICH_FLASH_SEG_SIZE_8K: ::kernel::sys::raw::c_uint = 8192;
pub const ICH_FLASH_SEG_SIZE_64K: ::kernel::sys::raw::c_uint = 65536;
pub const E1000_ICH_FWSM_RSPCIPHY: ::kernel::sys::raw::c_uint = 64;
pub const E1000_ICH_FWSM_FW_VALID: ::kernel::sys::raw::c_uint = 32768;
pub const E1000_ICH_FWSM_PCIM2PCI: ::kernel::sys::raw::c_uint = 16777216;
pub const E1000_ICH_FWSM_PCIM2PCI_COUNT: ::kernel::sys::raw::c_uint = 2000;
pub const E1000_ICH_MNG_IAMT_MODE: ::kernel::sys::raw::c_uint = 2;
pub const E1000_FWSM_WLOCK_MAC_MASK: ::kernel::sys::raw::c_uint = 896;
pub const E1000_FWSM_WLOCK_MAC_SHIFT: ::kernel::sys::raw::c_uint = 7;
pub const E1000_FWSM_ULP_CFG_DONE: ::kernel::sys::raw::c_uint = 1024;
pub const E1000_H2ME: ::kernel::sys::raw::c_uint = 23376;
pub const E1000_H2ME_ULP: ::kernel::sys::raw::c_uint = 2048;
pub const E1000_H2ME_ENFORCE_SETTINGS: ::kernel::sys::raw::c_uint = 4096;
pub const ID_LED_DEFAULT_ICH8LAN: ::kernel::sys::raw::c_uint = 6529;
pub const E1000_ICH_NVM_SIG_WORD: ::kernel::sys::raw::c_uint = 19;
pub const E1000_ICH_NVM_SIG_MASK: ::kernel::sys::raw::c_uint = 49152;
pub const E1000_ICH_NVM_VALID_SIG_MASK: ::kernel::sys::raw::c_uint = 192;
pub const E1000_ICH_NVM_SIG_VALUE: ::kernel::sys::raw::c_uint = 128;
pub const E1000_ICH8_LAN_INIT_TIMEOUT: ::kernel::sys::raw::c_uint = 1500;
pub const E1000_FEXT_PHY_CABLE_DISCONNECTED: ::kernel::sys::raw::c_uint = 4;
pub const E1000_FEXTNVM_SW_CONFIG: ::kernel::sys::raw::c_uint = 1;
pub const E1000_FEXTNVM_SW_CONFIG_ICH8M: ::kernel::sys::raw::c_uint =
    134217728;
pub const E1000_FEXTNVM3_PHY_CFG_COUNTER_MASK: ::kernel::sys::raw::c_uint =
    201326592;
pub const E1000_FEXTNVM3_PHY_CFG_COUNTER_50MSEC: ::kernel::sys::raw::c_uint =
    134217728;
pub const E1000_FEXTNVM4_BEACON_DURATION_MASK: ::kernel::sys::raw::c_uint = 7;
pub const E1000_FEXTNVM4_BEACON_DURATION_8USEC: ::kernel::sys::raw::c_uint =
    7;
pub const E1000_FEXTNVM4_BEACON_DURATION_16USEC: ::kernel::sys::raw::c_uint =
    3;
pub const E1000_FEXTNVM6_REQ_PLL_CLK: ::kernel::sys::raw::c_uint = 256;
pub const E1000_FEXTNVM6_ENABLE_K1_ENTRY_CONDITION: ::kernel::sys::raw::c_uint
          =
    512;
pub const E1000_FEXTNVM6_K1_OFF_ENABLE: ::kernel::sys::raw::c_uint =
    2147483648;
pub const E1000_FEXTNVM7_DISABLE_PB_READ: ::kernel::sys::raw::c_uint = 262144;
pub const E1000_FEXTNVM7_SIDE_CLK_UNGATE: ::kernel::sys::raw::c_uint = 4;
pub const E1000_FEXTNVM7_DISABLE_SMB_PERST: ::kernel::sys::raw::c_uint = 32;
pub const E1000_FEXTNVM9_IOSFSB_CLKGATE_DIS: ::kernel::sys::raw::c_uint =
    2048;
pub const E1000_FEXTNVM9_IOSFSB_CLKREQ_DIS: ::kernel::sys::raw::c_uint = 4096;
pub const E1000_FEXTNVM11_DISABLE_PB_READ: ::kernel::sys::raw::c_uint = 512;
pub const E1000_FEXTNVM11_DISABLE_MULR_FIX: ::kernel::sys::raw::c_uint = 8192;
pub const E1000_RXDCTL_THRESH_UNIT_DESC: ::kernel::sys::raw::c_uint =
    16777216;
pub const NVM_SIZE_MULTIPLIER: ::kernel::sys::raw::c_uint = 4096;
pub const E1000_FLASH_BASE_ADDR: ::kernel::sys::raw::c_uint = 57344;
pub const E1000_CTRL_EXT_NVMVS: ::kernel::sys::raw::c_uint = 3;
pub const E1000_TARC0_CB_MULTIQ_3_REQ: ::kernel::sys::raw::c_uint = 805306368;
pub const E1000_TARC0_CB_MULTIQ_2_REQ: ::kernel::sys::raw::c_uint = 536870912;
pub const PCIE_ICH8_SNOOP_ALL: ::kernel::sys::raw::c_uint = 63;
pub const E1000_ICH_RAR_ENTRIES: ::kernel::sys::raw::c_uint = 7;
pub const E1000_PCH2_RAR_ENTRIES: ::kernel::sys::raw::c_uint = 5;
pub const E1000_PCH_LPT_RAR_ENTRIES: ::kernel::sys::raw::c_uint = 12;
pub const PHY_PAGE_SHIFT: ::kernel::sys::raw::c_uint = 5;
pub const IGP3_KMRN_DIAG_PCS_LOCK_LOSS: ::kernel::sys::raw::c_uint = 2;
pub const IGP3_VR_CTRL_DEV_POWERDOWN_MODE_MASK: ::kernel::sys::raw::c_uint =
    768;
pub const IGP3_VR_CTRL_MODE_SHUTDOWN: ::kernel::sys::raw::c_uint = 512;
pub const BM_RCTL_UPE: ::kernel::sys::raw::c_uint = 1;
pub const BM_RCTL_MPE: ::kernel::sys::raw::c_uint = 2;
pub const BM_RCTL_MO_SHIFT: ::kernel::sys::raw::c_uint = 3;
pub const BM_RCTL_MO_MASK: ::kernel::sys::raw::c_uint = 24;
pub const BM_RCTL_BAM: ::kernel::sys::raw::c_uint = 32;
pub const BM_RCTL_PMCF: ::kernel::sys::raw::c_uint = 64;
pub const BM_RCTL_RFCE: ::kernel::sys::raw::c_uint = 128;
pub const HV_MUX_DATA_CTRL_GEN_TO_MAC: ::kernel::sys::raw::c_uint = 1024;
pub const HV_MUX_DATA_CTRL_FORCE_SPEED: ::kernel::sys::raw::c_uint = 4;
pub const HV_STATS_PAGE: ::kernel::sys::raw::c_uint = 778;
pub const E1000_FCRTV_PCH: ::kernel::sys::raw::c_uint = 24384;
pub const E1000_NVM_K1_CONFIG: ::kernel::sys::raw::c_uint = 27;
pub const E1000_NVM_K1_ENABLE: ::kernel::sys::raw::c_uint = 1;
pub const K1_ENTRY_LATENCY: ::kernel::sys::raw::c_uint = 0;
pub const K1_MIN_TIME: ::kernel::sys::raw::c_uint = 1;
pub const CV_SMB_CTRL_FORCE_SMBUS: ::kernel::sys::raw::c_uint = 1;
pub const I218_ULP_CONFIG1_START: ::kernel::sys::raw::c_uint = 1;
pub const I218_ULP_CONFIG1_IND: ::kernel::sys::raw::c_uint = 4;
pub const I218_ULP_CONFIG1_STICKY_ULP: ::kernel::sys::raw::c_uint = 16;
pub const I218_ULP_CONFIG1_INBAND_EXIT: ::kernel::sys::raw::c_uint = 32;
pub const I218_ULP_CONFIG1_WOL_HOST: ::kernel::sys::raw::c_uint = 64;
pub const I218_ULP_CONFIG1_RESET_TO_SMBUS: ::kernel::sys::raw::c_uint = 256;
pub const I218_ULP_CONFIG1_EN_ULP_LANPHYPC: ::kernel::sys::raw::c_uint = 1024;
pub const I218_ULP_CONFIG1_DIS_CLR_STICKY_ON_PERST: ::kernel::sys::raw::c_uint
          =
    2048;
pub const I218_ULP_CONFIG1_DISABLE_SMB_PERST: ::kernel::sys::raw::c_uint =
    4096;
pub const HV_SMB_ADDR_MASK: ::kernel::sys::raw::c_uint = 127;
pub const HV_SMB_ADDR_PEC_EN: ::kernel::sys::raw::c_uint = 512;
pub const HV_SMB_ADDR_VALID: ::kernel::sys::raw::c_uint = 128;
pub const HV_SMB_ADDR_FREQ_MASK: ::kernel::sys::raw::c_uint = 4352;
pub const HV_SMB_ADDR_FREQ_LOW_SHIFT: ::kernel::sys::raw::c_uint = 8;
pub const HV_SMB_ADDR_FREQ_HIGH_SHIFT: ::kernel::sys::raw::c_uint = 12;
pub const E1000_STRAP: ::kernel::sys::raw::c_uint = 12;
pub const E1000_STRAP_SMBUS_ADDRESS_MASK: ::kernel::sys::raw::c_uint =
    16646144;
pub const E1000_STRAP_SMBUS_ADDRESS_SHIFT: ::kernel::sys::raw::c_uint = 17;
pub const E1000_STRAP_SMT_FREQ_MASK: ::kernel::sys::raw::c_uint = 12288;
pub const E1000_STRAP_SMT_FREQ_SHIFT: ::kernel::sys::raw::c_uint = 12;
pub const HV_OEM_BITS_LPLU: ::kernel::sys::raw::c_uint = 4;
pub const HV_OEM_BITS_GBE_DIS: ::kernel::sys::raw::c_uint = 64;
pub const HV_OEM_BITS_RESTART_AN: ::kernel::sys::raw::c_uint = 1024;
pub const HV_KMRN_MDIO_SLOW: ::kernel::sys::raw::c_uint = 1024;
pub const HV_KMRN_FIFO_CTRLSTA_PREAMBLE_MASK: ::kernel::sys::raw::c_uint =
    28672;
pub const HV_KMRN_FIFO_CTRLSTA_PREAMBLE_SHIFT: ::kernel::sys::raw::c_uint =
    12;
pub const HV_PM_CTRL_K1_CLK_REQ: ::kernel::sys::raw::c_uint = 512;
pub const HV_PM_CTRL_K1_ENABLE: ::kernel::sys::raw::c_uint = 16384;
pub const I217_PLL_CLOCK_GATE_MASK: ::kernel::sys::raw::c_uint = 2047;
pub const SW_FLAG_TIMEOUT: ::kernel::sys::raw::c_uint = 1000;
pub const I217_INBAND_CTRL_LINK_STAT_TX_TIMEOUT_MASK:
          ::kernel::sys::raw::c_uint =
    16128;
pub const I217_INBAND_CTRL_LINK_STAT_TX_TIMEOUT_SHIFT:
          ::kernel::sys::raw::c_uint =
    8;
pub const I217_LPI_GPIO_CTRL_AUTO_EN_LPI: ::kernel::sys::raw::c_uint = 2048;
pub const I82579_LPI_CTRL_100_ENABLE: ::kernel::sys::raw::c_uint = 8192;
pub const I82579_LPI_CTRL_1000_ENABLE: ::kernel::sys::raw::c_uint = 16384;
pub const I82579_LPI_CTRL_ENABLE_MASK: ::kernel::sys::raw::c_uint = 24576;
pub const I82579_DFT_CTRL_GATE_PHY_RESET: ::kernel::sys::raw::c_uint = 64;
pub const I82579_EMI_ADDR: ::kernel::sys::raw::c_uint = 16;
pub const I82579_EMI_DATA: ::kernel::sys::raw::c_uint = 17;
pub const I82579_LPI_UPDATE_TIMER: ::kernel::sys::raw::c_uint = 18437;
pub const I82579_MSE_THRESHOLD: ::kernel::sys::raw::c_uint = 2127;
pub const I82577_MSE_THRESHOLD: ::kernel::sys::raw::c_uint = 2183;
pub const I82579_MSE_LINK_DOWN: ::kernel::sys::raw::c_uint = 9233;
pub const I82579_RX_CONFIG: ::kernel::sys::raw::c_uint = 13330;
pub const I82579_LPI_PLL_SHUT: ::kernel::sys::raw::c_uint = 17426;
pub const I82579_EEE_PCS_STATUS: ::kernel::sys::raw::c_uint = 6190;
pub const I82579_EEE_CAPABILITY: ::kernel::sys::raw::c_uint = 1040;
pub const I82579_EEE_ADVERTISEMENT: ::kernel::sys::raw::c_uint = 1038;
pub const I82579_EEE_LP_ABILITY: ::kernel::sys::raw::c_uint = 1039;
pub const I82579_EEE_100_SUPPORTED: ::kernel::sys::raw::c_uint = 2;
pub const I82579_EEE_1000_SUPPORTED: ::kernel::sys::raw::c_uint = 4;
pub const I82579_LPI_100_PLL_SHUT: ::kernel::sys::raw::c_uint = 4;
pub const I217_EEE_PCS_STATUS: ::kernel::sys::raw::c_uint = 37889;
pub const I217_EEE_CAPABILITY: ::kernel::sys::raw::c_uint = 32768;
pub const I217_EEE_ADVERTISEMENT: ::kernel::sys::raw::c_uint = 32769;
pub const I217_EEE_LP_ABILITY: ::kernel::sys::raw::c_uint = 32770;
pub const I217_RX_CONFIG: ::kernel::sys::raw::c_uint = 45580;
pub const E1000_EEE_RX_LPI_RCVD: ::kernel::sys::raw::c_uint = 1024;
pub const E1000_EEE_TX_LPI_RCVD: ::kernel::sys::raw::c_uint = 2048;
pub const I217_PROXY_CTRL_AUTO_DISABLE: ::kernel::sys::raw::c_uint = 128;
pub const I217_SxCTRL_ENABLE_LPI_RESET: ::kernel::sys::raw::c_uint = 4096;
pub const I217_CGFREG_ENABLE_MTA_RESET: ::kernel::sys::raw::c_uint = 2;
pub const I217_MEMPWR_DISABLE_SMB_RELEASE: ::kernel::sys::raw::c_uint = 16;
pub const E1000_LTRV: ::kernel::sys::raw::c_uint = 248;
pub const E1000_LTRV_VALUE_MASK: ::kernel::sys::raw::c_uint = 1023;
pub const E1000_LTRV_SCALE_MAX: ::kernel::sys::raw::c_uint = 5;
pub const E1000_LTRV_SCALE_FACTOR: ::kernel::sys::raw::c_uint = 5;
pub const E1000_LTRV_SCALE_SHIFT: ::kernel::sys::raw::c_uint = 10;
pub const E1000_LTRV_SCALE_MASK: ::kernel::sys::raw::c_uint = 7168;
pub const E1000_LTRV_REQ_SHIFT: ::kernel::sys::raw::c_uint = 15;
pub const E1000_LTRV_NOSNOOP_SHIFT: ::kernel::sys::raw::c_uint = 16;
pub const E1000_LTRV_SEND: ::kernel::sys::raw::c_uint = 1073741824;
pub const E1000_PCI_LTR_CAP_LPT: ::kernel::sys::raw::c_uint = 168;
pub const E1000_SVCR_OFF_EN: ::kernel::sys::raw::c_uint = 1;
pub const E1000_SVCR_OFF_MASKINT: ::kernel::sys::raw::c_uint = 4096;
pub const E1000_SVCR_OFF_TIMER_MASK: ::kernel::sys::raw::c_uint = 4294901760;
pub const E1000_SVCR_OFF_TIMER_SHIFT: ::kernel::sys::raw::c_uint = 16;
pub const E1000_SVT_OFF_HWM_MASK: ::kernel::sys::raw::c_uint = 31;
pub const ID_LED_DEFAULT_82575_SERDES: ::kernel::sys::raw::c_uint = 4376;
pub const E1000_RAR_ENTRIES_82575: ::kernel::sys::raw::c_uint = 16;
pub const E1000_RAR_ENTRIES_82576: ::kernel::sys::raw::c_uint = 24;
pub const E1000_RAR_ENTRIES_82580: ::kernel::sys::raw::c_uint = 24;
pub const E1000_RAR_ENTRIES_I350: ::kernel::sys::raw::c_uint = 32;
pub const E1000_SW_SYNCH_MB: ::kernel::sys::raw::c_uint = 256;
pub const E1000_STAT_DEV_RST_SET: ::kernel::sys::raw::c_uint = 1048576;
pub const E1000_CTRL_DEV_RST: ::kernel::sys::raw::c_uint = 536870912;
pub const E1000_SRRCTL_BSIZEPKT_SHIFT: ::kernel::sys::raw::c_uint = 10;
pub const E1000_SRRCTL_BSIZEHDRSIZE_MASK: ::kernel::sys::raw::c_uint = 3840;
pub const E1000_SRRCTL_BSIZEHDRSIZE_SHIFT: ::kernel::sys::raw::c_uint = 2;
pub const E1000_SRRCTL_DESCTYPE_LEGACY: ::kernel::sys::raw::c_uint = 0;
pub const E1000_SRRCTL_DESCTYPE_ADV_ONEBUF: ::kernel::sys::raw::c_uint =
    33554432;
pub const E1000_SRRCTL_DESCTYPE_HDR_SPLIT: ::kernel::sys::raw::c_uint =
    67108864;
pub const E1000_SRRCTL_DESCTYPE_HDR_SPLIT_ALWAYS: ::kernel::sys::raw::c_uint =
    167772160;
pub const E1000_SRRCTL_DESCTYPE_HDR_REPLICATION: ::kernel::sys::raw::c_uint =
    100663296;
pub const E1000_SRRCTL_DESCTYPE_HDR_REPLICATION_LARGE_PKT:
          ::kernel::sys::raw::c_uint =
    134217728;
pub const E1000_SRRCTL_DESCTYPE_MASK: ::kernel::sys::raw::c_uint = 234881024;
pub const E1000_SRRCTL_TIMESTAMP: ::kernel::sys::raw::c_uint = 1073741824;
pub const E1000_SRRCTL_DROP_EN: ::kernel::sys::raw::c_uint = 2147483648;
pub const E1000_SRRCTL_BSIZEPKT_MASK: ::kernel::sys::raw::c_uint = 127;
pub const E1000_SRRCTL_BSIZEHDR_MASK: ::kernel::sys::raw::c_uint = 16128;
pub const E1000_TX_HEAD_WB_ENABLE: ::kernel::sys::raw::c_uint = 1;
pub const E1000_TX_SEQNUM_WB_ENABLE: ::kernel::sys::raw::c_uint = 2;
pub const E1000_MRQC_ENABLE_RSS_4Q: ::kernel::sys::raw::c_uint = 2;
pub const E1000_MRQC_ENABLE_VMDQ: ::kernel::sys::raw::c_uint = 3;
pub const E1000_MRQC_ENABLE_VMDQ_RSS_2Q: ::kernel::sys::raw::c_uint = 5;
pub const E1000_MRQC_RSS_FIELD_IPV4_UDP: ::kernel::sys::raw::c_uint = 4194304;
pub const E1000_MRQC_RSS_FIELD_IPV6_UDP: ::kernel::sys::raw::c_uint = 8388608;
pub const E1000_MRQC_RSS_FIELD_IPV6_UDP_EX: ::kernel::sys::raw::c_uint =
    16777216;
pub const E1000_MRQC_ENABLE_RSS_8Q: ::kernel::sys::raw::c_uint = 2;
pub const E1000_VMRCTL_MIRROR_PORT_SHIFT: ::kernel::sys::raw::c_uint = 8;
pub const E1000_VMRCTL_MIRROR_DSTPORT_MASK: ::kernel::sys::raw::c_uint = 1792;
pub const E1000_VMRCTL_POOL_MIRROR_ENABLE: ::kernel::sys::raw::c_uint = 1;
pub const E1000_VMRCTL_UPLINK_MIRROR_ENABLE: ::kernel::sys::raw::c_uint = 2;
pub const E1000_VMRCTL_DOWNLINK_MIRROR_ENABLE: ::kernel::sys::raw::c_uint = 4;
pub const E1000_EICR_TX_QUEUE: ::kernel::sys::raw::c_uint = 3840;
pub const E1000_EICR_RX_QUEUE: ::kernel::sys::raw::c_uint = 15;
pub const E1000_EIMS_RX_QUEUE: ::kernel::sys::raw::c_uint = 15;
pub const E1000_EIMS_TX_QUEUE: ::kernel::sys::raw::c_uint = 3840;
pub const EIMS_ENABLE_MASK: ::kernel::sys::raw::c_uint = 3221229327;
pub const E1000_IMIR_PORT_IM_EN: ::kernel::sys::raw::c_uint = 65536;
pub const E1000_IMIR_PORT_BP: ::kernel::sys::raw::c_uint = 131072;
pub const E1000_IMIREXT_SIZE_BP: ::kernel::sys::raw::c_uint = 4096;
pub const E1000_IMIREXT_CTRL_URG: ::kernel::sys::raw::c_uint = 8192;
pub const E1000_IMIREXT_CTRL_ACK: ::kernel::sys::raw::c_uint = 16384;
pub const E1000_IMIREXT_CTRL_PSH: ::kernel::sys::raw::c_uint = 32768;
pub const E1000_IMIREXT_CTRL_RST: ::kernel::sys::raw::c_uint = 65536;
pub const E1000_IMIREXT_CTRL_SYN: ::kernel::sys::raw::c_uint = 131072;
pub const E1000_IMIREXT_CTRL_FIN: ::kernel::sys::raw::c_uint = 262144;
pub const E1000_IMIREXT_CTRL_BP: ::kernel::sys::raw::c_uint = 524288;
pub const E1000_RXDADV_RSSTYPE_MASK: ::kernel::sys::raw::c_uint = 15;
pub const E1000_RXDADV_RSSTYPE_SHIFT: ::kernel::sys::raw::c_uint = 12;
pub const E1000_RXDADV_HDRBUFLEN_MASK: ::kernel::sys::raw::c_uint = 32736;
pub const E1000_RXDADV_HDRBUFLEN_SHIFT: ::kernel::sys::raw::c_uint = 5;
pub const E1000_RXDADV_SPLITHEADER_EN: ::kernel::sys::raw::c_uint = 4096;
pub const E1000_RXDADV_SPH: ::kernel::sys::raw::c_uint = 32768;
pub const E1000_RXDADV_STAT_TS: ::kernel::sys::raw::c_uint = 65536;
pub const E1000_RXDADV_STAT_TSIP: ::kernel::sys::raw::c_uint = 32768;
pub const E1000_RXDADV_ERR_HBO: ::kernel::sys::raw::c_uint = 8388608;
pub const E1000_RXDADV_RSSTYPE_NONE: ::kernel::sys::raw::c_uint = 0;
pub const E1000_RXDADV_RSSTYPE_IPV4_TCP: ::kernel::sys::raw::c_uint = 1;
pub const E1000_RXDADV_RSSTYPE_IPV4: ::kernel::sys::raw::c_uint = 2;
pub const E1000_RXDADV_RSSTYPE_IPV6_TCP: ::kernel::sys::raw::c_uint = 3;
pub const E1000_RXDADV_RSSTYPE_IPV6_EX: ::kernel::sys::raw::c_uint = 4;
pub const E1000_RXDADV_RSSTYPE_IPV6: ::kernel::sys::raw::c_uint = 5;
pub const E1000_RXDADV_RSSTYPE_IPV6_TCP_EX: ::kernel::sys::raw::c_uint = 6;
pub const E1000_RXDADV_RSSTYPE_IPV4_UDP: ::kernel::sys::raw::c_uint = 7;
pub const E1000_RXDADV_RSSTYPE_IPV6_UDP: ::kernel::sys::raw::c_uint = 8;
pub const E1000_RXDADV_RSSTYPE_IPV6_UDP_EX: ::kernel::sys::raw::c_uint = 9;
pub const E1000_RXDADV_PKTTYPE_ILMASK: ::kernel::sys::raw::c_uint = 240;
pub const E1000_RXDADV_PKTTYPE_TLMASK: ::kernel::sys::raw::c_uint = 3840;
pub const E1000_RXDADV_PKTTYPE_NONE: ::kernel::sys::raw::c_uint = 0;
pub const E1000_RXDADV_PKTTYPE_IPV4: ::kernel::sys::raw::c_uint = 16;
pub const E1000_RXDADV_PKTTYPE_IPV4_EX: ::kernel::sys::raw::c_uint = 32;
pub const E1000_RXDADV_PKTTYPE_IPV6: ::kernel::sys::raw::c_uint = 64;
pub const E1000_RXDADV_PKTTYPE_IPV6_EX: ::kernel::sys::raw::c_uint = 128;
pub const E1000_RXDADV_PKTTYPE_TCP: ::kernel::sys::raw::c_uint = 256;
pub const E1000_RXDADV_PKTTYPE_UDP: ::kernel::sys::raw::c_uint = 512;
pub const E1000_RXDADV_PKTTYPE_SCTP: ::kernel::sys::raw::c_uint = 1024;
pub const E1000_RXDADV_PKTTYPE_NFS: ::kernel::sys::raw::c_uint = 2048;
pub const E1000_RXDADV_PKTTYPE_IPSEC_ESP: ::kernel::sys::raw::c_uint = 4096;
pub const E1000_RXDADV_PKTTYPE_IPSEC_AH: ::kernel::sys::raw::c_uint = 8192;
pub const E1000_RXDADV_PKTTYPE_LINKSEC: ::kernel::sys::raw::c_uint = 16384;
pub const E1000_RXDADV_PKTTYPE_ETQF: ::kernel::sys::raw::c_uint = 32768;
pub const E1000_RXDADV_PKTTYPE_ETQF_MASK: ::kernel::sys::raw::c_uint = 112;
pub const E1000_RXDADV_PKTTYPE_ETQF_SHIFT: ::kernel::sys::raw::c_uint = 4;
pub const E1000_RXDADV_LNKSEC_STATUS_SECP: ::kernel::sys::raw::c_uint =
    131072;
pub const E1000_RXDADV_LNKSEC_ERROR_BIT_MASK: ::kernel::sys::raw::c_uint =
    402653184;
pub const E1000_RXDADV_LNKSEC_ERROR_NO_SA_MATCH: ::kernel::sys::raw::c_uint =
    134217728;
pub const E1000_RXDADV_LNKSEC_ERROR_REPLAY_ERROR: ::kernel::sys::raw::c_uint =
    268435456;
pub const E1000_RXDADV_LNKSEC_ERROR_BAD_SIG: ::kernel::sys::raw::c_uint =
    402653184;
pub const E1000_RXDADV_IPSEC_STATUS_SECP: ::kernel::sys::raw::c_uint = 131072;
pub const E1000_RXDADV_IPSEC_ERROR_BIT_MASK: ::kernel::sys::raw::c_uint =
    402653184;
pub const E1000_RXDADV_IPSEC_ERROR_INVALID_PROTOCOL:
          ::kernel::sys::raw::c_uint =
    134217728;
pub const E1000_RXDADV_IPSEC_ERROR_INVALID_LENGTH: ::kernel::sys::raw::c_uint
          =
    268435456;
pub const E1000_RXDADV_IPSEC_ERROR_AUTHENTICATION_FAILED:
          ::kernel::sys::raw::c_uint =
    402653184;
pub const E1000_ADVTXD_DTYP_CTXT: ::kernel::sys::raw::c_uint = 2097152;
pub const E1000_ADVTXD_DTYP_DATA: ::kernel::sys::raw::c_uint = 3145728;
pub const E1000_ADVTXD_DCMD_EOP: ::kernel::sys::raw::c_uint = 16777216;
pub const E1000_ADVTXD_DCMD_IFCS: ::kernel::sys::raw::c_uint = 33554432;
pub const E1000_ADVTXD_DCMD_RS: ::kernel::sys::raw::c_uint = 134217728;
pub const E1000_ADVTXD_DCMD_DDTYP_ISCSI: ::kernel::sys::raw::c_uint =
    268435456;
pub const E1000_ADVTXD_DCMD_DEXT: ::kernel::sys::raw::c_uint = 536870912;
pub const E1000_ADVTXD_DCMD_VLE: ::kernel::sys::raw::c_uint = 1073741824;
pub const E1000_ADVTXD_DCMD_TSE: ::kernel::sys::raw::c_uint = 2147483648;
pub const E1000_ADVTXD_MAC_LINKSEC: ::kernel::sys::raw::c_uint = 262144;
pub const E1000_ADVTXD_MAC_TSTAMP: ::kernel::sys::raw::c_uint = 524288;
pub const E1000_ADVTXD_STAT_SN_CRC: ::kernel::sys::raw::c_uint = 2;
pub const E1000_ADVTXD_IDX_SHIFT: ::kernel::sys::raw::c_uint = 4;
pub const E1000_ADVTXD_POPTS_ISCO_1ST: ::kernel::sys::raw::c_uint = 0;
pub const E1000_ADVTXD_POPTS_ISCO_MDL: ::kernel::sys::raw::c_uint = 2048;
pub const E1000_ADVTXD_POPTS_ISCO_LAST: ::kernel::sys::raw::c_uint = 4096;
pub const E1000_ADVTXD_POPTS_ISCO_FULL: ::kernel::sys::raw::c_uint = 6144;
pub const E1000_ADVTXD_POPTS_IPSEC: ::kernel::sys::raw::c_uint = 1024;
pub const E1000_ADVTXD_PAYLEN_SHIFT: ::kernel::sys::raw::c_uint = 14;
pub const E1000_ADVTXD_MACLEN_SHIFT: ::kernel::sys::raw::c_uint = 9;
pub const E1000_ADVTXD_VLAN_SHIFT: ::kernel::sys::raw::c_uint = 16;
pub const E1000_ADVTXD_TUCMD_IPV4: ::kernel::sys::raw::c_uint = 1024;
pub const E1000_ADVTXD_TUCMD_IPV6: ::kernel::sys::raw::c_uint = 0;
pub const E1000_ADVTXD_TUCMD_L4T_UDP: ::kernel::sys::raw::c_uint = 0;
pub const E1000_ADVTXD_TUCMD_L4T_TCP: ::kernel::sys::raw::c_uint = 2048;
pub const E1000_ADVTXD_TUCMD_L4T_SCTP: ::kernel::sys::raw::c_uint = 4096;
pub const E1000_ADVTXD_TUCMD_IPSEC_TYPE_ESP: ::kernel::sys::raw::c_uint =
    8192;
pub const E1000_ADVTXD_TUCMD_IPSEC_ENCRYPT_EN: ::kernel::sys::raw::c_uint =
    16384;
pub const E1000_ADVTXD_TUCMD_MKRREQ: ::kernel::sys::raw::c_uint = 8192;
pub const E1000_ADVTXD_L4LEN_SHIFT: ::kernel::sys::raw::c_uint = 8;
pub const E1000_ADVTXD_MSS_SHIFT: ::kernel::sys::raw::c_uint = 16;
pub const E1000_ADVTXD_IPSEC_SA_INDEX_MASK: ::kernel::sys::raw::c_uint = 255;
pub const E1000_ADVTXD_IPSEC_ESP_LEN_MASK: ::kernel::sys::raw::c_uint = 255;
pub const E1000_TXDCTL_QUEUE_ENABLE: ::kernel::sys::raw::c_uint = 33554432;
pub const E1000_TXDCTL_SWFLSH: ::kernel::sys::raw::c_uint = 67108864;
pub const E1000_TXDCTL_PRIORITY: ::kernel::sys::raw::c_uint = 134217728;
pub const E1000_RXDCTL_QUEUE_ENABLE: ::kernel::sys::raw::c_uint = 33554432;
pub const E1000_RXDCTL_SWFLSH: ::kernel::sys::raw::c_uint = 67108864;
pub const E1000_DCA_CTRL_DCA_ENABLE: ::kernel::sys::raw::c_uint = 0;
pub const E1000_DCA_CTRL_DCA_DISABLE: ::kernel::sys::raw::c_uint = 1;
pub const E1000_DCA_CTRL_DCA_MODE_CB1: ::kernel::sys::raw::c_uint = 0;
pub const E1000_DCA_CTRL_DCA_MODE_CB2: ::kernel::sys::raw::c_uint = 2;
pub const E1000_DCA_RXCTRL_CPUID_MASK: ::kernel::sys::raw::c_uint = 31;
pub const E1000_DCA_RXCTRL_DESC_DCA_EN: ::kernel::sys::raw::c_uint = 32;
pub const E1000_DCA_RXCTRL_HEAD_DCA_EN: ::kernel::sys::raw::c_uint = 64;
pub const E1000_DCA_RXCTRL_DATA_DCA_EN: ::kernel::sys::raw::c_uint = 128;
pub const E1000_DCA_RXCTRL_DESC_RRO_EN: ::kernel::sys::raw::c_uint = 512;
pub const E1000_DCA_TXCTRL_CPUID_MASK: ::kernel::sys::raw::c_uint = 31;
pub const E1000_DCA_TXCTRL_DESC_DCA_EN: ::kernel::sys::raw::c_uint = 32;
pub const E1000_DCA_TXCTRL_DESC_RRO_EN: ::kernel::sys::raw::c_uint = 512;
pub const E1000_DCA_TXCTRL_TX_WB_RO_EN: ::kernel::sys::raw::c_uint = 2048;
pub const E1000_DCA_TXCTRL_DATA_RRO_EN: ::kernel::sys::raw::c_uint = 8192;
pub const E1000_DCA_TXCTRL_CPUID_MASK_82576: ::kernel::sys::raw::c_uint =
    4278190080;
pub const E1000_DCA_RXCTRL_CPUID_MASK_82576: ::kernel::sys::raw::c_uint =
    4278190080;
pub const E1000_DCA_TXCTRL_CPUID_SHIFT_82576: ::kernel::sys::raw::c_uint = 24;
pub const E1000_DCA_RXCTRL_CPUID_SHIFT_82576: ::kernel::sys::raw::c_uint = 24;
pub const E1000_ICR_LSECPNS: ::kernel::sys::raw::c_uint = 32;
pub const E1000_IMS_LSECPNS: ::kernel::sys::raw::c_uint = 32;
pub const E1000_ICS_LSECPNS: ::kernel::sys::raw::c_uint = 32;
pub const E1000_ETQF_FILTER_ENABLE: ::kernel::sys::raw::c_uint = 67108864;
pub const E1000_ETQF_IMM_INT: ::kernel::sys::raw::c_uint = 536870912;
pub const E1000_ETQF_1588: ::kernel::sys::raw::c_uint = 1073741824;
pub const E1000_ETQF_QUEUE_ENABLE: ::kernel::sys::raw::c_uint = 2147483648;
pub const E1000_ETQF_FILTER_EAPOL: ::kernel::sys::raw::c_uint = 0;
pub const E1000_FTQF_VF_BP: ::kernel::sys::raw::c_uint = 32768;
pub const E1000_FTQF_1588_TIME_STAMP: ::kernel::sys::raw::c_uint = 134217728;
pub const E1000_FTQF_MASK: ::kernel::sys::raw::c_uint = 4026531840;
pub const E1000_FTQF_MASK_PROTO_BP: ::kernel::sys::raw::c_uint = 268435456;
pub const E1000_FTQF_MASK_SOURCE_ADDR_BP: ::kernel::sys::raw::c_uint =
    536870912;
pub const E1000_FTQF_MASK_DEST_ADDR_BP: ::kernel::sys::raw::c_uint =
    1073741824;
pub const E1000_FTQF_MASK_SOURCE_PORT_BP: ::kernel::sys::raw::c_uint =
    2147483648;
pub const E1000_NVM_APME_82575: ::kernel::sys::raw::c_uint = 1024;
pub const MAX_NUM_VFS: ::kernel::sys::raw::c_uint = 7;
pub const E1000_DTXSWC_MAC_SPOOF_MASK: ::kernel::sys::raw::c_uint = 255;
pub const E1000_DTXSWC_VLAN_SPOOF_MASK: ::kernel::sys::raw::c_uint = 65280;
pub const E1000_DTXSWC_LLE_MASK: ::kernel::sys::raw::c_uint = 16711680;
pub const E1000_DTXSWC_VLAN_SPOOF_SHIFT: ::kernel::sys::raw::c_uint = 8;
pub const E1000_DTXSWC_LLE_SHIFT: ::kernel::sys::raw::c_uint = 16;
pub const E1000_DTXSWC_VMDQ_LOOPBACK_EN: ::kernel::sys::raw::c_uint =
    2147483648;
pub const E1000_VT_CTL_DEFAULT_POOL_SHIFT: ::kernel::sys::raw::c_uint = 7;
pub const E1000_VT_CTL_DEFAULT_POOL_MASK: ::kernel::sys::raw::c_uint = 896;
pub const E1000_VT_CTL_IGNORE_MAC: ::kernel::sys::raw::c_uint = 268435456;
pub const E1000_VT_CTL_DISABLE_DEF_POOL: ::kernel::sys::raw::c_uint =
    536870912;
pub const E1000_VT_CTL_VM_REPL_EN: ::kernel::sys::raw::c_uint = 1073741824;
pub const E1000_VMOLR_RLPML_MASK: ::kernel::sys::raw::c_uint = 16383;
pub const E1000_VMOLR_LPE: ::kernel::sys::raw::c_uint = 65536;
pub const E1000_VMOLR_RSSE: ::kernel::sys::raw::c_uint = 131072;
pub const E1000_VMOLR_AUPE: ::kernel::sys::raw::c_uint = 16777216;
pub const E1000_VMOLR_ROMPE: ::kernel::sys::raw::c_uint = 33554432;
pub const E1000_VMOLR_ROPE: ::kernel::sys::raw::c_uint = 67108864;
pub const E1000_VMOLR_BAM: ::kernel::sys::raw::c_uint = 134217728;
pub const E1000_VMOLR_MPME: ::kernel::sys::raw::c_uint = 268435456;
pub const E1000_VMOLR_STRVLAN: ::kernel::sys::raw::c_uint = 1073741824;
pub const E1000_VMOLR_STRCRC: ::kernel::sys::raw::c_uint = 2147483648;
pub const E1000_VMOLR_VPE: ::kernel::sys::raw::c_uint = 8388608;
pub const E1000_VMOLR_UPE: ::kernel::sys::raw::c_uint = 536870912;
pub const E1000_DVMOLR_HIDVLAN: ::kernel::sys::raw::c_uint = 536870912;
pub const E1000_DVMOLR_STRVLAN: ::kernel::sys::raw::c_uint = 1073741824;
pub const E1000_DVMOLR_STRCRC: ::kernel::sys::raw::c_uint = 2147483648;
pub const E1000_PBRWAC_WALPB: ::kernel::sys::raw::c_uint = 7;
pub const E1000_PBRWAC_PBE: ::kernel::sys::raw::c_uint = 8;
pub const E1000_VLVF_ARRAY_SIZE: ::kernel::sys::raw::c_uint = 32;
pub const E1000_VLVF_VLANID_MASK: ::kernel::sys::raw::c_uint = 4095;
pub const E1000_VLVF_POOLSEL_SHIFT: ::kernel::sys::raw::c_uint = 12;
pub const E1000_VLVF_POOLSEL_MASK: ::kernel::sys::raw::c_uint = 1044480;
pub const E1000_VLVF_LVLAN: ::kernel::sys::raw::c_uint = 1048576;
pub const E1000_VLVF_VLANID_ENABLE: ::kernel::sys::raw::c_uint = 2147483648;
pub const E1000_VMVIR_VLANA_DEFAULT: ::kernel::sys::raw::c_uint = 1073741824;
pub const E1000_VMVIR_VLANA_NEVER: ::kernel::sys::raw::c_uint = 2147483648;
pub const E1000_VF_INIT_TIMEOUT: ::kernel::sys::raw::c_uint = 200;
pub const E1000_IOVCTL_REUSE_VFQ: ::kernel::sys::raw::c_uint = 1;
pub const E1000_RPLOLR_STRVLAN: ::kernel::sys::raw::c_uint = 1073741824;
pub const E1000_RPLOLR_STRCRC: ::kernel::sys::raw::c_uint = 2147483648;
pub const E1000_TCTL_EXT_COLD: ::kernel::sys::raw::c_uint = 1047552;
pub const E1000_TCTL_EXT_COLD_SHIFT: ::kernel::sys::raw::c_uint = 10;
pub const E1000_DTXCTL_8023LL: ::kernel::sys::raw::c_uint = 4;
pub const E1000_DTXCTL_VLAN_ADDED: ::kernel::sys::raw::c_uint = 8;
pub const E1000_DTXCTL_OOS_ENABLE: ::kernel::sys::raw::c_uint = 16;
pub const E1000_DTXCTL_MDP_EN: ::kernel::sys::raw::c_uint = 32;
pub const E1000_DTXCTL_SPOOF_INT: ::kernel::sys::raw::c_uint = 64;
pub const E1000_EEPROM_PCS_AUTONEG_DISABLE_BIT: ::kernel::sys::raw::c_uint =
    16384;
pub const ALL_QUEUES: ::kernel::sys::raw::c_uint = 65535;
pub const E1000_RXPBS_SIZE_MASK_82576: ::kernel::sys::raw::c_uint = 127;
pub const E1000_I2C_T_HD_STA: ::kernel::sys::raw::c_uint = 4;
pub const E1000_I2C_T_LOW: ::kernel::sys::raw::c_uint = 5;
pub const E1000_I2C_T_HIGH: ::kernel::sys::raw::c_uint = 4;
pub const E1000_I2C_T_SU_STA: ::kernel::sys::raw::c_uint = 5;
pub const E1000_I2C_T_HD_DATA: ::kernel::sys::raw::c_uint = 5;
pub const E1000_I2C_T_SU_DATA: ::kernel::sys::raw::c_uint = 1;
pub const E1000_I2C_T_RISE: ::kernel::sys::raw::c_uint = 1;
pub const E1000_I2C_T_FALL: ::kernel::sys::raw::c_uint = 1;
pub const E1000_I2C_T_SU_STO: ::kernel::sys::raw::c_uint = 4;
pub const E1000_I2C_T_BUF: ::kernel::sys::raw::c_uint = 5;
pub const E1000_EEPROM_FLASH_SIZE_WORD: ::kernel::sys::raw::c_uint = 17;
pub const E1000_INVM_RSA_KEY_SHA256_DATA_SIZE_IN_DWORDS:
          ::kernel::sys::raw::c_uint =
    8;
pub const E1000_INVM_CSR_AUTOLOAD_DATA_SIZE_IN_DWORDS:
          ::kernel::sys::raw::c_uint =
    1;
pub const E1000_INVM_ULT_BYTES_SIZE: ::kernel::sys::raw::c_uint = 8;
pub const E1000_INVM_RECORD_SIZE_IN_BYTES: ::kernel::sys::raw::c_uint = 4;
pub const E1000_INVM_VER_FIELD_ONE: ::kernel::sys::raw::c_uint = 8184;
pub const E1000_INVM_VER_FIELD_TWO: ::kernel::sys::raw::c_uint = 8380416;
pub const E1000_INVM_IMGTYPE_FIELD: ::kernel::sys::raw::c_uint = 528482304;
pub const E1000_INVM_MAJOR_MASK: ::kernel::sys::raw::c_uint = 1008;
pub const E1000_INVM_MINOR_MASK: ::kernel::sys::raw::c_uint = 15;
pub const E1000_INVM_MAJOR_SHIFT: ::kernel::sys::raw::c_uint = 4;
pub const ID_LED_DEFAULT_I210: ::kernel::sys::raw::c_uint = 2073;
pub const ID_LED_DEFAULT_I210_SERDES: ::kernel::sys::raw::c_uint = 280;
pub const NVM_INIT_CTRL_4_DEFAULT_I211: ::kernel::sys::raw::c_uint = 193;
pub const NVM_LED_1_CFG_DEFAULT_I211: ::kernel::sys::raw::c_uint = 388;
pub const NVM_LED_0_2_CFG_DEFAULT_I211: ::kernel::sys::raw::c_uint = 8204;
pub const E1000_PCI_PMCSR: ::kernel::sys::raw::c_uint = 68;
pub const E1000_PCI_PMCSR_D3: ::kernel::sys::raw::c_uint = 3;
pub const E1000_MAX_PLL_TRIES: ::kernel::sys::raw::c_uint = 5;
pub const E1000_PHY_PLL_UNCONF: ::kernel::sys::raw::c_uint = 255;
pub const E1000_PHY_PLL_FREQ_PAGE: ::kernel::sys::raw::c_uint = 16515072;
pub const E1000_PHY_PLL_FREQ_REG: ::kernel::sys::raw::c_uint = 14;
pub const E1000_INVM_DEFAULT_AL: ::kernel::sys::raw::c_uint = 8239;
pub const E1000_INVM_AUTOLOAD: ::kernel::sys::raw::c_uint = 10;
pub const E1000_INVM_PLL_WO_VAL: ::kernel::sys::raw::c_uint = 16;
pub const CARRIER_EXTENSION: ::kernel::sys::raw::c_uint = 15;
pub const EM_MIN_TXD: ::kernel::sys::raw::c_uint = 128;
pub const EM_MAX_TXD: ::kernel::sys::raw::c_uint = 4096;
pub const EM_DEFAULT_TXD: ::kernel::sys::raw::c_uint = 1024;
pub const EM_DEFAULT_MULTI_TXD: ::kernel::sys::raw::c_uint = 4096;
pub const IGB_MAX_TXD: ::kernel::sys::raw::c_uint = 4096;
pub const EM_MIN_RXD: ::kernel::sys::raw::c_uint = 128;
pub const EM_MAX_RXD: ::kernel::sys::raw::c_uint = 4096;
pub const EM_DEFAULT_RXD: ::kernel::sys::raw::c_uint = 1024;
pub const EM_DEFAULT_MULTI_RXD: ::kernel::sys::raw::c_uint = 4096;
pub const IGB_MAX_RXD: ::kernel::sys::raw::c_uint = 4096;
pub const EM_TIDV: ::kernel::sys::raw::c_uint = 64;
pub const EM_TADV: ::kernel::sys::raw::c_uint = 64;
pub const EM_RDTR: ::kernel::sys::raw::c_uint = 0;
pub const EM_RADV: ::kernel::sys::raw::c_uint = 64;
pub const DO_AUTO_NEG: ::kernel::sys::raw::c_uint = 1;
pub const WAIT_FOR_AUTO_NEG_DEFAULT: ::kernel::sys::raw::c_uint = 0;
pub const AUTONEG_ADV_DEFAULT: ::kernel::sys::raw::c_uint = 47;
pub const AUTO_ALL_MODES: ::kernel::sys::raw::c_uint = 0;
pub const EM_VENDOR_ID: ::kernel::sys::raw::c_uint = 32902;
pub const EM_FLASH: ::kernel::sys::raw::c_uint = 20;
pub const EM_JUMBO_PBA: ::kernel::sys::raw::c_uint = 40;
pub const EM_DEFAULT_PBA: ::kernel::sys::raw::c_uint = 48;
pub const EM_SMARTSPEED_DOWNSHIFT: ::kernel::sys::raw::c_uint = 3;
pub const EM_SMARTSPEED_MAX: ::kernel::sys::raw::c_uint = 15;
pub const EM_MAX_LOOP: ::kernel::sys::raw::c_uint = 10;
pub const MAX_NUM_MULTICAST_ADDRESSES: ::kernel::sys::raw::c_uint = 128;
pub const PCI_ANY_ID: ::kernel::sys::raw::c_int = -1;
pub const EM_FC_PAUSE_TIME: ::kernel::sys::raw::c_uint = 1664;
pub const EM_EEPROM_APME: ::kernel::sys::raw::c_uint = 1024;
pub const EM_82544_APME: ::kernel::sys::raw::c_uint = 4;
pub const IGB_MEDIA_RESET: ::kernel::sys::raw::c_uint = 1;
pub const IGB_INTS_PER_SEC: ::kernel::sys::raw::c_uint = 8000;
pub const IGB_DEFAULT_ITR: ::kernel::sys::raw::c_uint = 500;
pub const IGB_LINK_ITR: ::kernel::sys::raw::c_uint = 2000;
pub const I210_LINK_DELAY: ::kernel::sys::raw::c_uint = 1000;
pub const IGB_MAX_SCATTER: ::kernel::sys::raw::c_uint = 40;
pub const IGB_VFTA_SIZE: ::kernel::sys::raw::c_uint = 128;
pub const IGB_BR_SIZE: ::kernel::sys::raw::c_uint = 4096;
pub const IGB_TSO_SEG_SIZE: ::kernel::sys::raw::c_uint = 4096;
pub const IGB_TXPBSIZE: ::kernel::sys::raw::c_uint = 20408;
pub const IGB_HDR_BUF: ::kernel::sys::raw::c_uint = 128;
pub const IGB_PKTTYPE_MASK: ::kernel::sys::raw::c_uint = 65520;
pub const IGB_DMCTLX_DCFLUSH_DIS: ::kernel::sys::raw::c_uint = 2147483648;
pub const EM_TX_IDLE: ::kernel::sys::raw::c_uint = 0;
pub const EM_TX_BUSY: ::kernel::sys::raw::c_uint = 1;
pub const EM_TX_HUNG: ::kernel::sys::raw::c_uint = 2147483648;
pub const EM_TX_MAXTRIES: ::kernel::sys::raw::c_uint = 10;
pub const PCICFG_DESC_RING_STATUS: ::kernel::sys::raw::c_uint = 228;
pub const FLUSH_DESC_REQUIRED: ::kernel::sys::raw::c_uint = 256;
pub const IGB_RX_HTHRESH: ::kernel::sys::raw::c_uint = 8;
pub const IGB_TX_HTHRESH: ::kernel::sys::raw::c_uint = 1;
pub const EM_DBA_ALIGN: ::kernel::sys::raw::c_uint = 128;
pub const TARC_COMPENSATION_MODE: ::kernel::sys::raw::c_uint = 128;
pub const TARC_SPEED_MODE_BIT: ::kernel::sys::raw::c_uint = 2097152;
pub const TARC_MQ_FIX: ::kernel::sys::raw::c_uint = 58720256;
pub const TARC_ERRATA_BIT: ::kernel::sys::raw::c_uint = 67108864;
pub const EM_BAR_TYPE_MASK: ::kernel::sys::raw::c_uint = 1;
pub const EM_BAR_TYPE_MMEM: ::kernel::sys::raw::c_uint = 0;
pub const EM_BAR_TYPE_IO: ::kernel::sys::raw::c_uint = 1;
pub const EM_BAR_TYPE_FLASH: ::kernel::sys::raw::c_uint = 20;
pub const EM_BAR_MEM_TYPE_MASK: ::kernel::sys::raw::c_uint = 6;
pub const EM_BAR_MEM_TYPE_32BIT: ::kernel::sys::raw::c_uint = 0;
pub const EM_BAR_MEM_TYPE_64BIT: ::kernel::sys::raw::c_uint = 4;
pub const EM_MSIX_BAR: ::kernel::sys::raw::c_uint = 3;
pub const DEBUG_INIT: ::kernel::sys::raw::c_uint = 0;
pub const DEBUG_IOCTL: ::kernel::sys::raw::c_uint = 0;
pub const DEBUG_HW: ::kernel::sys::raw::c_uint = 0;
pub const EM_MAX_SCATTER: ::kernel::sys::raw::c_uint = 40;
pub const EM_VFTA_SIZE: ::kernel::sys::raw::c_uint = 128;
pub const EM_TSO_SEG_SIZE: ::kernel::sys::raw::c_uint = 4096;
pub const EM_MSIX_MASK: ::kernel::sys::raw::c_uint = 32505856;
pub const EM_MSIX_LINK: ::kernel::sys::raw::c_uint = 16777216;
pub const ETH_ZLEN: ::kernel::sys::raw::c_uint = 60;
pub const EM_CSUM_OFFLOAD: ::kernel::sys::raw::c_uint = 7;
pub const IGB_CSUM_OFFLOAD: ::kernel::sys::raw::c_uint = 3599;
pub const EM_EIAC: ::kernel::sys::raw::c_uint = 220;
pub const EM_NVM_PCIE_CTRL: ::kernel::sys::raw::c_uint = 27;
pub const EM_NVM_MSIX_N_SHIFT: ::kernel::sys::raw::c_uint = 7;
pub const EM_RSSRK_SIZE: ::kernel::sys::raw::c_uint = 4;
pub type __int8_t = ::kernel::sys::raw::c_schar;
pub type __uint8_t = ::kernel::sys::raw::c_uchar;
pub type __int16_t = ::kernel::sys::raw::c_short;
pub type __uint16_t = ::kernel::sys::raw::c_ushort;
pub type __int32_t = ::kernel::sys::raw::c_int;
pub type __uint32_t = ::kernel::sys::raw::c_uint;
pub type __int64_t = ::kernel::sys::raw::c_long;
pub type __uint64_t = ::kernel::sys::raw::c_ulong;
pub type __clock_t = __int32_t;
pub type __critical_t = __int64_t;
pub type __double_t = f64;
pub type __float_t = f32;
pub type __intfptr_t = __int64_t;
pub type __intptr_t = __int64_t;
pub type __intmax_t = __int64_t;
pub type __int_fast8_t = __int32_t;
pub type __int_fast16_t = __int32_t;
pub type __int_fast32_t = __int32_t;
pub type __int_fast64_t = __int64_t;
pub type __int_least8_t = __int8_t;
pub type __int_least16_t = __int16_t;
pub type __int_least32_t = __int32_t;
pub type __int_least64_t = __int64_t;
pub type __ptrdiff_t = __int64_t;
pub type __register_t = __int64_t;
pub type __segsz_t = __int64_t;
pub type __size_t = __uint64_t;
pub type __ssize_t = __int64_t;
pub type __time_t = __int64_t;
pub type __uintfptr_t = __uint64_t;
pub type __uintptr_t = __uint64_t;
pub type __uintmax_t = __uint64_t;
pub type __uint_fast8_t = __uint32_t;
pub type __uint_fast16_t = __uint32_t;
pub type __uint_fast32_t = __uint32_t;
pub type __uint_fast64_t = __uint64_t;
pub type __uint_least8_t = __uint8_t;
pub type __uint_least16_t = __uint16_t;
pub type __uint_least32_t = __uint32_t;
pub type __uint_least64_t = __uint64_t;
pub type __u_register_t = __uint64_t;
pub type __vm_offset_t = __uint64_t;
pub type __vm_paddr_t = __uint64_t;
pub type __vm_size_t = __uint64_t;
pub type ___wchar_t = ::kernel::sys::raw::c_int;
pub type __blksize_t = __int32_t;
pub type __blkcnt_t = __int64_t;
pub type __clockid_t = __int32_t;
pub type __fflags_t = __uint32_t;
pub type __fsblkcnt_t = __uint64_t;
pub type __fsfilcnt_t = __uint64_t;
pub type __gid_t = __uint32_t;
pub type __id_t = __int64_t;
pub type __ino_t = __uint64_t;
pub type __key_t = ::kernel::sys::raw::c_long;
pub type __lwpid_t = __int32_t;
pub type __mode_t = __uint16_t;
pub type __accmode_t = ::kernel::sys::raw::c_int;
pub type __nl_item = ::kernel::sys::raw::c_int;
pub type __nlink_t = __uint64_t;
pub type __off_t = __int64_t;
pub type __off64_t = __int64_t;
pub type __pid_t = __int32_t;
pub type __rlim_t = __int64_t;
pub type __sa_family_t = __uint8_t;
pub type __socklen_t = __uint32_t;
pub type __suseconds_t = ::kernel::sys::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __timer {
    _unused: [u8; 0],
}
pub type __timer_t = *mut __timer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __mq {
    _unused: [u8; 0],
}
pub type __mqd_t = *mut __mq;
pub type __uid_t = __uint32_t;
pub type __useconds_t = ::kernel::sys::raw::c_uint;
pub type __cpuwhich_t = ::kernel::sys::raw::c_int;
pub type __cpulevel_t = ::kernel::sys::raw::c_int;
pub type __cpusetid_t = ::kernel::sys::raw::c_int;
pub type __ct_rune_t = ::kernel::sys::raw::c_int;
pub type __rune_t = __ct_rune_t;
pub type __wint_t = __ct_rune_t;
pub type __char16_t = __uint_least16_t;
pub type __char32_t = __uint_least32_t;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct __max_align_t {
    pub __max_align1: ::kernel::sys::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __max_align2: f64,
}
#[test]
fn bindgen_test_layout___max_align_t() {
    assert_eq!(::core::mem::size_of::<__max_align_t>() , 32usize , concat ! (
               "Size of: " , stringify ! ( __max_align_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __max_align_t ) ) . __max_align1 as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __max_align_t ) , "::"
                , stringify ! ( __max_align1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __max_align_t ) ) . __max_align2 as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __max_align_t ) , "::"
                , stringify ! ( __max_align2 ) ));
}
impl Clone for __max_align_t {
    fn clone(&self) -> Self { *self }
}
pub type __dev_t = __uint64_t;
pub type __fixpt_t = __uint32_t;
#[repr(C)]
#[derive(Copy)]
pub union __mbstate_t {
    pub __mbstate8: [::kernel::sys::raw::c_char; 128usize],
    pub _mbstateL: __int64_t,
    _bindgen_union_align: [u64; 16usize],
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(::core::mem::size_of::<__mbstate_t>() , 128usize , concat ! (
               "Size of: " , stringify ! ( __mbstate_t ) ));
    assert_eq! (::core::mem::align_of::<__mbstate_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __mbstate_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . __mbstate8 as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( __mbstate8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . _mbstateL as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( _mbstateL ) ));
}
impl Clone for __mbstate_t {
    fn clone(&self) -> Self { *self }
}
impl Default for __mbstate_t {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for __mbstate_t {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "__mbstate_t {{ union }}")
    }
}
pub type __rman_res_t = __uintmax_t;
pub type __va_list = __builtin_va_list;
pub type __gnuc_va_list = __va_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_cond {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_cond_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutex {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutex_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pthread_once {
    pub state: ::kernel::sys::raw::c_int,
    pub mutex: pthread_mutex_t,
}
#[test]
fn bindgen_test_layout_pthread_once() {
    assert_eq!(::core::mem::size_of::<pthread_once>() , 16usize , concat ! (
               "Size of: " , stringify ! ( pthread_once ) ));
    assert_eq! (::core::mem::align_of::<pthread_once>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pthread_once ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_once ) ) . state as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_once ) , "::" ,
                stringify ! ( state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pthread_once ) ) . mutex as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pthread_once ) , "::" ,
                stringify ! ( mutex ) ));
}
impl Clone for pthread_once {
    fn clone(&self) -> Self { *self }
}
impl Default for pthread_once {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_rwlock {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_rwlockattr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_barrier {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_barrier_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_spinlock {
    _unused: [u8; 0],
}
pub type pthread_t = *mut pthread;
pub type pthread_attr_t = *mut pthread_attr;
pub type pthread_mutex_t = *mut pthread_mutex;
pub type pthread_mutexattr_t = *mut pthread_mutex_attr;
pub type pthread_cond_t = *mut pthread_cond;
pub type pthread_condattr_t = *mut pthread_cond_attr;
pub type pthread_key_t = ::kernel::sys::raw::c_int;
pub type pthread_once_t = pthread_once;
pub type pthread_rwlock_t = *mut pthread_rwlock;
pub type pthread_rwlockattr_t = *mut pthread_rwlockattr;
pub type pthread_barrier_t = *mut pthread_barrier;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_barrierattr {
    _unused: [u8; 0],
}
pub type pthread_barrierattr_t = *mut pthread_barrierattr;
pub type pthread_spinlock_t = *mut pthread_spinlock;
pub type pthread_addr_t = *mut ::kernel::sys::raw::c_void;
pub type pthread_startroutine_t =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void)
                               -> *mut ::kernel::sys::raw::c_void>;
pub type u_char = ::kernel::sys::raw::c_uchar;
pub type u_short = ::kernel::sys::raw::c_ushort;
pub type u_int = ::kernel::sys::raw::c_uint;
pub type u_long = ::kernel::sys::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type u_quad_t = __uint64_t;
pub type quad_t = __int64_t;
pub type qaddr_t = *mut quad_t;
pub type caddr_t = *mut ::kernel::sys::raw::c_char;
pub type c_caddr_t = *const ::kernel::sys::raw::c_char;
pub type blksize_t = __blksize_t;
pub type cpuwhich_t = __cpuwhich_t;
pub type cpulevel_t = __cpulevel_t;
pub type cpusetid_t = __cpusetid_t;
pub type blkcnt_t = __blkcnt_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type critical_t = __critical_t;
pub type daddr_t = __int64_t;
pub type dev_t = __dev_t;
pub type fflags_t = __fflags_t;
pub type fixpt_t = __fixpt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type gid_t = __gid_t;
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type id_t = __id_t;
pub type ino_t = __ino_t;
pub type key_t = __key_t;
pub type lwpid_t = __lwpid_t;
pub type mode_t = __mode_t;
pub type accmode_t = __accmode_t;
pub type nlink_t = __nlink_t;
pub type off_t = __off_t;
pub type off64_t = __off64_t;
pub type pid_t = __pid_t;
pub type register_t = __register_t;
pub type rlim_t = __rlim_t;
pub type sbintime_t = __int64_t;
pub type segsz_t = __segsz_t;
pub type suseconds_t = __suseconds_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type mqd_t = __mqd_t;
pub type u_register_t = __u_register_t;
pub type uid_t = __uid_t;
pub type useconds_t = __useconds_t;
pub type cap_ioctl_t = ::kernel::sys::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cap_rights {
    _unused: [u8; 0],
}
pub type cap_rights_t = cap_rights;
pub type vm_offset_t = __vm_offset_t;
pub type vm_ooffset_t = __int64_t;
pub type vm_paddr_t = __vm_paddr_t;
pub type vm_pindex_t = __uint64_t;
pub type vm_size_t = __vm_size_t;
pub type rman_res_t = __rman_res_t;
pub type boolean_t = ::kernel::sys::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct device {
    _unused: [u8; 0],
}
pub type device_t = *mut device;
pub type intfptr_t = __intfptr_t;
pub type intrmask_t = __uint32_t;
pub type uintfptr_t = __uintfptr_t;
pub type uoff_t = __uint64_t;
pub type vm_memattr_t = ::kernel::sys::raw::c_char;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_page {
    _unused: [u8; 0],
}
pub type vm_page_t = *mut vm_page;
pub type bool_ = bool;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct __sigset {
    pub __bits: [__uint32_t; 4usize],
}
#[test]
fn bindgen_test_layout___sigset() {
    assert_eq!(::core::mem::size_of::<__sigset>() , 16usize , concat ! (
               "Size of: " , stringify ! ( __sigset ) ));
    assert_eq! (::core::mem::align_of::<__sigset>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( __sigset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __sigset ) ) . __bits as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __sigset ) , "::" ,
                stringify ! ( __bits ) ));
}
impl Clone for __sigset {
    fn clone(&self) -> Self { *self }
}
pub type __sigset_t = __sigset;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct timeval {
    pub tv_sec: time_t,
    pub tv_usec: suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(::core::mem::size_of::<timeval>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timeval ) ));
    assert_eq! (::core::mem::align_of::<timeval>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timeval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeval ) ) . tv_usec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timeval ) , "::" ,
                stringify ! ( tv_usec ) ));
}
impl Clone for timeval {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: ::kernel::sys::raw::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(::core::mem::size_of::<timespec>() , 16usize , concat ! (
               "Size of: " , stringify ! ( timespec ) ));
    assert_eq! (::core::mem::align_of::<timespec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timespec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_sec as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timespec ) ) . tv_nsec as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timespec ) , "::" ,
                stringify ! ( tv_nsec ) ));
}
impl Clone for timespec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(::core::mem::size_of::<itimerspec>() , 32usize , concat ! (
               "Size of: " , stringify ! ( itimerspec ) ));
    assert_eq! (::core::mem::align_of::<itimerspec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( itimerspec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerspec ) ) . it_interval as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerspec ) , "::" ,
                stringify ! ( it_interval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerspec ) ) . it_value as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerspec ) , "::" ,
                stringify ! ( it_value ) ));
}
impl Clone for itimerspec {
    fn clone(&self) -> Self { *self }
}
pub type __fd_mask = ::kernel::sys::raw::c_ulong;
pub type fd_mask = __fd_mask;
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(::core::mem::size_of::<fd_set>() , 128usize , concat ! (
               "Size of: " , stringify ! ( fd_set ) ));
    assert_eq! (::core::mem::align_of::<fd_set>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( fd_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fd_set ) ) . __fds_bits as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( fd_set ) , "::" ,
                stringify ! ( __fds_bits ) ));
}
impl Clone for fd_set {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct timezone {
    pub tz_minuteswest: ::kernel::sys::raw::c_int,
    pub tz_dsttime: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_timezone() {
    assert_eq!(::core::mem::size_of::<timezone>() , 8usize , concat ! (
               "Size of: " , stringify ! ( timezone ) ));
    assert_eq! (::core::mem::align_of::<timezone>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( timezone ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timezone ) ) . tz_minuteswest as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timezone ) , "::" ,
                stringify ! ( tz_minuteswest ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timezone ) ) . tz_dsttime as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( timezone ) , "::" ,
                stringify ! ( tz_dsttime ) ));
}
impl Clone for timezone {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct bintime {
    pub sec: time_t,
    pub frac: u64,
}
#[test]
fn bindgen_test_layout_bintime() {
    assert_eq!(::core::mem::size_of::<bintime>() , 16usize , concat ! (
               "Size of: " , stringify ! ( bintime ) ));
    assert_eq! (::core::mem::align_of::<bintime>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( bintime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bintime ) ) . sec as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( bintime ) , "::" ,
                stringify ! ( sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bintime ) ) . frac as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( bintime ) , "::" ,
                stringify ! ( frac ) ));
}
impl Clone for bintime {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
#[test]
fn bindgen_test_layout_itimerval() {
    assert_eq!(::core::mem::size_of::<itimerval>() , 32usize , concat ! (
               "Size of: " , stringify ! ( itimerval ) ));
    assert_eq! (::core::mem::align_of::<itimerval>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( itimerval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerval ) ) . it_interval as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerval ) , "::" ,
                stringify ! ( it_interval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const itimerval ) ) . it_value as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( itimerval ) , "::" ,
                stringify ! ( it_value ) ));
}
impl Clone for itimerval {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct clockinfo {
    pub hz: ::kernel::sys::raw::c_int,
    pub tick: ::kernel::sys::raw::c_int,
    pub spare: ::kernel::sys::raw::c_int,
    pub stathz: ::kernel::sys::raw::c_int,
    pub profhz: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_clockinfo() {
    assert_eq!(::core::mem::size_of::<clockinfo>() , 20usize , concat ! (
               "Size of: " , stringify ! ( clockinfo ) ));
    assert_eq! (::core::mem::align_of::<clockinfo>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( clockinfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clockinfo ) ) . hz as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( clockinfo ) , "::" ,
                stringify ! ( hz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clockinfo ) ) . tick as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( clockinfo ) , "::" ,
                stringify ! ( tick ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clockinfo ) ) . spare as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( clockinfo ) , "::" ,
                stringify ! ( spare ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clockinfo ) ) . stathz as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( clockinfo ) , "::" ,
                stringify ! ( stathz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const clockinfo ) ) . profhz as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( clockinfo ) , "::" ,
                stringify ! ( profhz ) ));
}
impl Clone for clockinfo {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn inittodr(base: time_t);
}
extern "C" {
    pub fn resettodr();
}
extern "C" {
    #[link_name = "time_second"]
    pub static mut time_second: time_t;
}
extern "C" {
    #[link_name = "time_uptime"]
    pub static mut time_uptime: time_t;
}
extern "C" {
    #[link_name = "tc_tick_bt"]
    pub static mut tc_tick_bt: bintime;
}
extern "C" {
    #[link_name = "tc_tick_sbt"]
    pub static mut tc_tick_sbt: sbintime_t;
}
extern "C" {
    #[link_name = "tick_bt"]
    pub static mut tick_bt: bintime;
}
extern "C" {
    #[link_name = "tick_sbt"]
    pub static mut tick_sbt: sbintime_t;
}
extern "C" {
    #[link_name = "tc_precexp"]
    pub static mut tc_precexp: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "tc_timepercentage"]
    pub static mut tc_timepercentage: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "bt_timethreshold"]
    pub static mut bt_timethreshold: bintime;
}
extern "C" {
    #[link_name = "bt_tickthreshold"]
    pub static mut bt_tickthreshold: bintime;
}
extern "C" {
    #[link_name = "sbt_timethreshold"]
    pub static mut sbt_timethreshold: sbintime_t;
}
extern "C" {
    #[link_name = "sbt_tickthreshold"]
    pub static mut sbt_tickthreshold: sbintime_t;
}
extern "C" {
    #[link_name = "rtc_generation"]
    pub static mut rtc_generation: ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn binuptime(bt: *mut bintime);
}
extern "C" {
    pub fn nanouptime(tsp: *mut timespec);
}
extern "C" {
    pub fn microuptime(tvp: *mut timeval);
}
extern "C" {
    pub fn bintime(bt: *mut bintime);
}
extern "C" {
    pub fn nanotime(tsp: *mut timespec);
}
extern "C" {
    pub fn microtime(tvp: *mut timeval);
}
extern "C" {
    pub fn getbinuptime(bt: *mut bintime);
}
extern "C" {
    pub fn getnanouptime(tsp: *mut timespec);
}
extern "C" {
    pub fn getmicrouptime(tvp: *mut timeval);
}
extern "C" {
    pub fn getbintime(bt: *mut bintime);
}
extern "C" {
    pub fn getnanotime(tsp: *mut timespec);
}
extern "C" {
    pub fn getmicrotime(tvp: *mut timeval);
}
extern "C" {
    pub fn getboottime(boottime: *mut timeval);
}
extern "C" {
    pub fn getboottimebin(boottimebin: *mut bintime);
}
extern "C" {
    pub fn itimerdecr(itp: *mut itimerval, usec: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn itimerfix(tv: *mut timeval) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn ppsratecheck(arg1: *mut timeval,
                        arg2: *mut ::kernel::sys::raw::c_int,
                        arg3: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn ratecheck(arg1: *mut timeval, arg2: *const timeval)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn timevaladd(t1: *mut timeval, t2: *const timeval);
}
extern "C" {
    pub fn timevalsub(t1: *mut timeval, t2: *const timeval);
}
extern "C" {
    pub fn tvtohz(tv: *mut timeval) -> ::kernel::sys::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct priority {
    pub pri_class: u_char,
    pub pri_level: u_char,
    pub pri_native: u_char,
    pub pri_user: u_char,
}
#[test]
fn bindgen_test_layout_priority() {
    assert_eq!(::core::mem::size_of::<priority>() , 4usize , concat ! (
               "Size of: " , stringify ! ( priority ) ));
    assert_eq! (::core::mem::align_of::<priority>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( priority ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const priority ) ) . pri_class as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( priority ) , "::" ,
                stringify ! ( pri_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const priority ) ) . pri_level as * const _ as
                usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( priority ) , "::" ,
                stringify ! ( pri_level ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const priority ) ) . pri_native as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( priority ) , "::" ,
                stringify ! ( pri_native ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const priority ) ) . pri_user as * const _ as
                usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( priority ) , "::" ,
                stringify ! ( pri_user ) ));
}
impl Clone for priority {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn htonl(arg1: __uint32_t) -> __uint32_t;
}
extern "C" {
    pub fn htons(arg1: __uint16_t) -> __uint16_t;
}
extern "C" {
    pub fn ntohl(arg1: __uint32_t) -> __uint32_t;
}
extern "C" {
    pub fn ntohs(arg1: __uint16_t) -> __uint16_t;
}
extern "C" {
    pub fn atomic_cmpset_char(dst: *mut u_char, expect: u_char, src: u_char)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn atomic_cmpset_short(dst: *mut u_short, expect: u_short,
                               src: u_short) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn atomic_cmpset_int(dst: *mut u_int, expect: u_int, src: u_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn atomic_cmpset_long(dst: *mut u_long, expect: u_long, src: u_long)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn atomic_fcmpset_char(dst: *mut u_char, expect: *mut u_char,
                               src: u_char) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn atomic_fcmpset_short(dst: *mut u_short, expect: *mut u_short,
                                src: u_short) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn atomic_fcmpset_int(dst: *mut u_int, expect: *mut u_int, src: u_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn atomic_fcmpset_long(dst: *mut u_long, expect: *mut u_long,
                               src: u_long) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn atomic_fetchadd_int(p: *mut u_int, v: u_int) -> u_int;
}
extern "C" {
    pub fn atomic_fetchadd_long(p: *mut u_long, v: u_long) -> u_long;
}
extern "C" {
    pub fn atomic_testandset_int(p: *mut u_int, v: u_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn atomic_testandset_long(p: *mut u_long, v: u_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn atomic_testandclear_int(p: *mut u_int, v: u_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn atomic_testandclear_long(p: *mut u_long, v: u_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn atomic_thread_fence_acq();
}
extern "C" {
    pub fn atomic_thread_fence_acq_rel();
}
extern "C" {
    pub fn atomic_thread_fence_rel();
}
extern "C" {
    pub fn atomic_thread_fence_seq_cst();
}
extern "C" {
    pub fn atomic_set_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_set_barr_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_clear_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_clear_barr_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_add_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_add_barr_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_subtract_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_subtract_barr_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_set_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_set_barr_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_clear_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_clear_barr_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_add_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_add_barr_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_subtract_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_subtract_barr_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_set_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_set_barr_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_clear_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_clear_barr_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_add_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_add_barr_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_subtract_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_subtract_barr_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_set_long(p: *mut u_long, v: u_long);
}
extern "C" {
    pub fn atomic_set_barr_long(p: *mut u_long, v: u_long);
}
extern "C" {
    pub fn atomic_clear_long(p: *mut u_long, v: u_long);
}
extern "C" {
    pub fn atomic_clear_barr_long(p: *mut u_long, v: u_long);
}
extern "C" {
    pub fn atomic_add_long(p: *mut u_long, v: u_long);
}
extern "C" {
    pub fn atomic_add_barr_long(p: *mut u_long, v: u_long);
}
extern "C" {
    pub fn atomic_subtract_long(p: *mut u_long, v: u_long);
}
extern "C" {
    pub fn atomic_subtract_barr_long(p: *mut u_long, v: u_long);
}
extern "C" {
    pub fn atomic_load_acq_char(p: *mut u_char) -> u_char;
}
extern "C" {
    pub fn atomic_store_rel_char(p: *mut u_char, v: u_char);
}
extern "C" {
    pub fn atomic_load_acq_short(p: *mut u_short) -> u_short;
}
extern "C" {
    pub fn atomic_store_rel_short(p: *mut u_short, v: u_short);
}
extern "C" {
    pub fn atomic_load_acq_int(p: *mut u_int) -> u_int;
}
extern "C" {
    pub fn atomic_store_rel_int(p: *mut u_int, v: u_int);
}
extern "C" {
    pub fn atomic_load_acq_long(p: *mut u_long) -> u_long;
}
extern "C" {
    pub fn atomic_store_rel_long(p: *mut u_long, v: u_long);
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy)]
pub struct region_descriptor {
    pub _bitfield_1: [u64; 2usize],
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_region_descriptor() {
    assert_eq!(::core::mem::size_of::<region_descriptor>() , 10usize , concat
               ! ( "Size of: " , stringify ! ( region_descriptor ) ));
    assert_eq! (::core::mem::align_of::<region_descriptor>() , 1usize , concat
                ! ( "Alignment of " , stringify ! ( region_descriptor ) ));
}
impl Clone for region_descriptor {
    fn clone(&self) -> Self { *self }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy)]
pub struct invpcid_descr {
    pub _bitfield_1: u64,
    pub addr: u64,
}
#[test]
fn bindgen_test_layout_invpcid_descr() {
    assert_eq!(::core::mem::size_of::<invpcid_descr>() , 16usize , concat ! (
               "Size of: " , stringify ! ( invpcid_descr ) ));
    assert_eq! (::core::mem::align_of::<invpcid_descr>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( invpcid_descr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const invpcid_descr ) ) . addr as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( invpcid_descr ) , "::"
                , stringify ! ( addr ) ));
}
impl Clone for invpcid_descr {
    fn clone(&self) -> Self { *self }
}
impl invpcid_descr {
    #[inline]
    pub fn pcid(&self) -> u64 {
        let mut unit_field_val: u64 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u64
                                                 as *mut u8,
                                             ::core::mem::size_of::<u64>())
        };
        let mask = 4095u64 as u64;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::core::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_pcid(&mut self, val: u64) {
        let mask = 4095u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u64
                                                 as *mut u8,
                                             ::core::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn pad(&self) -> u64 {
        let mut unit_field_val: u64 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u64
                                                 as *mut u8,
                                             ::core::mem::size_of::<u64>())
        };
        let mask = 18446744073709547520u64 as u64;
        let val = (unit_field_val & mask) >> 12usize;
        unsafe { ::core::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_pad(&mut self, val: u64) {
        let mask = 18446744073709547520u64 as u64;
        let val = val as u64 as u64;
        let mut unit_field_val: u64 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u64
                                                 as *mut u8,
                                             ::core::mem::size_of::<u64>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 12usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u64>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(pcid: u64, pad: u64) -> u64 {
        ({ ({ 0 } | ((pcid as u64 as u64) << 0usize) & (4095u64 as u64)) } |
             ((pad as u64 as u64) << 12usize) &
                 (18446744073709547520u64 as u64))
    }
}
pub const SGX_ECREATE: _bindgen_ty_1 = _bindgen_ty_1::SGX_ECREATE;
pub const SGX_EADD: _bindgen_ty_1 = _bindgen_ty_1::SGX_EADD;
pub const SGX_EINIT: _bindgen_ty_1 = _bindgen_ty_1::SGX_EINIT;
pub const SGX_EREMOVE: _bindgen_ty_1 = _bindgen_ty_1::SGX_EREMOVE;
pub const SGX_EDGBRD: _bindgen_ty_1 = _bindgen_ty_1::SGX_EDGBRD;
pub const SGX_EDGBWR: _bindgen_ty_1 = _bindgen_ty_1::SGX_EDGBWR;
pub const SGX_EEXTEND: _bindgen_ty_1 = _bindgen_ty_1::SGX_EEXTEND;
pub const SGX_ELDU: _bindgen_ty_1 = _bindgen_ty_1::SGX_ELDU;
pub const SGX_EBLOCK: _bindgen_ty_1 = _bindgen_ty_1::SGX_EBLOCK;
pub const SGX_EPA: _bindgen_ty_1 = _bindgen_ty_1::SGX_EPA;
pub const SGX_EWB: _bindgen_ty_1 = _bindgen_ty_1::SGX_EWB;
pub const SGX_ETRACK: _bindgen_ty_1 = _bindgen_ty_1::SGX_ETRACK;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_1 {
    SGX_ECREATE = 0,
    SGX_EADD = 1,
    SGX_EINIT = 2,
    SGX_EREMOVE = 3,
    SGX_EDGBRD = 4,
    SGX_EDGBWR = 5,
    SGX_EEXTEND = 6,
    SGX_ELDU = 8,
    SGX_EBLOCK = 9,
    SGX_EPA = 10,
    SGX_EWB = 11,
    SGX_ETRACK = 12,
}
pub const SGX_PT_SECS: _bindgen_ty_2 = _bindgen_ty_2::SGX_PT_SECS;
pub const SGX_PT_TCS: _bindgen_ty_2 = _bindgen_ty_2::SGX_PT_TCS;
pub const SGX_PT_REG: _bindgen_ty_2 = _bindgen_ty_2::SGX_PT_REG;
pub const SGX_PT_VA: _bindgen_ty_2 = _bindgen_ty_2::SGX_PT_VA;
pub const SGX_PT_TRIM: _bindgen_ty_2 = _bindgen_ty_2::SGX_PT_TRIM;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_2 {
    SGX_PT_SECS = 0,
    SGX_PT_TCS = 1,
    SGX_PT_REG = 2,
    SGX_PT_VA = 3,
    SGX_PT_TRIM = 4,
}
extern "C" {
    pub fn sgx_encls(eax: u32, rbx: u64, rcx: u64, rdx: u64)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn reset_dbregs();
}
extern "C" {
    pub fn rdmsr_safe(msr: u_int, val: *mut u64) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn wrmsr_safe(msr: u_int, newval: u64) -> ::kernel::sys::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lock_object {
    pub lo_name: *const ::kernel::sys::raw::c_char,
    pub lo_flags: u_int,
    pub lo_data: u_int,
    pub lo_witness: *mut witness,
}
#[test]
fn bindgen_test_layout_lock_object() {
    assert_eq!(::core::mem::size_of::<lock_object>() , 24usize , concat ! (
               "Size of: " , stringify ! ( lock_object ) ));
    assert_eq! (::core::mem::align_of::<lock_object>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lock_object ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_object ) ) . lo_name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_object ) , "::" ,
                stringify ! ( lo_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_object ) ) . lo_flags as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_object ) , "::" ,
                stringify ! ( lo_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_object ) ) . lo_data as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_object ) , "::" ,
                stringify ! ( lo_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_object ) ) . lo_witness as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_object ) , "::" ,
                stringify ! ( lo_witness ) ));
}
impl Clone for lock_object {
    fn clone(&self) -> Self { *self }
}
impl Default for lock_object {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct callout_list {
    pub lh_first: *mut callout,
}
#[test]
fn bindgen_test_layout_callout_list() {
    assert_eq!(::core::mem::size_of::<callout_list>() , 8usize , concat ! (
               "Size of: " , stringify ! ( callout_list ) ));
    assert_eq! (::core::mem::align_of::<callout_list>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( callout_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout_list ) ) . lh_first as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( callout_list ) , "::" ,
                stringify ! ( lh_first ) ));
}
impl Clone for callout_list {
    fn clone(&self) -> Self { *self }
}
impl Default for callout_list {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct callout_slist {
    pub slh_first: *mut callout,
}
#[test]
fn bindgen_test_layout_callout_slist() {
    assert_eq!(::core::mem::size_of::<callout_slist>() , 8usize , concat ! (
               "Size of: " , stringify ! ( callout_slist ) ));
    assert_eq! (::core::mem::align_of::<callout_slist>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( callout_slist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout_slist ) ) . slh_first as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( callout_slist ) , "::"
                , stringify ! ( slh_first ) ));
}
impl Clone for callout_slist {
    fn clone(&self) -> Self { *self }
}
impl Default for callout_slist {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct callout_tailq {
    pub tqh_first: *mut callout,
    pub tqh_last: *mut *mut callout,
}
#[test]
fn bindgen_test_layout_callout_tailq() {
    assert_eq!(::core::mem::size_of::<callout_tailq>() , 16usize , concat ! (
               "Size of: " , stringify ! ( callout_tailq ) ));
    assert_eq! (::core::mem::align_of::<callout_tailq>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( callout_tailq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout_tailq ) ) . tqh_first as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( callout_tailq ) , "::"
                , stringify ! ( tqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout_tailq ) ) . tqh_last as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( callout_tailq ) , "::"
                , stringify ! ( tqh_last ) ));
}
impl Clone for callout_tailq {
    fn clone(&self) -> Self { *self }
}
impl Default for callout_tailq {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct callout {
    pub c_links: callout__bindgen_ty_1,
    pub c_time: sbintime_t,
    pub c_precision: sbintime_t,
    pub c_arg: *mut ::kernel::sys::raw::c_void,
    pub c_func: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                *mut ::kernel::sys::raw::c_void)>,
    pub c_lock: *mut lock_object,
    pub c_flags: ::kernel::sys::raw::c_short,
    pub c_iflags: ::kernel::sys::raw::c_short,
    pub c_cpu: ::kernel::sys::raw::c_int,
}
#[repr(C)]
#[derive(Copy)]
pub union callout__bindgen_ty_1 {
    pub le: callout__bindgen_ty_1__bindgen_ty_1,
    pub sle: callout__bindgen_ty_1__bindgen_ty_2,
    pub tqe: callout__bindgen_ty_1__bindgen_ty_3,
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct callout__bindgen_ty_1__bindgen_ty_1 {
    pub le_next: *mut callout,
    pub le_prev: *mut *mut callout,
}
#[test]
fn bindgen_test_layout_callout__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<callout__bindgen_ty_1__bindgen_ty_1>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( callout__bindgen_ty_1__bindgen_ty_1
               ) ));
    assert_eq! (::core::mem::align_of::<callout__bindgen_ty_1__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                callout__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout__bindgen_ty_1__bindgen_ty_1 ) ) .
                le_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                callout__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! (
                le_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout__bindgen_ty_1__bindgen_ty_1 ) ) .
                le_prev as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                callout__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! (
                le_prev ) ));
}
impl Clone for callout__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for callout__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct callout__bindgen_ty_1__bindgen_ty_2 {
    pub sle_next: *mut callout,
}
#[test]
fn bindgen_test_layout_callout__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<callout__bindgen_ty_1__bindgen_ty_2>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( callout__bindgen_ty_1__bindgen_ty_2
               ) ));
    assert_eq! (::core::mem::align_of::<callout__bindgen_ty_1__bindgen_ty_2>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                callout__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout__bindgen_ty_1__bindgen_ty_2 ) ) .
                sle_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                callout__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify ! (
                sle_next ) ));
}
impl Clone for callout__bindgen_ty_1__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for callout__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct callout__bindgen_ty_1__bindgen_ty_3 {
    pub tqe_next: *mut callout,
    pub tqe_prev: *mut *mut callout,
}
#[test]
fn bindgen_test_layout_callout__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(::core::mem::size_of::<callout__bindgen_ty_1__bindgen_ty_3>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( callout__bindgen_ty_1__bindgen_ty_3
               ) ));
    assert_eq! (::core::mem::align_of::<callout__bindgen_ty_1__bindgen_ty_3>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                callout__bindgen_ty_1__bindgen_ty_3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout__bindgen_ty_1__bindgen_ty_3 ) ) .
                tqe_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                callout__bindgen_ty_1__bindgen_ty_3 ) , "::" , stringify ! (
                tqe_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout__bindgen_ty_1__bindgen_ty_3 ) ) .
                tqe_prev as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                callout__bindgen_ty_1__bindgen_ty_3 ) , "::" , stringify ! (
                tqe_prev ) ));
}
impl Clone for callout__bindgen_ty_1__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
impl Default for callout__bindgen_ty_1__bindgen_ty_3 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_callout__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<callout__bindgen_ty_1>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( callout__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<callout__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( callout__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout__bindgen_ty_1 ) ) . le as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( callout__bindgen_ty_1 )
                , "::" , stringify ! ( le ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout__bindgen_ty_1 ) ) . sle as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( callout__bindgen_ty_1 )
                , "::" , stringify ! ( sle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout__bindgen_ty_1 ) ) . tqe as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( callout__bindgen_ty_1 )
                , "::" , stringify ! ( tqe ) ));
}
impl Clone for callout__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for callout__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for callout__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "callout__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_callout() {
    assert_eq!(::core::mem::size_of::<callout>() , 64usize , concat ! (
               "Size of: " , stringify ! ( callout ) ));
    assert_eq! (::core::mem::align_of::<callout>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( callout ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout ) ) . c_links as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( callout ) , "::" ,
                stringify ! ( c_links ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout ) ) . c_time as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( callout ) , "::" ,
                stringify ! ( c_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout ) ) . c_precision as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( callout ) , "::" ,
                stringify ! ( c_precision ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout ) ) . c_arg as * const _ as usize
                } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( callout ) , "::" ,
                stringify ! ( c_arg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout ) ) . c_func as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( callout ) , "::" ,
                stringify ! ( c_func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout ) ) . c_lock as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( callout ) , "::" ,
                stringify ! ( c_lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout ) ) . c_flags as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( callout ) , "::" ,
                stringify ! ( c_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout ) ) . c_iflags as * const _ as
                usize } , 58usize , concat ! (
                "Alignment of field: " , stringify ! ( callout ) , "::" ,
                stringify ! ( c_iflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout ) ) . c_cpu as * const _ as usize
                } , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( callout ) , "::" ,
                stringify ! ( c_cpu ) ));
}
impl Clone for callout {
    fn clone(&self) -> Self { *self }
}
impl Default for callout {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for callout {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "callout {{ c_links: {:?}, c_time: {:?}, c_precision: {:?}, c_arg: {:?}, c_func: {:?}, c_lock: {:?}, c_flags: {:?}, c_iflags: {:?}, c_cpu: {:?} }}"
               , self . c_links , self . c_time , self . c_precision , self .
               c_arg , self . c_func , self . c_lock , self . c_flags , self .
               c_iflags , self . c_cpu)
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct callout_handle {
    pub callout: *mut callout,
}
#[test]
fn bindgen_test_layout_callout_handle() {
    assert_eq!(::core::mem::size_of::<callout_handle>() , 8usize , concat ! (
               "Size of: " , stringify ! ( callout_handle ) ));
    assert_eq! (::core::mem::align_of::<callout_handle>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( callout_handle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const callout_handle ) ) . callout as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( callout_handle ) , "::"
                , stringify ! ( callout ) ));
}
impl Clone for callout_handle {
    fn clone(&self) -> Self { *self }
}
impl Default for callout_handle {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    pub fn callout_init(arg1: *mut callout, arg2: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn _callout_init_lock(arg1: *mut callout, arg2: *mut lock_object,
                              arg3: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn callout_reset_sbt_on(arg1: *mut callout, arg2: sbintime_t,
                                arg3: sbintime_t,
                                arg4:
                                    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                                    *mut ::kernel::sys::raw::c_void)>,
                                arg5: *mut ::kernel::sys::raw::c_void,
                                arg6: ::kernel::sys::raw::c_int,
                                arg7: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn callout_schedule(arg1: *mut callout,
                            arg2: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn callout_schedule_on(arg1: *mut callout,
                               arg2: ::kernel::sys::raw::c_int,
                               arg3: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn _callout_stop_safe(arg1: *mut callout,
                              arg2: ::kernel::sys::raw::c_int,
                              arg3:
                                  ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                                  *mut ::kernel::sys::raw::c_void)>)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn callout_process(now: sbintime_t);
}
extern "C" {
    pub fn callout_when(sbt: sbintime_t, precision: sbintime_t,
                        flags: ::kernel::sys::raw::c_int,
                        sbt_res: *mut sbintime_t, prec_res: *mut sbintime_t);
}
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = __int_fast8_t;
pub type int_fast16_t = __int_fast16_t;
pub type int_fast32_t = __int_fast32_t;
pub type int_fast64_t = __int_fast64_t;
pub type uint_fast8_t = __uint_fast8_t;
pub type uint_fast16_t = __uint_fast16_t;
pub type uint_fast32_t = __uint_fast32_t;
pub type uint_fast64_t = __uint_fast64_t;
extern "C" {
    #[link_name = "cold"]
    pub static mut cold: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "suspend_blocked"]
    pub static mut suspend_blocked: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "rebooting"]
    pub static mut rebooting: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "panicstr"]
    pub static mut panicstr: *const ::kernel::sys::raw::c_char;
}
extern "C" {
    #[link_name = "version"]
    pub static mut version: [::kernel::sys::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "compiler_version"]
    pub static mut compiler_version: [::kernel::sys::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "copyright"]
    pub static mut copyright: [::kernel::sys::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "kstack_pages"]
    pub static mut kstack_pages: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "pagesizes"]
    pub static mut pagesizes: [u_long; 0usize];
}
extern "C" {
    #[link_name = "physmem"]
    pub static mut physmem: ::kernel::sys::raw::c_long;
}
extern "C" {
    #[link_name = "realmem"]
    pub static mut realmem: ::kernel::sys::raw::c_long;
}
extern "C" {
    #[link_name = "rootdevnames"]
    pub static mut rootdevnames: [*mut ::kernel::sys::raw::c_char; 2usize];
}
extern "C" {
    #[link_name = "boothowto"]
    pub static mut boothowto: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "bootverbose"]
    pub static mut bootverbose: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "maxusers"]
    pub static mut maxusers: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "ngroups_max"]
    pub static mut ngroups_max: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "vm_guest"]
    pub static mut vm_guest: ::kernel::sys::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VM_GUEST {
    VM_GUEST_NO = 0,
    VM_GUEST_VM = 1,
    VM_GUEST_XEN = 2,
    VM_GUEST_HV = 3,
    VM_GUEST_VMWARE = 4,
    VM_GUEST_KVM = 5,
    VM_GUEST_BHYVE = 6,
    VM_LAST = 7,
}
extern "C" {
    #[link_name = "osreldate"]
    pub static mut osreldate: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "envmode"]
    pub static mut envmode: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "hintmode"]
    pub static mut hintmode: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "dynamic_kenv"]
    pub static mut dynamic_kenv: ::kernel::sys::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mtx {
    pub lock_object: lock_object,
    pub mtx_lock: usize,
}
#[test]
fn bindgen_test_layout_mtx() {
    assert_eq!(::core::mem::size_of::<mtx>() , 32usize , concat ! (
               "Size of: " , stringify ! ( mtx ) ));
    assert_eq! (::core::mem::align_of::<mtx>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( mtx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mtx ) ) . lock_object as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mtx ) , "::" ,
                stringify ! ( lock_object ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mtx ) ) . mtx_lock as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( mtx ) , "::" ,
                stringify ! ( mtx_lock ) ));
}
impl Clone for mtx {
    fn clone(&self) -> Self { *self }
}
impl Default for mtx {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    #[link_name = "kenv_lock"]
    pub static mut kenv_lock: mtx;
}
extern "C" {
    #[link_name = "kern_envp"]
    pub static mut kern_envp: *mut ::kernel::sys::raw::c_char;
}
extern "C" {
    #[link_name = "static_env"]
    pub static mut static_env: [::kernel::sys::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "static_hints"]
    pub static mut static_hints: [::kernel::sys::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "kenvp"]
    pub static mut kenvp: *mut *mut ::kernel::sys::raw::c_char;
}
extern "C" {
    #[link_name = "zero_region"]
    pub static mut zero_region: *const ::kernel::sys::raw::c_void;
}
extern "C" {
    #[link_name = "unmapped_buf_allowed"]
    pub static mut unmapped_buf_allowed: ::kernel::sys::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct inpcb {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct malloc_type {
    pub ks_next: *mut malloc_type,
    pub ks_magic: u_long,
    pub ks_shortdesc: *const ::kernel::sys::raw::c_char,
    pub ks_handle: *mut ::kernel::sys::raw::c_void,
}
#[test]
fn bindgen_test_layout_malloc_type() {
    assert_eq!(::core::mem::size_of::<malloc_type>() , 32usize , concat ! (
               "Size of: " , stringify ! ( malloc_type ) ));
    assert_eq! (::core::mem::align_of::<malloc_type>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( malloc_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type ) ) . ks_next as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_type ) , "::" ,
                stringify ! ( ks_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type ) ) . ks_magic as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_type ) , "::" ,
                stringify ! ( ks_magic ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type ) ) . ks_shortdesc as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_type ) , "::" ,
                stringify ! ( ks_shortdesc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type ) ) . ks_handle as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_type ) , "::" ,
                stringify ! ( ks_handle ) ));
}
impl Clone for malloc_type {
    fn clone(&self) -> Self { *self }
}
impl Default for malloc_type {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct proc_ {
    pub p_list: proc__bindgen_ty_1,
    pub p_threads: proc__bindgen_ty_2,
    pub p_slock: mtx,
    pub p_ucred: *mut ucred,
    pub p_fd: *mut filedesc,
    pub p_fdtol: *mut filedesc_to_leader,
    pub p_stats: *mut pstats,
    pub p_limit: *mut plimit,
    pub p_limco: callout,
    pub p_sigacts: *mut sigacts,
    pub p_flag: ::kernel::sys::raw::c_int,
    pub p_flag2: ::kernel::sys::raw::c_int,
    pub p_state: proc__bindgen_ty_3,
    pub p_pid: pid_t,
    pub p_hash: proc__bindgen_ty_4,
    pub p_pglist: proc__bindgen_ty_5,
    pub p_pptr: *mut proc_,
    pub p_sibling: proc__bindgen_ty_6,
    pub p_children: proc__bindgen_ty_7,
    pub p_reaper: *mut proc_,
    pub p_reaplist: proc__bindgen_ty_8,
    pub p_reapsibling: proc__bindgen_ty_9,
    pub p_mtx: mtx,
    pub p_statmtx: mtx,
    pub p_itimmtx: mtx,
    pub p_profmtx: mtx,
    pub p_ksi: *mut ksiginfo,
    pub p_sigqueue: sigqueue_t,
    pub p_oppid: pid_t,
    pub p_vmspace: *mut vmspace,
    pub p_swtick: u_int,
    pub p_cowgen: u_int,
    pub p_realtimer: itimerval,
    pub p_ru: rusage,
    pub p_rux: rusage_ext,
    pub p_crux: rusage_ext,
    pub p_profthreads: ::kernel::sys::raw::c_int,
    pub p_exitthreads: ::kernel::sys::raw::c_int,
    pub p_traceflag: ::kernel::sys::raw::c_int,
    pub p_tracevp: *mut vnode,
    pub p_tracecred: *mut ucred,
    pub p_textvp: *mut vnode,
    pub p_lock: u_int,
    pub p_sigiolst: sigiolst,
    pub p_sigparent: ::kernel::sys::raw::c_int,
    pub p_sig: ::kernel::sys::raw::c_int,
    pub p_code: u_long,
    pub p_stops: u_int,
    pub p_stype: u_int,
    pub p_step: ::kernel::sys::raw::c_char,
    pub p_pfsflags: u_char,
    pub p_ptevents: u_int,
    pub p_nlminfo: *mut nlminfo,
    pub p_aioinfo: *mut kaioinfo,
    pub p_singlethread: *mut thread,
    pub p_suspcount: ::kernel::sys::raw::c_int,
    pub p_xthread: *mut thread,
    pub p_boundary_count: ::kernel::sys::raw::c_int,
    pub p_pendingcnt: ::kernel::sys::raw::c_int,
    pub p_itimers: *mut itimers,
    pub p_procdesc: *mut procdesc,
    pub p_treeflag: u_int,
    pub p_pendingexits: ::kernel::sys::raw::c_int,
    pub p_filemon: *mut filemon,
    pub p_pdeathsig: ::kernel::sys::raw::c_int,
    pub p_magic: u_int,
    pub p_osrel: ::kernel::sys::raw::c_int,
    pub p_comm: [::kernel::sys::raw::c_char; 20usize],
    pub p_sysent: *mut sysentvec,
    pub p_args: *mut pargs,
    pub p_cpulimit: rlim_t,
    pub p_nice: ::kernel::sys::raw::c_schar,
    pub p_fibnum: ::kernel::sys::raw::c_int,
    pub p_reapsubtree: pid_t,
    pub p_elf_machine: u16,
    pub p_elf_flags: u64,
    pub p_xexit: u_int,
    pub p_xsig: u_int,
    pub p_pgrp: *mut pgrp,
    pub p_klist: *mut knlist,
    pub p_numthreads: ::kernel::sys::raw::c_int,
    pub p_md: mdproc,
    pub p_itcallout: callout,
    pub p_acflag: u_short,
    pub p_peers: *mut proc_,
    pub p_leader: *mut proc_,
    pub p_emuldata: *mut ::kernel::sys::raw::c_void,
    pub p_label: *mut label,
    pub p_ktr: proc__bindgen_ty_10,
    pub p_mqnotifier: proc__bindgen_ty_11,
    pub p_dtrace: *mut kdtrace_proc,
    pub p_pwait: cv,
    pub p_dbgwait: cv,
    pub p_prev_runtime: u64,
    pub p_racct: *mut racct,
    pub p_throttled: ::kernel::sys::raw::c_int,
    pub p_orphan: proc__bindgen_ty_12,
    pub p_orphans: proc__bindgen_ty_13,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct proc__bindgen_ty_1 {
    pub le_next: *mut proc_,
    pub le_prev: *mut *mut proc_,
}
#[test]
fn bindgen_test_layout_proc__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<proc__bindgen_ty_1>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( proc__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<proc__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( proc__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc__bindgen_ty_1 ) ) . le_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( proc__bindgen_ty_1 ) ,
                "::" , stringify ! ( le_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc__bindgen_ty_1 ) ) . le_prev as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( proc__bindgen_ty_1 ) ,
                "::" , stringify ! ( le_prev ) ));
}
impl Clone for proc__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for proc__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct proc__bindgen_ty_2 {
    pub tqh_first: *mut thread,
    pub tqh_last: *mut *mut thread,
}
#[test]
fn bindgen_test_layout_proc__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<proc__bindgen_ty_2>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( proc__bindgen_ty_2 ) ));
    assert_eq! (::core::mem::align_of::<proc__bindgen_ty_2>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( proc__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc__bindgen_ty_2 ) ) . tqh_first as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( proc__bindgen_ty_2 ) ,
                "::" , stringify ! ( tqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc__bindgen_ty_2 ) ) . tqh_last as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( proc__bindgen_ty_2 ) ,
                "::" , stringify ! ( tqh_last ) ));
}
impl Clone for proc__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for proc__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub const proc__PRS_NEW: proc__bindgen_ty_3 = proc__bindgen_ty_3::PRS_NEW;
pub const proc__PRS_NORMAL: proc__bindgen_ty_3 =
    proc__bindgen_ty_3::PRS_NORMAL;
pub const proc__PRS_ZOMBIE: proc__bindgen_ty_3 =
    proc__bindgen_ty_3::PRS_ZOMBIE;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum proc__bindgen_ty_3 { PRS_NEW = 0, PRS_NORMAL = 1, PRS_ZOMBIE = 2, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct proc__bindgen_ty_4 {
    pub le_next: *mut proc_,
    pub le_prev: *mut *mut proc_,
}
#[test]
fn bindgen_test_layout_proc__bindgen_ty_4() {
    assert_eq!(::core::mem::size_of::<proc__bindgen_ty_4>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( proc__bindgen_ty_4 ) ));
    assert_eq! (::core::mem::align_of::<proc__bindgen_ty_4>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( proc__bindgen_ty_4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc__bindgen_ty_4 ) ) . le_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( proc__bindgen_ty_4 ) ,
                "::" , stringify ! ( le_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc__bindgen_ty_4 ) ) . le_prev as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( proc__bindgen_ty_4 ) ,
                "::" , stringify ! ( le_prev ) ));
}
impl Clone for proc__bindgen_ty_4 {
    fn clone(&self) -> Self { *self }
}
impl Default for proc__bindgen_ty_4 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct proc__bindgen_ty_5 {
    pub le_next: *mut proc_,
    pub le_prev: *mut *mut proc_,
}
#[test]
fn bindgen_test_layout_proc__bindgen_ty_5() {
    assert_eq!(::core::mem::size_of::<proc__bindgen_ty_5>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( proc__bindgen_ty_5 ) ));
    assert_eq! (::core::mem::align_of::<proc__bindgen_ty_5>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( proc__bindgen_ty_5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc__bindgen_ty_5 ) ) . le_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( proc__bindgen_ty_5 ) ,
                "::" , stringify ! ( le_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc__bindgen_ty_5 ) ) . le_prev as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( proc__bindgen_ty_5 ) ,
                "::" , stringify ! ( le_prev ) ));
}
impl Clone for proc__bindgen_ty_5 {
    fn clone(&self) -> Self { *self }
}
impl Default for proc__bindgen_ty_5 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct proc__bindgen_ty_6 {
    pub le_next: *mut proc_,
    pub le_prev: *mut *mut proc_,
}
#[test]
fn bindgen_test_layout_proc__bindgen_ty_6() {
    assert_eq!(::core::mem::size_of::<proc__bindgen_ty_6>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( proc__bindgen_ty_6 ) ));
    assert_eq! (::core::mem::align_of::<proc__bindgen_ty_6>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( proc__bindgen_ty_6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc__bindgen_ty_6 ) ) . le_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( proc__bindgen_ty_6 ) ,
                "::" , stringify ! ( le_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc__bindgen_ty_6 ) ) . le_prev as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( proc__bindgen_ty_6 ) ,
                "::" , stringify ! ( le_prev ) ));
}
impl Clone for proc__bindgen_ty_6 {
    fn clone(&self) -> Self { *self }
}
impl Default for proc__bindgen_ty_6 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct proc__bindgen_ty_7 {
    pub lh_first: *mut proc_,
}
#[test]
fn bindgen_test_layout_proc__bindgen_ty_7() {
    assert_eq!(::core::mem::size_of::<proc__bindgen_ty_7>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( proc__bindgen_ty_7 ) ));
    assert_eq! (::core::mem::align_of::<proc__bindgen_ty_7>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( proc__bindgen_ty_7 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc__bindgen_ty_7 ) ) . lh_first as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( proc__bindgen_ty_7 ) ,
                "::" , stringify ! ( lh_first ) ));
}
impl Clone for proc__bindgen_ty_7 {
    fn clone(&self) -> Self { *self }
}
impl Default for proc__bindgen_ty_7 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct proc__bindgen_ty_8 {
    pub lh_first: *mut proc_,
}
#[test]
fn bindgen_test_layout_proc__bindgen_ty_8() {
    assert_eq!(::core::mem::size_of::<proc__bindgen_ty_8>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( proc__bindgen_ty_8 ) ));
    assert_eq! (::core::mem::align_of::<proc__bindgen_ty_8>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( proc__bindgen_ty_8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc__bindgen_ty_8 ) ) . lh_first as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( proc__bindgen_ty_8 ) ,
                "::" , stringify ! ( lh_first ) ));
}
impl Clone for proc__bindgen_ty_8 {
    fn clone(&self) -> Self { *self }
}
impl Default for proc__bindgen_ty_8 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct proc__bindgen_ty_9 {
    pub le_next: *mut proc_,
    pub le_prev: *mut *mut proc_,
}
#[test]
fn bindgen_test_layout_proc__bindgen_ty_9() {
    assert_eq!(::core::mem::size_of::<proc__bindgen_ty_9>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( proc__bindgen_ty_9 ) ));
    assert_eq! (::core::mem::align_of::<proc__bindgen_ty_9>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( proc__bindgen_ty_9 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc__bindgen_ty_9 ) ) . le_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( proc__bindgen_ty_9 ) ,
                "::" , stringify ! ( le_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc__bindgen_ty_9 ) ) . le_prev as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( proc__bindgen_ty_9 ) ,
                "::" , stringify ! ( le_prev ) ));
}
impl Clone for proc__bindgen_ty_9 {
    fn clone(&self) -> Self { *self }
}
impl Default for proc__bindgen_ty_9 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct proc__bindgen_ty_10 {
    pub stqh_first: *mut ktr_request,
    pub stqh_last: *mut *mut ktr_request,
}
#[test]
fn bindgen_test_layout_proc__bindgen_ty_10() {
    assert_eq!(::core::mem::size_of::<proc__bindgen_ty_10>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( proc__bindgen_ty_10 )
               ));
    assert_eq! (::core::mem::align_of::<proc__bindgen_ty_10>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( proc__bindgen_ty_10 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc__bindgen_ty_10 ) ) . stqh_first as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( proc__bindgen_ty_10 ) ,
                "::" , stringify ! ( stqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc__bindgen_ty_10 ) ) . stqh_last as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( proc__bindgen_ty_10 ) ,
                "::" , stringify ! ( stqh_last ) ));
}
impl Clone for proc__bindgen_ty_10 {
    fn clone(&self) -> Self { *self }
}
impl Default for proc__bindgen_ty_10 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct proc__bindgen_ty_11 {
    pub lh_first: *mut mqueue_notifier,
}
#[test]
fn bindgen_test_layout_proc__bindgen_ty_11() {
    assert_eq!(::core::mem::size_of::<proc__bindgen_ty_11>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( proc__bindgen_ty_11 ) ));
    assert_eq! (::core::mem::align_of::<proc__bindgen_ty_11>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( proc__bindgen_ty_11 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc__bindgen_ty_11 ) ) . lh_first as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( proc__bindgen_ty_11 ) ,
                "::" , stringify ! ( lh_first ) ));
}
impl Clone for proc__bindgen_ty_11 {
    fn clone(&self) -> Self { *self }
}
impl Default for proc__bindgen_ty_11 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct proc__bindgen_ty_12 {
    pub le_next: *mut proc_,
    pub le_prev: *mut *mut proc_,
}
#[test]
fn bindgen_test_layout_proc__bindgen_ty_12() {
    assert_eq!(::core::mem::size_of::<proc__bindgen_ty_12>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( proc__bindgen_ty_12 )
               ));
    assert_eq! (::core::mem::align_of::<proc__bindgen_ty_12>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( proc__bindgen_ty_12 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc__bindgen_ty_12 ) ) . le_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( proc__bindgen_ty_12 ) ,
                "::" , stringify ! ( le_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc__bindgen_ty_12 ) ) . le_prev as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( proc__bindgen_ty_12 ) ,
                "::" , stringify ! ( le_prev ) ));
}
impl Clone for proc__bindgen_ty_12 {
    fn clone(&self) -> Self { *self }
}
impl Default for proc__bindgen_ty_12 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct proc__bindgen_ty_13 {
    pub lh_first: *mut proc_,
}
#[test]
fn bindgen_test_layout_proc__bindgen_ty_13() {
    assert_eq!(::core::mem::size_of::<proc__bindgen_ty_13>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( proc__bindgen_ty_13 ) ));
    assert_eq! (::core::mem::align_of::<proc__bindgen_ty_13>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( proc__bindgen_ty_13 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc__bindgen_ty_13 ) ) . lh_first as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( proc__bindgen_ty_13 ) ,
                "::" , stringify ! ( lh_first ) ));
}
impl Clone for proc__bindgen_ty_13 {
    fn clone(&self) -> Self { *self }
}
impl Default for proc__bindgen_ty_13 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_proc_() {
    assert_eq!(::core::mem::size_of::<proc_>() , 1336usize , concat ! (
               "Size of: " , stringify ! ( proc_ ) ));
    assert_eq! (::core::mem::align_of::<proc_>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( proc_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_list as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_threads as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_threads ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_slock as * const _ as usize
                } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_slock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_ucred as * const _ as usize
                } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_ucred ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_fd as * const _ as usize }
                , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_fd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_fdtol as * const _ as usize
                } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_fdtol ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_stats as * const _ as usize
                } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_stats ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_limit as * const _ as usize
                } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_limit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_limco as * const _ as usize
                } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_limco ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_sigacts as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_sigacts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_flag as * const _ as usize
                } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_flag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_flag2 as * const _ as usize
                } , 180usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_flag2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_state as * const _ as usize
                } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_pid as * const _ as usize }
                , 188usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_pid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_hash as * const _ as usize
                } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_hash ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_pglist as * const _ as
                usize } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_pglist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_pptr as * const _ as usize
                } , 224usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_pptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_sibling as * const _ as
                usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_sibling ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_children as * const _ as
                usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_children ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_reaper as * const _ as
                usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_reaper ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_reaplist as * const _ as
                usize } , 264usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_reaplist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_reapsibling as * const _ as
                usize } , 272usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_reapsibling ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_mtx as * const _ as usize }
                , 288usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_mtx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_statmtx as * const _ as
                usize } , 320usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_statmtx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_itimmtx as * const _ as
                usize } , 352usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_itimmtx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_profmtx as * const _ as
                usize } , 384usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_profmtx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_ksi as * const _ as usize }
                , 416usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_ksi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_sigqueue as * const _ as
                usize } , 424usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_sigqueue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_oppid as * const _ as usize
                } , 504usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_oppid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_vmspace as * const _ as
                usize } , 512usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_vmspace ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_swtick as * const _ as
                usize } , 520usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_swtick ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_cowgen as * const _ as
                usize } , 524usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_cowgen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_realtimer as * const _ as
                usize } , 528usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_realtimer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_ru as * const _ as usize }
                , 560usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_ru ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_rux as * const _ as usize }
                , 704usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_rux ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_crux as * const _ as usize
                } , 760usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_crux ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_profthreads as * const _ as
                usize } , 816usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_profthreads ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_exitthreads as * const _ as
                usize } , 820usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_exitthreads ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_traceflag as * const _ as
                usize } , 824usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_traceflag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_tracevp as * const _ as
                usize } , 832usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_tracevp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_tracecred as * const _ as
                usize } , 840usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_tracecred ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_textvp as * const _ as
                usize } , 848usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_textvp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_lock as * const _ as usize
                } , 856usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_sigiolst as * const _ as
                usize } , 864usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_sigiolst ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_sigparent as * const _ as
                usize } , 872usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_sigparent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_sig as * const _ as usize }
                , 876usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_code as * const _ as usize
                } , 880usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_code ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_stops as * const _ as usize
                } , 888usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_stops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_stype as * const _ as usize
                } , 892usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_stype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_step as * const _ as usize
                } , 896usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_step ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_pfsflags as * const _ as
                usize } , 897usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_pfsflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_ptevents as * const _ as
                usize } , 900usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_ptevents ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_nlminfo as * const _ as
                usize } , 904usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_nlminfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_aioinfo as * const _ as
                usize } , 912usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_aioinfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_singlethread as * const _
                as usize } , 920usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_singlethread ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_suspcount as * const _ as
                usize } , 928usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_suspcount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_xthread as * const _ as
                usize } , 936usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_xthread ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_boundary_count as * const _
                as usize } , 944usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_boundary_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_pendingcnt as * const _ as
                usize } , 948usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_pendingcnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_itimers as * const _ as
                usize } , 952usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_itimers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_procdesc as * const _ as
                usize } , 960usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_procdesc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_treeflag as * const _ as
                usize } , 968usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_treeflag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_pendingexits as * const _
                as usize } , 972usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_pendingexits ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_filemon as * const _ as
                usize } , 976usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_filemon ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_pdeathsig as * const _ as
                usize } , 984usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_pdeathsig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_magic as * const _ as usize
                } , 988usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_magic ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_osrel as * const _ as usize
                } , 992usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_osrel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_comm as * const _ as usize
                } , 996usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_comm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_sysent as * const _ as
                usize } , 1016usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_sysent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_args as * const _ as usize
                } , 1024usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_args ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_cpulimit as * const _ as
                usize } , 1032usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_cpulimit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_nice as * const _ as usize
                } , 1040usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_nice ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_fibnum as * const _ as
                usize } , 1044usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_fibnum ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_reapsubtree as * const _ as
                usize } , 1048usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_reapsubtree ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_elf_machine as * const _ as
                usize } , 1052usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_elf_machine ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_elf_flags as * const _ as
                usize } , 1056usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_elf_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_xexit as * const _ as usize
                } , 1064usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_xexit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_xsig as * const _ as usize
                } , 1068usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_xsig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_pgrp as * const _ as usize
                } , 1072usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_pgrp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_klist as * const _ as usize
                } , 1080usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_klist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_numthreads as * const _ as
                usize } , 1088usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_numthreads ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_md as * const _ as usize }
                , 1096usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_md ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_itcallout as * const _ as
                usize } , 1120usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_itcallout ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_acflag as * const _ as
                usize } , 1184usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_acflag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_peers as * const _ as usize
                } , 1192usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_peers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_leader as * const _ as
                usize } , 1200usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_leader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_emuldata as * const _ as
                usize } , 1208usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_emuldata ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_label as * const _ as usize
                } , 1216usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_label ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_ktr as * const _ as usize }
                , 1224usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_ktr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_mqnotifier as * const _ as
                usize } , 1240usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_mqnotifier ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_dtrace as * const _ as
                usize } , 1248usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_dtrace ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_pwait as * const _ as usize
                } , 1256usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_pwait ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_dbgwait as * const _ as
                usize } , 1272usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_dbgwait ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_prev_runtime as * const _
                as usize } , 1288usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_prev_runtime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_racct as * const _ as usize
                } , 1296usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_racct ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_throttled as * const _ as
                usize } , 1304usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_throttled ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_orphan as * const _ as
                usize } , 1312usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_orphan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ ) ) . p_orphans as * const _ as
                usize } , 1328usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ ) , "::" ,
                stringify ! ( p_orphans ) ));
}
impl Clone for proc_ {
    fn clone(&self) -> Self { *self }
}
impl Default for proc_ {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for proc_ {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "proc_ {{ p_list: {:?}, p_threads: {:?}, p_slock: {:?}, p_ucred: {:?}, p_fd: {:?}, p_fdtol: {:?}, p_stats: {:?}, p_limit: {:?}, p_limco: {:?}, p_sigacts: {:?}, p_flag: {:?}, p_flag2: {:?}, p_state: {:?}, p_pid: {:?}, p_hash: {:?}, p_pglist: {:?}, p_pptr: {:?}, p_sibling: {:?}, p_children: {:?}, p_reaper: {:?}, p_reaplist: {:?}, p_reapsibling: {:?}, p_mtx: {:?}, p_statmtx: {:?}, p_itimmtx: {:?}, p_profmtx: {:?}, p_ksi: {:?}, p_sigqueue: {:?}, p_oppid: {:?}, p_vmspace: {:?}, p_swtick: {:?}, p_cowgen: {:?}, p_realtimer: {:?}, p_ru: {:?}, p_rux: {:?}, p_crux: {:?}, p_profthreads: {:?}, p_exitthreads: {:?}, p_traceflag: {:?}, p_tracevp: {:?}, p_tracecred: {:?}, p_textvp: {:?}, p_lock: {:?}, p_sigiolst: {:?}, p_sigparent: {:?}, p_sig: {:?}, p_code: {:?}, p_stops: {:?}, p_stype: {:?}, p_step: {:?}, p_pfsflags: {:?}, p_ptevents: {:?}, p_nlminfo: {:?}, p_aioinfo: {:?}, p_singlethread: {:?}, p_suspcount: {:?}, p_xthread: {:?}, p_boundary_count: {:?}, p_pendingcnt: {:?}, p_itimers: {:?}, p_procdesc: {:?}, p_treeflag: {:?}, p_pendingexits: {:?}, p_filemon: {:?}, p_pdeathsig: {:?}, p_magic: {:?}, p_osrel: {:?}, p_comm: {:?}, p_sysent: {:?}, p_args: {:?}, p_cpulimit: {:?}, p_nice: {:?}, p_fibnum: {:?}, p_reapsubtree: {:?}, p_elf_machine: {:?}, p_elf_flags: {:?}, p_xexit: {:?}, p_xsig: {:?}, p_pgrp: {:?}, p_klist: {:?}, p_numthreads: {:?}, p_md: {:?}, p_itcallout: {:?}, p_acflag: {:?}, p_peers: {:?}, p_leader: {:?}, p_emuldata: {:?}, p_label: {:?}, p_ktr: {:?}, p_mqnotifier: {:?}, p_dtrace: {:?}, p_pwait: {:?}, p_dbgwait: {:?}, p_prev_runtime: {:?}, p_racct: {:?}, p_throttled: {:?}, p_orphan: {:?}, p_orphans: {:?} }}"
               , self . p_list , self . p_threads , self . p_slock , self .
               p_ucred , self . p_fd , self . p_fdtol , self . p_stats , self
               . p_limit , self . p_limco , self . p_sigacts , self . p_flag ,
               self . p_flag2 , self . p_state , self . p_pid , self . p_hash
               , self . p_pglist , self . p_pptr , self . p_sibling , self .
               p_children , self . p_reaper , self . p_reaplist , self .
               p_reapsibling , self . p_mtx , self . p_statmtx , self .
               p_itimmtx , self . p_profmtx , self . p_ksi , self . p_sigqueue
               , self . p_oppid , self . p_vmspace , self . p_swtick , self .
               p_cowgen , self . p_realtimer , self . p_ru , self . p_rux ,
               self . p_crux , self . p_profthreads , self . p_exitthreads ,
               self . p_traceflag , self . p_tracevp , self . p_tracecred ,
               self . p_textvp , self . p_lock , self . p_sigiolst , self .
               p_sigparent , self . p_sig , self . p_code , self . p_stops ,
               self . p_stype , self . p_step , self . p_pfsflags , self .
               p_ptevents , self . p_nlminfo , self . p_aioinfo , self .
               p_singlethread , self . p_suspcount , self . p_xthread , self .
               p_boundary_count , self . p_pendingcnt , self . p_itimers ,
               self . p_procdesc , self . p_treeflag , self . p_pendingexits ,
               self . p_filemon , self . p_pdeathsig , self . p_magic , self .
               p_osrel , self . p_comm , self . p_sysent , self . p_args ,
               self . p_cpulimit , self . p_nice , self . p_fibnum , self .
               p_reapsubtree , self . p_elf_machine , self . p_elf_flags ,
               self . p_xexit , self . p_xsig , self . p_pgrp , self . p_klist
               , self . p_numthreads , self . p_md , self . p_itcallout , self
               . p_acflag , self . p_peers , self . p_leader , self .
               p_emuldata , self . p_label , self . p_ktr , self .
               p_mqnotifier , self . p_dtrace , self . p_pwait , self .
               p_dbgwait , self . p_prev_runtime , self . p_racct , self .
               p_throttled , self . p_orphan , self . p_orphans)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct socket {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy)]
pub struct thread {
    pub td_lock: *mut mtx,
    pub td_proc: *mut proc_,
    pub td_plist: thread__bindgen_ty_1,
    pub td_runq: thread__bindgen_ty_2,
    pub td_slpq: thread__bindgen_ty_3,
    pub td_lockq: thread__bindgen_ty_4,
    pub td_hash: thread__bindgen_ty_5,
    pub td_cpuset: *mut cpuset,
    pub td_domain: domainset_ref,
    pub td_sel: *mut seltd,
    pub td_sleepqueue: *mut sleepqueue,
    pub td_turnstile: *mut turnstile,
    pub td_rlqe: *mut rl_q_entry,
    pub td_umtxq: *mut umtx_q,
    pub td_tid: lwpid_t,
    pub td_sigqueue: sigqueue_t,
    pub td_lend_user_pri: u_char,
    pub td_epochnest: u_char,
    pub td_flags: ::kernel::sys::raw::c_int,
    pub td_inhibitors: ::kernel::sys::raw::c_int,
    pub td_pflags: ::kernel::sys::raw::c_int,
    pub td_dupfd: ::kernel::sys::raw::c_int,
    pub td_sqqueue: ::kernel::sys::raw::c_int,
    pub td_wchan: *mut ::kernel::sys::raw::c_void,
    pub td_wmesg: *const ::kernel::sys::raw::c_char,
    pub td_owepreempt: u_char,
    pub td_tsqueue: u_char,
    pub td_locks: ::kernel::sys::raw::c_short,
    pub td_rw_rlocks: ::kernel::sys::raw::c_short,
    pub td_sx_slocks: ::kernel::sys::raw::c_short,
    pub td_lk_slocks: ::kernel::sys::raw::c_short,
    pub td_stopsched: ::kernel::sys::raw::c_short,
    pub td_blocked: *mut turnstile,
    pub td_lockname: *const ::kernel::sys::raw::c_char,
    pub td_contested: thread__bindgen_ty_6,
    pub td_sleeplocks: *mut lock_list_entry,
    pub td_intr_nesting_level: ::kernel::sys::raw::c_int,
    pub td_pinned: ::kernel::sys::raw::c_int,
    pub td_ucred: *mut ucred,
    pub td_limit: *mut plimit,
    pub td_slptick: ::kernel::sys::raw::c_int,
    pub td_blktick: ::kernel::sys::raw::c_int,
    pub td_swvoltick: ::kernel::sys::raw::c_int,
    pub td_swinvoltick: ::kernel::sys::raw::c_int,
    pub td_cow: u_int,
    pub td_ru: rusage,
    pub td_rux: rusage_ext,
    pub td_incruntime: u64,
    pub td_runtime: u64,
    pub td_pticks: u_int,
    pub td_sticks: u_int,
    pub td_iticks: u_int,
    pub td_uticks: u_int,
    pub td_intrval: ::kernel::sys::raw::c_int,
    pub td_oldsigmask: sigset_t,
    pub td_generation: u_int,
    pub td_sigstk: stack_t,
    pub td_xsig: ::kernel::sys::raw::c_int,
    pub td_profil_addr: u_long,
    pub td_profil_ticks: u_int,
    pub td_name: [::kernel::sys::raw::c_char; 20usize],
    pub td_fpop: *mut file,
    pub td_dbgflags: ::kernel::sys::raw::c_int,
    pub td_si: siginfo_t,
    pub td_ng_outbound: ::kernel::sys::raw::c_int,
    pub td_osd: osd,
    pub td_map_def_user: *mut vm_map_entry,
    pub td_dbg_forked: pid_t,
    pub td_vp_reserv: u_int,
    pub td_no_sleeping: ::kernel::sys::raw::c_int,
    pub td_su: *mut ::kernel::sys::raw::c_void,
    pub td_sleeptimo: sbintime_t,
    pub td_rtcgen: ::kernel::sys::raw::c_int,
    pub td_vslock_sz: usize,
    pub td_sigmask: sigset_t,
    pub td_rqindex: u_char,
    pub td_base_pri: u_char,
    pub td_priority: u_char,
    pub td_pri_class: u_char,
    pub td_user_pri: u_char,
    pub td_base_user_pri: u_char,
    pub td_pre_epoch_prio: u_char,
    pub td_rb_list: usize,
    pub td_rbp_list: usize,
    pub td_rb_inact: usize,
    pub td_sa: syscall_args,
    pub td_pcb: *mut pcb,
    pub td_state: thread__bindgen_ty_7,
    pub td_uretoff: thread__bindgen_ty_8,
    pub td_cowgen: u_int,
    pub td_slpcallout: callout,
    pub td_frame: *mut trapframe,
    pub td_kstack_obj: *mut vm_object,
    pub td_kstack: vm_offset_t,
    pub td_kstack_pages: ::kernel::sys::raw::c_int,
    pub td_critnest: u_int,
    pub td_md: mdthread,
    pub td_ar: *mut kaudit_record,
    pub td_lprof: [lpohead; 2usize],
    pub td_dtrace: *mut kdtrace_thread,
    pub td_errno: ::kernel::sys::raw::c_int,
    pub td_vnet: *mut vnet,
    pub td_vnet_lpush: *const ::kernel::sys::raw::c_char,
    pub td_intr_frame: *mut trapframe,
    pub td_rfppwait_p: *mut proc_,
    pub td_ma: *mut *mut vm_page,
    pub td_ma_cnt: ::kernel::sys::raw::c_int,
    pub td_emuldata: *mut ::kernel::sys::raw::c_void,
    pub td_lastcpu: ::kernel::sys::raw::c_int,
    pub td_oncpu: ::kernel::sys::raw::c_int,
    pub td_lkpi_task: *mut ::kernel::sys::raw::c_void,
    pub td_epochq: thread__bindgen_ty_9,
    pub td_epoch_section: epoch_section_t,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct thread__bindgen_ty_1 {
    pub tqe_next: *mut thread,
    pub tqe_prev: *mut *mut thread,
}
#[test]
fn bindgen_test_layout_thread__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<thread__bindgen_ty_1>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( thread__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<thread__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( thread__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread__bindgen_ty_1 ) ) . tqe_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( thread__bindgen_ty_1 )
                , "::" , stringify ! ( tqe_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread__bindgen_ty_1 ) ) . tqe_prev as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( thread__bindgen_ty_1 )
                , "::" , stringify ! ( tqe_prev ) ));
}
impl Clone for thread__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for thread__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct thread__bindgen_ty_2 {
    pub tqe_next: *mut thread,
    pub tqe_prev: *mut *mut thread,
}
#[test]
fn bindgen_test_layout_thread__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<thread__bindgen_ty_2>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( thread__bindgen_ty_2 )
               ));
    assert_eq! (::core::mem::align_of::<thread__bindgen_ty_2>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( thread__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread__bindgen_ty_2 ) ) . tqe_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( thread__bindgen_ty_2 )
                , "::" , stringify ! ( tqe_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread__bindgen_ty_2 ) ) . tqe_prev as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( thread__bindgen_ty_2 )
                , "::" , stringify ! ( tqe_prev ) ));
}
impl Clone for thread__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for thread__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct thread__bindgen_ty_3 {
    pub tqe_next: *mut thread,
    pub tqe_prev: *mut *mut thread,
}
#[test]
fn bindgen_test_layout_thread__bindgen_ty_3() {
    assert_eq!(::core::mem::size_of::<thread__bindgen_ty_3>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( thread__bindgen_ty_3 )
               ));
    assert_eq! (::core::mem::align_of::<thread__bindgen_ty_3>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( thread__bindgen_ty_3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread__bindgen_ty_3 ) ) . tqe_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( thread__bindgen_ty_3 )
                , "::" , stringify ! ( tqe_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread__bindgen_ty_3 ) ) . tqe_prev as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( thread__bindgen_ty_3 )
                , "::" , stringify ! ( tqe_prev ) ));
}
impl Clone for thread__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
impl Default for thread__bindgen_ty_3 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct thread__bindgen_ty_4 {
    pub tqe_next: *mut thread,
    pub tqe_prev: *mut *mut thread,
}
#[test]
fn bindgen_test_layout_thread__bindgen_ty_4() {
    assert_eq!(::core::mem::size_of::<thread__bindgen_ty_4>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( thread__bindgen_ty_4 )
               ));
    assert_eq! (::core::mem::align_of::<thread__bindgen_ty_4>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( thread__bindgen_ty_4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread__bindgen_ty_4 ) ) . tqe_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( thread__bindgen_ty_4 )
                , "::" , stringify ! ( tqe_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread__bindgen_ty_4 ) ) . tqe_prev as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( thread__bindgen_ty_4 )
                , "::" , stringify ! ( tqe_prev ) ));
}
impl Clone for thread__bindgen_ty_4 {
    fn clone(&self) -> Self { *self }
}
impl Default for thread__bindgen_ty_4 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct thread__bindgen_ty_5 {
    pub le_next: *mut thread,
    pub le_prev: *mut *mut thread,
}
#[test]
fn bindgen_test_layout_thread__bindgen_ty_5() {
    assert_eq!(::core::mem::size_of::<thread__bindgen_ty_5>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( thread__bindgen_ty_5 )
               ));
    assert_eq! (::core::mem::align_of::<thread__bindgen_ty_5>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( thread__bindgen_ty_5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread__bindgen_ty_5 ) ) . le_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( thread__bindgen_ty_5 )
                , "::" , stringify ! ( le_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread__bindgen_ty_5 ) ) . le_prev as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( thread__bindgen_ty_5 )
                , "::" , stringify ! ( le_prev ) ));
}
impl Clone for thread__bindgen_ty_5 {
    fn clone(&self) -> Self { *self }
}
impl Default for thread__bindgen_ty_5 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct thread__bindgen_ty_6 {
    pub lh_first: *mut turnstile,
}
#[test]
fn bindgen_test_layout_thread__bindgen_ty_6() {
    assert_eq!(::core::mem::size_of::<thread__bindgen_ty_6>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( thread__bindgen_ty_6 )
               ));
    assert_eq! (::core::mem::align_of::<thread__bindgen_ty_6>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( thread__bindgen_ty_6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread__bindgen_ty_6 ) ) . lh_first as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( thread__bindgen_ty_6 )
                , "::" , stringify ! ( lh_first ) ));
}
impl Clone for thread__bindgen_ty_6 {
    fn clone(&self) -> Self { *self }
}
impl Default for thread__bindgen_ty_6 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub const thread_TDS_INACTIVE: thread__bindgen_ty_7 =
    thread__bindgen_ty_7::TDS_INACTIVE;
pub const thread_TDS_INHIBITED: thread__bindgen_ty_7 =
    thread__bindgen_ty_7::TDS_INHIBITED;
pub const thread_TDS_CAN_RUN: thread__bindgen_ty_7 =
    thread__bindgen_ty_7::TDS_CAN_RUN;
pub const thread_TDS_RUNQ: thread__bindgen_ty_7 =
    thread__bindgen_ty_7::TDS_RUNQ;
pub const thread_TDS_RUNNING: thread__bindgen_ty_7 =
    thread__bindgen_ty_7::TDS_RUNNING;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum thread__bindgen_ty_7 {
    TDS_INACTIVE = 0,
    TDS_INHIBITED = 1,
    TDS_CAN_RUN = 2,
    TDS_RUNQ = 3,
    TDS_RUNNING = 4,
}
#[repr(C)]
#[derive(Copy)]
pub union thread__bindgen_ty_8 {
    pub tdu_retval: [register_t; 2usize],
    pub tdu_off: off_t,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_thread__bindgen_ty_8() {
    assert_eq!(::core::mem::size_of::<thread__bindgen_ty_8>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( thread__bindgen_ty_8 )
               ));
    assert_eq! (::core::mem::align_of::<thread__bindgen_ty_8>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( thread__bindgen_ty_8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread__bindgen_ty_8 ) ) . tdu_retval as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( thread__bindgen_ty_8 )
                , "::" , stringify ! ( tdu_retval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread__bindgen_ty_8 ) ) . tdu_off as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( thread__bindgen_ty_8 )
                , "::" , stringify ! ( tdu_off ) ));
}
impl Clone for thread__bindgen_ty_8 {
    fn clone(&self) -> Self { *self }
}
impl Default for thread__bindgen_ty_8 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for thread__bindgen_ty_8 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "thread__bindgen_ty_8 {{ union }}")
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct thread__bindgen_ty_9 {
    pub tqe_next: *mut thread,
    pub tqe_prev: *mut *mut thread,
}
#[test]
fn bindgen_test_layout_thread__bindgen_ty_9() {
    assert_eq!(::core::mem::size_of::<thread__bindgen_ty_9>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( thread__bindgen_ty_9 )
               ));
    assert_eq! (::core::mem::align_of::<thread__bindgen_ty_9>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( thread__bindgen_ty_9 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread__bindgen_ty_9 ) ) . tqe_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( thread__bindgen_ty_9 )
                , "::" , stringify ! ( tqe_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread__bindgen_ty_9 ) ) . tqe_prev as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( thread__bindgen_ty_9 )
                , "::" , stringify ! ( tqe_prev ) ));
}
impl Clone for thread__bindgen_ty_9 {
    fn clone(&self) -> Self { *self }
}
impl Default for thread__bindgen_ty_9 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_thread() {
    assert_eq!(::core::mem::size_of::<thread>() , 1352usize , concat ! (
               "Size of: " , stringify ! ( thread ) ));
    assert_eq! (::core::mem::align_of::<thread>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( thread ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_lock as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_proc as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_proc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_plist as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_plist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_runq as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_runq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_slpq as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_slpq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_lockq as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_lockq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_hash as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_hash ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_cpuset as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_cpuset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_domain as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_domain ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_sel as * const _ as usize
                } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_sel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_sleepqueue as * const _
                as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_sleepqueue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_turnstile as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_turnstile ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_rlqe as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_rlqe ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_umtxq as * const _ as
                usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_umtxq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_tid as * const _ as usize
                } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_tid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_sigqueue as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_sigqueue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_lend_user_pri as * const
                _ as usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_lend_user_pri ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_epochnest as * const _ as
                usize } , 249usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_epochnest ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_flags as * const _ as
                usize } , 252usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_inhibitors as * const _
                as usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_inhibitors ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_pflags as * const _ as
                usize } , 260usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_pflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_dupfd as * const _ as
                usize } , 264usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_dupfd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_sqqueue as * const _ as
                usize } , 268usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_sqqueue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_wchan as * const _ as
                usize } , 272usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_wchan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_wmesg as * const _ as
                usize } , 280usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_wmesg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_owepreempt as * const _
                as usize } , 288usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_owepreempt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_tsqueue as * const _ as
                usize } , 289usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_tsqueue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_locks as * const _ as
                usize } , 290usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_locks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_rw_rlocks as * const _ as
                usize } , 292usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_rw_rlocks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_sx_slocks as * const _ as
                usize } , 294usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_sx_slocks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_lk_slocks as * const _ as
                usize } , 296usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_lk_slocks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_stopsched as * const _ as
                usize } , 298usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_stopsched ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_blocked as * const _ as
                usize } , 304usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_blocked ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_lockname as * const _ as
                usize } , 312usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_lockname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_contested as * const _ as
                usize } , 320usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_contested ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_sleeplocks as * const _
                as usize } , 328usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_sleeplocks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_intr_nesting_level as *
                const _ as usize } , 336usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_intr_nesting_level ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_pinned as * const _ as
                usize } , 340usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_pinned ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_ucred as * const _ as
                usize } , 344usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_ucred ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_limit as * const _ as
                usize } , 352usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_limit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_slptick as * const _ as
                usize } , 360usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_slptick ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_blktick as * const _ as
                usize } , 364usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_blktick ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_swvoltick as * const _ as
                usize } , 368usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_swvoltick ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_swinvoltick as * const _
                as usize } , 372usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_swinvoltick ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_cow as * const _ as usize
                } , 376usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_cow ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_ru as * const _ as usize
                } , 384usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_ru ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_rux as * const _ as usize
                } , 528usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_rux ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_incruntime as * const _
                as usize } , 584usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_incruntime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_runtime as * const _ as
                usize } , 592usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_runtime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_pticks as * const _ as
                usize } , 600usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_pticks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_sticks as * const _ as
                usize } , 604usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_sticks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_iticks as * const _ as
                usize } , 608usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_iticks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_uticks as * const _ as
                usize } , 612usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_uticks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_intrval as * const _ as
                usize } , 616usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_intrval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_oldsigmask as * const _
                as usize } , 620usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_oldsigmask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_generation as * const _
                as usize } , 636usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_generation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_sigstk as * const _ as
                usize } , 640usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_sigstk ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_xsig as * const _ as
                usize } , 664usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_xsig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_profil_addr as * const _
                as usize } , 672usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_profil_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_profil_ticks as * const _
                as usize } , 680usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_profil_ticks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_name as * const _ as
                usize } , 684usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_fpop as * const _ as
                usize } , 704usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_fpop ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_dbgflags as * const _ as
                usize } , 712usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_dbgflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_si as * const _ as usize
                } , 720usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_si ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_ng_outbound as * const _
                as usize } , 800usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_ng_outbound ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_osd as * const _ as usize
                } , 808usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_osd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_map_def_user as * const _
                as usize } , 840usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_map_def_user ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_dbg_forked as * const _
                as usize } , 848usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_dbg_forked ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_vp_reserv as * const _ as
                usize } , 852usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_vp_reserv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_no_sleeping as * const _
                as usize } , 856usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_no_sleeping ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_su as * const _ as usize
                } , 864usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_su ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_sleeptimo as * const _ as
                usize } , 872usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_sleeptimo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_rtcgen as * const _ as
                usize } , 880usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_rtcgen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_vslock_sz as * const _ as
                usize } , 888usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_vslock_sz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_sigmask as * const _ as
                usize } , 896usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_sigmask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_rqindex as * const _ as
                usize } , 912usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_rqindex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_base_pri as * const _ as
                usize } , 913usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_base_pri ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_priority as * const _ as
                usize } , 914usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_priority ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_pri_class as * const _ as
                usize } , 915usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_pri_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_user_pri as * const _ as
                usize } , 916usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_user_pri ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_base_user_pri as * const
                _ as usize } , 917usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_base_user_pri ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_pre_epoch_prio as * const
                _ as usize } , 918usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_pre_epoch_prio ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_rb_list as * const _ as
                usize } , 920usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_rb_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_rbp_list as * const _ as
                usize } , 928usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_rbp_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_rb_inact as * const _ as
                usize } , 936usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_rb_inact ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_sa as * const _ as usize
                } , 944usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_sa ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_pcb as * const _ as usize
                } , 1032usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_pcb ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_state as * const _ as
                usize } , 1040usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_uretoff as * const _ as
                usize } , 1048usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_uretoff ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_cowgen as * const _ as
                usize } , 1064usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_cowgen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_slpcallout as * const _
                as usize } , 1072usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_slpcallout ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_frame as * const _ as
                usize } , 1136usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_frame ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_kstack_obj as * const _
                as usize } , 1144usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_kstack_obj ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_kstack as * const _ as
                usize } , 1152usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_kstack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_kstack_pages as * const _
                as usize } , 1160usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_kstack_pages ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_critnest as * const _ as
                usize } , 1164usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_critnest ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_md as * const _ as usize
                } , 1168usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_md ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_ar as * const _ as usize
                } , 1216usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_ar ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_lprof as * const _ as
                usize } , 1224usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_lprof ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_dtrace as * const _ as
                usize } , 1240usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_dtrace ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_errno as * const _ as
                usize } , 1248usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_errno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_vnet as * const _ as
                usize } , 1256usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_vnet ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_vnet_lpush as * const _
                as usize } , 1264usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_vnet_lpush ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_intr_frame as * const _
                as usize } , 1272usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_intr_frame ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_rfppwait_p as * const _
                as usize } , 1280usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_rfppwait_p ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_ma as * const _ as usize
                } , 1288usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_ma ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_ma_cnt as * const _ as
                usize } , 1296usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_ma_cnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_emuldata as * const _ as
                usize } , 1304usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_emuldata ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_lastcpu as * const _ as
                usize } , 1312usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_lastcpu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_oncpu as * const _ as
                usize } , 1316usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_oncpu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_lkpi_task as * const _ as
                usize } , 1320usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_lkpi_task ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_epochq as * const _ as
                usize } , 1328usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_epochq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread ) ) . td_epoch_section as * const
                _ as usize } , 1344usize , concat ! (
                "Alignment of field: " , stringify ! ( thread ) , "::" ,
                stringify ! ( td_epoch_section ) ));
}
impl Clone for thread {
    fn clone(&self) -> Self { *self }
}
impl Default for thread {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for thread {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "thread {{ td_lock: {:?}, td_proc: {:?}, td_plist: {:?}, td_runq: {:?}, td_slpq: {:?}, td_lockq: {:?}, td_hash: {:?}, td_cpuset: {:?}, td_domain: {:?}, td_sel: {:?}, td_sleepqueue: {:?}, td_turnstile: {:?}, td_rlqe: {:?}, td_umtxq: {:?}, td_tid: {:?}, td_sigqueue: {:?}, td_lend_user_pri: {:?}, td_epochnest: {:?}, td_flags: {:?}, td_inhibitors: {:?}, td_pflags: {:?}, td_dupfd: {:?}, td_sqqueue: {:?}, td_wchan: {:?}, td_wmesg: {:?}, td_owepreempt: {:?}, td_tsqueue: {:?}, td_locks: {:?}, td_rw_rlocks: {:?}, td_sx_slocks: {:?}, td_lk_slocks: {:?}, td_stopsched: {:?}, td_blocked: {:?}, td_lockname: {:?}, td_contested: {:?}, td_sleeplocks: {:?}, td_intr_nesting_level: {:?}, td_pinned: {:?}, td_ucred: {:?}, td_limit: {:?}, td_slptick: {:?}, td_blktick: {:?}, td_swvoltick: {:?}, td_swinvoltick: {:?}, td_cow: {:?}, td_ru: {:?}, td_rux: {:?}, td_incruntime: {:?}, td_runtime: {:?}, td_pticks: {:?}, td_sticks: {:?}, td_iticks: {:?}, td_uticks: {:?}, td_intrval: {:?}, td_oldsigmask: {:?}, td_generation: {:?}, td_sigstk: {:?}, td_xsig: {:?}, td_profil_addr: {:?}, td_profil_ticks: {:?}, td_name: {:?}, td_fpop: {:?}, td_dbgflags: {:?}, td_si: {:?}, td_ng_outbound: {:?}, td_osd: {:?}, td_map_def_user: {:?}, td_dbg_forked: {:?}, td_vp_reserv: {:?}, td_no_sleeping: {:?}, td_su: {:?}, td_sleeptimo: {:?}, td_rtcgen: {:?}, td_vslock_sz: {:?}, td_sigmask: {:?}, td_rqindex: {:?}, td_base_pri: {:?}, td_priority: {:?}, td_pri_class: {:?}, td_user_pri: {:?}, td_base_user_pri: {:?}, td_pre_epoch_prio: {:?}, td_rb_list: {:?}, td_rbp_list: {:?}, td_rb_inact: {:?}, td_sa: {:?}, td_pcb: {:?}, td_state: {:?}, td_uretoff: {:?}, td_cowgen: {:?}, td_slpcallout: {:?}, td_frame: {:?}, td_kstack_obj: {:?}, td_kstack: {:?}, td_kstack_pages: {:?}, td_critnest: {:?}, td_md: {:?}, td_ar: {:?}, td_lprof: {:?}, td_dtrace: {:?}, td_errno: {:?}, td_vnet: {:?}, td_vnet_lpush: {:?}, td_intr_frame: {:?}, td_rfppwait_p: {:?}, td_ma: {:?}, td_ma_cnt: {:?}, td_emuldata: {:?}, td_lastcpu: {:?}, td_oncpu: {:?}, td_lkpi_task: {:?}, td_epochq: {:?}, td_epoch_section: {:?} }}"
               , self . td_lock , self . td_proc , self . td_plist , self .
               td_runq , self . td_slpq , self . td_lockq , self . td_hash ,
               self . td_cpuset , self . td_domain , self . td_sel , self .
               td_sleepqueue , self . td_turnstile , self . td_rlqe , self .
               td_umtxq , self . td_tid , self . td_sigqueue , self .
               td_lend_user_pri , self . td_epochnest , self . td_flags , self
               . td_inhibitors , self . td_pflags , self . td_dupfd , self .
               td_sqqueue , self . td_wchan , self . td_wmesg , self .
               td_owepreempt , self . td_tsqueue , self . td_locks , self .
               td_rw_rlocks , self . td_sx_slocks , self . td_lk_slocks , self
               . td_stopsched , self . td_blocked , self . td_lockname , self
               . td_contested , self . td_sleeplocks , self .
               td_intr_nesting_level , self . td_pinned , self . td_ucred ,
               self . td_limit , self . td_slptick , self . td_blktick , self
               . td_swvoltick , self . td_swinvoltick , self . td_cow , self .
               td_ru , self . td_rux , self . td_incruntime , self .
               td_runtime , self . td_pticks , self . td_sticks , self .
               td_iticks , self . td_uticks , self . td_intrval , self .
               td_oldsigmask , self . td_generation , self . td_sigstk , self
               . td_xsig , self . td_profil_addr , self . td_profil_ticks ,
               self . td_name , self . td_fpop , self . td_dbgflags , self .
               td_si , self . td_ng_outbound , self . td_osd , self .
               td_map_def_user , self . td_dbg_forked , self . td_vp_reserv ,
               self . td_no_sleeping , self . td_su , self . td_sleeptimo ,
               self . td_rtcgen , self . td_vslock_sz , self . td_sigmask ,
               self . td_rqindex , self . td_base_pri , self . td_priority ,
               self . td_pri_class , self . td_user_pri , self .
               td_base_user_pri , self . td_pre_epoch_prio , self . td_rb_list
               , self . td_rbp_list , self . td_rb_inact , self . td_sa , self
               . td_pcb , self . td_state , self . td_uretoff , self .
               td_cowgen , self . td_slpcallout , self . td_frame , self .
               td_kstack_obj , self . td_kstack , self . td_kstack_pages ,
               self . td_critnest , self . td_md , self . td_ar , self .
               td_lprof , self . td_dtrace , self . td_errno , self . td_vnet
               , self . td_vnet_lpush , self . td_intr_frame , self .
               td_rfppwait_p , self . td_ma , self . td_ma_cnt , self .
               td_emuldata , self . td_lastcpu , self . td_oncpu , self .
               td_lkpi_task , self . td_epochq , self . td_epoch_section)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tty {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ucred {
    pub cr_ref: u_int,
    pub cr_uid: uid_t,
    pub cr_ruid: uid_t,
    pub cr_svuid: uid_t,
    pub cr_ngroups: ::kernel::sys::raw::c_int,
    pub cr_rgid: gid_t,
    pub cr_svgid: gid_t,
    pub cr_uidinfo: *mut uidinfo,
    pub cr_ruidinfo: *mut uidinfo,
    pub cr_prison: *mut prison,
    pub cr_loginclass: *mut loginclass,
    pub cr_flags: u_int,
    pub cr_pspare2: [*mut ::kernel::sys::raw::c_void; 2usize],
    pub cr_label: *mut label,
    pub cr_audit: auditinfo_addr,
    pub cr_groups: *mut gid_t,
    pub cr_agroups: ::kernel::sys::raw::c_int,
    pub cr_smallgroups: [gid_t; 16usize],
}
#[test]
fn bindgen_test_layout_ucred() {
    assert_eq!(::core::mem::size_of::<ucred>() , 224usize , concat ! (
               "Size of: " , stringify ! ( ucred ) ));
    assert_eq! (::core::mem::align_of::<ucred>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ucred ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ucred ) ) . cr_ref as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ucred ) , "::" ,
                stringify ! ( cr_ref ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ucred ) ) . cr_uid as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ucred ) , "::" ,
                stringify ! ( cr_uid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ucred ) ) . cr_ruid as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ucred ) , "::" ,
                stringify ! ( cr_ruid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ucred ) ) . cr_svuid as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( ucred ) , "::" ,
                stringify ! ( cr_svuid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ucred ) ) . cr_ngroups as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ucred ) , "::" ,
                stringify ! ( cr_ngroups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ucred ) ) . cr_rgid as * const _ as usize
                } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( ucred ) , "::" ,
                stringify ! ( cr_rgid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ucred ) ) . cr_svgid as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ucred ) , "::" ,
                stringify ! ( cr_svgid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ucred ) ) . cr_uidinfo as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( ucred ) , "::" ,
                stringify ! ( cr_uidinfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ucred ) ) . cr_ruidinfo as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( ucred ) , "::" ,
                stringify ! ( cr_ruidinfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ucred ) ) . cr_prison as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( ucred ) , "::" ,
                stringify ! ( cr_prison ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ucred ) ) . cr_loginclass as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( ucred ) , "::" ,
                stringify ! ( cr_loginclass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ucred ) ) . cr_flags as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( ucred ) , "::" ,
                stringify ! ( cr_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ucred ) ) . cr_pspare2 as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( ucred ) , "::" ,
                stringify ! ( cr_pspare2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ucred ) ) . cr_label as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( ucred ) , "::" ,
                stringify ! ( cr_label ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ucred ) ) . cr_audit as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( ucred ) , "::" ,
                stringify ! ( cr_audit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ucred ) ) . cr_groups as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( ucred ) , "::" ,
                stringify ! ( cr_groups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ucred ) ) . cr_agroups as * const _ as
                usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( ucred ) , "::" ,
                stringify ! ( cr_agroups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ucred ) ) . cr_smallgroups as * const _
                as usize } , 156usize , concat ! (
                "Alignment of field: " , stringify ! ( ucred ) , "::" ,
                stringify ! ( cr_smallgroups ) ));
}
impl Clone for ucred {
    fn clone(&self) -> Self { *self }
}
impl Default for ucred {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uio {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _jmp_buf {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct trapframe {
    pub tf_rdi: register_t,
    pub tf_rsi: register_t,
    pub tf_rdx: register_t,
    pub tf_rcx: register_t,
    pub tf_r8: register_t,
    pub tf_r9: register_t,
    pub tf_rax: register_t,
    pub tf_rbx: register_t,
    pub tf_rbp: register_t,
    pub tf_r10: register_t,
    pub tf_r11: register_t,
    pub tf_r12: register_t,
    pub tf_r13: register_t,
    pub tf_r14: register_t,
    pub tf_r15: register_t,
    pub tf_trapno: u32,
    pub tf_fs: u16,
    pub tf_gs: u16,
    pub tf_addr: register_t,
    pub tf_flags: u32,
    pub tf_es: u16,
    pub tf_ds: u16,
    pub tf_err: register_t,
    pub tf_rip: register_t,
    pub tf_cs: register_t,
    pub tf_rflags: register_t,
    pub tf_rsp: register_t,
    pub tf_ss: register_t,
}
#[test]
fn bindgen_test_layout_trapframe() {
    assert_eq!(::core::mem::size_of::<trapframe>() , 192usize , concat ! (
               "Size of: " , stringify ! ( trapframe ) ));
    assert_eq! (::core::mem::align_of::<trapframe>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( trapframe ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_rdi as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_rdi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_rsi as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_rsi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_rdx as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_rdx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_rcx as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_rcx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_r8 as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_r8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_r9 as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_r9 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_rax as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_rax ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_rbx as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_rbx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_rbp as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_rbp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_r10 as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_r10 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_r11 as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_r11 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_r12 as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_r12 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_r13 as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_r13 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_r14 as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_r14 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_r15 as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_r15 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_trapno as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_trapno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_fs as * const _ as
                usize } , 124usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_fs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_gs as * const _ as
                usize } , 126usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_gs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_addr as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_flags as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_es as * const _ as
                usize } , 140usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_es ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_ds as * const _ as
                usize } , 142usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_ds ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_err as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_err ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_rip as * const _ as
                usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_rip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_cs as * const _ as
                usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_cs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_rflags as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_rflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_rsp as * const _ as
                usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_rsp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const trapframe ) ) . tf_ss as * const _ as
                usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( trapframe ) , "::" ,
                stringify ! ( tf_ss ) ));
}
impl Clone for trapframe {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eventtimer {
    _unused: [u8; 0],
}
extern "C" {
    pub fn setjmp(arg1: *mut _jmp_buf) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn longjmp(arg1: *mut _jmp_buf, arg2: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn dumpstatus(addr: vm_offset_t, count: off_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn nullop() -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn eopnotsupp() -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn ureadc(arg1: ::kernel::sys::raw::c_int, arg2: *mut uio)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn hashdestroy(arg1: *mut ::kernel::sys::raw::c_void,
                       arg2: *mut malloc_type, arg3: u_long);
}
extern "C" {
    pub fn hashinit(count: ::kernel::sys::raw::c_int, type_: *mut malloc_type,
                    hashmask: *mut u_long) -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn hashinit_flags(count: ::kernel::sys::raw::c_int,
                          type_: *mut malloc_type, hashmask: *mut u_long,
                          flags: ::kernel::sys::raw::c_int)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn phashinit(count: ::kernel::sys::raw::c_int,
                     type_: *mut malloc_type, nentries: *mut u_long)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn phashinit_flags(count: ::kernel::sys::raw::c_int,
                           type_: *mut malloc_type, nentries: *mut u_long,
                           flags: ::kernel::sys::raw::c_int)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn g_waitidle();
}
extern "C" {
    pub fn panic(arg1: *const ::kernel::sys::raw::c_char, ...);
}
extern "C" {
    pub fn vpanic(arg1: *const ::kernel::sys::raw::c_char,
                  arg2: *mut __va_list_tag);
}
extern "C" {
    pub fn cpu_boot(arg1: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn cpu_flush_dcache(arg1: *mut ::kernel::sys::raw::c_void,
                            arg2: usize);
}
extern "C" {
    pub fn cpu_rootconf();
}
extern "C" {
    pub fn critical_enter();
}
extern "C" {
    pub fn critical_exit();
}
extern "C" {
    pub fn init_param1();
}
extern "C" {
    pub fn init_param2(physpages: ::kernel::sys::raw::c_long);
}
extern "C" {
    pub fn init_static_kenv(arg1: *mut ::kernel::sys::raw::c_char,
                            arg2: usize);
}
extern "C" {
    pub fn tablefull(arg1: *const ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn kvprintf(arg1: *const ::kernel::sys::raw::c_char,
                    arg2:
                        ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                        ::kernel::sys::raw::c_int,
                                                                    arg2:
                                                                        *mut ::kernel::sys::raw::c_void)>,
                    arg3: *mut ::kernel::sys::raw::c_void,
                    arg4: ::kernel::sys::raw::c_int, arg5: *mut __va_list_tag)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn log(arg1: ::kernel::sys::raw::c_int,
               arg2: *const ::kernel::sys::raw::c_char, ...);
}
extern "C" {
    pub fn log_console(arg1: *mut uio);
}
extern "C" {
    pub fn vlog(arg1: ::kernel::sys::raw::c_int,
                arg2: *const ::kernel::sys::raw::c_char,
                arg3: *mut __va_list_tag);
}
extern "C" {
    pub fn asprintf(ret: *mut *mut ::kernel::sys::raw::c_char,
                    mtp: *mut malloc_type,
                    format: *const ::kernel::sys::raw::c_char, ...)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn printf(arg1: *const ::kernel::sys::raw::c_char, ...)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn snprintf(arg1: *mut ::kernel::sys::raw::c_char, arg2: usize,
                    arg3: *const ::kernel::sys::raw::c_char, ...)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sprintf(buf: *mut ::kernel::sys::raw::c_char,
                   arg1: *const ::kernel::sys::raw::c_char, ...)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn uprintf(arg1: *const ::kernel::sys::raw::c_char, ...)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn vprintf(arg1: *const ::kernel::sys::raw::c_char,
                   arg2: *mut __va_list_tag) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn vasprintf(ret: *mut *mut ::kernel::sys::raw::c_char,
                     mtp: *mut malloc_type,
                     format: *const ::kernel::sys::raw::c_char,
                     ap: *mut __va_list_tag) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(arg1: *mut ::kernel::sys::raw::c_char, arg2: usize,
                     arg3: *const ::kernel::sys::raw::c_char,
                     arg4: *mut __va_list_tag) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn vsnrprintf(arg1: *mut ::kernel::sys::raw::c_char, arg2: usize,
                      arg3: ::kernel::sys::raw::c_int,
                      arg4: *const ::kernel::sys::raw::c_char,
                      arg5: *mut __va_list_tag) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn vsprintf(buf: *mut ::kernel::sys::raw::c_char,
                    arg1: *const ::kernel::sys::raw::c_char,
                    arg2: *mut __va_list_tag) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn ttyprintf(arg1: *mut tty,
                     arg2: *const ::kernel::sys::raw::c_char, ...)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sscanf(arg1: *const ::kernel::sys::raw::c_char,
                  arg2: *const ::kernel::sys::raw::c_char, ...)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn vsscanf(arg1: *const ::kernel::sys::raw::c_char,
                   arg2: *const ::kernel::sys::raw::c_char,
                   arg3: *mut __va_list_tag) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn strtol(arg1: *const ::kernel::sys::raw::c_char,
                  arg2: *mut *mut ::kernel::sys::raw::c_char,
                  arg3: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_long;
}
extern "C" {
    pub fn strtoul(arg1: *const ::kernel::sys::raw::c_char,
                   arg2: *mut *mut ::kernel::sys::raw::c_char,
                   arg3: ::kernel::sys::raw::c_int) -> u_long;
}
extern "C" {
    pub fn strtoq(arg1: *const ::kernel::sys::raw::c_char,
                  arg2: *mut *mut ::kernel::sys::raw::c_char,
                  arg3: ::kernel::sys::raw::c_int) -> quad_t;
}
extern "C" {
    pub fn strtouq(arg1: *const ::kernel::sys::raw::c_char,
                   arg2: *mut *mut ::kernel::sys::raw::c_char,
                   arg3: ::kernel::sys::raw::c_int) -> u_quad_t;
}
extern "C" {
    pub fn tprintf(p: *mut proc_, pri: ::kernel::sys::raw::c_int,
                   arg1: *const ::kernel::sys::raw::c_char, ...);
}
extern "C" {
    pub fn vtprintf(arg1: *mut proc_, arg2: ::kernel::sys::raw::c_int,
                    arg3: *const ::kernel::sys::raw::c_char,
                    arg4: *mut __va_list_tag);
}
extern "C" {
    pub fn hexdump(ptr: *const ::kernel::sys::raw::c_void,
                   length: ::kernel::sys::raw::c_int,
                   hdr: *const ::kernel::sys::raw::c_char,
                   flags: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn bcopy(from: *const ::kernel::sys::raw::c_void,
                 to: *mut ::kernel::sys::raw::c_void, len: usize);
}
extern "C" {
    pub fn bzero(buf: *mut ::kernel::sys::raw::c_void, len: usize);
}
extern "C" {
    pub fn explicit_bzero(arg1: *mut ::kernel::sys::raw::c_void, arg2: usize);
}
extern "C" {
    pub fn memcpy(to: *mut ::kernel::sys::raw::c_void,
                  from: *const ::kernel::sys::raw::c_void, len: usize)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn memmove(dest: *mut ::kernel::sys::raw::c_void,
                   src: *const ::kernel::sys::raw::c_void, n: usize)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn copystr(kfaddr: *const ::kernel::sys::raw::c_void,
                   kdaddr: *mut ::kernel::sys::raw::c_void, len: usize,
                   lencopied: *mut usize) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn copyinstr(udaddr: *const ::kernel::sys::raw::c_void,
                     kaddr: *mut ::kernel::sys::raw::c_void, len: usize,
                     lencopied: *mut usize) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn copyin(udaddr: *const ::kernel::sys::raw::c_void,
                  kaddr: *mut ::kernel::sys::raw::c_void, len: usize)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn copyin_nofault(udaddr: *const ::kernel::sys::raw::c_void,
                          kaddr: *mut ::kernel::sys::raw::c_void, len: usize)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn copyout(kaddr: *const ::kernel::sys::raw::c_void,
                   udaddr: *mut ::kernel::sys::raw::c_void, len: usize)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn copyout_nofault(kaddr: *const ::kernel::sys::raw::c_void,
                           udaddr: *mut ::kernel::sys::raw::c_void,
                           len: usize) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn fubyte(base: *const ::kernel::sys::raw::c_void)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn fuword(base: *const ::kernel::sys::raw::c_void)
     -> ::kernel::sys::raw::c_long;
}
extern "C" {
    pub fn fuword16(base: *const ::kernel::sys::raw::c_void)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn fuword32(base: *const ::kernel::sys::raw::c_void) -> i32;
}
extern "C" {
    pub fn fuword64(base: *const ::kernel::sys::raw::c_void) -> i64;
}
extern "C" {
    pub fn fueword(base: *const ::kernel::sys::raw::c_void,
                   val: *mut ::kernel::sys::raw::c_long)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn fueword32(base: *const ::kernel::sys::raw::c_void, val: *mut i32)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn fueword64(base: *const ::kernel::sys::raw::c_void, val: *mut i64)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn subyte(base: *mut ::kernel::sys::raw::c_void,
                  byte: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn suword(base: *mut ::kernel::sys::raw::c_void,
                  word: ::kernel::sys::raw::c_long)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn suword16(base: *mut ::kernel::sys::raw::c_void,
                    word: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn suword32(base: *mut ::kernel::sys::raw::c_void, word: i32)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn suword64(base: *mut ::kernel::sys::raw::c_void, word: i64)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn casuword32(base: *mut u32, oldval: u32, newval: u32) -> u32;
}
extern "C" {
    pub fn casuword(p: *mut u_long, oldval: u_long, newval: u_long) -> u_long;
}
extern "C" {
    pub fn casueword32(base: *mut u32, oldval: u32, oldvalp: *mut u32,
                       newval: u32) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn casueword(p: *mut u_long, oldval: u_long, oldvalp: *mut u_long,
                     newval: u_long) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn realitexpire(arg1: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn sysbeep(hertz: ::kernel::sys::raw::c_int,
                   period: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn hardclock(usermode: ::kernel::sys::raw::c_int, pc: uintfptr_t);
}
extern "C" {
    pub fn hardclock_cnt(cnt: ::kernel::sys::raw::c_int,
                         usermode: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn hardclock_cpu(usermode: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn hardclock_sync(cpu: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn softclock(arg1: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn statclock(usermode: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn statclock_cnt(cnt: ::kernel::sys::raw::c_int,
                         usermode: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn profclock(usermode: ::kernel::sys::raw::c_int, pc: uintfptr_t);
}
extern "C" {
    pub fn profclock_cnt(cnt: ::kernel::sys::raw::c_int,
                         usermode: ::kernel::sys::raw::c_int, pc: uintfptr_t);
}
extern "C" {
    pub fn hardclockintr() -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn startprofclock(arg1: *mut proc_);
}
extern "C" {
    pub fn stopprofclock(arg1: *mut proc_);
}
extern "C" {
    pub fn cpu_startprofclock();
}
extern "C" {
    pub fn cpu_stopprofclock();
}
extern "C" {
    pub fn suspendclock();
}
extern "C" {
    pub fn resumeclock();
}
extern "C" {
    pub fn cpu_idleclock() -> sbintime_t;
}
extern "C" {
    pub fn cpu_activeclock();
}
extern "C" {
    pub fn cpu_new_callout(cpu: ::kernel::sys::raw::c_int, bt: sbintime_t,
                           bt_opt: sbintime_t);
}
extern "C" {
    pub fn cpu_et_frequency(et: *mut eventtimer, newfreq: u64);
}
extern "C" {
    #[link_name = "cpu_disable_c2_sleep"]
    pub static mut cpu_disable_c2_sleep: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "cpu_disable_c3_sleep"]
    pub static mut cpu_disable_c3_sleep: ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn kern_getenv(name: *const ::kernel::sys::raw::c_char)
     -> *mut ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn freeenv(env: *mut ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn getenv_int(name: *const ::kernel::sys::raw::c_char,
                      data: *mut ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn getenv_uint(name: *const ::kernel::sys::raw::c_char,
                       data: *mut ::kernel::sys::raw::c_uint)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn getenv_long(name: *const ::kernel::sys::raw::c_char,
                       data: *mut ::kernel::sys::raw::c_long)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn getenv_ulong(name: *const ::kernel::sys::raw::c_char,
                        data: *mut ::kernel::sys::raw::c_ulong)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn getenv_string(name: *const ::kernel::sys::raw::c_char,
                         data: *mut ::kernel::sys::raw::c_char,
                         size: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn getenv_int64(name: *const ::kernel::sys::raw::c_char,
                        data: *mut i64) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn getenv_uint64(name: *const ::kernel::sys::raw::c_char,
                         data: *mut u64) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn getenv_quad(name: *const ::kernel::sys::raw::c_char,
                       data: *mut quad_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn kern_setenv(name: *const ::kernel::sys::raw::c_char,
                       value: *const ::kernel::sys::raw::c_char)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn kern_unsetenv(name: *const ::kernel::sys::raw::c_char)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn testenv(name: *const ::kernel::sys::raw::c_char)
     -> ::kernel::sys::raw::c_int;
}
pub type cpu_tick_f = ::core::option::Option<unsafe extern "C" fn() -> u64>;
extern "C" {
    pub fn set_cputicker(func: cpu_tick_f, freq: u64,
                         var: ::kernel::sys::raw::c_uint);
}
extern "C" {
    #[link_name = "cpu_ticks"]
    pub static mut cpu_ticks: cpu_tick_f;
}
extern "C" {
    pub fn cpu_tickrate() -> u64;
}
extern "C" {
    pub fn cputick2usec(tick: u64) -> u64;
}
extern "C" {
    #[link_name = "bcd2bin_data"]
    pub static mut bcd2bin_data: [u_char; 0usize];
}
extern "C" {
    #[link_name = "bin2bcd_data"]
    pub static mut bin2bcd_data: [u_char; 0usize];
}
extern "C" {
    #[link_name = "hex2ascii_data"]
    pub static mut hex2ascii_data: [::kernel::sys::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "arc4rand_iniseed_state"]
    pub static mut arc4rand_iniseed_state: ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn arc4random() -> u32;
}
extern "C" {
    pub fn arc4random_buf(arg1: *mut ::kernel::sys::raw::c_void, arg2: usize);
}
extern "C" {
    pub fn arc4rand(arg1: *mut ::kernel::sys::raw::c_void, arg2: u_int,
                    arg3: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn bcmp(arg1: *const ::kernel::sys::raw::c_void,
                arg2: *const ::kernel::sys::raw::c_void, arg3: usize)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn timingsafe_bcmp(arg1: *const ::kernel::sys::raw::c_void,
                           arg2: *const ::kernel::sys::raw::c_void,
                           arg3: usize) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bsearch(arg1: *const ::kernel::sys::raw::c_void,
                   arg2: *const ::kernel::sys::raw::c_void, arg3: usize,
                   arg4: usize,
                   arg5:
                       ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                       *const ::kernel::sys::raw::c_void,
                                                                   arg2:
                                                                       *const ::kernel::sys::raw::c_void)
                                                  ->
                                                      ::kernel::sys::raw::c_int>)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn fnmatch(arg1: *const ::kernel::sys::raw::c_char,
                   arg2: *const ::kernel::sys::raw::c_char,
                   arg3: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn locc(arg1: ::kernel::sys::raw::c_int,
                arg2: *mut ::kernel::sys::raw::c_char, arg3: u_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn memchr(s: *const ::kernel::sys::raw::c_void,
                  c: ::kernel::sys::raw::c_int, n: usize)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn memcchr(s: *const ::kernel::sys::raw::c_void,
                   c: ::kernel::sys::raw::c_int, n: usize)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn memcmp(b1: *const ::kernel::sys::raw::c_void,
                  b2: *const ::kernel::sys::raw::c_void, len: usize)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn memmem(l: *const ::kernel::sys::raw::c_void, l_len: usize,
                  s: *const ::kernel::sys::raw::c_void, s_len: usize)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn qsort(base: *mut ::kernel::sys::raw::c_void, nmemb: usize,
                 size: usize,
                 compar:
                     ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                     *const ::kernel::sys::raw::c_void,
                                                                 arg2:
                                                                     *const ::kernel::sys::raw::c_void)
                                                ->
                                                    ::kernel::sys::raw::c_int>);
}
extern "C" {
    pub fn qsort_r(base: *mut ::kernel::sys::raw::c_void, nmemb: usize,
                   size: usize, thunk: *mut ::kernel::sys::raw::c_void,
                   compar:
                       ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                       *mut ::kernel::sys::raw::c_void,
                                                                   arg2:
                                                                       *const ::kernel::sys::raw::c_void,
                                                                   arg3:
                                                                       *const ::kernel::sys::raw::c_void)
                                                  ->
                                                      ::kernel::sys::raw::c_int>);
}
extern "C" {
    pub fn random() -> u_long;
}
extern "C" {
    pub fn scanc(arg1: u_int, arg2: *const u_char, arg3: *const u_char,
                 arg4: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn srandom(arg1: u_long);
}
extern "C" {
    pub fn strcasecmp(arg1: *const ::kernel::sys::raw::c_char,
                      arg2: *const ::kernel::sys::raw::c_char)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn strcat(arg1: *mut ::kernel::sys::raw::c_char,
                  arg2: *const ::kernel::sys::raw::c_char)
     -> *mut ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn strchr(arg1: *const ::kernel::sys::raw::c_char,
                  arg2: ::kernel::sys::raw::c_int)
     -> *mut ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn strcmp(arg1: *const ::kernel::sys::raw::c_char,
                  arg2: *const ::kernel::sys::raw::c_char)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn strcpy(arg1: *mut ::kernel::sys::raw::c_char,
                  arg2: *const ::kernel::sys::raw::c_char)
     -> *mut ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn strcspn(arg1: *const ::kernel::sys::raw::c_char,
                   arg2: *const ::kernel::sys::raw::c_char) -> usize;
}
extern "C" {
    pub fn strdup(arg1: *const ::kernel::sys::raw::c_char,
                  arg2: *mut malloc_type) -> *mut ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn strncat(arg1: *mut ::kernel::sys::raw::c_char,
                   arg2: *const ::kernel::sys::raw::c_char, arg3: usize)
     -> *mut ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn strndup(arg1: *const ::kernel::sys::raw::c_char, arg2: usize,
                   arg3: *mut malloc_type) -> *mut ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn strlcat(arg1: *mut ::kernel::sys::raw::c_char,
                   arg2: *const ::kernel::sys::raw::c_char, arg3: usize)
     -> usize;
}
extern "C" {
    pub fn strlcpy(arg1: *mut ::kernel::sys::raw::c_char,
                   arg2: *const ::kernel::sys::raw::c_char, arg3: usize)
     -> usize;
}
extern "C" {
    pub fn strlen(arg1: *const ::kernel::sys::raw::c_char) -> usize;
}
extern "C" {
    pub fn strncasecmp(arg1: *const ::kernel::sys::raw::c_char,
                       arg2: *const ::kernel::sys::raw::c_char, arg3: usize)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn strncmp(arg1: *const ::kernel::sys::raw::c_char,
                   arg2: *const ::kernel::sys::raw::c_char, arg3: usize)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn strncpy(arg1: *mut ::kernel::sys::raw::c_char,
                   arg2: *const ::kernel::sys::raw::c_char, arg3: usize)
     -> *mut ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn strnlen(arg1: *const ::kernel::sys::raw::c_char, arg2: usize)
     -> usize;
}
extern "C" {
    pub fn strrchr(arg1: *const ::kernel::sys::raw::c_char,
                   arg2: ::kernel::sys::raw::c_int)
     -> *mut ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn strsep(arg1: *mut *mut ::kernel::sys::raw::c_char,
                  delim: *const ::kernel::sys::raw::c_char)
     -> *mut ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn strspn(arg1: *const ::kernel::sys::raw::c_char,
                  arg2: *const ::kernel::sys::raw::c_char) -> usize;
}
extern "C" {
    pub fn strstr(arg1: *const ::kernel::sys::raw::c_char,
                  arg2: *const ::kernel::sys::raw::c_char)
     -> *mut ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn strvalid(arg1: *const ::kernel::sys::raw::c_char, arg2: usize)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "crc32_tab"]
    pub static mut crc32_tab: [u32; 0usize];
}
extern "C" {
    pub fn calculate_crc32c(crc32c: u32,
                            buffer: *const ::kernel::sys::raw::c_uchar,
                            length: ::kernel::sys::raw::c_uint) -> u32;
}
extern "C" {
    pub fn sse42_crc32c(arg1: u32, arg2: *const ::kernel::sys::raw::c_uchar,
                        arg3: ::kernel::sys::raw::c_uint) -> u32;
}
extern "C" {
    pub fn consinit();
}
extern "C" {
    pub fn cpu_initclocks();
}
extern "C" {
    pub fn cpu_initclocks_bsp();
}
extern "C" {
    pub fn cpu_initclocks_ap();
}
extern "C" {
    pub fn usrinfoinit();
}
extern "C" {
    pub fn kern_reboot(arg1: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn shutdown_nice(arg1: ::kernel::sys::raw::c_int);
}
pub type timeout_t =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void)>;
extern "C" {
    pub fn callout_handle_init(arg1: *mut callout_handle);
}
extern "C" {
    pub fn timeout(arg1: timeout_t, arg2: *mut ::kernel::sys::raw::c_void,
                   arg3: ::kernel::sys::raw::c_int) -> callout_handle;
}
extern "C" {
    pub fn untimeout(arg1: timeout_t, arg2: *mut ::kernel::sys::raw::c_void,
                     arg3: callout_handle);
}
extern "C" {
    pub fn _sleep(chan: *mut ::kernel::sys::raw::c_void,
                  lock: *mut lock_object, pri: ::kernel::sys::raw::c_int,
                  wmesg: *const ::kernel::sys::raw::c_char, sbt: sbintime_t,
                  pr: sbintime_t, flags: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn msleep_spin_sbt(chan: *mut ::kernel::sys::raw::c_void,
                           mtx: *mut mtx,
                           wmesg: *const ::kernel::sys::raw::c_char,
                           sbt: sbintime_t, pr: sbintime_t,
                           flags: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn pause_sbt(wmesg: *const ::kernel::sys::raw::c_char,
                     sbt: sbintime_t, pr: sbintime_t,
                     flags: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn wakeup(chan: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn wakeup_one(chan: *mut ::kernel::sys::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cdev {
    _unused: [u8; 0],
}
extern "C" {
    pub fn dev2udev(x: *mut cdev) -> dev_t;
}
extern "C" {
    pub fn devtoname(cdev: *mut cdev) -> *const ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn devfs_iosize_max() -> usize;
}
extern "C" {
    pub fn iosize_max() -> usize;
}
extern "C" {
    pub fn poll_no_poll(events: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn DELAY(usec: ::kernel::sys::raw::c_int);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct root_hold_token {
    _unused: [u8; 0],
}
extern "C" {
    pub fn root_mount_hold(identifier: *const ::kernel::sys::raw::c_char)
     -> *mut root_hold_token;
}
extern "C" {
    pub fn root_mount_rel(h: *mut root_hold_token);
}
extern "C" {
    pub fn root_mounted() -> ::kernel::sys::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct unrhdr {
    _unused: [u8; 0],
}
extern "C" {
    pub fn new_unrhdr(low: ::kernel::sys::raw::c_int,
                      high: ::kernel::sys::raw::c_int, mutex: *mut mtx)
     -> *mut unrhdr;
}
extern "C" {
    pub fn init_unrhdr(uh: *mut unrhdr, low: ::kernel::sys::raw::c_int,
                       high: ::kernel::sys::raw::c_int, mutex: *mut mtx);
}
extern "C" {
    pub fn delete_unrhdr(uh: *mut unrhdr);
}
extern "C" {
    pub fn clear_unrhdr(uh: *mut unrhdr);
}
extern "C" {
    pub fn clean_unrhdr(uh: *mut unrhdr);
}
extern "C" {
    pub fn clean_unrhdrl(uh: *mut unrhdr);
}
extern "C" {
    pub fn alloc_unr(uh: *mut unrhdr) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn alloc_unr_specific(uh: *mut unrhdr, item: u_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn alloc_unrl(uh: *mut unrhdr) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn free_unr(uh: *mut unrhdr, item: u_int);
}
extern "C" {
    pub fn intr_prof_stack_use(td: *mut thread, frame: *mut trapframe);
}
extern "C" {
    pub fn counted_warning(counter: *mut ::kernel::sys::raw::c_uint,
                           msg: *const ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn _gone_in(major: ::kernel::sys::raw::c_int,
                    msg: *const ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn _gone_in_dev(dev: *mut device, major: ::kernel::sys::raw::c_int,
                        msg: *const ::kernel::sys::raw::c_char);
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct pti_frame {
    pub pti_rdx: register_t,
    pub pti_rax: register_t,
    pub pti_err: register_t,
    pub pti_rip: register_t,
    pub pti_cs: register_t,
    pub pti_rflags: register_t,
    pub pti_rsp: register_t,
    pub pti_ss: register_t,
}
#[test]
fn bindgen_test_layout_pti_frame() {
    assert_eq!(::core::mem::size_of::<pti_frame>() , 64usize , concat ! (
               "Size of: " , stringify ! ( pti_frame ) ));
    assert_eq! (::core::mem::align_of::<pti_frame>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pti_frame ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pti_frame ) ) . pti_rdx as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pti_frame ) , "::" ,
                stringify ! ( pti_rdx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pti_frame ) ) . pti_rax as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pti_frame ) , "::" ,
                stringify ! ( pti_rax ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pti_frame ) ) . pti_err as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( pti_frame ) , "::" ,
                stringify ! ( pti_err ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pti_frame ) ) . pti_rip as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( pti_frame ) , "::" ,
                stringify ! ( pti_rip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pti_frame ) ) . pti_cs as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( pti_frame ) , "::" ,
                stringify ! ( pti_cs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pti_frame ) ) . pti_rflags as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( pti_frame ) , "::" ,
                stringify ! ( pti_rflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pti_frame ) ) . pti_rsp as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( pti_frame ) , "::" ,
                stringify ! ( pti_rsp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pti_frame ) ) . pti_ss as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( pti_frame ) , "::" ,
                stringify ! ( pti_ss ) ));
}
impl Clone for pti_frame {
    fn clone(&self) -> Self { *self }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy)]
pub struct segment_descriptor {
    pub _bitfield_1: [u32; 3usize],
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_segment_descriptor() {
    assert_eq!(::core::mem::size_of::<segment_descriptor>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( segment_descriptor ) ));
    assert_eq! (::core::mem::align_of::<segment_descriptor>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( segment_descriptor ) ));
}
impl Clone for segment_descriptor {
    fn clone(&self) -> Self { *self }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy)]
pub struct user_segment_descriptor {
    pub _bitfield_1: [u32; 3usize],
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_user_segment_descriptor() {
    assert_eq!(::core::mem::size_of::<user_segment_descriptor>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( user_segment_descriptor ) ));
    assert_eq! (::core::mem::align_of::<user_segment_descriptor>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( user_segment_descriptor ) ));
}
impl Clone for user_segment_descriptor {
    fn clone(&self) -> Self { *self }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy)]
pub struct gate_descriptor {
    pub _bitfield_1: [u64; 3usize],
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_gate_descriptor() {
    assert_eq!(::core::mem::size_of::<gate_descriptor>() , 16usize , concat !
               ( "Size of: " , stringify ! ( gate_descriptor ) ));
    assert_eq! (::core::mem::align_of::<gate_descriptor>() , 1usize , concat !
                ( "Alignment of " , stringify ! ( gate_descriptor ) ));
}
impl Clone for gate_descriptor {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union descriptor {
    pub sd: user_segment_descriptor,
    pub gd: gate_descriptor,
    _bindgen_union_align: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_descriptor() {
    assert_eq!(::core::mem::size_of::<descriptor>() , 16usize , concat ! (
               "Size of: " , stringify ! ( descriptor ) ));
    assert_eq! (::core::mem::align_of::<descriptor>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( descriptor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const descriptor ) ) . sd as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( descriptor ) , "::" ,
                stringify ! ( sd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const descriptor ) ) . gd as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( descriptor ) , "::" ,
                stringify ! ( gd ) ));
}
impl Clone for descriptor {
    fn clone(&self) -> Self { *self }
}
impl Default for descriptor {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for descriptor {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "descriptor {{ union }}")
    }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy)]
pub struct system_segment_descriptor {
    pub _bitfield_1: [u64; 3usize],
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_system_segment_descriptor() {
    assert_eq!(::core::mem::size_of::<system_segment_descriptor>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( system_segment_descriptor ) ));
    assert_eq! (::core::mem::align_of::<system_segment_descriptor>() , 1usize
                , concat ! (
                "Alignment of " , stringify ! ( system_segment_descriptor )
                ));
}
impl Clone for system_segment_descriptor {
    fn clone(&self) -> Self { *self }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy)]
pub struct soft_segment_descriptor {
    pub ssd_base: ::kernel::sys::raw::c_ulong,
    pub ssd_limit: ::kernel::sys::raw::c_ulong,
    pub _bitfield_1: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_soft_segment_descriptor() {
    assert_eq!(::core::mem::size_of::<soft_segment_descriptor>() , 18usize ,
               concat ! (
               "Size of: " , stringify ! ( soft_segment_descriptor ) ));
    assert_eq! (::core::mem::align_of::<soft_segment_descriptor>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( soft_segment_descriptor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const soft_segment_descriptor ) ) . ssd_base as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( soft_segment_descriptor
                ) , "::" , stringify ! ( ssd_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const soft_segment_descriptor ) ) . ssd_limit
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( soft_segment_descriptor
                ) , "::" , stringify ! ( ssd_limit ) ));
}
impl Clone for soft_segment_descriptor {
    fn clone(&self) -> Self { *self }
}
impl soft_segment_descriptor {
    #[inline]
    pub fn ssd_type(&self) -> ::kernel::sys::raw::c_ulong {
        let mut unit_field_val: u16 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u16
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>())
        };
        let mask = 31u64 as u16;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::core::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_ssd_type(&mut self, val: ::kernel::sys::raw::c_ulong) {
        let mask = 31u64 as u16;
        let val = val as u64 as u16;
        let mut unit_field_val: u16 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u16
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn ssd_dpl(&self) -> ::kernel::sys::raw::c_ulong {
        let mut unit_field_val: u16 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u16
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>())
        };
        let mask = 96u64 as u16;
        let val = (unit_field_val & mask) >> 5usize;
        unsafe { ::core::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_ssd_dpl(&mut self, val: ::kernel::sys::raw::c_ulong) {
        let mask = 96u64 as u16;
        let val = val as u64 as u16;
        let mut unit_field_val: u16 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u16
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 5usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn ssd_p(&self) -> ::kernel::sys::raw::c_ulong {
        let mut unit_field_val: u16 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u16
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>())
        };
        let mask = 128u64 as u16;
        let val = (unit_field_val & mask) >> 7usize;
        unsafe { ::core::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_ssd_p(&mut self, val: ::kernel::sys::raw::c_ulong) {
        let mask = 128u64 as u16;
        let val = val as u64 as u16;
        let mut unit_field_val: u16 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u16
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 7usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn ssd_long(&self) -> ::kernel::sys::raw::c_ulong {
        let mut unit_field_val: u16 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u16
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>())
        };
        let mask = 256u64 as u16;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::core::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_ssd_long(&mut self, val: ::kernel::sys::raw::c_ulong) {
        let mask = 256u64 as u16;
        let val = val as u64 as u16;
        let mut unit_field_val: u16 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u16
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn ssd_def32(&self) -> ::kernel::sys::raw::c_ulong {
        let mut unit_field_val: u16 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u16
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>())
        };
        let mask = 512u64 as u16;
        let val = (unit_field_val & mask) >> 9usize;
        unsafe { ::core::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_ssd_def32(&mut self, val: ::kernel::sys::raw::c_ulong) {
        let mask = 512u64 as u16;
        let val = val as u64 as u16;
        let mut unit_field_val: u16 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u16
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 9usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn ssd_gran(&self) -> ::kernel::sys::raw::c_ulong {
        let mut unit_field_val: u16 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u16
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>())
        };
        let mask = 1024u64 as u16;
        let val = (unit_field_val & mask) >> 10usize;
        unsafe { ::core::mem::transmute(val as u64) }
    }
    #[inline]
    pub fn set_ssd_gran(&mut self, val: ::kernel::sys::raw::c_ulong) {
        let mask = 1024u64 as u16;
        let val = val as u64 as u16;
        let mut unit_field_val: u16 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u16
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 10usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(ssd_type: ::kernel::sys::raw::c_ulong,
                          ssd_dpl: ::kernel::sys::raw::c_ulong,
                          ssd_p: ::kernel::sys::raw::c_ulong,
                          ssd_long: ::kernel::sys::raw::c_ulong,
                          ssd_def32: ::kernel::sys::raw::c_ulong,
                          ssd_gran: ::kernel::sys::raw::c_ulong) -> u16 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({ 0 } |
                                      ((ssd_type as u64 as u16) << 0usize) &
                                          (31u64 as u16))
                             } |
                                 ((ssd_dpl as u64 as u16) << 5usize) &
                                     (96u64 as u16))
                        } |
                            ((ssd_p as u64 as u16) << 7usize) &
                                (128u64 as u16))
                   } | ((ssd_long as u64 as u16) << 8usize) & (256u64 as u16))
              } | ((ssd_def32 as u64 as u16) << 9usize) & (512u64 as u16))
         } | ((ssd_gran as u64 as u16) << 10usize) & (1024u64 as u16))
    }
}
extern "C" {
    #[link_name = "gdt"]
    pub static mut gdt: [user_segment_descriptor; 0usize];
}
extern "C" {
    #[link_name = "gdt_segs"]
    pub static mut gdt_segs: [soft_segment_descriptor; 0usize];
}
extern "C" {
    #[link_name = "idt"]
    pub static mut idt: *mut gate_descriptor;
}
extern "C" {
    #[link_name = "r_gdt"]
    pub static mut r_gdt: region_descriptor;
}
extern "C" {
    #[link_name = "r_idt"]
    pub static mut r_idt: region_descriptor;
}
extern "C" {
    pub fn lgdt(rdp: *mut region_descriptor);
}
extern "C" {
    pub fn sdtossd(sdp: *mut user_segment_descriptor,
                   ssdp: *mut soft_segment_descriptor);
}
extern "C" {
    pub fn ssdtosd(ssdp: *mut soft_segment_descriptor,
                   sdp: *mut user_segment_descriptor);
}
extern "C" {
    pub fn ssdtosyssd(ssdp: *mut soft_segment_descriptor,
                      sdp: *mut system_segment_descriptor);
}
extern "C" {
    pub fn update_gdt_gsbase(td: *mut thread, base: u32);
}
extern "C" {
    pub fn update_gdt_fsbase(td: *mut thread, base: u32);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cpu_ops {
    pub cpu_init: ::core::option::Option<unsafe extern "C" fn()>,
    pub cpu_resume: ::core::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout_cpu_ops() {
    assert_eq!(::core::mem::size_of::<cpu_ops>() , 16usize , concat ! (
               "Size of: " , stringify ! ( cpu_ops ) ));
    assert_eq! (::core::mem::align_of::<cpu_ops>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( cpu_ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_ops ) ) . cpu_init as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( cpu_ops ) , "::" ,
                stringify ! ( cpu_init ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_ops ) ) . cpu_resume as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( cpu_ops ) , "::" ,
                stringify ! ( cpu_resume ) ));
}
impl Clone for cpu_ops {
    fn clone(&self) -> Self { *self }
}
impl Default for cpu_ops {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    #[link_name = "cpu_ops"]
    pub static mut cpu_ops: cpu_ops;
}
extern "C" {
    #[link_name = "brwsection"]
    pub static mut brwsection: [::kernel::sys::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "btext"]
    pub static mut btext: [::kernel::sys::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "_end"]
    pub static mut _end: [::kernel::sys::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "etext"]
    pub static mut etext: [::kernel::sys::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "vmm_resume_p"]
    pub static mut vmm_resume_p:
               ::core::option::Option<unsafe extern "C" fn()>;
}
extern "C" {
    pub fn cpu_halt();
}
extern "C" {
    pub fn cpu_reset();
}
extern "C" {
    pub fn fork_trampoline();
}
extern "C" {
    pub fn swi_vm(arg1: *mut ::kernel::sys::raw::c_void);
}
#[repr(C)]
pub struct buf_ring {
    pub br_prod_head: u32,
    pub br_prod_tail: u32,
    pub br_prod_size: ::kernel::sys::raw::c_int,
    pub br_prod_mask: ::kernel::sys::raw::c_int,
    pub br_drops: u64,
    pub __bindgen_padding_0: [u32; 10usize],
    pub br_cons_head: u32,
    pub br_cons_tail: u32,
    pub br_cons_size: ::kernel::sys::raw::c_int,
    pub br_cons_mask: ::kernel::sys::raw::c_int,
    pub __bindgen_padding_1: [u64; 6usize],
    pub br_ring: __IncompleteArrayField<*mut ::kernel::sys::raw::c_void>,
}
#[test]
fn bindgen_test_layout_buf_ring() {
    assert_eq!(::core::mem::size_of::<buf_ring>() , 128usize , concat ! (
               "Size of: " , stringify ! ( buf_ring ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const buf_ring ) ) . br_prod_head as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( buf_ring ) , "::" ,
                stringify ! ( br_prod_head ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const buf_ring ) ) . br_prod_tail as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( buf_ring ) , "::" ,
                stringify ! ( br_prod_tail ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const buf_ring ) ) . br_prod_size as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( buf_ring ) , "::" ,
                stringify ! ( br_prod_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const buf_ring ) ) . br_prod_mask as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( buf_ring ) , "::" ,
                stringify ! ( br_prod_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const buf_ring ) ) . br_drops as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( buf_ring ) , "::" ,
                stringify ! ( br_drops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const buf_ring ) ) . br_cons_head as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( buf_ring ) , "::" ,
                stringify ! ( br_cons_head ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const buf_ring ) ) . br_cons_tail as * const _
                as usize } , 68usize , concat ! (
                "Alignment of field: " , stringify ! ( buf_ring ) , "::" ,
                stringify ! ( br_cons_tail ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const buf_ring ) ) . br_cons_size as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( buf_ring ) , "::" ,
                stringify ! ( br_cons_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const buf_ring ) ) . br_cons_mask as * const _
                as usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( buf_ring ) , "::" ,
                stringify ! ( br_cons_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const buf_ring ) ) . br_ring as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( buf_ring ) , "::" ,
                stringify ! ( br_ring ) ));
}
impl Default for buf_ring {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for buf_ring {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "buf_ring {{ br_prod_head: {:?}, br_prod_tail: {:?}, br_prod_size: {:?}, br_prod_mask: {:?}, br_drops: {:?}, br_cons_head: {:?}, br_cons_tail: {:?}, br_cons_size: {:?}, br_cons_mask: {:?}, br_ring: {:?} }}"
               , self . br_prod_head , self . br_prod_tail , self .
               br_prod_size , self . br_prod_mask , self . br_drops , self .
               br_cons_head , self . br_cons_tail , self . br_cons_size , self
               . br_cons_mask , self . br_ring)
    }
}
extern "C" {
    pub fn buf_ring_alloc(count: ::kernel::sys::raw::c_int,
                          type_: *mut malloc_type,
                          flags: ::kernel::sys::raw::c_int, arg1: *mut mtx)
     -> *mut buf_ring;
}
extern "C" {
    pub fn buf_ring_free(br: *mut buf_ring, type_: *mut malloc_type);
}
pub type bus_addr_t = u64;
pub type bus_size_t = u64;
pub type bus_space_tag_t = u64;
pub type bus_space_handle_t = u64;
pub type bus_dmasync_op_t = ::kernel::sys::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bus_dma_tag {
    _unused: [u8; 0],
}
pub type bus_dma_tag_t = *mut bus_dma_tag;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bus_dmamap {
    _unused: [u8; 0],
}
pub type bus_dmamap_t = *mut bus_dmamap;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum bus_dma_lock_op_t { BUS_DMA_LOCK = 1, BUS_DMA_UNLOCK = 2, }
pub type bus_dma_lock_t =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: bus_dma_lock_op_t)>;
/// @brief Interface information structure.
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct u_businfo {
    /// < @brief interface version
    pub ub_version: ::kernel::sys::raw::c_int,
    /// < @brief generation count
    pub ub_generation: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_u_businfo() {
    assert_eq!(::core::mem::size_of::<u_businfo>() , 8usize , concat ! (
               "Size of: " , stringify ! ( u_businfo ) ));
    assert_eq! (::core::mem::align_of::<u_businfo>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( u_businfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_businfo ) ) . ub_version as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( u_businfo ) , "::" ,
                stringify ! ( ub_version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_businfo ) ) . ub_generation as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( u_businfo ) , "::" ,
                stringify ! ( ub_generation ) ));
}
impl Clone for u_businfo {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
/// @brief State of the device.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum device_state {
    DS_NOTPRESENT = 10,
    DS_ALIVE = 20,
    DS_ATTACHING = 25,
    DS_ATTACHED = 30,
    DS_BUSY = 40,
}
pub use self::device_state as device_state_t;
/// @brief Device information exported to userspace.
#[repr(C)]
#[derive(Copy)]
pub struct u_device {
    pub dv_handle: usize,
    pub dv_parent: usize,
    /// < @brief Name of device in tree.
    pub dv_name: [::kernel::sys::raw::c_char; 32usize],
    /// < @brief Driver description
    pub dv_desc: [::kernel::sys::raw::c_char; 32usize],
    /// < @brief Driver name
    pub dv_drivername: [::kernel::sys::raw::c_char; 32usize],
    /// < @brief Plug and play info
    pub dv_pnpinfo: [::kernel::sys::raw::c_char; 128usize],
    /// < @brief Where is the device?
    pub dv_location: [::kernel::sys::raw::c_char; 128usize],
    /// < @brief API Flags for device
    pub dv_devflags: u32,
    /// < @brief flags for dev state
    pub dv_flags: u16,
    /// < @brief State of attachment
    pub dv_state: device_state_t,
}
#[test]
fn bindgen_test_layout_u_device() {
    assert_eq!(::core::mem::size_of::<u_device>() , 384usize , concat ! (
               "Size of: " , stringify ! ( u_device ) ));
    assert_eq! (::core::mem::align_of::<u_device>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( u_device ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_device ) ) . dv_handle as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( u_device ) , "::" ,
                stringify ! ( dv_handle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_device ) ) . dv_parent as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( u_device ) , "::" ,
                stringify ! ( dv_parent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_device ) ) . dv_name as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( u_device ) , "::" ,
                stringify ! ( dv_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_device ) ) . dv_desc as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( u_device ) , "::" ,
                stringify ! ( dv_desc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_device ) ) . dv_drivername as * const _
                as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( u_device ) , "::" ,
                stringify ! ( dv_drivername ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_device ) ) . dv_pnpinfo as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( u_device ) , "::" ,
                stringify ! ( dv_pnpinfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_device ) ) . dv_location as * const _
                as usize } , 240usize , concat ! (
                "Alignment of field: " , stringify ! ( u_device ) , "::" ,
                stringify ! ( dv_location ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_device ) ) . dv_devflags as * const _
                as usize } , 368usize , concat ! (
                "Alignment of field: " , stringify ! ( u_device ) , "::" ,
                stringify ! ( dv_devflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_device ) ) . dv_flags as * const _ as
                usize } , 372usize , concat ! (
                "Alignment of field: " , stringify ! ( u_device ) , "::" ,
                stringify ! ( dv_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_device ) ) . dv_state as * const _ as
                usize } , 376usize , concat ! (
                "Alignment of field: " , stringify ! ( u_device ) , "::" ,
                stringify ! ( dv_state ) ));
}
impl Clone for u_device {
    fn clone(&self) -> Self { *self }
}
impl Default for u_device {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for u_device {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "u_device {{ dv_handle: {:?}, dv_parent: {:?}, dv_name: [{}], dv_desc: [{}], dv_drivername: [{}], dv_pnpinfo: [{}], dv_location: [{}], dv_devflags: {:?}, dv_flags: {:?}, dv_state: {:?} }}"
               , self . dv_handle , self . dv_parent , self . dv_name . iter (
                ) . enumerate (  ) . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ) , self . dv_desc . iter (  ) . enumerate (  ) .
               map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ) , self . dv_drivername . iter (  ) . enumerate (
               ) . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ) , self . dv_pnpinfo . iter (  ) . enumerate (  )
               . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ) , self . dv_location . iter (  ) . enumerate (  )
               . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ) , self . dv_devflags , self . dv_flags , self .
               dv_state)
    }
}
/// @brief Device request structure used for ioctl's.
///
/// Used for ioctl's on /dev/devctl2.  All device ioctl's
/// must have parameter definitions which begin with dr_name.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct devreq_buffer {
    pub buffer: *mut ::kernel::sys::raw::c_void,
    pub length: usize,
}
#[test]
fn bindgen_test_layout_devreq_buffer() {
    assert_eq!(::core::mem::size_of::<devreq_buffer>() , 16usize , concat ! (
               "Size of: " , stringify ! ( devreq_buffer ) ));
    assert_eq! (::core::mem::align_of::<devreq_buffer>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( devreq_buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const devreq_buffer ) ) . buffer as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( devreq_buffer ) , "::"
                , stringify ! ( buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const devreq_buffer ) ) . length as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( devreq_buffer ) , "::"
                , stringify ! ( length ) ));
}
impl Clone for devreq_buffer {
    fn clone(&self) -> Self { *self }
}
impl Default for devreq_buffer {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct devreq {
    pub dr_name: [::kernel::sys::raw::c_char; 128usize],
    pub dr_flags: ::kernel::sys::raw::c_int,
    pub dr_dru: devreq__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub union devreq__bindgen_ty_1 {
    pub dru_buffer: devreq_buffer,
    pub dru_data: *mut ::kernel::sys::raw::c_void,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_devreq__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<devreq__bindgen_ty_1>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( devreq__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<devreq__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( devreq__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const devreq__bindgen_ty_1 ) ) . dru_buffer as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( devreq__bindgen_ty_1 )
                , "::" , stringify ! ( dru_buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const devreq__bindgen_ty_1 ) ) . dru_data as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( devreq__bindgen_ty_1 )
                , "::" , stringify ! ( dru_data ) ));
}
impl Clone for devreq__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for devreq__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for devreq__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "devreq__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_devreq() {
    assert_eq!(::core::mem::size_of::<devreq>() , 152usize , concat ! (
               "Size of: " , stringify ! ( devreq ) ));
    assert_eq! (::core::mem::align_of::<devreq>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( devreq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const devreq ) ) . dr_name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( devreq ) , "::" ,
                stringify ! ( dr_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const devreq ) ) . dr_flags as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( devreq ) , "::" ,
                stringify ! ( dr_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const devreq ) ) . dr_dru as * const _ as usize
                } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( devreq ) , "::" ,
                stringify ! ( dr_dru ) ));
}
impl Clone for devreq {
    fn clone(&self) -> Self { *self }
}
impl Default for devreq {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for devreq {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "devreq {{ dr_name: [{}], dr_flags: {:?}, dr_dru: {:?} }}"
               , self . dr_name . iter (  ) . enumerate (  ) . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ) , self . dr_flags , self . dr_dru)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lock_list_entry {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lock_class {
    pub lc_name: *const ::kernel::sys::raw::c_char,
    pub lc_flags: u_int,
    pub lc_assert: ::core::option::Option<unsafe extern "C" fn(lock:
                                                                   *const lock_object,
                                                               what:
                                                                   ::kernel::sys::raw::c_int)>,
    pub lc_ddb_show: ::core::option::Option<unsafe extern "C" fn(lock:
                                                                     *const lock_object)>,
    pub lc_lock: ::core::option::Option<unsafe extern "C" fn(lock:
                                                                 *mut lock_object,
                                                             how: usize)>,
    pub lc_owner: ::core::option::Option<unsafe extern "C" fn(lock:
                                                                  *const lock_object,
                                                              owner:
                                                                  *mut *mut thread)
                                             -> ::kernel::sys::raw::c_int>,
    pub lc_unlock: ::core::option::Option<unsafe extern "C" fn(lock:
                                                                   *mut lock_object)
                                              -> usize>,
}
#[test]
fn bindgen_test_layout_lock_class() {
    assert_eq!(::core::mem::size_of::<lock_class>() , 56usize , concat ! (
               "Size of: " , stringify ! ( lock_class ) ));
    assert_eq! (::core::mem::align_of::<lock_class>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lock_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_class ) ) . lc_name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_class ) , "::" ,
                stringify ! ( lc_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_class ) ) . lc_flags as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_class ) , "::" ,
                stringify ! ( lc_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_class ) ) . lc_assert as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_class ) , "::" ,
                stringify ! ( lc_assert ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_class ) ) . lc_ddb_show as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_class ) , "::" ,
                stringify ! ( lc_ddb_show ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_class ) ) . lc_lock as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_class ) , "::" ,
                stringify ! ( lc_lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_class ) ) . lc_owner as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_class ) , "::" ,
                stringify ! ( lc_owner ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_class ) ) . lc_unlock as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_class ) , "::" ,
                stringify ! ( lc_unlock ) ));
}
impl Clone for lock_class {
    fn clone(&self) -> Self { *self }
}
impl Default for lock_class {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    #[link_name = "lock_class_mtx_sleep"]
    pub static mut lock_class_mtx_sleep: lock_class;
}
extern "C" {
    #[link_name = "lock_class_mtx_spin"]
    pub static mut lock_class_mtx_spin: lock_class;
}
extern "C" {
    #[link_name = "lock_class_sx"]
    pub static mut lock_class_sx: lock_class;
}
extern "C" {
    #[link_name = "lock_class_rw"]
    pub static mut lock_class_rw: lock_class;
}
extern "C" {
    #[link_name = "lock_class_rm"]
    pub static mut lock_class_rm: lock_class;
}
extern "C" {
    #[link_name = "lock_class_rm_sleepable"]
    pub static mut lock_class_rm_sleepable: lock_class;
}
extern "C" {
    #[link_name = "lock_class_lockmgr"]
    pub static mut lock_class_lockmgr: lock_class;
}
extern "C" {
    #[link_name = "lock_classes"]
    pub static mut lock_classes: [*mut lock_class; 0usize];
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct lock_delay_config {
    pub base: u_int,
    pub max: u_int,
}
#[test]
fn bindgen_test_layout_lock_delay_config() {
    assert_eq!(::core::mem::size_of::<lock_delay_config>() , 8usize , concat !
               ( "Size of: " , stringify ! ( lock_delay_config ) ));
    assert_eq! (::core::mem::align_of::<lock_delay_config>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( lock_delay_config ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_delay_config ) ) . base as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_delay_config ) ,
                "::" , stringify ! ( base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_delay_config ) ) . max as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_delay_config ) ,
                "::" , stringify ! ( max ) ));
}
impl Clone for lock_delay_config {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lock_delay_arg {
    pub config: *mut lock_delay_config,
    pub delay: u_int,
    pub spin_cnt: u_int,
}
#[test]
fn bindgen_test_layout_lock_delay_arg() {
    assert_eq!(::core::mem::size_of::<lock_delay_arg>() , 16usize , concat ! (
               "Size of: " , stringify ! ( lock_delay_arg ) ));
    assert_eq! (::core::mem::align_of::<lock_delay_arg>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( lock_delay_arg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_delay_arg ) ) . config as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_delay_arg ) , "::"
                , stringify ! ( config ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_delay_arg ) ) . delay as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_delay_arg ) , "::"
                , stringify ! ( delay ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lock_delay_arg ) ) . spin_cnt as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( lock_delay_arg ) , "::"
                , stringify ! ( spin_cnt ) ));
}
impl Clone for lock_delay_arg {
    fn clone(&self) -> Self { *self }
}
impl Default for lock_delay_arg {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    pub fn lock_init(arg1: *mut lock_object, arg2: *mut lock_class,
                     arg3: *const ::kernel::sys::raw::c_char,
                     arg4: *const ::kernel::sys::raw::c_char,
                     arg5: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn lock_destroy(arg1: *mut lock_object);
}
extern "C" {
    pub fn lock_delay(arg1: *mut lock_delay_arg);
}
extern "C" {
    pub fn lock_delay_default_init(arg1: *mut lock_delay_config);
}
extern "C" {
    pub fn spinlock_enter();
}
extern "C" {
    pub fn spinlock_exit();
}
extern "C" {
    pub fn witness_init(arg1: *mut lock_object,
                        arg2: *const ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn witness_destroy(arg1: *mut lock_object);
}
extern "C" {
    pub fn witness_defineorder(arg1: *mut lock_object, arg2: *mut lock_object)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn witness_checkorder(arg1: *mut lock_object,
                              arg2: ::kernel::sys::raw::c_int,
                              arg3: *const ::kernel::sys::raw::c_char,
                              arg4: ::kernel::sys::raw::c_int,
                              arg5: *mut lock_object);
}
extern "C" {
    pub fn witness_lock(arg1: *mut lock_object,
                        arg2: ::kernel::sys::raw::c_int,
                        arg3: *const ::kernel::sys::raw::c_char,
                        arg4: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn witness_upgrade(arg1: *mut lock_object,
                           arg2: ::kernel::sys::raw::c_int,
                           arg3: *const ::kernel::sys::raw::c_char,
                           arg4: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn witness_downgrade(arg1: *mut lock_object,
                             arg2: ::kernel::sys::raw::c_int,
                             arg3: *const ::kernel::sys::raw::c_char,
                             arg4: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn witness_unlock(arg1: *mut lock_object,
                          arg2: ::kernel::sys::raw::c_int,
                          arg3: *const ::kernel::sys::raw::c_char,
                          arg4: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn witness_save(arg1: *mut lock_object,
                        arg2: *mut *const ::kernel::sys::raw::c_char,
                        arg3: *mut ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn witness_restore(arg1: *mut lock_object,
                           arg2: *const ::kernel::sys::raw::c_char,
                           arg3: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn witness_list_locks(arg1: *mut *mut lock_list_entry,
                              arg2:
                                  ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                                  *const ::kernel::sys::raw::c_char, ...)
                                                             ->
                                                                 ::kernel::sys::raw::c_int>)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn witness_warn(arg1: ::kernel::sys::raw::c_int,
                        arg2: *mut lock_object,
                        arg3: *const ::kernel::sys::raw::c_char, ...)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn witness_assert(arg1: *const lock_object,
                          arg2: ::kernel::sys::raw::c_int,
                          arg3: *const ::kernel::sys::raw::c_char,
                          arg4: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn witness_display_spinlock(arg1: *mut lock_object, arg2: *mut thread,
                                    arg3:
                                        ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                                        *const ::kernel::sys::raw::c_char, ...)
                                                                   ->
                                                                       ::kernel::sys::raw::c_int>);
}
extern "C" {
    pub fn witness_line(arg1: *mut lock_object) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn witness_norelease(arg1: *mut lock_object);
}
extern "C" {
    pub fn witness_releaseok(arg1: *mut lock_object);
}
extern "C" {
    pub fn witness_file(arg1: *mut lock_object)
     -> *const ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn witness_thread_exit(arg1: *mut thread);
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct bitset {
    pub __bits: [::kernel::sys::raw::c_long; 1usize],
}
#[test]
fn bindgen_test_layout_bitset() {
    assert_eq!(::core::mem::size_of::<bitset>() , 8usize , concat ! (
               "Size of: " , stringify ! ( bitset ) ));
    assert_eq! (::core::mem::align_of::<bitset>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( bitset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bitset ) ) . __bits as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( bitset ) , "::" ,
                stringify ! ( __bits ) ));
}
impl Clone for bitset {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct _cpuset {
    pub __bits: [::kernel::sys::raw::c_long; 4usize],
}
#[test]
fn bindgen_test_layout__cpuset() {
    assert_eq!(::core::mem::size_of::<_cpuset>() , 32usize , concat ! (
               "Size of: " , stringify ! ( _cpuset ) ));
    assert_eq! (::core::mem::align_of::<_cpuset>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _cpuset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _cpuset ) ) . __bits as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _cpuset ) , "::" ,
                stringify ! ( __bits ) ));
}
impl Clone for _cpuset {
    fn clone(&self) -> Self { *self }
}
pub type cpuset_t = _cpuset;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ktr_entry {
    pub ktr_timestamp: u_int64_t,
    pub ktr_cpu: ::kernel::sys::raw::c_int,
    pub ktr_line: ::kernel::sys::raw::c_int,
    pub ktr_file: *const ::kernel::sys::raw::c_char,
    pub ktr_desc: *const ::kernel::sys::raw::c_char,
    pub ktr_thread: *mut thread,
    pub ktr_parms: [u_long; 6usize],
}
#[test]
fn bindgen_test_layout_ktr_entry() {
    assert_eq!(::core::mem::size_of::<ktr_entry>() , 88usize , concat ! (
               "Size of: " , stringify ! ( ktr_entry ) ));
    assert_eq! (::core::mem::align_of::<ktr_entry>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ktr_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ktr_entry ) ) . ktr_timestamp as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ktr_entry ) , "::" ,
                stringify ! ( ktr_timestamp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ktr_entry ) ) . ktr_cpu as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ktr_entry ) , "::" ,
                stringify ! ( ktr_cpu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ktr_entry ) ) . ktr_line as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( ktr_entry ) , "::" ,
                stringify ! ( ktr_line ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ktr_entry ) ) . ktr_file as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ktr_entry ) , "::" ,
                stringify ! ( ktr_file ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ktr_entry ) ) . ktr_desc as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ktr_entry ) , "::" ,
                stringify ! ( ktr_desc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ktr_entry ) ) . ktr_thread as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( ktr_entry ) , "::" ,
                stringify ! ( ktr_thread ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ktr_entry ) ) . ktr_parms as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( ktr_entry ) , "::" ,
                stringify ! ( ktr_parms ) ));
}
impl Clone for ktr_entry {
    fn clone(&self) -> Self { *self }
}
impl Default for ktr_entry {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    #[link_name = "ktr_cpumask"]
    pub static mut ktr_cpumask: cpuset_t;
}
extern "C" {
    #[link_name = "ktr_mask"]
    pub static mut ktr_mask: u64;
}
extern "C" {
    #[link_name = "ktr_entries"]
    pub static mut ktr_entries: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "ktr_verbose"]
    pub static mut ktr_verbose: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "ktr_idx"]
    pub static mut ktr_idx: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "ktr_buf"]
    pub static mut ktr_buf: *mut ktr_entry;
}
#[repr(C)]
#[derive(Copy)]
pub struct mtx_padalign {
    pub lock_object: lock_object,
    pub mtx_lock: usize,
    pub __bindgen_padding_0: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_mtx_padalign() {
    assert_eq!(::core::mem::size_of::<mtx_padalign>() , 64usize , concat ! (
               "Size of: " , stringify ! ( mtx_padalign ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mtx_padalign ) ) . lock_object as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mtx_padalign ) , "::" ,
                stringify ! ( lock_object ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mtx_padalign ) ) . mtx_lock as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( mtx_padalign ) , "::" ,
                stringify ! ( mtx_lock ) ));
}
impl Clone for mtx_padalign {
    fn clone(&self) -> Self { *self }
}
impl Default for mtx_padalign {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for mtx_padalign {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "mtx_padalign {{ lock_object: {:?}, mtx_lock: {:?} }}" ,
               self . lock_object , self . mtx_lock)
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sx {
    pub lock_object: lock_object,
    pub sx_lock: usize,
}
#[test]
fn bindgen_test_layout_sx() {
    assert_eq!(::core::mem::size_of::<sx>() , 32usize , concat ! (
               "Size of: " , stringify ! ( sx ) ));
    assert_eq! (::core::mem::align_of::<sx>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sx ) ) . lock_object as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sx ) , "::" , stringify
                ! ( lock_object ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sx ) ) . sx_lock as * const _ as usize }
                , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( sx ) , "::" , stringify
                ! ( sx_lock ) ));
}
impl Clone for sx {
    fn clone(&self) -> Self { *self }
}
impl Default for sx {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rmpriolist {
    pub lh_first: *mut rm_priotracker,
}
#[test]
fn bindgen_test_layout_rmpriolist() {
    assert_eq!(::core::mem::size_of::<rmpriolist>() , 8usize , concat ! (
               "Size of: " , stringify ! ( rmpriolist ) ));
    assert_eq! (::core::mem::align_of::<rmpriolist>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rmpriolist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmpriolist ) ) . lh_first as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rmpriolist ) , "::" ,
                stringify ! ( lh_first ) ));
}
impl Clone for rmpriolist {
    fn clone(&self) -> Self { *self }
}
impl Default for rmpriolist {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rm_queue {
    pub rmq_next: *mut rm_queue,
    pub rmq_prev: *mut rm_queue,
}
#[test]
fn bindgen_test_layout_rm_queue() {
    assert_eq!(::core::mem::size_of::<rm_queue>() , 16usize , concat ! (
               "Size of: " , stringify ! ( rm_queue ) ));
    assert_eq! (::core::mem::align_of::<rm_queue>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rm_queue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rm_queue ) ) . rmq_next as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rm_queue ) , "::" ,
                stringify ! ( rmq_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rm_queue ) ) . rmq_prev as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rm_queue ) , "::" ,
                stringify ! ( rmq_prev ) ));
}
impl Clone for rm_queue {
    fn clone(&self) -> Self { *self }
}
impl Default for rm_queue {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct rmlock {
    pub lock_object: lock_object,
    pub rm_writecpus: cpuset_t,
    pub rm_activeReaders: rmlock__bindgen_ty_1,
    pub _rm_lock: rmlock__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rmlock__bindgen_ty_1 {
    pub lh_first: *mut rm_priotracker,
}
#[test]
fn bindgen_test_layout_rmlock__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<rmlock__bindgen_ty_1>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( rmlock__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<rmlock__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rmlock__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmlock__bindgen_ty_1 ) ) . lh_first as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rmlock__bindgen_ty_1 )
                , "::" , stringify ! ( lh_first ) ));
}
impl Clone for rmlock__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for rmlock__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub union rmlock__bindgen_ty_2 {
    pub _rm_wlock_object: lock_object,
    pub _rm_lock_mtx: mtx,
    pub _rm_lock_sx: sx,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_rmlock__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<rmlock__bindgen_ty_2>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( rmlock__bindgen_ty_2 )
               ));
    assert_eq! (::core::mem::align_of::<rmlock__bindgen_ty_2>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rmlock__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmlock__bindgen_ty_2 ) ) .
                _rm_wlock_object as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rmlock__bindgen_ty_2 )
                , "::" , stringify ! ( _rm_wlock_object ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmlock__bindgen_ty_2 ) ) . _rm_lock_mtx
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rmlock__bindgen_ty_2 )
                , "::" , stringify ! ( _rm_lock_mtx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmlock__bindgen_ty_2 ) ) . _rm_lock_sx as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rmlock__bindgen_ty_2 )
                , "::" , stringify ! ( _rm_lock_sx ) ));
}
impl Clone for rmlock__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for rmlock__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for rmlock__bindgen_ty_2 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "rmlock__bindgen_ty_2 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_rmlock() {
    assert_eq!(::core::mem::size_of::<rmlock>() , 96usize , concat ! (
               "Size of: " , stringify ! ( rmlock ) ));
    assert_eq! (::core::mem::align_of::<rmlock>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rmlock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmlock ) ) . lock_object as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rmlock ) , "::" ,
                stringify ! ( lock_object ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmlock ) ) . rm_writecpus as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rmlock ) , "::" ,
                stringify ! ( rm_writecpus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmlock ) ) . rm_activeReaders as * const
                _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( rmlock ) , "::" ,
                stringify ! ( rm_activeReaders ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rmlock ) ) . _rm_lock as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( rmlock ) , "::" ,
                stringify ! ( _rm_lock ) ));
}
impl Clone for rmlock {
    fn clone(&self) -> Self { *self }
}
impl Default for rmlock {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for rmlock {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "rmlock {{ lock_object: {:?}, rm_writecpus: {:?}, rm_activeReaders: {:?}, _rm_lock: {:?} }}"
               , self . lock_object , self . rm_writecpus , self .
               rm_activeReaders , self . _rm_lock)
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rm_priotracker {
    pub rmp_cpuQueue: rm_queue,
    pub rmp_rmlock: *mut rmlock,
    pub rmp_thread: *mut thread,
    pub rmp_flags: ::kernel::sys::raw::c_int,
    pub rmp_qentry: rm_priotracker__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rm_priotracker__bindgen_ty_1 {
    pub le_next: *mut rm_priotracker,
    pub le_prev: *mut *mut rm_priotracker,
}
#[test]
fn bindgen_test_layout_rm_priotracker__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<rm_priotracker__bindgen_ty_1>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( rm_priotracker__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<rm_priotracker__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( rm_priotracker__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rm_priotracker__bindgen_ty_1 ) ) .
                le_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                rm_priotracker__bindgen_ty_1 ) , "::" , stringify ! ( le_next
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rm_priotracker__bindgen_ty_1 ) ) .
                le_prev as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                rm_priotracker__bindgen_ty_1 ) , "::" , stringify ! ( le_prev
                ) ));
}
impl Clone for rm_priotracker__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for rm_priotracker__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_rm_priotracker() {
    assert_eq!(::core::mem::size_of::<rm_priotracker>() , 56usize , concat ! (
               "Size of: " , stringify ! ( rm_priotracker ) ));
    assert_eq! (::core::mem::align_of::<rm_priotracker>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( rm_priotracker ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rm_priotracker ) ) . rmp_cpuQueue as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rm_priotracker ) , "::"
                , stringify ! ( rmp_cpuQueue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rm_priotracker ) ) . rmp_rmlock as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rm_priotracker ) , "::"
                , stringify ! ( rmp_rmlock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rm_priotracker ) ) . rmp_thread as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rm_priotracker ) , "::"
                , stringify ! ( rmp_thread ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rm_priotracker ) ) . rmp_flags as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rm_priotracker ) , "::"
                , stringify ! ( rmp_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rm_priotracker ) ) . rmp_qentry as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rm_priotracker ) , "::"
                , stringify ! ( rmp_qentry ) ));
}
impl Clone for rm_priotracker {
    fn clone(&self) -> Self { *self }
}
impl Default for rm_priotracker {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct rusage {
    pub ru_utime: timeval,
    pub ru_stime: timeval,
    pub ru_maxrss: ::kernel::sys::raw::c_long,
    pub ru_ixrss: ::kernel::sys::raw::c_long,
    pub ru_idrss: ::kernel::sys::raw::c_long,
    pub ru_isrss: ::kernel::sys::raw::c_long,
    pub ru_minflt: ::kernel::sys::raw::c_long,
    pub ru_majflt: ::kernel::sys::raw::c_long,
    pub ru_nswap: ::kernel::sys::raw::c_long,
    pub ru_inblock: ::kernel::sys::raw::c_long,
    pub ru_oublock: ::kernel::sys::raw::c_long,
    pub ru_msgsnd: ::kernel::sys::raw::c_long,
    pub ru_msgrcv: ::kernel::sys::raw::c_long,
    pub ru_nsignals: ::kernel::sys::raw::c_long,
    pub ru_nvcsw: ::kernel::sys::raw::c_long,
    pub ru_nivcsw: ::kernel::sys::raw::c_long,
}
#[test]
fn bindgen_test_layout_rusage() {
    assert_eq!(::core::mem::size_of::<rusage>() , 144usize , concat ! (
               "Size of: " , stringify ! ( rusage ) ));
    assert_eq! (::core::mem::align_of::<rusage>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rusage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_utime as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_utime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_stime as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_stime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_maxrss as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_maxrss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_ixrss as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_ixrss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_idrss as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_idrss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_isrss as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_isrss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_minflt as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_minflt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_majflt as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_majflt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_nswap as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_nswap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_inblock as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_inblock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_oublock as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_oublock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_msgsnd as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_msgsnd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_msgrcv as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_msgrcv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_nsignals as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_nsignals ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_nvcsw as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_nvcsw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage ) ) . ru_nivcsw as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage ) , "::" ,
                stringify ! ( ru_nivcsw ) ));
}
impl Clone for rusage {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct __wrusage {
    pub wru_self: rusage,
    pub wru_children: rusage,
}
#[test]
fn bindgen_test_layout___wrusage() {
    assert_eq!(::core::mem::size_of::<__wrusage>() , 288usize , concat ! (
               "Size of: " , stringify ! ( __wrusage ) ));
    assert_eq! (::core::mem::align_of::<__wrusage>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __wrusage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __wrusage ) ) . wru_self as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __wrusage ) , "::" ,
                stringify ! ( wru_self ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __wrusage ) ) . wru_children as * const _
                as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( __wrusage ) , "::" ,
                stringify ! ( wru_children ) ));
}
impl Clone for __wrusage {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct rlimit {
    pub rlim_cur: rlim_t,
    pub rlim_max: rlim_t,
}
#[test]
fn bindgen_test_layout_rlimit() {
    assert_eq!(::core::mem::size_of::<rlimit>() , 16usize , concat ! (
               "Size of: " , stringify ! ( rlimit ) ));
    assert_eq! (::core::mem::align_of::<rlimit>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rlimit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rlimit ) ) . rlim_cur as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rlimit ) , "::" ,
                stringify ! ( rlim_cur ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rlimit ) ) . rlim_max as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rlimit ) , "::" ,
                stringify ! ( rlim_max ) ));
}
impl Clone for rlimit {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct orlimit {
    pub rlim_cur: __int32_t,
    pub rlim_max: __int32_t,
}
#[test]
fn bindgen_test_layout_orlimit() {
    assert_eq!(::core::mem::size_of::<orlimit>() , 8usize , concat ! (
               "Size of: " , stringify ! ( orlimit ) ));
    assert_eq! (::core::mem::align_of::<orlimit>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( orlimit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const orlimit ) ) . rlim_cur as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( orlimit ) , "::" ,
                stringify ! ( rlim_cur ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const orlimit ) ) . rlim_max as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( orlimit ) , "::" ,
                stringify ! ( rlim_max ) ));
}
impl Clone for orlimit {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct loadavg {
    pub ldavg: [__fixpt_t; 3usize],
    pub fscale: ::kernel::sys::raw::c_long,
}
#[test]
fn bindgen_test_layout_loadavg() {
    assert_eq!(::core::mem::size_of::<loadavg>() , 24usize , concat ! (
               "Size of: " , stringify ! ( loadavg ) ));
    assert_eq! (::core::mem::align_of::<loadavg>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( loadavg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const loadavg ) ) . ldavg as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( loadavg ) , "::" ,
                stringify ! ( ldavg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const loadavg ) ) . fscale as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( loadavg ) , "::" ,
                stringify ! ( fscale ) ));
}
impl Clone for loadavg {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "averunnable"]
    pub static mut averunnable: loadavg;
}
extern "C" {
    pub fn read_cpu_time(cp_time: *mut ::kernel::sys::raw::c_long);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcb {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "__start_set_pcpu"]
    pub static mut __start_set_pcpu: *mut usize;
}
extern "C" {
    #[link_name = "__stop_set_pcpu"]
    pub static mut __stop_set_pcpu: *mut usize;
}
extern "C" {
    #[link_name = "dpcpu_off"]
    pub static mut dpcpu_off: [usize; 0usize];
}
#[repr(C)]
#[derive(Copy)]
pub struct pcpu {
    pub pc_curthread: *mut thread,
    pub pc_idlethread: *mut thread,
    pub pc_fpcurthread: *mut thread,
    pub pc_deadthread: *mut thread,
    pub pc_curpcb: *mut pcb,
    pub pc_switchtime: u64,
    pub pc_switchticks: ::kernel::sys::raw::c_int,
    pub pc_cpuid: u_int,
    pub pc_allcpu: pcpu__bindgen_ty_1,
    pub pc_spinlocks: *mut lock_list_entry,
    pub pc_cp_time: [::kernel::sys::raw::c_long; 5usize],
    pub pc_device: *mut device,
    pub pc_netisr: *mut ::kernel::sys::raw::c_void,
    pub pc_unused1: ::kernel::sys::raw::c_int,
    pub pc_domain: ::kernel::sys::raw::c_int,
    pub pc_rm_queue: rm_queue,
    pub pc_dynamic: usize,
    pub pc_early_dummy_counter: u64,
    pub __bindgen_padding_0: [u8; 88usize],
    pub pc_monitorbuf: [::kernel::sys::raw::c_char; 128usize],
    pub pc_prvspace: *mut pcpu,
    pub pc_curpmap: *mut pmap,
    pub pc_tssp: *mut amd64tss,
    pub pc_commontssp: *mut amd64tss,
    pub pc_kcr3: u64,
    pub pc_ucr3: u64,
    pub pc_saved_ucr3: u64,
    pub pc_rsp0: register_t,
    pub pc_scratch_rsp: register_t,
    pub pc_scratch_rax: register_t,
    pub pc_apic_id: u_int,
    pub pc_acpi_id: u_int,
    pub pc_fs32p: *mut user_segment_descriptor,
    pub pc_gs32p: *mut user_segment_descriptor,
    pub pc_ldt: *mut system_segment_descriptor,
    pub pc_tss: *mut system_segment_descriptor,
    pub pc_pm_save_cnt: u64,
    pub pc_cmci_mask: u_int,
    pub pc_dbreg: [u64; 16usize],
    pub pc_pti_stack: [u64; 16usize],
    pub pc_pti_rsp0: register_t,
    pub pc_dbreg_cmd: ::kernel::sys::raw::c_int,
    pub pc_vcpu_id: u_int,
    pub pc_pcid_next: u32,
    pub pc_pcid_gen: u32,
    pub pc_smp_tlb_done: u32,
    pub pc_ibpb_set: u32,
    pub __pad: [::kernel::sys::raw::c_char; 216usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pcpu__bindgen_ty_1 {
    pub stqe_next: *mut pcpu,
}
#[test]
fn bindgen_test_layout_pcpu__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<pcpu__bindgen_ty_1>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( pcpu__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<pcpu__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( pcpu__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu__bindgen_ty_1 ) ) . stqe_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu__bindgen_ty_1 ) ,
                "::" , stringify ! ( stqe_next ) ));
}
impl Clone for pcpu__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for pcpu__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_pcpu() {
    assert_eq!(::core::mem::size_of::<pcpu>() , 1024usize , concat ! (
               "Size of: " , stringify ! ( pcpu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_curthread as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_curthread ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_idlethread as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_idlethread ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_fpcurthread as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_fpcurthread ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_deadthread as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_deadthread ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_curpcb as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_curpcb ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_switchtime as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_switchtime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_switchticks as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_switchticks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_cpuid as * const _ as usize
                } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_cpuid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_allcpu as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_allcpu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_spinlocks as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_spinlocks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_cp_time as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_cp_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_device as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_device ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_netisr as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_netisr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_unused1 as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_unused1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_domain as * const _ as
                usize } , 132usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_domain ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_rm_queue as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_rm_queue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_dynamic as * const _ as
                usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_dynamic ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_early_dummy_counter as *
                const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_early_dummy_counter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_monitorbuf as * const _ as
                usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_monitorbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_prvspace as * const _ as
                usize } , 384usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_prvspace ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_curpmap as * const _ as
                usize } , 392usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_curpmap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_tssp as * const _ as usize
                } , 400usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_tssp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_commontssp as * const _ as
                usize } , 408usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_commontssp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_kcr3 as * const _ as usize
                } , 416usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_kcr3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_ucr3 as * const _ as usize
                } , 424usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_ucr3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_saved_ucr3 as * const _ as
                usize } , 432usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_saved_ucr3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_rsp0 as * const _ as usize
                } , 440usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_rsp0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_scratch_rsp as * const _ as
                usize } , 448usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_scratch_rsp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_scratch_rax as * const _ as
                usize } , 456usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_scratch_rax ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_apic_id as * const _ as
                usize } , 464usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_apic_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_acpi_id as * const _ as
                usize } , 468usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_acpi_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_fs32p as * const _ as usize
                } , 472usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_fs32p ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_gs32p as * const _ as usize
                } , 480usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_gs32p ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_ldt as * const _ as usize }
                , 488usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_ldt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_tss as * const _ as usize }
                , 496usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_tss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_pm_save_cnt as * const _ as
                usize } , 504usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_pm_save_cnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_cmci_mask as * const _ as
                usize } , 512usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_cmci_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_dbreg as * const _ as usize
                } , 520usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_dbreg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_pti_stack as * const _ as
                usize } , 648usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_pti_stack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_pti_rsp0 as * const _ as
                usize } , 776usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_pti_rsp0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_dbreg_cmd as * const _ as
                usize } , 784usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_dbreg_cmd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_vcpu_id as * const _ as
                usize } , 788usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_vcpu_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_pcid_next as * const _ as
                usize } , 792usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_pcid_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_pcid_gen as * const _ as
                usize } , 796usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_pcid_gen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_smp_tlb_done as * const _
                as usize } , 800usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_smp_tlb_done ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . pc_ibpb_set as * const _ as
                usize } , 804usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( pc_ibpb_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcpu ) ) . __pad as * const _ as usize }
                , 808usize , concat ! (
                "Alignment of field: " , stringify ! ( pcpu ) , "::" ,
                stringify ! ( __pad ) ));
}
impl Clone for pcpu {
    fn clone(&self) -> Self { *self }
}
impl Default for pcpu {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for pcpu {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "pcpu {{ pc_curthread: {:?}, pc_idlethread: {:?}, pc_fpcurthread: {:?}, pc_deadthread: {:?}, pc_curpcb: {:?}, pc_switchtime: {:?}, pc_switchticks: {:?}, pc_cpuid: {:?}, pc_allcpu: {:?}, pc_spinlocks: {:?}, pc_cp_time: {:?}, pc_device: {:?}, pc_netisr: {:?}, pc_unused1: {:?}, pc_domain: {:?}, pc_rm_queue: {:?}, pc_dynamic: {:?}, pc_early_dummy_counter: {:?}, pc_monitorbuf: [{}], pc_prvspace: {:?}, pc_curpmap: {:?}, pc_tssp: {:?}, pc_commontssp: {:?}, pc_kcr3: {:?}, pc_ucr3: {:?}, pc_saved_ucr3: {:?}, pc_rsp0: {:?}, pc_scratch_rsp: {:?}, pc_scratch_rax: {:?}, pc_apic_id: {:?}, pc_acpi_id: {:?}, pc_fs32p: {:?}, pc_gs32p: {:?}, pc_ldt: {:?}, pc_tss: {:?}, pc_pm_save_cnt: {:?}, pc_cmci_mask: {:?}, pc_dbreg: {:?}, pc_pti_stack: {:?}, pc_pti_rsp0: {:?}, pc_dbreg_cmd: {:?}, pc_vcpu_id: {:?}, pc_pcid_next: {:?}, pc_pcid_gen: {:?}, pc_smp_tlb_done: {:?}, pc_ibpb_set: {:?}, __pad: [{}] }}"
               , self . pc_curthread , self . pc_idlethread , self .
               pc_fpcurthread , self . pc_deadthread , self . pc_curpcb , self
               . pc_switchtime , self . pc_switchticks , self . pc_cpuid ,
               self . pc_allcpu , self . pc_spinlocks , self . pc_cp_time ,
               self . pc_device , self . pc_netisr , self . pc_unused1 , self
               . pc_domain , self . pc_rm_queue , self . pc_dynamic , self .
               pc_early_dummy_counter , self . pc_monitorbuf . iter (  ) .
               enumerate (  ) . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ) , self . pc_prvspace , self . pc_curpmap , self .
               pc_tssp , self . pc_commontssp , self . pc_kcr3 , self .
               pc_ucr3 , self . pc_saved_ucr3 , self . pc_rsp0 , self .
               pc_scratch_rsp , self . pc_scratch_rax , self . pc_apic_id ,
               self . pc_acpi_id , self . pc_fs32p , self . pc_gs32p , self .
               pc_ldt , self . pc_tss , self . pc_pm_save_cnt , self .
               pc_cmci_mask , self . pc_dbreg , self . pc_pti_stack , self .
               pc_pti_rsp0 , self . pc_dbreg_cmd , self . pc_vcpu_id , self .
               pc_pcid_next , self . pc_pcid_gen , self . pc_smp_tlb_done ,
               self . pc_ibpb_set , self . __pad . iter (  ) . enumerate (  )
               . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ))
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cpuhead {
    pub stqh_first: *mut pcpu,
    pub stqh_last: *mut *mut pcpu,
}
#[test]
fn bindgen_test_layout_cpuhead() {
    assert_eq!(::core::mem::size_of::<cpuhead>() , 16usize , concat ! (
               "Size of: " , stringify ! ( cpuhead ) ));
    assert_eq! (::core::mem::align_of::<cpuhead>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( cpuhead ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuhead ) ) . stqh_first as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuhead ) , "::" ,
                stringify ! ( stqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuhead ) ) . stqh_last as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuhead ) , "::" ,
                stringify ! ( stqh_last ) ));
}
impl Clone for cpuhead {
    fn clone(&self) -> Self { *self }
}
impl Default for cpuhead {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    #[link_name = "cpuhead"]
    pub static mut cpuhead: cpuhead;
}
extern "C" {
    #[link_name = "cpuid_to_pcpu"]
    pub static mut cpuid_to_pcpu: [*mut pcpu; 0usize];
}
extern "C" {
    pub fn cpu_pcpu_init(pcpu: *mut pcpu, cpuid: ::kernel::sys::raw::c_int,
                         size: usize);
}
extern "C" {
    pub fn db_show_mdpcpu(pcpu: *mut pcpu);
}
extern "C" {
    pub fn dpcpu_alloc(size: ::kernel::sys::raw::c_int)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn dpcpu_copy(s: *mut ::kernel::sys::raw::c_void,
                      size: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn dpcpu_free(s: *mut ::kernel::sys::raw::c_void,
                      size: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn dpcpu_init(dpcpu: *mut ::kernel::sys::raw::c_void,
                      cpuid: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn pcpu_destroy(pcpu: *mut pcpu);
}
extern "C" {
    pub fn pcpu_find(cpuid: u_int) -> *mut pcpu;
}
extern "C" {
    pub fn pcpu_init(pcpu: *mut pcpu, cpuid: ::kernel::sys::raw::c_int,
                     size: usize);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lock_profile_object {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct lpohead {
    pub lh_first: *mut lock_profile_object,
}
#[test]
fn bindgen_test_layout_lpohead() {
    assert_eq!(::core::mem::size_of::<lpohead>() , 8usize , concat ! (
               "Size of: " , stringify ! ( lpohead ) ));
    assert_eq! (::core::mem::align_of::<lpohead>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( lpohead ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const lpohead ) ) . lh_first as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( lpohead ) , "::" ,
                stringify ! ( lh_first ) ));
}
impl Clone for lpohead {
    fn clone(&self) -> Self { *self }
}
impl Default for lpohead {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    #[link_name = "sdt_probes_enabled"]
    pub static mut sdt_probes_enabled: bool_;
}
pub type sdt_probe_func_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: u32, arg0: usize,
                                                arg1: usize, arg2: usize,
                                                arg3: usize, arg4: usize)>;
extern "C" {
    #[link_name = "sdt_probe_func"]
    pub static mut sdt_probe_func: sdt_probe_func_t;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sdt_probe {
    pub version: ::kernel::sys::raw::c_int,
    pub prov: *mut sdt_provider,
    pub probe_entry: sdt_probe__bindgen_ty_1,
    pub argtype_list: sdt_probe__bindgen_ty_2,
    pub mod_: *const ::kernel::sys::raw::c_char,
    pub func: *const ::kernel::sys::raw::c_char,
    pub name: *const ::kernel::sys::raw::c_char,
    pub id: id_t,
    pub n_args: ::kernel::sys::raw::c_int,
    pub sdtp_lf: *mut linker_file,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sdt_probe__bindgen_ty_1 {
    pub tqe_next: *mut sdt_probe,
    pub tqe_prev: *mut *mut sdt_probe,
}
#[test]
fn bindgen_test_layout_sdt_probe__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<sdt_probe__bindgen_ty_1>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( sdt_probe__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<sdt_probe__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( sdt_probe__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe__bindgen_ty_1 ) ) . tqe_next as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe__bindgen_ty_1
                ) , "::" , stringify ! ( tqe_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe__bindgen_ty_1 ) ) . tqe_prev as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe__bindgen_ty_1
                ) , "::" , stringify ! ( tqe_prev ) ));
}
impl Clone for sdt_probe__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for sdt_probe__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sdt_probe__bindgen_ty_2 {
    pub tqh_first: *mut sdt_argtype,
    pub tqh_last: *mut *mut sdt_argtype,
}
#[test]
fn bindgen_test_layout_sdt_probe__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<sdt_probe__bindgen_ty_2>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( sdt_probe__bindgen_ty_2 ) ));
    assert_eq! (::core::mem::align_of::<sdt_probe__bindgen_ty_2>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( sdt_probe__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe__bindgen_ty_2 ) ) . tqh_first
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe__bindgen_ty_2
                ) , "::" , stringify ! ( tqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe__bindgen_ty_2 ) ) . tqh_last as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe__bindgen_ty_2
                ) , "::" , stringify ! ( tqh_last ) ));
}
impl Clone for sdt_probe__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for sdt_probe__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_sdt_probe() {
    assert_eq!(::core::mem::size_of::<sdt_probe>() , 96usize , concat ! (
               "Size of: " , stringify ! ( sdt_probe ) ));
    assert_eq! (::core::mem::align_of::<sdt_probe>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sdt_probe ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . version as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . prov as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( prov ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . probe_entry as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( probe_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . argtype_list as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( argtype_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . mod_ as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( mod_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . func as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . name as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . id as * const _ as usize
                } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . n_args as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( n_args ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_probe ) ) . sdtp_lf as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_probe ) , "::" ,
                stringify ! ( sdtp_lf ) ));
}
impl Clone for sdt_probe {
    fn clone(&self) -> Self { *self }
}
impl Default for sdt_probe {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sdt_provider {
    pub name: *mut ::kernel::sys::raw::c_char,
    pub prov_entry: sdt_provider__bindgen_ty_1,
    pub id: usize,
    pub sdt_refs: ::kernel::sys::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sdt_provider__bindgen_ty_1 {
    pub tqe_next: *mut sdt_provider,
    pub tqe_prev: *mut *mut sdt_provider,
}
#[test]
fn bindgen_test_layout_sdt_provider__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<sdt_provider__bindgen_ty_1>() , 16usize
               , concat ! (
               "Size of: " , stringify ! ( sdt_provider__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<sdt_provider__bindgen_ty_1>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( sdt_provider__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_provider__bindgen_ty_1 ) ) . tqe_next
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                sdt_provider__bindgen_ty_1 ) , "::" , stringify ! ( tqe_next )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_provider__bindgen_ty_1 ) ) . tqe_prev
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                sdt_provider__bindgen_ty_1 ) , "::" , stringify ! ( tqe_prev )
                ));
}
impl Clone for sdt_provider__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for sdt_provider__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_sdt_provider() {
    assert_eq!(::core::mem::size_of::<sdt_provider>() , 40usize , concat ! (
               "Size of: " , stringify ! ( sdt_provider ) ));
    assert_eq! (::core::mem::align_of::<sdt_provider>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sdt_provider ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_provider ) ) . name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_provider ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_provider ) ) . prov_entry as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_provider ) , "::" ,
                stringify ! ( prov_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_provider ) ) . id as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_provider ) , "::" ,
                stringify ! ( id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_provider ) ) . sdt_refs as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_provider ) , "::" ,
                stringify ! ( sdt_refs ) ));
}
impl Clone for sdt_provider {
    fn clone(&self) -> Self { *self }
}
impl Default for sdt_provider {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct linker_file {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sdt_argtype {
    pub ndx: ::kernel::sys::raw::c_int,
    pub type_: *const ::kernel::sys::raw::c_char,
    pub xtype: *const ::kernel::sys::raw::c_char,
    pub argtype_entry: sdt_argtype__bindgen_ty_1,
    pub probe: *mut sdt_probe,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sdt_argtype__bindgen_ty_1 {
    pub tqe_next: *mut sdt_argtype,
    pub tqe_prev: *mut *mut sdt_argtype,
}
#[test]
fn bindgen_test_layout_sdt_argtype__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<sdt_argtype__bindgen_ty_1>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( sdt_argtype__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<sdt_argtype__bindgen_ty_1>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( sdt_argtype__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_argtype__bindgen_ty_1 ) ) . tqe_next
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                sdt_argtype__bindgen_ty_1 ) , "::" , stringify ! ( tqe_next )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_argtype__bindgen_ty_1 ) ) . tqe_prev
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                sdt_argtype__bindgen_ty_1 ) , "::" , stringify ! ( tqe_prev )
                ));
}
impl Clone for sdt_argtype__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for sdt_argtype__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_sdt_argtype() {
    assert_eq!(::core::mem::size_of::<sdt_argtype>() , 48usize , concat ! (
               "Size of: " , stringify ! ( sdt_argtype ) ));
    assert_eq! (::core::mem::align_of::<sdt_argtype>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sdt_argtype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_argtype ) ) . ndx as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_argtype ) , "::" ,
                stringify ! ( ndx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_argtype ) ) . type_ as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_argtype ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_argtype ) ) . xtype as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_argtype ) , "::" ,
                stringify ! ( xtype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_argtype ) ) . argtype_entry as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_argtype ) , "::" ,
                stringify ! ( argtype_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sdt_argtype ) ) . probe as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( sdt_argtype ) , "::" ,
                stringify ! ( probe ) ));
}
impl Clone for sdt_argtype {
    fn clone(&self) -> Self { *self }
}
impl Default for sdt_argtype {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    pub fn sdt_probe_stub(arg1: u32, arg2: usize, arg3: usize, arg4: usize,
                          arg5: usize, arg6: usize);
}
extern "C" {
    #[link_name = "lockstat_enabled"]
    pub static mut lockstat_enabled: bool_;
}
extern "C" {
    pub fn _mtx_init(c: *mut usize, name: *const ::kernel::sys::raw::c_char,
                     type_: *const ::kernel::sys::raw::c_char,
                     opts: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn _mtx_destroy(c: *mut usize);
}
extern "C" {
    pub fn mtx_sysinit(arg: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn _mtx_trylock_flags_int(m: *mut mtx,
                                  opts: ::kernel::sys::raw::c_int,
                                  file: *const ::kernel::sys::raw::c_char,
                                  line: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn _mtx_trylock_flags_(c: *mut usize, opts: ::kernel::sys::raw::c_int,
                               file: *const ::kernel::sys::raw::c_char,
                               line: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn mutex_init();
}
extern "C" {
    pub fn __mtx_lock_sleep(c: *mut usize, v: usize,
                            opts: ::kernel::sys::raw::c_int,
                            file: *const ::kernel::sys::raw::c_char,
                            line: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn __mtx_unlock_sleep(c: *mut usize, v: usize,
                              opts: ::kernel::sys::raw::c_int,
                              file: *const ::kernel::sys::raw::c_char,
                              line: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn __mtx_lock_flags(c: *mut usize, opts: ::kernel::sys::raw::c_int,
                            file: *const ::kernel::sys::raw::c_char,
                            line: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn __mtx_unlock_flags(c: *mut usize, opts: ::kernel::sys::raw::c_int,
                              file: *const ::kernel::sys::raw::c_char,
                              line: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn __mtx_lock_spin_flags(c: *mut usize,
                                 opts: ::kernel::sys::raw::c_int,
                                 file: *const ::kernel::sys::raw::c_char,
                                 line: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn __mtx_trylock_spin_flags(c: *mut usize,
                                    opts: ::kernel::sys::raw::c_int,
                                    file: *const ::kernel::sys::raw::c_char,
                                    line: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn __mtx_unlock_spin_flags(c: *mut usize,
                                   opts: ::kernel::sys::raw::c_int,
                                   file: *const ::kernel::sys::raw::c_char,
                                   line: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn mtx_spin_wait_unlocked(m: *mut mtx);
}
extern "C" {
    pub fn thread_lock_flags_(arg1: *mut thread,
                              arg2: ::kernel::sys::raw::c_int,
                              arg3: *const ::kernel::sys::raw::c_char,
                              arg4: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn _thread_lock(td: *mut thread, opts: ::kernel::sys::raw::c_int,
                        file: *const ::kernel::sys::raw::c_char,
                        line: ::kernel::sys::raw::c_int);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mtx_pool {
    _unused: [u8; 0],
}
extern "C" {
    pub fn mtx_pool_create(mtx_name: *const ::kernel::sys::raw::c_char,
                           pool_size: ::kernel::sys::raw::c_int,
                           opts: ::kernel::sys::raw::c_int) -> *mut mtx_pool;
}
extern "C" {
    pub fn mtx_pool_destroy(poolp: *mut *mut mtx_pool);
}
extern "C" {
    pub fn mtx_pool_find(pool: *mut mtx_pool,
                         ptr: *mut ::kernel::sys::raw::c_void) -> *mut mtx;
}
extern "C" {
    pub fn mtx_pool_alloc(pool: *mut mtx_pool) -> *mut mtx;
}
extern "C" {
    #[link_name = "mtxpool_sleep"]
    pub static mut mtxpool_sleep: *mut mtx_pool;
}
extern "C" {
    #[link_name = "Giant"]
    pub static mut Giant: mtx;
}
extern "C" {
    #[link_name = "blocked_lock"]
    pub static mut blocked_lock: mtx;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mtx_args {
    pub ma_mtx: *mut ::kernel::sys::raw::c_void,
    pub ma_desc: *const ::kernel::sys::raw::c_char,
    pub ma_opts: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_mtx_args() {
    assert_eq!(::core::mem::size_of::<mtx_args>() , 24usize , concat ! (
               "Size of: " , stringify ! ( mtx_args ) ));
    assert_eq! (::core::mem::align_of::<mtx_args>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( mtx_args ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mtx_args ) ) . ma_mtx as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mtx_args ) , "::" ,
                stringify ! ( ma_mtx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mtx_args ) ) . ma_desc as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mtx_args ) , "::" ,
                stringify ! ( ma_desc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mtx_args ) ) . ma_opts as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mtx_args ) , "::" ,
                stringify ! ( ma_opts ) ));
}
impl Clone for mtx_args {
    fn clone(&self) -> Self { *self }
}
impl Default for mtx_args {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry {
    pub ee_link: eventhandler_entry__bindgen_ty_1,
    pub ee_priority: ::kernel::sys::raw::c_int,
    pub ee_arg: *mut ::kernel::sys::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry__bindgen_ty_1 {
    pub tqe_next: *mut eventhandler_entry,
    pub tqe_prev: *mut *mut eventhandler_entry,
}
#[test]
fn bindgen_test_layout_eventhandler_entry__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry__bindgen_ty_1>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry__bindgen_ty_1 ) ) .
                tqe_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry__bindgen_ty_1 ) , "::" , stringify ! (
                tqe_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry__bindgen_ty_1 ) ) .
                tqe_prev as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry__bindgen_ty_1 ) , "::" , stringify ! (
                tqe_prev ) ));
}
impl Clone for eventhandler_entry__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_eventhandler_entry() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry>() , 32usize , concat
               ! ( "Size of: " , stringify ! ( eventhandler_entry ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry ) ) . ee_link as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( eventhandler_entry ) ,
                "::" , stringify ! ( ee_link ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry ) ) . ee_priority as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( eventhandler_entry ) ,
                "::" , stringify ! ( ee_priority ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry ) ) . ee_arg as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( eventhandler_entry ) ,
                "::" , stringify ! ( ee_arg ) ));
}
impl Clone for eventhandler_entry {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_list {
    pub el_name: *mut ::kernel::sys::raw::c_char,
    pub el_flags: ::kernel::sys::raw::c_int,
    pub el_runcount: u_int,
    pub el_lock: mtx,
    pub el_link: eventhandler_list__bindgen_ty_1,
    pub el_entries: eventhandler_list__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_list__bindgen_ty_1 {
    pub tqe_next: *mut eventhandler_list,
    pub tqe_prev: *mut *mut eventhandler_list,
}
#[test]
fn bindgen_test_layout_eventhandler_list__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<eventhandler_list__bindgen_ty_1>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_list__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_list__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_list__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_list__bindgen_ty_1 ) ) .
                tqe_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_list__bindgen_ty_1 ) , "::" , stringify ! (
                tqe_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_list__bindgen_ty_1 ) ) .
                tqe_prev as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_list__bindgen_ty_1 ) , "::" , stringify ! (
                tqe_prev ) ));
}
impl Clone for eventhandler_list__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_list__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_list__bindgen_ty_2 {
    pub tqh_first: *mut eventhandler_entry,
    pub tqh_last: *mut *mut eventhandler_entry,
}
#[test]
fn bindgen_test_layout_eventhandler_list__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<eventhandler_list__bindgen_ty_2>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_list__bindgen_ty_2 )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_list__bindgen_ty_2>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_list__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_list__bindgen_ty_2 ) ) .
                tqh_first as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_list__bindgen_ty_2 ) , "::" , stringify ! (
                tqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_list__bindgen_ty_2 ) ) .
                tqh_last as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_list__bindgen_ty_2 ) , "::" , stringify ! (
                tqh_last ) ));
}
impl Clone for eventhandler_list__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_list__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_eventhandler_list() {
    assert_eq!(::core::mem::size_of::<eventhandler_list>() , 80usize , concat
               ! ( "Size of: " , stringify ! ( eventhandler_list ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_list>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( eventhandler_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_list ) ) . el_name as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( eventhandler_list ) ,
                "::" , stringify ! ( el_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_list ) ) . el_flags as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( eventhandler_list ) ,
                "::" , stringify ! ( el_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_list ) ) . el_runcount as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( eventhandler_list ) ,
                "::" , stringify ! ( el_runcount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_list ) ) . el_lock as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( eventhandler_list ) ,
                "::" , stringify ! ( el_lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_list ) ) . el_link as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( eventhandler_list ) ,
                "::" , stringify ! ( el_link ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_list ) ) . el_entries as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( eventhandler_list ) ,
                "::" , stringify ! ( el_entries ) ));
}
impl Clone for eventhandler_list {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_list {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type eventhandler_tag = *mut eventhandler_entry;
extern "C" {
    pub fn eventhandler_register(list: *mut eventhandler_list,
                                 name: *const ::kernel::sys::raw::c_char,
                                 func: *mut ::kernel::sys::raw::c_void,
                                 arg: *mut ::kernel::sys::raw::c_void,
                                 priority: ::kernel::sys::raw::c_int)
     -> eventhandler_tag;
}
extern "C" {
    pub fn eventhandler_deregister(list: *mut eventhandler_list,
                                   tag: eventhandler_tag);
}
extern "C" {
    pub fn eventhandler_deregister_nowait(list: *mut eventhandler_list,
                                          tag: eventhandler_tag);
}
extern "C" {
    pub fn eventhandler_find_list(name: *const ::kernel::sys::raw::c_char)
     -> *mut eventhandler_list;
}
extern "C" {
    pub fn eventhandler_prune_list(list: *mut eventhandler_list);
}
extern "C" {
    pub fn eventhandler_create_list(name: *const ::kernel::sys::raw::c_char)
     -> *mut eventhandler_list;
}
pub type shutdown_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2:
                                                    ::kernel::sys::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_shutdown_pre_sync {
    pub ee: eventhandler_entry,
    pub eh_func: shutdown_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_shutdown_pre_sync() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_shutdown_pre_sync>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_shutdown_pre_sync ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_shutdown_pre_sync>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_shutdown_pre_sync ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_shutdown_pre_sync ) )
                . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_shutdown_pre_sync ) , "::" , stringify ! (
                ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_shutdown_pre_sync ) )
                . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_shutdown_pre_sync ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_shutdown_pre_sync {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_shutdown_pre_sync {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __hack {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_shutdown_post_sync {
    pub ee: eventhandler_entry,
    pub eh_func: shutdown_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_shutdown_post_sync() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_shutdown_post_sync>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_shutdown_post_sync ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_shutdown_post_sync>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_shutdown_post_sync ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_shutdown_post_sync ) )
                . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_shutdown_post_sync ) , "::" , stringify ! (
                ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_shutdown_post_sync ) )
                . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_shutdown_post_sync ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_shutdown_post_sync {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_shutdown_post_sync {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_shutdown_final {
    pub ee: eventhandler_entry,
    pub eh_func: shutdown_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_shutdown_final() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_shutdown_final>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_shutdown_final )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_shutdown_final>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_shutdown_final ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_shutdown_final ) ) .
                ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_shutdown_final ) , "::" , stringify ! ( ee
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_shutdown_final ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_shutdown_final ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_shutdown_final {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_shutdown_final {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type power_change_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_power_resume {
    pub ee: eventhandler_entry,
    pub eh_func: power_change_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_power_resume() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_power_resume>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_power_resume )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_power_resume>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_power_resume ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_power_resume ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_power_resume ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_power_resume ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_power_resume ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_power_resume {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_power_resume {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_power_suspend {
    pub ee: eventhandler_entry,
    pub eh_func: power_change_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_power_suspend() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_power_suspend>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_power_suspend )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_power_suspend>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_power_suspend ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_power_suspend ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_power_suspend ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_power_suspend ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_power_suspend ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_power_suspend {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_power_suspend {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_power_suspend_early {
    pub ee: eventhandler_entry,
    pub eh_func: power_change_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_power_suspend_early() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_power_suspend_early>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_power_suspend_early ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_power_suspend_early>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_power_suspend_early ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_power_suspend_early )
                ) . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_power_suspend_early ) , "::" , stringify !
                ( ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_power_suspend_early )
                ) . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_power_suspend_early ) , "::" , stringify !
                ( eh_func ) ));
}
impl Clone for eventhandler_entry_power_suspend_early {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_power_suspend_early {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type vm_lowmem_handler_t =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2:
                                                    ::kernel::sys::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_vm_lowmem {
    pub ee: eventhandler_entry,
    pub eh_func: vm_lowmem_handler_t,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_vm_lowmem() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_vm_lowmem>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_vm_lowmem ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_vm_lowmem>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_vm_lowmem )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_vm_lowmem ) ) . ee as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_vm_lowmem ) , "::" , stringify ! ( ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_vm_lowmem ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_vm_lowmem ) , "::" , stringify ! ( eh_func
                ) ));
}
impl Clone for eventhandler_entry_vm_lowmem {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_vm_lowmem {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type mountroot_handler_t =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_mountroot {
    pub ee: eventhandler_entry,
    pub eh_func: mountroot_handler_t,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_mountroot() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_mountroot>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_mountroot ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_mountroot>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_mountroot )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_mountroot ) ) . ee as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_mountroot ) , "::" , stringify ! ( ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_mountroot ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_mountroot ) , "::" , stringify ! ( eh_func
                ) ));
}
impl Clone for eventhandler_entry_mountroot {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_mountroot {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mount {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnode {
    _unused: [u8; 0],
}
pub type vfs_mounted_notify_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut mount,
                                                arg3: *mut vnode,
                                                arg4: *mut thread)>;
pub type vfs_unmounted_notify_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut mount,
                                                arg3: *mut thread)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_vfs_mounted {
    pub ee: eventhandler_entry,
    pub eh_func: vfs_mounted_notify_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_vfs_mounted() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_vfs_mounted>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_vfs_mounted )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_vfs_mounted>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_vfs_mounted
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_vfs_mounted ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_vfs_mounted ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_vfs_mounted ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_vfs_mounted ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_vfs_mounted {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_vfs_mounted {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_vfs_unmounted {
    pub ee: eventhandler_entry,
    pub eh_func: vfs_unmounted_notify_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_vfs_unmounted() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_vfs_unmounted>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_vfs_unmounted )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_vfs_unmounted>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_vfs_unmounted ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_vfs_unmounted ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_vfs_unmounted ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_vfs_unmounted ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_vfs_unmounted ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_vfs_unmounted {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_vfs_unmounted {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct image_params {
    _unused: [u8; 0],
}
pub type exitlist_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut proc_)>;
pub type forklist_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut proc_,
                                                arg3: *mut proc_,
                                                arg4:
                                                    ::kernel::sys::raw::c_int)>;
pub type execlist_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut proc_,
                                                arg3: *mut image_params)>;
pub type proc_ctor_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut proc_)>;
pub type proc_dtor_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut proc_)>;
pub type proc_init_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut proc_)>;
pub type proc_fini_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut proc_)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_process_ctor {
    pub ee: eventhandler_entry,
    pub eh_func: proc_ctor_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_process_ctor() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_process_ctor>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_process_ctor )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_process_ctor>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_process_ctor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_ctor ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_ctor ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_ctor ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_ctor ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_process_ctor {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_process_ctor {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_process_dtor {
    pub ee: eventhandler_entry,
    pub eh_func: proc_dtor_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_process_dtor() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_process_dtor>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_process_dtor )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_process_dtor>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_process_dtor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_dtor ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_dtor ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_dtor ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_dtor ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_process_dtor {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_process_dtor {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_process_init {
    pub ee: eventhandler_entry,
    pub eh_func: proc_init_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_process_init() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_process_init>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_process_init )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_process_init>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_process_init ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_init ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_init ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_init ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_init ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_process_init {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_process_init {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_process_fini {
    pub ee: eventhandler_entry,
    pub eh_func: proc_fini_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_process_fini() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_process_fini>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_process_fini )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_process_fini>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_process_fini ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_fini ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_fini ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_fini ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_fini ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_process_fini {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_process_fini {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_process_exit {
    pub ee: eventhandler_entry,
    pub eh_func: exitlist_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_process_exit() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_process_exit>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_process_exit )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_process_exit>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_process_exit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_exit ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_exit ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_exit ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_exit ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_process_exit {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_process_exit {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_process_fork {
    pub ee: eventhandler_entry,
    pub eh_func: forklist_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_process_fork() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_process_fork>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_process_fork )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_process_fork>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_process_fork ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_fork ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_fork ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_fork ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_fork ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_process_fork {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_process_fork {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_process_exec {
    pub ee: eventhandler_entry,
    pub eh_func: execlist_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_process_exec() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_process_exec>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_process_exec )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_process_exec>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_process_exec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_exec ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_exec ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_process_exec ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_process_exec ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_process_exec {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_process_exec {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type app_coredump_start_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut thread,
                                                name:
                                                    *mut ::kernel::sys::raw::c_char)>;
pub type app_coredump_progress_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                td: *mut thread,
                                                byte_count:
                                                    ::kernel::sys::raw::c_int)>;
pub type app_coredump_finish_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                td: *mut thread)>;
pub type app_coredump_error_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                td: *mut thread,
                                                msg:
                                                    *mut ::kernel::sys::raw::c_char, ...)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_app_coredump_start {
    pub ee: eventhandler_entry,
    pub eh_func: app_coredump_start_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_app_coredump_start() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_app_coredump_start>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_app_coredump_start ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_app_coredump_start>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_app_coredump_start ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_app_coredump_start ) )
                . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_app_coredump_start ) , "::" , stringify ! (
                ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_app_coredump_start ) )
                . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_app_coredump_start ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_app_coredump_start {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_app_coredump_start {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_app_coredump_progress {
    pub ee: eventhandler_entry,
    pub eh_func: app_coredump_progress_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_app_coredump_progress() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_app_coredump_progress>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_app_coredump_progress ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_app_coredump_progress>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_app_coredump_progress ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const eventhandler_entry_app_coredump_progress ) )
                . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_app_coredump_progress ) , "::" , stringify
                ! ( ee ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const eventhandler_entry_app_coredump_progress ) )
                . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_app_coredump_progress ) , "::" , stringify
                ! ( eh_func ) ));
}
impl Clone for eventhandler_entry_app_coredump_progress {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_app_coredump_progress {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_app_coredump_finish {
    pub ee: eventhandler_entry,
    pub eh_func: app_coredump_finish_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_app_coredump_finish() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_app_coredump_finish>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_app_coredump_finish ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_app_coredump_finish>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_app_coredump_finish ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_app_coredump_finish )
                ) . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_app_coredump_finish ) , "::" , stringify !
                ( ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_app_coredump_finish )
                ) . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_app_coredump_finish ) , "::" , stringify !
                ( eh_func ) ));
}
impl Clone for eventhandler_entry_app_coredump_finish {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_app_coredump_finish {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_app_coredump_error {
    pub ee: eventhandler_entry,
    pub eh_func: app_coredump_error_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_app_coredump_error() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_app_coredump_error>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_app_coredump_error ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_app_coredump_error>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_app_coredump_error ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_app_coredump_error ) )
                . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_app_coredump_error ) , "::" , stringify ! (
                ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_app_coredump_error ) )
                . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_app_coredump_error ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_app_coredump_error {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_app_coredump_error {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type thread_ctor_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut thread)>;
pub type thread_dtor_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut thread)>;
pub type thread_fini_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut thread)>;
pub type thread_init_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut thread)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_thread_ctor {
    pub ee: eventhandler_entry,
    pub eh_func: thread_ctor_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_thread_ctor() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_thread_ctor>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_thread_ctor )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_thread_ctor>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_thread_ctor
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_thread_ctor ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_thread_ctor ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_thread_ctor ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_thread_ctor ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_thread_ctor {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_thread_ctor {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_thread_dtor {
    pub ee: eventhandler_entry,
    pub eh_func: thread_dtor_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_thread_dtor() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_thread_dtor>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_thread_dtor )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_thread_dtor>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_thread_dtor
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_thread_dtor ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_thread_dtor ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_thread_dtor ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_thread_dtor ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_thread_dtor {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_thread_dtor {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_thread_init {
    pub ee: eventhandler_entry,
    pub eh_func: thread_init_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_thread_init() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_thread_init>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_thread_init )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_thread_init>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_thread_init
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_thread_init ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_thread_init ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_thread_init ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_thread_init ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_thread_init {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_thread_init {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_thread_fini {
    pub ee: eventhandler_entry,
    pub eh_func: thread_fini_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_thread_fini() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_thread_fini>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_thread_fini )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_thread_fini>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_thread_fini
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_thread_fini ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_thread_fini ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_thread_fini ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_thread_fini ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_thread_fini {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_thread_fini {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type uma_zone_chfn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_nmbclusters_change {
    pub ee: eventhandler_entry,
    pub eh_func: uma_zone_chfn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_nmbclusters_change() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_nmbclusters_change>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_nmbclusters_change ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_nmbclusters_change>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_nmbclusters_change ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_nmbclusters_change ) )
                . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_nmbclusters_change ) , "::" , stringify ! (
                ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_nmbclusters_change ) )
                . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_nmbclusters_change ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_nmbclusters_change {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_nmbclusters_change {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_nmbufs_change {
    pub ee: eventhandler_entry,
    pub eh_func: uma_zone_chfn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_nmbufs_change() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_nmbufs_change>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_nmbufs_change )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_nmbufs_change>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_nmbufs_change ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_nmbufs_change ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_nmbufs_change ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_nmbufs_change ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_nmbufs_change ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_nmbufs_change {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_nmbufs_change {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_maxsockets_change {
    pub ee: eventhandler_entry,
    pub eh_func: uma_zone_chfn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_maxsockets_change() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_maxsockets_change>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_maxsockets_change ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_maxsockets_change>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_maxsockets_change ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_maxsockets_change ) )
                . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_maxsockets_change ) , "::" , stringify ! (
                ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_maxsockets_change ) )
                . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_maxsockets_change ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_maxsockets_change {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_maxsockets_change {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type kld_load_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut linker_file)>;
pub type kld_unload_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2:
                                                    *const ::kernel::sys::raw::c_char,
                                                arg3: caddr_t, arg4: usize)>;
pub type kld_unload_try_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut linker_file,
                                                arg3:
                                                    *mut ::kernel::sys::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_kld_load {
    pub ee: eventhandler_entry,
    pub eh_func: kld_load_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_kld_load() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_kld_load>() , 40usize
               , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_kld_load ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_kld_load>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_kld_load )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_kld_load ) ) . ee as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_kld_load ) , "::" , stringify ! ( ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_kld_load ) ) . eh_func
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_kld_load ) , "::" , stringify ! ( eh_func )
                ));
}
impl Clone for eventhandler_entry_kld_load {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_kld_load {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_kld_unload {
    pub ee: eventhandler_entry,
    pub eh_func: kld_unload_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_kld_unload() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_kld_unload>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_kld_unload ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_kld_unload>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_kld_unload
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_kld_unload ) ) . ee as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_kld_unload ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_kld_unload ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_kld_unload ) , "::" , stringify ! ( eh_func
                ) ));
}
impl Clone for eventhandler_entry_kld_unload {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_kld_unload {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_kld_unload_try {
    pub ee: eventhandler_entry,
    pub eh_func: kld_unload_try_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_kld_unload_try() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_kld_unload_try>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_kld_unload_try )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_kld_unload_try>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_kld_unload_try ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_kld_unload_try ) ) .
                ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_kld_unload_try ) , "::" , stringify ! ( ee
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_kld_unload_try ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_kld_unload_try ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_kld_unload_try {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_kld_unload_try {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fb_info {
    _unused: [u8; 0],
}
pub type register_framebuffer_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut fb_info)>;
pub type unregister_framebuffer_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut fb_info)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_register_framebuffer {
    pub ee: eventhandler_entry,
    pub eh_func: register_framebuffer_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_register_framebuffer() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_register_framebuffer>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_register_framebuffer ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_register_framebuffer>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_register_framebuffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_register_framebuffer )
                ) . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_register_framebuffer ) , "::" , stringify !
                ( ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_register_framebuffer )
                ) . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_register_framebuffer ) , "::" , stringify !
                ( eh_func ) ));
}
impl Clone for eventhandler_entry_register_framebuffer {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_register_framebuffer {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_unregister_framebuffer {
    pub ee: eventhandler_entry,
    pub eh_func: unregister_framebuffer_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_unregister_framebuffer() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_unregister_framebuffer>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_unregister_framebuffer ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_unregister_framebuffer>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_unregister_framebuffer ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const eventhandler_entry_unregister_framebuffer ) )
                . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_unregister_framebuffer ) , "::" , stringify
                ! ( ee ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const eventhandler_entry_unregister_framebuffer ) )
                . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_unregister_framebuffer ) , "::" , stringify
                ! ( eh_func ) ));
}
impl Clone for eventhandler_entry_unregister_framebuffer {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_unregister_framebuffer {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cam_path {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ata_params {
    _unused: [u8; 0],
}
pub type ada_probe_veto_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut cam_path,
                                                arg3: *mut ata_params,
                                                arg4:
                                                    *mut ::kernel::sys::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_ada_probe_veto {
    pub ee: eventhandler_entry,
    pub eh_func: ada_probe_veto_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_ada_probe_veto() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_ada_probe_veto>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_ada_probe_veto )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_ada_probe_veto>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_ada_probe_veto ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_ada_probe_veto ) ) .
                ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_ada_probe_veto ) , "::" , stringify ! ( ee
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_ada_probe_veto ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_ada_probe_veto ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_ada_probe_veto {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_ada_probe_veto {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct swdevt {
    _unused: [u8; 0],
}
pub type swapon_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut swdevt)>;
pub type swapoff_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut swdevt)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_swapon {
    pub ee: eventhandler_entry,
    pub eh_func: swapon_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_swapon() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_swapon>() , 40usize ,
               concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_swapon ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_swapon>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_swapon )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_swapon ) ) . ee as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_swapon ) , "::" , stringify ! ( ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_swapon ) ) . eh_func
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_swapon ) , "::" , stringify ! ( eh_func )
                ));
}
impl Clone for eventhandler_entry_swapon {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_swapon {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_swapoff {
    pub ee: eventhandler_entry,
    pub eh_func: swapoff_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_swapoff() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_swapoff>() , 40usize
               , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_swapoff ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_swapoff>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_swapoff )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_swapoff ) ) . ee as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_swapoff ) , "::" , stringify ! ( ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_swapoff ) ) . eh_func
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_swapoff ) , "::" , stringify ! ( eh_func )
                ));
}
impl Clone for eventhandler_entry_swapoff {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_swapoff {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum evhdev_detach {
    EVHDEV_DETACH_BEGIN = 0,
    EVHDEV_DETACH_COMPLETE = 1,
    EVHDEV_DETACH_FAILED = 2,
}
pub type device_attach_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: device_t)>;
pub type device_detach_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: device_t,
                                                arg3: evhdev_detach)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_device_attach {
    pub ee: eventhandler_entry,
    pub eh_func: device_attach_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_device_attach() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_device_attach>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_device_attach )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_device_attach>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_device_attach ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_device_attach ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_device_attach ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_device_attach ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_device_attach ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_device_attach {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_device_attach {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_device_detach {
    pub ee: eventhandler_entry,
    pub eh_func: device_detach_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_device_detach() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_device_detach>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_device_detach )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_device_detach>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_device_detach ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_device_detach ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_device_detach ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_device_detach ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_device_detach ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_device_detach {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_device_detach {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct kobj {
    pub ops: kobj_ops_t,
}
#[test]
fn bindgen_test_layout_kobj() {
    assert_eq!(::core::mem::size_of::<kobj>() , 8usize , concat ! (
               "Size of: " , stringify ! ( kobj ) ));
    assert_eq! (::core::mem::align_of::<kobj>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kobj ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kobj ) ) . ops as * const _ as usize } ,
                0usize , concat ! (
                "Alignment of field: " , stringify ! ( kobj ) , "::" ,
                stringify ! ( ops ) ));
}
impl Clone for kobj {
    fn clone(&self) -> Self { *self }
}
impl Default for kobj {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type kobj_t = *mut kobj;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct kobj_class {
    pub name: *const ::kernel::sys::raw::c_char,
    pub methods: *mut kobj_method_t,
    pub size: usize,
    pub baseclasses: *mut kobj_class_t,
    pub refs: u_int,
    pub ops: kobj_ops_t,
}
#[test]
fn bindgen_test_layout_kobj_class() {
    assert_eq!(::core::mem::size_of::<kobj_class>() , 48usize , concat ! (
               "Size of: " , stringify ! ( kobj_class ) ));
    assert_eq! (::core::mem::align_of::<kobj_class>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kobj_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kobj_class ) ) . name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kobj_class ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kobj_class ) ) . methods as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kobj_class ) , "::" ,
                stringify ! ( methods ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kobj_class ) ) . size as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( kobj_class ) , "::" ,
                stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kobj_class ) ) . baseclasses as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( kobj_class ) , "::" ,
                stringify ! ( baseclasses ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kobj_class ) ) . refs as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( kobj_class ) , "::" ,
                stringify ! ( refs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kobj_class ) ) . ops as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( kobj_class ) , "::" ,
                stringify ! ( ops ) ));
}
impl Clone for kobj_class {
    fn clone(&self) -> Self { *self }
}
impl Default for kobj_class {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type kobj_class_t = *mut kobj_class;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct kobj_method {
    pub desc: kobjop_desc_t,
    pub func: kobjop_t,
}
#[test]
fn bindgen_test_layout_kobj_method() {
    assert_eq!(::core::mem::size_of::<kobj_method>() , 16usize , concat ! (
               "Size of: " , stringify ! ( kobj_method ) ));
    assert_eq! (::core::mem::align_of::<kobj_method>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kobj_method ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kobj_method ) ) . desc as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kobj_method ) , "::" ,
                stringify ! ( desc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kobj_method ) ) . func as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kobj_method ) , "::" ,
                stringify ! ( func ) ));
}
impl Clone for kobj_method {
    fn clone(&self) -> Self { *self }
}
impl Default for kobj_method {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type kobj_method_t = kobj_method;
pub type kobjop_t =
    ::core::option::Option<unsafe extern "C" fn()
                               -> ::kernel::sys::raw::c_int>;
#[repr(C)]
#[derive(Copy)]
pub struct kobj_ops {
    pub cache: [*mut kobj_method_t; 256usize],
    pub cls: kobj_class_t,
}
#[test]
fn bindgen_test_layout_kobj_ops() {
    assert_eq!(::core::mem::size_of::<kobj_ops>() , 2056usize , concat ! (
               "Size of: " , stringify ! ( kobj_ops ) ));
    assert_eq! (::core::mem::align_of::<kobj_ops>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kobj_ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kobj_ops ) ) . cache as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kobj_ops ) , "::" ,
                stringify ! ( cache ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kobj_ops ) ) . cls as * const _ as usize
                } , 2048usize , concat ! (
                "Alignment of field: " , stringify ! ( kobj_ops ) , "::" ,
                stringify ! ( cls ) ));
}
impl Clone for kobj_ops {
    fn clone(&self) -> Self { *self }
}
impl Default for kobj_ops {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for kobj_ops {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "kobj_ops {{ cache: [{}], cls: {:?} }}" , self . cache .
               iter (  ) . enumerate (  ) . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ) , self . cls)
    }
}
pub type kobj_ops_t = *mut kobj_ops;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct kobjop_desc {
    pub id: ::kernel::sys::raw::c_uint,
    pub deflt: kobj_method_t,
}
#[test]
fn bindgen_test_layout_kobjop_desc() {
    assert_eq!(::core::mem::size_of::<kobjop_desc>() , 24usize , concat ! (
               "Size of: " , stringify ! ( kobjop_desc ) ));
    assert_eq! (::core::mem::align_of::<kobjop_desc>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kobjop_desc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kobjop_desc ) ) . id as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kobjop_desc ) , "::" ,
                stringify ! ( id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kobjop_desc ) ) . deflt as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kobjop_desc ) , "::" ,
                stringify ! ( deflt ) ));
}
impl Clone for kobjop_desc {
    fn clone(&self) -> Self { *self }
}
impl Default for kobjop_desc {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type kobjop_desc_t = *mut kobjop_desc;
extern "C" {
    pub fn kobj_class_compile(cls: kobj_class_t);
}
extern "C" {
    pub fn kobj_class_compile_static(cls: kobj_class_t, ops: kobj_ops_t);
}
extern "C" {
    pub fn kobj_class_free(cls: kobj_class_t);
}
extern "C" {
    pub fn kobj_create(cls: kobj_class_t, mtype: *mut malloc_type,
                       mflags: ::kernel::sys::raw::c_int) -> kobj_t;
}
extern "C" {
    pub fn kobj_init(obj: kobj_t, cls: kobj_class_t);
}
extern "C" {
    pub fn kobj_init_static(obj: kobj_t, cls: kobj_class_t);
}
extern "C" {
    pub fn kobj_delete(obj: kobj_t, mtype: *mut malloc_type);
}
extern "C" {
    pub fn kobj_lookup_method(cls: kobj_class_t, cep: *mut *mut kobj_method_t,
                              desc: kobjop_desc_t) -> *mut kobj_method_t;
}
extern "C" {
    pub fn kobj_error_method() -> ::kernel::sys::raw::c_int;
}
extern "C" {
    /// devctl hooks.  Typically one should use the devctl_notify
/// hook to send the message.  However, devctl_queue_data is also
/// included in case devctl_notify isn't sufficiently general.
    pub fn devctl_process_running() -> boolean_t;
}
extern "C" {
    pub fn devctl_notify_f(__system: *const ::kernel::sys::raw::c_char,
                           __subsystem: *const ::kernel::sys::raw::c_char,
                           __type: *const ::kernel::sys::raw::c_char,
                           __data: *const ::kernel::sys::raw::c_char,
                           __flags: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn devctl_notify(__system: *const ::kernel::sys::raw::c_char,
                         __subsystem: *const ::kernel::sys::raw::c_char,
                         __type: *const ::kernel::sys::raw::c_char,
                         __data: *const ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn devctl_queue_data_f(__data: *mut ::kernel::sys::raw::c_char,
                               __flags: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn devctl_queue_data(__data: *mut ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn devctl_safe_quote(__dst: *mut ::kernel::sys::raw::c_char,
                             __src: *const ::kernel::sys::raw::c_char,
                             len: usize);
}
/// Device name parsers.  Hook to allow device enumerators to map
/// scheme-specific names to a device.
pub type dev_lookup_fn =
    ::core::option::Option<unsafe extern "C" fn(arg:
                                                    *mut ::kernel::sys::raw::c_void,
                                                name:
                                                    *const ::kernel::sys::raw::c_char,
                                                result: *mut device_t)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_dev_lookup {
    pub ee: eventhandler_entry,
    pub eh_func: dev_lookup_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_dev_lookup() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_dev_lookup>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_dev_lookup ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_dev_lookup>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_dev_lookup
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_dev_lookup ) ) . ee as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_dev_lookup ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_dev_lookup ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_dev_lookup ) , "::" , stringify ! ( eh_func
                ) ));
}
impl Clone for eventhandler_entry_dev_lookup {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_dev_lookup {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
/// @brief A device driver (included mainly for compatibility with
/// FreeBSD 4.x).
pub type driver_t = kobj_class;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct devclass {
    _unused: [u8; 0],
}
/// @brief A device class
///
/// The devclass object has two main functions in the system. The first
/// is to manage the allocation of unit numbers for device instances
/// and the second is to hold the list of device drivers for a
/// particular bus type. Each devclass has a name and there cannot be
/// two devclasses with the same name. This ensures that unique unit
/// numbers are allocated to device instances.
///
/// Drivers that support several different bus attachments (e.g. isa,
/// pci, pccard) should all use the same devclass to ensure that unit
/// numbers do not conflict.
///
/// Each devclass may also have a parent devclass. This is used when
/// searching for device drivers to allow a form of inheritance. When
/// matching drivers with devices, first the driver list of the parent
/// device's devclass is searched. If no driver is found in that list,
/// the search continues in the parent devclass (if any).
pub type devclass_t = *mut devclass;
/// @brief Driver interrupt service routines
///
/// The filter routine is run in primary interrupt context and may not
/// block or use regular mutexes.  It may only use spin mutexes for
/// synchronization.  The filter may either completely handle the
/// interrupt or it may perform some of the work and defer more
/// expensive work to the regular interrupt handler.  If a filter
/// routine is not registered by the driver, then the regular interrupt
/// handler is always used to handle interrupts from this device.
///
/// The regular interrupt handler executes in its own thread context
/// and may use regular mutexes.  However, it is prohibited from
/// sleeping on a sleep queue.
pub type driver_filter_t =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void)
                               -> ::kernel::sys::raw::c_int>;
pub type driver_intr_t =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void)>;
#[repr(u32)]
/// @brief Interrupt type bits.
///
/// These flags are used both by newbus interrupt
/// registration (nexus.c) and also in struct intrec, which defines
/// interrupt properties.
///
/// XXX We should probably revisit this and remove the vestiges of the
/// spls implicit in names like INTR_TYPE_TTY. In the meantime, don't
/// confuse things by renaming them (Grog, 18 July 2000).
///
/// Buses which do interrupt remapping will want to change their type
/// to reflect what sort of devices are underneath.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum intr_type {
    INTR_TYPE_TTY = 1,
    INTR_TYPE_BIO = 2,
    INTR_TYPE_NET = 4,
    INTR_TYPE_CAM = 8,
    INTR_TYPE_MISC = 16,
    INTR_TYPE_CLK = 32,
    INTR_TYPE_AV = 64,
    INTR_EXCL = 256,
    INTR_MPSAFE = 512,
    INTR_ENTROPY = 1024,
    INTR_MD1 = 4096,
    INTR_MD2 = 8192,
    INTR_MD3 = 16384,
    INTR_MD4 = 32768,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum intr_trigger {
    INTR_TRIGGER_INVALID = -1,
    INTR_TRIGGER_CONFORM = 0,
    INTR_TRIGGER_EDGE = 1,
    INTR_TRIGGER_LEVEL = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum intr_polarity {
    INTR_POLARITY_CONFORM = 0,
    INTR_POLARITY_HIGH = 1,
    INTR_POLARITY_LOW = 2,
}
#[repr(u32)]
/// CPU sets supported by bus_get_cpus().  Note that not all sets may be
/// supported for a given device.  If a request is not supported by a
/// device (or its parents), then bus_get_cpus() will fail with EINVAL.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum cpu_sets { LOCAL_CPUS = 0, INTR_CPUS = 1, }
pub type devop_t =
    ::core::option::Option<unsafe extern "C" fn()
                               -> ::kernel::sys::raw::c_int>;
/// @brief This structure is deprecated.
///
/// Use the kobj(9) macro DEFINE_CLASS to
/// declare classes which implement device drivers.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct driver {
    pub name: *const ::kernel::sys::raw::c_char,
    pub methods: *mut kobj_method_t,
    pub size: usize,
    pub baseclasses: *mut kobj_class_t,
    pub refs: u_int,
    pub ops: kobj_ops_t,
}
#[test]
fn bindgen_test_layout_driver() {
    assert_eq!(::core::mem::size_of::<driver>() , 48usize , concat ! (
               "Size of: " , stringify ! ( driver ) ));
    assert_eq! (::core::mem::align_of::<driver>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( driver ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const driver ) ) . name as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( driver ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const driver ) ) . methods as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( driver ) , "::" ,
                stringify ! ( methods ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const driver ) ) . size as * const _ as usize }
                , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( driver ) , "::" ,
                stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const driver ) ) . baseclasses as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( driver ) , "::" ,
                stringify ! ( baseclasses ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const driver ) ) . refs as * const _ as usize }
                , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( driver ) , "::" ,
                stringify ! ( refs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const driver ) ) . ops as * const _ as usize }
                , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( driver ) , "::" ,
                stringify ! ( ops ) ));
}
impl Clone for driver {
    fn clone(&self) -> Self { *self }
}
impl Default for driver {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
/// @brief A resource mapping.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct resource_map {
    pub r_bustag: bus_space_tag_t,
    pub r_bushandle: bus_space_handle_t,
    pub r_size: bus_size_t,
    pub r_vaddr: *mut ::kernel::sys::raw::c_void,
}
#[test]
fn bindgen_test_layout_resource_map() {
    assert_eq!(::core::mem::size_of::<resource_map>() , 32usize , concat ! (
               "Size of: " , stringify ! ( resource_map ) ));
    assert_eq! (::core::mem::align_of::<resource_map>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( resource_map ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_map ) ) . r_bustag as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_map ) , "::" ,
                stringify ! ( r_bustag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_map ) ) . r_bushandle as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_map ) , "::" ,
                stringify ! ( r_bushandle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_map ) ) . r_size as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_map ) , "::" ,
                stringify ! ( r_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_map ) ) . r_vaddr as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_map ) , "::" ,
                stringify ! ( r_vaddr ) ));
}
impl Clone for resource_map {
    fn clone(&self) -> Self { *self }
}
impl Default for resource_map {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
/// @brief Optional properties of a resource mapping request.
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct resource_map_request {
    pub size: usize,
    pub offset: rman_res_t,
    pub length: rman_res_t,
    pub memattr: vm_memattr_t,
}
#[test]
fn bindgen_test_layout_resource_map_request() {
    assert_eq!(::core::mem::size_of::<resource_map_request>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( resource_map_request )
               ));
    assert_eq! (::core::mem::align_of::<resource_map_request>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( resource_map_request ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_map_request ) ) . size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_map_request )
                , "::" , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_map_request ) ) . offset as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_map_request )
                , "::" , stringify ! ( offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_map_request ) ) . length as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_map_request )
                , "::" , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_map_request ) ) . memattr as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_map_request )
                , "::" , stringify ! ( memattr ) ));
}
impl Clone for resource_map_request {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn resource_init_map_request_impl(_args: *mut resource_map_request,
                                          _sz: usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct resource {
    pub __r_i: *mut resource_i,
    pub r_bustag: bus_space_tag_t,
    pub r_bushandle: bus_space_handle_t,
}
#[test]
fn bindgen_test_layout_resource() {
    assert_eq!(::core::mem::size_of::<resource>() , 24usize , concat ! (
               "Size of: " , stringify ! ( resource ) ));
    assert_eq! (::core::mem::align_of::<resource>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( resource ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource ) ) . __r_i as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( resource ) , "::" ,
                stringify ! ( __r_i ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource ) ) . r_bustag as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( resource ) , "::" ,
                stringify ! ( r_bustag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource ) ) . r_bushandle as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( resource ) , "::" ,
                stringify ! ( r_bushandle ) ));
}
impl Clone for resource {
    fn clone(&self) -> Self { *self }
}
impl Default for resource {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
/// @brief An entry for a single resource in a resource list.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct resource_list_entry {
    pub link: resource_list_entry__bindgen_ty_1,
    /// < @brief type argument to alloc_resource
    pub type_: ::kernel::sys::raw::c_int,
    /// < @brief resource identifier
    pub rid: ::kernel::sys::raw::c_int,
    /// < @brief resource flags
    pub flags: ::kernel::sys::raw::c_int,
    /// < @brief the real resource when allocated
    pub res: *mut resource,
    /// < @brief start of resource range
    pub start: rman_res_t,
    /// < @brief end of resource range
    pub end: rman_res_t,
    /// < @brief count within range
    pub count: rman_res_t,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct resource_list_entry__bindgen_ty_1 {
    pub stqe_next: *mut resource_list_entry,
}
#[test]
fn bindgen_test_layout_resource_list_entry__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<resource_list_entry__bindgen_ty_1>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( resource_list_entry__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<resource_list_entry__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                resource_list_entry__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_list_entry__bindgen_ty_1 ) ) .
                stqe_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                resource_list_entry__bindgen_ty_1 ) , "::" , stringify ! (
                stqe_next ) ));
}
impl Clone for resource_list_entry__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for resource_list_entry__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_resource_list_entry() {
    assert_eq!(::core::mem::size_of::<resource_list_entry>() , 56usize ,
               concat ! ( "Size of: " , stringify ! ( resource_list_entry )
               ));
    assert_eq! (::core::mem::align_of::<resource_list_entry>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( resource_list_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_list_entry ) ) . link as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_list_entry ) ,
                "::" , stringify ! ( link ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_list_entry ) ) . type_ as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_list_entry ) ,
                "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_list_entry ) ) . rid as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_list_entry ) ,
                "::" , stringify ! ( rid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_list_entry ) ) . flags as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_list_entry ) ,
                "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_list_entry ) ) . res as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_list_entry ) ,
                "::" , stringify ! ( res ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_list_entry ) ) . start as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_list_entry ) ,
                "::" , stringify ! ( start ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_list_entry ) ) . end as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_list_entry ) ,
                "::" , stringify ! ( end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_list_entry ) ) . count as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_list_entry ) ,
                "::" , stringify ! ( count ) ));
}
impl Clone for resource_list_entry {
    fn clone(&self) -> Self { *self }
}
impl Default for resource_list_entry {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct resource_list {
    pub stqh_first: *mut resource_list_entry,
    pub stqh_last: *mut *mut resource_list_entry,
}
#[test]
fn bindgen_test_layout_resource_list() {
    assert_eq!(::core::mem::size_of::<resource_list>() , 16usize , concat ! (
               "Size of: " , stringify ! ( resource_list ) ));
    assert_eq! (::core::mem::align_of::<resource_list>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( resource_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_list ) ) . stqh_first as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_list ) , "::"
                , stringify ! ( stqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_list ) ) . stqh_last as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_list ) , "::"
                , stringify ! ( stqh_last ) ));
}
impl Clone for resource_list {
    fn clone(&self) -> Self { *self }
}
impl Default for resource_list {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    pub fn resource_list_init(rl: *mut resource_list);
}
extern "C" {
    pub fn resource_list_free(rl: *mut resource_list);
}
extern "C" {
    pub fn resource_list_add(rl: *mut resource_list,
                             type_: ::kernel::sys::raw::c_int,
                             rid: ::kernel::sys::raw::c_int,
                             start: rman_res_t, end: rman_res_t,
                             count: rman_res_t) -> *mut resource_list_entry;
}
extern "C" {
    pub fn resource_list_add_next(rl: *mut resource_list,
                                  type_: ::kernel::sys::raw::c_int,
                                  start: rman_res_t, end: rman_res_t,
                                  count: rman_res_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn resource_list_busy(rl: *mut resource_list,
                              type_: ::kernel::sys::raw::c_int,
                              rid: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn resource_list_reserved(rl: *mut resource_list,
                                  type_: ::kernel::sys::raw::c_int,
                                  rid: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn resource_list_find(rl: *mut resource_list,
                              type_: ::kernel::sys::raw::c_int,
                              rid: ::kernel::sys::raw::c_int)
     -> *mut resource_list_entry;
}
extern "C" {
    pub fn resource_list_delete(rl: *mut resource_list,
                                type_: ::kernel::sys::raw::c_int,
                                rid: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn resource_list_alloc(rl: *mut resource_list, bus: device_t,
                               child: device_t,
                               type_: ::kernel::sys::raw::c_int,
                               rid: *mut ::kernel::sys::raw::c_int,
                               start: rman_res_t, end: rman_res_t,
                               count: rman_res_t, flags: u_int)
     -> *mut resource;
}
extern "C" {
    pub fn resource_list_release(rl: *mut resource_list, bus: device_t,
                                 child: device_t,
                                 type_: ::kernel::sys::raw::c_int,
                                 rid: ::kernel::sys::raw::c_int,
                                 res: *mut resource)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn resource_list_release_active(rl: *mut resource_list, bus: device_t,
                                        child: device_t,
                                        type_: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn resource_list_reserve(rl: *mut resource_list, bus: device_t,
                                 child: device_t,
                                 type_: ::kernel::sys::raw::c_int,
                                 rid: *mut ::kernel::sys::raw::c_int,
                                 start: rman_res_t, end: rman_res_t,
                                 count: rman_res_t, flags: u_int)
     -> *mut resource;
}
extern "C" {
    pub fn resource_list_unreserve(rl: *mut resource_list, bus: device_t,
                                   child: device_t,
                                   type_: ::kernel::sys::raw::c_int,
                                   rid: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn resource_list_purge(rl: *mut resource_list);
}
extern "C" {
    pub fn resource_list_print_type(rl: *mut resource_list,
                                    name: *const ::kernel::sys::raw::c_char,
                                    type_: ::kernel::sys::raw::c_int,
                                    format: *const ::kernel::sys::raw::c_char)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "root_bus"]
    pub static mut root_bus: device_t;
}
extern "C" {
    #[link_name = "root_devclass"]
    pub static mut root_devclass: devclass_t;
}
extern "C" {
    pub fn root_bus_configure();
}
extern "C" {
    pub fn bus_generic_activate_resource(dev: device_t, child: device_t,
                                         type_: ::kernel::sys::raw::c_int,
                                         rid: ::kernel::sys::raw::c_int,
                                         r: *mut resource)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_add_child(dev: device_t, order: u_int,
                                 name: *const ::kernel::sys::raw::c_char,
                                 unit: ::kernel::sys::raw::c_int) -> device_t;
}
extern "C" {
    pub fn bus_generic_adjust_resource(bus: device_t, child: device_t,
                                       type_: ::kernel::sys::raw::c_int,
                                       r: *mut resource, start: rman_res_t,
                                       end: rman_res_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_alloc_resource(bus: device_t, child: device_t,
                                      type_: ::kernel::sys::raw::c_int,
                                      rid: *mut ::kernel::sys::raw::c_int,
                                      start: rman_res_t, end: rman_res_t,
                                      count: rman_res_t, flags: u_int)
     -> *mut resource;
}
extern "C" {
    pub fn bus_generic_attach(dev: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_bind_intr(dev: device_t, child: device_t,
                                 irq: *mut resource,
                                 cpu: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_child_present(dev: device_t, child: device_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_config_intr(arg1: device_t,
                                   arg2: ::kernel::sys::raw::c_int,
                                   arg3: intr_trigger, arg4: intr_polarity)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_describe_intr(dev: device_t, child: device_t,
                                     irq: *mut resource,
                                     cookie: *mut ::kernel::sys::raw::c_void,
                                     descr: *const ::kernel::sys::raw::c_char)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_deactivate_resource(dev: device_t, child: device_t,
                                           type_: ::kernel::sys::raw::c_int,
                                           rid: ::kernel::sys::raw::c_int,
                                           r: *mut resource)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_detach(dev: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_driver_added(dev: device_t, driver: *mut driver_t);
}
extern "C" {
    pub fn bus_generic_get_cpus(dev: device_t, child: device_t, op: cpu_sets,
                                setsize: usize, cpuset: *mut _cpuset)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_get_dma_tag(dev: device_t, child: device_t)
     -> bus_dma_tag_t;
}
extern "C" {
    pub fn bus_generic_get_bus_tag(dev: device_t, child: device_t)
     -> bus_space_tag_t;
}
extern "C" {
    pub fn bus_generic_get_domain(dev: device_t, child: device_t,
                                  domain: *mut ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_get_resource_list(arg1: device_t, arg2: device_t)
     -> *mut resource_list;
}
extern "C" {
    pub fn bus_generic_map_resource(dev: device_t, child: device_t,
                                    type_: ::kernel::sys::raw::c_int,
                                    r: *mut resource,
                                    args: *mut resource_map_request,
                                    map: *mut resource_map)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_new_pass(dev: device_t);
}
extern "C" {
    pub fn bus_print_child_header(dev: device_t, child: device_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_print_child_domain(dev: device_t, child: device_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_print_child_footer(dev: device_t, child: device_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_print_child(dev: device_t, child: device_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_probe(dev: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_read_ivar(dev: device_t, child: device_t,
                                 which: ::kernel::sys::raw::c_int,
                                 result: *mut usize)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_release_resource(bus: device_t, child: device_t,
                                        type_: ::kernel::sys::raw::c_int,
                                        rid: ::kernel::sys::raw::c_int,
                                        r: *mut resource)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_resume(dev: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_resume_child(dev: device_t, child: device_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_setup_intr(dev: device_t, child: device_t,
                                  irq: *mut resource,
                                  flags: ::kernel::sys::raw::c_int,
                                  filter: driver_filter_t,
                                  intr: driver_intr_t,
                                  arg: *mut ::kernel::sys::raw::c_void,
                                  cookiep:
                                      *mut *mut ::kernel::sys::raw::c_void)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_rl_alloc_resource(arg1: device_t, arg2: device_t,
                                         arg3: ::kernel::sys::raw::c_int,
                                         arg4: *mut ::kernel::sys::raw::c_int,
                                         arg5: rman_res_t, arg6: rman_res_t,
                                         arg7: rman_res_t, arg8: u_int)
     -> *mut resource;
}
extern "C" {
    pub fn bus_generic_rl_delete_resource(arg1: device_t, arg2: device_t,
                                          arg3: ::kernel::sys::raw::c_int,
                                          arg4: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn bus_generic_rl_get_resource(arg1: device_t, arg2: device_t,
                                       arg3: ::kernel::sys::raw::c_int,
                                       arg4: ::kernel::sys::raw::c_int,
                                       arg5: *mut rman_res_t,
                                       arg6: *mut rman_res_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_rl_set_resource(arg1: device_t, arg2: device_t,
                                       arg3: ::kernel::sys::raw::c_int,
                                       arg4: ::kernel::sys::raw::c_int,
                                       arg5: rman_res_t, arg6: rman_res_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_rl_release_resource(arg1: device_t, arg2: device_t,
                                           arg3: ::kernel::sys::raw::c_int,
                                           arg4: ::kernel::sys::raw::c_int,
                                           arg5: *mut resource)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_shutdown(dev: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_suspend(dev: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_suspend_child(dev: device_t, child: device_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_teardown_intr(dev: device_t, child: device_t,
                                     irq: *mut resource,
                                     cookie: *mut ::kernel::sys::raw::c_void)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_unmap_resource(dev: device_t, child: device_t,
                                      type_: ::kernel::sys::raw::c_int,
                                      r: *mut resource,
                                      map: *mut resource_map)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_generic_write_ivar(dev: device_t, child: device_t,
                                  which: ::kernel::sys::raw::c_int,
                                  value: usize) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_null_rescan(dev: device_t) -> ::kernel::sys::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct resource_spec {
    pub type_: ::kernel::sys::raw::c_int,
    pub rid: ::kernel::sys::raw::c_int,
    pub flags: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_resource_spec() {
    assert_eq!(::core::mem::size_of::<resource_spec>() , 12usize , concat ! (
               "Size of: " , stringify ! ( resource_spec ) ));
    assert_eq! (::core::mem::align_of::<resource_spec>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( resource_spec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_spec ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_spec ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_spec ) ) . rid as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_spec ) , "::"
                , stringify ! ( rid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_spec ) ) . flags as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_spec ) , "::"
                , stringify ! ( flags ) ));
}
impl Clone for resource_spec {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn bus_alloc_resources(dev: device_t, rs: *mut resource_spec,
                               res: *mut *mut resource)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_release_resources(dev: device_t, rs: *const resource_spec,
                                 res: *mut *mut resource);
}
extern "C" {
    pub fn bus_adjust_resource(child: device_t,
                               type_: ::kernel::sys::raw::c_int,
                               r: *mut resource, start: rman_res_t,
                               end: rman_res_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_alloc_resource(dev: device_t, type_: ::kernel::sys::raw::c_int,
                              rid: *mut ::kernel::sys::raw::c_int,
                              start: rman_res_t, end: rman_res_t,
                              count: rman_res_t, flags: u_int)
     -> *mut resource;
}
extern "C" {
    pub fn bus_activate_resource(dev: device_t,
                                 type_: ::kernel::sys::raw::c_int,
                                 rid: ::kernel::sys::raw::c_int,
                                 r: *mut resource)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_deactivate_resource(dev: device_t,
                                   type_: ::kernel::sys::raw::c_int,
                                   rid: ::kernel::sys::raw::c_int,
                                   r: *mut resource)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_map_resource(dev: device_t, type_: ::kernel::sys::raw::c_int,
                            r: *mut resource, args: *mut resource_map_request,
                            map: *mut resource_map)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_unmap_resource(dev: device_t, type_: ::kernel::sys::raw::c_int,
                              r: *mut resource, map: *mut resource_map)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_get_cpus(dev: device_t, op: cpu_sets, setsize: usize,
                        cpuset: *mut _cpuset) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_get_dma_tag(dev: device_t) -> bus_dma_tag_t;
}
extern "C" {
    pub fn bus_get_bus_tag(dev: device_t) -> bus_space_tag_t;
}
extern "C" {
    pub fn bus_get_domain(dev: device_t,
                          domain: *mut ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_release_resource(dev: device_t,
                                type_: ::kernel::sys::raw::c_int,
                                rid: ::kernel::sys::raw::c_int,
                                r: *mut resource)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_free_resource(dev: device_t, type_: ::kernel::sys::raw::c_int,
                             r: *mut resource) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_setup_intr(dev: device_t, r: *mut resource,
                          flags: ::kernel::sys::raw::c_int,
                          filter: driver_filter_t, handler: driver_intr_t,
                          arg: *mut ::kernel::sys::raw::c_void,
                          cookiep: *mut *mut ::kernel::sys::raw::c_void)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_teardown_intr(dev: device_t, r: *mut resource,
                             cookie: *mut ::kernel::sys::raw::c_void)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_bind_intr(dev: device_t, r: *mut resource,
                         cpu: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_describe_intr(dev: device_t, irq: *mut resource,
                             cookie: *mut ::kernel::sys::raw::c_void,
                             fmt: *const ::kernel::sys::raw::c_char, ...)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_set_resource(dev: device_t, type_: ::kernel::sys::raw::c_int,
                            rid: ::kernel::sys::raw::c_int, start: rman_res_t,
                            count: rman_res_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_get_resource(dev: device_t, type_: ::kernel::sys::raw::c_int,
                            rid: ::kernel::sys::raw::c_int,
                            startp: *mut rman_res_t, countp: *mut rman_res_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_get_resource_start(dev: device_t,
                                  type_: ::kernel::sys::raw::c_int,
                                  rid: ::kernel::sys::raw::c_int)
     -> rman_res_t;
}
extern "C" {
    pub fn bus_get_resource_count(dev: device_t,
                                  type_: ::kernel::sys::raw::c_int,
                                  rid: ::kernel::sys::raw::c_int)
     -> rman_res_t;
}
extern "C" {
    pub fn bus_delete_resource(dev: device_t,
                               type_: ::kernel::sys::raw::c_int,
                               rid: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn bus_child_present(child: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_child_pnpinfo_str(child: device_t,
                                 buf: *mut ::kernel::sys::raw::c_char,
                                 buflen: usize) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_child_location_str(child: device_t,
                                  buf: *mut ::kernel::sys::raw::c_char,
                                  buflen: usize) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_enumerate_hinted_children(bus: device_t);
}
extern "C" {
    pub fn device_add_child(dev: device_t,
                            name: *const ::kernel::sys::raw::c_char,
                            unit: ::kernel::sys::raw::c_int) -> device_t;
}
extern "C" {
    pub fn device_add_child_ordered(dev: device_t, order: u_int,
                                    name: *const ::kernel::sys::raw::c_char,
                                    unit: ::kernel::sys::raw::c_int)
     -> device_t;
}
extern "C" {
    pub fn device_busy(dev: device_t);
}
extern "C" {
    pub fn device_delete_child(dev: device_t, child: device_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn device_delete_children(dev: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn device_attach(dev: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn device_detach(dev: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn device_disable(dev: device_t);
}
extern "C" {
    pub fn device_enable(dev: device_t);
}
extern "C" {
    pub fn device_find_child(dev: device_t,
                             classname: *const ::kernel::sys::raw::c_char,
                             unit: ::kernel::sys::raw::c_int) -> device_t;
}
extern "C" {
    pub fn device_get_desc(dev: device_t)
     -> *const ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn device_get_devclass(dev: device_t) -> devclass_t;
}
extern "C" {
    pub fn device_get_driver(dev: device_t) -> *mut driver_t;
}
extern "C" {
    pub fn device_get_flags(dev: device_t) -> u_int32_t;
}
extern "C" {
    pub fn device_get_parent(dev: device_t) -> device_t;
}
extern "C" {
    pub fn device_get_children(dev: device_t, listp: *mut *mut device_t,
                               countp: *mut ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn device_get_ivars(dev: device_t) -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn device_set_ivars(dev: device_t,
                            ivars: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn device_get_name(dev: device_t)
     -> *const ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn device_get_nameunit(dev: device_t)
     -> *const ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn device_get_softc(dev: device_t) -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn device_get_state(dev: device_t) -> device_state_t;
}
extern "C" {
    pub fn device_get_unit(dev: device_t) -> ::kernel::sys::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sysctl_ctx_list {
    pub tqh_first: *mut sysctl_ctx_entry,
    pub tqh_last: *mut *mut sysctl_ctx_entry,
}
#[test]
fn bindgen_test_layout_sysctl_ctx_list() {
    assert_eq!(::core::mem::size_of::<sysctl_ctx_list>() , 16usize , concat !
               ( "Size of: " , stringify ! ( sysctl_ctx_list ) ));
    assert_eq! (::core::mem::align_of::<sysctl_ctx_list>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( sysctl_ctx_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_ctx_list ) ) . tqh_first as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sysctl_ctx_list ) ,
                "::" , stringify ! ( tqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_ctx_list ) ) . tqh_last as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sysctl_ctx_list ) ,
                "::" , stringify ! ( tqh_last ) ));
}
impl Clone for sysctl_ctx_list {
    fn clone(&self) -> Self { *self }
}
impl Default for sysctl_ctx_list {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    pub fn device_get_sysctl_ctx(dev: device_t) -> *mut sysctl_ctx_list;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sysctl_oid {
    pub oid_children: sysctl_oid_list,
    pub oid_parent: *mut sysctl_oid_list,
    pub oid_link: sysctl_oid__bindgen_ty_1,
    pub oid_number: ::kernel::sys::raw::c_int,
    pub oid_kind: u_int,
    pub oid_arg1: *mut ::kernel::sys::raw::c_void,
    pub oid_arg2: intmax_t,
    pub oid_name: *const ::kernel::sys::raw::c_char,
    pub oid_handler: ::core::option::Option<unsafe extern "C" fn(oidp:
                                                                     *mut sysctl_oid,
                                                                 arg1:
                                                                     *mut ::kernel::sys::raw::c_void,
                                                                 arg2:
                                                                     intmax_t,
                                                                 req:
                                                                     *mut sysctl_req)
                                                -> ::kernel::sys::raw::c_int>,
    pub oid_fmt: *const ::kernel::sys::raw::c_char,
    pub oid_refcnt: ::kernel::sys::raw::c_int,
    pub oid_running: u_int,
    pub oid_descr: *const ::kernel::sys::raw::c_char,
    pub oid_label: *const ::kernel::sys::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sysctl_oid__bindgen_ty_1 {
    pub sle_next: *mut sysctl_oid,
}
#[test]
fn bindgen_test_layout_sysctl_oid__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<sysctl_oid__bindgen_ty_1>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( sysctl_oid__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<sysctl_oid__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( sysctl_oid__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_oid__bindgen_ty_1 ) ) . sle_next
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                sysctl_oid__bindgen_ty_1 ) , "::" , stringify ! ( sle_next )
                ));
}
impl Clone for sysctl_oid__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for sysctl_oid__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_sysctl_oid() {
    assert_eq!(::core::mem::size_of::<sysctl_oid>() , 96usize , concat ! (
               "Size of: " , stringify ! ( sysctl_oid ) ));
    assert_eq! (::core::mem::align_of::<sysctl_oid>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sysctl_oid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_oid ) ) . oid_children as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sysctl_oid ) , "::" ,
                stringify ! ( oid_children ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_oid ) ) . oid_parent as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sysctl_oid ) , "::" ,
                stringify ! ( oid_parent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_oid ) ) . oid_link as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( sysctl_oid ) , "::" ,
                stringify ! ( oid_link ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_oid ) ) . oid_number as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( sysctl_oid ) , "::" ,
                stringify ! ( oid_number ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_oid ) ) . oid_kind as * const _ as
                usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( sysctl_oid ) , "::" ,
                stringify ! ( oid_kind ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_oid ) ) . oid_arg1 as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( sysctl_oid ) , "::" ,
                stringify ! ( oid_arg1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_oid ) ) . oid_arg2 as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( sysctl_oid ) , "::" ,
                stringify ! ( oid_arg2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_oid ) ) . oid_name as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( sysctl_oid ) , "::" ,
                stringify ! ( oid_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_oid ) ) . oid_handler as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( sysctl_oid ) , "::" ,
                stringify ! ( oid_handler ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_oid ) ) . oid_fmt as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( sysctl_oid ) , "::" ,
                stringify ! ( oid_fmt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_oid ) ) . oid_refcnt as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( sysctl_oid ) , "::" ,
                stringify ! ( oid_refcnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_oid ) ) . oid_running as * const _
                as usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( sysctl_oid ) , "::" ,
                stringify ! ( oid_running ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_oid ) ) . oid_descr as * const _
                as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( sysctl_oid ) , "::" ,
                stringify ! ( oid_descr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_oid ) ) . oid_label as * const _
                as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( sysctl_oid ) , "::" ,
                stringify ! ( oid_label ) ));
}
impl Clone for sysctl_oid {
    fn clone(&self) -> Self { *self }
}
impl Default for sysctl_oid {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    pub fn device_get_sysctl_tree(dev: device_t) -> *mut sysctl_oid;
}
extern "C" {
    pub fn device_has_quiet_children(dev: device_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn device_is_alive(dev: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn device_is_attached(dev: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn device_is_enabled(dev: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn device_is_suspended(dev: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn device_is_quiet(dev: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn device_lookup_by_name(name: *const ::kernel::sys::raw::c_char)
     -> device_t;
}
extern "C" {
    pub fn device_print_prettyname(dev: device_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn device_printf(dev: device_t,
                         arg1: *const ::kernel::sys::raw::c_char, ...)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn device_probe(dev: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn device_probe_and_attach(dev: device_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn device_probe_child(bus: device_t, dev: device_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn device_quiesce(dev: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn device_quiet(dev: device_t);
}
extern "C" {
    pub fn device_quiet_children(dev: device_t);
}
extern "C" {
    pub fn device_set_desc(dev: device_t,
                           desc: *const ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn device_set_desc_copy(dev: device_t,
                                desc: *const ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn device_set_devclass(dev: device_t,
                               classname: *const ::kernel::sys::raw::c_char)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn device_set_devclass_fixed(dev: device_t,
                                     classname:
                                         *const ::kernel::sys::raw::c_char)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn device_set_driver(dev: device_t, driver: *mut driver_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn device_set_flags(dev: device_t, flags: u_int32_t);
}
extern "C" {
    pub fn device_set_softc(dev: device_t,
                            softc: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn device_free_softc(softc: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn device_claim_softc(dev: device_t);
}
extern "C" {
    pub fn device_set_unit(dev: device_t, unit: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn device_shutdown(dev: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn device_unbusy(dev: device_t);
}
extern "C" {
    pub fn device_verbose(dev: device_t);
}
extern "C" {
    pub fn devclass_add_driver(dc: devclass_t, driver: *mut driver_t,
                               pass: ::kernel::sys::raw::c_int,
                               dcp: *mut devclass_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn devclass_create(classname: *const ::kernel::sys::raw::c_char)
     -> devclass_t;
}
extern "C" {
    pub fn devclass_delete_driver(busclass: devclass_t, driver: *mut driver_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn devclass_find(classname: *const ::kernel::sys::raw::c_char)
     -> devclass_t;
}
extern "C" {
    pub fn devclass_get_name(dc: devclass_t)
     -> *const ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn devclass_get_device(dc: devclass_t,
                               unit: ::kernel::sys::raw::c_int) -> device_t;
}
extern "C" {
    pub fn devclass_get_softc(dc: devclass_t, unit: ::kernel::sys::raw::c_int)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn devclass_get_devices(dc: devclass_t, listp: *mut *mut device_t,
                                countp: *mut ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn devclass_get_drivers(dc: devclass_t,
                                listp: *mut *mut *mut driver_t,
                                countp: *mut ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn devclass_get_count(dc: devclass_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn devclass_get_maxunit(dc: devclass_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn devclass_find_free_unit(dc: devclass_t,
                                   unit: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn devclass_set_parent(dc: devclass_t, pdc: devclass_t);
}
extern "C" {
    pub fn devclass_get_parent(dc: devclass_t) -> devclass_t;
}
extern "C" {
    pub fn devclass_get_sysctl_ctx(dc: devclass_t) -> *mut sysctl_ctx_list;
}
extern "C" {
    pub fn devclass_get_sysctl_tree(dc: devclass_t) -> *mut sysctl_oid;
}
extern "C" {
    pub fn resource_int_value(name: *const ::kernel::sys::raw::c_char,
                              unit: ::kernel::sys::raw::c_int,
                              resname: *const ::kernel::sys::raw::c_char,
                              result: *mut ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn resource_long_value(name: *const ::kernel::sys::raw::c_char,
                               unit: ::kernel::sys::raw::c_int,
                               resname: *const ::kernel::sys::raw::c_char,
                               result: *mut ::kernel::sys::raw::c_long)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn resource_string_value(name: *const ::kernel::sys::raw::c_char,
                                 unit: ::kernel::sys::raw::c_int,
                                 resname: *const ::kernel::sys::raw::c_char,
                                 result:
                                     *mut *const ::kernel::sys::raw::c_char)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn resource_disabled(name: *const ::kernel::sys::raw::c_char,
                             unit: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn resource_find_match(anchor: *mut ::kernel::sys::raw::c_int,
                               name: *mut *const ::kernel::sys::raw::c_char,
                               unit: *mut ::kernel::sys::raw::c_int,
                               resname: *const ::kernel::sys::raw::c_char,
                               value: *const ::kernel::sys::raw::c_char)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn resource_find_dev(anchor: *mut ::kernel::sys::raw::c_int,
                             name: *const ::kernel::sys::raw::c_char,
                             unit: *mut ::kernel::sys::raw::c_int,
                             resname: *const ::kernel::sys::raw::c_char,
                             value: *const ::kernel::sys::raw::c_char)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn resource_unset_value(name: *const ::kernel::sys::raw::c_char,
                                unit: ::kernel::sys::raw::c_int,
                                resname: *const ::kernel::sys::raw::c_char)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_data_generation_check(generation: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_data_generation_update();
}
extern "C" {
    #[link_name = "bus_current_pass"]
    pub static mut bus_current_pass: ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_set_pass(pass: ::kernel::sys::raw::c_int);
}
extern "C" {
    #[link_name = "device_probe_desc"]
    pub static mut device_probe_desc: kobjop_desc;
}
/// @brief A function implementing the DEVICE_PROBE() method
pub type device_probe_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "device_identify_desc"]
    pub static mut device_identify_desc: kobjop_desc;
}
/// @brief A function implementing the DEVICE_IDENTIFY() method
pub type device_identify_t =
    ::core::option::Option<unsafe extern "C" fn(driver: *mut driver_t,
                                                parent: device_t)>;
extern "C" {
    #[link_name = "device_attach_desc"]
    pub static mut device_attach_desc: kobjop_desc;
}
/// @brief A function implementing the DEVICE_ATTACH() method
pub type device_attach_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "device_detach_desc"]
    pub static mut device_detach_desc: kobjop_desc;
}
/// @brief A function implementing the DEVICE_DETACH() method
pub type device_detach_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "device_shutdown_desc"]
    pub static mut device_shutdown_desc: kobjop_desc;
}
/// @brief A function implementing the DEVICE_SHUTDOWN() method
pub type device_shutdown_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "device_suspend_desc"]
    pub static mut device_suspend_desc: kobjop_desc;
}
/// @brief A function implementing the DEVICE_SUSPEND() method
pub type device_suspend_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "device_resume_desc"]
    pub static mut device_resume_desc: kobjop_desc;
}
/// @brief A function implementing the DEVICE_RESUME() method
pub type device_resume_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "device_quiesce_desc"]
    pub static mut device_quiesce_desc: kobjop_desc;
}
/// @brief A function implementing the DEVICE_QUIESCE() method
pub type device_quiesce_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "device_register_desc"]
    pub static mut device_register_desc: kobjop_desc;
}
/// @brief A function implementing the DEVICE_REGISTER() method
pub type device_register_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t)
                               -> *mut ::kernel::sys::raw::c_void>;
extern "C" {
    #[link_name = "bus_print_child_desc"]
    pub static mut bus_print_child_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_PRINT_CHILD() method
pub type bus_print_child_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_probe_nomatch_desc"]
    pub static mut bus_probe_nomatch_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_PROBE_NOMATCH() method
pub type bus_probe_nomatch_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t)>;
extern "C" {
    #[link_name = "bus_read_ivar_desc"]
    pub static mut bus_read_ivar_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_READ_IVAR() method
pub type bus_read_ivar_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t,
                                                _index:
                                                    ::kernel::sys::raw::c_int,
                                                _result: *mut usize)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_write_ivar_desc"]
    pub static mut bus_write_ivar_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_WRITE_IVAR() method
pub type bus_write_ivar_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t,
                                                _indx:
                                                    ::kernel::sys::raw::c_int,
                                                _value: usize)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_child_deleted_desc"]
    pub static mut bus_child_deleted_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_CHILD_DELETED() method
pub type bus_child_deleted_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t)>;
extern "C" {
    #[link_name = "bus_child_detached_desc"]
    pub static mut bus_child_detached_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_CHILD_DETACHED() method
pub type bus_child_detached_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t)>;
extern "C" {
    #[link_name = "bus_driver_added_desc"]
    pub static mut bus_driver_added_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_DRIVER_ADDED() method
pub type bus_driver_added_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _driver: *mut driver_t)>;
extern "C" {
    #[link_name = "bus_add_child_desc"]
    pub static mut bus_add_child_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_ADD_CHILD() method
pub type bus_add_child_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t, _order: u_int,
                                                _name:
                                                    *const ::kernel::sys::raw::c_char,
                                                _unit:
                                                    ::kernel::sys::raw::c_int)
                               -> device_t>;
extern "C" {
    #[link_name = "bus_rescan_desc"]
    pub static mut bus_rescan_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_RESCAN() method
pub type bus_rescan_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_alloc_resource_desc"]
    pub static mut bus_alloc_resource_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_ALLOC_RESOURCE() method
pub type bus_alloc_resource_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t,
                                                _type:
                                                    ::kernel::sys::raw::c_int,
                                                _rid:
                                                    *mut ::kernel::sys::raw::c_int,
                                                _start: rman_res_t,
                                                _end: rman_res_t,
                                                _count: rman_res_t,
                                                _flags: u_int)
                               -> *mut resource>;
extern "C" {
    #[link_name = "bus_activate_resource_desc"]
    pub static mut bus_activate_resource_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_ACTIVATE_RESOURCE() method
pub type bus_activate_resource_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t,
                                                _type:
                                                    ::kernel::sys::raw::c_int,
                                                _rid:
                                                    ::kernel::sys::raw::c_int,
                                                _r: *mut resource)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_map_resource_desc"]
    pub static mut bus_map_resource_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_MAP_RESOURCE() method
pub type bus_map_resource_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t,
                                                _type:
                                                    ::kernel::sys::raw::c_int,
                                                _r: *mut resource,
                                                _args:
                                                    *mut resource_map_request,
                                                _map: *mut resource_map)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_unmap_resource_desc"]
    pub static mut bus_unmap_resource_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_UNMAP_RESOURCE() method
pub type bus_unmap_resource_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t,
                                                _type:
                                                    ::kernel::sys::raw::c_int,
                                                _r: *mut resource,
                                                _map: *mut resource_map)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_deactivate_resource_desc"]
    pub static mut bus_deactivate_resource_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_DEACTIVATE_RESOURCE() method
pub type bus_deactivate_resource_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t,
                                                _type:
                                                    ::kernel::sys::raw::c_int,
                                                _rid:
                                                    ::kernel::sys::raw::c_int,
                                                _r: *mut resource)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_adjust_resource_desc"]
    pub static mut bus_adjust_resource_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_ADJUST_RESOURCE() method
pub type bus_adjust_resource_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t,
                                                _type:
                                                    ::kernel::sys::raw::c_int,
                                                _res: *mut resource,
                                                _start: rman_res_t,
                                                _end: rman_res_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_release_resource_desc"]
    pub static mut bus_release_resource_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_RELEASE_RESOURCE() method
pub type bus_release_resource_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t,
                                                _type:
                                                    ::kernel::sys::raw::c_int,
                                                _rid:
                                                    ::kernel::sys::raw::c_int,
                                                _res: *mut resource)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_setup_intr_desc"]
    pub static mut bus_setup_intr_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_SETUP_INTR() method
pub type bus_setup_intr_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t,
                                                _irq: *mut resource,
                                                _flags:
                                                    ::kernel::sys::raw::c_int,
                                                _filter: driver_filter_t,
                                                _intr: driver_intr_t,
                                                _arg:
                                                    *mut ::kernel::sys::raw::c_void,
                                                _cookiep:
                                                    *mut *mut ::kernel::sys::raw::c_void)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_teardown_intr_desc"]
    pub static mut bus_teardown_intr_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_TEARDOWN_INTR() method
pub type bus_teardown_intr_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t,
                                                _irq: *mut resource,
                                                _cookie:
                                                    *mut ::kernel::sys::raw::c_void)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_set_resource_desc"]
    pub static mut bus_set_resource_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_SET_RESOURCE() method
pub type bus_set_resource_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t,
                                                _type:
                                                    ::kernel::sys::raw::c_int,
                                                _rid:
                                                    ::kernel::sys::raw::c_int,
                                                _start: rman_res_t,
                                                _count: rman_res_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_get_resource_desc"]
    pub static mut bus_get_resource_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_GET_RESOURCE() method
pub type bus_get_resource_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t,
                                                _type:
                                                    ::kernel::sys::raw::c_int,
                                                _rid:
                                                    ::kernel::sys::raw::c_int,
                                                _startp: *mut rman_res_t,
                                                _countp: *mut rman_res_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_delete_resource_desc"]
    pub static mut bus_delete_resource_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_DELETE_RESOURCE() method
pub type bus_delete_resource_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t,
                                                _type:
                                                    ::kernel::sys::raw::c_int,
                                                _rid:
                                                    ::kernel::sys::raw::c_int)>;
extern "C" {
    #[link_name = "bus_get_resource_list_desc"]
    pub static mut bus_get_resource_list_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_GET_RESOURCE_LIST() method
pub type bus_get_resource_list_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t)
                               -> *mut resource_list>;
extern "C" {
    #[link_name = "bus_child_present_desc"]
    pub static mut bus_child_present_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_CHILD_PRESENT() method
pub type bus_child_present_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_child_pnpinfo_str_desc"]
    pub static mut bus_child_pnpinfo_str_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_CHILD_PNPINFO_STR() method
pub type bus_child_pnpinfo_str_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t,
                                                _buf:
                                                    *mut ::kernel::sys::raw::c_char,
                                                _buflen: usize)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_child_location_str_desc"]
    pub static mut bus_child_location_str_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_CHILD_LOCATION_STR() method
pub type bus_child_location_str_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t,
                                                _buf:
                                                    *mut ::kernel::sys::raw::c_char,
                                                _buflen: usize)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_bind_intr_desc"]
    pub static mut bus_bind_intr_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_BIND_INTR() method
pub type bus_bind_intr_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t,
                                                _irq: *mut resource,
                                                _cpu:
                                                    ::kernel::sys::raw::c_int)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_config_intr_desc"]
    pub static mut bus_config_intr_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_CONFIG_INTR() method
pub type bus_config_intr_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _irq:
                                                    ::kernel::sys::raw::c_int,
                                                _trig: intr_trigger,
                                                _pol: intr_polarity)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_describe_intr_desc"]
    pub static mut bus_describe_intr_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_DESCRIBE_INTR() method
pub type bus_describe_intr_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t,
                                                _irq: *mut resource,
                                                _cookie:
                                                    *mut ::kernel::sys::raw::c_void,
                                                _descr:
                                                    *const ::kernel::sys::raw::c_char)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_hinted_child_desc"]
    pub static mut bus_hinted_child_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_HINTED_CHILD() method
pub type bus_hinted_child_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _dname:
                                                    *const ::kernel::sys::raw::c_char,
                                                _dunit:
                                                    ::kernel::sys::raw::c_int)>;
extern "C" {
    #[link_name = "bus_get_dma_tag_desc"]
    pub static mut bus_get_dma_tag_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_GET_DMA_TAG() method
pub type bus_get_dma_tag_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t)
                               -> bus_dma_tag_t>;
extern "C" {
    #[link_name = "bus_get_bus_tag_desc"]
    pub static mut bus_get_bus_tag_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_GET_BUS_TAG() method
pub type bus_get_bus_tag_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t)
                               -> bus_space_tag_t>;
extern "C" {
    #[link_name = "bus_hint_device_unit_desc"]
    pub static mut bus_hint_device_unit_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_HINT_DEVICE_UNIT() method
pub type bus_hint_device_unit_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t,
                                                _name:
                                                    *const ::kernel::sys::raw::c_char,
                                                _unitp:
                                                    *mut ::kernel::sys::raw::c_int)>;
extern "C" {
    #[link_name = "bus_new_pass_desc"]
    pub static mut bus_new_pass_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_NEW_PASS() method
pub type bus_new_pass_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t)>;
extern "C" {
    #[link_name = "bus_remap_intr_desc"]
    pub static mut bus_remap_intr_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_REMAP_INTR() method
pub type bus_remap_intr_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t, _irq: u_int)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_suspend_child_desc"]
    pub static mut bus_suspend_child_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_SUSPEND_CHILD() method
pub type bus_suspend_child_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_resume_child_desc"]
    pub static mut bus_resume_child_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_RESUME_CHILD() method
pub type bus_resume_child_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_get_domain_desc"]
    pub static mut bus_get_domain_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_GET_DOMAIN() method
pub type bus_get_domain_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t,
                                                _domain:
                                                    *mut ::kernel::sys::raw::c_int)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "bus_get_cpus_desc"]
    pub static mut bus_get_cpus_desc: kobjop_desc;
}
/// @brief A function implementing the BUS_GET_CPUS() method
pub type bus_get_cpus_t =
    ::core::option::Option<unsafe extern "C" fn(_dev: device_t,
                                                _child: device_t,
                                                _op: cpu_sets,
                                                _setsize: usize,
                                                _cpuset: *mut cpuset_t)
                               -> ::kernel::sys::raw::c_int>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct module {
    _unused: [u8; 0],
}
extern "C" {
    pub fn driver_module_handler(arg1: *mut module,
                                 arg2: ::kernel::sys::raw::c_int,
                                 arg3: *mut ::kernel::sys::raw::c_void)
     -> ::kernel::sys::raw::c_int;
}
/// Module support for automatically adding drivers to buses.
#[repr(C)]
#[derive(Debug, Copy)]
pub struct driver_module_data {
    pub dmd_chainevh: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut module,
                                                                  arg2:
                                                                      ::kernel::sys::raw::c_int,
                                                                  arg3:
                                                                      *mut ::kernel::sys::raw::c_void)
                                                 ->
                                                     ::kernel::sys::raw::c_int>,
    pub dmd_chainarg: *mut ::kernel::sys::raw::c_void,
    pub dmd_busname: *const ::kernel::sys::raw::c_char,
    pub dmd_driver: kobj_class_t,
    pub dmd_devclass: *mut devclass_t,
    pub dmd_pass: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_driver_module_data() {
    assert_eq!(::core::mem::size_of::<driver_module_data>() , 48usize , concat
               ! ( "Size of: " , stringify ! ( driver_module_data ) ));
    assert_eq! (::core::mem::align_of::<driver_module_data>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( driver_module_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const driver_module_data ) ) . dmd_chainevh as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( driver_module_data ) ,
                "::" , stringify ! ( dmd_chainevh ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const driver_module_data ) ) . dmd_chainarg as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( driver_module_data ) ,
                "::" , stringify ! ( dmd_chainarg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const driver_module_data ) ) . dmd_busname as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( driver_module_data ) ,
                "::" , stringify ! ( dmd_busname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const driver_module_data ) ) . dmd_driver as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( driver_module_data ) ,
                "::" , stringify ! ( dmd_driver ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const driver_module_data ) ) . dmd_devclass as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( driver_module_data ) ,
                "::" , stringify ! ( dmd_devclass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const driver_module_data ) ) . dmd_pass as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( driver_module_data ) ,
                "::" , stringify ! ( dmd_pass ) ));
}
impl Clone for driver_module_data {
    fn clone(&self) -> Self { *self }
}
impl Default for driver_module_data {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    #[link_name = "kernelname"]
    pub static mut kernelname: [::kernel::sys::raw::c_char; 1024usize];
}
extern "C" {
    #[link_name = "tick"]
    pub static mut tick: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "hz"]
    pub static mut hz: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "psratio"]
    pub static mut psratio: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "stathz"]
    pub static mut stathz: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "profhz"]
    pub static mut profhz: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "profprocs"]
    pub static mut profprocs: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "ticks"]
    pub static mut ticks: ::kernel::sys::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sysinit_sub_id {
    SI_SUB_DUMMY = 0,
    SI_SUB_DONE = 1,
    SI_SUB_TUNABLES = 7340032,
    SI_SUB_COPYRIGHT = 8388609,
    SI_SUB_VM = 16777216,
    SI_SUB_KMEM = 25165824,
    SI_SUB_HYPERVISOR = 27525120,
    SI_SUB_WITNESS = 27787264,
    SI_SUB_MTX_POOL_DYNAMIC = 28049408,
    SI_SUB_LOCK = 28311552,
    SI_SUB_EVENTHANDLER = 29360128,
    SI_SUB_VNET_PRELINK = 31457280,
    SI_SUB_KLD = 33554432,
    SI_SUB_CPU = 34603008,
    SI_SUB_RACCT = 34668544,
    SI_SUB_KDTRACE = 34865152,
    SI_SUB_RANDOM = 34996224,
    SI_SUB_MAC = 35127296,
    SI_SUB_MAC_POLICY = 35389440,
    SI_SUB_MAC_LATE = 35454976,
    SI_SUB_VNET = 35520512,
    SI_SUB_INTRINSIC = 35651584,
    SI_SUB_VM_CONF = 36700160,
    SI_SUB_DDB_SERVICES = 37224448,
    SI_SUB_RUN_QUEUE = 37748736,
    SI_SUB_KTRACE = 38273024,
    SI_SUB_OPENSOLARIS = 38338560,
    SI_SUB_AUDIT = 38535168,
    SI_SUB_CREATE_INIT = 38797312,
    SI_SUB_SCHED_IDLE = 39845888,
    SI_SUB_MBUF = 40894464,
    SI_SUB_INTR = 41943040,
    SI_SUB_TASKQ = 42467328,
    SI_SUB_SOFTINTR = 44040192,
    SI_SUB_DEVFS = 49283072,
    SI_SUB_INIT_IF = 50331648,
    SI_SUB_NETGRAPH = 50397184,
    SI_SUB_DTRACE = 50462720,
    SI_SUB_DTRACE_PROVIDER = 50626560,
    SI_SUB_DTRACE_ANON = 50905088,
    SI_SUB_DRIVERS = 51380224,
    SI_SUB_CONFIGURE = 58720256,
    SI_SUB_VFS = 67108864,
    SI_SUB_CLOCKS = 75497472,
    SI_SUB_SYSV_SHM = 104857600,
    SI_SUB_SYSV_SEM = 109051904,
    SI_SUB_SYSV_MSG = 113246208,
    SI_SUB_P1003_1B = 115343360,
    SI_SUB_PSEUDO = 117440512,
    SI_SUB_EXEC = 121634816,
    SI_SUB_PROTO_BEGIN = 134217728,
    SI_SUB_PROTO_PFIL = 135266304,
    SI_SUB_PROTO_IF = 138412032,
    SI_SUB_PROTO_DOMAININIT = 140509184,
    SI_SUB_PROTO_MC = 141557760,
    SI_SUB_PROTO_DOMAIN = 142606336,
    SI_SUB_PROTO_FIREWALL = 142630912,
    SI_SUB_PROTO_IFATTACHDOMAIN = 142639104,
    SI_SUB_PROTO_END = 150994943,
    SI_SUB_KPROF = 150994944,
    SI_SUB_KICK_SCHEDULER = 167772160,
    SI_SUB_INT_CONFIG_HOOKS = 176160768,
    SI_SUB_ROOT_CONF = 184549376,
    SI_SUB_INTRINSIC_POST = 218103808,
    SI_SUB_SYSCALLS = 226492416,
    SI_SUB_VNET_DONE = 230686720,
    SI_SUB_KTHREAD_INIT = 234881024,
    SI_SUB_KTHREAD_PAGE = 239075328,
    SI_SUB_KTHREAD_VM = 243269632,
    SI_SUB_KTHREAD_BUF = 245366784,
    SI_SUB_KTHREAD_UPDATE = 247463936,
    SI_SUB_KTHREAD_IDLE = 249561088,
    SI_SUB_SMP = 251658240,
    SI_SUB_RACCTD = 252706816,
    SI_SUB_LAST = 268435455,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum sysinit_elem_order {
    SI_ORDER_FIRST = 0,
    SI_ORDER_SECOND = 1,
    SI_ORDER_THIRD = 2,
    SI_ORDER_FOURTH = 3,
    SI_ORDER_MIDDLE = 16777216,
    SI_ORDER_ANY = 268435455,
}
pub type sysinit_nfunc_t =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void)>;
pub type sysinit_cfunc_t =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *const ::kernel::sys::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sysinit {
    pub subsystem: sysinit_sub_id,
    pub order: sysinit_elem_order,
    pub func: sysinit_cfunc_t,
    pub udata: *const ::kernel::sys::raw::c_void,
}
#[test]
fn bindgen_test_layout_sysinit() {
    assert_eq!(::core::mem::size_of::<sysinit>() , 24usize , concat ! (
               "Size of: " , stringify ! ( sysinit ) ));
    assert_eq! (::core::mem::align_of::<sysinit>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sysinit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysinit ) ) . subsystem as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sysinit ) , "::" ,
                stringify ! ( subsystem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysinit ) ) . order as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( sysinit ) , "::" ,
                stringify ! ( order ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysinit ) ) . func as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sysinit ) , "::" ,
                stringify ! ( func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysinit ) ) . udata as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( sysinit ) , "::" ,
                stringify ! ( udata ) ));
}
impl Clone for sysinit {
    fn clone(&self) -> Self { *self }
}
impl Default for sysinit {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    pub fn sysinit_add(set: *mut *mut sysinit, set_end: *mut *mut sysinit);
}
extern "C" {
    pub fn tunable_int_init(arg1: *mut ::kernel::sys::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tunable_int {
    pub path: *const ::kernel::sys::raw::c_char,
    pub var: *mut ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_tunable_int() {
    assert_eq!(::core::mem::size_of::<tunable_int>() , 16usize , concat ! (
               "Size of: " , stringify ! ( tunable_int ) ));
    assert_eq! (::core::mem::align_of::<tunable_int>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( tunable_int ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tunable_int ) ) . path as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tunable_int ) , "::" ,
                stringify ! ( path ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tunable_int ) ) . var as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tunable_int ) , "::" ,
                stringify ! ( var ) ));
}
impl Clone for tunable_int {
    fn clone(&self) -> Self { *self }
}
impl Default for tunable_int {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    pub fn tunable_long_init(arg1: *mut ::kernel::sys::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tunable_long {
    pub path: *const ::kernel::sys::raw::c_char,
    pub var: *mut ::kernel::sys::raw::c_long,
}
#[test]
fn bindgen_test_layout_tunable_long() {
    assert_eq!(::core::mem::size_of::<tunable_long>() , 16usize , concat ! (
               "Size of: " , stringify ! ( tunable_long ) ));
    assert_eq! (::core::mem::align_of::<tunable_long>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( tunable_long ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tunable_long ) ) . path as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tunable_long ) , "::" ,
                stringify ! ( path ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tunable_long ) ) . var as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tunable_long ) , "::" ,
                stringify ! ( var ) ));
}
impl Clone for tunable_long {
    fn clone(&self) -> Self { *self }
}
impl Default for tunable_long {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    pub fn tunable_ulong_init(arg1: *mut ::kernel::sys::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tunable_ulong {
    pub path: *const ::kernel::sys::raw::c_char,
    pub var: *mut ::kernel::sys::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_tunable_ulong() {
    assert_eq!(::core::mem::size_of::<tunable_ulong>() , 16usize , concat ! (
               "Size of: " , stringify ! ( tunable_ulong ) ));
    assert_eq! (::core::mem::align_of::<tunable_ulong>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( tunable_ulong ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tunable_ulong ) ) . path as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tunable_ulong ) , "::"
                , stringify ! ( path ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tunable_ulong ) ) . var as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tunable_ulong ) , "::"
                , stringify ! ( var ) ));
}
impl Clone for tunable_ulong {
    fn clone(&self) -> Self { *self }
}
impl Default for tunable_ulong {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    pub fn tunable_int64_init(arg1: *mut ::kernel::sys::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tunable_int64 {
    pub path: *const ::kernel::sys::raw::c_char,
    pub var: *mut i64,
}
#[test]
fn bindgen_test_layout_tunable_int64() {
    assert_eq!(::core::mem::size_of::<tunable_int64>() , 16usize , concat ! (
               "Size of: " , stringify ! ( tunable_int64 ) ));
    assert_eq! (::core::mem::align_of::<tunable_int64>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( tunable_int64 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tunable_int64 ) ) . path as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tunable_int64 ) , "::"
                , stringify ! ( path ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tunable_int64 ) ) . var as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tunable_int64 ) , "::"
                , stringify ! ( var ) ));
}
impl Clone for tunable_int64 {
    fn clone(&self) -> Self { *self }
}
impl Default for tunable_int64 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    pub fn tunable_uint64_init(arg1: *mut ::kernel::sys::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tunable_uint64 {
    pub path: *const ::kernel::sys::raw::c_char,
    pub var: *mut u64,
}
#[test]
fn bindgen_test_layout_tunable_uint64() {
    assert_eq!(::core::mem::size_of::<tunable_uint64>() , 16usize , concat ! (
               "Size of: " , stringify ! ( tunable_uint64 ) ));
    assert_eq! (::core::mem::align_of::<tunable_uint64>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( tunable_uint64 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tunable_uint64 ) ) . path as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tunable_uint64 ) , "::"
                , stringify ! ( path ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tunable_uint64 ) ) . var as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tunable_uint64 ) , "::"
                , stringify ! ( var ) ));
}
impl Clone for tunable_uint64 {
    fn clone(&self) -> Self { *self }
}
impl Default for tunable_uint64 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    pub fn tunable_quad_init(arg1: *mut ::kernel::sys::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tunable_quad {
    pub path: *const ::kernel::sys::raw::c_char,
    pub var: *mut quad_t,
}
#[test]
fn bindgen_test_layout_tunable_quad() {
    assert_eq!(::core::mem::size_of::<tunable_quad>() , 16usize , concat ! (
               "Size of: " , stringify ! ( tunable_quad ) ));
    assert_eq! (::core::mem::align_of::<tunable_quad>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( tunable_quad ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tunable_quad ) ) . path as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tunable_quad ) , "::" ,
                stringify ! ( path ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tunable_quad ) ) . var as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tunable_quad ) , "::" ,
                stringify ! ( var ) ));
}
impl Clone for tunable_quad {
    fn clone(&self) -> Self { *self }
}
impl Default for tunable_quad {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    pub fn tunable_str_init(arg1: *mut ::kernel::sys::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tunable_str {
    pub path: *const ::kernel::sys::raw::c_char,
    pub var: *mut ::kernel::sys::raw::c_char,
    pub size: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_tunable_str() {
    assert_eq!(::core::mem::size_of::<tunable_str>() , 24usize , concat ! (
               "Size of: " , stringify ! ( tunable_str ) ));
    assert_eq! (::core::mem::align_of::<tunable_str>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( tunable_str ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tunable_str ) ) . path as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tunable_str ) , "::" ,
                stringify ! ( path ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tunable_str ) ) . var as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tunable_str ) , "::" ,
                stringify ! ( var ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tunable_str ) ) . size as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( tunable_str ) , "::" ,
                stringify ! ( size ) ));
}
impl Clone for tunable_str {
    fn clone(&self) -> Self { *self }
}
impl Default for tunable_str {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type ich_func_t =
    ::core::option::Option<unsafe extern "C" fn(_arg:
                                                    *mut ::kernel::sys::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct intr_config_hook {
    pub ich_links: intr_config_hook__bindgen_ty_1,
    pub ich_func: ich_func_t,
    pub ich_arg: *mut ::kernel::sys::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct intr_config_hook__bindgen_ty_1 {
    pub tqe_next: *mut intr_config_hook,
    pub tqe_prev: *mut *mut intr_config_hook,
}
#[test]
fn bindgen_test_layout_intr_config_hook__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<intr_config_hook__bindgen_ty_1>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( intr_config_hook__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<intr_config_hook__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( intr_config_hook__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const intr_config_hook__bindgen_ty_1 ) ) .
                tqe_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                intr_config_hook__bindgen_ty_1 ) , "::" , stringify ! (
                tqe_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const intr_config_hook__bindgen_ty_1 ) ) .
                tqe_prev as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                intr_config_hook__bindgen_ty_1 ) , "::" , stringify ! (
                tqe_prev ) ));
}
impl Clone for intr_config_hook__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for intr_config_hook__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_intr_config_hook() {
    assert_eq!(::core::mem::size_of::<intr_config_hook>() , 32usize , concat !
               ( "Size of: " , stringify ! ( intr_config_hook ) ));
    assert_eq! (::core::mem::align_of::<intr_config_hook>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( intr_config_hook ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const intr_config_hook ) ) . ich_links as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( intr_config_hook ) ,
                "::" , stringify ! ( ich_links ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const intr_config_hook ) ) . ich_func as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( intr_config_hook ) ,
                "::" , stringify ! ( ich_func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const intr_config_hook ) ) . ich_arg as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( intr_config_hook ) ,
                "::" , stringify ! ( ich_arg ) ));
}
impl Clone for intr_config_hook {
    fn clone(&self) -> Self { *self }
}
impl Default for intr_config_hook {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    pub fn config_intrhook_establish(hook: *mut intr_config_hook)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn config_intrhook_disestablish(hook: *mut intr_config_hook);
}
extern "C" {
    pub fn config_intrhook_oneshot(_func: ich_func_t,
                                   _arg: *mut ::kernel::sys::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct kproc_desc {
    pub arg0: *const ::kernel::sys::raw::c_char,
    pub func: ::core::option::Option<unsafe extern "C" fn()>,
    pub global_procpp: *mut *mut proc_,
}
#[test]
fn bindgen_test_layout_kproc_desc() {
    assert_eq!(::core::mem::size_of::<kproc_desc>() , 24usize , concat ! (
               "Size of: " , stringify ! ( kproc_desc ) ));
    assert_eq! (::core::mem::align_of::<kproc_desc>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kproc_desc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kproc_desc ) ) . arg0 as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kproc_desc ) , "::" ,
                stringify ! ( arg0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kproc_desc ) ) . func as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kproc_desc ) , "::" ,
                stringify ! ( func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kproc_desc ) ) . global_procpp as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( kproc_desc ) , "::" ,
                stringify ! ( global_procpp ) ));
}
impl Clone for kproc_desc {
    fn clone(&self) -> Self { *self }
}
impl Default for kproc_desc {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct kthread_desc {
    pub arg0: *const ::kernel::sys::raw::c_char,
    pub func: ::core::option::Option<unsafe extern "C" fn()>,
    pub global_threadpp: *mut *mut thread,
}
#[test]
fn bindgen_test_layout_kthread_desc() {
    assert_eq!(::core::mem::size_of::<kthread_desc>() , 24usize , concat ! (
               "Size of: " , stringify ! ( kthread_desc ) ));
    assert_eq! (::core::mem::align_of::<kthread_desc>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kthread_desc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kthread_desc ) ) . arg0 as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kthread_desc ) , "::" ,
                stringify ! ( arg0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kthread_desc ) ) . func as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kthread_desc ) , "::" ,
                stringify ! ( func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kthread_desc ) ) . global_threadpp as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( kthread_desc ) , "::" ,
                stringify ! ( global_threadpp ) ));
}
impl Clone for kthread_desc {
    fn clone(&self) -> Self { *self }
}
impl Default for kthread_desc {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    pub fn kproc_create(arg1:
                            ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                            *mut ::kernel::sys::raw::c_void)>,
                        arg2: *mut ::kernel::sys::raw::c_void,
                        arg3: *mut *mut proc_,
                        flags: ::kernel::sys::raw::c_int,
                        pages: ::kernel::sys::raw::c_int,
                        arg4: *const ::kernel::sys::raw::c_char, ...)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn kproc_exit(arg1: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn kproc_resume(arg1: *mut proc_) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn kproc_shutdown(arg1: *mut ::kernel::sys::raw::c_void,
                          arg2: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn kproc_start(arg1: *const ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn kproc_suspend(arg1: *mut proc_, arg2: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn kproc_suspend_check(arg1: *mut proc_);
}
extern "C" {
    pub fn kproc_kthread_add(arg1:
                                 ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                                 *mut ::kernel::sys::raw::c_void)>,
                             arg2: *mut ::kernel::sys::raw::c_void,
                             arg3: *mut *mut proc_, arg4: *mut *mut thread,
                             flags: ::kernel::sys::raw::c_int,
                             pages: ::kernel::sys::raw::c_int,
                             procname: *const ::kernel::sys::raw::c_char,
                             arg5: *const ::kernel::sys::raw::c_char, ...)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn kthread_add(arg1:
                           ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                           *mut ::kernel::sys::raw::c_void)>,
                       arg2: *mut ::kernel::sys::raw::c_void,
                       arg3: *mut proc_, arg4: *mut *mut thread,
                       flags: ::kernel::sys::raw::c_int,
                       pages: ::kernel::sys::raw::c_int,
                       arg5: *const ::kernel::sys::raw::c_char, ...)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn kthread_exit();
}
extern "C" {
    pub fn kthread_resume(arg1: *mut thread) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn kthread_shutdown(arg1: *mut ::kernel::sys::raw::c_void,
                            arg2: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn kthread_start(arg1: *const ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn kthread_suspend(arg1: *mut thread, arg2: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn kthread_suspend_check();
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct malloc_type_stats {
    pub mts_memalloced: u64,
    pub mts_memfreed: u64,
    pub mts_numallocs: u64,
    pub mts_numfrees: u64,
    pub mts_size: u64,
    pub _mts_reserved1: u64,
    pub _mts_reserved2: u64,
    pub _mts_reserved3: u64,
}
#[test]
fn bindgen_test_layout_malloc_type_stats() {
    assert_eq!(::core::mem::size_of::<malloc_type_stats>() , 64usize , concat
               ! ( "Size of: " , stringify ! ( malloc_type_stats ) ));
    assert_eq! (::core::mem::align_of::<malloc_type_stats>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( malloc_type_stats ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type_stats ) ) . mts_memalloced as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_type_stats ) ,
                "::" , stringify ! ( mts_memalloced ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type_stats ) ) . mts_memfreed as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_type_stats ) ,
                "::" , stringify ! ( mts_memfreed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type_stats ) ) . mts_numallocs as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_type_stats ) ,
                "::" , stringify ! ( mts_numallocs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type_stats ) ) . mts_numfrees as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_type_stats ) ,
                "::" , stringify ! ( mts_numfrees ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type_stats ) ) . mts_size as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_type_stats ) ,
                "::" , stringify ! ( mts_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type_stats ) ) . _mts_reserved1 as
                * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_type_stats ) ,
                "::" , stringify ! ( _mts_reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type_stats ) ) . _mts_reserved2 as
                * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_type_stats ) ,
                "::" , stringify ! ( _mts_reserved2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type_stats ) ) . _mts_reserved3 as
                * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_type_stats ) ,
                "::" , stringify ! ( _mts_reserved3 ) ));
}
impl Clone for malloc_type_stats {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct malloc_type_internal {
    pub mti_probes: [u32; 2usize],
    pub mti_zone: u_char,
    pub mti_stats: [malloc_type_stats; 256usize],
}
#[test]
fn bindgen_test_layout_malloc_type_internal() {
    assert_eq!(::core::mem::size_of::<malloc_type_internal>() , 16400usize ,
               concat ! ( "Size of: " , stringify ! ( malloc_type_internal )
               ));
    assert_eq! (::core::mem::align_of::<malloc_type_internal>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( malloc_type_internal ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type_internal ) ) . mti_probes as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_type_internal )
                , "::" , stringify ! ( mti_probes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type_internal ) ) . mti_zone as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_type_internal )
                , "::" , stringify ! ( mti_zone ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type_internal ) ) . mti_stats as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_type_internal )
                , "::" , stringify ! ( mti_stats ) ));
}
impl Clone for malloc_type_internal {
    fn clone(&self) -> Self { *self }
}
impl Default for malloc_type_internal {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for malloc_type_internal {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "malloc_type_internal {{ mti_probes: {:?}, mti_zone: {:?}, mti_stats: [{}] }}"
               , self . mti_probes , self . mti_zone , self . mti_stats . iter
               (  ) . enumerate (  ) . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ))
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct malloc_type_stream_header {
    pub mtsh_version: u32,
    pub mtsh_maxcpus: u32,
    pub mtsh_count: u32,
    pub _mtsh_pad: u32,
}
#[test]
fn bindgen_test_layout_malloc_type_stream_header() {
    assert_eq!(::core::mem::size_of::<malloc_type_stream_header>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( malloc_type_stream_header ) ));
    assert_eq! (::core::mem::align_of::<malloc_type_stream_header>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( malloc_type_stream_header )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type_stream_header ) ) .
                mtsh_version as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                malloc_type_stream_header ) , "::" , stringify ! (
                mtsh_version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type_stream_header ) ) .
                mtsh_maxcpus as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                malloc_type_stream_header ) , "::" , stringify ! (
                mtsh_maxcpus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type_stream_header ) ) .
                mtsh_count as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                malloc_type_stream_header ) , "::" , stringify ! ( mtsh_count
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type_stream_header ) ) . _mtsh_pad
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                malloc_type_stream_header ) , "::" , stringify ! ( _mtsh_pad )
                ));
}
impl Clone for malloc_type_stream_header {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct malloc_type_header {
    pub mth_name: [::kernel::sys::raw::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_malloc_type_header() {
    assert_eq!(::core::mem::size_of::<malloc_type_header>() , 32usize , concat
               ! ( "Size of: " , stringify ! ( malloc_type_header ) ));
    assert_eq! (::core::mem::align_of::<malloc_type_header>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( malloc_type_header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const malloc_type_header ) ) . mth_name as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( malloc_type_header ) ,
                "::" , stringify ! ( mth_name ) ));
}
impl Clone for malloc_type_header {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "M_CACHE"]
    pub static mut M_CACHE: [malloc_type; 1usize];
}
extern "C" {
    #[link_name = "M_DEVBUF"]
    pub static mut M_DEVBUF: [malloc_type; 1usize];
}
extern "C" {
    #[link_name = "M_TEMP"]
    pub static mut M_TEMP: [malloc_type; 1usize];
}
extern "C" {
    #[link_name = "M_IOV"]
    pub static mut M_IOV: [malloc_type; 1usize];
}
extern "C" {
    #[link_name = "malloc_mtx"]
    pub static mut malloc_mtx: mtx;
}
pub type malloc_type_list_func_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut malloc_type,
                                                arg2:
                                                    *mut ::kernel::sys::raw::c_void)>;
extern "C" {
    pub fn contigfree(addr: *mut ::kernel::sys::raw::c_void,
                      size: ::kernel::sys::raw::c_ulong,
                      type_: *mut malloc_type);
}
extern "C" {
    pub fn contigmalloc(size: ::kernel::sys::raw::c_ulong,
                        type_: *mut malloc_type,
                        flags: ::kernel::sys::raw::c_int, low: vm_paddr_t,
                        high: vm_paddr_t,
                        alignment: ::kernel::sys::raw::c_ulong,
                        boundary: vm_paddr_t)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn contigmalloc_domain(size: ::kernel::sys::raw::c_ulong,
                               type_: *mut malloc_type,
                               domain: ::kernel::sys::raw::c_int,
                               flags: ::kernel::sys::raw::c_int,
                               low: vm_paddr_t, high: vm_paddr_t,
                               alignment: ::kernel::sys::raw::c_ulong,
                               boundary: vm_paddr_t)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn free(addr: *mut ::kernel::sys::raw::c_void,
                type_: *mut malloc_type);
}
extern "C" {
    pub fn free_domain(addr: *mut ::kernel::sys::raw::c_void,
                       type_: *mut malloc_type);
}
extern "C" {
    pub fn malloc(size: usize, type_: *mut malloc_type,
                  flags: ::kernel::sys::raw::c_int)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn malloc_domain(size: usize, type_: *mut malloc_type,
                         domain: ::kernel::sys::raw::c_int,
                         flags: ::kernel::sys::raw::c_int)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn mallocarray(nmemb: usize, size: usize, type_: *mut malloc_type,
                       flags: ::kernel::sys::raw::c_int)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn malloc_init(arg1: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn malloc_last_fail() -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn malloc_type_allocated(type_: *mut malloc_type,
                                 size: ::kernel::sys::raw::c_ulong);
}
extern "C" {
    pub fn malloc_type_freed(type_: *mut malloc_type,
                             size: ::kernel::sys::raw::c_ulong);
}
extern "C" {
    pub fn malloc_type_list(arg1: malloc_type_list_func_t,
                            arg2: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn malloc_uninit(arg1: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn realloc(addr: *mut ::kernel::sys::raw::c_void, size: usize,
                   type_: *mut malloc_type, flags: ::kernel::sys::raw::c_int)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn reallocf(addr: *mut ::kernel::sys::raw::c_void, size: usize,
                    type_: *mut malloc_type, flags: ::kernel::sys::raw::c_int)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn malloc_desc2type(desc: *const ::kernel::sys::raw::c_char)
     -> *mut malloc_type;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uma_zone {
    _unused: [u8; 0],
}
pub type uma_zone_t = *mut uma_zone;
extern "C" {
    pub fn zone_drain(arg1: uma_zone_t);
}
pub type uma_ctor =
    ::core::option::Option<unsafe extern "C" fn(mem:
                                                    *mut ::kernel::sys::raw::c_void,
                                                size:
                                                    ::kernel::sys::raw::c_int,
                                                arg:
                                                    *mut ::kernel::sys::raw::c_void,
                                                flags:
                                                    ::kernel::sys::raw::c_int)
                               -> ::kernel::sys::raw::c_int>;
pub type uma_dtor =
    ::core::option::Option<unsafe extern "C" fn(mem:
                                                    *mut ::kernel::sys::raw::c_void,
                                                size:
                                                    ::kernel::sys::raw::c_int,
                                                arg:
                                                    *mut ::kernel::sys::raw::c_void)>;
pub type uma_init =
    ::core::option::Option<unsafe extern "C" fn(mem:
                                                    *mut ::kernel::sys::raw::c_void,
                                                size:
                                                    ::kernel::sys::raw::c_int,
                                                flags:
                                                    ::kernel::sys::raw::c_int)
                               -> ::kernel::sys::raw::c_int>;
pub type uma_fini =
    ::core::option::Option<unsafe extern "C" fn(mem:
                                                    *mut ::kernel::sys::raw::c_void,
                                                size:
                                                    ::kernel::sys::raw::c_int)>;
pub type uma_import =
    ::core::option::Option<unsafe extern "C" fn(arg:
                                                    *mut ::kernel::sys::raw::c_void,
                                                store:
                                                    *mut *mut ::kernel::sys::raw::c_void,
                                                count:
                                                    ::kernel::sys::raw::c_int,
                                                domain:
                                                    ::kernel::sys::raw::c_int,
                                                flags:
                                                    ::kernel::sys::raw::c_int)
                               -> ::kernel::sys::raw::c_int>;
pub type uma_release =
    ::core::option::Option<unsafe extern "C" fn(arg:
                                                    *mut ::kernel::sys::raw::c_void,
                                                store:
                                                    *mut *mut ::kernel::sys::raw::c_void,
                                                count:
                                                    ::kernel::sys::raw::c_int)>;
extern "C" {
    pub fn uma_zcreate(name: *const ::kernel::sys::raw::c_char, size: usize,
                       ctor: uma_ctor, dtor: uma_dtor, uminit: uma_init,
                       fini: uma_fini, align: ::kernel::sys::raw::c_int,
                       flags: u32) -> uma_zone_t;
}
extern "C" {
    pub fn uma_zsecond_create(name: *mut ::kernel::sys::raw::c_char,
                              ctor: uma_ctor, dtor: uma_dtor, zinit: uma_init,
                              zfini: uma_fini, master: uma_zone_t)
     -> uma_zone_t;
}
extern "C" {
    pub fn uma_zsecond_add(zone: uma_zone_t, master: uma_zone_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn uma_zcache_create(name: *mut ::kernel::sys::raw::c_char,
                             size: ::kernel::sys::raw::c_int, ctor: uma_ctor,
                             dtor: uma_dtor, zinit: uma_init, zfini: uma_fini,
                             zimport: uma_import, zrelease: uma_release,
                             arg: *mut ::kernel::sys::raw::c_void,
                             flags: ::kernel::sys::raw::c_int) -> uma_zone_t;
}
extern "C" {
    pub fn uma_zdestroy(zone: uma_zone_t);
}
extern "C" {
    pub fn uma_zalloc_arg(zone: uma_zone_t,
                          arg: *mut ::kernel::sys::raw::c_void,
                          flags: ::kernel::sys::raw::c_int)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn uma_zalloc_domain(zone: uma_zone_t,
                             arg: *mut ::kernel::sys::raw::c_void,
                             domain: ::kernel::sys::raw::c_int,
                             flags: ::kernel::sys::raw::c_int)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn uma_zfree_arg(zone: uma_zone_t,
                         item: *mut ::kernel::sys::raw::c_void,
                         arg: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn uma_zfree_domain(zone: uma_zone_t,
                            item: *mut ::kernel::sys::raw::c_void,
                            arg: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn uma_zwait(zone: uma_zone_t);
}
pub type uma_alloc =
    ::core::option::Option<unsafe extern "C" fn(zone: uma_zone_t,
                                                size: vm_size_t,
                                                domain:
                                                    ::kernel::sys::raw::c_int,
                                                pflag: *mut u8,
                                                wait:
                                                    ::kernel::sys::raw::c_int)
                               -> *mut ::kernel::sys::raw::c_void>;
pub type uma_free =
    ::core::option::Option<unsafe extern "C" fn(item:
                                                    *mut ::kernel::sys::raw::c_void,
                                                size: vm_size_t, pflag: u8)>;
extern "C" {
    pub fn uma_reclaim();
}
extern "C" {
    pub fn uma_set_align(align: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn uma_zone_reserve(zone: uma_zone_t,
                            nitems: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn uma_zone_reserve_kva(zone: uma_zone_t,
                                nitems: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn uma_zone_set_max(zone: uma_zone_t,
                            nitems: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn uma_zone_get_max(zone: uma_zone_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn uma_zone_set_warning(zone: uma_zone_t,
                                warning: *const ::kernel::sys::raw::c_char);
}
pub type uma_maxaction_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: uma_zone_t,
                                                arg2:
                                                    ::kernel::sys::raw::c_int)>;
extern "C" {
    pub fn uma_zone_set_maxaction(zone: uma_zone_t, arg1: uma_maxaction_t);
}
extern "C" {
    pub fn uma_zone_get_cur(zone: uma_zone_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn uma_zone_set_init(zone: uma_zone_t, uminit: uma_init);
}
extern "C" {
    pub fn uma_zone_set_fini(zone: uma_zone_t, fini: uma_fini);
}
extern "C" {
    pub fn uma_zone_set_zinit(zone: uma_zone_t, zinit: uma_init);
}
extern "C" {
    pub fn uma_zone_set_zfini(zone: uma_zone_t, zfini: uma_fini);
}
extern "C" {
    pub fn uma_zone_set_allocf(zone: uma_zone_t, allocf: uma_alloc);
}
extern "C" {
    pub fn uma_zone_set_freef(zone: uma_zone_t, freef: uma_free);
}
extern "C" {
    pub fn uma_prealloc(zone: uma_zone_t, itemcnt: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn uma_zone_exhausted(zone: uma_zone_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn uma_zone_exhausted_nolock(zone: uma_zone_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "pcpu_zone_64"]
    pub static mut pcpu_zone_64: uma_zone_t;
}
extern "C" {
    #[link_name = "pcpu_zone_ptr"]
    pub static mut pcpu_zone_ptr: uma_zone_t;
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct uma_stream_header {
    pub ush_version: u32,
    pub ush_maxcpus: u32,
    pub ush_count: u32,
    pub _ush_pad: u32,
}
#[test]
fn bindgen_test_layout_uma_stream_header() {
    assert_eq!(::core::mem::size_of::<uma_stream_header>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( uma_stream_header ) ));
    assert_eq! (::core::mem::align_of::<uma_stream_header>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( uma_stream_header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_stream_header ) ) . ush_version as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_stream_header ) ,
                "::" , stringify ! ( ush_version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_stream_header ) ) . ush_maxcpus as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_stream_header ) ,
                "::" , stringify ! ( ush_maxcpus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_stream_header ) ) . ush_count as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_stream_header ) ,
                "::" , stringify ! ( ush_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_stream_header ) ) . _ush_pad as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_stream_header ) ,
                "::" , stringify ! ( _ush_pad ) ));
}
impl Clone for uma_stream_header {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct uma_type_header {
    pub uth_name: [::kernel::sys::raw::c_char; 32usize],
    pub uth_align: u32,
    pub uth_size: u32,
    pub uth_rsize: u32,
    pub uth_maxpages: u32,
    pub uth_limit: u32,
    pub uth_pages: u32,
    pub uth_keg_free: u32,
    pub uth_zone_free: u32,
    pub uth_bucketsize: u32,
    pub uth_zone_flags: u32,
    pub uth_allocs: u64,
    pub uth_frees: u64,
    pub uth_fails: u64,
    pub uth_sleeps: u64,
    pub _uth_reserved1: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_uma_type_header() {
    assert_eq!(::core::mem::size_of::<uma_type_header>() , 120usize , concat !
               ( "Size of: " , stringify ! ( uma_type_header ) ));
    assert_eq! (::core::mem::align_of::<uma_type_header>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( uma_type_header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_type_header ) ) . uth_name as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_type_header ) ,
                "::" , stringify ! ( uth_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_type_header ) ) . uth_align as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_type_header ) ,
                "::" , stringify ! ( uth_align ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_type_header ) ) . uth_size as * const
                _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_type_header ) ,
                "::" , stringify ! ( uth_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_type_header ) ) . uth_rsize as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_type_header ) ,
                "::" , stringify ! ( uth_rsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_type_header ) ) . uth_maxpages as *
                const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_type_header ) ,
                "::" , stringify ! ( uth_maxpages ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_type_header ) ) . uth_limit as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_type_header ) ,
                "::" , stringify ! ( uth_limit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_type_header ) ) . uth_pages as *
                const _ as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_type_header ) ,
                "::" , stringify ! ( uth_pages ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_type_header ) ) . uth_keg_free as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_type_header ) ,
                "::" , stringify ! ( uth_keg_free ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_type_header ) ) . uth_zone_free as *
                const _ as usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_type_header ) ,
                "::" , stringify ! ( uth_zone_free ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_type_header ) ) . uth_bucketsize as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_type_header ) ,
                "::" , stringify ! ( uth_bucketsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_type_header ) ) . uth_zone_flags as *
                const _ as usize } , 68usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_type_header ) ,
                "::" , stringify ! ( uth_zone_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_type_header ) ) . uth_allocs as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_type_header ) ,
                "::" , stringify ! ( uth_allocs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_type_header ) ) . uth_frees as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_type_header ) ,
                "::" , stringify ! ( uth_frees ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_type_header ) ) . uth_fails as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_type_header ) ,
                "::" , stringify ! ( uth_fails ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_type_header ) ) . uth_sleeps as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_type_header ) ,
                "::" , stringify ! ( uth_sleeps ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_type_header ) ) . _uth_reserved1 as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_type_header ) ,
                "::" , stringify ! ( _uth_reserved1 ) ));
}
impl Clone for uma_type_header {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct uma_percpu_stat {
    pub ups_allocs: u64,
    pub ups_frees: u64,
    pub ups_cache_free: u64,
    pub _ups_reserved: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_uma_percpu_stat() {
    assert_eq!(::core::mem::size_of::<uma_percpu_stat>() , 64usize , concat !
               ( "Size of: " , stringify ! ( uma_percpu_stat ) ));
    assert_eq! (::core::mem::align_of::<uma_percpu_stat>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( uma_percpu_stat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_percpu_stat ) ) . ups_allocs as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_percpu_stat ) ,
                "::" , stringify ! ( ups_allocs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_percpu_stat ) ) . ups_frees as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_percpu_stat ) ,
                "::" , stringify ! ( ups_frees ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_percpu_stat ) ) . ups_cache_free as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_percpu_stat ) ,
                "::" , stringify ! ( ups_cache_free ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const uma_percpu_stat ) ) . _ups_reserved as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( uma_percpu_stat ) ,
                "::" , stringify ! ( _ups_reserved ) ));
}
impl Clone for uma_percpu_stat {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn uma_reclaim_wakeup();
}
extern "C" {
    pub fn uma_reclaim_worker(arg1: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn uma_limit() -> ::kernel::sys::raw::c_ulong;
}
extern "C" {
    pub fn uma_size() -> ::kernel::sys::raw::c_ulong;
}
extern "C" {
    pub fn uma_avail() -> ::kernel::sys::raw::c_long;
}
#[repr(C)]
pub struct mbuf {
    pub __bindgen_anon_1: mbuf__bindgen_ty_1,
    pub __bindgen_anon_2: mbuf__bindgen_ty_2,
    pub m_data: caddr_t,
    pub m_len: i32,
    pub _bitfield_1: u32,
    pub __bindgen_anon_3: mbuf__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy)]
pub union mbuf__bindgen_ty_1 {
    pub m_next: *mut mbuf,
    pub m_slist: mbuf__bindgen_ty_1__bindgen_ty_1,
    pub m_stailq: mbuf__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mbuf__bindgen_ty_1__bindgen_ty_1 {
    pub sle_next: *mut mbuf,
}
#[test]
fn bindgen_test_layout_mbuf__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<mbuf__bindgen_ty_1__bindgen_ty_1>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( mbuf__bindgen_ty_1__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<mbuf__bindgen_ty_1__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                mbuf__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbuf__bindgen_ty_1__bindgen_ty_1 ) ) .
                sle_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                mbuf__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! (
                sle_next ) ));
}
impl Clone for mbuf__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for mbuf__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mbuf__bindgen_ty_1__bindgen_ty_2 {
    pub stqe_next: *mut mbuf,
}
#[test]
fn bindgen_test_layout_mbuf__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<mbuf__bindgen_ty_1__bindgen_ty_2>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( mbuf__bindgen_ty_1__bindgen_ty_2 )
               ));
    assert_eq! (::core::mem::align_of::<mbuf__bindgen_ty_1__bindgen_ty_2>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                mbuf__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbuf__bindgen_ty_1__bindgen_ty_2 ) ) .
                stqe_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                mbuf__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify ! (
                stqe_next ) ));
}
impl Clone for mbuf__bindgen_ty_1__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for mbuf__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_mbuf__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<mbuf__bindgen_ty_1>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( mbuf__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<mbuf__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( mbuf__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbuf__bindgen_ty_1 ) ) . m_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mbuf__bindgen_ty_1 ) ,
                "::" , stringify ! ( m_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbuf__bindgen_ty_1 ) ) . m_slist as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mbuf__bindgen_ty_1 ) ,
                "::" , stringify ! ( m_slist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbuf__bindgen_ty_1 ) ) . m_stailq as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mbuf__bindgen_ty_1 ) ,
                "::" , stringify ! ( m_stailq ) ));
}
impl Clone for mbuf__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for mbuf__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for mbuf__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "mbuf__bindgen_ty_1 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy)]
pub union mbuf__bindgen_ty_2 {
    pub m_nextpkt: *mut mbuf,
    pub m_slistpkt: mbuf__bindgen_ty_2__bindgen_ty_1,
    pub m_stailqpkt: mbuf__bindgen_ty_2__bindgen_ty_2,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mbuf__bindgen_ty_2__bindgen_ty_1 {
    pub sle_next: *mut mbuf,
}
#[test]
fn bindgen_test_layout_mbuf__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<mbuf__bindgen_ty_2__bindgen_ty_1>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( mbuf__bindgen_ty_2__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<mbuf__bindgen_ty_2__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                mbuf__bindgen_ty_2__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbuf__bindgen_ty_2__bindgen_ty_1 ) ) .
                sle_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                mbuf__bindgen_ty_2__bindgen_ty_1 ) , "::" , stringify ! (
                sle_next ) ));
}
impl Clone for mbuf__bindgen_ty_2__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for mbuf__bindgen_ty_2__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mbuf__bindgen_ty_2__bindgen_ty_2 {
    pub stqe_next: *mut mbuf,
}
#[test]
fn bindgen_test_layout_mbuf__bindgen_ty_2__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<mbuf__bindgen_ty_2__bindgen_ty_2>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( mbuf__bindgen_ty_2__bindgen_ty_2 )
               ));
    assert_eq! (::core::mem::align_of::<mbuf__bindgen_ty_2__bindgen_ty_2>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                mbuf__bindgen_ty_2__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbuf__bindgen_ty_2__bindgen_ty_2 ) ) .
                stqe_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                mbuf__bindgen_ty_2__bindgen_ty_2 ) , "::" , stringify ! (
                stqe_next ) ));
}
impl Clone for mbuf__bindgen_ty_2__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for mbuf__bindgen_ty_2__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_mbuf__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<mbuf__bindgen_ty_2>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( mbuf__bindgen_ty_2 ) ));
    assert_eq! (::core::mem::align_of::<mbuf__bindgen_ty_2>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( mbuf__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbuf__bindgen_ty_2 ) ) . m_nextpkt as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mbuf__bindgen_ty_2 ) ,
                "::" , stringify ! ( m_nextpkt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbuf__bindgen_ty_2 ) ) . m_slistpkt as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mbuf__bindgen_ty_2 ) ,
                "::" , stringify ! ( m_slistpkt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbuf__bindgen_ty_2 ) ) . m_stailqpkt as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mbuf__bindgen_ty_2 ) ,
                "::" , stringify ! ( m_stailqpkt ) ));
}
impl Clone for mbuf__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for mbuf__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for mbuf__bindgen_ty_2 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "mbuf__bindgen_ty_2 {{ union }}")
    }
}
#[repr(C)]
pub struct mbuf__bindgen_ty_3 {
    pub __bindgen_anon_1: __BindgenUnionField<mbuf__bindgen_ty_3__bindgen_ty_1>,
    pub m_dat: __BindgenUnionField<[::kernel::sys::raw::c_char; 0usize]>,
    pub bindgen_union_field: [u64; 13usize],
}
#[repr(C)]
pub struct mbuf__bindgen_ty_3__bindgen_ty_1 {
    pub m_pkthdr: pkthdr,
    pub __bindgen_anon_1: mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
pub struct mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {
    pub m_ext: __BindgenUnionField<m_ext>,
    pub m_pktdat: __BindgenUnionField<[::kernel::sys::raw::c_char; 0usize]>,
    pub bindgen_union_field: [u64; 6usize],
}
#[test]
fn bindgen_test_layout_mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1>()
               , 48usize , concat ! (
               "Size of: " , stringify ! (
               mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 )
                ) . m_ext as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( m_ext ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 )
                ) . m_pktdat as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( m_pktdat ) ));
}
impl Default for mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "mbuf__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_mbuf__bindgen_ty_3__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<mbuf__bindgen_ty_3__bindgen_ty_1>() ,
               104usize , concat ! (
               "Size of: " , stringify ! ( mbuf__bindgen_ty_3__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<mbuf__bindgen_ty_3__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                mbuf__bindgen_ty_3__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbuf__bindgen_ty_3__bindgen_ty_1 ) ) .
                m_pkthdr as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                mbuf__bindgen_ty_3__bindgen_ty_1 ) , "::" , stringify ! (
                m_pkthdr ) ));
}
impl Default for mbuf__bindgen_ty_3__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for mbuf__bindgen_ty_3__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "mbuf__bindgen_ty_3__bindgen_ty_1 {{ m_pkthdr: {:?} }}" ,
               self . m_pkthdr)
    }
}
#[test]
fn bindgen_test_layout_mbuf__bindgen_ty_3() {
    assert_eq!(::core::mem::size_of::<mbuf__bindgen_ty_3>() , 104usize ,
               concat ! ( "Size of: " , stringify ! ( mbuf__bindgen_ty_3 ) ));
    assert_eq! (::core::mem::align_of::<mbuf__bindgen_ty_3>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( mbuf__bindgen_ty_3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbuf__bindgen_ty_3 ) ) . m_dat as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mbuf__bindgen_ty_3 ) ,
                "::" , stringify ! ( m_dat ) ));
}
impl Default for mbuf__bindgen_ty_3 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for mbuf__bindgen_ty_3 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "mbuf__bindgen_ty_3 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_mbuf() {
    assert_eq!(::core::mem::size_of::<mbuf>() , 136usize , concat ! (
               "Size of: " , stringify ! ( mbuf ) ));
    assert_eq! (::core::mem::align_of::<mbuf>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( mbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbuf ) ) . m_data as * const _ as usize }
                , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mbuf ) , "::" ,
                stringify ! ( m_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbuf ) ) . m_len as * const _ as usize }
                , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( mbuf ) , "::" ,
                stringify ! ( m_len ) ));
}
impl Default for mbuf {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for mbuf {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "mbuf {{ m_data: {:?}, m_len: {:?}, m_type : {:?}, m_flags : {:?} }}"
               , self . m_data , self . m_len , self . m_type (  ) , self .
               m_flags (  ))
    }
}
impl mbuf {
    #[inline]
    pub fn m_type(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u32
                                                 as *mut u8,
                                             ::core::mem::size_of::<u32>())
        };
        let mask = 255u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::core::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_m_type(&mut self, val: u32) {
        let mask = 255u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u32
                                                 as *mut u8,
                                             ::core::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn m_flags(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u32
                                                 as *mut u8,
                                             ::core::mem::size_of::<u32>())
        };
        let mask = 4294967040u64 as u32;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::core::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_m_flags(&mut self, val: u32) {
        let mask = 4294967040u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u32
                                                 as *mut u8,
                                             ::core::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(m_type: u32, m_flags: u32) -> u32 {
        ({ ({ 0 } | ((m_type as u32 as u32) << 0usize) & (255u64 as u32)) } |
             ((m_flags as u32 as u32) << 8usize) & (4294967040u64 as u32))
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct mb_args {
    pub flags: ::kernel::sys::raw::c_int,
    pub type_: ::kernel::sys::raw::c_short,
}
#[test]
fn bindgen_test_layout_mb_args() {
    assert_eq!(::core::mem::size_of::<mb_args>() , 8usize , concat ! (
               "Size of: " , stringify ! ( mb_args ) ));
    assert_eq! (::core::mem::align_of::<mb_args>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( mb_args ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mb_args ) ) . flags as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mb_args ) , "::" ,
                stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mb_args ) ) . type_ as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( mb_args ) , "::" ,
                stringify ! ( type_ ) ));
}
impl Clone for mb_args {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct m_tag {
    pub m_tag_link: m_tag__bindgen_ty_1,
    pub m_tag_id: u_int16_t,
    pub m_tag_len: u_int16_t,
    pub m_tag_cookie: u_int32_t,
    pub m_tag_free: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                    *mut m_tag)>,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct m_tag__bindgen_ty_1 {
    pub sle_next: *mut m_tag,
}
#[test]
fn bindgen_test_layout_m_tag__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<m_tag__bindgen_ty_1>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( m_tag__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<m_tag__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( m_tag__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const m_tag__bindgen_ty_1 ) ) . sle_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( m_tag__bindgen_ty_1 ) ,
                "::" , stringify ! ( sle_next ) ));
}
impl Clone for m_tag__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for m_tag__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_m_tag() {
    assert_eq!(::core::mem::size_of::<m_tag>() , 24usize , concat ! (
               "Size of: " , stringify ! ( m_tag ) ));
    assert_eq! (::core::mem::align_of::<m_tag>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( m_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const m_tag ) ) . m_tag_link as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( m_tag ) , "::" ,
                stringify ! ( m_tag_link ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const m_tag ) ) . m_tag_id as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( m_tag ) , "::" ,
                stringify ! ( m_tag_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const m_tag ) ) . m_tag_len as * const _ as
                usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( m_tag ) , "::" ,
                stringify ! ( m_tag_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const m_tag ) ) . m_tag_cookie as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( m_tag ) , "::" ,
                stringify ! ( m_tag_cookie ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const m_tag ) ) . m_tag_free as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( m_tag ) , "::" ,
                stringify ! ( m_tag_free ) ));
}
impl Clone for m_tag {
    fn clone(&self) -> Self { *self }
}
impl Default for m_tag {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct m_snd_tag {
    pub ifp: *mut ifnet,
}
#[test]
fn bindgen_test_layout_m_snd_tag() {
    assert_eq!(::core::mem::size_of::<m_snd_tag>() , 8usize , concat ! (
               "Size of: " , stringify ! ( m_snd_tag ) ));
    assert_eq! (::core::mem::align_of::<m_snd_tag>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( m_snd_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const m_snd_tag ) ) . ifp as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( m_snd_tag ) , "::" ,
                stringify ! ( ifp ) ));
}
impl Clone for m_snd_tag {
    fn clone(&self) -> Self { *self }
}
impl Default for m_snd_tag {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct pkthdr {
    pub __bindgen_anon_1: pkthdr__bindgen_ty_1,
    pub tags: pkthdr_packet_tags,
    pub len: i32,
    pub flowid: u32,
    pub csum_flags: u32,
    pub fibnum: u16,
    pub cosqos: u8,
    pub rsstype: u8,
    pub __bindgen_anon_2: pkthdr__bindgen_ty_2,
    pub PH_per: pkthdr__bindgen_ty_3,
    pub PH_loc: pkthdr__bindgen_ty_4,
}
#[repr(C)]
#[derive(Copy)]
pub union pkthdr__bindgen_ty_1 {
    pub snd_tag: *mut m_snd_tag,
    pub rcvif: *mut ifnet,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_pkthdr__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<pkthdr__bindgen_ty_1>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( pkthdr__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<pkthdr__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( pkthdr__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_1 ) ) . snd_tag as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr__bindgen_ty_1 )
                , "::" , stringify ! ( snd_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_1 ) ) . rcvif as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr__bindgen_ty_1 )
                , "::" , stringify ! ( rcvif ) ));
}
impl Clone for pkthdr__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for pkthdr__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for pkthdr__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "pkthdr__bindgen_ty_1 {{ union }}")
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pkthdr_packet_tags {
    pub slh_first: *mut m_tag,
}
#[test]
fn bindgen_test_layout_pkthdr_packet_tags() {
    assert_eq!(::core::mem::size_of::<pkthdr_packet_tags>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( pkthdr_packet_tags ) ));
    assert_eq! (::core::mem::align_of::<pkthdr_packet_tags>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( pkthdr_packet_tags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr_packet_tags ) ) . slh_first as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr_packet_tags ) ,
                "::" , stringify ! ( slh_first ) ));
}
impl Clone for pkthdr_packet_tags {
    fn clone(&self) -> Self { *self }
}
impl Default for pkthdr_packet_tags {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub union pkthdr__bindgen_ty_2 {
    pub rcv_tstmp: u64,
    pub __bindgen_anon_1: pkthdr__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct pkthdr__bindgen_ty_2__bindgen_ty_1 {
    pub l2hlen: u8,
    pub l3hlen: u8,
    pub l4hlen: u8,
    pub l5hlen: u8,
    pub spare: u32,
}
#[test]
fn bindgen_test_layout_pkthdr__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<pkthdr__bindgen_ty_2__bindgen_ty_1>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( pkthdr__bindgen_ty_2__bindgen_ty_1
               ) ));
    assert_eq! (::core::mem::align_of::<pkthdr__bindgen_ty_2__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                pkthdr__bindgen_ty_2__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_2__bindgen_ty_1 ) ) .
                l2hlen as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pkthdr__bindgen_ty_2__bindgen_ty_1 ) , "::" , stringify ! (
                l2hlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_2__bindgen_ty_1 ) ) .
                l3hlen as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                pkthdr__bindgen_ty_2__bindgen_ty_1 ) , "::" , stringify ! (
                l3hlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_2__bindgen_ty_1 ) ) .
                l4hlen as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                pkthdr__bindgen_ty_2__bindgen_ty_1 ) , "::" , stringify ! (
                l4hlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_2__bindgen_ty_1 ) ) .
                l5hlen as * const _ as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! (
                pkthdr__bindgen_ty_2__bindgen_ty_1 ) , "::" , stringify ! (
                l5hlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_2__bindgen_ty_1 ) ) .
                spare as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                pkthdr__bindgen_ty_2__bindgen_ty_1 ) , "::" , stringify ! (
                spare ) ));
}
impl Clone for pkthdr__bindgen_ty_2__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_pkthdr__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<pkthdr__bindgen_ty_2>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( pkthdr__bindgen_ty_2 )
               ));
    assert_eq! (::core::mem::align_of::<pkthdr__bindgen_ty_2>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( pkthdr__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_2 ) ) . rcv_tstmp as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr__bindgen_ty_2 )
                , "::" , stringify ! ( rcv_tstmp ) ));
}
impl Clone for pkthdr__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for pkthdr__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for pkthdr__bindgen_ty_2 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "pkthdr__bindgen_ty_2 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy)]
pub union pkthdr__bindgen_ty_3 {
    pub eight: [u8; 8usize],
    pub sixteen: [u16; 4usize],
    pub thirtytwo: [u32; 2usize],
    pub sixtyfour: [u64; 1usize],
    pub unintptr: [usize; 1usize],
    pub ptr: *mut ::kernel::sys::raw::c_void,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_pkthdr__bindgen_ty_3() {
    assert_eq!(::core::mem::size_of::<pkthdr__bindgen_ty_3>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( pkthdr__bindgen_ty_3 )
               ));
    assert_eq! (::core::mem::align_of::<pkthdr__bindgen_ty_3>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( pkthdr__bindgen_ty_3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_3 ) ) . eight as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr__bindgen_ty_3 )
                , "::" , stringify ! ( eight ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_3 ) ) . sixteen as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr__bindgen_ty_3 )
                , "::" , stringify ! ( sixteen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_3 ) ) . thirtytwo as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr__bindgen_ty_3 )
                , "::" , stringify ! ( thirtytwo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_3 ) ) . sixtyfour as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr__bindgen_ty_3 )
                , "::" , stringify ! ( sixtyfour ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_3 ) ) . unintptr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr__bindgen_ty_3 )
                , "::" , stringify ! ( unintptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_3 ) ) . ptr as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr__bindgen_ty_3 )
                , "::" , stringify ! ( ptr ) ));
}
impl Clone for pkthdr__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
impl Default for pkthdr__bindgen_ty_3 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for pkthdr__bindgen_ty_3 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "pkthdr__bindgen_ty_3 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy)]
pub union pkthdr__bindgen_ty_4 {
    pub eight: [u8; 8usize],
    pub sixteen: [u16; 4usize],
    pub thirtytwo: [u32; 2usize],
    pub sixtyfour: [u64; 1usize],
    pub unintptr: [usize; 1usize],
    pub ptr: *mut ::kernel::sys::raw::c_void,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_pkthdr__bindgen_ty_4() {
    assert_eq!(::core::mem::size_of::<pkthdr__bindgen_ty_4>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( pkthdr__bindgen_ty_4 )
               ));
    assert_eq! (::core::mem::align_of::<pkthdr__bindgen_ty_4>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( pkthdr__bindgen_ty_4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_4 ) ) . eight as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr__bindgen_ty_4 )
                , "::" , stringify ! ( eight ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_4 ) ) . sixteen as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr__bindgen_ty_4 )
                , "::" , stringify ! ( sixteen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_4 ) ) . thirtytwo as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr__bindgen_ty_4 )
                , "::" , stringify ! ( thirtytwo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_4 ) ) . sixtyfour as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr__bindgen_ty_4 )
                , "::" , stringify ! ( sixtyfour ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_4 ) ) . unintptr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr__bindgen_ty_4 )
                , "::" , stringify ! ( unintptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr__bindgen_ty_4 ) ) . ptr as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr__bindgen_ty_4 )
                , "::" , stringify ! ( ptr ) ));
}
impl Clone for pkthdr__bindgen_ty_4 {
    fn clone(&self) -> Self { *self }
}
impl Default for pkthdr__bindgen_ty_4 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for pkthdr__bindgen_ty_4 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "pkthdr__bindgen_ty_4 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_pkthdr() {
    assert_eq!(::core::mem::size_of::<pkthdr>() , 56usize , concat ! (
               "Size of: " , stringify ! ( pkthdr ) ));
    assert_eq! (::core::mem::align_of::<pkthdr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pkthdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr ) ) . tags as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr ) , "::" ,
                stringify ! ( tags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr ) ) . len as * const _ as usize }
                , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr ) , "::" ,
                stringify ! ( len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr ) ) . flowid as * const _ as usize
                } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr ) , "::" ,
                stringify ! ( flowid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr ) ) . csum_flags as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr ) , "::" ,
                stringify ! ( csum_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr ) ) . fibnum as * const _ as usize
                } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr ) , "::" ,
                stringify ! ( fibnum ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr ) ) . cosqos as * const _ as usize
                } , 30usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr ) , "::" ,
                stringify ! ( cosqos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr ) ) . rsstype as * const _ as
                usize } , 31usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr ) , "::" ,
                stringify ! ( rsstype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr ) ) . PH_per as * const _ as usize
                } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr ) , "::" ,
                stringify ! ( PH_per ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pkthdr ) ) . PH_loc as * const _ as usize
                } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( pkthdr ) , "::" ,
                stringify ! ( PH_loc ) ));
}
impl Clone for pkthdr {
    fn clone(&self) -> Self { *self }
}
impl Default for pkthdr {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for pkthdr {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "pkthdr {{ tags: {:?}, len: {:?}, flowid: {:?}, csum_flags: {:?}, fibnum: {:?}, cosqos: {:?}, rsstype: {:?}, PH_per: {:?}, PH_loc: {:?} }}"
               , self . tags , self . len , self . flowid , self . csum_flags
               , self . fibnum , self . cosqos , self . rsstype , self .
               PH_per , self . PH_loc)
    }
}
pub type m_ext_free_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut mbuf)>;
#[repr(C)]
#[derive(Copy)]
pub struct m_ext {
    pub __bindgen_anon_1: m_ext__bindgen_ty_1,
    pub ext_buf: *mut ::kernel::sys::raw::c_char,
    pub ext_size: u32,
    pub _bitfield_1: u32,
    pub ext_free: m_ext_free_t,
    pub ext_arg1: *mut ::kernel::sys::raw::c_void,
    pub ext_arg2: *mut ::kernel::sys::raw::c_void,
}
#[repr(C)]
#[derive(Copy)]
pub union m_ext__bindgen_ty_1 {
    pub ext_count: u_int,
    pub ext_cnt: *mut u_int,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_m_ext__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<m_ext__bindgen_ty_1>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( m_ext__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<m_ext__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( m_ext__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const m_ext__bindgen_ty_1 ) ) . ext_count as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( m_ext__bindgen_ty_1 ) ,
                "::" , stringify ! ( ext_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const m_ext__bindgen_ty_1 ) ) . ext_cnt as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( m_ext__bindgen_ty_1 ) ,
                "::" , stringify ! ( ext_cnt ) ));
}
impl Clone for m_ext__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for m_ext__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for m_ext__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "m_ext__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_m_ext() {
    assert_eq!(::core::mem::size_of::<m_ext>() , 48usize , concat ! (
               "Size of: " , stringify ! ( m_ext ) ));
    assert_eq! (::core::mem::align_of::<m_ext>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( m_ext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const m_ext ) ) . ext_buf as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( m_ext ) , "::" ,
                stringify ! ( ext_buf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const m_ext ) ) . ext_size as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( m_ext ) , "::" ,
                stringify ! ( ext_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const m_ext ) ) . ext_free as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( m_ext ) , "::" ,
                stringify ! ( ext_free ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const m_ext ) ) . ext_arg1 as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( m_ext ) , "::" ,
                stringify ! ( ext_arg1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const m_ext ) ) . ext_arg2 as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( m_ext ) , "::" ,
                stringify ! ( ext_arg2 ) ));
}
impl Clone for m_ext {
    fn clone(&self) -> Self { *self }
}
impl Default for m_ext {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for m_ext {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "m_ext {{ ext_buf: {:?}, ext_size: {:?}, ext_type : {:?}, ext_flags : {:?}, ext_free: {:?}, ext_arg1: {:?}, ext_arg2: {:?} }}"
               , self . ext_buf , self . ext_size , self . ext_type (  ) ,
               self . ext_flags (  ) , self . ext_free , self . ext_arg1 ,
               self . ext_arg2)
    }
}
impl m_ext {
    #[inline]
    pub fn ext_type(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u32
                                                 as *mut u8,
                                             ::core::mem::size_of::<u32>())
        };
        let mask = 255u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::core::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_ext_type(&mut self, val: u32) {
        let mask = 255u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u32
                                                 as *mut u8,
                                             ::core::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn ext_flags(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u32
                                                 as *mut u8,
                                             ::core::mem::size_of::<u32>())
        };
        let mask = 4294967040u64 as u32;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::core::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_ext_flags(&mut self, val: u32) {
        let mask = 4294967040u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u32
                                                 as *mut u8,
                                             ::core::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(ext_type: u32, ext_flags: u32) -> u32 {
        ({ ({ 0 } | ((ext_type as u32 as u32) << 0usize) & (255u64 as u32)) }
             | ((ext_flags as u32 as u32) << 8usize) & (4294967040u64 as u32))
    }
}
extern "C" {
    #[link_name = "zone_mbuf"]
    pub static mut zone_mbuf: uma_zone_t;
}
extern "C" {
    #[link_name = "zone_clust"]
    pub static mut zone_clust: uma_zone_t;
}
extern "C" {
    #[link_name = "zone_pack"]
    pub static mut zone_pack: uma_zone_t;
}
extern "C" {
    #[link_name = "zone_jumbop"]
    pub static mut zone_jumbop: uma_zone_t;
}
extern "C" {
    #[link_name = "zone_jumbo9"]
    pub static mut zone_jumbo9: uma_zone_t;
}
extern "C" {
    #[link_name = "zone_jumbo16"]
    pub static mut zone_jumbo16: uma_zone_t;
}
extern "C" {
    pub fn mb_dupcl(arg1: *mut mbuf, arg2: *mut mbuf);
}
extern "C" {
    pub fn mb_free_ext(arg1: *mut mbuf);
}
extern "C" {
    pub fn m_adj(arg1: *mut mbuf, arg2: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn m_apply(arg1: *mut mbuf, arg2: ::kernel::sys::raw::c_int,
                   arg3: ::kernel::sys::raw::c_int,
                   arg4:
                       ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                       *mut ::kernel::sys::raw::c_void,
                                                                   arg2:
                                                                       *mut ::kernel::sys::raw::c_void,
                                                                   arg3:
                                                                       u_int)
                                                  ->
                                                      ::kernel::sys::raw::c_int>,
                   arg5: *mut ::kernel::sys::raw::c_void)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn m_append(arg1: *mut mbuf, arg2: ::kernel::sys::raw::c_int,
                    arg3: c_caddr_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn m_cat(arg1: *mut mbuf, arg2: *mut mbuf);
}
extern "C" {
    pub fn m_catpkt(arg1: *mut mbuf, arg2: *mut mbuf);
}
extern "C" {
    pub fn m_clget(m: *mut mbuf, how: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn m_cljget(m: *mut mbuf, how: ::kernel::sys::raw::c_int,
                    size: ::kernel::sys::raw::c_int)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn m_collapse(arg1: *mut mbuf, arg2: ::kernel::sys::raw::c_int,
                      arg3: ::kernel::sys::raw::c_int) -> *mut mbuf;
}
extern "C" {
    pub fn m_copyback(arg1: *mut mbuf, arg2: ::kernel::sys::raw::c_int,
                      arg3: ::kernel::sys::raw::c_int, arg4: c_caddr_t);
}
extern "C" {
    pub fn m_copydata(arg1: *const mbuf, arg2: ::kernel::sys::raw::c_int,
                      arg3: ::kernel::sys::raw::c_int, arg4: caddr_t);
}
extern "C" {
    pub fn m_copym(arg1: *mut mbuf, arg2: ::kernel::sys::raw::c_int,
                   arg3: ::kernel::sys::raw::c_int,
                   arg4: ::kernel::sys::raw::c_int) -> *mut mbuf;
}
extern "C" {
    pub fn m_copypacket(arg1: *mut mbuf, arg2: ::kernel::sys::raw::c_int)
     -> *mut mbuf;
}
extern "C" {
    pub fn m_copy_pkthdr(arg1: *mut mbuf, arg2: *mut mbuf);
}
extern "C" {
    pub fn m_copyup(arg1: *mut mbuf, arg2: ::kernel::sys::raw::c_int,
                    arg3: ::kernel::sys::raw::c_int) -> *mut mbuf;
}
extern "C" {
    pub fn m_defrag(arg1: *mut mbuf, arg2: ::kernel::sys::raw::c_int)
     -> *mut mbuf;
}
extern "C" {
    pub fn m_demote_pkthdr(arg1: *mut mbuf);
}
extern "C" {
    pub fn m_demote(arg1: *mut mbuf, arg2: ::kernel::sys::raw::c_int,
                    arg3: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn m_devget(arg1: *mut ::kernel::sys::raw::c_char,
                    arg2: ::kernel::sys::raw::c_int,
                    arg3: ::kernel::sys::raw::c_int, arg4: *mut ifnet,
                    arg5:
                        ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                        *mut ::kernel::sys::raw::c_char,
                                                                    arg2:
                                                                        caddr_t,
                                                                    arg3:
                                                                        u_int)>)
     -> *mut mbuf;
}
extern "C" {
    pub fn m_dup(arg1: *const mbuf, arg2: ::kernel::sys::raw::c_int)
     -> *mut mbuf;
}
extern "C" {
    pub fn m_dup_pkthdr(arg1: *mut mbuf, arg2: *const mbuf,
                        arg3: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn m_extadd(arg1: *mut mbuf, arg2: *mut ::kernel::sys::raw::c_char,
                    arg3: u_int, arg4: m_ext_free_t,
                    arg5: *mut ::kernel::sys::raw::c_void,
                    arg6: *mut ::kernel::sys::raw::c_void,
                    arg7: ::kernel::sys::raw::c_int,
                    arg8: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn m_fixhdr(arg1: *mut mbuf) -> u_int;
}
extern "C" {
    pub fn m_fragment(arg1: *mut mbuf, arg2: ::kernel::sys::raw::c_int,
                      arg3: ::kernel::sys::raw::c_int) -> *mut mbuf;
}
extern "C" {
    pub fn m_freem(arg1: *mut mbuf);
}
extern "C" {
    pub fn m_get2(arg1: ::kernel::sys::raw::c_int,
                  arg2: ::kernel::sys::raw::c_int,
                  arg3: ::kernel::sys::raw::c_short,
                  arg4: ::kernel::sys::raw::c_int) -> *mut mbuf;
}
extern "C" {
    pub fn m_getjcl(arg1: ::kernel::sys::raw::c_int,
                    arg2: ::kernel::sys::raw::c_short,
                    arg3: ::kernel::sys::raw::c_int,
                    arg4: ::kernel::sys::raw::c_int) -> *mut mbuf;
}
extern "C" {
    pub fn m_getm2(arg1: *mut mbuf, arg2: ::kernel::sys::raw::c_int,
                   arg3: ::kernel::sys::raw::c_int,
                   arg4: ::kernel::sys::raw::c_short,
                   arg5: ::kernel::sys::raw::c_int) -> *mut mbuf;
}
extern "C" {
    pub fn m_getptr(arg1: *mut mbuf, arg2: ::kernel::sys::raw::c_int,
                    arg3: *mut ::kernel::sys::raw::c_int) -> *mut mbuf;
}
extern "C" {
    pub fn m_length(arg1: *mut mbuf, arg2: *mut *mut mbuf) -> u_int;
}
extern "C" {
    pub fn m_mbuftouio(arg1: *mut uio, arg2: *const mbuf,
                       arg3: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn m_move_pkthdr(arg1: *mut mbuf, arg2: *mut mbuf);
}
extern "C" {
    pub fn m_pkthdr_init(arg1: *mut mbuf, arg2: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn m_prepend(arg1: *mut mbuf, arg2: ::kernel::sys::raw::c_int,
                     arg3: ::kernel::sys::raw::c_int) -> *mut mbuf;
}
extern "C" {
    pub fn m_print(arg1: *const mbuf, arg2: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn m_pulldown(arg1: *mut mbuf, arg2: ::kernel::sys::raw::c_int,
                      arg3: ::kernel::sys::raw::c_int,
                      arg4: *mut ::kernel::sys::raw::c_int) -> *mut mbuf;
}
extern "C" {
    pub fn m_pullup(arg1: *mut mbuf, arg2: ::kernel::sys::raw::c_int)
     -> *mut mbuf;
}
extern "C" {
    pub fn m_sanity(arg1: *mut mbuf, arg2: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn m_split(arg1: *mut mbuf, arg2: ::kernel::sys::raw::c_int,
                   arg3: ::kernel::sys::raw::c_int) -> *mut mbuf;
}
extern "C" {
    pub fn m_uiotombuf(arg1: *mut uio, arg2: ::kernel::sys::raw::c_int,
                       arg3: ::kernel::sys::raw::c_int,
                       arg4: ::kernel::sys::raw::c_int,
                       arg5: ::kernel::sys::raw::c_int) -> *mut mbuf;
}
extern "C" {
    pub fn m_unshare(arg1: *mut mbuf, arg2: ::kernel::sys::raw::c_int)
     -> *mut mbuf;
}
extern "C" {
    #[link_name = "max_datalen"]
    pub static mut max_datalen: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "max_hdr"]
    pub static mut max_hdr: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "max_linkhdr"]
    pub static mut max_linkhdr: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "max_protohdr"]
    pub static mut max_protohdr: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "nmbclusters"]
    pub static mut nmbclusters: ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn m_tag_alloc(arg1: u_int32_t, arg2: ::kernel::sys::raw::c_int,
                       arg3: ::kernel::sys::raw::c_int,
                       arg4: ::kernel::sys::raw::c_int) -> *mut m_tag;
}
extern "C" {
    pub fn m_tag_delete(arg1: *mut mbuf, arg2: *mut m_tag);
}
extern "C" {
    pub fn m_tag_delete_chain(arg1: *mut mbuf, arg2: *mut m_tag);
}
extern "C" {
    pub fn m_tag_free_default(arg1: *mut m_tag);
}
extern "C" {
    pub fn m_tag_locate(arg1: *mut mbuf, arg2: u_int32_t,
                        arg3: ::kernel::sys::raw::c_int, arg4: *mut m_tag)
     -> *mut m_tag;
}
extern "C" {
    pub fn m_tag_copy(arg1: *mut m_tag, arg2: ::kernel::sys::raw::c_int)
     -> *mut m_tag;
}
extern "C" {
    pub fn m_tag_copy_chain(arg1: *mut mbuf, arg2: *const mbuf,
                            arg3: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn m_tag_delete_nonpersistent(arg1: *mut mbuf);
}
extern "C" {
    pub fn m_ether_tcpip_hash_init() -> u32;
}
extern "C" {
    pub fn m_ether_tcpip_hash(arg1: u32, arg2: *const mbuf, arg3: u32) -> u32;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mbufq {
    pub mq_head: mbufq__bindgen_ty_1,
    pub mq_len: ::kernel::sys::raw::c_int,
    pub mq_maxlen: ::kernel::sys::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mbufq__bindgen_ty_1 {
    pub stqh_first: *mut mbuf,
    pub stqh_last: *mut *mut mbuf,
}
#[test]
fn bindgen_test_layout_mbufq__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<mbufq__bindgen_ty_1>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( mbufq__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<mbufq__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( mbufq__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbufq__bindgen_ty_1 ) ) . stqh_first as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mbufq__bindgen_ty_1 ) ,
                "::" , stringify ! ( stqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbufq__bindgen_ty_1 ) ) . stqh_last as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mbufq__bindgen_ty_1 ) ,
                "::" , stringify ! ( stqh_last ) ));
}
impl Clone for mbufq__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for mbufq__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_mbufq() {
    assert_eq!(::core::mem::size_of::<mbufq>() , 24usize , concat ! (
               "Size of: " , stringify ! ( mbufq ) ));
    assert_eq! (::core::mem::align_of::<mbufq>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( mbufq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbufq ) ) . mq_head as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mbufq ) , "::" ,
                stringify ! ( mq_head ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbufq ) ) . mq_len as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mbufq ) , "::" ,
                stringify ! ( mq_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mbufq ) ) . mq_maxlen as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( mbufq ) , "::" ,
                stringify ! ( mq_maxlen ) ));
}
impl Clone for mbufq {
    fn clone(&self) -> Self { *self }
}
impl Default for mbufq {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum modeventtype {
    MOD_LOAD = 0,
    MOD_UNLOAD = 1,
    MOD_SHUTDOWN = 2,
    MOD_QUIESCE = 3,
}
pub use self::modeventtype as modeventtype_t;
pub type module_t = *mut module;
pub type modeventhand_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: module_t,
                                                arg2:
                                                    ::kernel::sys::raw::c_int,
                                                arg3:
                                                    *mut ::kernel::sys::raw::c_void)
                               -> ::kernel::sys::raw::c_int>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct moduledata {
    pub name: *const ::kernel::sys::raw::c_char,
    pub evhand: modeventhand_t,
    pub priv_: *mut ::kernel::sys::raw::c_void,
}
#[test]
fn bindgen_test_layout_moduledata() {
    assert_eq!(::core::mem::size_of::<moduledata>() , 24usize , concat ! (
               "Size of: " , stringify ! ( moduledata ) ));
    assert_eq! (::core::mem::align_of::<moduledata>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( moduledata ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const moduledata ) ) . name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( moduledata ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const moduledata ) ) . evhand as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( moduledata ) , "::" ,
                stringify ! ( evhand ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const moduledata ) ) . priv_ as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( moduledata ) , "::" ,
                stringify ! ( priv_ ) ));
}
impl Clone for moduledata {
    fn clone(&self) -> Self { *self }
}
impl Default for moduledata {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type moduledata_t = moduledata;
#[repr(C)]
#[derive(Copy)]
pub union modspecific {
    pub intval: ::kernel::sys::raw::c_int,
    pub uintval: u_int,
    pub longval: ::kernel::sys::raw::c_long,
    pub ulongval: u_long,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_modspecific() {
    assert_eq!(::core::mem::size_of::<modspecific>() , 8usize , concat ! (
               "Size of: " , stringify ! ( modspecific ) ));
    assert_eq! (::core::mem::align_of::<modspecific>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( modspecific ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const modspecific ) ) . intval as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( modspecific ) , "::" ,
                stringify ! ( intval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const modspecific ) ) . uintval as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( modspecific ) , "::" ,
                stringify ! ( uintval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const modspecific ) ) . longval as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( modspecific ) , "::" ,
                stringify ! ( longval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const modspecific ) ) . ulongval as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( modspecific ) , "::" ,
                stringify ! ( ulongval ) ));
}
impl Clone for modspecific {
    fn clone(&self) -> Self { *self }
}
impl Default for modspecific {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for modspecific {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "modspecific {{ union }}")
    }
}
pub type modspecific_t = modspecific;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct mod_depend {
    pub md_ver_minimum: ::kernel::sys::raw::c_int,
    pub md_ver_preferred: ::kernel::sys::raw::c_int,
    pub md_ver_maximum: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_mod_depend() {
    assert_eq!(::core::mem::size_of::<mod_depend>() , 12usize , concat ! (
               "Size of: " , stringify ! ( mod_depend ) ));
    assert_eq! (::core::mem::align_of::<mod_depend>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( mod_depend ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mod_depend ) ) . md_ver_minimum as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mod_depend ) , "::" ,
                stringify ! ( md_ver_minimum ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mod_depend ) ) . md_ver_preferred as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( mod_depend ) , "::" ,
                stringify ! ( md_ver_preferred ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mod_depend ) ) . md_ver_maximum as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mod_depend ) , "::" ,
                stringify ! ( md_ver_maximum ) ));
}
impl Clone for mod_depend {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct mod_version {
    pub mv_version: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_mod_version() {
    assert_eq!(::core::mem::size_of::<mod_version>() , 4usize , concat ! (
               "Size of: " , stringify ! ( mod_version ) ));
    assert_eq! (::core::mem::align_of::<mod_version>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( mod_version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mod_version ) ) . mv_version as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mod_version ) , "::" ,
                stringify ! ( mv_version ) ));
}
impl Clone for mod_version {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mod_metadata {
    pub md_version: ::kernel::sys::raw::c_int,
    pub md_type: ::kernel::sys::raw::c_int,
    pub md_data: *const ::kernel::sys::raw::c_void,
    pub md_cval: *const ::kernel::sys::raw::c_char,
}
#[test]
fn bindgen_test_layout_mod_metadata() {
    assert_eq!(::core::mem::size_of::<mod_metadata>() , 24usize , concat ! (
               "Size of: " , stringify ! ( mod_metadata ) ));
    assert_eq! (::core::mem::align_of::<mod_metadata>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( mod_metadata ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mod_metadata ) ) . md_version as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mod_metadata ) , "::" ,
                stringify ! ( md_version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mod_metadata ) ) . md_type as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( mod_metadata ) , "::" ,
                stringify ! ( md_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mod_metadata ) ) . md_data as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mod_metadata ) , "::" ,
                stringify ! ( md_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mod_metadata ) ) . md_cval as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mod_metadata ) , "::" ,
                stringify ! ( md_cval ) ));
}
impl Clone for mod_metadata {
    fn clone(&self) -> Self { *self }
}
impl Default for mod_metadata {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mod_pnp_match_info {
    pub descr: *const ::kernel::sys::raw::c_char,
    pub bus: *const ::kernel::sys::raw::c_char,
    pub table: *const ::kernel::sys::raw::c_void,
    pub entry_len: ::kernel::sys::raw::c_int,
    pub num_entry: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_mod_pnp_match_info() {
    assert_eq!(::core::mem::size_of::<mod_pnp_match_info>() , 32usize , concat
               ! ( "Size of: " , stringify ! ( mod_pnp_match_info ) ));
    assert_eq! (::core::mem::align_of::<mod_pnp_match_info>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( mod_pnp_match_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mod_pnp_match_info ) ) . descr as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mod_pnp_match_info ) ,
                "::" , stringify ! ( descr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mod_pnp_match_info ) ) . bus as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mod_pnp_match_info ) ,
                "::" , stringify ! ( bus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mod_pnp_match_info ) ) . table as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mod_pnp_match_info ) ,
                "::" , stringify ! ( table ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mod_pnp_match_info ) ) . entry_len as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( mod_pnp_match_info ) ,
                "::" , stringify ! ( entry_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mod_pnp_match_info ) ) . num_entry as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( mod_pnp_match_info ) ,
                "::" , stringify ! ( num_entry ) ));
}
impl Clone for mod_pnp_match_info {
    fn clone(&self) -> Self { *self }
}
impl Default for mod_pnp_match_info {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    #[link_name = "modules_sx"]
    pub static mut modules_sx: sx;
}
extern "C" {
    pub fn module_register_init(arg1: *const ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn module_register(arg1: *const moduledata, arg2: *mut linker_file)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn module_lookupbyname(arg1: *const ::kernel::sys::raw::c_char)
     -> module_t;
}
extern "C" {
    pub fn module_lookupbyid(arg1: ::kernel::sys::raw::c_int) -> module_t;
}
extern "C" {
    pub fn module_quiesce(arg1: module_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn module_reference(arg1: module_t);
}
extern "C" {
    pub fn module_release(arg1: module_t);
}
extern "C" {
    pub fn module_unload(arg1: module_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn module_getid(arg1: module_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn module_getfnext(arg1: module_t) -> module_t;
}
extern "C" {
    pub fn module_getname(arg1: module_t)
     -> *const ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn module_setspecific(arg1: module_t, arg2: *mut modspecific_t);
}
extern "C" {
    pub fn module_file(arg1: module_t) -> *mut linker_file;
}
#[repr(C)]
#[derive(Copy)]
pub struct module_stat {
    pub version: ::kernel::sys::raw::c_int,
    pub name: [::kernel::sys::raw::c_char; 32usize],
    pub refs: ::kernel::sys::raw::c_int,
    pub id: ::kernel::sys::raw::c_int,
    pub data: modspecific_t,
}
#[test]
fn bindgen_test_layout_module_stat() {
    assert_eq!(::core::mem::size_of::<module_stat>() , 56usize , concat ! (
               "Size of: " , stringify ! ( module_stat ) ));
    assert_eq! (::core::mem::align_of::<module_stat>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( module_stat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const module_stat ) ) . version as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( module_stat ) , "::" ,
                stringify ! ( version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const module_stat ) ) . name as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( module_stat ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const module_stat ) ) . refs as * const _ as
                usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( module_stat ) , "::" ,
                stringify ! ( refs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const module_stat ) ) . id as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( module_stat ) , "::" ,
                stringify ! ( id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const module_stat ) ) . data as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( module_stat ) , "::" ,
                stringify ! ( data ) ));
}
impl Clone for module_stat {
    fn clone(&self) -> Self { *self }
}
impl Default for module_stat {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for module_stat {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "module_stat {{ version: {:?}, name: [{}], refs: {:?}, id: {:?}, data: {:?} }}"
               , self . version , self . name . iter (  ) . enumerate (  ) .
               map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ) , self . refs , self . id , self . data)
    }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum rman_type { RMAN_UNINIT = 0, RMAN_GAUGE = 1, RMAN_ARRAY = 2, }
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct u_resource {
    pub r_handle: usize,
    pub r_parent: usize,
    pub r_device: usize,
    pub r_devname: [::kernel::sys::raw::c_char; 32usize],
    pub r_start: rman_res_t,
    pub r_size: rman_res_t,
    pub r_flags: u_int,
}
#[test]
fn bindgen_test_layout_u_resource() {
    assert_eq!(::core::mem::size_of::<u_resource>() , 80usize , concat ! (
               "Size of: " , stringify ! ( u_resource ) ));
    assert_eq! (::core::mem::align_of::<u_resource>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( u_resource ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_resource ) ) . r_handle as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( u_resource ) , "::" ,
                stringify ! ( r_handle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_resource ) ) . r_parent as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( u_resource ) , "::" ,
                stringify ! ( r_parent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_resource ) ) . r_device as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( u_resource ) , "::" ,
                stringify ! ( r_device ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_resource ) ) . r_devname as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( u_resource ) , "::" ,
                stringify ! ( r_devname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_resource ) ) . r_start as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( u_resource ) , "::" ,
                stringify ! ( r_start ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_resource ) ) . r_size as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( u_resource ) , "::" ,
                stringify ! ( r_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_resource ) ) . r_flags as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( u_resource ) , "::" ,
                stringify ! ( r_flags ) ));
}
impl Clone for u_resource {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct u_rman {
    pub rm_handle: usize,
    pub rm_descr: [::kernel::sys::raw::c_char; 32usize],
    pub rm_start: rman_res_t,
    pub rm_size: rman_res_t,
    pub rm_type: rman_type,
}
#[test]
fn bindgen_test_layout_u_rman() {
    assert_eq!(::core::mem::size_of::<u_rman>() , 64usize , concat ! (
               "Size of: " , stringify ! ( u_rman ) ));
    assert_eq! (::core::mem::align_of::<u_rman>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( u_rman ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_rman ) ) . rm_handle as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( u_rman ) , "::" ,
                stringify ! ( rm_handle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_rman ) ) . rm_descr as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( u_rman ) , "::" ,
                stringify ! ( rm_descr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_rman ) ) . rm_start as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( u_rman ) , "::" ,
                stringify ! ( rm_start ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_rman ) ) . rm_size as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( u_rman ) , "::" ,
                stringify ! ( rm_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const u_rman ) ) . rm_type as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( u_rman ) , "::" ,
                stringify ! ( rm_type ) ));
}
impl Clone for u_rman {
    fn clone(&self) -> Self { *self }
}
impl Default for u_rman {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct resource_i {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct resource_head {
    pub tqh_first: *mut resource_i,
    pub tqh_last: *mut *mut resource_i,
}
#[test]
fn bindgen_test_layout_resource_head() {
    assert_eq!(::core::mem::size_of::<resource_head>() , 16usize , concat ! (
               "Size of: " , stringify ! ( resource_head ) ));
    assert_eq! (::core::mem::align_of::<resource_head>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( resource_head ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_head ) ) . tqh_first as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_head ) , "::"
                , stringify ! ( tqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const resource_head ) ) . tqh_last as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( resource_head ) , "::"
                , stringify ! ( tqh_last ) ));
}
impl Clone for resource_head {
    fn clone(&self) -> Self { *self }
}
impl Default for resource_head {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rman {
    pub rm_list: resource_head,
    pub rm_mtx: *mut mtx,
    pub rm_link: rman__bindgen_ty_1,
    pub rm_start: rman_res_t,
    pub rm_end: rman_res_t,
    pub rm_type: rman_type,
    pub rm_descr: *const ::kernel::sys::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rman__bindgen_ty_1 {
    pub tqe_next: *mut rman,
    pub tqe_prev: *mut *mut rman,
}
#[test]
fn bindgen_test_layout_rman__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<rman__bindgen_ty_1>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( rman__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<rman__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( rman__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rman__bindgen_ty_1 ) ) . tqe_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rman__bindgen_ty_1 ) ,
                "::" , stringify ! ( tqe_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rman__bindgen_ty_1 ) ) . tqe_prev as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rman__bindgen_ty_1 ) ,
                "::" , stringify ! ( tqe_prev ) ));
}
impl Clone for rman__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for rman__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_rman() {
    assert_eq!(::core::mem::size_of::<rman>() , 72usize , concat ! (
               "Size of: " , stringify ! ( rman ) ));
    assert_eq! (::core::mem::align_of::<rman>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rman ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rman ) ) . rm_list as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rman ) , "::" ,
                stringify ! ( rm_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rman ) ) . rm_mtx as * const _ as usize }
                , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rman ) , "::" ,
                stringify ! ( rm_mtx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rman ) ) . rm_link as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rman ) , "::" ,
                stringify ! ( rm_link ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rman ) ) . rm_start as * const _ as usize
                } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rman ) , "::" ,
                stringify ! ( rm_start ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rman ) ) . rm_end as * const _ as usize }
                , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( rman ) , "::" ,
                stringify ! ( rm_end ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rman ) ) . rm_type as * const _ as usize
                } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( rman ) , "::" ,
                stringify ! ( rm_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rman ) ) . rm_descr as * const _ as usize
                } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( rman ) , "::" ,
                stringify ! ( rm_descr ) ));
}
impl Clone for rman {
    fn clone(&self) -> Self { *self }
}
impl Default for rman {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rman_head {
    pub tqh_first: *mut rman,
    pub tqh_last: *mut *mut rman,
}
#[test]
fn bindgen_test_layout_rman_head() {
    assert_eq!(::core::mem::size_of::<rman_head>() , 16usize , concat ! (
               "Size of: " , stringify ! ( rman_head ) ));
    assert_eq! (::core::mem::align_of::<rman_head>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rman_head ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rman_head ) ) . tqh_first as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rman_head ) , "::" ,
                stringify ! ( tqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rman_head ) ) . tqh_last as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rman_head ) , "::" ,
                stringify ! ( tqh_last ) ));
}
impl Clone for rman_head {
    fn clone(&self) -> Self { *self }
}
impl Default for rman_head {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    pub fn rman_activate_resource(r: *mut resource)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn rman_adjust_resource(r: *mut resource, start: rman_res_t,
                                end: rman_res_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn rman_first_free_region(rm: *mut rman, start: *mut rman_res_t,
                                  end: *mut rman_res_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn rman_get_bushandle(arg1: *mut resource) -> bus_space_handle_t;
}
extern "C" {
    pub fn rman_get_bustag(arg1: *mut resource) -> bus_space_tag_t;
}
extern "C" {
    pub fn rman_get_end(arg1: *mut resource) -> rman_res_t;
}
extern "C" {
    pub fn rman_get_device(arg1: *mut resource) -> device_t;
}
extern "C" {
    pub fn rman_get_flags(arg1: *mut resource) -> u_int;
}
extern "C" {
    pub fn rman_get_mapping(arg1: *mut resource, arg2: *mut resource_map);
}
extern "C" {
    pub fn rman_get_rid(arg1: *mut resource) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn rman_get_size(arg1: *mut resource) -> rman_res_t;
}
extern "C" {
    pub fn rman_get_start(arg1: *mut resource) -> rman_res_t;
}
extern "C" {
    pub fn rman_get_virtual(arg1: *mut resource)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn rman_deactivate_resource(r: *mut resource)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn rman_fini(rm: *mut rman) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn rman_init(rm: *mut rman) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn rman_init_from_resource(rm: *mut rman, r: *mut resource)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn rman_last_free_region(rm: *mut rman, start: *mut rman_res_t,
                                 end: *mut rman_res_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn rman_make_alignment_flags(size: u32) -> u32;
}
extern "C" {
    pub fn rman_manage_region(rm: *mut rman, start: rman_res_t,
                              end: rman_res_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn rman_is_region_manager(r: *mut resource, rm: *mut rman)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn rman_release_resource(r: *mut resource)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn rman_reserve_resource(rm: *mut rman, start: rman_res_t,
                                 end: rman_res_t, count: rman_res_t,
                                 flags: u_int, dev: device_t)
     -> *mut resource;
}
extern "C" {
    pub fn rman_reserve_resource_bound(rm: *mut rman, start: rman_res_t,
                                       end: rman_res_t, count: rman_res_t,
                                       bound: rman_res_t, flags: u_int,
                                       dev: device_t) -> *mut resource;
}
extern "C" {
    pub fn rman_set_bushandle(_r: *mut resource, _h: bus_space_handle_t);
}
extern "C" {
    pub fn rman_set_bustag(_r: *mut resource, _t: bus_space_tag_t);
}
extern "C" {
    pub fn rman_set_device(_r: *mut resource, _dev: device_t);
}
extern "C" {
    pub fn rman_set_end(_r: *mut resource, _end: rman_res_t);
}
extern "C" {
    pub fn rman_set_mapping(arg1: *mut resource, arg2: *mut resource_map);
}
extern "C" {
    pub fn rman_set_rid(_r: *mut resource, _rid: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn rman_set_start(_r: *mut resource, _start: rman_res_t);
}
extern "C" {
    pub fn rman_set_virtual(_r: *mut resource,
                            _v: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    #[link_name = "rman_head"]
    pub static mut rman_head: rman_head;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct setlist {
    pub lh_first: *mut cpuset,
}
#[test]
fn bindgen_test_layout_setlist() {
    assert_eq!(::core::mem::size_of::<setlist>() , 8usize , concat ! (
               "Size of: " , stringify ! ( setlist ) ));
    assert_eq! (::core::mem::align_of::<setlist>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( setlist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const setlist ) ) . lh_first as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( setlist ) , "::" ,
                stringify ! ( lh_first ) ));
}
impl Clone for setlist {
    fn clone(&self) -> Self { *self }
}
impl Default for setlist {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cpuset {
    pub cs_mask: cpuset_t,
    pub cs_domain: *mut domainset,
    pub cs_ref: u_int,
    pub cs_flags: ::kernel::sys::raw::c_int,
    pub cs_id: cpusetid_t,
    pub cs_parent: *mut cpuset,
    pub cs_link: cpuset__bindgen_ty_1,
    pub cs_siblings: cpuset__bindgen_ty_2,
    pub cs_children: setlist,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cpuset__bindgen_ty_1 {
    pub le_next: *mut cpuset,
    pub le_prev: *mut *mut cpuset,
}
#[test]
fn bindgen_test_layout_cpuset__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<cpuset__bindgen_ty_1>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( cpuset__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<cpuset__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( cpuset__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuset__bindgen_ty_1 ) ) . le_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuset__bindgen_ty_1 )
                , "::" , stringify ! ( le_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuset__bindgen_ty_1 ) ) . le_prev as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuset__bindgen_ty_1 )
                , "::" , stringify ! ( le_prev ) ));
}
impl Clone for cpuset__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for cpuset__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cpuset__bindgen_ty_2 {
    pub le_next: *mut cpuset,
    pub le_prev: *mut *mut cpuset,
}
#[test]
fn bindgen_test_layout_cpuset__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<cpuset__bindgen_ty_2>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( cpuset__bindgen_ty_2 )
               ));
    assert_eq! (::core::mem::align_of::<cpuset__bindgen_ty_2>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( cpuset__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuset__bindgen_ty_2 ) ) . le_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuset__bindgen_ty_2 )
                , "::" , stringify ! ( le_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuset__bindgen_ty_2 ) ) . le_prev as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuset__bindgen_ty_2 )
                , "::" , stringify ! ( le_prev ) ));
}
impl Clone for cpuset__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for cpuset__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_cpuset() {
    assert_eq!(::core::mem::size_of::<cpuset>() , 104usize , concat ! (
               "Size of: " , stringify ! ( cpuset ) ));
    assert_eq! (::core::mem::align_of::<cpuset>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( cpuset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuset ) ) . cs_mask as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuset ) , "::" ,
                stringify ! ( cs_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuset ) ) . cs_domain as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuset ) , "::" ,
                stringify ! ( cs_domain ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuset ) ) . cs_ref as * const _ as usize
                } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuset ) , "::" ,
                stringify ! ( cs_ref ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuset ) ) . cs_flags as * const _ as
                usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuset ) , "::" ,
                stringify ! ( cs_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuset ) ) . cs_id as * const _ as usize
                } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuset ) , "::" ,
                stringify ! ( cs_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuset ) ) . cs_parent as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuset ) , "::" ,
                stringify ! ( cs_parent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuset ) ) . cs_link as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuset ) , "::" ,
                stringify ! ( cs_link ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuset ) ) . cs_siblings as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuset ) , "::" ,
                stringify ! ( cs_siblings ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpuset ) ) . cs_children as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( cpuset ) , "::" ,
                stringify ! ( cs_children ) ));
}
impl Clone for cpuset {
    fn clone(&self) -> Self { *self }
}
impl Default for cpuset {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    #[link_name = "cpuset_root"]
    pub static mut cpuset_root: *mut cpuset_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct prison {
    _unused: [u8; 0],
}
extern "C" {
    pub fn cpuset_thread0() -> *mut cpuset;
}
extern "C" {
    pub fn cpuset_ref(arg1: *mut cpuset) -> *mut cpuset;
}
extern "C" {
    pub fn cpuset_rel(arg1: *mut cpuset);
}
extern "C" {
    pub fn cpuset_setthread(id: lwpid_t, arg1: *mut cpuset_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn cpuset_setithread(id: lwpid_t, cpu: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn cpuset_create_root(arg1: *mut prison, arg2: *mut *mut cpuset)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn cpuset_setproc_update_set(arg1: *mut proc_, arg2: *mut cpuset)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn cpuset_which(arg1: cpuwhich_t, arg2: id_t, arg3: *mut *mut proc_,
                        arg4: *mut *mut thread, arg5: *mut *mut cpuset)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn cpuset_kernthread(arg1: *mut thread);
}
extern "C" {
    pub fn cpusetobj_strprint(arg1: *mut ::kernel::sys::raw::c_char,
                              arg2: *const cpuset_t)
     -> *mut ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn cpusetobj_strscan(arg1: *mut cpuset_t,
                             arg2: *const ::kernel::sys::raw::c_char)
     -> ::kernel::sys::raw::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum topo_node_type {
    TOPO_TYPE_DUMMY = 0,
    TOPO_TYPE_PU = 1,
    TOPO_TYPE_CORE = 2,
    TOPO_TYPE_CACHE = 3,
    TOPO_TYPE_PKG = 4,
    TOPO_TYPE_NODE = 5,
    TOPO_TYPE_GROUP = 6,
    TOPO_TYPE_SYSTEM = 7,
}
pub type hwid_t = ::kernel::sys::raw::c_uint;
pub type cpuid_t = ::kernel::sys::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct topo_node {
    pub parent: *mut topo_node,
    pub children: topo_node_topo_children,
    pub siblings: topo_node__bindgen_ty_1,
    pub cpuset: cpuset_t,
    pub type_: topo_node_type,
    pub subtype: usize,
    pub hwid: hwid_t,
    pub id: cpuid_t,
    pub nchildren: ::kernel::sys::raw::c_int,
    pub cpu_count: ::kernel::sys::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct topo_node_topo_children {
    pub tqh_first: *mut topo_node,
    pub tqh_last: *mut *mut topo_node,
}
#[test]
fn bindgen_test_layout_topo_node_topo_children() {
    assert_eq!(::core::mem::size_of::<topo_node_topo_children>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( topo_node_topo_children ) ));
    assert_eq! (::core::mem::align_of::<topo_node_topo_children>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( topo_node_topo_children ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const topo_node_topo_children ) ) . tqh_first
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( topo_node_topo_children
                ) , "::" , stringify ! ( tqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const topo_node_topo_children ) ) . tqh_last as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( topo_node_topo_children
                ) , "::" , stringify ! ( tqh_last ) ));
}
impl Clone for topo_node_topo_children {
    fn clone(&self) -> Self { *self }
}
impl Default for topo_node_topo_children {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct topo_node__bindgen_ty_1 {
    pub tqe_next: *mut topo_node,
    pub tqe_prev: *mut *mut topo_node,
}
#[test]
fn bindgen_test_layout_topo_node__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<topo_node__bindgen_ty_1>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( topo_node__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<topo_node__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( topo_node__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const topo_node__bindgen_ty_1 ) ) . tqe_next as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( topo_node__bindgen_ty_1
                ) , "::" , stringify ! ( tqe_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const topo_node__bindgen_ty_1 ) ) . tqe_prev as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( topo_node__bindgen_ty_1
                ) , "::" , stringify ! ( tqe_prev ) ));
}
impl Clone for topo_node__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for topo_node__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_topo_node() {
    assert_eq!(::core::mem::size_of::<topo_node>() , 104usize , concat ! (
               "Size of: " , stringify ! ( topo_node ) ));
    assert_eq! (::core::mem::align_of::<topo_node>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( topo_node ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const topo_node ) ) . parent as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( topo_node ) , "::" ,
                stringify ! ( parent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const topo_node ) ) . children as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( topo_node ) , "::" ,
                stringify ! ( children ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const topo_node ) ) . siblings as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( topo_node ) , "::" ,
                stringify ! ( siblings ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const topo_node ) ) . cpuset as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( topo_node ) , "::" ,
                stringify ! ( cpuset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const topo_node ) ) . type_ as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( topo_node ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const topo_node ) ) . subtype as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( topo_node ) , "::" ,
                stringify ! ( subtype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const topo_node ) ) . hwid as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( topo_node ) , "::" ,
                stringify ! ( hwid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const topo_node ) ) . id as * const _ as usize
                } , 92usize , concat ! (
                "Alignment of field: " , stringify ! ( topo_node ) , "::" ,
                stringify ! ( id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const topo_node ) ) . nchildren as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( topo_node ) , "::" ,
                stringify ! ( nchildren ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const topo_node ) ) . cpu_count as * const _ as
                usize } , 100usize , concat ! (
                "Alignment of field: " , stringify ! ( topo_node ) , "::" ,
                stringify ! ( cpu_count ) ));
}
impl Clone for topo_node {
    fn clone(&self) -> Self { *self }
}
impl Default for topo_node {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cpu_group {
    pub cg_parent: *mut cpu_group,
    pub cg_child: *mut cpu_group,
    pub cg_mask: cpuset_t,
    pub cg_count: i32,
    pub cg_children: i16,
    pub cg_level: i8,
    pub cg_flags: i8,
}
#[test]
fn bindgen_test_layout_cpu_group() {
    assert_eq!(::core::mem::size_of::<cpu_group>() , 56usize , concat ! (
               "Size of: " , stringify ! ( cpu_group ) ));
    assert_eq! (::core::mem::align_of::<cpu_group>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( cpu_group ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_group ) ) . cg_parent as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( cpu_group ) , "::" ,
                stringify ! ( cg_parent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_group ) ) . cg_child as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( cpu_group ) , "::" ,
                stringify ! ( cg_child ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_group ) ) . cg_mask as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( cpu_group ) , "::" ,
                stringify ! ( cg_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_group ) ) . cg_count as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( cpu_group ) , "::" ,
                stringify ! ( cg_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_group ) ) . cg_children as * const _
                as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( cpu_group ) , "::" ,
                stringify ! ( cg_children ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_group ) ) . cg_level as * const _ as
                usize } , 54usize , concat ! (
                "Alignment of field: " , stringify ! ( cpu_group ) , "::" ,
                stringify ! ( cg_level ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cpu_group ) ) . cg_flags as * const _ as
                usize } , 55usize , concat ! (
                "Alignment of field: " , stringify ! ( cpu_group ) , "::" ,
                stringify ! ( cg_flags ) ));
}
impl Clone for cpu_group {
    fn clone(&self) -> Self { *self }
}
impl Default for cpu_group {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type cpu_group_t = *mut cpu_group;
extern "C" {
    #[link_name = "mp_maxid"]
    pub static mut mp_maxid: u_int;
}
extern "C" {
    #[link_name = "mp_maxcpus"]
    pub static mut mp_maxcpus: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "mp_ncpus"]
    pub static mut mp_ncpus: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "smp_started"]
    pub static mut smp_started: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "all_cpus"]
    pub static mut all_cpus: cpuset_t;
}
extern "C" {
    #[link_name = "cpuset_domain"]
    pub static mut cpuset_domain: [cpuset_t; 8usize];
}
extern "C" {
    pub fn quiesce_all_cpus(arg1: *const ::kernel::sys::raw::c_char,
                            arg2: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn quiesce_cpus(arg1: cpuset_t,
                        arg2: *const ::kernel::sys::raw::c_char,
                        arg3: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn smp_no_rendezvous_barrier(arg1: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn smp_rendezvous(arg1:
                              ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                              *mut ::kernel::sys::raw::c_void)>,
                          arg2:
                              ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                              *mut ::kernel::sys::raw::c_void)>,
                          arg3:
                              ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                              *mut ::kernel::sys::raw::c_void)>,
                          arg: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn smp_rendezvous_cpus(arg1: cpuset_t,
                               arg2:
                                   ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                                   *mut ::kernel::sys::raw::c_void)>,
                               arg3:
                                   ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                                   *mut ::kernel::sys::raw::c_void)>,
                               arg4:
                                   ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                                   *mut ::kernel::sys::raw::c_void)>,
                               arg: *mut ::kernel::sys::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct iovec {
    pub iov_base: *mut ::kernel::sys::raw::c_void,
    pub iov_len: usize,
}
#[test]
fn bindgen_test_layout_iovec() {
    assert_eq!(::core::mem::size_of::<iovec>() , 16usize , concat ! (
               "Size of: " , stringify ! ( iovec ) ));
    assert_eq! (::core::mem::align_of::<iovec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( iovec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const iovec ) ) . iov_base as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( iovec ) , "::" ,
                stringify ! ( iov_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const iovec ) ) . iov_len as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( iovec ) , "::" ,
                stringify ! ( iov_len ) ));
}
impl Clone for iovec {
    fn clone(&self) -> Self { *self }
}
impl Default for iovec {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type sa_family_t = __sa_family_t;
pub type socklen_t = __socklen_t;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct linger {
    pub l_onoff: ::kernel::sys::raw::c_int,
    pub l_linger: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_linger() {
    assert_eq!(::core::mem::size_of::<linger>() , 8usize , concat ! (
               "Size of: " , stringify ! ( linger ) ));
    assert_eq! (::core::mem::align_of::<linger>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( linger ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const linger ) ) . l_onoff as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( linger ) , "::" ,
                stringify ! ( l_onoff ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const linger ) ) . l_linger as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( linger ) , "::" ,
                stringify ! ( l_linger ) ));
}
impl Clone for linger {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct accept_filter_arg {
    pub af_name: [::kernel::sys::raw::c_char; 16usize],
    pub af_arg: [::kernel::sys::raw::c_char; 240usize],
}
#[test]
fn bindgen_test_layout_accept_filter_arg() {
    assert_eq!(::core::mem::size_of::<accept_filter_arg>() , 256usize , concat
               ! ( "Size of: " , stringify ! ( accept_filter_arg ) ));
    assert_eq! (::core::mem::align_of::<accept_filter_arg>() , 1usize , concat
                ! ( "Alignment of " , stringify ! ( accept_filter_arg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const accept_filter_arg ) ) . af_name as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( accept_filter_arg ) ,
                "::" , stringify ! ( af_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const accept_filter_arg ) ) . af_arg as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( accept_filter_arg ) ,
                "::" , stringify ! ( af_arg ) ));
}
impl Clone for accept_filter_arg {
    fn clone(&self) -> Self { *self }
}
impl Default for accept_filter_arg {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for accept_filter_arg {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "accept_filter_arg {{ af_name: {:?}, af_arg: [{}] }}" ,
               self . af_name , self . af_arg . iter (  ) . enumerate (  ) .
               map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ))
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct sockaddr {
    pub sa_len: ::kernel::sys::raw::c_uchar,
    pub sa_family: sa_family_t,
    pub sa_data: [::kernel::sys::raw::c_char; 14usize],
}
#[test]
fn bindgen_test_layout_sockaddr() {
    assert_eq!(::core::mem::size_of::<sockaddr>() , 16usize , concat ! (
               "Size of: " , stringify ! ( sockaddr ) ));
    assert_eq! (::core::mem::align_of::<sockaddr>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( sockaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr ) ) . sa_len as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr ) , "::" ,
                stringify ! ( sa_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr ) ) . sa_family as * const _ as
                usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr ) , "::" ,
                stringify ! ( sa_family ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr ) ) . sa_data as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr ) , "::" ,
                stringify ! ( sa_data ) ));
}
impl Clone for sockaddr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct sockproto {
    pub sp_family: ::kernel::sys::raw::c_ushort,
    pub sp_protocol: ::kernel::sys::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_sockproto() {
    assert_eq!(::core::mem::size_of::<sockproto>() , 4usize , concat ! (
               "Size of: " , stringify ! ( sockproto ) ));
    assert_eq! (::core::mem::align_of::<sockproto>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( sockproto ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockproto ) ) . sp_family as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sockproto ) , "::" ,
                stringify ! ( sp_family ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockproto ) ) . sp_protocol as * const _
                as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( sockproto ) , "::" ,
                stringify ! ( sp_protocol ) ));
}
impl Clone for sockproto {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct sockaddr_storage {
    pub ss_len: ::kernel::sys::raw::c_uchar,
    pub ss_family: sa_family_t,
    pub __ss_pad1: [::kernel::sys::raw::c_char; 6usize],
    pub __ss_align: __int64_t,
    pub __ss_pad2: [::kernel::sys::raw::c_char; 112usize],
}
#[test]
fn bindgen_test_layout_sockaddr_storage() {
    assert_eq!(::core::mem::size_of::<sockaddr_storage>() , 128usize , concat
               ! ( "Size of: " , stringify ! ( sockaddr_storage ) ));
    assert_eq! (::core::mem::align_of::<sockaddr_storage>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( sockaddr_storage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_storage ) ) . ss_len as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_storage ) ,
                "::" , stringify ! ( ss_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_storage ) ) . ss_family as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_storage ) ,
                "::" , stringify ! ( ss_family ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_storage ) ) . __ss_pad1 as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_storage ) ,
                "::" , stringify ! ( __ss_pad1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_storage ) ) . __ss_align as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_storage ) ,
                "::" , stringify ! ( __ss_align ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_storage ) ) . __ss_pad2 as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_storage ) ,
                "::" , stringify ! ( __ss_pad2 ) ));
}
impl Clone for sockaddr_storage {
    fn clone(&self) -> Self { *self }
}
impl Default for sockaddr_storage {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for sockaddr_storage {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "sockaddr_storage {{ ss_len: {:?}, ss_family: {:?}, __ss_pad1: {:?}, __ss_align: {:?}, __ss_pad2: [{}] }}"
               , self . ss_len , self . ss_family , self . __ss_pad1 , self .
               __ss_align , self . __ss_pad2 . iter (  ) . enumerate (  ) .
               map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ))
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct msghdr {
    pub msg_name: *mut ::kernel::sys::raw::c_void,
    pub msg_namelen: socklen_t,
    pub msg_iov: *mut iovec,
    pub msg_iovlen: ::kernel::sys::raw::c_int,
    pub msg_control: *mut ::kernel::sys::raw::c_void,
    pub msg_controllen: socklen_t,
    pub msg_flags: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_msghdr() {
    assert_eq!(::core::mem::size_of::<msghdr>() , 48usize , concat ! (
               "Size of: " , stringify ! ( msghdr ) ));
    assert_eq! (::core::mem::align_of::<msghdr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( msghdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msghdr ) ) . msg_name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( msghdr ) , "::" ,
                stringify ! ( msg_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msghdr ) ) . msg_namelen as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( msghdr ) , "::" ,
                stringify ! ( msg_namelen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msghdr ) ) . msg_iov as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( msghdr ) , "::" ,
                stringify ! ( msg_iov ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msghdr ) ) . msg_iovlen as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( msghdr ) , "::" ,
                stringify ! ( msg_iovlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msghdr ) ) . msg_control as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( msghdr ) , "::" ,
                stringify ! ( msg_control ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msghdr ) ) . msg_controllen as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( msghdr ) , "::" ,
                stringify ! ( msg_controllen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msghdr ) ) . msg_flags as * const _ as
                usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( msghdr ) , "::" ,
                stringify ! ( msg_flags ) ));
}
impl Clone for msghdr {
    fn clone(&self) -> Self { *self }
}
impl Default for msghdr {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct cmsghdr {
    pub cmsg_len: socklen_t,
    pub cmsg_level: ::kernel::sys::raw::c_int,
    pub cmsg_type: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_cmsghdr() {
    assert_eq!(::core::mem::size_of::<cmsghdr>() , 12usize , concat ! (
               "Size of: " , stringify ! ( cmsghdr ) ));
    assert_eq! (::core::mem::align_of::<cmsghdr>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( cmsghdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmsghdr ) ) . cmsg_len as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( cmsghdr ) , "::" ,
                stringify ! ( cmsg_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmsghdr ) ) . cmsg_level as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( cmsghdr ) , "::" ,
                stringify ! ( cmsg_level ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmsghdr ) ) . cmsg_type as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( cmsghdr ) , "::" ,
                stringify ! ( cmsg_type ) ));
}
impl Clone for cmsghdr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct cmsgcred {
    pub cmcred_pid: pid_t,
    pub cmcred_uid: uid_t,
    pub cmcred_euid: uid_t,
    pub cmcred_gid: gid_t,
    pub cmcred_ngroups: ::kernel::sys::raw::c_short,
    pub cmcred_groups: [gid_t; 16usize],
}
#[test]
fn bindgen_test_layout_cmsgcred() {
    assert_eq!(::core::mem::size_of::<cmsgcred>() , 84usize , concat ! (
               "Size of: " , stringify ! ( cmsgcred ) ));
    assert_eq! (::core::mem::align_of::<cmsgcred>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( cmsgcred ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmsgcred ) ) . cmcred_pid as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( cmsgcred ) , "::" ,
                stringify ! ( cmcred_pid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmsgcred ) ) . cmcred_uid as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( cmsgcred ) , "::" ,
                stringify ! ( cmcred_uid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmsgcred ) ) . cmcred_euid as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( cmsgcred ) , "::" ,
                stringify ! ( cmcred_euid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmsgcred ) ) . cmcred_gid as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( cmsgcred ) , "::" ,
                stringify ! ( cmcred_gid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmsgcred ) ) . cmcred_ngroups as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( cmsgcred ) , "::" ,
                stringify ! ( cmcred_ngroups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cmsgcred ) ) . cmcred_groups as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( cmsgcred ) , "::" ,
                stringify ! ( cmcred_groups ) ));
}
impl Clone for cmsgcred {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct sockcred {
    pub sc_uid: uid_t,
    pub sc_euid: uid_t,
    pub sc_gid: gid_t,
    pub sc_egid: gid_t,
    pub sc_ngroups: ::kernel::sys::raw::c_int,
    pub sc_groups: [gid_t; 1usize],
}
#[test]
fn bindgen_test_layout_sockcred() {
    assert_eq!(::core::mem::size_of::<sockcred>() , 24usize , concat ! (
               "Size of: " , stringify ! ( sockcred ) ));
    assert_eq! (::core::mem::align_of::<sockcred>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( sockcred ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockcred ) ) . sc_uid as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sockcred ) , "::" ,
                stringify ! ( sc_uid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockcred ) ) . sc_euid as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( sockcred ) , "::" ,
                stringify ! ( sc_euid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockcred ) ) . sc_gid as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sockcred ) , "::" ,
                stringify ! ( sc_gid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockcred ) ) . sc_egid as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( sockcred ) , "::" ,
                stringify ! ( sc_egid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockcred ) ) . sc_ngroups as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( sockcred ) , "::" ,
                stringify ! ( sc_ngroups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockcred ) ) . sc_groups as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( sockcred ) , "::" ,
                stringify ! ( sc_groups ) ));
}
impl Clone for sockcred {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct sock_timestamp_info {
    pub st_info_flags: __uint32_t,
    pub st_info_pad0: __uint32_t,
    pub st_info_rsv: [__uint64_t; 7usize],
}
#[test]
fn bindgen_test_layout_sock_timestamp_info() {
    assert_eq!(::core::mem::size_of::<sock_timestamp_info>() , 64usize ,
               concat ! ( "Size of: " , stringify ! ( sock_timestamp_info )
               ));
    assert_eq! (::core::mem::align_of::<sock_timestamp_info>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( sock_timestamp_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sock_timestamp_info ) ) . st_info_flags
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sock_timestamp_info ) ,
                "::" , stringify ! ( st_info_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sock_timestamp_info ) ) . st_info_pad0 as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( sock_timestamp_info ) ,
                "::" , stringify ! ( st_info_pad0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sock_timestamp_info ) ) . st_info_rsv as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sock_timestamp_info ) ,
                "::" , stringify ! ( st_info_rsv ) ));
}
impl Clone for sock_timestamp_info {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct osockaddr {
    pub sa_family: ::kernel::sys::raw::c_ushort,
    pub sa_data: [::kernel::sys::raw::c_char; 14usize],
}
#[test]
fn bindgen_test_layout_osockaddr() {
    assert_eq!(::core::mem::size_of::<osockaddr>() , 16usize , concat ! (
               "Size of: " , stringify ! ( osockaddr ) ));
    assert_eq! (::core::mem::align_of::<osockaddr>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( osockaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const osockaddr ) ) . sa_family as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( osockaddr ) , "::" ,
                stringify ! ( sa_family ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const osockaddr ) ) . sa_data as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( osockaddr ) , "::" ,
                stringify ! ( sa_data ) ));
}
impl Clone for osockaddr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct omsghdr {
    pub msg_name: *mut ::kernel::sys::raw::c_char,
    pub msg_namelen: ::kernel::sys::raw::c_int,
    pub msg_iov: *mut iovec,
    pub msg_iovlen: ::kernel::sys::raw::c_int,
    pub msg_accrights: *mut ::kernel::sys::raw::c_char,
    pub msg_accrightslen: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_omsghdr() {
    assert_eq!(::core::mem::size_of::<omsghdr>() , 48usize , concat ! (
               "Size of: " , stringify ! ( omsghdr ) ));
    assert_eq! (::core::mem::align_of::<omsghdr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( omsghdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const omsghdr ) ) . msg_name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( omsghdr ) , "::" ,
                stringify ! ( msg_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const omsghdr ) ) . msg_namelen as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( omsghdr ) , "::" ,
                stringify ! ( msg_namelen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const omsghdr ) ) . msg_iov as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( omsghdr ) , "::" ,
                stringify ! ( msg_iov ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const omsghdr ) ) . msg_iovlen as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( omsghdr ) , "::" ,
                stringify ! ( msg_iovlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const omsghdr ) ) . msg_accrights as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( omsghdr ) , "::" ,
                stringify ! ( msg_accrights ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const omsghdr ) ) . msg_accrightslen as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( omsghdr ) , "::" ,
                stringify ! ( msg_accrightslen ) ));
}
impl Clone for omsghdr {
    fn clone(&self) -> Self { *self }
}
impl Default for omsghdr {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sf_hdtr {
    pub headers: *mut iovec,
    pub hdr_cnt: ::kernel::sys::raw::c_int,
    pub trailers: *mut iovec,
    pub trl_cnt: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_sf_hdtr() {
    assert_eq!(::core::mem::size_of::<sf_hdtr>() , 32usize , concat ! (
               "Size of: " , stringify ! ( sf_hdtr ) ));
    assert_eq! (::core::mem::align_of::<sf_hdtr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sf_hdtr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sf_hdtr ) ) . headers as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sf_hdtr ) , "::" ,
                stringify ! ( headers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sf_hdtr ) ) . hdr_cnt as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sf_hdtr ) , "::" ,
                stringify ! ( hdr_cnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sf_hdtr ) ) . trailers as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( sf_hdtr ) , "::" ,
                stringify ! ( trailers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sf_hdtr ) ) . trl_cnt as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( sf_hdtr ) , "::" ,
                stringify ! ( trl_cnt ) ));
}
impl Clone for sf_hdtr {
    fn clone(&self) -> Self { *self }
}
impl Default for sf_hdtr {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mmsghdr {
    pub msg_hdr: msghdr,
    pub msg_len: isize,
}
#[test]
fn bindgen_test_layout_mmsghdr() {
    assert_eq!(::core::mem::size_of::<mmsghdr>() , 56usize , concat ! (
               "Size of: " , stringify ! ( mmsghdr ) ));
    assert_eq! (::core::mem::align_of::<mmsghdr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( mmsghdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mmsghdr ) ) . msg_hdr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mmsghdr ) , "::" ,
                stringify ! ( msg_hdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mmsghdr ) ) . msg_len as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( mmsghdr ) , "::" ,
                stringify ! ( msg_len ) ));
}
impl Clone for mmsghdr {
    fn clone(&self) -> Self { *self }
}
impl Default for mmsghdr {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tcpcb {
    _unused: [u8; 0],
}
extern "C" {
    pub fn so_sototcpcb(so: *mut socket) -> *mut tcpcb;
}
extern "C" {
    pub fn so_sotoinpcb(so: *mut socket) -> *mut inpcb;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockbuf {
    _unused: [u8; 0],
}
extern "C" {
    pub fn so_sockbuf_snd(arg1: *mut socket) -> *mut sockbuf;
}
extern "C" {
    pub fn so_sockbuf_rcv(arg1: *mut socket) -> *mut sockbuf;
}
extern "C" {
    pub fn so_state_get(arg1: *const socket) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn so_state_set(arg1: *mut socket, arg2: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn so_options_get(arg1: *const socket) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn so_options_set(arg1: *mut socket, arg2: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn so_error_get(arg1: *const socket) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn so_error_set(arg1: *mut socket, arg2: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn so_linger_get(arg1: *const socket) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn so_linger_set(arg1: *mut socket, arg2: ::kernel::sys::raw::c_int);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct protosw {
    pub pr_type: ::kernel::sys::raw::c_short,
    pub pr_domain: *mut domain,
    pub pr_protocol: ::kernel::sys::raw::c_short,
    pub pr_flags: ::kernel::sys::raw::c_short,
    pub pr_input: pr_input_t,
    pub pr_output: pr_output_t,
    pub pr_ctlinput: pr_ctlinput_t,
    pub pr_ctloutput: pr_ctloutput_t,
    pub pr_init: pr_init_t,
    pub pr_fasttimo: pr_fasttimo_t,
    pub pr_slowtimo: pr_slowtimo_t,
    pub pr_drain: pr_drain_t,
    pub pr_usrreqs: *mut pr_usrreqs,
}
#[test]
fn bindgen_test_layout_protosw() {
    assert_eq!(::core::mem::size_of::<protosw>() , 96usize , concat ! (
               "Size of: " , stringify ! ( protosw ) ));
    assert_eq! (::core::mem::align_of::<protosw>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( protosw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const protosw ) ) . pr_type as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( protosw ) , "::" ,
                stringify ! ( pr_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const protosw ) ) . pr_domain as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( protosw ) , "::" ,
                stringify ! ( pr_domain ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const protosw ) ) . pr_protocol as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( protosw ) , "::" ,
                stringify ! ( pr_protocol ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const protosw ) ) . pr_flags as * const _ as
                usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( protosw ) , "::" ,
                stringify ! ( pr_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const protosw ) ) . pr_input as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( protosw ) , "::" ,
                stringify ! ( pr_input ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const protosw ) ) . pr_output as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( protosw ) , "::" ,
                stringify ! ( pr_output ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const protosw ) ) . pr_ctlinput as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( protosw ) , "::" ,
                stringify ! ( pr_ctlinput ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const protosw ) ) . pr_ctloutput as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( protosw ) , "::" ,
                stringify ! ( pr_ctloutput ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const protosw ) ) . pr_init as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( protosw ) , "::" ,
                stringify ! ( pr_init ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const protosw ) ) . pr_fasttimo as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( protosw ) , "::" ,
                stringify ! ( pr_fasttimo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const protosw ) ) . pr_slowtimo as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( protosw ) , "::" ,
                stringify ! ( pr_slowtimo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const protosw ) ) . pr_drain as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( protosw ) , "::" ,
                stringify ! ( pr_drain ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const protosw ) ) . pr_usrreqs as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( protosw ) , "::" ,
                stringify ! ( pr_usrreqs ) ));
}
impl Clone for protosw {
    fn clone(&self) -> Self { *self }
}
impl Default for protosw {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    pub fn so_protosw_get(arg1: *const socket) -> *mut protosw;
}
extern "C" {
    pub fn so_protosw_set(arg1: *mut socket, arg2: *mut protosw);
}
extern "C" {
    pub fn so_sorwakeup_locked(so: *mut socket);
}
extern "C" {
    pub fn so_sowwakeup_locked(so: *mut socket);
}
extern "C" {
    pub fn so_sorwakeup(so: *mut socket);
}
extern "C" {
    pub fn so_sowwakeup(so: *mut socket);
}
extern "C" {
    pub fn so_lock(so: *mut socket);
}
extern "C" {
    pub fn so_unlock(so: *mut socket);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ctlname {
    pub ctl_name: *mut ::kernel::sys::raw::c_char,
    pub ctl_type: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_ctlname() {
    assert_eq!(::core::mem::size_of::<ctlname>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ctlname ) ));
    assert_eq! (::core::mem::align_of::<ctlname>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ctlname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ctlname ) ) . ctl_name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ctlname ) , "::" ,
                stringify ! ( ctl_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ctlname ) ) . ctl_type as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ctlname ) , "::" ,
                stringify ! ( ctl_type ) ));
}
impl Clone for ctlname {
    fn clone(&self) -> Self { *self }
}
impl Default for ctlname {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sysctl_req {
    pub td: *mut thread,
    pub lock: ::kernel::sys::raw::c_int,
    pub oldptr: *mut ::kernel::sys::raw::c_void,
    pub oldlen: usize,
    pub oldidx: usize,
    pub oldfunc: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                 *mut sysctl_req,
                                                             arg2:
                                                                 *const ::kernel::sys::raw::c_void,
                                                             arg3: usize)
                                            -> ::kernel::sys::raw::c_int>,
    pub newptr: *mut ::kernel::sys::raw::c_void,
    pub newlen: usize,
    pub newidx: usize,
    pub newfunc: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                 *mut sysctl_req,
                                                             arg2:
                                                                 *mut ::kernel::sys::raw::c_void,
                                                             arg3: usize)
                                            -> ::kernel::sys::raw::c_int>,
    pub validlen: usize,
    pub flags: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_sysctl_req() {
    assert_eq!(::core::mem::size_of::<sysctl_req>() , 96usize , concat ! (
               "Size of: " , stringify ! ( sysctl_req ) ));
    assert_eq! (::core::mem::align_of::<sysctl_req>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sysctl_req ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_req ) ) . td as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sysctl_req ) , "::" ,
                stringify ! ( td ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_req ) ) . lock as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sysctl_req ) , "::" ,
                stringify ! ( lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_req ) ) . oldptr as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( sysctl_req ) , "::" ,
                stringify ! ( oldptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_req ) ) . oldlen as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( sysctl_req ) , "::" ,
                stringify ! ( oldlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_req ) ) . oldidx as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( sysctl_req ) , "::" ,
                stringify ! ( oldidx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_req ) ) . oldfunc as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( sysctl_req ) , "::" ,
                stringify ! ( oldfunc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_req ) ) . newptr as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( sysctl_req ) , "::" ,
                stringify ! ( newptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_req ) ) . newlen as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( sysctl_req ) , "::" ,
                stringify ! ( newlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_req ) ) . newidx as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( sysctl_req ) , "::" ,
                stringify ! ( newidx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_req ) ) . newfunc as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( sysctl_req ) , "::" ,
                stringify ! ( newfunc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_req ) ) . validlen as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( sysctl_req ) , "::" ,
                stringify ! ( validlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_req ) ) . flags as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( sysctl_req ) , "::" ,
                stringify ! ( flags ) ));
}
impl Clone for sysctl_req {
    fn clone(&self) -> Self { *self }
}
impl Default for sysctl_req {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sysctl_oid_list {
    pub slh_first: *mut sysctl_oid,
}
#[test]
fn bindgen_test_layout_sysctl_oid_list() {
    assert_eq!(::core::mem::size_of::<sysctl_oid_list>() , 8usize , concat ! (
               "Size of: " , stringify ! ( sysctl_oid_list ) ));
    assert_eq! (::core::mem::align_of::<sysctl_oid_list>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( sysctl_oid_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_oid_list ) ) . slh_first as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sysctl_oid_list ) ,
                "::" , stringify ! ( slh_first ) ));
}
impl Clone for sysctl_oid_list {
    fn clone(&self) -> Self { *self }
}
impl Default for sysctl_oid_list {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    pub fn sysctl_handle_bool(oidp: *mut sysctl_oid,
                              arg1: *mut ::kernel::sys::raw::c_void,
                              arg2: intmax_t, req: *mut sysctl_req)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sysctl_handle_8(oidp: *mut sysctl_oid,
                           arg1: *mut ::kernel::sys::raw::c_void,
                           arg2: intmax_t, req: *mut sysctl_req)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sysctl_handle_16(oidp: *mut sysctl_oid,
                            arg1: *mut ::kernel::sys::raw::c_void,
                            arg2: intmax_t, req: *mut sysctl_req)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sysctl_handle_32(oidp: *mut sysctl_oid,
                            arg1: *mut ::kernel::sys::raw::c_void,
                            arg2: intmax_t, req: *mut sysctl_req)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sysctl_handle_64(oidp: *mut sysctl_oid,
                            arg1: *mut ::kernel::sys::raw::c_void,
                            arg2: intmax_t, req: *mut sysctl_req)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sysctl_handle_int(oidp: *mut sysctl_oid,
                             arg1: *mut ::kernel::sys::raw::c_void,
                             arg2: intmax_t, req: *mut sysctl_req)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sysctl_msec_to_ticks(oidp: *mut sysctl_oid,
                                arg1: *mut ::kernel::sys::raw::c_void,
                                arg2: intmax_t, req: *mut sysctl_req)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sysctl_handle_long(oidp: *mut sysctl_oid,
                              arg1: *mut ::kernel::sys::raw::c_void,
                              arg2: intmax_t, req: *mut sysctl_req)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sysctl_handle_string(oidp: *mut sysctl_oid,
                                arg1: *mut ::kernel::sys::raw::c_void,
                                arg2: intmax_t, req: *mut sysctl_req)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sysctl_handle_opaque(oidp: *mut sysctl_oid,
                                arg1: *mut ::kernel::sys::raw::c_void,
                                arg2: intmax_t, req: *mut sysctl_req)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sysctl_handle_counter_u64(oidp: *mut sysctl_oid,
                                     arg1: *mut ::kernel::sys::raw::c_void,
                                     arg2: intmax_t, req: *mut sysctl_req)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sysctl_handle_counter_u64_array(oidp: *mut sysctl_oid,
                                           arg1:
                                               *mut ::kernel::sys::raw::c_void,
                                           arg2: intmax_t,
                                           req: *mut sysctl_req)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sysctl_handle_uma_zone_max(oidp: *mut sysctl_oid,
                                      arg1: *mut ::kernel::sys::raw::c_void,
                                      arg2: intmax_t, req: *mut sysctl_req)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sysctl_handle_uma_zone_cur(oidp: *mut sysctl_oid,
                                      arg1: *mut ::kernel::sys::raw::c_void,
                                      arg2: intmax_t, req: *mut sysctl_req)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sysctl_dpcpu_int(oidp: *mut sysctl_oid,
                            arg1: *mut ::kernel::sys::raw::c_void,
                            arg2: intmax_t, req: *mut sysctl_req)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sysctl_dpcpu_long(oidp: *mut sysctl_oid,
                             arg1: *mut ::kernel::sys::raw::c_void,
                             arg2: intmax_t, req: *mut sysctl_req)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sysctl_dpcpu_quad(oidp: *mut sysctl_oid,
                             arg1: *mut ::kernel::sys::raw::c_void,
                             arg2: intmax_t, req: *mut sysctl_req)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sysctl_register_oid(oidp: *mut sysctl_oid);
}
extern "C" {
    pub fn sysctl_register_disabled_oid(oidp: *mut sysctl_oid);
}
extern "C" {
    pub fn sysctl_enable_oid(oidp: *mut sysctl_oid);
}
extern "C" {
    pub fn sysctl_unregister_oid(oidp: *mut sysctl_oid);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sysctl_ctx_entry {
    pub entry: *mut sysctl_oid,
    pub link: sysctl_ctx_entry__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sysctl_ctx_entry__bindgen_ty_1 {
    pub tqe_next: *mut sysctl_ctx_entry,
    pub tqe_prev: *mut *mut sysctl_ctx_entry,
}
#[test]
fn bindgen_test_layout_sysctl_ctx_entry__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<sysctl_ctx_entry__bindgen_ty_1>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( sysctl_ctx_entry__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<sysctl_ctx_entry__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( sysctl_ctx_entry__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_ctx_entry__bindgen_ty_1 ) ) .
                tqe_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                sysctl_ctx_entry__bindgen_ty_1 ) , "::" , stringify ! (
                tqe_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_ctx_entry__bindgen_ty_1 ) ) .
                tqe_prev as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                sysctl_ctx_entry__bindgen_ty_1 ) , "::" , stringify ! (
                tqe_prev ) ));
}
impl Clone for sysctl_ctx_entry__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for sysctl_ctx_entry__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_sysctl_ctx_entry() {
    assert_eq!(::core::mem::size_of::<sysctl_ctx_entry>() , 24usize , concat !
               ( "Size of: " , stringify ! ( sysctl_ctx_entry ) ));
    assert_eq! (::core::mem::align_of::<sysctl_ctx_entry>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( sysctl_ctx_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_ctx_entry ) ) . entry as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sysctl_ctx_entry ) ,
                "::" , stringify ! ( entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sysctl_ctx_entry ) ) . link as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sysctl_ctx_entry ) ,
                "::" , stringify ! ( link ) ));
}
impl Clone for sysctl_ctx_entry {
    fn clone(&self) -> Self { *self }
}
impl Default for sysctl_ctx_entry {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    #[link_name = "sysctl__children"]
    pub static mut sysctl__children: sysctl_oid_list;
}
extern "C" {
    #[link_name = "sysctl___kern"]
    pub static mut sysctl___kern: sysctl_oid;
}
extern "C" {
    #[link_name = "sysctl___kern_features"]
    pub static mut sysctl___kern_features: sysctl_oid;
}
extern "C" {
    #[link_name = "sysctl___kern_ipc"]
    pub static mut sysctl___kern_ipc: sysctl_oid;
}
extern "C" {
    #[link_name = "sysctl___kern_proc"]
    pub static mut sysctl___kern_proc: sysctl_oid;
}
extern "C" {
    #[link_name = "sysctl___kern_sched"]
    pub static mut sysctl___kern_sched: sysctl_oid;
}
extern "C" {
    #[link_name = "sysctl___kern_sched_stats"]
    pub static mut sysctl___kern_sched_stats: sysctl_oid;
}
extern "C" {
    #[link_name = "sysctl___sysctl"]
    pub static mut sysctl___sysctl: sysctl_oid;
}
extern "C" {
    #[link_name = "sysctl___vm"]
    pub static mut sysctl___vm: sysctl_oid;
}
extern "C" {
    #[link_name = "sysctl___vm_stats"]
    pub static mut sysctl___vm_stats: sysctl_oid;
}
extern "C" {
    #[link_name = "sysctl___vm_stats_misc"]
    pub static mut sysctl___vm_stats_misc: sysctl_oid;
}
extern "C" {
    #[link_name = "sysctl___vfs"]
    pub static mut sysctl___vfs: sysctl_oid;
}
extern "C" {
    #[link_name = "sysctl___net"]
    pub static mut sysctl___net: sysctl_oid;
}
extern "C" {
    #[link_name = "sysctl___debug"]
    pub static mut sysctl___debug: sysctl_oid;
}
extern "C" {
    #[link_name = "sysctl___debug_sizeof"]
    pub static mut sysctl___debug_sizeof: sysctl_oid;
}
extern "C" {
    #[link_name = "sysctl___dev"]
    pub static mut sysctl___dev: sysctl_oid;
}
extern "C" {
    #[link_name = "sysctl___hw"]
    pub static mut sysctl___hw: sysctl_oid;
}
extern "C" {
    #[link_name = "sysctl___hw_bus"]
    pub static mut sysctl___hw_bus: sysctl_oid;
}
extern "C" {
    #[link_name = "sysctl___hw_bus_devices"]
    pub static mut sysctl___hw_bus_devices: sysctl_oid;
}
extern "C" {
    #[link_name = "sysctl___hw_bus_info"]
    pub static mut sysctl___hw_bus_info: sysctl_oid;
}
extern "C" {
    #[link_name = "sysctl___machdep"]
    pub static mut sysctl___machdep: sysctl_oid;
}
extern "C" {
    #[link_name = "sysctl___user"]
    pub static mut sysctl___user: sysctl_oid;
}
extern "C" {
    #[link_name = "sysctl___compat"]
    pub static mut sysctl___compat: sysctl_oid;
}
extern "C" {
    #[link_name = "sysctl___regression"]
    pub static mut sysctl___regression: sysctl_oid;
}
extern "C" {
    #[link_name = "sysctl___security"]
    pub static mut sysctl___security: sysctl_oid;
}
extern "C" {
    #[link_name = "sysctl___security_bsd"]
    pub static mut sysctl___security_bsd: sysctl_oid;
}
extern "C" {
    #[link_name = "machine"]
    pub static mut machine: [::kernel::sys::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "osrelease"]
    pub static mut osrelease: [::kernel::sys::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "ostype"]
    pub static mut ostype: [::kernel::sys::raw::c_char; 0usize];
}
extern "C" {
    #[link_name = "kern_ident"]
    pub static mut kern_ident: [::kernel::sys::raw::c_char; 0usize];
}
extern "C" {
    pub fn sysctl_add_oid(clist: *mut sysctl_ctx_list,
                          parent: *mut sysctl_oid_list,
                          nbr: ::kernel::sys::raw::c_int,
                          name: *const ::kernel::sys::raw::c_char,
                          kind: ::kernel::sys::raw::c_int,
                          arg1: *mut ::kernel::sys::raw::c_void,
                          arg2: intmax_t,
                          handler:
                              ::core::option::Option<unsafe extern "C" fn(oidp:
                                                                              *mut sysctl_oid,
                                                                          arg1:
                                                                              *mut ::kernel::sys::raw::c_void,
                                                                          arg2:
                                                                              intmax_t,
                                                                          req:
                                                                              *mut sysctl_req)
                                                         ->
                                                             ::kernel::sys::raw::c_int>,
                          fmt: *const ::kernel::sys::raw::c_char,
                          descr: *const ::kernel::sys::raw::c_char,
                          label: *const ::kernel::sys::raw::c_char)
     -> *mut sysctl_oid;
}
extern "C" {
    pub fn sysctl_remove_name(parent: *mut sysctl_oid,
                              name: *const ::kernel::sys::raw::c_char,
                              del: ::kernel::sys::raw::c_int,
                              recurse: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sysctl_rename_oid(oidp: *mut sysctl_oid,
                             name: *const ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn sysctl_move_oid(oidp: *mut sysctl_oid,
                           parent: *mut sysctl_oid_list)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sysctl_remove_oid(oidp: *mut sysctl_oid,
                             del: ::kernel::sys::raw::c_int,
                             recurse: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sysctl_ctx_init(clist: *mut sysctl_ctx_list)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sysctl_ctx_free(clist: *mut sysctl_ctx_list)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sysctl_ctx_entry_add(clist: *mut sysctl_ctx_list,
                                oidp: *mut sysctl_oid)
     -> *mut sysctl_ctx_entry;
}
extern "C" {
    pub fn sysctl_ctx_entry_find(clist: *mut sysctl_ctx_list,
                                 oidp: *mut sysctl_oid)
     -> *mut sysctl_ctx_entry;
}
extern "C" {
    pub fn sysctl_ctx_entry_del(clist: *mut sysctl_ctx_list,
                                oidp: *mut sysctl_oid)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn kernel_sysctl(td: *mut thread,
                         name: *mut ::kernel::sys::raw::c_int, namelen: u_int,
                         old: *mut ::kernel::sys::raw::c_void,
                         oldlenp: *mut usize,
                         new: *mut ::kernel::sys::raw::c_void, newlen: usize,
                         retval: *mut usize, flags: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn kernel_sysctlbyname(td: *mut thread,
                               name: *mut ::kernel::sys::raw::c_char,
                               old: *mut ::kernel::sys::raw::c_void,
                               oldlenp: *mut usize,
                               new: *mut ::kernel::sys::raw::c_void,
                               newlen: usize, retval: *mut usize,
                               flags: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn userland_sysctl(td: *mut thread,
                           name: *mut ::kernel::sys::raw::c_int,
                           namelen: u_int,
                           old: *mut ::kernel::sys::raw::c_void,
                           oldlenp: *mut usize,
                           inkernel: ::kernel::sys::raw::c_int,
                           new: *mut ::kernel::sys::raw::c_void,
                           newlen: usize, retval: *mut usize,
                           flags: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sysctl_find_oid(name: *mut ::kernel::sys::raw::c_int,
                           namelen: u_int, noid: *mut *mut sysctl_oid,
                           nindx: *mut ::kernel::sys::raw::c_int,
                           req: *mut sysctl_req) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sysctl_wlock();
}
extern "C" {
    pub fn sysctl_wunlock();
}
extern "C" {
    pub fn sysctl_wire_old_buffer(req: *mut sysctl_req, len: usize)
     -> ::kernel::sys::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sbuf {
    _unused: [u8; 0],
}
extern "C" {
    pub fn sbuf_new_for_sysctl(arg1: *mut sbuf,
                               arg2: *mut ::kernel::sys::raw::c_char,
                               arg3: ::kernel::sys::raw::c_int,
                               arg4: *mut sysctl_req) -> *mut sbuf;
}
pub type task_fn_t =
    ::core::option::Option<unsafe extern "C" fn(context:
                                                    *mut ::kernel::sys::raw::c_void,
                                                pending:
                                                    ::kernel::sys::raw::c_int)>;
pub type gtask_fn_t =
    ::core::option::Option<unsafe extern "C" fn(context:
                                                    *mut ::kernel::sys::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct task {
    pub ta_link: task__bindgen_ty_1,
    pub ta_pending: u16,
    pub ta_priority: u_short,
    pub ta_func: task_fn_t,
    pub ta_context: *mut ::kernel::sys::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct task__bindgen_ty_1 {
    pub stqe_next: *mut task,
}
#[test]
fn bindgen_test_layout_task__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<task__bindgen_ty_1>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( task__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<task__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( task__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const task__bindgen_ty_1 ) ) . stqe_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( task__bindgen_ty_1 ) ,
                "::" , stringify ! ( stqe_next ) ));
}
impl Clone for task__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for task__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_task() {
    assert_eq!(::core::mem::size_of::<task>() , 32usize , concat ! (
               "Size of: " , stringify ! ( task ) ));
    assert_eq! (::core::mem::align_of::<task>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( task ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const task ) ) . ta_link as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( task ) , "::" ,
                stringify ! ( ta_link ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const task ) ) . ta_pending as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( task ) , "::" ,
                stringify ! ( ta_pending ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const task ) ) . ta_priority as * const _ as
                usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( task ) , "::" ,
                stringify ! ( ta_priority ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const task ) ) . ta_func as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( task ) , "::" ,
                stringify ! ( ta_func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const task ) ) . ta_context as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( task ) , "::" ,
                stringify ! ( ta_context ) ));
}
impl Clone for task {
    fn clone(&self) -> Self { *self }
}
impl Default for task {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct gtask {
    pub ta_link: gtask__bindgen_ty_1,
    pub ta_flags: u16,
    pub ta_priority: u_short,
    pub ta_func: gtask_fn_t,
    pub ta_context: *mut ::kernel::sys::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct gtask__bindgen_ty_1 {
    pub stqe_next: *mut gtask,
}
#[test]
fn bindgen_test_layout_gtask__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<gtask__bindgen_ty_1>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( gtask__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<gtask__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( gtask__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gtask__bindgen_ty_1 ) ) . stqe_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( gtask__bindgen_ty_1 ) ,
                "::" , stringify ! ( stqe_next ) ));
}
impl Clone for gtask__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for gtask__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_gtask() {
    assert_eq!(::core::mem::size_of::<gtask>() , 32usize , concat ! (
               "Size of: " , stringify ! ( gtask ) ));
    assert_eq! (::core::mem::align_of::<gtask>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( gtask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gtask ) ) . ta_link as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( gtask ) , "::" ,
                stringify ! ( ta_link ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gtask ) ) . ta_flags as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( gtask ) , "::" ,
                stringify ! ( ta_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gtask ) ) . ta_priority as * const _ as
                usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( gtask ) , "::" ,
                stringify ! ( ta_priority ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gtask ) ) . ta_func as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( gtask ) , "::" ,
                stringify ! ( ta_func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const gtask ) ) . ta_context as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( gtask ) , "::" ,
                stringify ! ( ta_context ) ));
}
impl Clone for gtask {
    fn clone(&self) -> Self { *self }
}
impl Default for gtask {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct grouptask {
    pub gt_task: gtask,
    pub gt_taskqueue: *mut ::kernel::sys::raw::c_void,
    pub gt_list: grouptask__bindgen_ty_1,
    pub gt_uniq: *mut ::kernel::sys::raw::c_void,
    pub gt_name: [::kernel::sys::raw::c_char; 32usize],
    pub gt_irq: i16,
    pub gt_cpu: i16,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct grouptask__bindgen_ty_1 {
    pub le_next: *mut grouptask,
    pub le_prev: *mut *mut grouptask,
}
#[test]
fn bindgen_test_layout_grouptask__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<grouptask__bindgen_ty_1>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( grouptask__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<grouptask__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( grouptask__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const grouptask__bindgen_ty_1 ) ) . le_next as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( grouptask__bindgen_ty_1
                ) , "::" , stringify ! ( le_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const grouptask__bindgen_ty_1 ) ) . le_prev as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( grouptask__bindgen_ty_1
                ) , "::" , stringify ! ( le_prev ) ));
}
impl Clone for grouptask__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for grouptask__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_grouptask() {
    assert_eq!(::core::mem::size_of::<grouptask>() , 104usize , concat ! (
               "Size of: " , stringify ! ( grouptask ) ));
    assert_eq! (::core::mem::align_of::<grouptask>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( grouptask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const grouptask ) ) . gt_task as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( grouptask ) , "::" ,
                stringify ! ( gt_task ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const grouptask ) ) . gt_taskqueue as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( grouptask ) , "::" ,
                stringify ! ( gt_taskqueue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const grouptask ) ) . gt_list as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( grouptask ) , "::" ,
                stringify ! ( gt_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const grouptask ) ) . gt_uniq as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( grouptask ) , "::" ,
                stringify ! ( gt_uniq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const grouptask ) ) . gt_name as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( grouptask ) , "::" ,
                stringify ! ( gt_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const grouptask ) ) . gt_irq as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( grouptask ) , "::" ,
                stringify ! ( gt_irq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const grouptask ) ) . gt_cpu as * const _ as
                usize } , 98usize , concat ! (
                "Alignment of field: " , stringify ! ( grouptask ) , "::" ,
                stringify ! ( gt_cpu ) ));
}
impl Clone for grouptask {
    fn clone(&self) -> Self { *self }
}
impl Default for grouptask {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct taskqueue {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct taskqgroup {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy)]
pub struct timeout_task {
    pub q: *mut taskqueue,
    pub t: task,
    pub c: callout,
    pub f: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_timeout_task() {
    assert_eq!(::core::mem::size_of::<timeout_task>() , 112usize , concat ! (
               "Size of: " , stringify ! ( timeout_task ) ));
    assert_eq! (::core::mem::align_of::<timeout_task>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( timeout_task ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeout_task ) ) . q as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( timeout_task ) , "::" ,
                stringify ! ( q ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeout_task ) ) . t as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( timeout_task ) , "::" ,
                stringify ! ( t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeout_task ) ) . c as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( timeout_task ) , "::" ,
                stringify ! ( c ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const timeout_task ) ) . f as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( timeout_task ) , "::" ,
                stringify ! ( f ) ));
}
impl Clone for timeout_task {
    fn clone(&self) -> Self { *self }
}
impl Default for timeout_task {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for timeout_task {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "timeout_task {{ q: {:?}, t: {:?}, c: {:?}, f: {:?} }}" ,
               self . q , self . t , self . c , self . f)
    }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum taskqueue_callback_type {
    TASKQUEUE_CALLBACK_TYPE_INIT = 0,
    TASKQUEUE_CALLBACK_TYPE_SHUTDOWN = 1,
}
pub type taskqueue_callback_fn =
    ::core::option::Option<unsafe extern "C" fn(context:
                                                    *mut ::kernel::sys::raw::c_void)>;
pub type taskqueue_enqueue_fn =
    ::core::option::Option<unsafe extern "C" fn(context:
                                                    *mut ::kernel::sys::raw::c_void)>;
extern "C" {
    pub fn taskqueue_create(name: *const ::kernel::sys::raw::c_char,
                            mflags: ::kernel::sys::raw::c_int,
                            enqueue: taskqueue_enqueue_fn,
                            context: *mut ::kernel::sys::raw::c_void)
     -> *mut taskqueue;
}
extern "C" {
    pub fn taskqueue_start_threads(tqp: *mut *mut taskqueue,
                                   count: ::kernel::sys::raw::c_int,
                                   pri: ::kernel::sys::raw::c_int,
                                   name:
                                       *const ::kernel::sys::raw::c_char, ...)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn taskqueue_start_threads_cpuset(tqp: *mut *mut taskqueue,
                                          count: ::kernel::sys::raw::c_int,
                                          pri: ::kernel::sys::raw::c_int,
                                          mask: *mut cpuset_t,
                                          name:
                                              *const ::kernel::sys::raw::c_char, ...)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn taskqueue_enqueue(queue: *mut taskqueue, task: *mut task)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn taskqueue_enqueue_timeout(queue: *mut taskqueue,
                                     timeout_task: *mut timeout_task,
                                     ticks: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn taskqueue_enqueue_timeout_sbt(queue: *mut taskqueue,
                                         timeout_task: *mut timeout_task,
                                         sbt: sbintime_t, pr: sbintime_t,
                                         flags: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn taskqueue_poll_is_busy(queue: *mut taskqueue, task: *mut task)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn taskqueue_cancel(queue: *mut taskqueue, task: *mut task,
                            pendp: *mut u_int) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn taskqueue_cancel_timeout(queue: *mut taskqueue,
                                    timeout_task: *mut timeout_task,
                                    pendp: *mut u_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn taskqueue_drain(queue: *mut taskqueue, task: *mut task);
}
extern "C" {
    pub fn taskqueue_drain_timeout(queue: *mut taskqueue,
                                   timeout_task: *mut timeout_task);
}
extern "C" {
    pub fn taskqueue_drain_all(queue: *mut taskqueue);
}
extern "C" {
    pub fn taskqueue_free(queue: *mut taskqueue);
}
extern "C" {
    pub fn taskqueue_run(queue: *mut taskqueue);
}
extern "C" {
    pub fn taskqueue_block(queue: *mut taskqueue);
}
extern "C" {
    pub fn taskqueue_unblock(queue: *mut taskqueue);
}
extern "C" {
    pub fn taskqueue_member(queue: *mut taskqueue, td: *mut thread)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn taskqueue_set_callback(queue: *mut taskqueue,
                                  cb_type: taskqueue_callback_type,
                                  callback: taskqueue_callback_fn,
                                  context: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn taskqueue_thread_loop(arg: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn taskqueue_thread_enqueue(context: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn _timeout_task_init(queue: *mut taskqueue,
                              timeout_task: *mut timeout_task,
                              priority: ::kernel::sys::raw::c_int,
                              func: task_fn_t,
                              context: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    #[link_name = "taskqueue_swi_giant"]
    pub static mut taskqueue_swi_giant: *mut taskqueue;
}
extern "C" {
    #[link_name = "taskqueue_swi"]
    pub static mut taskqueue_swi: *mut taskqueue;
}
extern "C" {
    #[link_name = "taskqueue_thread"]
    pub static mut taskqueue_thread: *mut taskqueue;
}
extern "C" {
    #[link_name = "taskqueue_fast"]
    pub static mut taskqueue_fast: *mut taskqueue;
}
extern "C" {
    pub fn taskqueue_create_fast(name: *const ::kernel::sys::raw::c_char,
                                 mflags: ::kernel::sys::raw::c_int,
                                 enqueue: taskqueue_enqueue_fn,
                                 context: *mut ::kernel::sys::raw::c_void)
     -> *mut taskqueue;
}
extern "C" {
    pub fn bus_space_map(tag: bus_space_tag_t, addr: bus_addr_t,
                         size: bus_size_t, flags: ::kernel::sys::raw::c_int,
                         bshp: *mut bus_space_handle_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_space_unmap(tag: bus_space_tag_t, bsh: bus_space_handle_t,
                           size: bus_size_t);
}
extern "C" {
    pub fn bus_space_alloc(t: bus_space_tag_t, rstart: bus_addr_t,
                           rend: bus_addr_t, size: bus_size_t,
                           align: bus_size_t, boundary: bus_size_t,
                           flags: ::kernel::sys::raw::c_int,
                           addrp: *mut bus_addr_t,
                           bshp: *mut bus_space_handle_t)
     -> ::kernel::sys::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ccb {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bio {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct memdesc {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy)]
pub struct pmap {
    pub pm_mtx: mtx,
    pub pm_pml4: *mut pml4_entry_t,
    pub pm_pml4u: *mut pml4_entry_t,
    pub pm_cr3: u64,
    pub pm_ucr3: u64,
    pub pm_pvchunk: pmap__bindgen_ty_1,
    pub pm_active: cpuset_t,
    pub pm_type: pmap_type,
    pub pm_stats: pmap_statistics,
    pub pm_root: vm_radix,
    pub pm_eptgen: ::kernel::sys::raw::c_long,
    pub pm_flags: ::kernel::sys::raw::c_int,
    pub pm_pcids: [pmap_pcids; 256usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pmap__bindgen_ty_1 {
    pub tqh_first: *mut pv_chunk,
    pub tqh_last: *mut *mut pv_chunk,
}
#[test]
fn bindgen_test_layout_pmap__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<pmap__bindgen_ty_1>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( pmap__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<pmap__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( pmap__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pmap__bindgen_ty_1 ) ) . tqh_first as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pmap__bindgen_ty_1 ) ,
                "::" , stringify ! ( tqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pmap__bindgen_ty_1 ) ) . tqh_last as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pmap__bindgen_ty_1 ) ,
                "::" , stringify ! ( tqh_last ) ));
}
impl Clone for pmap__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for pmap__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_pmap() {
    assert_eq!(::core::mem::size_of::<pmap>() , 2208usize , concat ! (
               "Size of: " , stringify ! ( pmap ) ));
    assert_eq! (::core::mem::align_of::<pmap>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pmap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pmap ) ) . pm_mtx as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pmap ) , "::" ,
                stringify ! ( pm_mtx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pmap ) ) . pm_pml4 as * const _ as usize
                } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( pmap ) , "::" ,
                stringify ! ( pm_pml4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pmap ) ) . pm_pml4u as * const _ as usize
                } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( pmap ) , "::" ,
                stringify ! ( pm_pml4u ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pmap ) ) . pm_cr3 as * const _ as usize }
                , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( pmap ) , "::" ,
                stringify ! ( pm_cr3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pmap ) ) . pm_ucr3 as * const _ as usize
                } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( pmap ) , "::" ,
                stringify ! ( pm_ucr3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pmap ) ) . pm_pvchunk as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( pmap ) , "::" ,
                stringify ! ( pm_pvchunk ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pmap ) ) . pm_active as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( pmap ) , "::" ,
                stringify ! ( pm_active ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pmap ) ) . pm_type as * const _ as usize
                } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( pmap ) , "::" ,
                stringify ! ( pm_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pmap ) ) . pm_stats as * const _ as usize
                } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( pmap ) , "::" ,
                stringify ! ( pm_stats ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pmap ) ) . pm_root as * const _ as usize
                } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( pmap ) , "::" ,
                stringify ! ( pm_root ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pmap ) ) . pm_eptgen as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( pmap ) , "::" ,
                stringify ! ( pm_eptgen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pmap ) ) . pm_flags as * const _ as usize
                } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( pmap ) , "::" ,
                stringify ! ( pm_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pmap ) ) . pm_pcids as * const _ as usize
                } , 156usize , concat ! (
                "Alignment of field: " , stringify ! ( pmap ) , "::" ,
                stringify ! ( pm_pcids ) ));
}
impl Clone for pmap {
    fn clone(&self) -> Self { *self }
}
impl Default for pmap {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for pmap {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "pmap {{ pm_mtx: {:?}, pm_pml4: {:?}, pm_pml4u: {:?}, pm_cr3: {:?}, pm_ucr3: {:?}, pm_pvchunk: {:?}, pm_active: {:?}, pm_type: {:?}, pm_stats: {:?}, pm_root: {:?}, pm_eptgen: {:?}, pm_flags: {:?}, pm_pcids: [{}] }}"
               , self . pm_mtx , self . pm_pml4 , self . pm_pml4u , self .
               pm_cr3 , self . pm_ucr3 , self . pm_pvchunk , self . pm_active
               , self . pm_type , self . pm_stats , self . pm_root , self .
               pm_eptgen , self . pm_flags , self . pm_pcids . iter (  ) .
               enumerate (  ) . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ))
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct bus_dma_segment {
    pub ds_addr: bus_addr_t,
    pub ds_len: bus_size_t,
}
#[test]
fn bindgen_test_layout_bus_dma_segment() {
    assert_eq!(::core::mem::size_of::<bus_dma_segment>() , 16usize , concat !
               ( "Size of: " , stringify ! ( bus_dma_segment ) ));
    assert_eq! (::core::mem::align_of::<bus_dma_segment>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( bus_dma_segment ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_segment ) ) . ds_addr as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_segment ) ,
                "::" , stringify ! ( ds_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_segment ) ) . ds_len as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_segment ) ,
                "::" , stringify ! ( ds_len ) ));
}
impl Clone for bus_dma_segment {
    fn clone(&self) -> Self { *self }
}
pub type bus_dma_segment_t = bus_dma_segment;
pub type bus_dma_filter_t =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: bus_addr_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    pub fn busdma_lock_mutex(arg: *mut ::kernel::sys::raw::c_void,
                             op: bus_dma_lock_op_t);
}
extern "C" {
    pub fn bus_dma_tag_create(parent: bus_dma_tag_t, alignment: bus_size_t,
                              boundary: bus_addr_t, lowaddr: bus_addr_t,
                              highaddr: bus_addr_t,
                              filtfunc: bus_dma_filter_t,
                              filtfuncarg: *mut ::kernel::sys::raw::c_void,
                              maxsize: bus_size_t,
                              nsegments: ::kernel::sys::raw::c_int,
                              maxsegsz: bus_size_t,
                              flags: ::kernel::sys::raw::c_int,
                              lockfunc: bus_dma_lock_t,
                              lockfuncarg: *mut ::kernel::sys::raw::c_void,
                              dmat: *mut bus_dma_tag_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_dma_tag_set_domain(dmat: bus_dma_tag_t,
                                  domain: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_dma_tag_destroy(dmat: bus_dma_tag_t)
     -> ::kernel::sys::raw::c_int;
}
pub type bus_dmamap_callback_t =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut bus_dma_segment_t,
                                                arg3:
                                                    ::kernel::sys::raw::c_int,
                                                arg4:
                                                    ::kernel::sys::raw::c_int)>;
pub type bus_dmamap_callback2_t =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut bus_dma_segment_t,
                                                arg3:
                                                    ::kernel::sys::raw::c_int,
                                                arg4: bus_size_t,
                                                arg5:
                                                    ::kernel::sys::raw::c_int)>;
extern "C" {
    pub fn bus_dmamap_load(dmat: bus_dma_tag_t, map: bus_dmamap_t,
                           buf: *mut ::kernel::sys::raw::c_void,
                           buflen: bus_size_t,
                           callback: bus_dmamap_callback_t,
                           callback_arg: *mut ::kernel::sys::raw::c_void,
                           flags: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_dmamap_load_mbuf(dmat: bus_dma_tag_t, map: bus_dmamap_t,
                                mbuf: *mut mbuf,
                                callback: bus_dmamap_callback2_t,
                                callback_arg: *mut ::kernel::sys::raw::c_void,
                                flags: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_dmamap_load_mbuf_sg(dmat: bus_dma_tag_t, map: bus_dmamap_t,
                                   mbuf: *mut mbuf,
                                   segs: *mut bus_dma_segment_t,
                                   nsegs: *mut ::kernel::sys::raw::c_int,
                                   flags: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_dmamap_load_uio(dmat: bus_dma_tag_t, map: bus_dmamap_t,
                               ui: *mut uio, callback: bus_dmamap_callback2_t,
                               callback_arg: *mut ::kernel::sys::raw::c_void,
                               flags: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_dmamap_load_ccb(dmat: bus_dma_tag_t, map: bus_dmamap_t,
                               ccb: *mut ccb, callback: bus_dmamap_callback_t,
                               callback_arg: *mut ::kernel::sys::raw::c_void,
                               flags: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_dmamap_load_bio(dmat: bus_dma_tag_t, map: bus_dmamap_t,
                               bio: *mut bio, callback: bus_dmamap_callback_t,
                               callback_arg: *mut ::kernel::sys::raw::c_void,
                               flags: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_dmamap_load_mem(dmat: bus_dma_tag_t, map: bus_dmamap_t,
                               mem: *mut memdesc,
                               callback: bus_dmamap_callback_t,
                               callback_arg: *mut ::kernel::sys::raw::c_void,
                               flags: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bus_dmamap_load_ma_triv(dmat: bus_dma_tag_t, map: bus_dmamap_t,
                                   ma: *mut *mut vm_page, tlen: bus_size_t,
                                   ma_offs: ::kernel::sys::raw::c_int,
                                   flags: ::kernel::sys::raw::c_int,
                                   segs: *mut bus_dma_segment_t,
                                   segp: *mut ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct bus_dma_tag_common {
    pub impl_: *mut bus_dma_impl,
    pub parent: *mut bus_dma_tag_common,
    pub alignment: bus_size_t,
    pub boundary: bus_addr_t,
    pub lowaddr: bus_addr_t,
    pub highaddr: bus_addr_t,
    pub filter: bus_dma_filter_t,
    pub filterarg: *mut ::kernel::sys::raw::c_void,
    pub maxsize: bus_size_t,
    pub nsegments: u_int,
    pub maxsegsz: bus_size_t,
    pub flags: ::kernel::sys::raw::c_int,
    pub lockfunc: bus_dma_lock_t,
    pub lockfuncarg: *mut ::kernel::sys::raw::c_void,
    pub ref_count: ::kernel::sys::raw::c_int,
    pub domain: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_bus_dma_tag_common() {
    assert_eq!(::core::mem::size_of::<bus_dma_tag_common>() , 120usize ,
               concat ! ( "Size of: " , stringify ! ( bus_dma_tag_common ) ));
    assert_eq! (::core::mem::align_of::<bus_dma_tag_common>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( bus_dma_tag_common ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_tag_common ) ) . impl_ as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_tag_common ) ,
                "::" , stringify ! ( impl_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_tag_common ) ) . parent as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_tag_common ) ,
                "::" , stringify ! ( parent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_tag_common ) ) . alignment as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_tag_common ) ,
                "::" , stringify ! ( alignment ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_tag_common ) ) . boundary as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_tag_common ) ,
                "::" , stringify ! ( boundary ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_tag_common ) ) . lowaddr as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_tag_common ) ,
                "::" , stringify ! ( lowaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_tag_common ) ) . highaddr as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_tag_common ) ,
                "::" , stringify ! ( highaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_tag_common ) ) . filter as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_tag_common ) ,
                "::" , stringify ! ( filter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_tag_common ) ) . filterarg as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_tag_common ) ,
                "::" , stringify ! ( filterarg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_tag_common ) ) . maxsize as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_tag_common ) ,
                "::" , stringify ! ( maxsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_tag_common ) ) . nsegments as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_tag_common ) ,
                "::" , stringify ! ( nsegments ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_tag_common ) ) . maxsegsz as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_tag_common ) ,
                "::" , stringify ! ( maxsegsz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_tag_common ) ) . flags as * const
                _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_tag_common ) ,
                "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_tag_common ) ) . lockfunc as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_tag_common ) ,
                "::" , stringify ! ( lockfunc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_tag_common ) ) . lockfuncarg as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_tag_common ) ,
                "::" , stringify ! ( lockfuncarg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_tag_common ) ) . ref_count as *
                const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_tag_common ) ,
                "::" , stringify ! ( ref_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_tag_common ) ) . domain as *
                const _ as usize } , 116usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_tag_common ) ,
                "::" , stringify ! ( domain ) ));
}
impl Clone for bus_dma_tag_common {
    fn clone(&self) -> Self { *self }
}
impl Default for bus_dma_tag_common {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct bus_dma_impl {
    pub tag_create: ::core::option::Option<unsafe extern "C" fn(parent:
                                                                    bus_dma_tag_t,
                                                                alignment:
                                                                    bus_size_t,
                                                                boundary:
                                                                    bus_addr_t,
                                                                lowaddr:
                                                                    bus_addr_t,
                                                                highaddr:
                                                                    bus_addr_t,
                                                                filter:
                                                                    bus_dma_filter_t,
                                                                filterarg:
                                                                    *mut ::kernel::sys::raw::c_void,
                                                                maxsize:
                                                                    bus_size_t,
                                                                nsegments:
                                                                    ::kernel::sys::raw::c_int,
                                                                maxsegsz:
                                                                    bus_size_t,
                                                                flags:
                                                                    ::kernel::sys::raw::c_int,
                                                                lockfunc:
                                                                    bus_dma_lock_t,
                                                                lockfuncarg:
                                                                    *mut ::kernel::sys::raw::c_void,
                                                                dmat:
                                                                    *mut bus_dma_tag_t)
                                               -> ::kernel::sys::raw::c_int>,
    pub tag_destroy: ::core::option::Option<unsafe extern "C" fn(dmat:
                                                                     bus_dma_tag_t)
                                                -> ::kernel::sys::raw::c_int>,
    pub tag_set_domain: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                        bus_dma_tag_t)
                                                   ->
                                                       ::kernel::sys::raw::c_int>,
    pub map_create: ::core::option::Option<unsafe extern "C" fn(dmat:
                                                                    bus_dma_tag_t,
                                                                flags:
                                                                    ::kernel::sys::raw::c_int,
                                                                mapp:
                                                                    *mut bus_dmamap_t)
                                               -> ::kernel::sys::raw::c_int>,
    pub map_destroy: ::core::option::Option<unsafe extern "C" fn(dmat:
                                                                     bus_dma_tag_t,
                                                                 map:
                                                                     bus_dmamap_t)
                                                -> ::kernel::sys::raw::c_int>,
    pub mem_alloc: ::core::option::Option<unsafe extern "C" fn(dmat:
                                                                   bus_dma_tag_t,
                                                               vaddr:
                                                                   *mut *mut ::kernel::sys::raw::c_void,
                                                               flags:
                                                                   ::kernel::sys::raw::c_int,
                                                               mapp:
                                                                   *mut bus_dmamap_t)
                                              -> ::kernel::sys::raw::c_int>,
    pub mem_free: ::core::option::Option<unsafe extern "C" fn(dmat:
                                                                  bus_dma_tag_t,
                                                              vaddr:
                                                                  *mut ::kernel::sys::raw::c_void,
                                                              map:
                                                                  bus_dmamap_t)>,
    pub load_ma: ::core::option::Option<unsafe extern "C" fn(dmat:
                                                                 bus_dma_tag_t,
                                                             map:
                                                                 bus_dmamap_t,
                                                             ma:
                                                                 *mut *mut vm_page,
                                                             tlen: bus_size_t,
                                                             ma_offs:
                                                                 ::kernel::sys::raw::c_int,
                                                             flags:
                                                                 ::kernel::sys::raw::c_int,
                                                             segs:
                                                                 *mut bus_dma_segment_t,
                                                             segp:
                                                                 *mut ::kernel::sys::raw::c_int)
                                            -> ::kernel::sys::raw::c_int>,
    pub load_phys: ::core::option::Option<unsafe extern "C" fn(dmat:
                                                                   bus_dma_tag_t,
                                                               map:
                                                                   bus_dmamap_t,
                                                               buf:
                                                                   vm_paddr_t,
                                                               buflen:
                                                                   bus_size_t,
                                                               flags:
                                                                   ::kernel::sys::raw::c_int,
                                                               segs:
                                                                   *mut bus_dma_segment_t,
                                                               segp:
                                                                   *mut ::kernel::sys::raw::c_int)
                                              -> ::kernel::sys::raw::c_int>,
    pub load_buffer: ::core::option::Option<unsafe extern "C" fn(dmat:
                                                                     bus_dma_tag_t,
                                                                 map:
                                                                     bus_dmamap_t,
                                                                 buf:
                                                                     *mut ::kernel::sys::raw::c_void,
                                                                 buflen:
                                                                     bus_size_t,
                                                                 pmap:
                                                                     *mut pmap,
                                                                 flags:
                                                                     ::kernel::sys::raw::c_int,
                                                                 segs:
                                                                     *mut bus_dma_segment_t,
                                                                 segp:
                                                                     *mut ::kernel::sys::raw::c_int)
                                                -> ::kernel::sys::raw::c_int>,
    pub map_waitok: ::core::option::Option<unsafe extern "C" fn(dmat:
                                                                    bus_dma_tag_t,
                                                                map:
                                                                    bus_dmamap_t,
                                                                mem:
                                                                    *mut memdesc,
                                                                callback:
                                                                    bus_dmamap_callback_t,
                                                                callback_arg:
                                                                    *mut ::kernel::sys::raw::c_void)>,
    pub map_complete: ::core::option::Option<unsafe extern "C" fn(dmat:
                                                                      bus_dma_tag_t,
                                                                  map:
                                                                      bus_dmamap_t,
                                                                  segs:
                                                                      *mut bus_dma_segment_t,
                                                                  nsegs:
                                                                      ::kernel::sys::raw::c_int,
                                                                  error:
                                                                      ::kernel::sys::raw::c_int)
                                                 -> *mut bus_dma_segment_t>,
    pub map_unload: ::core::option::Option<unsafe extern "C" fn(dmat:
                                                                    bus_dma_tag_t,
                                                                map:
                                                                    bus_dmamap_t)>,
    pub map_sync: ::core::option::Option<unsafe extern "C" fn(dmat:
                                                                  bus_dma_tag_t,
                                                              map:
                                                                  bus_dmamap_t,
                                                              op:
                                                                  bus_dmasync_op_t)>,
}
#[test]
fn bindgen_test_layout_bus_dma_impl() {
    assert_eq!(::core::mem::size_of::<bus_dma_impl>() , 112usize , concat ! (
               "Size of: " , stringify ! ( bus_dma_impl ) ));
    assert_eq! (::core::mem::align_of::<bus_dma_impl>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( bus_dma_impl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_impl ) ) . tag_create as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_impl ) , "::" ,
                stringify ! ( tag_create ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_impl ) ) . tag_destroy as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_impl ) , "::" ,
                stringify ! ( tag_destroy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_impl ) ) . tag_set_domain as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_impl ) , "::" ,
                stringify ! ( tag_set_domain ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_impl ) ) . map_create as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_impl ) , "::" ,
                stringify ! ( map_create ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_impl ) ) . map_destroy as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_impl ) , "::" ,
                stringify ! ( map_destroy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_impl ) ) . mem_alloc as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_impl ) , "::" ,
                stringify ! ( mem_alloc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_impl ) ) . mem_free as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_impl ) , "::" ,
                stringify ! ( mem_free ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_impl ) ) . load_ma as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_impl ) , "::" ,
                stringify ! ( load_ma ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_impl ) ) . load_phys as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_impl ) , "::" ,
                stringify ! ( load_phys ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_impl ) ) . load_buffer as * const
                _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_impl ) , "::" ,
                stringify ! ( load_buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_impl ) ) . map_waitok as * const
                _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_impl ) , "::" ,
                stringify ! ( map_waitok ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_impl ) ) . map_complete as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_impl ) , "::" ,
                stringify ! ( map_complete ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_impl ) ) . map_unload as * const
                _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_impl ) , "::" ,
                stringify ! ( map_unload ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bus_dma_impl ) ) . map_sync as * const _
                as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( bus_dma_impl ) , "::" ,
                stringify ! ( map_sync ) ));
}
impl Clone for bus_dma_impl {
    fn clone(&self) -> Self { *self }
}
impl Default for bus_dma_impl {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for bus_dma_impl {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "bus_dma_impl {{ tag_create: FunctionPointer, tag_destroy: {:?}, tag_set_domain: {:?}, map_create: {:?}, map_destroy: {:?}, mem_alloc: {:?}, mem_free: {:?}, load_ma: {:?}, load_phys: {:?}, load_buffer: {:?}, map_waitok: {:?}, map_complete: {:?}, map_unload: {:?}, map_sync: {:?} }}"
               , self . tag_destroy , self . tag_set_domain , self .
               map_create , self . map_destroy , self . mem_alloc , self .
               mem_free , self . load_ma , self . load_phys , self .
               load_buffer , self . map_waitok , self . map_complete , self .
               map_unload , self . map_sync)
    }
}
extern "C" {
    pub fn bus_dma_dflt_lock(arg: *mut ::kernel::sys::raw::c_void,
                             op: bus_dma_lock_op_t);
}
extern "C" {
    pub fn bus_dma_run_filter(dmat: *mut bus_dma_tag_common,
                              paddr: bus_addr_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn common_bus_dma_tag_create(parent: *mut bus_dma_tag_common,
                                     alignment: bus_size_t,
                                     boundary: bus_addr_t,
                                     lowaddr: bus_addr_t,
                                     highaddr: bus_addr_t,
                                     filter: bus_dma_filter_t,
                                     filterarg:
                                         *mut ::kernel::sys::raw::c_void,
                                     maxsize: bus_size_t,
                                     nsegments: ::kernel::sys::raw::c_int,
                                     maxsegsz: bus_size_t,
                                     flags: ::kernel::sys::raw::c_int,
                                     lockfunc: bus_dma_lock_t,
                                     lockfuncarg:
                                         *mut ::kernel::sys::raw::c_void,
                                     sz: usize,
                                     dmat:
                                         *mut *mut ::kernel::sys::raw::c_void)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "bus_dma_bounce_impl"]
    pub static mut bus_dma_bounce_impl: bus_dma_impl;
}
pub type bpf_int32 = i32;
pub type bpf_u_int32 = u_int32_t;
pub type bpf_int64 = i64;
pub type bpf_u_int64 = u_int64_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct bpf_program {
    pub bf_len: u_int,
    pub bf_insns: *mut bpf_insn,
}
#[test]
fn bindgen_test_layout_bpf_program() {
    assert_eq!(::core::mem::size_of::<bpf_program>() , 16usize , concat ! (
               "Size of: " , stringify ! ( bpf_program ) ));
    assert_eq! (::core::mem::align_of::<bpf_program>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( bpf_program ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_program ) ) . bf_len as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_program ) , "::" ,
                stringify ! ( bf_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_program ) ) . bf_insns as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_program ) , "::" ,
                stringify ! ( bf_insns ) ));
}
impl Clone for bpf_program {
    fn clone(&self) -> Self { *self }
}
impl Default for bpf_program {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct bpf_stat {
    pub bs_recv: u_int,
    pub bs_drop: u_int,
}
#[test]
fn bindgen_test_layout_bpf_stat() {
    assert_eq!(::core::mem::size_of::<bpf_stat>() , 8usize , concat ! (
               "Size of: " , stringify ! ( bpf_stat ) ));
    assert_eq! (::core::mem::align_of::<bpf_stat>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( bpf_stat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_stat ) ) . bs_recv as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_stat ) , "::" ,
                stringify ! ( bs_recv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_stat ) ) . bs_drop as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_stat ) , "::" ,
                stringify ! ( bs_drop ) ));
}
impl Clone for bpf_stat {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct bpf_version {
    pub bv_major: u_short,
    pub bv_minor: u_short,
}
#[test]
fn bindgen_test_layout_bpf_version() {
    assert_eq!(::core::mem::size_of::<bpf_version>() , 4usize , concat ! (
               "Size of: " , stringify ! ( bpf_version ) ));
    assert_eq! (::core::mem::align_of::<bpf_version>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( bpf_version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_version ) ) . bv_major as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_version ) , "::" ,
                stringify ! ( bv_major ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_version ) ) . bv_minor as * const _
                as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_version ) , "::" ,
                stringify ! ( bv_minor ) ));
}
impl Clone for bpf_version {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct bpf_zbuf {
    pub bz_bufa: *mut ::kernel::sys::raw::c_void,
    pub bz_bufb: *mut ::kernel::sys::raw::c_void,
    pub bz_buflen: usize,
}
#[test]
fn bindgen_test_layout_bpf_zbuf() {
    assert_eq!(::core::mem::size_of::<bpf_zbuf>() , 24usize , concat ! (
               "Size of: " , stringify ! ( bpf_zbuf ) ));
    assert_eq! (::core::mem::align_of::<bpf_zbuf>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( bpf_zbuf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_zbuf ) ) . bz_bufa as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_zbuf ) , "::" ,
                stringify ! ( bz_bufa ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_zbuf ) ) . bz_bufb as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_zbuf ) , "::" ,
                stringify ! ( bz_bufb ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_zbuf ) ) . bz_buflen as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_zbuf ) , "::" ,
                stringify ! ( bz_buflen ) ));
}
impl Clone for bpf_zbuf {
    fn clone(&self) -> Self { *self }
}
impl Default for bpf_zbuf {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum bpf_direction { BPF_D_IN = 0, BPF_D_INOUT = 1, BPF_D_OUT = 2, }
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct bpf_ts {
    pub bt_sec: bpf_int64,
    pub bt_frac: bpf_u_int64,
}
#[test]
fn bindgen_test_layout_bpf_ts() {
    assert_eq!(::core::mem::size_of::<bpf_ts>() , 16usize , concat ! (
               "Size of: " , stringify ! ( bpf_ts ) ));
    assert_eq! (::core::mem::align_of::<bpf_ts>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( bpf_ts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_ts ) ) . bt_sec as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_ts ) , "::" ,
                stringify ! ( bt_sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_ts ) ) . bt_frac as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_ts ) , "::" ,
                stringify ! ( bt_frac ) ));
}
impl Clone for bpf_ts {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct bpf_xhdr {
    pub bh_tstamp: bpf_ts,
    pub bh_caplen: bpf_u_int32,
    pub bh_datalen: bpf_u_int32,
    pub bh_hdrlen: u_short,
}
#[test]
fn bindgen_test_layout_bpf_xhdr() {
    assert_eq!(::core::mem::size_of::<bpf_xhdr>() , 32usize , concat ! (
               "Size of: " , stringify ! ( bpf_xhdr ) ));
    assert_eq! (::core::mem::align_of::<bpf_xhdr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( bpf_xhdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_xhdr ) ) . bh_tstamp as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_xhdr ) , "::" ,
                stringify ! ( bh_tstamp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_xhdr ) ) . bh_caplen as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_xhdr ) , "::" ,
                stringify ! ( bh_caplen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_xhdr ) ) . bh_datalen as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_xhdr ) , "::" ,
                stringify ! ( bh_datalen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_xhdr ) ) . bh_hdrlen as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_xhdr ) , "::" ,
                stringify ! ( bh_hdrlen ) ));
}
impl Clone for bpf_xhdr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct bpf_hdr {
    pub bh_tstamp: timeval,
    pub bh_caplen: bpf_u_int32,
    pub bh_datalen: bpf_u_int32,
    pub bh_hdrlen: u_short,
}
#[test]
fn bindgen_test_layout_bpf_hdr() {
    assert_eq!(::core::mem::size_of::<bpf_hdr>() , 32usize , concat ! (
               "Size of: " , stringify ! ( bpf_hdr ) ));
    assert_eq! (::core::mem::align_of::<bpf_hdr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( bpf_hdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_hdr ) ) . bh_tstamp as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_hdr ) , "::" ,
                stringify ! ( bh_tstamp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_hdr ) ) . bh_caplen as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_hdr ) , "::" ,
                stringify ! ( bh_caplen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_hdr ) ) . bh_datalen as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_hdr ) , "::" ,
                stringify ! ( bh_datalen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_hdr ) ) . bh_hdrlen as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_hdr ) , "::" ,
                stringify ! ( bh_hdrlen ) ));
}
impl Clone for bpf_hdr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct bpf_zbuf_header {
    pub bzh_kernel_gen: u_int,
    pub bzh_kernel_len: u_int,
    pub bzh_user_gen: u_int,
    pub _bzh_pad: [u_int; 5usize],
}
#[test]
fn bindgen_test_layout_bpf_zbuf_header() {
    assert_eq!(::core::mem::size_of::<bpf_zbuf_header>() , 32usize , concat !
               ( "Size of: " , stringify ! ( bpf_zbuf_header ) ));
    assert_eq! (::core::mem::align_of::<bpf_zbuf_header>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( bpf_zbuf_header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_zbuf_header ) ) . bzh_kernel_gen as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_zbuf_header ) ,
                "::" , stringify ! ( bzh_kernel_gen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_zbuf_header ) ) . bzh_kernel_len as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_zbuf_header ) ,
                "::" , stringify ! ( bzh_kernel_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_zbuf_header ) ) . bzh_user_gen as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_zbuf_header ) ,
                "::" , stringify ! ( bzh_user_gen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_zbuf_header ) ) . _bzh_pad as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_zbuf_header ) ,
                "::" , stringify ! ( _bzh_pad ) ));
}
impl Clone for bpf_zbuf_header {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct bpf_insn {
    pub code: u_short,
    pub jt: u_char,
    pub jf: u_char,
    pub k: bpf_u_int32,
}
#[test]
fn bindgen_test_layout_bpf_insn() {
    assert_eq!(::core::mem::size_of::<bpf_insn>() , 8usize , concat ! (
               "Size of: " , stringify ! ( bpf_insn ) ));
    assert_eq! (::core::mem::align_of::<bpf_insn>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( bpf_insn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_insn ) ) . code as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_insn ) , "::" ,
                stringify ! ( code ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_insn ) ) . jt as * const _ as usize }
                , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_insn ) , "::" ,
                stringify ! ( jt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_insn ) ) . jf as * const _ as usize }
                , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_insn ) , "::" ,
                stringify ! ( jf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_insn ) ) . k as * const _ as usize }
                , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_insn ) , "::" ,
                stringify ! ( k ) ));
}
impl Clone for bpf_insn {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct bpf_dltlist {
    pub bfl_len: u_int,
    pub bfl_list: *mut u_int,
}
#[test]
fn bindgen_test_layout_bpf_dltlist() {
    assert_eq!(::core::mem::size_of::<bpf_dltlist>() , 16usize , concat ! (
               "Size of: " , stringify ! ( bpf_dltlist ) ));
    assert_eq! (::core::mem::align_of::<bpf_dltlist>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( bpf_dltlist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_dltlist ) ) . bfl_len as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_dltlist ) , "::" ,
                stringify ! ( bfl_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_dltlist ) ) . bfl_list as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_dltlist ) , "::" ,
                stringify ! ( bfl_list ) ));
}
impl Clone for bpf_dltlist {
    fn clone(&self) -> Self { *self }
}
impl Default for bpf_dltlist {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    #[link_name = "M_BPF"]
    pub static mut M_BPF: [malloc_type; 1usize];
}
extern "C" {
    #[link_name = "sysctl___net_bpf"]
    pub static mut sysctl___net_bpf: sysctl_oid;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bpf_if {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct bpf_if_ext {
    pub bif_next: bpf_if_ext__bindgen_ty_1,
    pub bif_dlist: bpf_if_ext__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct bpf_if_ext__bindgen_ty_1 {
    pub le_next: *mut bpf_if,
    pub le_prev: *mut *mut bpf_if,
}
#[test]
fn bindgen_test_layout_bpf_if_ext__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<bpf_if_ext__bindgen_ty_1>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( bpf_if_ext__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<bpf_if_ext__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( bpf_if_ext__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_if_ext__bindgen_ty_1 ) ) . le_next as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                bpf_if_ext__bindgen_ty_1 ) , "::" , stringify ! ( le_next )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_if_ext__bindgen_ty_1 ) ) . le_prev as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                bpf_if_ext__bindgen_ty_1 ) , "::" , stringify ! ( le_prev )
                ));
}
impl Clone for bpf_if_ext__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for bpf_if_ext__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct bpf_if_ext__bindgen_ty_2 {
    pub lh_first: *mut bpf_d,
}
#[test]
fn bindgen_test_layout_bpf_if_ext__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<bpf_if_ext__bindgen_ty_2>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( bpf_if_ext__bindgen_ty_2 ) ));
    assert_eq! (::core::mem::align_of::<bpf_if_ext__bindgen_ty_2>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( bpf_if_ext__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_if_ext__bindgen_ty_2 ) ) . lh_first
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                bpf_if_ext__bindgen_ty_2 ) , "::" , stringify ! ( lh_first )
                ));
}
impl Clone for bpf_if_ext__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for bpf_if_ext__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_bpf_if_ext() {
    assert_eq!(::core::mem::size_of::<bpf_if_ext>() , 24usize , concat ! (
               "Size of: " , stringify ! ( bpf_if_ext ) ));
    assert_eq! (::core::mem::align_of::<bpf_if_ext>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( bpf_if_ext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_if_ext ) ) . bif_next as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_if_ext ) , "::" ,
                stringify ! ( bif_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const bpf_if_ext ) ) . bif_dlist as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( bpf_if_ext ) , "::" ,
                stringify ! ( bif_dlist ) ));
}
impl Clone for bpf_if_ext {
    fn clone(&self) -> Self { *self }
}
impl Default for bpf_if_ext {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    pub fn bpf_bufheld(d: *mut bpf_d);
}
extern "C" {
    pub fn bpf_validate(arg1: *const bpf_insn,
                        arg2: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn bpf_tap(arg1: *mut bpf_if, arg2: *mut u_char, arg3: u_int);
}
extern "C" {
    pub fn bpf_mtap(arg1: *mut bpf_if, arg2: *mut mbuf);
}
extern "C" {
    pub fn bpf_mtap2(arg1: *mut bpf_if, arg2: *mut ::kernel::sys::raw::c_void,
                     arg3: u_int, arg4: *mut mbuf);
}
extern "C" {
    pub fn bpfattach(arg1: *mut ifnet, arg2: u_int, arg3: u_int);
}
extern "C" {
    pub fn bpfattach2(arg1: *mut ifnet, arg2: u_int, arg3: u_int,
                      arg4: *mut *mut bpf_if);
}
extern "C" {
    pub fn bpfdetach(arg1: *mut ifnet);
}
extern "C" {
    pub fn bpfilterattach(arg1: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn bpf_filter(arg1: *const bpf_insn, arg2: *mut u_char, arg3: u_int,
                      arg4: u_int) -> u_int;
}
#[repr(C)]
#[derive(Copy)]
pub struct ifnet {
    pub if_link: ifnet__bindgen_ty_1,
    pub if_clones: ifnet__bindgen_ty_2,
    pub if_groups: ifnet__bindgen_ty_3,
    pub if_alloctype: u_char,
    pub if_softc: *mut ::kernel::sys::raw::c_void,
    pub if_llsoftc: *mut ::kernel::sys::raw::c_void,
    pub if_l2com: *mut ::kernel::sys::raw::c_void,
    pub if_dname: *const ::kernel::sys::raw::c_char,
    pub if_dunit: ::kernel::sys::raw::c_int,
    pub if_index: u_short,
    pub if_index_reserved: ::kernel::sys::raw::c_short,
    pub if_xname: [::kernel::sys::raw::c_char; 16usize],
    pub if_description: *mut ::kernel::sys::raw::c_char,
    pub if_flags: ::kernel::sys::raw::c_int,
    pub if_drv_flags: ::kernel::sys::raw::c_int,
    pub if_capabilities: ::kernel::sys::raw::c_int,
    pub if_capenable: ::kernel::sys::raw::c_int,
    pub if_linkmib: *mut ::kernel::sys::raw::c_void,
    pub if_linkmiblen: usize,
    pub if_refcount: u_int,
    pub if_type: u8,
    pub if_addrlen: u8,
    pub if_hdrlen: u8,
    pub if_link_state: u8,
    pub if_mtu: u32,
    pub if_metric: u32,
    pub if_baudrate: u64,
    pub if_hwassist: u64,
    pub if_epoch: time_t,
    pub if_lastchange: timeval,
    pub if_snd: ifaltq,
    pub if_linktask: task,
    pub if_addr_lock: mtx,
    pub if_addrhead: ifaddrhead,
    pub if_multiaddrs: ifmultihead,
    pub if_amcount: ::kernel::sys::raw::c_int,
    pub if_addr: *mut ifaddr,
    pub if_hw_addr: *mut ::kernel::sys::raw::c_void,
    pub if_broadcastaddr: *const u_int8_t,
    pub if_afdata_lock: mtx,
    pub if_afdata: [*mut ::kernel::sys::raw::c_void; 42usize],
    pub if_afdata_initialized: ::kernel::sys::raw::c_int,
    pub if_fib: u_int,
    pub if_vnet: *mut vnet,
    pub if_home_vnet: *mut vnet,
    pub if_vlantrunk: *mut ifvlantrunk,
    pub if_bpf: *mut bpf_if,
    pub if_pcount: ::kernel::sys::raw::c_int,
    pub if_bridge: *mut ::kernel::sys::raw::c_void,
    pub if_lagg: *mut ::kernel::sys::raw::c_void,
    pub if_pf_kif: *mut ::kernel::sys::raw::c_void,
    pub if_carp: *mut carp_if,
    pub if_label: *mut label,
    pub if_netmap: *mut netmap_adapter,
    pub if_output: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                   *mut ifnet,
                                                               arg2:
                                                                   *mut mbuf,
                                                               arg3:
                                                                   *const sockaddr,
                                                               arg4:
                                                                   *mut route)
                                              -> ::kernel::sys::raw::c_int>,
    pub if_input: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                  *mut ifnet,
                                                              arg2:
                                                                  *mut mbuf)>,
    pub if_bridge_input: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                         *mut ifnet,
                                                                     arg2:
                                                                         *mut mbuf)
                                                    -> *mut mbuf>,
    pub if_bridge_output: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                          *mut ifnet,
                                                                      arg2:
                                                                          *mut mbuf,
                                                                      arg3:
                                                                          *mut sockaddr,
                                                                      arg4:
                                                                          *mut rtentry)
                                                     ->
                                                         ::kernel::sys::raw::c_int>,
    pub if_bridge_linkstate: ::core::option::Option<unsafe extern "C" fn(ifp:
                                                                             *mut ifnet)>,
    pub if_start: if_start_fn_t,
    pub if_ioctl: if_ioctl_fn_t,
    pub if_init: if_init_fn_t,
    pub if_resolvemulti: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                         *mut ifnet,
                                                                     arg2:
                                                                         *mut *mut sockaddr,
                                                                     arg3:
                                                                         *mut sockaddr)
                                                    ->
                                                        ::kernel::sys::raw::c_int>,
    pub if_qflush: if_qflush_fn_t,
    pub if_transmit: if_transmit_fn_t,
    pub if_reassign: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                     *mut ifnet,
                                                                 arg2:
                                                                     *mut vnet,
                                                                 arg3:
                                                                     *mut ::kernel::sys::raw::c_char)>,
    pub if_get_counter: if_get_counter_t,
    pub if_requestencap: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                         *mut ifnet,
                                                                     arg2:
                                                                         *mut if_encap_req)
                                                    ->
                                                        ::kernel::sys::raw::c_int>,
    pub if_counters: [counter_u64_t; 12usize],
    pub if_hw_tsomax: u_int,
    pub if_hw_tsomaxsegcount: u_int,
    pub if_hw_tsomaxsegsize: u_int,
    pub if_snd_tag_alloc: if_snd_tag_alloc_t,
    pub if_snd_tag_modify: if_snd_tag_modify_t,
    pub if_snd_tag_query: if_snd_tag_query_t,
    pub if_snd_tag_free: if_snd_tag_free_t,
    pub if_pcp: u8,
    pub if_netdump_methods: *mut netdump_methods,
    pub if_epoch_ctx: epoch_context,
    pub if_ispare: [::kernel::sys::raw::c_int; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifnet__bindgen_ty_1 {
    pub cstqe_next: *mut ifnet,
}
#[test]
fn bindgen_test_layout_ifnet__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<ifnet__bindgen_ty_1>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( ifnet__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<ifnet__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( ifnet__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet__bindgen_ty_1 ) ) . cstqe_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet__bindgen_ty_1 ) ,
                "::" , stringify ! ( cstqe_next ) ));
}
impl Clone for ifnet__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for ifnet__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifnet__bindgen_ty_2 {
    pub le_next: *mut ifnet,
    pub le_prev: *mut *mut ifnet,
}
#[test]
fn bindgen_test_layout_ifnet__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<ifnet__bindgen_ty_2>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( ifnet__bindgen_ty_2 )
               ));
    assert_eq! (::core::mem::align_of::<ifnet__bindgen_ty_2>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( ifnet__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet__bindgen_ty_2 ) ) . le_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet__bindgen_ty_2 ) ,
                "::" , stringify ! ( le_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet__bindgen_ty_2 ) ) . le_prev as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet__bindgen_ty_2 ) ,
                "::" , stringify ! ( le_prev ) ));
}
impl Clone for ifnet__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for ifnet__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifnet__bindgen_ty_3 {
    pub cstqh_first: *mut ifg_list,
    pub cstqh_last: *mut *mut ifg_list,
}
#[test]
fn bindgen_test_layout_ifnet__bindgen_ty_3() {
    assert_eq!(::core::mem::size_of::<ifnet__bindgen_ty_3>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( ifnet__bindgen_ty_3 )
               ));
    assert_eq! (::core::mem::align_of::<ifnet__bindgen_ty_3>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( ifnet__bindgen_ty_3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet__bindgen_ty_3 ) ) . cstqh_first as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet__bindgen_ty_3 ) ,
                "::" , stringify ! ( cstqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet__bindgen_ty_3 ) ) . cstqh_last as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet__bindgen_ty_3 ) ,
                "::" , stringify ! ( cstqh_last ) ));
}
impl Clone for ifnet__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
impl Default for ifnet__bindgen_ty_3 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_ifnet() {
    assert_eq!(::core::mem::size_of::<ifnet>() , 1256usize , concat ! (
               "Size of: " , stringify ! ( ifnet ) ));
    assert_eq! (::core::mem::align_of::<ifnet>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ifnet ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_link as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_link ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_clones as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_clones ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_groups as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_groups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_alloctype as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_alloctype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_softc as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_softc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_llsoftc as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_llsoftc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_l2com as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_l2com ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_dname as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_dname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_dunit as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_dunit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_index as * const _ as
                usize } , 84usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_index_reserved as * const
                _ as usize } , 86usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_index_reserved ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_xname as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_xname ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_description as * const _
                as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_description ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_flags as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_drv_flags as * const _ as
                usize } , 116usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_drv_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_capabilities as * const _
                as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_capabilities ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_capenable as * const _ as
                usize } , 124usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_capenable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_linkmib as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_linkmib ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_linkmiblen as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_linkmiblen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_refcount as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_refcount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_type as * const _ as usize
                } , 148usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_addrlen as * const _ as
                usize } , 149usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_addrlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_hdrlen as * const _ as
                usize } , 150usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_hdrlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_link_state as * const _ as
                usize } , 151usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_link_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_mtu as * const _ as usize
                } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_mtu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_metric as * const _ as
                usize } , 156usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_metric ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_baudrate as * const _ as
                usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_baudrate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_hwassist as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_hwassist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_epoch as * const _ as
                usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_epoch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_lastchange as * const _ as
                usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_lastchange ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_snd as * const _ as usize
                } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_snd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_linktask as * const _ as
                usize } , 360usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_linktask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_addr_lock as * const _ as
                usize } , 392usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_addr_lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_addrhead as * const _ as
                usize } , 424usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_addrhead ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_multiaddrs as * const _ as
                usize } , 440usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_multiaddrs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_amcount as * const _ as
                usize } , 456usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_amcount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_addr as * const _ as usize
                } , 464usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_hw_addr as * const _ as
                usize } , 472usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_hw_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_broadcastaddr as * const _
                as usize } , 480usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_broadcastaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_afdata_lock as * const _
                as usize } , 488usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_afdata_lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_afdata as * const _ as
                usize } , 520usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_afdata ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_afdata_initialized as *
                const _ as usize } , 856usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_afdata_initialized ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_fib as * const _ as usize
                } , 860usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_fib ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_vnet as * const _ as usize
                } , 864usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_vnet ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_home_vnet as * const _ as
                usize } , 872usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_home_vnet ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_vlantrunk as * const _ as
                usize } , 880usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_vlantrunk ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_bpf as * const _ as usize
                } , 888usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_bpf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_pcount as * const _ as
                usize } , 896usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_pcount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_bridge as * const _ as
                usize } , 904usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_bridge ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_lagg as * const _ as usize
                } , 912usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_lagg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_pf_kif as * const _ as
                usize } , 920usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_pf_kif ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_carp as * const _ as usize
                } , 928usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_carp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_label as * const _ as
                usize } , 936usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_label ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_netmap as * const _ as
                usize } , 944usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_netmap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_output as * const _ as
                usize } , 952usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_output ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_input as * const _ as
                usize } , 960usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_input ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_bridge_input as * const _
                as usize } , 968usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_bridge_input ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_bridge_output as * const _
                as usize } , 976usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_bridge_output ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_bridge_linkstate as *
                const _ as usize } , 984usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_bridge_linkstate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_start as * const _ as
                usize } , 992usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_start ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_ioctl as * const _ as
                usize } , 1000usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_ioctl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_init as * const _ as usize
                } , 1008usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_init ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_resolvemulti as * const _
                as usize } , 1016usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_resolvemulti ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_qflush as * const _ as
                usize } , 1024usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_qflush ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_transmit as * const _ as
                usize } , 1032usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_transmit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_reassign as * const _ as
                usize } , 1040usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_reassign ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_get_counter as * const _
                as usize } , 1048usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_get_counter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_requestencap as * const _
                as usize } , 1056usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_requestencap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_counters as * const _ as
                usize } , 1064usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_counters ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_hw_tsomax as * const _ as
                usize } , 1160usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_hw_tsomax ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_hw_tsomaxsegcount as *
                const _ as usize } , 1164usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_hw_tsomaxsegcount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_hw_tsomaxsegsize as *
                const _ as usize } , 1168usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_hw_tsomaxsegsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_snd_tag_alloc as * const _
                as usize } , 1176usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_snd_tag_alloc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_snd_tag_modify as * const
                _ as usize } , 1184usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_snd_tag_modify ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_snd_tag_query as * const _
                as usize } , 1192usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_snd_tag_query ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_snd_tag_free as * const _
                as usize } , 1200usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_snd_tag_free ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_pcp as * const _ as usize
                } , 1208usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_pcp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_netdump_methods as * const
                _ as usize } , 1216usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_netdump_methods ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_epoch_ctx as * const _ as
                usize } , 1224usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_epoch_ctx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet ) ) . if_ispare as * const _ as
                usize } , 1240usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet ) , "::" ,
                stringify ! ( if_ispare ) ));
}
impl Clone for ifnet {
    fn clone(&self) -> Self { *self }
}
impl Default for ifnet {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for ifnet {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "ifnet {{ if_link: {:?}, if_clones: {:?}, if_groups: {:?}, if_alloctype: {:?}, if_softc: {:?}, if_llsoftc: {:?}, if_l2com: {:?}, if_dname: {:?}, if_dunit: {:?}, if_index: {:?}, if_index_reserved: {:?}, if_xname: {:?}, if_description: {:?}, if_flags: {:?}, if_drv_flags: {:?}, if_capabilities: {:?}, if_capenable: {:?}, if_linkmib: {:?}, if_linkmiblen: {:?}, if_refcount: {:?}, if_type: {:?}, if_addrlen: {:?}, if_hdrlen: {:?}, if_link_state: {:?}, if_mtu: {:?}, if_metric: {:?}, if_baudrate: {:?}, if_hwassist: {:?}, if_epoch: {:?}, if_lastchange: {:?}, if_snd: {:?}, if_linktask: {:?}, if_addr_lock: {:?}, if_addrhead: {:?}, if_multiaddrs: {:?}, if_amcount: {:?}, if_addr: {:?}, if_hw_addr: {:?}, if_broadcastaddr: {:?}, if_afdata_lock: {:?}, if_afdata: [{}], if_afdata_initialized: {:?}, if_fib: {:?}, if_vnet: {:?}, if_home_vnet: {:?}, if_vlantrunk: {:?}, if_bpf: {:?}, if_pcount: {:?}, if_bridge: {:?}, if_lagg: {:?}, if_pf_kif: {:?}, if_carp: {:?}, if_label: {:?}, if_netmap: {:?}, if_output: {:?}, if_input: {:?}, if_bridge_input: {:?}, if_bridge_output: {:?}, if_bridge_linkstate: {:?}, if_start: {:?}, if_ioctl: {:?}, if_init: {:?}, if_resolvemulti: {:?}, if_qflush: {:?}, if_transmit: {:?}, if_reassign: {:?}, if_get_counter: {:?}, if_requestencap: {:?}, if_counters: {:?}, if_hw_tsomax: {:?}, if_hw_tsomaxsegcount: {:?}, if_hw_tsomaxsegsize: {:?}, if_snd_tag_alloc: {:?}, if_snd_tag_modify: {:?}, if_snd_tag_query: {:?}, if_snd_tag_free: {:?}, if_pcp: {:?}, if_netdump_methods: {:?}, if_epoch_ctx: {:?}, if_ispare: {:?} }}"
               , self . if_link , self . if_clones , self . if_groups , self .
               if_alloctype , self . if_softc , self . if_llsoftc , self .
               if_l2com , self . if_dname , self . if_dunit , self . if_index
               , self . if_index_reserved , self . if_xname , self .
               if_description , self . if_flags , self . if_drv_flags , self .
               if_capabilities , self . if_capenable , self . if_linkmib ,
               self . if_linkmiblen , self . if_refcount , self . if_type ,
               self . if_addrlen , self . if_hdrlen , self . if_link_state ,
               self . if_mtu , self . if_metric , self . if_baudrate , self .
               if_hwassist , self . if_epoch , self . if_lastchange , self .
               if_snd , self . if_linktask , self . if_addr_lock , self .
               if_addrhead , self . if_multiaddrs , self . if_amcount , self .
               if_addr , self . if_hw_addr , self . if_broadcastaddr , self .
               if_afdata_lock , self . if_afdata . iter (  ) . enumerate (  )
               . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ) , self . if_afdata_initialized , self . if_fib ,
               self . if_vnet , self . if_home_vnet , self . if_vlantrunk ,
               self . if_bpf , self . if_pcount , self . if_bridge , self .
               if_lagg , self . if_pf_kif , self . if_carp , self . if_label ,
               self . if_netmap , self . if_output , self . if_input , self .
               if_bridge_input , self . if_bridge_output , self .
               if_bridge_linkstate , self . if_start , self . if_ioctl , self
               . if_init , self . if_resolvemulti , self . if_qflush , self .
               if_transmit , self . if_reassign , self . if_get_counter , self
               . if_requestencap , self . if_counters , self . if_hw_tsomax ,
               self . if_hw_tsomaxsegcount , self . if_hw_tsomaxsegsize , self
               . if_snd_tag_alloc , self . if_snd_tag_modify , self .
               if_snd_tag_query , self . if_snd_tag_free , self . if_pcp ,
               self . if_netdump_methods , self . if_epoch_ctx , self .
               if_ispare)
    }
}
pub type bpf_track_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut ifnet,
                                                arg3:
                                                    ::kernel::sys::raw::c_int,
                                                arg4:
                                                    ::kernel::sys::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_bpf_track {
    pub ee: eventhandler_entry,
    pub eh_func: bpf_track_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_bpf_track() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_bpf_track>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_bpf_track ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_bpf_track>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_bpf_track )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_bpf_track ) ) . ee as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_bpf_track ) , "::" , stringify ! ( ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_bpf_track ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_bpf_track ) , "::" , stringify ! ( eh_func
                ) ));
}
impl Clone for eventhandler_entry_bpf_track {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_bpf_track {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy)]
pub struct ether_header {
    pub ether_dhost: [u_char; 6usize],
    pub ether_shost: [u_char; 6usize],
    pub ether_type: u_short,
}
#[test]
fn bindgen_test_layout_ether_header() {
    assert_eq!(::core::mem::size_of::<ether_header>() , 14usize , concat ! (
               "Size of: " , stringify ! ( ether_header ) ));
    assert_eq! (::core::mem::align_of::<ether_header>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( ether_header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ether_header ) ) . ether_dhost as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ether_header ) , "::" ,
                stringify ! ( ether_dhost ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ether_header ) ) . ether_shost as * const
                _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( ether_header ) , "::" ,
                stringify ! ( ether_shost ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ether_header ) ) . ether_type as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( ether_header ) , "::" ,
                stringify ! ( ether_type ) ));
}
impl Clone for ether_header {
    fn clone(&self) -> Self { *self }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy)]
pub struct ether_addr {
    pub octet: [u_char; 6usize],
}
#[test]
fn bindgen_test_layout_ether_addr() {
    assert_eq!(::core::mem::size_of::<ether_addr>() , 6usize , concat ! (
               "Size of: " , stringify ! ( ether_addr ) ));
    assert_eq! (::core::mem::align_of::<ether_addr>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( ether_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ether_addr ) ) . octet as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ether_addr ) , "::" ,
                stringify ! ( octet ) ));
}
impl Clone for ether_addr {
    fn clone(&self) -> Self { *self }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy)]
pub struct ether_vlan_header {
    pub evl_dhost: [u8; 6usize],
    pub evl_shost: [u8; 6usize],
    pub evl_encap_proto: u16,
    pub evl_tag: u16,
    pub evl_proto: u16,
}
#[test]
fn bindgen_test_layout_ether_vlan_header() {
    assert_eq!(::core::mem::size_of::<ether_vlan_header>() , 18usize , concat
               ! ( "Size of: " , stringify ! ( ether_vlan_header ) ));
    assert_eq! (::core::mem::align_of::<ether_vlan_header>() , 1usize , concat
                ! ( "Alignment of " , stringify ! ( ether_vlan_header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ether_vlan_header ) ) . evl_dhost as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ether_vlan_header ) ,
                "::" , stringify ! ( evl_dhost ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ether_vlan_header ) ) . evl_shost as *
                const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( ether_vlan_header ) ,
                "::" , stringify ! ( evl_shost ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ether_vlan_header ) ) . evl_encap_proto
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( ether_vlan_header ) ,
                "::" , stringify ! ( evl_encap_proto ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ether_vlan_header ) ) . evl_tag as *
                const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( ether_vlan_header ) ,
                "::" , stringify ! ( evl_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ether_vlan_header ) ) . evl_proto as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ether_vlan_header ) ,
                "::" , stringify ! ( evl_proto ) ));
}
impl Clone for ether_vlan_header {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct route {
    _unused: [u8; 0],
}
extern "C" {
    pub fn ether_crc32_le(arg1: *const u8, arg2: usize) -> u32;
}
extern "C" {
    pub fn ether_crc32_be(arg1: *const u8, arg2: usize) -> u32;
}
extern "C" {
    pub fn ether_demux(arg1: *mut ifnet, arg2: *mut mbuf);
}
extern "C" {
    pub fn ether_ifattach(arg1: *mut ifnet, arg2: *const u_int8_t);
}
extern "C" {
    pub fn ether_ifdetach(arg1: *mut ifnet);
}
extern "C" {
    pub fn ether_ioctl(arg1: *mut ifnet, arg2: u_long, arg3: caddr_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn ether_output(arg1: *mut ifnet, arg2: *mut mbuf,
                        arg3: *const sockaddr, arg4: *mut route)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn ether_output_frame(arg1: *mut ifnet, arg2: *mut mbuf)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn ether_sprintf(arg1: *const u_int8_t)
     -> *mut ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn ether_vlan_mtap(arg1: *mut bpf_if, arg2: *mut mbuf,
                           arg3: *mut ::kernel::sys::raw::c_void,
                           arg4: u_int);
}
extern "C" {
    pub fn ether_vlanencap(arg1: *mut mbuf, arg2: u16) -> *mut mbuf;
}
extern "C" {
    pub fn ether_8021q_frame(mp: *mut *mut mbuf, ife: *mut ifnet,
                             p: *mut ifnet, vid: u16, pcp: u8) -> bool_;
}
pub type ether_ifattach_event_handler_t =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut ifnet)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_ether_ifattach_event {
    pub ee: eventhandler_entry,
    pub eh_func: ether_ifattach_event_handler_t,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_ether_ifattach_event() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_ether_ifattach_event>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_ether_ifattach_event ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_ether_ifattach_event>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_ether_ifattach_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_ether_ifattach_event )
                ) . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_ether_ifattach_event ) , "::" , stringify !
                ( ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_ether_ifattach_event )
                ) . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_ether_ifattach_event ) , "::" , stringify !
                ( eh_func ) ));
}
impl Clone for eventhandler_entry_ether_ifattach_event {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_ether_ifattach_event {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct if_clonereq {
    pub ifcr_total: ::kernel::sys::raw::c_int,
    pub ifcr_count: ::kernel::sys::raw::c_int,
    pub ifcr_buffer: *mut ::kernel::sys::raw::c_char,
}
#[test]
fn bindgen_test_layout_if_clonereq() {
    assert_eq!(::core::mem::size_of::<if_clonereq>() , 16usize , concat ! (
               "Size of: " , stringify ! ( if_clonereq ) ));
    assert_eq! (::core::mem::align_of::<if_clonereq>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( if_clonereq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_clonereq ) ) . ifcr_total as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_clonereq ) , "::" ,
                stringify ! ( ifcr_total ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_clonereq ) ) . ifcr_count as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( if_clonereq ) , "::" ,
                stringify ! ( ifcr_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_clonereq ) ) . ifcr_buffer as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( if_clonereq ) , "::" ,
                stringify ! ( ifcr_buffer ) ));
}
impl Clone for if_clonereq {
    fn clone(&self) -> Self { *self }
}
impl Default for if_clonereq {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct if_data {
    pub ifi_type: u8,
    pub ifi_physical: u8,
    pub ifi_addrlen: u8,
    pub ifi_hdrlen: u8,
    pub ifi_link_state: u8,
    pub ifi_vhid: u8,
    pub ifi_datalen: u16,
    pub ifi_mtu: u32,
    pub ifi_metric: u32,
    pub ifi_baudrate: u64,
    pub ifi_ipackets: u64,
    pub ifi_ierrors: u64,
    pub ifi_opackets: u64,
    pub ifi_oerrors: u64,
    pub ifi_collisions: u64,
    pub ifi_ibytes: u64,
    pub ifi_obytes: u64,
    pub ifi_imcasts: u64,
    pub ifi_omcasts: u64,
    pub ifi_iqdrops: u64,
    pub ifi_oqdrops: u64,
    pub ifi_noproto: u64,
    pub ifi_hwassist: u64,
    pub __ifi_epoch: if_data__bindgen_ty_1,
    pub __ifi_lastchange: if_data__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy)]
pub union if_data__bindgen_ty_1 {
    pub tt: time_t,
    pub ph: u64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_if_data__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<if_data__bindgen_ty_1>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( if_data__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<if_data__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( if_data__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data__bindgen_ty_1 ) ) . tt as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data__bindgen_ty_1 )
                , "::" , stringify ! ( tt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data__bindgen_ty_1 ) ) . ph as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data__bindgen_ty_1 )
                , "::" , stringify ! ( ph ) ));
}
impl Clone for if_data__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for if_data__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for if_data__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "if_data__bindgen_ty_1 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy)]
pub union if_data__bindgen_ty_2 {
    pub tv: timeval,
    pub ph: if_data__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct if_data__bindgen_ty_2__bindgen_ty_1 {
    pub ph1: u64,
    pub ph2: u64,
}
#[test]
fn bindgen_test_layout_if_data__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<if_data__bindgen_ty_2__bindgen_ty_1>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( if_data__bindgen_ty_2__bindgen_ty_1
               ) ));
    assert_eq! (::core::mem::align_of::<if_data__bindgen_ty_2__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                if_data__bindgen_ty_2__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data__bindgen_ty_2__bindgen_ty_1 ) ) .
                ph1 as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                if_data__bindgen_ty_2__bindgen_ty_1 ) , "::" , stringify ! (
                ph1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data__bindgen_ty_2__bindgen_ty_1 ) ) .
                ph2 as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                if_data__bindgen_ty_2__bindgen_ty_1 ) , "::" , stringify ! (
                ph2 ) ));
}
impl Clone for if_data__bindgen_ty_2__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_if_data__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<if_data__bindgen_ty_2>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( if_data__bindgen_ty_2 )
               ));
    assert_eq! (::core::mem::align_of::<if_data__bindgen_ty_2>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( if_data__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data__bindgen_ty_2 ) ) . tv as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data__bindgen_ty_2 )
                , "::" , stringify ! ( tv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data__bindgen_ty_2 ) ) . ph as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data__bindgen_ty_2 )
                , "::" , stringify ! ( ph ) ));
}
impl Clone for if_data__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for if_data__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for if_data__bindgen_ty_2 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "if_data__bindgen_ty_2 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_if_data() {
    assert_eq!(::core::mem::size_of::<if_data>() , 152usize , concat ! (
               "Size of: " , stringify ! ( if_data ) ));
    assert_eq! (::core::mem::align_of::<if_data>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( if_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_type as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_physical as * const _
                as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_physical ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_addrlen as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_addrlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_hdrlen as * const _ as
                usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_hdrlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_link_state as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_link_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_vhid as * const _ as
                usize } , 5usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_vhid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_datalen as * const _ as
                usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_datalen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_mtu as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_mtu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_metric as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_metric ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_baudrate as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_baudrate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_ipackets as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_ipackets ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_ierrors as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_ierrors ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_opackets as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_opackets ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_oerrors as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_oerrors ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_collisions as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_collisions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_ibytes as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_ibytes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_obytes as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_obytes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_imcasts as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_imcasts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_omcasts as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_omcasts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_iqdrops as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_iqdrops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_oqdrops as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_oqdrops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_noproto as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_noproto ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . ifi_hwassist as * const _
                as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( ifi_hwassist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . __ifi_epoch as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( __ifi_epoch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_data ) ) . __ifi_lastchange as * const
                _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( if_data ) , "::" ,
                stringify ! ( __ifi_lastchange ) ));
}
impl Clone for if_data {
    fn clone(&self) -> Self { *self }
}
impl Default for if_data {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for if_data {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "if_data {{ ifi_type: {:?}, ifi_physical: {:?}, ifi_addrlen: {:?}, ifi_hdrlen: {:?}, ifi_link_state: {:?}, ifi_vhid: {:?}, ifi_datalen: {:?}, ifi_mtu: {:?}, ifi_metric: {:?}, ifi_baudrate: {:?}, ifi_ipackets: {:?}, ifi_ierrors: {:?}, ifi_opackets: {:?}, ifi_oerrors: {:?}, ifi_collisions: {:?}, ifi_ibytes: {:?}, ifi_obytes: {:?}, ifi_imcasts: {:?}, ifi_omcasts: {:?}, ifi_iqdrops: {:?}, ifi_oqdrops: {:?}, ifi_noproto: {:?}, ifi_hwassist: {:?}, __ifi_epoch: {:?}, __ifi_lastchange: {:?} }}"
               , self . ifi_type , self . ifi_physical , self . ifi_addrlen ,
               self . ifi_hdrlen , self . ifi_link_state , self . ifi_vhid ,
               self . ifi_datalen , self . ifi_mtu , self . ifi_metric , self
               . ifi_baudrate , self . ifi_ipackets , self . ifi_ierrors ,
               self . ifi_opackets , self . ifi_oerrors , self .
               ifi_collisions , self . ifi_ibytes , self . ifi_obytes , self .
               ifi_imcasts , self . ifi_omcasts , self . ifi_iqdrops , self .
               ifi_oqdrops , self . ifi_noproto , self . ifi_hwassist , self .
               __ifi_epoch , self . __ifi_lastchange)
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct if_msghdr {
    pub ifm_msglen: u_short,
    pub ifm_version: u_char,
    pub ifm_type: u_char,
    pub ifm_addrs: ::kernel::sys::raw::c_int,
    pub ifm_flags: ::kernel::sys::raw::c_int,
    pub ifm_index: u_short,
    pub ifm_data: if_data,
}
#[test]
fn bindgen_test_layout_if_msghdr() {
    assert_eq!(::core::mem::size_of::<if_msghdr>() , 168usize , concat ! (
               "Size of: " , stringify ! ( if_msghdr ) ));
    assert_eq! (::core::mem::align_of::<if_msghdr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( if_msghdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_msghdr ) ) . ifm_msglen as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_msghdr ) , "::" ,
                stringify ! ( ifm_msglen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_msghdr ) ) . ifm_version as * const _
                as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( if_msghdr ) , "::" ,
                stringify ! ( ifm_version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_msghdr ) ) . ifm_type as * const _ as
                usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( if_msghdr ) , "::" ,
                stringify ! ( ifm_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_msghdr ) ) . ifm_addrs as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( if_msghdr ) , "::" ,
                stringify ! ( ifm_addrs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_msghdr ) ) . ifm_flags as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( if_msghdr ) , "::" ,
                stringify ! ( ifm_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_msghdr ) ) . ifm_index as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( if_msghdr ) , "::" ,
                stringify ! ( ifm_index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_msghdr ) ) . ifm_data as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( if_msghdr ) , "::" ,
                stringify ! ( ifm_data ) ));
}
impl Clone for if_msghdr {
    fn clone(&self) -> Self { *self }
}
impl Default for if_msghdr {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for if_msghdr {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "if_msghdr {{ ifm_msglen: {:?}, ifm_version: {:?}, ifm_type: {:?}, ifm_addrs: {:?}, ifm_flags: {:?}, ifm_index: {:?}, ifm_data: {:?} }}"
               , self . ifm_msglen , self . ifm_version , self . ifm_type ,
               self . ifm_addrs , self . ifm_flags , self . ifm_index , self .
               ifm_data)
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct if_msghdrl {
    pub ifm_msglen: u_short,
    pub ifm_version: u_char,
    pub ifm_type: u_char,
    pub ifm_addrs: ::kernel::sys::raw::c_int,
    pub ifm_flags: ::kernel::sys::raw::c_int,
    pub ifm_index: u_short,
    pub _ifm_spare1: u_short,
    pub ifm_len: u_short,
    pub ifm_data_off: u_short,
    pub ifm_data: if_data,
}
#[test]
fn bindgen_test_layout_if_msghdrl() {
    assert_eq!(::core::mem::size_of::<if_msghdrl>() , 176usize , concat ! (
               "Size of: " , stringify ! ( if_msghdrl ) ));
    assert_eq! (::core::mem::align_of::<if_msghdrl>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( if_msghdrl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_msghdrl ) ) . ifm_msglen as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_msghdrl ) , "::" ,
                stringify ! ( ifm_msglen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_msghdrl ) ) . ifm_version as * const _
                as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( if_msghdrl ) , "::" ,
                stringify ! ( ifm_version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_msghdrl ) ) . ifm_type as * const _ as
                usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( if_msghdrl ) , "::" ,
                stringify ! ( ifm_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_msghdrl ) ) . ifm_addrs as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( if_msghdrl ) , "::" ,
                stringify ! ( ifm_addrs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_msghdrl ) ) . ifm_flags as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( if_msghdrl ) , "::" ,
                stringify ! ( ifm_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_msghdrl ) ) . ifm_index as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( if_msghdrl ) , "::" ,
                stringify ! ( ifm_index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_msghdrl ) ) . _ifm_spare1 as * const _
                as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( if_msghdrl ) , "::" ,
                stringify ! ( _ifm_spare1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_msghdrl ) ) . ifm_len as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( if_msghdrl ) , "::" ,
                stringify ! ( ifm_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_msghdrl ) ) . ifm_data_off as * const
                _ as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( if_msghdrl ) , "::" ,
                stringify ! ( ifm_data_off ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_msghdrl ) ) . ifm_data as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( if_msghdrl ) , "::" ,
                stringify ! ( ifm_data ) ));
}
impl Clone for if_msghdrl {
    fn clone(&self) -> Self { *self }
}
impl Default for if_msghdrl {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for if_msghdrl {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "if_msghdrl {{ ifm_msglen: {:?}, ifm_version: {:?}, ifm_type: {:?}, ifm_addrs: {:?}, ifm_flags: {:?}, ifm_index: {:?}, _ifm_spare1: {:?}, ifm_len: {:?}, ifm_data_off: {:?}, ifm_data: {:?} }}"
               , self . ifm_msglen , self . ifm_version , self . ifm_type ,
               self . ifm_addrs , self . ifm_flags , self . ifm_index , self .
               _ifm_spare1 , self . ifm_len , self . ifm_data_off , self .
               ifm_data)
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct ifa_msghdr {
    pub ifam_msglen: u_short,
    pub ifam_version: u_char,
    pub ifam_type: u_char,
    pub ifam_addrs: ::kernel::sys::raw::c_int,
    pub ifam_flags: ::kernel::sys::raw::c_int,
    pub ifam_index: u_short,
    pub ifam_metric: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_ifa_msghdr() {
    assert_eq!(::core::mem::size_of::<ifa_msghdr>() , 20usize , concat ! (
               "Size of: " , stringify ! ( ifa_msghdr ) ));
    assert_eq! (::core::mem::align_of::<ifa_msghdr>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( ifa_msghdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifa_msghdr ) ) . ifam_msglen as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifa_msghdr ) , "::" ,
                stringify ! ( ifam_msglen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifa_msghdr ) ) . ifam_version as * const
                _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( ifa_msghdr ) , "::" ,
                stringify ! ( ifam_version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifa_msghdr ) ) . ifam_type as * const _
                as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( ifa_msghdr ) , "::" ,
                stringify ! ( ifam_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifa_msghdr ) ) . ifam_addrs as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ifa_msghdr ) , "::" ,
                stringify ! ( ifam_addrs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifa_msghdr ) ) . ifam_flags as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifa_msghdr ) , "::" ,
                stringify ! ( ifam_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifa_msghdr ) ) . ifam_index as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( ifa_msghdr ) , "::" ,
                stringify ! ( ifam_index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifa_msghdr ) ) . ifam_metric as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ifa_msghdr ) , "::" ,
                stringify ! ( ifam_metric ) ));
}
impl Clone for ifa_msghdr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ifa_msghdrl {
    pub ifam_msglen: u_short,
    pub ifam_version: u_char,
    pub ifam_type: u_char,
    pub ifam_addrs: ::kernel::sys::raw::c_int,
    pub ifam_flags: ::kernel::sys::raw::c_int,
    pub ifam_index: u_short,
    pub _ifam_spare1: u_short,
    pub ifam_len: u_short,
    pub ifam_data_off: u_short,
    pub ifam_metric: ::kernel::sys::raw::c_int,
    pub ifam_data: if_data,
}
#[test]
fn bindgen_test_layout_ifa_msghdrl() {
    assert_eq!(::core::mem::size_of::<ifa_msghdrl>() , 176usize , concat ! (
               "Size of: " , stringify ! ( ifa_msghdrl ) ));
    assert_eq! (::core::mem::align_of::<ifa_msghdrl>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ifa_msghdrl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifa_msghdrl ) ) . ifam_msglen as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifa_msghdrl ) , "::" ,
                stringify ! ( ifam_msglen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifa_msghdrl ) ) . ifam_version as * const
                _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( ifa_msghdrl ) , "::" ,
                stringify ! ( ifam_version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifa_msghdrl ) ) . ifam_type as * const _
                as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( ifa_msghdrl ) , "::" ,
                stringify ! ( ifam_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifa_msghdrl ) ) . ifam_addrs as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ifa_msghdrl ) , "::" ,
                stringify ! ( ifam_addrs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifa_msghdrl ) ) . ifam_flags as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifa_msghdrl ) , "::" ,
                stringify ! ( ifam_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifa_msghdrl ) ) . ifam_index as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( ifa_msghdrl ) , "::" ,
                stringify ! ( ifam_index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifa_msghdrl ) ) . _ifam_spare1 as * const
                _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( ifa_msghdrl ) , "::" ,
                stringify ! ( _ifam_spare1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifa_msghdrl ) ) . ifam_len as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ifa_msghdrl ) , "::" ,
                stringify ! ( ifam_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifa_msghdrl ) ) . ifam_data_off as *
                const _ as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( ifa_msghdrl ) , "::" ,
                stringify ! ( ifam_data_off ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifa_msghdrl ) ) . ifam_metric as * const
                _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( ifa_msghdrl ) , "::" ,
                stringify ! ( ifam_metric ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifa_msghdrl ) ) . ifam_data as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ifa_msghdrl ) , "::" ,
                stringify ! ( ifam_data ) ));
}
impl Clone for ifa_msghdrl {
    fn clone(&self) -> Self { *self }
}
impl Default for ifa_msghdrl {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for ifa_msghdrl {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "ifa_msghdrl {{ ifam_msglen: {:?}, ifam_version: {:?}, ifam_type: {:?}, ifam_addrs: {:?}, ifam_flags: {:?}, ifam_index: {:?}, _ifam_spare1: {:?}, ifam_len: {:?}, ifam_data_off: {:?}, ifam_metric: {:?}, ifam_data: {:?} }}"
               , self . ifam_msglen , self . ifam_version , self . ifam_type ,
               self . ifam_addrs , self . ifam_flags , self . ifam_index ,
               self . _ifam_spare1 , self . ifam_len , self . ifam_data_off ,
               self . ifam_metric , self . ifam_data)
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct ifma_msghdr {
    pub ifmam_msglen: u_short,
    pub ifmam_version: u_char,
    pub ifmam_type: u_char,
    pub ifmam_addrs: ::kernel::sys::raw::c_int,
    pub ifmam_flags: ::kernel::sys::raw::c_int,
    pub ifmam_index: u_short,
}
#[test]
fn bindgen_test_layout_ifma_msghdr() {
    assert_eq!(::core::mem::size_of::<ifma_msghdr>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ifma_msghdr ) ));
    assert_eq! (::core::mem::align_of::<ifma_msghdr>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( ifma_msghdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifma_msghdr ) ) . ifmam_msglen as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifma_msghdr ) , "::" ,
                stringify ! ( ifmam_msglen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifma_msghdr ) ) . ifmam_version as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( ifma_msghdr ) , "::" ,
                stringify ! ( ifmam_version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifma_msghdr ) ) . ifmam_type as * const _
                as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( ifma_msghdr ) , "::" ,
                stringify ! ( ifmam_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifma_msghdr ) ) . ifmam_addrs as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ifma_msghdr ) , "::" ,
                stringify ! ( ifmam_addrs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifma_msghdr ) ) . ifmam_flags as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifma_msghdr ) , "::" ,
                stringify ! ( ifmam_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifma_msghdr ) ) . ifmam_index as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( ifma_msghdr ) , "::" ,
                stringify ! ( ifmam_index ) ));
}
impl Clone for ifma_msghdr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct if_announcemsghdr {
    pub ifan_msglen: u_short,
    pub ifan_version: u_char,
    pub ifan_type: u_char,
    pub ifan_index: u_short,
    pub ifan_name: [::kernel::sys::raw::c_char; 16usize],
    pub ifan_what: u_short,
}
#[test]
fn bindgen_test_layout_if_announcemsghdr() {
    assert_eq!(::core::mem::size_of::<if_announcemsghdr>() , 24usize , concat
               ! ( "Size of: " , stringify ! ( if_announcemsghdr ) ));
    assert_eq! (::core::mem::align_of::<if_announcemsghdr>() , 2usize , concat
                ! ( "Alignment of " , stringify ! ( if_announcemsghdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_announcemsghdr ) ) . ifan_msglen as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_announcemsghdr ) ,
                "::" , stringify ! ( ifan_msglen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_announcemsghdr ) ) . ifan_version as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( if_announcemsghdr ) ,
                "::" , stringify ! ( ifan_version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_announcemsghdr ) ) . ifan_type as *
                const _ as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( if_announcemsghdr ) ,
                "::" , stringify ! ( ifan_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_announcemsghdr ) ) . ifan_index as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( if_announcemsghdr ) ,
                "::" , stringify ! ( ifan_index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_announcemsghdr ) ) . ifan_name as *
                const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( if_announcemsghdr ) ,
                "::" , stringify ! ( ifan_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_announcemsghdr ) ) . ifan_what as *
                const _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! ( if_announcemsghdr ) ,
                "::" , stringify ! ( ifan_what ) ));
}
impl Clone for if_announcemsghdr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifreq_buffer {
    pub length: usize,
    pub buffer: *mut ::kernel::sys::raw::c_void,
}
#[test]
fn bindgen_test_layout_ifreq_buffer() {
    assert_eq!(::core::mem::size_of::<ifreq_buffer>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ifreq_buffer ) ));
    assert_eq! (::core::mem::align_of::<ifreq_buffer>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ifreq_buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifreq_buffer ) ) . length as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifreq_buffer ) , "::" ,
                stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifreq_buffer ) ) . buffer as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifreq_buffer ) , "::" ,
                stringify ! ( buffer ) ));
}
impl Clone for ifreq_buffer {
    fn clone(&self) -> Self { *self }
}
impl Default for ifreq_buffer {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct ifreq {
    pub ifr_name: [::kernel::sys::raw::c_char; 16usize],
    pub ifr_ifru: ifreq__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub union ifreq__bindgen_ty_1 {
    pub ifru_addr: sockaddr,
    pub ifru_dstaddr: sockaddr,
    pub ifru_broadaddr: sockaddr,
    pub ifru_buffer: ifreq_buffer,
    pub ifru_flags: [::kernel::sys::raw::c_short; 2usize],
    pub ifru_index: ::kernel::sys::raw::c_short,
    pub ifru_jid: ::kernel::sys::raw::c_int,
    pub ifru_metric: ::kernel::sys::raw::c_int,
    pub ifru_mtu: ::kernel::sys::raw::c_int,
    pub ifru_phys: ::kernel::sys::raw::c_int,
    pub ifru_media: ::kernel::sys::raw::c_int,
    pub ifru_data: caddr_t,
    pub ifru_cap: [::kernel::sys::raw::c_int; 2usize],
    pub ifru_fib: u_int,
    pub ifru_vlan_pcp: u_char,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_ifreq__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<ifreq__bindgen_ty_1>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( ifreq__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<ifreq__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( ifreq__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifreq__bindgen_ty_1 ) ) . ifru_addr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifreq__bindgen_ty_1 ) ,
                "::" , stringify ! ( ifru_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifreq__bindgen_ty_1 ) ) . ifru_dstaddr as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifreq__bindgen_ty_1 ) ,
                "::" , stringify ! ( ifru_dstaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifreq__bindgen_ty_1 ) ) . ifru_broadaddr
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifreq__bindgen_ty_1 ) ,
                "::" , stringify ! ( ifru_broadaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifreq__bindgen_ty_1 ) ) . ifru_buffer as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifreq__bindgen_ty_1 ) ,
                "::" , stringify ! ( ifru_buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifreq__bindgen_ty_1 ) ) . ifru_flags as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifreq__bindgen_ty_1 ) ,
                "::" , stringify ! ( ifru_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifreq__bindgen_ty_1 ) ) . ifru_index as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifreq__bindgen_ty_1 ) ,
                "::" , stringify ! ( ifru_index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifreq__bindgen_ty_1 ) ) . ifru_jid as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifreq__bindgen_ty_1 ) ,
                "::" , stringify ! ( ifru_jid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifreq__bindgen_ty_1 ) ) . ifru_metric as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifreq__bindgen_ty_1 ) ,
                "::" , stringify ! ( ifru_metric ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifreq__bindgen_ty_1 ) ) . ifru_mtu as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifreq__bindgen_ty_1 ) ,
                "::" , stringify ! ( ifru_mtu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifreq__bindgen_ty_1 ) ) . ifru_phys as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifreq__bindgen_ty_1 ) ,
                "::" , stringify ! ( ifru_phys ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifreq__bindgen_ty_1 ) ) . ifru_media as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifreq__bindgen_ty_1 ) ,
                "::" , stringify ! ( ifru_media ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifreq__bindgen_ty_1 ) ) . ifru_data as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifreq__bindgen_ty_1 ) ,
                "::" , stringify ! ( ifru_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifreq__bindgen_ty_1 ) ) . ifru_cap as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifreq__bindgen_ty_1 ) ,
                "::" , stringify ! ( ifru_cap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifreq__bindgen_ty_1 ) ) . ifru_fib as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifreq__bindgen_ty_1 ) ,
                "::" , stringify ! ( ifru_fib ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifreq__bindgen_ty_1 ) ) . ifru_vlan_pcp
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifreq__bindgen_ty_1 ) ,
                "::" , stringify ! ( ifru_vlan_pcp ) ));
}
impl Clone for ifreq__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for ifreq__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for ifreq__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "ifreq__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_ifreq() {
    assert_eq!(::core::mem::size_of::<ifreq>() , 32usize , concat ! (
               "Size of: " , stringify ! ( ifreq ) ));
    assert_eq! (::core::mem::align_of::<ifreq>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ifreq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifreq ) ) . ifr_name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifreq ) , "::" ,
                stringify ! ( ifr_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifreq ) ) . ifr_ifru as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ifreq ) , "::" ,
                stringify ! ( ifr_ifru ) ));
}
impl Clone for ifreq {
    fn clone(&self) -> Self { *self }
}
impl Default for ifreq {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for ifreq {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "ifreq {{ ifr_name: {:?}, ifr_ifru: {:?} }}" , self .
               ifr_name , self . ifr_ifru)
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct ifaliasreq {
    pub ifra_name: [::kernel::sys::raw::c_char; 16usize],
    pub ifra_addr: sockaddr,
    pub ifra_broadaddr: sockaddr,
    pub ifra_mask: sockaddr,
    pub ifra_vhid: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_ifaliasreq() {
    assert_eq!(::core::mem::size_of::<ifaliasreq>() , 68usize , concat ! (
               "Size of: " , stringify ! ( ifaliasreq ) ));
    assert_eq! (::core::mem::align_of::<ifaliasreq>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( ifaliasreq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaliasreq ) ) . ifra_name as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaliasreq ) , "::" ,
                stringify ! ( ifra_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaliasreq ) ) . ifra_addr as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaliasreq ) , "::" ,
                stringify ! ( ifra_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaliasreq ) ) . ifra_broadaddr as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaliasreq ) , "::" ,
                stringify ! ( ifra_broadaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaliasreq ) ) . ifra_mask as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaliasreq ) , "::" ,
                stringify ! ( ifra_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaliasreq ) ) . ifra_vhid as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaliasreq ) , "::" ,
                stringify ! ( ifra_vhid ) ));
}
impl Clone for ifaliasreq {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct oifaliasreq {
    pub ifra_name: [::kernel::sys::raw::c_char; 16usize],
    pub ifra_addr: sockaddr,
    pub ifra_broadaddr: sockaddr,
    pub ifra_mask: sockaddr,
}
#[test]
fn bindgen_test_layout_oifaliasreq() {
    assert_eq!(::core::mem::size_of::<oifaliasreq>() , 64usize , concat ! (
               "Size of: " , stringify ! ( oifaliasreq ) ));
    assert_eq! (::core::mem::align_of::<oifaliasreq>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( oifaliasreq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const oifaliasreq ) ) . ifra_name as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( oifaliasreq ) , "::" ,
                stringify ! ( ifra_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const oifaliasreq ) ) . ifra_addr as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( oifaliasreq ) , "::" ,
                stringify ! ( ifra_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const oifaliasreq ) ) . ifra_broadaddr as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( oifaliasreq ) , "::" ,
                stringify ! ( ifra_broadaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const oifaliasreq ) ) . ifra_mask as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( oifaliasreq ) , "::" ,
                stringify ! ( ifra_mask ) ));
}
impl Clone for oifaliasreq {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifmediareq {
    pub ifm_name: [::kernel::sys::raw::c_char; 16usize],
    pub ifm_current: ::kernel::sys::raw::c_int,
    pub ifm_mask: ::kernel::sys::raw::c_int,
    pub ifm_status: ::kernel::sys::raw::c_int,
    pub ifm_active: ::kernel::sys::raw::c_int,
    pub ifm_count: ::kernel::sys::raw::c_int,
    pub ifm_ulist: *mut ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_ifmediareq() {
    assert_eq!(::core::mem::size_of::<ifmediareq>() , 48usize , concat ! (
               "Size of: " , stringify ! ( ifmediareq ) ));
    assert_eq! (::core::mem::align_of::<ifmediareq>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ifmediareq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmediareq ) ) . ifm_name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmediareq ) , "::" ,
                stringify ! ( ifm_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmediareq ) ) . ifm_current as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmediareq ) , "::" ,
                stringify ! ( ifm_current ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmediareq ) ) . ifm_mask as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmediareq ) , "::" ,
                stringify ! ( ifm_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmediareq ) ) . ifm_status as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmediareq ) , "::" ,
                stringify ! ( ifm_status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmediareq ) ) . ifm_active as * const _
                as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmediareq ) , "::" ,
                stringify ! ( ifm_active ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmediareq ) ) . ifm_count as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmediareq ) , "::" ,
                stringify ! ( ifm_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmediareq ) ) . ifm_ulist as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmediareq ) , "::" ,
                stringify ! ( ifm_ulist ) ));
}
impl Clone for ifmediareq {
    fn clone(&self) -> Self { *self }
}
impl Default for ifmediareq {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifdrv {
    pub ifd_name: [::kernel::sys::raw::c_char; 16usize],
    pub ifd_cmd: ::kernel::sys::raw::c_ulong,
    pub ifd_len: usize,
    pub ifd_data: *mut ::kernel::sys::raw::c_void,
}
#[test]
fn bindgen_test_layout_ifdrv() {
    assert_eq!(::core::mem::size_of::<ifdrv>() , 40usize , concat ! (
               "Size of: " , stringify ! ( ifdrv ) ));
    assert_eq! (::core::mem::align_of::<ifdrv>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ifdrv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifdrv ) ) . ifd_name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifdrv ) , "::" ,
                stringify ! ( ifd_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifdrv ) ) . ifd_cmd as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ifdrv ) , "::" ,
                stringify ! ( ifd_cmd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifdrv ) ) . ifd_len as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ifdrv ) , "::" ,
                stringify ! ( ifd_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifdrv ) ) . ifd_data as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( ifdrv ) , "::" ,
                stringify ! ( ifd_data ) ));
}
impl Clone for ifdrv {
    fn clone(&self) -> Self { *self }
}
impl Default for ifdrv {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct ifstat {
    pub ifs_name: [::kernel::sys::raw::c_char; 16usize],
    pub ascii: [::kernel::sys::raw::c_char; 801usize],
}
#[test]
fn bindgen_test_layout_ifstat() {
    assert_eq!(::core::mem::size_of::<ifstat>() , 817usize , concat ! (
               "Size of: " , stringify ! ( ifstat ) ));
    assert_eq! (::core::mem::align_of::<ifstat>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( ifstat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifstat ) ) . ifs_name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifstat ) , "::" ,
                stringify ! ( ifs_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifstat ) ) . ascii as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ifstat ) , "::" ,
                stringify ! ( ascii ) ));
}
impl Clone for ifstat {
    fn clone(&self) -> Self { *self }
}
impl Default for ifstat {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for ifstat {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "ifstat {{ ifs_name: {:?}, ascii: [{}] }}" , self .
               ifs_name , self . ascii . iter (  ) . enumerate (  ) . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ))
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct ifconf {
    pub ifc_len: ::kernel::sys::raw::c_int,
    pub ifc_ifcu: ifconf__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub union ifconf__bindgen_ty_1 {
    pub ifcu_buf: caddr_t,
    pub ifcu_req: *mut ifreq,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_ifconf__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<ifconf__bindgen_ty_1>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( ifconf__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<ifconf__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( ifconf__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifconf__bindgen_ty_1 ) ) . ifcu_buf as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifconf__bindgen_ty_1 )
                , "::" , stringify ! ( ifcu_buf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifconf__bindgen_ty_1 ) ) . ifcu_req as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifconf__bindgen_ty_1 )
                , "::" , stringify ! ( ifcu_req ) ));
}
impl Clone for ifconf__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for ifconf__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for ifconf__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "ifconf__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_ifconf() {
    assert_eq!(::core::mem::size_of::<ifconf>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ifconf ) ));
    assert_eq! (::core::mem::align_of::<ifconf>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ifconf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifconf ) ) . ifc_len as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifconf ) , "::" ,
                stringify ! ( ifc_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifconf ) ) . ifc_ifcu as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifconf ) , "::" ,
                stringify ! ( ifc_ifcu ) ));
}
impl Clone for ifconf {
    fn clone(&self) -> Self { *self }
}
impl Default for ifconf {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for ifconf {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "ifconf {{ ifc_len: {:?}, ifc_ifcu: {:?} }}" , self .
               ifc_len , self . ifc_ifcu)
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct ifg_req {
    pub ifgrq_ifgrqu: ifg_req__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub union ifg_req__bindgen_ty_1 {
    pub ifgrqu_group: [::kernel::sys::raw::c_char; 16usize],
    pub ifgrqu_member: [::kernel::sys::raw::c_char; 16usize],
    _bindgen_union_align: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_ifg_req__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<ifg_req__bindgen_ty_1>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( ifg_req__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<ifg_req__bindgen_ty_1>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( ifg_req__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifg_req__bindgen_ty_1 ) ) . ifgrqu_group
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifg_req__bindgen_ty_1 )
                , "::" , stringify ! ( ifgrqu_group ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifg_req__bindgen_ty_1 ) ) . ifgrqu_member
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifg_req__bindgen_ty_1 )
                , "::" , stringify ! ( ifgrqu_member ) ));
}
impl Clone for ifg_req__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for ifg_req__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for ifg_req__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "ifg_req__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_ifg_req() {
    assert_eq!(::core::mem::size_of::<ifg_req>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ifg_req ) ));
    assert_eq! (::core::mem::align_of::<ifg_req>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( ifg_req ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifg_req ) ) . ifgrq_ifgrqu as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifg_req ) , "::" ,
                stringify ! ( ifgrq_ifgrqu ) ));
}
impl Clone for ifg_req {
    fn clone(&self) -> Self { *self }
}
impl Default for ifg_req {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for ifg_req {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "ifg_req {{ ifgrq_ifgrqu: {:?} }}" , self . ifgrq_ifgrqu)
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct ifgroupreq {
    pub ifgr_name: [::kernel::sys::raw::c_char; 16usize],
    pub ifgr_len: u_int,
    pub ifgr_ifgru: ifgroupreq__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub union ifgroupreq__bindgen_ty_1 {
    pub ifgru_group: [::kernel::sys::raw::c_char; 16usize],
    pub ifgru_groups: *mut ifg_req,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_ifgroupreq__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<ifgroupreq__bindgen_ty_1>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( ifgroupreq__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<ifgroupreq__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( ifgroupreq__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifgroupreq__bindgen_ty_1 ) ) .
                ifgru_group as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                ifgroupreq__bindgen_ty_1 ) , "::" , stringify ! ( ifgru_group
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifgroupreq__bindgen_ty_1 ) ) .
                ifgru_groups as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                ifgroupreq__bindgen_ty_1 ) , "::" , stringify ! ( ifgru_groups
                ) ));
}
impl Clone for ifgroupreq__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for ifgroupreq__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for ifgroupreq__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "ifgroupreq__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_ifgroupreq() {
    assert_eq!(::core::mem::size_of::<ifgroupreq>() , 40usize , concat ! (
               "Size of: " , stringify ! ( ifgroupreq ) ));
    assert_eq! (::core::mem::align_of::<ifgroupreq>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ifgroupreq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifgroupreq ) ) . ifgr_name as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifgroupreq ) , "::" ,
                stringify ! ( ifgr_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifgroupreq ) ) . ifgr_len as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ifgroupreq ) , "::" ,
                stringify ! ( ifgr_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifgroupreq ) ) . ifgr_ifgru as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ifgroupreq ) , "::" ,
                stringify ! ( ifgr_ifgru ) ));
}
impl Clone for ifgroupreq {
    fn clone(&self) -> Self { *self }
}
impl Default for ifgroupreq {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for ifgroupreq {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "ifgroupreq {{ ifgr_name: {:?}, ifgr_len: {:?}, ifgr_ifgru: {:?} }}"
               , self . ifgr_name , self . ifgr_len , self . ifgr_ifgru)
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct ifi2creq {
    pub dev_addr: u8,
    pub offset: u8,
    pub len: u8,
    pub spare0: u8,
    pub spare1: u32,
    pub data: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_ifi2creq() {
    assert_eq!(::core::mem::size_of::<ifi2creq>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ifi2creq ) ));
    assert_eq! (::core::mem::align_of::<ifi2creq>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( ifi2creq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifi2creq ) ) . dev_addr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifi2creq ) , "::" ,
                stringify ! ( dev_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifi2creq ) ) . offset as * const _ as
                usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( ifi2creq ) , "::" ,
                stringify ! ( offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifi2creq ) ) . len as * const _ as usize
                } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( ifi2creq ) , "::" ,
                stringify ! ( len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifi2creq ) ) . spare0 as * const _ as
                usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( ifi2creq ) , "::" ,
                stringify ! ( spare0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifi2creq ) ) . spare1 as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ifi2creq ) , "::" ,
                stringify ! ( spare1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifi2creq ) ) . data as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifi2creq ) , "::" ,
                stringify ! ( data ) ));
}
impl Clone for ifi2creq {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ifrsskey {
    pub ifrk_name: [::kernel::sys::raw::c_char; 16usize],
    pub ifrk_func: u8,
    pub ifrk_spare0: u8,
    pub ifrk_keylen: u16,
    pub ifrk_key: [u8; 128usize],
}
#[test]
fn bindgen_test_layout_ifrsskey() {
    assert_eq!(::core::mem::size_of::<ifrsskey>() , 148usize , concat ! (
               "Size of: " , stringify ! ( ifrsskey ) ));
    assert_eq! (::core::mem::align_of::<ifrsskey>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( ifrsskey ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifrsskey ) ) . ifrk_name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifrsskey ) , "::" ,
                stringify ! ( ifrk_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifrsskey ) ) . ifrk_func as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ifrsskey ) , "::" ,
                stringify ! ( ifrk_func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifrsskey ) ) . ifrk_spare0 as * const _
                as usize } , 17usize , concat ! (
                "Alignment of field: " , stringify ! ( ifrsskey ) , "::" ,
                stringify ! ( ifrk_spare0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifrsskey ) ) . ifrk_keylen as * const _
                as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( ifrsskey ) , "::" ,
                stringify ! ( ifrk_keylen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifrsskey ) ) . ifrk_key as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( ifrsskey ) , "::" ,
                stringify ! ( ifrk_key ) ));
}
impl Clone for ifrsskey {
    fn clone(&self) -> Self { *self }
}
impl Default for ifrsskey {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for ifrsskey {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "ifrsskey {{ ifrk_name: {:?}, ifrk_func: {:?}, ifrk_spare0: {:?}, ifrk_keylen: {:?}, ifrk_key: [{}] }}"
               , self . ifrk_name , self . ifrk_func , self . ifrk_spare0 ,
               self . ifrk_keylen , self . ifrk_key . iter (  ) . enumerate (
               ) . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ))
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct ifrsshash {
    pub ifrh_name: [::kernel::sys::raw::c_char; 16usize],
    pub ifrh_func: u8,
    pub ifrh_spare0: u8,
    pub ifrh_spare1: u16,
    pub ifrh_types: u32,
}
#[test]
fn bindgen_test_layout_ifrsshash() {
    assert_eq!(::core::mem::size_of::<ifrsshash>() , 24usize , concat ! (
               "Size of: " , stringify ! ( ifrsshash ) ));
    assert_eq! (::core::mem::align_of::<ifrsshash>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( ifrsshash ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifrsshash ) ) . ifrh_name as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifrsshash ) , "::" ,
                stringify ! ( ifrh_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifrsshash ) ) . ifrh_func as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ifrsshash ) , "::" ,
                stringify ! ( ifrh_func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifrsshash ) ) . ifrh_spare0 as * const _
                as usize } , 17usize , concat ! (
                "Alignment of field: " , stringify ! ( ifrsshash ) , "::" ,
                stringify ! ( ifrh_spare0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifrsshash ) ) . ifrh_spare1 as * const _
                as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( ifrsshash ) , "::" ,
                stringify ! ( ifrh_spare1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifrsshash ) ) . ifrh_types as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( ifrsshash ) , "::" ,
                stringify ! ( ifrh_types ) ));
}
impl Clone for ifrsshash {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "M_IFADDR"]
    pub static mut M_IFADDR: [malloc_type; 1usize];
}
extern "C" {
    #[link_name = "M_IFMADDR"]
    pub static mut M_IFMADDR: [malloc_type; 1usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rtentry {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rt_addrinfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct carp_if {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct carp_softc {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ifvlantrunk {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct vnet {
    pub vnet_le: vnet__bindgen_ty_1,
    pub vnet_magic_n: u_int,
    pub vnet_ifcnt: u_int,
    pub vnet_sockcnt: u_int,
    pub vnet_state: u_int,
    pub vnet_data_mem: *mut ::kernel::sys::raw::c_void,
    pub vnet_data_base: usize,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct vnet__bindgen_ty_1 {
    pub le_next: *mut vnet,
    pub le_prev: *mut *mut vnet,
}
#[test]
fn bindgen_test_layout_vnet__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<vnet__bindgen_ty_1>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( vnet__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<vnet__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( vnet__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vnet__bindgen_ty_1 ) ) . le_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( vnet__bindgen_ty_1 ) ,
                "::" , stringify ! ( le_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vnet__bindgen_ty_1 ) ) . le_prev as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( vnet__bindgen_ty_1 ) ,
                "::" , stringify ! ( le_prev ) ));
}
impl Clone for vnet__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for vnet__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_vnet() {
    assert_eq!(::core::mem::size_of::<vnet>() , 48usize , concat ! (
               "Size of: " , stringify ! ( vnet ) ));
    assert_eq! (::core::mem::align_of::<vnet>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( vnet ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vnet ) ) . vnet_le as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( vnet ) , "::" ,
                stringify ! ( vnet_le ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vnet ) ) . vnet_magic_n as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( vnet ) , "::" ,
                stringify ! ( vnet_magic_n ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vnet ) ) . vnet_ifcnt as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( vnet ) , "::" ,
                stringify ! ( vnet_ifcnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vnet ) ) . vnet_sockcnt as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( vnet ) , "::" ,
                stringify ! ( vnet_sockcnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vnet ) ) . vnet_state as * const _ as
                usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( vnet ) , "::" ,
                stringify ! ( vnet_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vnet ) ) . vnet_data_mem as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( vnet ) , "::" ,
                stringify ! ( vnet_data_mem ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vnet ) ) . vnet_data_base as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( vnet ) , "::" ,
                stringify ! ( vnet_data_base ) ));
}
impl Clone for vnet {
    fn clone(&self) -> Self { *self }
}
impl Default for vnet {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifmedia {
    pub ifm_mask: ::kernel::sys::raw::c_int,
    pub ifm_media: ::kernel::sys::raw::c_int,
    pub ifm_cur: *mut ifmedia_entry,
    pub ifm_list: ifmedia__bindgen_ty_1,
    pub ifm_change: ifm_change_cb_t,
    pub ifm_status: ifm_stat_cb_t,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifmedia__bindgen_ty_1 {
    pub lh_first: *mut ifmedia_entry,
}
#[test]
fn bindgen_test_layout_ifmedia__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<ifmedia__bindgen_ty_1>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( ifmedia__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<ifmedia__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( ifmedia__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmedia__bindgen_ty_1 ) ) . lh_first as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmedia__bindgen_ty_1 )
                , "::" , stringify ! ( lh_first ) ));
}
impl Clone for ifmedia__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for ifmedia__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_ifmedia() {
    assert_eq!(::core::mem::size_of::<ifmedia>() , 40usize , concat ! (
               "Size of: " , stringify ! ( ifmedia ) ));
    assert_eq! (::core::mem::align_of::<ifmedia>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ifmedia ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmedia ) ) . ifm_mask as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmedia ) , "::" ,
                stringify ! ( ifm_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmedia ) ) . ifm_media as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmedia ) , "::" ,
                stringify ! ( ifm_media ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmedia ) ) . ifm_cur as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmedia ) , "::" ,
                stringify ! ( ifm_cur ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmedia ) ) . ifm_list as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmedia ) , "::" ,
                stringify ! ( ifm_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmedia ) ) . ifm_change as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmedia ) , "::" ,
                stringify ! ( ifm_change ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmedia ) ) . ifm_status as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmedia ) , "::" ,
                stringify ! ( ifm_status ) ));
}
impl Clone for ifmedia {
    fn clone(&self) -> Self { *self }
}
impl Default for ifmedia {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netmap_adapter {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netdump_methods {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ck_stack_entry {
    pub next: *mut ck_stack_entry,
}
#[test]
fn bindgen_test_layout_ck_stack_entry() {
    assert_eq!(::core::mem::size_of::<ck_stack_entry>() , 8usize , concat ! (
               "Size of: " , stringify ! ( ck_stack_entry ) ));
    assert_eq! (::core::mem::align_of::<ck_stack_entry>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( ck_stack_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ck_stack_entry ) ) . next as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ck_stack_entry ) , "::"
                , stringify ! ( next ) ));
}
impl Clone for ck_stack_entry {
    fn clone(&self) -> Self { *self }
}
impl Default for ck_stack_entry {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type ck_stack_entry_t = ck_stack_entry;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ck_stack {
    pub head: *mut ck_stack_entry,
    pub generation: *mut ::kernel::sys::raw::c_char,
}
#[test]
fn bindgen_test_layout_ck_stack() {
    assert_eq!(::core::mem::size_of::<ck_stack>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ck_stack ) ));
    assert_eq! (::core::mem::align_of::<ck_stack>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ck_stack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ck_stack ) ) . head as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ck_stack ) , "::" ,
                stringify ! ( head ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ck_stack ) ) . generation as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ck_stack ) , "::" ,
                stringify ! ( generation ) ));
}
impl Clone for ck_stack {
    fn clone(&self) -> Self { *self }
}
impl Default for ck_stack {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type ck_stack_t = ck_stack;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ck_epoch_entry {
    pub function: ck_epoch_cb_t,
    pub stack_entry: ck_stack_entry_t,
}
#[test]
fn bindgen_test_layout_ck_epoch_entry() {
    assert_eq!(::core::mem::size_of::<ck_epoch_entry>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ck_epoch_entry ) ));
    assert_eq! (::core::mem::align_of::<ck_epoch_entry>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( ck_epoch_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ck_epoch_entry ) ) . function as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ck_epoch_entry ) , "::"
                , stringify ! ( function ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ck_epoch_entry ) ) . stack_entry as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ck_epoch_entry ) , "::"
                , stringify ! ( stack_entry ) ));
}
impl Clone for ck_epoch_entry {
    fn clone(&self) -> Self { *self }
}
impl Default for ck_epoch_entry {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type ck_epoch_entry_t = ck_epoch_entry;
pub type ck_epoch_cb_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ck_epoch_entry_t)>;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct ck_epoch_section {
    pub bucket: ::kernel::sys::raw::c_uint,
}
#[test]
fn bindgen_test_layout_ck_epoch_section() {
    assert_eq!(::core::mem::size_of::<ck_epoch_section>() , 4usize , concat !
               ( "Size of: " , stringify ! ( ck_epoch_section ) ));
    assert_eq! (::core::mem::align_of::<ck_epoch_section>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( ck_epoch_section ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ck_epoch_section ) ) . bucket as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ck_epoch_section ) ,
                "::" , stringify ! ( bucket ) ));
}
impl Clone for ck_epoch_section {
    fn clone(&self) -> Self { *self }
}
pub type ck_epoch_section_t = ck_epoch_section;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct ck_epoch_ref {
    pub epoch: ::kernel::sys::raw::c_uint,
    pub count: ::kernel::sys::raw::c_uint,
}
#[test]
fn bindgen_test_layout_ck_epoch_ref() {
    assert_eq!(::core::mem::size_of::<ck_epoch_ref>() , 8usize , concat ! (
               "Size of: " , stringify ! ( ck_epoch_ref ) ));
    assert_eq! (::core::mem::align_of::<ck_epoch_ref>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( ck_epoch_ref ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ck_epoch_ref ) ) . epoch as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ck_epoch_ref ) , "::" ,
                stringify ! ( epoch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ck_epoch_ref ) ) . count as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ck_epoch_ref ) , "::" ,
                stringify ! ( count ) ));
}
impl Clone for ck_epoch_ref {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct ck_epoch_record {
    pub record_next: ck_stack_entry_t,
    pub global: *mut ck_epoch,
    pub state: ::kernel::sys::raw::c_uint,
    pub epoch: ::kernel::sys::raw::c_uint,
    pub active: ::kernel::sys::raw::c_uint,
    pub __bindgen_padding_0: [u32; 9usize],
    pub local: ck_epoch_record__bindgen_ty_1,
    pub n_pending: ::kernel::sys::raw::c_uint,
    pub n_peak: ::kernel::sys::raw::c_uint,
    pub n_dispatch: ::kernel::sys::raw::c_uint,
    pub ct: *mut ::kernel::sys::raw::c_void,
    pub pending: [ck_stack_t; 4usize],
    pub __bindgen_padding_1: [u64; 3usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct ck_epoch_record__bindgen_ty_1 {
    pub bucket: [ck_epoch_ref; 2usize],
}
#[test]
fn bindgen_test_layout_ck_epoch_record__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<ck_epoch_record__bindgen_ty_1>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( ck_epoch_record__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<ck_epoch_record__bindgen_ty_1>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( ck_epoch_record__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ck_epoch_record__bindgen_ty_1 ) ) .
                bucket as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                ck_epoch_record__bindgen_ty_1 ) , "::" , stringify ! ( bucket
                ) ));
}
impl Clone for ck_epoch_record__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_ck_epoch_record() {
    assert_eq!(::core::mem::size_of::<ck_epoch_record>() , 192usize , concat !
               ( "Size of: " , stringify ! ( ck_epoch_record ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ck_epoch_record ) ) . record_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ck_epoch_record ) ,
                "::" , stringify ! ( record_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ck_epoch_record ) ) . global as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ck_epoch_record ) ,
                "::" , stringify ! ( global ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ck_epoch_record ) ) . state as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ck_epoch_record ) ,
                "::" , stringify ! ( state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ck_epoch_record ) ) . epoch as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( ck_epoch_record ) ,
                "::" , stringify ! ( epoch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ck_epoch_record ) ) . active as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ck_epoch_record ) ,
                "::" , stringify ! ( active ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ck_epoch_record ) ) . local as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( ck_epoch_record ) ,
                "::" , stringify ! ( local ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ck_epoch_record ) ) . n_pending as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( ck_epoch_record ) ,
                "::" , stringify ! ( n_pending ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ck_epoch_record ) ) . n_peak as * const _
                as usize } , 84usize , concat ! (
                "Alignment of field: " , stringify ! ( ck_epoch_record ) ,
                "::" , stringify ! ( n_peak ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ck_epoch_record ) ) . n_dispatch as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( ck_epoch_record ) ,
                "::" , stringify ! ( n_dispatch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ck_epoch_record ) ) . ct as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( ck_epoch_record ) ,
                "::" , stringify ! ( ct ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ck_epoch_record ) ) . pending as * const
                _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( ck_epoch_record ) ,
                "::" , stringify ! ( pending ) ));
}
impl Clone for ck_epoch_record {
    fn clone(&self) -> Self { *self }
}
impl Default for ck_epoch_record {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for ck_epoch_record {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "ck_epoch_record {{ record_next: {:?}, global: {:?}, state: {:?}, epoch: {:?}, active: {:?}, local: {:?}, n_pending: {:?}, n_peak: {:?}, n_dispatch: {:?}, ct: {:?}, pending: {:?} }}"
               , self . record_next , self . global , self . state , self .
               epoch , self . active , self . local , self . n_pending , self
               . n_peak , self . n_dispatch , self . ct , self . pending)
    }
}
pub type ck_epoch_record_t = ck_epoch_record;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ck_epoch {
    pub epoch: ::kernel::sys::raw::c_uint,
    pub n_free: ::kernel::sys::raw::c_uint,
    pub records: ck_stack_t,
}
#[test]
fn bindgen_test_layout_ck_epoch() {
    assert_eq!(::core::mem::size_of::<ck_epoch>() , 24usize , concat ! (
               "Size of: " , stringify ! ( ck_epoch ) ));
    assert_eq! (::core::mem::align_of::<ck_epoch>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ck_epoch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ck_epoch ) ) . epoch as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ck_epoch ) , "::" ,
                stringify ! ( epoch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ck_epoch ) ) . n_free as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ck_epoch ) , "::" ,
                stringify ! ( n_free ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ck_epoch ) ) . records as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ck_epoch ) , "::" ,
                stringify ! ( records ) ));
}
impl Clone for ck_epoch {
    fn clone(&self) -> Self { *self }
}
impl Default for ck_epoch {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type ck_epoch_t = ck_epoch;
extern "C" {
    pub fn _ck_epoch_addref(arg1: *mut ck_epoch_record_t,
                            arg2: *mut ck_epoch_section_t);
}
extern "C" {
    pub fn _ck_epoch_delref(arg1: *mut ck_epoch_record_t,
                            arg2: *mut ck_epoch_section_t) -> bool_;
}
pub type ck_epoch_wait_cb_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ck_epoch_t,
                                                arg2: *mut ck_epoch_record_t,
                                                arg3:
                                                    *mut ::kernel::sys::raw::c_void)>;
extern "C" {
    pub fn ck_epoch_init(arg1: *mut ck_epoch_t);
}
extern "C" {
    pub fn ck_epoch_recycle(arg1: *mut ck_epoch_t,
                            arg2: *mut ::kernel::sys::raw::c_void)
     -> *mut ck_epoch_record_t;
}
extern "C" {
    pub fn ck_epoch_register(arg1: *mut ck_epoch_t,
                             arg2: *mut ck_epoch_record_t,
                             arg3: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn ck_epoch_unregister(arg1: *mut ck_epoch_record_t);
}
extern "C" {
    pub fn ck_epoch_poll(arg1: *mut ck_epoch_record_t) -> bool_;
}
extern "C" {
    pub fn ck_epoch_poll_deferred(record: *mut ck_epoch_record,
                                  deferred: *mut ck_stack_t) -> bool_;
}
extern "C" {
    pub fn ck_epoch_synchronize(arg1: *mut ck_epoch_record_t);
}
extern "C" {
    pub fn ck_epoch_synchronize_wait(arg1: *mut ck_epoch_t,
                                     arg2: ck_epoch_wait_cb_t,
                                     arg3: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn ck_epoch_barrier(arg1: *mut ck_epoch_record_t);
}
extern "C" {
    pub fn ck_epoch_barrier_wait(arg1: *mut ck_epoch_record_t,
                                 arg2: ck_epoch_wait_cb_t,
                                 arg3: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn ck_epoch_reclaim(arg1: *mut ck_epoch_record_t);
}
pub type counter_u64_t = *mut u64;
extern "C" {
    #[link_name = "__pcpu"]
    pub static mut __pcpu: [pcpu; 0usize];
}
extern "C" {
    pub fn counter_u64_alloc(arg1: ::kernel::sys::raw::c_int)
     -> counter_u64_t;
}
extern "C" {
    pub fn counter_u64_free(arg1: counter_u64_t);
}
extern "C" {
    pub fn counter_u64_zero(arg1: counter_u64_t);
}
extern "C" {
    pub fn counter_u64_fetch(arg1: counter_u64_t) -> u64;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct counter_rate {
    pub cr_rate: counter_u64_t,
    pub cr_lock: ::kernel::sys::raw::c_int,
    pub cr_ticks: ::kernel::sys::raw::c_int,
    pub cr_over: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_counter_rate() {
    assert_eq!(::core::mem::size_of::<counter_rate>() , 24usize , concat ! (
               "Size of: " , stringify ! ( counter_rate ) ));
    assert_eq! (::core::mem::align_of::<counter_rate>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( counter_rate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const counter_rate ) ) . cr_rate as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( counter_rate ) , "::" ,
                stringify ! ( cr_rate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const counter_rate ) ) . cr_lock as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( counter_rate ) , "::" ,
                stringify ! ( cr_lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const counter_rate ) ) . cr_ticks as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( counter_rate ) , "::" ,
                stringify ! ( cr_ticks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const counter_rate ) ) . cr_over as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( counter_rate ) , "::" ,
                stringify ! ( cr_over ) ));
}
impl Clone for counter_rate {
    fn clone(&self) -> Self { *self }
}
impl Default for counter_rate {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    pub fn counter_ratecheck(arg1: *mut counter_rate, arg2: i64) -> i64;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct kevent {
    pub ident: __uintptr_t,
    pub filter: ::kernel::sys::raw::c_short,
    pub flags: ::kernel::sys::raw::c_ushort,
    pub fflags: ::kernel::sys::raw::c_uint,
    pub data: __int64_t,
    pub udata: *mut ::kernel::sys::raw::c_void,
    pub ext: [__uint64_t; 4usize],
}
#[test]
fn bindgen_test_layout_kevent() {
    assert_eq!(::core::mem::size_of::<kevent>() , 64usize , concat ! (
               "Size of: " , stringify ! ( kevent ) ));
    assert_eq! (::core::mem::align_of::<kevent>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kevent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kevent ) ) . ident as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kevent ) , "::" ,
                stringify ! ( ident ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kevent ) ) . filter as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kevent ) , "::" ,
                stringify ! ( filter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kevent ) ) . flags as * const _ as usize
                } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( kevent ) , "::" ,
                stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kevent ) ) . fflags as * const _ as usize
                } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( kevent ) , "::" ,
                stringify ! ( fflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kevent ) ) . data as * const _ as usize }
                , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( kevent ) , "::" ,
                stringify ! ( data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kevent ) ) . udata as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( kevent ) , "::" ,
                stringify ! ( udata ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kevent ) ) . ext as * const _ as usize }
                , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( kevent ) , "::" ,
                stringify ! ( ext ) ));
}
impl Clone for kevent {
    fn clone(&self) -> Self { *self }
}
impl Default for kevent {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kevent32 {
    pub ident: u32,
    pub filter: ::kernel::sys::raw::c_short,
    pub flags: u_short,
    pub fflags: u_int,
    pub data1: i32,
    pub data2: i32,
    pub udata: u32,
    pub ext64: [u32; 8usize],
}
#[test]
fn bindgen_test_layout_kevent32() {
    assert_eq!(::core::mem::size_of::<kevent32>() , 56usize , concat ! (
               "Size of: " , stringify ! ( kevent32 ) ));
    assert_eq! (::core::mem::align_of::<kevent32>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( kevent32 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kevent32 ) ) . ident as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kevent32 ) , "::" ,
                stringify ! ( ident ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kevent32 ) ) . filter as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( kevent32 ) , "::" ,
                stringify ! ( filter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kevent32 ) ) . flags as * const _ as
                usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( kevent32 ) , "::" ,
                stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kevent32 ) ) . fflags as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kevent32 ) , "::" ,
                stringify ! ( fflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kevent32 ) ) . data1 as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( kevent32 ) , "::" ,
                stringify ! ( data1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kevent32 ) ) . data2 as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( kevent32 ) , "::" ,
                stringify ! ( data2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kevent32 ) ) . udata as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( kevent32 ) , "::" ,
                stringify ! ( udata ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kevent32 ) ) . ext64 as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( kevent32 ) , "::" ,
                stringify ! ( ext64 ) ));
}
impl Clone for kevent32 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct knote {
    pub kn_link: knote__bindgen_ty_1,
    pub kn_selnext: knote__bindgen_ty_2,
    pub kn_knlist: *mut knlist,
    pub kn_tqe: knote__bindgen_ty_3,
    pub kn_kq: *mut kqueue,
    pub kn_kevent: kevent,
    pub kn_hook: *mut ::kernel::sys::raw::c_void,
    pub kn_hookid: ::kernel::sys::raw::c_int,
    pub kn_status: ::kernel::sys::raw::c_int,
    pub kn_influx: ::kernel::sys::raw::c_int,
    pub kn_sfflags: ::kernel::sys::raw::c_int,
    pub kn_sdata: i64,
    pub kn_ptr: knote__bindgen_ty_4,
    pub kn_fop: *mut filterops,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct knote__bindgen_ty_1 {
    pub sle_next: *mut knote,
}
#[test]
fn bindgen_test_layout_knote__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<knote__bindgen_ty_1>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( knote__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<knote__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( knote__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote__bindgen_ty_1 ) ) . sle_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( knote__bindgen_ty_1 ) ,
                "::" , stringify ! ( sle_next ) ));
}
impl Clone for knote__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for knote__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct knote__bindgen_ty_2 {
    pub sle_next: *mut knote,
}
#[test]
fn bindgen_test_layout_knote__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<knote__bindgen_ty_2>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( knote__bindgen_ty_2 ) ));
    assert_eq! (::core::mem::align_of::<knote__bindgen_ty_2>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( knote__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote__bindgen_ty_2 ) ) . sle_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( knote__bindgen_ty_2 ) ,
                "::" , stringify ! ( sle_next ) ));
}
impl Clone for knote__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for knote__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct knote__bindgen_ty_3 {
    pub tqe_next: *mut knote,
    pub tqe_prev: *mut *mut knote,
}
#[test]
fn bindgen_test_layout_knote__bindgen_ty_3() {
    assert_eq!(::core::mem::size_of::<knote__bindgen_ty_3>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( knote__bindgen_ty_3 )
               ));
    assert_eq! (::core::mem::align_of::<knote__bindgen_ty_3>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( knote__bindgen_ty_3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote__bindgen_ty_3 ) ) . tqe_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( knote__bindgen_ty_3 ) ,
                "::" , stringify ! ( tqe_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote__bindgen_ty_3 ) ) . tqe_prev as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( knote__bindgen_ty_3 ) ,
                "::" , stringify ! ( tqe_prev ) ));
}
impl Clone for knote__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
impl Default for knote__bindgen_ty_3 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub union knote__bindgen_ty_4 {
    pub p_fp: *mut file,
    pub p_proc: *mut proc_,
    pub p_aio: *mut kaiocb,
    pub p_lio: *mut aioliojob,
    pub p_v: *mut ::kernel::sys::raw::c_void,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_knote__bindgen_ty_4() {
    assert_eq!(::core::mem::size_of::<knote__bindgen_ty_4>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( knote__bindgen_ty_4 ) ));
    assert_eq! (::core::mem::align_of::<knote__bindgen_ty_4>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( knote__bindgen_ty_4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote__bindgen_ty_4 ) ) . p_fp as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( knote__bindgen_ty_4 ) ,
                "::" , stringify ! ( p_fp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote__bindgen_ty_4 ) ) . p_proc as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( knote__bindgen_ty_4 ) ,
                "::" , stringify ! ( p_proc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote__bindgen_ty_4 ) ) . p_aio as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( knote__bindgen_ty_4 ) ,
                "::" , stringify ! ( p_aio ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote__bindgen_ty_4 ) ) . p_lio as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( knote__bindgen_ty_4 ) ,
                "::" , stringify ! ( p_lio ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote__bindgen_ty_4 ) ) . p_v as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( knote__bindgen_ty_4 ) ,
                "::" , stringify ! ( p_v ) ));
}
impl Clone for knote__bindgen_ty_4 {
    fn clone(&self) -> Self { *self }
}
impl Default for knote__bindgen_ty_4 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for knote__bindgen_ty_4 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "knote__bindgen_ty_4 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_knote() {
    assert_eq!(::core::mem::size_of::<knote>() , 160usize , concat ! (
               "Size of: " , stringify ! ( knote ) ));
    assert_eq! (::core::mem::align_of::<knote>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( knote ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote ) ) . kn_link as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( knote ) , "::" ,
                stringify ! ( kn_link ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote ) ) . kn_selnext as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( knote ) , "::" ,
                stringify ! ( kn_selnext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote ) ) . kn_knlist as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( knote ) , "::" ,
                stringify ! ( kn_knlist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote ) ) . kn_tqe as * const _ as usize
                } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( knote ) , "::" ,
                stringify ! ( kn_tqe ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote ) ) . kn_kq as * const _ as usize }
                , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( knote ) , "::" ,
                stringify ! ( kn_kq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote ) ) . kn_kevent as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( knote ) , "::" ,
                stringify ! ( kn_kevent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote ) ) . kn_hook as * const _ as usize
                } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( knote ) , "::" ,
                stringify ! ( kn_hook ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote ) ) . kn_hookid as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( knote ) , "::" ,
                stringify ! ( kn_hookid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote ) ) . kn_status as * const _ as
                usize } , 124usize , concat ! (
                "Alignment of field: " , stringify ! ( knote ) , "::" ,
                stringify ! ( kn_status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote ) ) . kn_influx as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( knote ) , "::" ,
                stringify ! ( kn_influx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote ) ) . kn_sfflags as * const _ as
                usize } , 132usize , concat ! (
                "Alignment of field: " , stringify ! ( knote ) , "::" ,
                stringify ! ( kn_sfflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote ) ) . kn_sdata as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( knote ) , "::" ,
                stringify ! ( kn_sdata ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote ) ) . kn_ptr as * const _ as usize
                } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( knote ) , "::" ,
                stringify ! ( kn_ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knote ) ) . kn_fop as * const _ as usize
                } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( knote ) , "::" ,
                stringify ! ( kn_fop ) ));
}
impl Clone for knote {
    fn clone(&self) -> Self { *self }
}
impl Default for knote {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for knote {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "knote {{ kn_link: {:?}, kn_selnext: {:?}, kn_knlist: {:?}, kn_tqe: {:?}, kn_kq: {:?}, kn_kevent: {:?}, kn_hook: {:?}, kn_hookid: {:?}, kn_status: {:?}, kn_influx: {:?}, kn_sfflags: {:?}, kn_sdata: {:?}, kn_ptr: {:?}, kn_fop: {:?} }}"
               , self . kn_link , self . kn_selnext , self . kn_knlist , self
               . kn_tqe , self . kn_kq , self . kn_kevent , self . kn_hook ,
               self . kn_hookid , self . kn_status , self . kn_influx , self .
               kn_sfflags , self . kn_sdata , self . kn_ptr , self . kn_fop)
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct klist {
    pub slh_first: *mut knote,
}
#[test]
fn bindgen_test_layout_klist() {
    assert_eq!(::core::mem::size_of::<klist>() , 8usize , concat ! (
               "Size of: " , stringify ! ( klist ) ));
    assert_eq! (::core::mem::align_of::<klist>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( klist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const klist ) ) . slh_first as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( klist ) , "::" ,
                stringify ! ( slh_first ) ));
}
impl Clone for klist {
    fn clone(&self) -> Self { *self }
}
impl Default for klist {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kqueue {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct kqlist {
    pub tqh_first: *mut kqueue,
    pub tqh_last: *mut *mut kqueue,
}
#[test]
fn bindgen_test_layout_kqlist() {
    assert_eq!(::core::mem::size_of::<kqlist>() , 16usize , concat ! (
               "Size of: " , stringify ! ( kqlist ) ));
    assert_eq! (::core::mem::align_of::<kqlist>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kqlist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kqlist ) ) . tqh_first as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kqlist ) , "::" ,
                stringify ! ( tqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kqlist ) ) . tqh_last as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kqlist ) , "::" ,
                stringify ! ( tqh_last ) ));
}
impl Clone for kqlist {
    fn clone(&self) -> Self { *self }
}
impl Default for kqlist {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct knlist {
    pub kl_list: klist,
    pub kl_lock: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                 *mut ::kernel::sys::raw::c_void)>,
    pub kl_unlock: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                   *mut ::kernel::sys::raw::c_void)>,
    pub kl_assert_locked: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                          *mut ::kernel::sys::raw::c_void)>,
    pub kl_assert_unlocked: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                            *mut ::kernel::sys::raw::c_void)>,
    pub kl_lockarg: *mut ::kernel::sys::raw::c_void,
    pub kl_autodestroy: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_knlist() {
    assert_eq!(::core::mem::size_of::<knlist>() , 56usize , concat ! (
               "Size of: " , stringify ! ( knlist ) ));
    assert_eq! (::core::mem::align_of::<knlist>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( knlist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knlist ) ) . kl_list as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( knlist ) , "::" ,
                stringify ! ( kl_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knlist ) ) . kl_lock as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( knlist ) , "::" ,
                stringify ! ( kl_lock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knlist ) ) . kl_unlock as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( knlist ) , "::" ,
                stringify ! ( kl_unlock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knlist ) ) . kl_assert_locked as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( knlist ) , "::" ,
                stringify ! ( kl_assert_locked ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knlist ) ) . kl_assert_unlocked as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( knlist ) , "::" ,
                stringify ! ( kl_assert_unlocked ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knlist ) ) . kl_lockarg as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( knlist ) , "::" ,
                stringify ! ( kl_lockarg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const knlist ) ) . kl_autodestroy as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( knlist ) , "::" ,
                stringify ! ( kl_autodestroy ) ));
}
impl Clone for knlist {
    fn clone(&self) -> Self { *self }
}
impl Default for knlist {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct filterops {
    pub f_isfd: ::kernel::sys::raw::c_int,
    pub f_attach: ::core::option::Option<unsafe extern "C" fn(kn: *mut knote)
                                             -> ::kernel::sys::raw::c_int>,
    pub f_detach: ::core::option::Option<unsafe extern "C" fn(kn:
                                                                  *mut knote)>,
    pub f_event: ::core::option::Option<unsafe extern "C" fn(kn: *mut knote,
                                                             hint:
                                                                 ::kernel::sys::raw::c_long)
                                            -> ::kernel::sys::raw::c_int>,
    pub f_touch: ::core::option::Option<unsafe extern "C" fn(kn: *mut knote,
                                                             kev: *mut kevent,
                                                             type_: u_long)>,
}
#[test]
fn bindgen_test_layout_filterops() {
    assert_eq!(::core::mem::size_of::<filterops>() , 40usize , concat ! (
               "Size of: " , stringify ! ( filterops ) ));
    assert_eq! (::core::mem::align_of::<filterops>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( filterops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const filterops ) ) . f_isfd as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( filterops ) , "::" ,
                stringify ! ( f_isfd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const filterops ) ) . f_attach as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( filterops ) , "::" ,
                stringify ! ( f_attach ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const filterops ) ) . f_detach as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( filterops ) , "::" ,
                stringify ! ( f_detach ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const filterops ) ) . f_event as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( filterops ) , "::" ,
                stringify ! ( f_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const filterops ) ) . f_touch as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( filterops ) , "::" ,
                stringify ! ( f_touch ) ));
}
impl Clone for filterops {
    fn clone(&self) -> Self { *self }
}
impl Default for filterops {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct kevent_copyops {
    pub arg: *mut ::kernel::sys::raw::c_void,
    pub k_copyout: ::core::option::Option<unsafe extern "C" fn(arg:
                                                                   *mut ::kernel::sys::raw::c_void,
                                                               kevp:
                                                                   *mut kevent,
                                                               count:
                                                                   ::kernel::sys::raw::c_int)
                                              -> ::kernel::sys::raw::c_int>,
    pub k_copyin: ::core::option::Option<unsafe extern "C" fn(arg:
                                                                  *mut ::kernel::sys::raw::c_void,
                                                              kevp:
                                                                  *mut kevent,
                                                              count:
                                                                  ::kernel::sys::raw::c_int)
                                             -> ::kernel::sys::raw::c_int>,
    pub kevent_size: usize,
}
#[test]
fn bindgen_test_layout_kevent_copyops() {
    assert_eq!(::core::mem::size_of::<kevent_copyops>() , 32usize , concat ! (
               "Size of: " , stringify ! ( kevent_copyops ) ));
    assert_eq! (::core::mem::align_of::<kevent_copyops>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( kevent_copyops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kevent_copyops ) ) . arg as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kevent_copyops ) , "::"
                , stringify ! ( arg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kevent_copyops ) ) . k_copyout as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kevent_copyops ) , "::"
                , stringify ! ( k_copyout ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kevent_copyops ) ) . k_copyin as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( kevent_copyops ) , "::"
                , stringify ! ( k_copyin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kevent_copyops ) ) . kevent_size as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( kevent_copyops ) , "::"
                , stringify ! ( kevent_size ) ));
}
impl Clone for kevent_copyops {
    fn clone(&self) -> Self { *self }
}
impl Default for kevent_copyops {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rwlock {
    pub lock_object: lock_object,
    pub rw_lock: usize,
}
#[test]
fn bindgen_test_layout_rwlock() {
    assert_eq!(::core::mem::size_of::<rwlock>() , 32usize , concat ! (
               "Size of: " , stringify ! ( rwlock ) ));
    assert_eq! (::core::mem::align_of::<rwlock>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rwlock ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rwlock ) ) . lock_object as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rwlock ) , "::" ,
                stringify ! ( lock_object ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rwlock ) ) . rw_lock as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rwlock ) , "::" ,
                stringify ! ( rw_lock ) ));
}
impl Clone for rwlock {
    fn clone(&self) -> Self { *self }
}
impl Default for rwlock {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    pub fn knote(list: *mut knlist, hint: ::kernel::sys::raw::c_long,
                 lockflags: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn knote_fork(list: *mut knlist, pid: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn knlist_alloc(lock: *mut mtx) -> *mut knlist;
}
extern "C" {
    pub fn knlist_detach(knl: *mut knlist);
}
extern "C" {
    pub fn knlist_add(knl: *mut knlist, kn: *mut knote,
                      islocked: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn knlist_remove(knl: *mut knlist, kn: *mut knote,
                         islocked: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn knlist_empty(knl: *mut knlist) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn knlist_init(knl: *mut knlist,
                       lock: *mut ::kernel::sys::raw::c_void,
                       kl_lock:
                           ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                           *mut ::kernel::sys::raw::c_void)>,
                       kl_unlock:
                           ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                           *mut ::kernel::sys::raw::c_void)>,
                       kl_assert_locked:
                           ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                           *mut ::kernel::sys::raw::c_void)>,
                       kl_assert_unlocked:
                           ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                           *mut ::kernel::sys::raw::c_void)>);
}
extern "C" {
    pub fn knlist_init_mtx(knl: *mut knlist, lock: *mut mtx);
}
extern "C" {
    pub fn knlist_init_rw_reader(knl: *mut knlist, lock: *mut rwlock);
}
extern "C" {
    pub fn knlist_destroy(knl: *mut knlist);
}
extern "C" {
    pub fn knlist_cleardel(knl: *mut knlist, td: *mut thread,
                           islocked: ::kernel::sys::raw::c_int,
                           killkn: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn knote_fdclose(p: *mut thread, fd: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn kqfd_register(fd: ::kernel::sys::raw::c_int, kev: *mut kevent,
                         p: *mut thread, waitok: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn kqueue_add_filteropts(filt: ::kernel::sys::raw::c_int,
                                 filtops: *mut filterops)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn kqueue_del_filteropts(filt: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cv_waitq {
    pub tqh_first: *mut thread,
    pub tqh_last: *mut *mut thread,
}
#[test]
fn bindgen_test_layout_cv_waitq() {
    assert_eq!(::core::mem::size_of::<cv_waitq>() , 16usize , concat ! (
               "Size of: " , stringify ! ( cv_waitq ) ));
    assert_eq! (::core::mem::align_of::<cv_waitq>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( cv_waitq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cv_waitq ) ) . tqh_first as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( cv_waitq ) , "::" ,
                stringify ! ( tqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cv_waitq ) ) . tqh_last as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( cv_waitq ) , "::" ,
                stringify ! ( tqh_last ) ));
}
impl Clone for cv_waitq {
    fn clone(&self) -> Self { *self }
}
impl Default for cv_waitq {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct cv {
    pub cv_description: *const ::kernel::sys::raw::c_char,
    pub cv_waiters: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_cv() {
    assert_eq!(::core::mem::size_of::<cv>() , 16usize , concat ! (
               "Size of: " , stringify ! ( cv ) ));
    assert_eq! (::core::mem::align_of::<cv>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( cv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cv ) ) . cv_description as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( cv ) , "::" , stringify
                ! ( cv_description ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const cv ) ) . cv_waiters as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( cv ) , "::" , stringify
                ! ( cv_waiters ) ));
}
impl Clone for cv {
    fn clone(&self) -> Self { *self }
}
impl Default for cv {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    pub fn cv_init(cvp: *mut cv, desc: *const ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn cv_destroy(cvp: *mut cv);
}
extern "C" {
    pub fn _cv_wait(cvp: *mut cv, lock: *mut lock_object);
}
extern "C" {
    pub fn _cv_wait_unlock(cvp: *mut cv, lock: *mut lock_object);
}
extern "C" {
    pub fn _cv_wait_sig(cvp: *mut cv, lock: *mut lock_object)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn _cv_timedwait_sbt(cvp: *mut cv, lock: *mut lock_object,
                             sbt: sbintime_t, pr: sbintime_t,
                             flags: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn _cv_timedwait_sig_sbt(cvp: *mut cv, lock: *mut lock_object,
                                 sbt: sbintime_t, pr: sbintime_t,
                                 flags: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn cv_signal(cvp: *mut cv);
}
extern "C" {
    pub fn cv_broadcastpri(cvp: *mut cv, pri: ::kernel::sys::raw::c_int);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct osd {
    pub osd_nslots: u_int,
    pub osd_slots: *mut *mut ::kernel::sys::raw::c_void,
    pub osd_next: osd__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct osd__bindgen_ty_1 {
    pub le_next: *mut osd,
    pub le_prev: *mut *mut osd,
}
#[test]
fn bindgen_test_layout_osd__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<osd__bindgen_ty_1>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( osd__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<osd__bindgen_ty_1>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( osd__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const osd__bindgen_ty_1 ) ) . le_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( osd__bindgen_ty_1 ) ,
                "::" , stringify ! ( le_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const osd__bindgen_ty_1 ) ) . le_prev as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( osd__bindgen_ty_1 ) ,
                "::" , stringify ! ( le_prev ) ));
}
impl Clone for osd__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for osd__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_osd() {
    assert_eq!(::core::mem::size_of::<osd>() , 32usize , concat ! (
               "Size of: " , stringify ! ( osd ) ));
    assert_eq! (::core::mem::align_of::<osd>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( osd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const osd ) ) . osd_nslots as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( osd ) , "::" ,
                stringify ! ( osd_nslots ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const osd ) ) . osd_slots as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( osd ) , "::" ,
                stringify ! ( osd_slots ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const osd ) ) . osd_next as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( osd ) , "::" ,
                stringify ! ( osd_next ) ));
}
impl Clone for osd {
    fn clone(&self) -> Self { *self }
}
impl Default for osd {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type osd_destructor_t =
    ::core::option::Option<unsafe extern "C" fn(value:
                                                    *mut ::kernel::sys::raw::c_void)>;
pub type osd_method_t =
    ::core::option::Option<unsafe extern "C" fn(obj:
                                                    *mut ::kernel::sys::raw::c_void,
                                                data:
                                                    *mut ::kernel::sys::raw::c_void)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    pub fn osd_register(type_: u_int, destructor: osd_destructor_t,
                        methods: *mut osd_method_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn osd_deregister(type_: u_int, slot: u_int);
}
extern "C" {
    pub fn osd_set(type_: u_int, osd: *mut osd, slot: u_int,
                   value: *mut ::kernel::sys::raw::c_void)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn osd_reserve(slot: u_int) -> *mut *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn osd_set_reserved(type_: u_int, osd: *mut osd, slot: u_int,
                            rsv: *mut *mut ::kernel::sys::raw::c_void,
                            value: *mut ::kernel::sys::raw::c_void)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn osd_free_reserved(rsv: *mut *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn osd_get(type_: u_int, osd: *mut osd, slot: u_int)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn osd_del(type_: u_int, osd: *mut osd, slot: u_int);
}
extern "C" {
    pub fn osd_call(type_: u_int, method: u_int,
                    obj: *mut ::kernel::sys::raw::c_void,
                    data: *mut ::kernel::sys::raw::c_void)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn osd_exit(type_: u_int, osd: *mut osd);
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct rtprio {
    pub type_: u_short,
    pub prio: u_short,
}
#[test]
fn bindgen_test_layout_rtprio() {
    assert_eq!(::core::mem::size_of::<rtprio>() , 4usize , concat ! (
               "Size of: " , stringify ! ( rtprio ) ));
    assert_eq! (::core::mem::align_of::<rtprio>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( rtprio ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rtprio ) ) . type_ as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rtprio ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rtprio ) ) . prio as * const _ as usize }
                , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( rtprio ) , "::" ,
                stringify ! ( prio ) ));
}
impl Clone for rtprio {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn rtp_to_pri(arg1: *mut rtprio, arg2: *mut thread)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn pri_to_rtp(arg1: *mut thread, arg2: *mut rtprio);
}
pub type rqb_word_t = u_int64_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rqhead {
    pub tqh_first: *mut thread,
    pub tqh_last: *mut *mut thread,
}
#[test]
fn bindgen_test_layout_rqhead() {
    assert_eq!(::core::mem::size_of::<rqhead>() , 16usize , concat ! (
               "Size of: " , stringify ! ( rqhead ) ));
    assert_eq! (::core::mem::align_of::<rqhead>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rqhead ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rqhead ) ) . tqh_first as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rqhead ) , "::" ,
                stringify ! ( tqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rqhead ) ) . tqh_last as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rqhead ) , "::" ,
                stringify ! ( tqh_last ) ));
}
impl Clone for rqhead {
    fn clone(&self) -> Self { *self }
}
impl Default for rqhead {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct rqbits {
    pub rqb_bits: [rqb_word_t; 1usize],
}
#[test]
fn bindgen_test_layout_rqbits() {
    assert_eq!(::core::mem::size_of::<rqbits>() , 8usize , concat ! (
               "Size of: " , stringify ! ( rqbits ) ));
    assert_eq! (::core::mem::align_of::<rqbits>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rqbits ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rqbits ) ) . rqb_bits as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rqbits ) , "::" ,
                stringify ! ( rqb_bits ) ));
}
impl Clone for rqbits {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct runq {
    pub rq_status: rqbits,
    pub rq_queues: [rqhead; 64usize],
}
#[test]
fn bindgen_test_layout_runq() {
    assert_eq!(::core::mem::size_of::<runq>() , 1032usize , concat ! (
               "Size of: " , stringify ! ( runq ) ));
    assert_eq! (::core::mem::align_of::<runq>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( runq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const runq ) ) . rq_status as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( runq ) , "::" ,
                stringify ! ( rq_status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const runq ) ) . rq_queues as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( runq ) , "::" ,
                stringify ! ( rq_queues ) ));
}
impl Clone for runq {
    fn clone(&self) -> Self { *self }
}
impl Default for runq {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for runq {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "runq {{ rq_status: {:?}, rq_queues: [{}] }}" , self .
               rq_status , self . rq_queues . iter (  ) . enumerate (  ) . map
               (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ))
    }
}
extern "C" {
    pub fn runq_add(arg1: *mut runq, arg2: *mut thread,
                    arg3: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn runq_add_pri(arg1: *mut runq, arg2: *mut thread, arg3: u_char,
                        arg4: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn runq_check(arg1: *mut runq) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn runq_choose(arg1: *mut runq) -> *mut thread;
}
extern "C" {
    pub fn runq_choose_from(arg1: *mut runq, arg2: u_char) -> *mut thread;
}
extern "C" {
    pub fn runq_choose_fuzz(arg1: *mut runq, arg2: ::kernel::sys::raw::c_int)
     -> *mut thread;
}
extern "C" {
    pub fn runq_init(arg1: *mut runq);
}
extern "C" {
    pub fn runq_remove(arg1: *mut runq, arg2: *mut thread);
}
extern "C" {
    pub fn runq_remove_idx(arg1: *mut runq, arg2: *mut thread,
                           arg3: *mut u_char);
}
#[repr(C)]
#[derive(Copy)]
pub struct sigio {
    pub sio_u: sigio__bindgen_ty_1,
    pub sio_pgsigio: sigio__bindgen_ty_2,
    pub sio_myref: *mut *mut sigio,
    pub sio_ucred: *mut ucred,
    pub sio_pgid: pid_t,
}
#[repr(C)]
#[derive(Copy)]
pub union sigio__bindgen_ty_1 {
    pub siu_proc: *mut proc_,
    pub siu_pgrp: *mut pgrp,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_sigio__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<sigio__bindgen_ty_1>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( sigio__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<sigio__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( sigio__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigio__bindgen_ty_1 ) ) . siu_proc as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigio__bindgen_ty_1 ) ,
                "::" , stringify ! ( siu_proc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigio__bindgen_ty_1 ) ) . siu_pgrp as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigio__bindgen_ty_1 ) ,
                "::" , stringify ! ( siu_pgrp ) ));
}
impl Clone for sigio__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for sigio__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for sigio__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "sigio__bindgen_ty_1 {{ union }}")
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sigio__bindgen_ty_2 {
    pub sle_next: *mut sigio,
}
#[test]
fn bindgen_test_layout_sigio__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<sigio__bindgen_ty_2>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( sigio__bindgen_ty_2 ) ));
    assert_eq! (::core::mem::align_of::<sigio__bindgen_ty_2>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( sigio__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigio__bindgen_ty_2 ) ) . sle_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigio__bindgen_ty_2 ) ,
                "::" , stringify ! ( sle_next ) ));
}
impl Clone for sigio__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for sigio__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_sigio() {
    assert_eq!(::core::mem::size_of::<sigio>() , 40usize , concat ! (
               "Size of: " , stringify ! ( sigio ) ));
    assert_eq! (::core::mem::align_of::<sigio>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sigio ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigio ) ) . sio_u as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigio ) , "::" ,
                stringify ! ( sio_u ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigio ) ) . sio_pgsigio as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sigio ) , "::" ,
                stringify ! ( sio_pgsigio ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigio ) ) . sio_myref as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( sigio ) , "::" ,
                stringify ! ( sio_myref ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigio ) ) . sio_ucred as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( sigio ) , "::" ,
                stringify ! ( sio_ucred ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigio ) ) . sio_pgid as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( sigio ) , "::" ,
                stringify ! ( sio_pgid ) ));
}
impl Clone for sigio {
    fn clone(&self) -> Self { *self }
}
impl Default for sigio {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for sigio {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "sigio {{ sio_u: {:?}, sio_pgsigio: {:?}, sio_myref: {:?}, sio_ucred: {:?}, sio_pgid: {:?} }}"
               , self . sio_u , self . sio_pgsigio , self . sio_myref , self .
               sio_ucred , self . sio_pgid)
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sigiolst {
    pub slh_first: *mut sigio,
}
#[test]
fn bindgen_test_layout_sigiolst() {
    assert_eq!(::core::mem::size_of::<sigiolst>() , 8usize , concat ! (
               "Size of: " , stringify ! ( sigiolst ) ));
    assert_eq! (::core::mem::align_of::<sigiolst>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sigiolst ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigiolst ) ) . slh_first as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigiolst ) , "::" ,
                stringify ! ( slh_first ) ));
}
impl Clone for sigiolst {
    fn clone(&self) -> Self { *self }
}
impl Default for sigiolst {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    pub fn fgetown(sigiop: *mut *mut sigio) -> pid_t;
}
extern "C" {
    pub fn fsetown(pgid: pid_t, sigiop: *mut *mut sigio)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn funsetown(sigiop: *mut *mut sigio);
}
extern "C" {
    pub fn funsetownlst(sigiolst: *mut sigiolst);
}
pub type sig_atomic_t = ::kernel::sys::raw::c_long;
#[repr(C)]
#[derive(Copy)]
pub struct sigcontext {
    pub sc_mask: __sigset,
    pub sc_onstack: ::kernel::sys::raw::c_long,
    pub sc_rdi: ::kernel::sys::raw::c_long,
    pub sc_rsi: ::kernel::sys::raw::c_long,
    pub sc_rdx: ::kernel::sys::raw::c_long,
    pub sc_rcx: ::kernel::sys::raw::c_long,
    pub sc_r8: ::kernel::sys::raw::c_long,
    pub sc_r9: ::kernel::sys::raw::c_long,
    pub sc_rax: ::kernel::sys::raw::c_long,
    pub sc_rbx: ::kernel::sys::raw::c_long,
    pub sc_rbp: ::kernel::sys::raw::c_long,
    pub sc_r10: ::kernel::sys::raw::c_long,
    pub sc_r11: ::kernel::sys::raw::c_long,
    pub sc_r12: ::kernel::sys::raw::c_long,
    pub sc_r13: ::kernel::sys::raw::c_long,
    pub sc_r14: ::kernel::sys::raw::c_long,
    pub sc_r15: ::kernel::sys::raw::c_long,
    pub sc_trapno: ::kernel::sys::raw::c_int,
    pub sc_fs: ::kernel::sys::raw::c_short,
    pub sc_gs: ::kernel::sys::raw::c_short,
    pub sc_addr: ::kernel::sys::raw::c_long,
    pub sc_flags: ::kernel::sys::raw::c_int,
    pub sc_es: ::kernel::sys::raw::c_short,
    pub sc_ds: ::kernel::sys::raw::c_short,
    pub sc_err: ::kernel::sys::raw::c_long,
    pub sc_rip: ::kernel::sys::raw::c_long,
    pub sc_cs: ::kernel::sys::raw::c_long,
    pub sc_rflags: ::kernel::sys::raw::c_long,
    pub sc_rsp: ::kernel::sys::raw::c_long,
    pub sc_ss: ::kernel::sys::raw::c_long,
    pub sc_len: ::kernel::sys::raw::c_long,
    pub sc_fpformat: ::kernel::sys::raw::c_long,
    pub sc_ownedfp: ::kernel::sys::raw::c_long,
    pub sc_fpstate: [::kernel::sys::raw::c_long; 64usize],
    pub sc_fsbase: ::kernel::sys::raw::c_long,
    pub sc_gsbase: ::kernel::sys::raw::c_long,
    pub sc_xfpustate: ::kernel::sys::raw::c_long,
    pub sc_xfpustate_len: ::kernel::sys::raw::c_long,
    pub sc_spare: [::kernel::sys::raw::c_long; 4usize],
}
#[test]
fn bindgen_test_layout_sigcontext() {
    assert_eq!(::core::mem::size_of::<sigcontext>() , 816usize , concat ! (
               "Size of: " , stringify ! ( sigcontext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_mask as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_onstack as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_onstack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_rdi as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_rdi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_rsi as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_rsi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_rdx as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_rdx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_rcx as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_rcx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_r8 as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_r8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_r9 as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_r9 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_rax as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_rax ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_rbx as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_rbx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_rbp as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_rbp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_r10 as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_r10 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_r11 as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_r11 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_r12 as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_r12 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_r13 as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_r13 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_r14 as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_r14 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_r15 as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_r15 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_trapno as * const _
                as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_trapno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_fs as * const _ as
                usize } , 148usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_fs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_gs as * const _ as
                usize } , 150usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_gs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_addr as * const _ as
                usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_flags as * const _ as
                usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_es as * const _ as
                usize } , 164usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_es ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_ds as * const _ as
                usize } , 166usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_ds ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_err as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_err ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_rip as * const _ as
                usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_rip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_cs as * const _ as
                usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_cs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_rflags as * const _
                as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_rflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_rsp as * const _ as
                usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_rsp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_ss as * const _ as
                usize } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_ss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_len as * const _ as
                usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_fpformat as * const _
                as usize } , 224usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_fpformat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_ownedfp as * const _
                as usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_ownedfp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_fpstate as * const _
                as usize } , 240usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_fpstate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_fsbase as * const _
                as usize } , 752usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_fsbase ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_gsbase as * const _
                as usize } , 760usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_gsbase ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_xfpustate as * const
                _ as usize } , 768usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_xfpustate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_xfpustate_len as *
                const _ as usize } , 776usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_xfpustate_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigcontext ) ) . sc_spare as * const _ as
                usize } , 784usize , concat ! (
                "Alignment of field: " , stringify ! ( sigcontext ) , "::" ,
                stringify ! ( sc_spare ) ));
}
impl Clone for sigcontext {
    fn clone(&self) -> Self { *self }
}
impl Default for sigcontext {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for sigcontext {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "sigcontext {{ sc_mask: {:?}, sc_onstack: {:?}, sc_rdi: {:?}, sc_rsi: {:?}, sc_rdx: {:?}, sc_rcx: {:?}, sc_r8: {:?}, sc_r9: {:?}, sc_rax: {:?}, sc_rbx: {:?}, sc_rbp: {:?}, sc_r10: {:?}, sc_r11: {:?}, sc_r12: {:?}, sc_r13: {:?}, sc_r14: {:?}, sc_r15: {:?}, sc_trapno: {:?}, sc_fs: {:?}, sc_gs: {:?}, sc_addr: {:?}, sc_flags: {:?}, sc_es: {:?}, sc_ds: {:?}, sc_err: {:?}, sc_rip: {:?}, sc_cs: {:?}, sc_rflags: {:?}, sc_rsp: {:?}, sc_ss: {:?}, sc_len: {:?}, sc_fpformat: {:?}, sc_ownedfp: {:?}, sc_fpstate: [{}], sc_fsbase: {:?}, sc_gsbase: {:?}, sc_xfpustate: {:?}, sc_xfpustate_len: {:?}, sc_spare: {:?} }}"
               , self . sc_mask , self . sc_onstack , self . sc_rdi , self .
               sc_rsi , self . sc_rdx , self . sc_rcx , self . sc_r8 , self .
               sc_r9 , self . sc_rax , self . sc_rbx , self . sc_rbp , self .
               sc_r10 , self . sc_r11 , self . sc_r12 , self . sc_r13 , self .
               sc_r14 , self . sc_r15 , self . sc_trapno , self . sc_fs , self
               . sc_gs , self . sc_addr , self . sc_flags , self . sc_es ,
               self . sc_ds , self . sc_err , self . sc_rip , self . sc_cs ,
               self . sc_rflags , self . sc_rsp , self . sc_ss , self . sc_len
               , self . sc_fpformat , self . sc_ownedfp , self . sc_fpstate .
               iter (  ) . enumerate (  ) . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ) , self . sc_fsbase , self . sc_gsbase , self .
               sc_xfpustate , self . sc_xfpustate_len , self . sc_spare)
    }
}
pub type __sighandler_t =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    ::kernel::sys::raw::c_int)>;
#[repr(C)]
#[derive(Copy)]
pub union sigval {
    pub sival_int: ::kernel::sys::raw::c_int,
    pub sival_ptr: *mut ::kernel::sys::raw::c_void,
    pub sigval_int: ::kernel::sys::raw::c_int,
    pub sigval_ptr: *mut ::kernel::sys::raw::c_void,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_sigval() {
    assert_eq!(::core::mem::size_of::<sigval>() , 8usize , concat ! (
               "Size of: " , stringify ! ( sigval ) ));
    assert_eq! (::core::mem::align_of::<sigval>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sigval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigval ) ) . sival_int as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigval ) , "::" ,
                stringify ! ( sival_int ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigval ) ) . sival_ptr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigval ) , "::" ,
                stringify ! ( sival_ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigval ) ) . sigval_int as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigval ) , "::" ,
                stringify ! ( sigval_int ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigval ) ) . sigval_ptr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigval ) , "::" ,
                stringify ! ( sigval_ptr ) ));
}
impl Clone for sigval {
    fn clone(&self) -> Self { *self }
}
impl Default for sigval {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for sigval {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "sigval {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy)]
pub union sigval32 {
    pub sival_int: ::kernel::sys::raw::c_int,
    pub sival_ptr: u32,
    pub sigval_int: ::kernel::sys::raw::c_int,
    pub sigval_ptr: u32,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_sigval32() {
    assert_eq!(::core::mem::size_of::<sigval32>() , 4usize , concat ! (
               "Size of: " , stringify ! ( sigval32 ) ));
    assert_eq! (::core::mem::align_of::<sigval32>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( sigval32 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigval32 ) ) . sival_int as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigval32 ) , "::" ,
                stringify ! ( sival_int ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigval32 ) ) . sival_ptr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigval32 ) , "::" ,
                stringify ! ( sival_ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigval32 ) ) . sigval_int as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigval32 ) , "::" ,
                stringify ! ( sigval_int ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigval32 ) ) . sigval_ptr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigval32 ) , "::" ,
                stringify ! ( sigval_ptr ) ));
}
impl Clone for sigval32 {
    fn clone(&self) -> Self { *self }
}
impl Default for sigval32 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for sigval32 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "sigval32 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct sigevent {
    pub sigev_notify: ::kernel::sys::raw::c_int,
    pub sigev_signo: ::kernel::sys::raw::c_int,
    pub sigev_value: sigval,
    pub _sigev_un: sigevent__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub union sigevent__bindgen_ty_1 {
    pub _threadid: __lwpid_t,
    pub _sigev_thread: sigevent__bindgen_ty_1__bindgen_ty_1,
    pub _kevent_flags: ::kernel::sys::raw::c_ushort,
    pub __spare__: [::kernel::sys::raw::c_long; 8usize],
    _bindgen_union_align: [u64; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sigevent__bindgen_ty_1__bindgen_ty_1 {
    pub _function: ::core::option::Option<unsafe extern "C" fn(arg1: sigval)>,
    pub _attribute: *mut *mut pthread_attr,
}
#[test]
fn bindgen_test_layout_sigevent__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<sigevent__bindgen_ty_1__bindgen_ty_1>()
               , 16usize , concat ! (
               "Size of: " , stringify ! (
               sigevent__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<sigevent__bindgen_ty_1__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                sigevent__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent__bindgen_ty_1__bindgen_ty_1 ) )
                . _function as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                sigevent__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! (
                _function ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent__bindgen_ty_1__bindgen_ty_1 ) )
                . _attribute as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                sigevent__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! (
                _attribute ) ));
}
impl Clone for sigevent__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for sigevent__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_sigevent__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<sigevent__bindgen_ty_1>() , 64usize ,
               concat ! ( "Size of: " , stringify ! ( sigevent__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<sigevent__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( sigevent__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent__bindgen_ty_1 ) ) . _threadid as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigevent__bindgen_ty_1
                ) , "::" , stringify ! ( _threadid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent__bindgen_ty_1 ) ) .
                _sigev_thread as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigevent__bindgen_ty_1
                ) , "::" , stringify ! ( _sigev_thread ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent__bindgen_ty_1 ) ) .
                _kevent_flags as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigevent__bindgen_ty_1
                ) , "::" , stringify ! ( _kevent_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent__bindgen_ty_1 ) ) . __spare__ as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigevent__bindgen_ty_1
                ) , "::" , stringify ! ( __spare__ ) ));
}
impl Clone for sigevent__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for sigevent__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for sigevent__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "sigevent__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_sigevent() {
    assert_eq!(::core::mem::size_of::<sigevent>() , 80usize , concat ! (
               "Size of: " , stringify ! ( sigevent ) ));
    assert_eq! (::core::mem::align_of::<sigevent>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sigevent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent ) ) . sigev_notify as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigevent ) , "::" ,
                stringify ! ( sigev_notify ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent ) ) . sigev_signo as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( sigevent ) , "::" ,
                stringify ! ( sigev_signo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent ) ) . sigev_value as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sigevent ) , "::" ,
                stringify ! ( sigev_value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigevent ) ) . _sigev_un as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( sigevent ) , "::" ,
                stringify ! ( _sigev_un ) ));
}
impl Clone for sigevent {
    fn clone(&self) -> Self { *self }
}
impl Default for sigevent {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for sigevent {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "sigevent {{ sigev_notify: {:?}, sigev_signo: {:?}, sigev_value: {:?}, _sigev_un: {:?} }}"
               , self . sigev_notify , self . sigev_signo , self . sigev_value
               , self . _sigev_un)
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct __siginfo {
    pub si_signo: ::kernel::sys::raw::c_int,
    pub si_errno: ::kernel::sys::raw::c_int,
    pub si_code: ::kernel::sys::raw::c_int,
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_status: ::kernel::sys::raw::c_int,
    pub si_addr: *mut ::kernel::sys::raw::c_void,
    pub si_value: sigval,
    pub _reason: __siginfo__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub union __siginfo__bindgen_ty_1 {
    pub _fault: __siginfo__bindgen_ty_1__bindgen_ty_1,
    pub _timer: __siginfo__bindgen_ty_1__bindgen_ty_2,
    pub _mesgq: __siginfo__bindgen_ty_1__bindgen_ty_3,
    pub _poll: __siginfo__bindgen_ty_1__bindgen_ty_4,
    pub __spare__: __siginfo__bindgen_ty_1__bindgen_ty_5,
    _bindgen_union_align: [u64; 5usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct __siginfo__bindgen_ty_1__bindgen_ty_1 {
    pub _trapno: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout___siginfo__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<__siginfo__bindgen_ty_1__bindgen_ty_1>()
               , 4usize , concat ! (
               "Size of: " , stringify ! (
               __siginfo__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<__siginfo__bindgen_ty_1__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                __siginfo__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo__bindgen_ty_1__bindgen_ty_1 ) )
                . _trapno as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __siginfo__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! (
                _trapno ) ));
}
impl Clone for __siginfo__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct __siginfo__bindgen_ty_1__bindgen_ty_2 {
    pub _timerid: ::kernel::sys::raw::c_int,
    pub _overrun: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout___siginfo__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<__siginfo__bindgen_ty_1__bindgen_ty_2>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               __siginfo__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (::core::mem::align_of::<__siginfo__bindgen_ty_1__bindgen_ty_2>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                __siginfo__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo__bindgen_ty_1__bindgen_ty_2 ) )
                . _timerid as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __siginfo__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify ! (
                _timerid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo__bindgen_ty_1__bindgen_ty_2 ) )
                . _overrun as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                __siginfo__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify ! (
                _overrun ) ));
}
impl Clone for __siginfo__bindgen_ty_1__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct __siginfo__bindgen_ty_1__bindgen_ty_3 {
    pub _mqd: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout___siginfo__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(::core::mem::size_of::<__siginfo__bindgen_ty_1__bindgen_ty_3>()
               , 4usize , concat ! (
               "Size of: " , stringify ! (
               __siginfo__bindgen_ty_1__bindgen_ty_3 ) ));
    assert_eq! (::core::mem::align_of::<__siginfo__bindgen_ty_1__bindgen_ty_3>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                __siginfo__bindgen_ty_1__bindgen_ty_3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo__bindgen_ty_1__bindgen_ty_3 ) )
                . _mqd as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __siginfo__bindgen_ty_1__bindgen_ty_3 ) , "::" , stringify ! (
                _mqd ) ));
}
impl Clone for __siginfo__bindgen_ty_1__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct __siginfo__bindgen_ty_1__bindgen_ty_4 {
    pub _band: ::kernel::sys::raw::c_long,
}
#[test]
fn bindgen_test_layout___siginfo__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(::core::mem::size_of::<__siginfo__bindgen_ty_1__bindgen_ty_4>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               __siginfo__bindgen_ty_1__bindgen_ty_4 ) ));
    assert_eq! (::core::mem::align_of::<__siginfo__bindgen_ty_1__bindgen_ty_4>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                __siginfo__bindgen_ty_1__bindgen_ty_4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo__bindgen_ty_1__bindgen_ty_4 ) )
                . _band as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __siginfo__bindgen_ty_1__bindgen_ty_4 ) , "::" , stringify ! (
                _band ) ));
}
impl Clone for __siginfo__bindgen_ty_1__bindgen_ty_4 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct __siginfo__bindgen_ty_1__bindgen_ty_5 {
    pub __spare1__: ::kernel::sys::raw::c_long,
    pub __spare2__: [::kernel::sys::raw::c_int; 7usize],
}
#[test]
fn bindgen_test_layout___siginfo__bindgen_ty_1__bindgen_ty_5() {
    assert_eq!(::core::mem::size_of::<__siginfo__bindgen_ty_1__bindgen_ty_5>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               __siginfo__bindgen_ty_1__bindgen_ty_5 ) ));
    assert_eq! (::core::mem::align_of::<__siginfo__bindgen_ty_1__bindgen_ty_5>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                __siginfo__bindgen_ty_1__bindgen_ty_5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo__bindgen_ty_1__bindgen_ty_5 ) )
                . __spare1__ as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __siginfo__bindgen_ty_1__bindgen_ty_5 ) , "::" , stringify ! (
                __spare1__ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo__bindgen_ty_1__bindgen_ty_5 ) )
                . __spare2__ as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                __siginfo__bindgen_ty_1__bindgen_ty_5 ) , "::" , stringify ! (
                __spare2__ ) ));
}
impl Clone for __siginfo__bindgen_ty_1__bindgen_ty_5 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout___siginfo__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<__siginfo__bindgen_ty_1>() , 40usize ,
               concat ! (
               "Size of: " , stringify ! ( __siginfo__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<__siginfo__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( __siginfo__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo__bindgen_ty_1 ) ) . _fault as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo__bindgen_ty_1
                ) , "::" , stringify ! ( _fault ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo__bindgen_ty_1 ) ) . _timer as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo__bindgen_ty_1
                ) , "::" , stringify ! ( _timer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo__bindgen_ty_1 ) ) . _mesgq as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo__bindgen_ty_1
                ) , "::" , stringify ! ( _mesgq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo__bindgen_ty_1 ) ) . _poll as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo__bindgen_ty_1
                ) , "::" , stringify ! ( _poll ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo__bindgen_ty_1 ) ) . __spare__
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo__bindgen_ty_1
                ) , "::" , stringify ! ( __spare__ ) ));
}
impl Clone for __siginfo__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for __siginfo__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for __siginfo__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "__siginfo__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout___siginfo() {
    assert_eq!(::core::mem::size_of::<__siginfo>() , 80usize , concat ! (
               "Size of: " , stringify ! ( __siginfo ) ));
    assert_eq! (::core::mem::align_of::<__siginfo>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __siginfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo ) ) . si_signo as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo ) , "::" ,
                stringify ! ( si_signo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo ) ) . si_errno as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo ) , "::" ,
                stringify ! ( si_errno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo ) ) . si_code as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo ) , "::" ,
                stringify ! ( si_code ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo ) ) . si_pid as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo ) , "::" ,
                stringify ! ( si_pid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo ) ) . si_uid as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo ) , "::" ,
                stringify ! ( si_uid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo ) ) . si_status as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo ) , "::" ,
                stringify ! ( si_status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo ) ) . si_addr as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo ) , "::" ,
                stringify ! ( si_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo ) ) . si_value as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo ) , "::" ,
                stringify ! ( si_value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __siginfo ) ) . _reason as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( __siginfo ) , "::" ,
                stringify ! ( _reason ) ));
}
impl Clone for __siginfo {
    fn clone(&self) -> Self { *self }
}
impl Default for __siginfo {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for __siginfo {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "__siginfo {{ si_signo: {:?}, si_errno: {:?}, si_code: {:?}, si_pid: {:?}, si_uid: {:?}, si_status: {:?}, si_addr: {:?}, si_value: {:?}, _reason: {:?} }}"
               , self . si_signo , self . si_errno , self . si_code , self .
               si_pid , self . si_uid , self . si_status , self . si_addr ,
               self . si_value , self . _reason)
    }
}
pub type siginfo_t = __siginfo;
#[repr(C)]
#[derive(Copy)]
pub struct siginfo32 {
    pub si_signo: ::kernel::sys::raw::c_int,
    pub si_errno: ::kernel::sys::raw::c_int,
    pub si_code: ::kernel::sys::raw::c_int,
    pub si_pid: __pid_t,
    pub si_uid: __uid_t,
    pub si_status: ::kernel::sys::raw::c_int,
    pub si_addr: u32,
    pub si_value: sigval32,
    pub _reason: siginfo32__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub union siginfo32__bindgen_ty_1 {
    pub _fault: siginfo32__bindgen_ty_1__bindgen_ty_1,
    pub _timer: siginfo32__bindgen_ty_1__bindgen_ty_2,
    pub _mesgq: siginfo32__bindgen_ty_1__bindgen_ty_3,
    pub _poll: siginfo32__bindgen_ty_1__bindgen_ty_4,
    pub __spare__: siginfo32__bindgen_ty_1__bindgen_ty_5,
    _bindgen_union_align: [u32; 8usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct siginfo32__bindgen_ty_1__bindgen_ty_1 {
    pub _trapno: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_siginfo32__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<siginfo32__bindgen_ty_1__bindgen_ty_1>()
               , 4usize , concat ! (
               "Size of: " , stringify ! (
               siginfo32__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<siginfo32__bindgen_ty_1__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                siginfo32__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo32__bindgen_ty_1__bindgen_ty_1 ) )
                . _trapno as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo32__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! (
                _trapno ) ));
}
impl Clone for siginfo32__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct siginfo32__bindgen_ty_1__bindgen_ty_2 {
    pub _timerid: ::kernel::sys::raw::c_int,
    pub _overrun: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_siginfo32__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<siginfo32__bindgen_ty_1__bindgen_ty_2>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               siginfo32__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (::core::mem::align_of::<siginfo32__bindgen_ty_1__bindgen_ty_2>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                siginfo32__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo32__bindgen_ty_1__bindgen_ty_2 ) )
                . _timerid as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo32__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify ! (
                _timerid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo32__bindgen_ty_1__bindgen_ty_2 ) )
                . _overrun as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo32__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify ! (
                _overrun ) ));
}
impl Clone for siginfo32__bindgen_ty_1__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct siginfo32__bindgen_ty_1__bindgen_ty_3 {
    pub _mqd: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_siginfo32__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(::core::mem::size_of::<siginfo32__bindgen_ty_1__bindgen_ty_3>()
               , 4usize , concat ! (
               "Size of: " , stringify ! (
               siginfo32__bindgen_ty_1__bindgen_ty_3 ) ));
    assert_eq! (::core::mem::align_of::<siginfo32__bindgen_ty_1__bindgen_ty_3>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                siginfo32__bindgen_ty_1__bindgen_ty_3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo32__bindgen_ty_1__bindgen_ty_3 ) )
                . _mqd as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo32__bindgen_ty_1__bindgen_ty_3 ) , "::" , stringify ! (
                _mqd ) ));
}
impl Clone for siginfo32__bindgen_ty_1__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct siginfo32__bindgen_ty_1__bindgen_ty_4 {
    pub _band: i32,
}
#[test]
fn bindgen_test_layout_siginfo32__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(::core::mem::size_of::<siginfo32__bindgen_ty_1__bindgen_ty_4>()
               , 4usize , concat ! (
               "Size of: " , stringify ! (
               siginfo32__bindgen_ty_1__bindgen_ty_4 ) ));
    assert_eq! (::core::mem::align_of::<siginfo32__bindgen_ty_1__bindgen_ty_4>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                siginfo32__bindgen_ty_1__bindgen_ty_4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo32__bindgen_ty_1__bindgen_ty_4 ) )
                . _band as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo32__bindgen_ty_1__bindgen_ty_4 ) , "::" , stringify ! (
                _band ) ));
}
impl Clone for siginfo32__bindgen_ty_1__bindgen_ty_4 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct siginfo32__bindgen_ty_1__bindgen_ty_5 {
    pub __spare1__: i32,
    pub __spare2__: [::kernel::sys::raw::c_int; 7usize],
}
#[test]
fn bindgen_test_layout_siginfo32__bindgen_ty_1__bindgen_ty_5() {
    assert_eq!(::core::mem::size_of::<siginfo32__bindgen_ty_1__bindgen_ty_5>()
               , 32usize , concat ! (
               "Size of: " , stringify ! (
               siginfo32__bindgen_ty_1__bindgen_ty_5 ) ));
    assert_eq! (::core::mem::align_of::<siginfo32__bindgen_ty_1__bindgen_ty_5>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                siginfo32__bindgen_ty_1__bindgen_ty_5 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo32__bindgen_ty_1__bindgen_ty_5 ) )
                . __spare1__ as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo32__bindgen_ty_1__bindgen_ty_5 ) , "::" , stringify ! (
                __spare1__ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo32__bindgen_ty_1__bindgen_ty_5 ) )
                . __spare2__ as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                siginfo32__bindgen_ty_1__bindgen_ty_5 ) , "::" , stringify ! (
                __spare2__ ) ));
}
impl Clone for siginfo32__bindgen_ty_1__bindgen_ty_5 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_siginfo32__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<siginfo32__bindgen_ty_1>() , 32usize ,
               concat ! (
               "Size of: " , stringify ! ( siginfo32__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<siginfo32__bindgen_ty_1>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( siginfo32__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo32__bindgen_ty_1 ) ) . _fault as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo32__bindgen_ty_1
                ) , "::" , stringify ! ( _fault ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo32__bindgen_ty_1 ) ) . _timer as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo32__bindgen_ty_1
                ) , "::" , stringify ! ( _timer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo32__bindgen_ty_1 ) ) . _mesgq as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo32__bindgen_ty_1
                ) , "::" , stringify ! ( _mesgq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo32__bindgen_ty_1 ) ) . _poll as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo32__bindgen_ty_1
                ) , "::" , stringify ! ( _poll ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo32__bindgen_ty_1 ) ) . __spare__
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo32__bindgen_ty_1
                ) , "::" , stringify ! ( __spare__ ) ));
}
impl Clone for siginfo32__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for siginfo32__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for siginfo32__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "siginfo32__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_siginfo32() {
    assert_eq!(::core::mem::size_of::<siginfo32>() , 64usize , concat ! (
               "Size of: " , stringify ! ( siginfo32 ) ));
    assert_eq! (::core::mem::align_of::<siginfo32>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( siginfo32 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo32 ) ) . si_signo as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo32 ) , "::" ,
                stringify ! ( si_signo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo32 ) ) . si_errno as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo32 ) , "::" ,
                stringify ! ( si_errno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo32 ) ) . si_code as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo32 ) , "::" ,
                stringify ! ( si_code ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo32 ) ) . si_pid as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo32 ) , "::" ,
                stringify ! ( si_pid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo32 ) ) . si_uid as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo32 ) , "::" ,
                stringify ! ( si_uid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo32 ) ) . si_status as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo32 ) , "::" ,
                stringify ! ( si_status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo32 ) ) . si_addr as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo32 ) , "::" ,
                stringify ! ( si_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo32 ) ) . si_value as * const _ as
                usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo32 ) , "::" ,
                stringify ! ( si_value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const siginfo32 ) ) . _reason as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( siginfo32 ) , "::" ,
                stringify ! ( _reason ) ));
}
impl Clone for siginfo32 {
    fn clone(&self) -> Self { *self }
}
impl Default for siginfo32 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for siginfo32 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "siginfo32 {{ si_signo: {:?}, si_errno: {:?}, si_code: {:?}, si_pid: {:?}, si_uid: {:?}, si_status: {:?}, si_addr: {:?}, si_value: {:?}, _reason: {:?} }}"
               , self . si_signo , self . si_errno , self . si_code , self .
               si_pid , self . si_uid , self . si_status , self . si_addr ,
               self . si_value , self . _reason)
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct sigaction {
    pub __sigaction_u: sigaction__bindgen_ty_1,
    pub sa_flags: ::kernel::sys::raw::c_int,
    pub sa_mask: sigset_t,
}
#[repr(C)]
#[derive(Copy)]
pub union sigaction__bindgen_ty_1 {
    pub __sa_handler: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                      ::kernel::sys::raw::c_int)>,
    pub __sa_sigaction: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                        ::kernel::sys::raw::c_int,
                                                                    arg2:
                                                                        *mut __siginfo,
                                                                    arg3:
                                                                        *mut ::kernel::sys::raw::c_void)>,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_sigaction__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<sigaction__bindgen_ty_1>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( sigaction__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<sigaction__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( sigaction__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigaction__bindgen_ty_1 ) ) .
                __sa_handler as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigaction__bindgen_ty_1
                ) , "::" , stringify ! ( __sa_handler ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigaction__bindgen_ty_1 ) ) .
                __sa_sigaction as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigaction__bindgen_ty_1
                ) , "::" , stringify ! ( __sa_sigaction ) ));
}
impl Clone for sigaction__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for sigaction__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for sigaction__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "sigaction__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_sigaction() {
    assert_eq!(::core::mem::size_of::<sigaction>() , 32usize , concat ! (
               "Size of: " , stringify ! ( sigaction ) ));
    assert_eq! (::core::mem::align_of::<sigaction>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sigaction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigaction ) ) . __sigaction_u as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigaction ) , "::" ,
                stringify ! ( __sigaction_u ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigaction ) ) . sa_flags as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sigaction ) , "::" ,
                stringify ! ( sa_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigaction ) ) . sa_mask as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( sigaction ) , "::" ,
                stringify ! ( sa_mask ) ));
}
impl Clone for sigaction {
    fn clone(&self) -> Self { *self }
}
impl Default for sigaction {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for sigaction {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "sigaction {{ __sigaction_u: {:?}, sa_flags: {:?}, sa_mask: {:?} }}"
               , self . __sigaction_u , self . sa_flags , self . sa_mask)
    }
}
pub type sig_t = __sighandler_t;
pub type __siginfohandler_t =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    ::kernel::sys::raw::c_int,
                                                arg2: *mut __siginfo,
                                                arg3:
                                                    *mut ::kernel::sys::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sigaltstack {
    pub ss_sp: *mut ::kernel::sys::raw::c_void,
    pub ss_size: __size_t,
    pub ss_flags: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigaltstack() {
    assert_eq!(::core::mem::size_of::<sigaltstack>() , 24usize , concat ! (
               "Size of: " , stringify ! ( sigaltstack ) ));
    assert_eq! (::core::mem::align_of::<sigaltstack>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sigaltstack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigaltstack ) ) . ss_sp as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigaltstack ) , "::" ,
                stringify ! ( ss_sp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigaltstack ) ) . ss_size as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sigaltstack ) , "::" ,
                stringify ! ( ss_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigaltstack ) ) . ss_flags as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( sigaltstack ) , "::" ,
                stringify ! ( ss_flags ) ));
}
impl Clone for sigaltstack {
    fn clone(&self) -> Self { *self }
}
impl Default for sigaltstack {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type stack_t = sigaltstack;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sigvec {
    pub sv_handler: __sighandler_t,
    pub sv_mask: ::kernel::sys::raw::c_int,
    pub sv_flags: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigvec() {
    assert_eq!(::core::mem::size_of::<sigvec>() , 16usize , concat ! (
               "Size of: " , stringify ! ( sigvec ) ));
    assert_eq! (::core::mem::align_of::<sigvec>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sigvec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigvec ) ) . sv_handler as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigvec ) , "::" ,
                stringify ! ( sv_handler ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigvec ) ) . sv_mask as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sigvec ) , "::" ,
                stringify ! ( sv_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigvec ) ) . sv_flags as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( sigvec ) , "::" ,
                stringify ! ( sv_flags ) ));
}
impl Clone for sigvec {
    fn clone(&self) -> Self { *self }
}
impl Default for sigvec {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sigstack {
    pub ss_sp: *mut ::kernel::sys::raw::c_void,
    pub ss_onstack: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_sigstack() {
    assert_eq!(::core::mem::size_of::<sigstack>() , 16usize , concat ! (
               "Size of: " , stringify ! ( sigstack ) ));
    assert_eq! (::core::mem::align_of::<sigstack>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sigstack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigstack ) ) . ss_sp as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigstack ) , "::" ,
                stringify ! ( ss_sp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigstack ) ) . ss_onstack as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sigstack ) , "::" ,
                stringify ! ( ss_onstack ) ));
}
impl Clone for sigstack {
    fn clone(&self) -> Self { *self }
}
impl Default for sigstack {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    pub fn signal(arg1: ::kernel::sys::raw::c_int, arg2: __sighandler_t)
     -> __sighandler_t;
}
#[repr(C)]
#[derive(Copy)]
pub struct sigacts {
    pub ps_sigact: [sig_t; 128usize],
    pub ps_catchmask: [sigset_t; 128usize],
    pub ps_sigonstack: sigset_t,
    pub ps_sigintr: sigset_t,
    pub ps_sigreset: sigset_t,
    pub ps_signodefer: sigset_t,
    pub ps_siginfo: sigset_t,
    pub ps_sigignore: sigset_t,
    pub ps_sigcatch: sigset_t,
    pub ps_freebsd4: sigset_t,
    pub ps_osigset: sigset_t,
    pub ps_usertramp: sigset_t,
    pub ps_flag: ::kernel::sys::raw::c_int,
    pub ps_refcnt: u_int,
    pub ps_mtx: mtx,
}
#[test]
fn bindgen_test_layout_sigacts() {
    assert_eq!(::core::mem::size_of::<sigacts>() , 3272usize , concat ! (
               "Size of: " , stringify ! ( sigacts ) ));
    assert_eq! (::core::mem::align_of::<sigacts>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sigacts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigacts ) ) . ps_sigact as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigacts ) , "::" ,
                stringify ! ( ps_sigact ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigacts ) ) . ps_catchmask as * const _
                as usize } , 1024usize , concat ! (
                "Alignment of field: " , stringify ! ( sigacts ) , "::" ,
                stringify ! ( ps_catchmask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigacts ) ) . ps_sigonstack as * const _
                as usize } , 3072usize , concat ! (
                "Alignment of field: " , stringify ! ( sigacts ) , "::" ,
                stringify ! ( ps_sigonstack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigacts ) ) . ps_sigintr as * const _ as
                usize } , 3088usize , concat ! (
                "Alignment of field: " , stringify ! ( sigacts ) , "::" ,
                stringify ! ( ps_sigintr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigacts ) ) . ps_sigreset as * const _ as
                usize } , 3104usize , concat ! (
                "Alignment of field: " , stringify ! ( sigacts ) , "::" ,
                stringify ! ( ps_sigreset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigacts ) ) . ps_signodefer as * const _
                as usize } , 3120usize , concat ! (
                "Alignment of field: " , stringify ! ( sigacts ) , "::" ,
                stringify ! ( ps_signodefer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigacts ) ) . ps_siginfo as * const _ as
                usize } , 3136usize , concat ! (
                "Alignment of field: " , stringify ! ( sigacts ) , "::" ,
                stringify ! ( ps_siginfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigacts ) ) . ps_sigignore as * const _
                as usize } , 3152usize , concat ! (
                "Alignment of field: " , stringify ! ( sigacts ) , "::" ,
                stringify ! ( ps_sigignore ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigacts ) ) . ps_sigcatch as * const _ as
                usize } , 3168usize , concat ! (
                "Alignment of field: " , stringify ! ( sigacts ) , "::" ,
                stringify ! ( ps_sigcatch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigacts ) ) . ps_freebsd4 as * const _ as
                usize } , 3184usize , concat ! (
                "Alignment of field: " , stringify ! ( sigacts ) , "::" ,
                stringify ! ( ps_freebsd4 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigacts ) ) . ps_osigset as * const _ as
                usize } , 3200usize , concat ! (
                "Alignment of field: " , stringify ! ( sigacts ) , "::" ,
                stringify ! ( ps_osigset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigacts ) ) . ps_usertramp as * const _
                as usize } , 3216usize , concat ! (
                "Alignment of field: " , stringify ! ( sigacts ) , "::" ,
                stringify ! ( ps_usertramp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigacts ) ) . ps_flag as * const _ as
                usize } , 3232usize , concat ! (
                "Alignment of field: " , stringify ! ( sigacts ) , "::" ,
                stringify ! ( ps_flag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigacts ) ) . ps_refcnt as * const _ as
                usize } , 3236usize , concat ! (
                "Alignment of field: " , stringify ! ( sigacts ) , "::" ,
                stringify ! ( ps_refcnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigacts ) ) . ps_mtx as * const _ as
                usize } , 3240usize , concat ! (
                "Alignment of field: " , stringify ! ( sigacts ) , "::" ,
                stringify ! ( ps_mtx ) ));
}
impl Clone for sigacts {
    fn clone(&self) -> Self { *self }
}
impl Default for sigacts {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for sigacts {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "sigacts {{ ps_sigact: [{}], ps_catchmask: [{}], ps_sigonstack: {:?}, ps_sigintr: {:?}, ps_sigreset: {:?}, ps_signodefer: {:?}, ps_siginfo: {:?}, ps_sigignore: {:?}, ps_sigcatch: {:?}, ps_freebsd4: {:?}, ps_osigset: {:?}, ps_usertramp: {:?}, ps_flag: {:?}, ps_refcnt: {:?}, ps_mtx: {:?} }}"
               , self . ps_sigact . iter (  ) . enumerate (  ) . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ) , self . ps_catchmask . iter (  ) . enumerate (
               ) . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ) , self . ps_sigonstack , self . ps_sigintr , self
               . ps_sigreset , self . ps_signodefer , self . ps_siginfo , self
               . ps_sigignore , self . ps_sigcatch , self . ps_freebsd4 , self
               . ps_osigset , self . ps_usertramp , self . ps_flag , self .
               ps_refcnt , self . ps_mtx)
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct ksiginfo {
    pub ksi_link: ksiginfo__bindgen_ty_1,
    pub ksi_info: siginfo_t,
    pub ksi_flags: ::kernel::sys::raw::c_int,
    pub ksi_sigq: *mut sigqueue,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ksiginfo__bindgen_ty_1 {
    pub tqe_next: *mut ksiginfo,
    pub tqe_prev: *mut *mut ksiginfo,
}
#[test]
fn bindgen_test_layout_ksiginfo__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<ksiginfo__bindgen_ty_1>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( ksiginfo__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<ksiginfo__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( ksiginfo__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ksiginfo__bindgen_ty_1 ) ) . tqe_next as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ksiginfo__bindgen_ty_1
                ) , "::" , stringify ! ( tqe_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ksiginfo__bindgen_ty_1 ) ) . tqe_prev as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ksiginfo__bindgen_ty_1
                ) , "::" , stringify ! ( tqe_prev ) ));
}
impl Clone for ksiginfo__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for ksiginfo__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_ksiginfo() {
    assert_eq!(::core::mem::size_of::<ksiginfo>() , 112usize , concat ! (
               "Size of: " , stringify ! ( ksiginfo ) ));
    assert_eq! (::core::mem::align_of::<ksiginfo>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ksiginfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ksiginfo ) ) . ksi_link as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ksiginfo ) , "::" ,
                stringify ! ( ksi_link ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ksiginfo ) ) . ksi_info as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ksiginfo ) , "::" ,
                stringify ! ( ksi_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ksiginfo ) ) . ksi_flags as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( ksiginfo ) , "::" ,
                stringify ! ( ksi_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ksiginfo ) ) . ksi_sigq as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( ksiginfo ) , "::" ,
                stringify ! ( ksi_sigq ) ));
}
impl Clone for ksiginfo {
    fn clone(&self) -> Self { *self }
}
impl Default for ksiginfo {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for ksiginfo {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "ksiginfo {{ ksi_link: {:?}, ksi_info: {:?}, ksi_flags: {:?}, ksi_sigq: {:?} }}"
               , self . ksi_link , self . ksi_info , self . ksi_flags , self .
               ksi_sigq)
    }
}
pub type ksiginfo_t = ksiginfo;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sigqueue {
    pub sq_signals: sigset_t,
    pub sq_kill: sigset_t,
    pub sq_ptrace: sigset_t,
    pub sq_list: sigqueue__bindgen_ty_1,
    pub sq_proc: *mut proc_,
    pub sq_flags: ::kernel::sys::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sigqueue__bindgen_ty_1 {
    pub tqh_first: *mut ksiginfo,
    pub tqh_last: *mut *mut ksiginfo,
}
#[test]
fn bindgen_test_layout_sigqueue__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<sigqueue__bindgen_ty_1>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( sigqueue__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<sigqueue__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( sigqueue__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigqueue__bindgen_ty_1 ) ) . tqh_first as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigqueue__bindgen_ty_1
                ) , "::" , stringify ! ( tqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigqueue__bindgen_ty_1 ) ) . tqh_last as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sigqueue__bindgen_ty_1
                ) , "::" , stringify ! ( tqh_last ) ));
}
impl Clone for sigqueue__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for sigqueue__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_sigqueue() {
    assert_eq!(::core::mem::size_of::<sigqueue>() , 80usize , concat ! (
               "Size of: " , stringify ! ( sigqueue ) ));
    assert_eq! (::core::mem::align_of::<sigqueue>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sigqueue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigqueue ) ) . sq_signals as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sigqueue ) , "::" ,
                stringify ! ( sq_signals ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigqueue ) ) . sq_kill as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( sigqueue ) , "::" ,
                stringify ! ( sq_kill ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigqueue ) ) . sq_ptrace as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( sigqueue ) , "::" ,
                stringify ! ( sq_ptrace ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigqueue ) ) . sq_list as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( sigqueue ) , "::" ,
                stringify ! ( sq_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigqueue ) ) . sq_proc as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( sigqueue ) , "::" ,
                stringify ! ( sq_proc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sigqueue ) ) . sq_flags as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( sigqueue ) , "::" ,
                stringify ! ( sq_flags ) ));
}
impl Clone for sigqueue {
    fn clone(&self) -> Self { *self }
}
impl Default for sigqueue {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type sigqueue_t = sigqueue;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pgrp {
    pub pg_hash: pgrp__bindgen_ty_1,
    pub pg_members: pgrp__bindgen_ty_2,
    pub pg_session: *mut session,
    pub pg_sigiolst: sigiolst,
    pub pg_id: pid_t,
    pub pg_jobc: ::kernel::sys::raw::c_int,
    pub pg_mtx: mtx,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pgrp__bindgen_ty_1 {
    pub le_next: *mut pgrp,
    pub le_prev: *mut *mut pgrp,
}
#[test]
fn bindgen_test_layout_pgrp__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<pgrp__bindgen_ty_1>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( pgrp__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<pgrp__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( pgrp__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgrp__bindgen_ty_1 ) ) . le_next as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pgrp__bindgen_ty_1 ) ,
                "::" , stringify ! ( le_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgrp__bindgen_ty_1 ) ) . le_prev as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pgrp__bindgen_ty_1 ) ,
                "::" , stringify ! ( le_prev ) ));
}
impl Clone for pgrp__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for pgrp__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pgrp__bindgen_ty_2 {
    pub lh_first: *mut proc_,
}
#[test]
fn bindgen_test_layout_pgrp__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<pgrp__bindgen_ty_2>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( pgrp__bindgen_ty_2 ) ));
    assert_eq! (::core::mem::align_of::<pgrp__bindgen_ty_2>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( pgrp__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgrp__bindgen_ty_2 ) ) . lh_first as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pgrp__bindgen_ty_2 ) ,
                "::" , stringify ! ( lh_first ) ));
}
impl Clone for pgrp__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for pgrp__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_pgrp() {
    assert_eq!(::core::mem::size_of::<pgrp>() , 80usize , concat ! (
               "Size of: " , stringify ! ( pgrp ) ));
    assert_eq! (::core::mem::align_of::<pgrp>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pgrp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgrp ) ) . pg_hash as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pgrp ) , "::" ,
                stringify ! ( pg_hash ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgrp ) ) . pg_members as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( pgrp ) , "::" ,
                stringify ! ( pg_members ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgrp ) ) . pg_session as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( pgrp ) , "::" ,
                stringify ! ( pg_session ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgrp ) ) . pg_sigiolst as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( pgrp ) , "::" ,
                stringify ! ( pg_sigiolst ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgrp ) ) . pg_id as * const _ as usize }
                , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( pgrp ) , "::" ,
                stringify ! ( pg_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgrp ) ) . pg_jobc as * const _ as usize
                } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( pgrp ) , "::" ,
                stringify ! ( pg_jobc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgrp ) ) . pg_mtx as * const _ as usize }
                , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( pgrp ) , "::" ,
                stringify ! ( pg_mtx ) ));
}
impl Clone for pgrp {
    fn clone(&self) -> Self { *self }
}
impl Default for pgrp {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    #[link_name = "sigio_lock"]
    pub static mut sigio_lock: mtx;
}
extern "C" {
    pub fn sigdeferstop_impl(mode: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sigallowstop_impl(prev: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn cursig(td: *mut thread) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn execsigs(p: *mut proc_);
}
extern "C" {
    pub fn gsignal(pgid: ::kernel::sys::raw::c_int,
                   sig: ::kernel::sys::raw::c_int, ksi: *mut ksiginfo_t);
}
extern "C" {
    pub fn killproc(p: *mut proc_, why: *mut ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn ksiginfo_alloc(wait: ::kernel::sys::raw::c_int) -> *mut ksiginfo_t;
}
extern "C" {
    pub fn ksiginfo_free(ksi: *mut ksiginfo_t);
}
extern "C" {
    pub fn pksignal(p: *mut proc_, sig: ::kernel::sys::raw::c_int,
                    ksi: *mut ksiginfo_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn pgsigio(sigiop: *mut *mut sigio, sig: ::kernel::sys::raw::c_int,
                   checkctty: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn pgsignal(pgrp: *mut pgrp, sig: ::kernel::sys::raw::c_int,
                    checkctty: ::kernel::sys::raw::c_int,
                    ksi: *mut ksiginfo_t);
}
extern "C" {
    pub fn postsig(sig: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn kern_psignal(p: *mut proc_, sig: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn ptracestop(td: *mut thread, sig: ::kernel::sys::raw::c_int,
                      si: *mut ksiginfo_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sendsig(catcher: sig_t, ksi: *mut ksiginfo_t,
                   retmask: *mut sigset_t);
}
extern "C" {
    pub fn sigacts_alloc() -> *mut sigacts;
}
extern "C" {
    pub fn sigacts_copy(dest: *mut sigacts, src: *mut sigacts);
}
extern "C" {
    pub fn sigacts_free(ps: *mut sigacts);
}
extern "C" {
    pub fn sigacts_hold(ps: *mut sigacts) -> *mut sigacts;
}
extern "C" {
    pub fn sigacts_shared(ps: *mut sigacts) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sigexit(td: *mut thread, sig: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn sigev_findtd(p: *mut proc_, sigev: *mut sigevent,
                        arg1: *mut *mut thread) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sig_ffs(set: *mut sigset_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn siginit(p: *mut proc_);
}
extern "C" {
    pub fn signotify(td: *mut thread);
}
extern "C" {
    pub fn sigqueue_delete(queue: *mut sigqueue,
                           sig: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn sigqueue_delete_proc(p: *mut proc_,
                                sig: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn sigqueue_flush(queue: *mut sigqueue);
}
extern "C" {
    pub fn sigqueue_init(queue: *mut sigqueue, p: *mut proc_);
}
extern "C" {
    pub fn sigqueue_take(ksi: *mut ksiginfo_t);
}
extern "C" {
    pub fn tdksignal(td: *mut thread, sig: ::kernel::sys::raw::c_int,
                     ksi: *mut ksiginfo_t);
}
extern "C" {
    pub fn tdsendsignal(p: *mut proc_, td: *mut thread,
                        sig: ::kernel::sys::raw::c_int, ksi: *mut ksiginfo_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn tdsigcleanup(td: *mut thread);
}
extern "C" {
    pub fn tdsignal(td: *mut thread, sig: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn trapsignal(td: *mut thread, ksi: *mut ksiginfo_t);
}
#[repr(C)]
#[derive(Copy)]
pub struct __mcontext {
    pub mc_onstack: __register_t,
    pub mc_rdi: __register_t,
    pub mc_rsi: __register_t,
    pub mc_rdx: __register_t,
    pub mc_rcx: __register_t,
    pub mc_r8: __register_t,
    pub mc_r9: __register_t,
    pub mc_rax: __register_t,
    pub mc_rbx: __register_t,
    pub mc_rbp: __register_t,
    pub mc_r10: __register_t,
    pub mc_r11: __register_t,
    pub mc_r12: __register_t,
    pub mc_r13: __register_t,
    pub mc_r14: __register_t,
    pub mc_r15: __register_t,
    pub mc_trapno: __uint32_t,
    pub mc_fs: __uint16_t,
    pub mc_gs: __uint16_t,
    pub mc_addr: __register_t,
    pub mc_flags: __uint32_t,
    pub mc_es: __uint16_t,
    pub mc_ds: __uint16_t,
    pub mc_err: __register_t,
    pub mc_rip: __register_t,
    pub mc_cs: __register_t,
    pub mc_rflags: __register_t,
    pub mc_rsp: __register_t,
    pub mc_ss: __register_t,
    pub mc_len: ::kernel::sys::raw::c_long,
    pub mc_fpformat: ::kernel::sys::raw::c_long,
    pub mc_ownedfp: ::kernel::sys::raw::c_long,
    pub mc_fpstate: [::kernel::sys::raw::c_long; 64usize],
    pub mc_fsbase: __register_t,
    pub mc_gsbase: __register_t,
    pub mc_xfpustate: __register_t,
    pub mc_xfpustate_len: __register_t,
    pub mc_spare: [::kernel::sys::raw::c_long; 4usize],
}
#[test]
fn bindgen_test_layout___mcontext() {
    assert_eq!(::core::mem::size_of::<__mcontext>() , 800usize , concat ! (
               "Size of: " , stringify ! ( __mcontext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_onstack as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_onstack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_rdi as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_rdi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_rsi as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_rsi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_rdx as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_rdx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_rcx as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_rcx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_r8 as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_r8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_r9 as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_r9 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_rax as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_rax ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_rbx as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_rbx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_rbp as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_rbp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_r10 as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_r10 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_r11 as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_r11 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_r12 as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_r12 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_r13 as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_r13 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_r14 as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_r14 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_r15 as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_r15 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_trapno as * const _
                as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_trapno ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_fs as * const _ as
                usize } , 132usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_fs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_gs as * const _ as
                usize } , 134usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_gs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_addr as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_flags as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_es as * const _ as
                usize } , 148usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_es ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_ds as * const _ as
                usize } , 150usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_ds ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_err as * const _ as
                usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_err ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_rip as * const _ as
                usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_rip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_cs as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_cs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_rflags as * const _
                as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_rflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_rsp as * const _ as
                usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_rsp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_ss as * const _ as
                usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_ss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_len as * const _ as
                usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_fpformat as * const _
                as usize } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_fpformat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_ownedfp as * const _
                as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_ownedfp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_fpstate as * const _
                as usize } , 224usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_fpstate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_fsbase as * const _
                as usize } , 736usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_fsbase ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_gsbase as * const _
                as usize } , 744usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_gsbase ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_xfpustate as * const
                _ as usize } , 752usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_xfpustate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_xfpustate_len as *
                const _ as usize } , 760usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_xfpustate_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mcontext ) ) . mc_spare as * const _ as
                usize } , 768usize , concat ! (
                "Alignment of field: " , stringify ! ( __mcontext ) , "::" ,
                stringify ! ( mc_spare ) ));
}
impl Clone for __mcontext {
    fn clone(&self) -> Self { *self }
}
impl Default for __mcontext {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for __mcontext {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "__mcontext {{ mc_onstack: {:?}, mc_rdi: {:?}, mc_rsi: {:?}, mc_rdx: {:?}, mc_rcx: {:?}, mc_r8: {:?}, mc_r9: {:?}, mc_rax: {:?}, mc_rbx: {:?}, mc_rbp: {:?}, mc_r10: {:?}, mc_r11: {:?}, mc_r12: {:?}, mc_r13: {:?}, mc_r14: {:?}, mc_r15: {:?}, mc_trapno: {:?}, mc_fs: {:?}, mc_gs: {:?}, mc_addr: {:?}, mc_flags: {:?}, mc_es: {:?}, mc_ds: {:?}, mc_err: {:?}, mc_rip: {:?}, mc_cs: {:?}, mc_rflags: {:?}, mc_rsp: {:?}, mc_ss: {:?}, mc_len: {:?}, mc_fpformat: {:?}, mc_ownedfp: {:?}, mc_fpstate: [{}], mc_fsbase: {:?}, mc_gsbase: {:?}, mc_xfpustate: {:?}, mc_xfpustate_len: {:?}, mc_spare: {:?} }}"
               , self . mc_onstack , self . mc_rdi , self . mc_rsi , self .
               mc_rdx , self . mc_rcx , self . mc_r8 , self . mc_r9 , self .
               mc_rax , self . mc_rbx , self . mc_rbp , self . mc_r10 , self .
               mc_r11 , self . mc_r12 , self . mc_r13 , self . mc_r14 , self .
               mc_r15 , self . mc_trapno , self . mc_fs , self . mc_gs , self
               . mc_addr , self . mc_flags , self . mc_es , self . mc_ds ,
               self . mc_err , self . mc_rip , self . mc_cs , self . mc_rflags
               , self . mc_rsp , self . mc_ss , self . mc_len , self .
               mc_fpformat , self . mc_ownedfp , self . mc_fpstate . iter (  )
               . enumerate (  ) . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ) , self . mc_fsbase , self . mc_gsbase , self .
               mc_xfpustate , self . mc_xfpustate_len , self . mc_spare)
    }
}
pub type mcontext_t = __mcontext;
#[repr(C)]
#[derive(Copy)]
pub struct __ucontext {
    pub uc_sigmask: __sigset_t,
    pub uc_mcontext: mcontext_t,
    pub uc_link: *mut __ucontext,
    pub uc_stack: sigaltstack,
    pub uc_flags: ::kernel::sys::raw::c_int,
    pub __spare__: [::kernel::sys::raw::c_int; 4usize],
    pub __bindgen_padding_0: [u32; 3usize],
}
#[test]
fn bindgen_test_layout___ucontext() {
    assert_eq!(::core::mem::size_of::<__ucontext>() , 880usize , concat ! (
               "Size of: " , stringify ! ( __ucontext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __ucontext ) ) . uc_sigmask as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __ucontext ) , "::" ,
                stringify ! ( uc_sigmask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __ucontext ) ) . uc_mcontext as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __ucontext ) , "::" ,
                stringify ! ( uc_mcontext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __ucontext ) ) . uc_link as * const _ as
                usize } , 816usize , concat ! (
                "Alignment of field: " , stringify ! ( __ucontext ) , "::" ,
                stringify ! ( uc_link ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __ucontext ) ) . uc_stack as * const _ as
                usize } , 824usize , concat ! (
                "Alignment of field: " , stringify ! ( __ucontext ) , "::" ,
                stringify ! ( uc_stack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __ucontext ) ) . uc_flags as * const _ as
                usize } , 848usize , concat ! (
                "Alignment of field: " , stringify ! ( __ucontext ) , "::" ,
                stringify ! ( uc_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __ucontext ) ) . __spare__ as * const _
                as usize } , 852usize , concat ! (
                "Alignment of field: " , stringify ! ( __ucontext ) , "::" ,
                stringify ! ( __spare__ ) ));
}
impl Clone for __ucontext {
    fn clone(&self) -> Self { *self }
}
impl Default for __ucontext {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for __ucontext {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "__ucontext {{ uc_sigmask: {:?}, uc_mcontext: {:?}, uc_link: {:?}, uc_stack: {:?}, uc_flags: {:?}, __spare__: {:?} }}"
               , self . uc_sigmask , self . uc_mcontext , self . uc_link ,
               self . uc_stack , self . uc_flags , self . __spare__)
    }
}
pub type ucontext_t = __ucontext;
extern "C" {
    pub fn get_mcontext(arg1: *mut thread, arg2: *mut mcontext_t,
                        arg3: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn set_mcontext(arg1: *mut thread, arg2: *mut mcontext_t)
     -> ::kernel::sys::raw::c_int;
}
pub type au_id_t = uid_t;
pub type au_asid_t = pid_t;
pub type au_event_t = u_int16_t;
pub type au_emod_t = u_int16_t;
pub type au_class_t = u_int32_t;
pub type au_asflgs_t = u_int64_t;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct au_tid {
    pub port: u_int32_t,
    pub machine: u_int32_t,
}
#[test]
fn bindgen_test_layout_au_tid() {
    assert_eq!(::core::mem::size_of::<au_tid>() , 8usize , concat ! (
               "Size of: " , stringify ! ( au_tid ) ));
    assert_eq! (::core::mem::align_of::<au_tid>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( au_tid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const au_tid ) ) . port as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( au_tid ) , "::" ,
                stringify ! ( port ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const au_tid ) ) . machine as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( au_tid ) , "::" ,
                stringify ! ( machine ) ));
}
impl Clone for au_tid {
    fn clone(&self) -> Self { *self }
}
pub type au_tid_t = au_tid;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct au_tid_addr {
    pub at_port: u_int32_t,
    pub at_type: u_int32_t,
    pub at_addr: [u_int32_t; 4usize],
}
#[test]
fn bindgen_test_layout_au_tid_addr() {
    assert_eq!(::core::mem::size_of::<au_tid_addr>() , 24usize , concat ! (
               "Size of: " , stringify ! ( au_tid_addr ) ));
    assert_eq! (::core::mem::align_of::<au_tid_addr>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( au_tid_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const au_tid_addr ) ) . at_port as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( au_tid_addr ) , "::" ,
                stringify ! ( at_port ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const au_tid_addr ) ) . at_type as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( au_tid_addr ) , "::" ,
                stringify ! ( at_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const au_tid_addr ) ) . at_addr as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( au_tid_addr ) , "::" ,
                stringify ! ( at_addr ) ));
}
impl Clone for au_tid_addr {
    fn clone(&self) -> Self { *self }
}
pub type au_tid_addr_t = au_tid_addr;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct au_mask {
    pub am_success: ::kernel::sys::raw::c_uint,
    pub am_failure: ::kernel::sys::raw::c_uint,
}
#[test]
fn bindgen_test_layout_au_mask() {
    assert_eq!(::core::mem::size_of::<au_mask>() , 8usize , concat ! (
               "Size of: " , stringify ! ( au_mask ) ));
    assert_eq! (::core::mem::align_of::<au_mask>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( au_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const au_mask ) ) . am_success as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( au_mask ) , "::" ,
                stringify ! ( am_success ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const au_mask ) ) . am_failure as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( au_mask ) , "::" ,
                stringify ! ( am_failure ) ));
}
impl Clone for au_mask {
    fn clone(&self) -> Self { *self }
}
pub type au_mask_t = au_mask;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct auditinfo {
    pub ai_auid: au_id_t,
    pub ai_mask: au_mask_t,
    pub ai_termid: au_tid_t,
    pub ai_asid: au_asid_t,
}
#[test]
fn bindgen_test_layout_auditinfo() {
    assert_eq!(::core::mem::size_of::<auditinfo>() , 24usize , concat ! (
               "Size of: " , stringify ! ( auditinfo ) ));
    assert_eq! (::core::mem::align_of::<auditinfo>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( auditinfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const auditinfo ) ) . ai_auid as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( auditinfo ) , "::" ,
                stringify ! ( ai_auid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const auditinfo ) ) . ai_mask as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( auditinfo ) , "::" ,
                stringify ! ( ai_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const auditinfo ) ) . ai_termid as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( auditinfo ) , "::" ,
                stringify ! ( ai_termid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const auditinfo ) ) . ai_asid as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( auditinfo ) , "::" ,
                stringify ! ( ai_asid ) ));
}
impl Clone for auditinfo {
    fn clone(&self) -> Self { *self }
}
pub type auditinfo_t = auditinfo;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct auditinfo_addr {
    pub ai_auid: au_id_t,
    pub ai_mask: au_mask_t,
    pub ai_termid: au_tid_addr_t,
    pub ai_asid: au_asid_t,
    pub ai_flags: au_asflgs_t,
}
#[test]
fn bindgen_test_layout_auditinfo_addr() {
    assert_eq!(::core::mem::size_of::<auditinfo_addr>() , 48usize , concat ! (
               "Size of: " , stringify ! ( auditinfo_addr ) ));
    assert_eq! (::core::mem::align_of::<auditinfo_addr>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( auditinfo_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const auditinfo_addr ) ) . ai_auid as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( auditinfo_addr ) , "::"
                , stringify ! ( ai_auid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const auditinfo_addr ) ) . ai_mask as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( auditinfo_addr ) , "::"
                , stringify ! ( ai_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const auditinfo_addr ) ) . ai_termid as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( auditinfo_addr ) , "::"
                , stringify ! ( ai_termid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const auditinfo_addr ) ) . ai_asid as * const _
                as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( auditinfo_addr ) , "::"
                , stringify ! ( ai_asid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const auditinfo_addr ) ) . ai_flags as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( auditinfo_addr ) , "::"
                , stringify ! ( ai_flags ) ));
}
impl Clone for auditinfo_addr {
    fn clone(&self) -> Self { *self }
}
pub type auditinfo_addr_t = auditinfo_addr;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct auditpinfo {
    pub ap_pid: pid_t,
    pub ap_auid: au_id_t,
    pub ap_mask: au_mask_t,
    pub ap_termid: au_tid_t,
    pub ap_asid: au_asid_t,
}
#[test]
fn bindgen_test_layout_auditpinfo() {
    assert_eq!(::core::mem::size_of::<auditpinfo>() , 28usize , concat ! (
               "Size of: " , stringify ! ( auditpinfo ) ));
    assert_eq! (::core::mem::align_of::<auditpinfo>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( auditpinfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const auditpinfo ) ) . ap_pid as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( auditpinfo ) , "::" ,
                stringify ! ( ap_pid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const auditpinfo ) ) . ap_auid as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( auditpinfo ) , "::" ,
                stringify ! ( ap_auid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const auditpinfo ) ) . ap_mask as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( auditpinfo ) , "::" ,
                stringify ! ( ap_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const auditpinfo ) ) . ap_termid as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( auditpinfo ) , "::" ,
                stringify ! ( ap_termid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const auditpinfo ) ) . ap_asid as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( auditpinfo ) , "::" ,
                stringify ! ( ap_asid ) ));
}
impl Clone for auditpinfo {
    fn clone(&self) -> Self { *self }
}
pub type auditpinfo_t = auditpinfo;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct auditpinfo_addr {
    pub ap_pid: pid_t,
    pub ap_auid: au_id_t,
    pub ap_mask: au_mask_t,
    pub ap_termid: au_tid_addr_t,
    pub ap_asid: au_asid_t,
    pub ap_flags: au_asflgs_t,
}
#[test]
fn bindgen_test_layout_auditpinfo_addr() {
    assert_eq!(::core::mem::size_of::<auditpinfo_addr>() , 56usize , concat !
               ( "Size of: " , stringify ! ( auditpinfo_addr ) ));
    assert_eq! (::core::mem::align_of::<auditpinfo_addr>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( auditpinfo_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const auditpinfo_addr ) ) . ap_pid as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( auditpinfo_addr ) ,
                "::" , stringify ! ( ap_pid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const auditpinfo_addr ) ) . ap_auid as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( auditpinfo_addr ) ,
                "::" , stringify ! ( ap_auid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const auditpinfo_addr ) ) . ap_mask as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( auditpinfo_addr ) ,
                "::" , stringify ! ( ap_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const auditpinfo_addr ) ) . ap_termid as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( auditpinfo_addr ) ,
                "::" , stringify ! ( ap_termid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const auditpinfo_addr ) ) . ap_asid as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( auditpinfo_addr ) ,
                "::" , stringify ! ( ap_asid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const auditpinfo_addr ) ) . ap_flags as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( auditpinfo_addr ) ,
                "::" , stringify ! ( ap_flags ) ));
}
impl Clone for auditpinfo_addr {
    fn clone(&self) -> Self { *self }
}
pub type auditpinfo_addr_t = auditpinfo_addr;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct au_session {
    pub as_aia_p: *mut auditinfo_addr_t,
    pub as_mask: au_mask_t,
}
#[test]
fn bindgen_test_layout_au_session() {
    assert_eq!(::core::mem::size_of::<au_session>() , 16usize , concat ! (
               "Size of: " , stringify ! ( au_session ) ));
    assert_eq! (::core::mem::align_of::<au_session>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( au_session ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const au_session ) ) . as_aia_p as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( au_session ) , "::" ,
                stringify ! ( as_aia_p ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const au_session ) ) . as_mask as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( au_session ) , "::" ,
                stringify ! ( as_mask ) ));
}
impl Clone for au_session {
    fn clone(&self) -> Self { *self }
}
impl Default for au_session {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type au_session_t = au_session;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct au_token {
    _unused: [u8; 0],
}
pub type token_t = au_token;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct au_qctrl {
    pub aq_hiwater: ::kernel::sys::raw::c_int,
    pub aq_lowater: ::kernel::sys::raw::c_int,
    pub aq_bufsz: ::kernel::sys::raw::c_int,
    pub aq_delay: ::kernel::sys::raw::c_int,
    pub aq_minfree: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_au_qctrl() {
    assert_eq!(::core::mem::size_of::<au_qctrl>() , 20usize , concat ! (
               "Size of: " , stringify ! ( au_qctrl ) ));
    assert_eq! (::core::mem::align_of::<au_qctrl>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( au_qctrl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const au_qctrl ) ) . aq_hiwater as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( au_qctrl ) , "::" ,
                stringify ! ( aq_hiwater ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const au_qctrl ) ) . aq_lowater as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( au_qctrl ) , "::" ,
                stringify ! ( aq_lowater ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const au_qctrl ) ) . aq_bufsz as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( au_qctrl ) , "::" ,
                stringify ! ( aq_bufsz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const au_qctrl ) ) . aq_delay as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( au_qctrl ) , "::" ,
                stringify ! ( aq_delay ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const au_qctrl ) ) . aq_minfree as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( au_qctrl ) , "::" ,
                stringify ! ( aq_minfree ) ));
}
impl Clone for au_qctrl {
    fn clone(&self) -> Self { *self }
}
pub type au_qctrl_t = au_qctrl;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct audit_stat {
    pub as_version: ::kernel::sys::raw::c_uint,
    pub as_numevent: ::kernel::sys::raw::c_uint,
    pub as_generated: ::kernel::sys::raw::c_int,
    pub as_nonattrib: ::kernel::sys::raw::c_int,
    pub as_kernel: ::kernel::sys::raw::c_int,
    pub as_audit: ::kernel::sys::raw::c_int,
    pub as_auditctl: ::kernel::sys::raw::c_int,
    pub as_enqueue: ::kernel::sys::raw::c_int,
    pub as_written: ::kernel::sys::raw::c_int,
    pub as_wblocked: ::kernel::sys::raw::c_int,
    pub as_rblocked: ::kernel::sys::raw::c_int,
    pub as_dropped: ::kernel::sys::raw::c_int,
    pub as_totalsize: ::kernel::sys::raw::c_int,
    pub as_memused: ::kernel::sys::raw::c_uint,
}
#[test]
fn bindgen_test_layout_audit_stat() {
    assert_eq!(::core::mem::size_of::<audit_stat>() , 56usize , concat ! (
               "Size of: " , stringify ! ( audit_stat ) ));
    assert_eq! (::core::mem::align_of::<audit_stat>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( audit_stat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const audit_stat ) ) . as_version as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( audit_stat ) , "::" ,
                stringify ! ( as_version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const audit_stat ) ) . as_numevent as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( audit_stat ) , "::" ,
                stringify ! ( as_numevent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const audit_stat ) ) . as_generated as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( audit_stat ) , "::" ,
                stringify ! ( as_generated ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const audit_stat ) ) . as_nonattrib as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( audit_stat ) , "::" ,
                stringify ! ( as_nonattrib ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const audit_stat ) ) . as_kernel as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( audit_stat ) , "::" ,
                stringify ! ( as_kernel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const audit_stat ) ) . as_audit as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( audit_stat ) , "::" ,
                stringify ! ( as_audit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const audit_stat ) ) . as_auditctl as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( audit_stat ) , "::" ,
                stringify ! ( as_auditctl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const audit_stat ) ) . as_enqueue as * const _
                as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( audit_stat ) , "::" ,
                stringify ! ( as_enqueue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const audit_stat ) ) . as_written as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( audit_stat ) , "::" ,
                stringify ! ( as_written ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const audit_stat ) ) . as_wblocked as * const _
                as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( audit_stat ) , "::" ,
                stringify ! ( as_wblocked ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const audit_stat ) ) . as_rblocked as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( audit_stat ) , "::" ,
                stringify ! ( as_rblocked ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const audit_stat ) ) . as_dropped as * const _
                as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( audit_stat ) , "::" ,
                stringify ! ( as_dropped ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const audit_stat ) ) . as_totalsize as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( audit_stat ) , "::" ,
                stringify ! ( as_totalsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const audit_stat ) ) . as_memused as * const _
                as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( audit_stat ) , "::" ,
                stringify ! ( as_memused ) ));
}
impl Clone for audit_stat {
    fn clone(&self) -> Self { *self }
}
pub type au_stat_t = audit_stat;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct audit_fstat {
    pub af_filesz: u_int64_t,
    pub af_currsz: u_int64_t,
}
#[test]
fn bindgen_test_layout_audit_fstat() {
    assert_eq!(::core::mem::size_of::<audit_fstat>() , 16usize , concat ! (
               "Size of: " , stringify ! ( audit_fstat ) ));
    assert_eq! (::core::mem::align_of::<audit_fstat>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( audit_fstat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const audit_fstat ) ) . af_filesz as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( audit_fstat ) , "::" ,
                stringify ! ( af_filesz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const audit_fstat ) ) . af_currsz as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( audit_fstat ) , "::" ,
                stringify ! ( af_currsz ) ));
}
impl Clone for audit_fstat {
    fn clone(&self) -> Self { *self }
}
pub type au_fstat_t = audit_fstat;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct au_evclass_map {
    pub ec_number: au_event_t,
    pub ec_class: au_class_t,
}
#[test]
fn bindgen_test_layout_au_evclass_map() {
    assert_eq!(::core::mem::size_of::<au_evclass_map>() , 8usize , concat ! (
               "Size of: " , stringify ! ( au_evclass_map ) ));
    assert_eq! (::core::mem::align_of::<au_evclass_map>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( au_evclass_map ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const au_evclass_map ) ) . ec_number as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( au_evclass_map ) , "::"
                , stringify ! ( ec_number ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const au_evclass_map ) ) . ec_class as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( au_evclass_map ) , "::"
                , stringify ! ( ec_class ) ));
}
impl Clone for au_evclass_map {
    fn clone(&self) -> Self { *self }
}
pub type au_evclass_map_t = au_evclass_map;
#[repr(C)]
#[derive(Copy)]
pub struct au_evname_map {
    pub en_number: au_event_t,
    pub en_name: [::kernel::sys::raw::c_char; 64usize],
}
#[test]
fn bindgen_test_layout_au_evname_map() {
    assert_eq!(::core::mem::size_of::<au_evname_map>() , 66usize , concat ! (
               "Size of: " , stringify ! ( au_evname_map ) ));
    assert_eq! (::core::mem::align_of::<au_evname_map>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( au_evname_map ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const au_evname_map ) ) . en_number as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( au_evname_map ) , "::"
                , stringify ! ( en_number ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const au_evname_map ) ) . en_name as * const _
                as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( au_evname_map ) , "::"
                , stringify ! ( en_name ) ));
}
impl Clone for au_evname_map {
    fn clone(&self) -> Self { *self }
}
impl Default for au_evname_map {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for au_evname_map {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "au_evname_map {{ en_number: {:?}, en_name: [{}] }}" , self
               . en_number , self . en_name . iter (  ) . enumerate (  ) . map
               (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ))
    }
}
pub type au_evname_map_t = au_evname_map;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct loginclass {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct xucred {
    pub cr_version: u_int,
    pub cr_uid: uid_t,
    pub cr_ngroups: ::kernel::sys::raw::c_short,
    pub cr_groups: [gid_t; 16usize],
    pub _cr_unused1: *mut ::kernel::sys::raw::c_void,
}
#[test]
fn bindgen_test_layout_xucred() {
    assert_eq!(::core::mem::size_of::<xucred>() , 88usize , concat ! (
               "Size of: " , stringify ! ( xucred ) ));
    assert_eq! (::core::mem::align_of::<xucred>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( xucred ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xucred ) ) . cr_version as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( xucred ) , "::" ,
                stringify ! ( cr_version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xucred ) ) . cr_uid as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( xucred ) , "::" ,
                stringify ! ( cr_uid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xucred ) ) . cr_ngroups as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( xucred ) , "::" ,
                stringify ! ( cr_ngroups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xucred ) ) . cr_groups as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( xucred ) , "::" ,
                stringify ! ( cr_groups ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const xucred ) ) . _cr_unused1 as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( xucred ) , "::" ,
                stringify ! ( _cr_unused1 ) ));
}
impl Clone for xucred {
    fn clone(&self) -> Self { *self }
}
impl Default for xucred {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    pub fn change_egid(newcred: *mut ucred, egid: gid_t);
}
extern "C" {
    pub fn change_euid(newcred: *mut ucred, euip: *mut uidinfo);
}
extern "C" {
    pub fn change_rgid(newcred: *mut ucred, rgid: gid_t);
}
extern "C" {
    pub fn change_ruid(newcred: *mut ucred, ruip: *mut uidinfo);
}
extern "C" {
    pub fn change_svgid(newcred: *mut ucred, svgid: gid_t);
}
extern "C" {
    pub fn change_svuid(newcred: *mut ucred, svuid: uid_t);
}
extern "C" {
    pub fn crcopy(dest: *mut ucred, src: *mut ucred);
}
extern "C" {
    pub fn crcopysafe(p: *mut proc_, cr: *mut ucred) -> *mut ucred;
}
extern "C" {
    pub fn crdup(cr: *mut ucred) -> *mut ucred;
}
extern "C" {
    pub fn crextend(cr: *mut ucred, n: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn proc_set_cred_init(p: *mut proc_, cr: *mut ucred);
}
extern "C" {
    pub fn proc_set_cred(p: *mut proc_, cr: *mut ucred) -> *mut ucred;
}
extern "C" {
    pub fn crfree(cr: *mut ucred);
}
extern "C" {
    pub fn crget() -> *mut ucred;
}
extern "C" {
    pub fn crhold(cr: *mut ucred) -> *mut ucred;
}
extern "C" {
    pub fn cru2x(cr: *mut ucred, xcr: *mut xucred);
}
extern "C" {
    pub fn crsetgroups(cr: *mut ucred, n: ::kernel::sys::raw::c_int,
                       groups: *mut gid_t);
}
extern "C" {
    pub fn groupmember(gid: gid_t, cred: *mut ucred)
     -> ::kernel::sys::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct _domainset {
    pub __bits: [::kernel::sys::raw::c_long; 1usize],
}
#[test]
fn bindgen_test_layout__domainset() {
    assert_eq!(::core::mem::size_of::<_domainset>() , 8usize , concat ! (
               "Size of: " , stringify ! ( _domainset ) ));
    assert_eq! (::core::mem::align_of::<_domainset>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( _domainset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _domainset ) ) . __bits as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _domainset ) , "::" ,
                stringify ! ( __bits ) ));
}
impl Clone for _domainset {
    fn clone(&self) -> Self { *self }
}
pub type domainset_t = _domainset;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct domainset {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct domainset_ref {
    pub dr_policy: *mut domainset,
    pub dr_iterator: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_domainset_ref() {
    assert_eq!(::core::mem::size_of::<domainset_ref>() , 16usize , concat ! (
               "Size of: " , stringify ! ( domainset_ref ) ));
    assert_eq! (::core::mem::align_of::<domainset_ref>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( domainset_ref ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const domainset_ref ) ) . dr_policy as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( domainset_ref ) , "::"
                , stringify ! ( dr_policy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const domainset_ref ) ) . dr_iterator as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( domainset_ref ) , "::"
                , stringify ! ( dr_iterator ) ));
}
impl Clone for domainset_ref {
    fn clone(&self) -> Self { *self }
}
impl Default for domainset_ref {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct proc_ldt {
    pub ldt_base: caddr_t,
    pub ldt_refcnt: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_proc_ldt() {
    assert_eq!(::core::mem::size_of::<proc_ldt>() , 16usize , concat ! (
               "Size of: " , stringify ! ( proc_ldt ) ));
    assert_eq! (::core::mem::align_of::<proc_ldt>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( proc_ldt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ldt ) ) . ldt_base as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ldt ) , "::" ,
                stringify ! ( ldt_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proc_ldt ) ) . ldt_refcnt as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( proc_ldt ) , "::" ,
                stringify ! ( ldt_refcnt ) ));
}
impl Clone for proc_ldt {
    fn clone(&self) -> Self { *self }
}
impl Default for proc_ldt {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pmap_invl_gen {
    pub gen: u_long,
    pub link: pmap_invl_gen__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pmap_invl_gen__bindgen_ty_1 {
    pub le_next: *mut pmap_invl_gen,
    pub le_prev: *mut *mut pmap_invl_gen,
}
#[test]
fn bindgen_test_layout_pmap_invl_gen__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<pmap_invl_gen__bindgen_ty_1>() , 16usize
               , concat ! (
               "Size of: " , stringify ! ( pmap_invl_gen__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<pmap_invl_gen__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( pmap_invl_gen__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pmap_invl_gen__bindgen_ty_1 ) ) . le_next
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pmap_invl_gen__bindgen_ty_1 ) , "::" , stringify ! ( le_next )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pmap_invl_gen__bindgen_ty_1 ) ) . le_prev
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                pmap_invl_gen__bindgen_ty_1 ) , "::" , stringify ! ( le_prev )
                ));
}
impl Clone for pmap_invl_gen__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for pmap_invl_gen__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_pmap_invl_gen() {
    assert_eq!(::core::mem::size_of::<pmap_invl_gen>() , 24usize , concat ! (
               "Size of: " , stringify ! ( pmap_invl_gen ) ));
    assert_eq! (::core::mem::align_of::<pmap_invl_gen>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pmap_invl_gen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pmap_invl_gen ) ) . gen as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pmap_invl_gen ) , "::"
                , stringify ! ( gen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pmap_invl_gen ) ) . link as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pmap_invl_gen ) , "::"
                , stringify ! ( link ) ));
}
impl Clone for pmap_invl_gen {
    fn clone(&self) -> Self { *self }
}
impl Default for pmap_invl_gen {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mdthread {
    pub md_spinlock_count: ::kernel::sys::raw::c_int,
    pub md_saved_flags: register_t,
    pub md_spurflt_addr: register_t,
    pub md_invl_gen: pmap_invl_gen,
}
#[test]
fn bindgen_test_layout_mdthread() {
    assert_eq!(::core::mem::size_of::<mdthread>() , 48usize , concat ! (
               "Size of: " , stringify ! ( mdthread ) ));
    assert_eq! (::core::mem::align_of::<mdthread>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( mdthread ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mdthread ) ) . md_spinlock_count as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mdthread ) , "::" ,
                stringify ! ( md_spinlock_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mdthread ) ) . md_saved_flags as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mdthread ) , "::" ,
                stringify ! ( md_saved_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mdthread ) ) . md_spurflt_addr as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( mdthread ) , "::" ,
                stringify ! ( md_spurflt_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mdthread ) ) . md_invl_gen as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( mdthread ) , "::" ,
                stringify ! ( md_invl_gen ) ));
}
impl Clone for mdthread {
    fn clone(&self) -> Self { *self }
}
impl Default for mdthread {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct mdproc {
    pub md_ldt: *mut proc_ldt,
    pub md_ldt_sd: system_segment_descriptor,
}
#[test]
fn bindgen_test_layout_mdproc() {
    assert_eq!(::core::mem::size_of::<mdproc>() , 24usize , concat ! (
               "Size of: " , stringify ! ( mdproc ) ));
    assert_eq! (::core::mem::align_of::<mdproc>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( mdproc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mdproc ) ) . md_ldt as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( mdproc ) , "::" ,
                stringify ! ( md_ldt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const mdproc ) ) . md_ldt_sd as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( mdproc ) , "::" ,
                stringify ! ( md_ldt_sd ) ));
}
impl Clone for mdproc {
    fn clone(&self) -> Self { *self }
}
impl Default for mdproc {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct syscall_args {
    pub code: u_int,
    pub callp: *mut sysent,
    pub args: [register_t; 8usize],
    pub narg: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_syscall_args() {
    assert_eq!(::core::mem::size_of::<syscall_args>() , 88usize , concat ! (
               "Size of: " , stringify ! ( syscall_args ) ));
    assert_eq! (::core::mem::align_of::<syscall_args>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( syscall_args ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const syscall_args ) ) . code as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( syscall_args ) , "::" ,
                stringify ! ( code ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const syscall_args ) ) . callp as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( syscall_args ) , "::" ,
                stringify ! ( callp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const syscall_args ) ) . args as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( syscall_args ) , "::" ,
                stringify ! ( args ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const syscall_args ) ) . narg as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( syscall_args ) , "::" ,
                stringify ! ( narg ) ));
}
impl Clone for syscall_args {
    fn clone(&self) -> Self { *self }
}
impl Default for syscall_args {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    pub fn user_ldt_alloc(arg1: *mut proc_, arg2: ::kernel::sys::raw::c_int)
     -> *mut proc_ldt;
}
extern "C" {
    pub fn user_ldt_free(arg1: *mut thread);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sysarch_args {
    _unused: [u8; 0],
}
extern "C" {
    pub fn sysarch_ldt(td: *mut thread, uap: *mut sysarch_args,
                       uap_space: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn amd64_set_ldt_data(td: *mut thread,
                              start: ::kernel::sys::raw::c_int,
                              num: ::kernel::sys::raw::c_int,
                              descs: *mut user_segment_descriptor)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "dt_lock"]
    pub static mut dt_lock: mtx;
}
extern "C" {
    #[link_name = "max_ldt_segment"]
    pub static mut max_ldt_segment: ::kernel::sys::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct epoch_section {
    pub bucket: ::kernel::sys::raw::c_uint,
}
#[test]
fn bindgen_test_layout_epoch_section() {
    assert_eq!(::core::mem::size_of::<epoch_section>() , 4usize , concat ! (
               "Size of: " , stringify ! ( epoch_section ) ));
    assert_eq! (::core::mem::align_of::<epoch_section>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( epoch_section ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const epoch_section ) ) . bucket as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( epoch_section ) , "::"
                , stringify ! ( bucket ) ));
}
impl Clone for epoch_section {
    fn clone(&self) -> Self { *self }
}
pub type epoch_section_t = epoch_section;
#[repr(C)]
#[derive(Copy)]
pub struct session {
    pub s_count: u_int,
    pub s_leader: *mut proc_,
    pub s_ttyvp: *mut vnode,
    pub s_ttydp: *mut cdev_priv,
    pub s_ttyp: *mut tty,
    pub s_sid: pid_t,
    pub s_login: [::kernel::sys::raw::c_char; 40usize],
    pub s_mtx: mtx,
}
#[test]
fn bindgen_test_layout_session() {
    assert_eq!(::core::mem::size_of::<session>() , 120usize , concat ! (
               "Size of: " , stringify ! ( session ) ));
    assert_eq! (::core::mem::align_of::<session>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( session ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const session ) ) . s_count as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( session ) , "::" ,
                stringify ! ( s_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const session ) ) . s_leader as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( session ) , "::" ,
                stringify ! ( s_leader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const session ) ) . s_ttyvp as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( session ) , "::" ,
                stringify ! ( s_ttyvp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const session ) ) . s_ttydp as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( session ) , "::" ,
                stringify ! ( s_ttydp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const session ) ) . s_ttyp as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( session ) , "::" ,
                stringify ! ( s_ttyp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const session ) ) . s_sid as * const _ as usize
                } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( session ) , "::" ,
                stringify ! ( s_sid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const session ) ) . s_login as * const _ as
                usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( session ) , "::" ,
                stringify ! ( s_login ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const session ) ) . s_mtx as * const _ as usize
                } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( session ) , "::" ,
                stringify ! ( s_mtx ) ));
}
impl Clone for session {
    fn clone(&self) -> Self { *self }
}
impl Default for session {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for session {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "session {{ s_count: {:?}, s_leader: {:?}, s_ttyvp: {:?}, s_ttydp: {:?}, s_ttyp: {:?}, s_sid: {:?}, s_login: [{}], s_mtx: {:?} }}"
               , self . s_count , self . s_leader , self . s_ttyvp , self .
               s_ttydp , self . s_ttyp , self . s_sid , self . s_login . iter
               (  ) . enumerate (  ) . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ) , self . s_mtx)
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct pargs {
    pub ar_ref: u_int,
    pub ar_length: u_int,
    pub ar_args: [u_char; 1usize],
}
#[test]
fn bindgen_test_layout_pargs() {
    assert_eq!(::core::mem::size_of::<pargs>() , 12usize , concat ! (
               "Size of: " , stringify ! ( pargs ) ));
    assert_eq! (::core::mem::align_of::<pargs>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( pargs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pargs ) ) . ar_ref as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pargs ) , "::" ,
                stringify ! ( ar_ref ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pargs ) ) . ar_length as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( pargs ) , "::" ,
                stringify ! ( ar_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pargs ) ) . ar_args as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pargs ) , "::" ,
                stringify ! ( ar_args ) ));
}
impl Clone for pargs {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct filecaps {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct filemon {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kaioinfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kaudit_record {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kdtrace_proc {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kdtrace_thread {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mqueue_notifier {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nlminfo {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct p_sched {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct procdesc {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct racct {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sleepqueue {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct td_sched {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct turnstile {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_map {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_map_entry {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct rusage_ext {
    pub rux_runtime: u64,
    pub rux_uticks: u64,
    pub rux_sticks: u64,
    pub rux_iticks: u64,
    pub rux_uu: u64,
    pub rux_su: u64,
    pub rux_tu: u64,
}
#[test]
fn bindgen_test_layout_rusage_ext() {
    assert_eq!(::core::mem::size_of::<rusage_ext>() , 56usize , concat ! (
               "Size of: " , stringify ! ( rusage_ext ) ));
    assert_eq! (::core::mem::align_of::<rusage_ext>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rusage_ext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_ext ) ) . rux_runtime as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_ext ) , "::" ,
                stringify ! ( rux_runtime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_ext ) ) . rux_uticks as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_ext ) , "::" ,
                stringify ! ( rux_uticks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_ext ) ) . rux_sticks as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_ext ) , "::" ,
                stringify ! ( rux_sticks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_ext ) ) . rux_iticks as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_ext ) , "::" ,
                stringify ! ( rux_iticks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_ext ) ) . rux_uu as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_ext ) , "::" ,
                stringify ! ( rux_uu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_ext ) ) . rux_su as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_ext ) , "::" ,
                stringify ! ( rux_su ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rusage_ext ) ) . rux_tu as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( rusage_ext ) , "::" ,
                stringify ! ( rux_tu ) ));
}
impl Clone for rusage_ext {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct thread0_storage {
    pub t0st_thread: thread,
    pub t0st_sched: [u64; 10usize],
}
#[test]
fn bindgen_test_layout_thread0_storage() {
    assert_eq!(::core::mem::size_of::<thread0_storage>() , 1432usize , concat
               ! ( "Size of: " , stringify ! ( thread0_storage ) ));
    assert_eq! (::core::mem::align_of::<thread0_storage>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( thread0_storage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread0_storage ) ) . t0st_thread as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( thread0_storage ) ,
                "::" , stringify ! ( t0st_thread ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const thread0_storage ) ) . t0st_sched as *
                const _ as usize } , 1352usize , concat ! (
                "Alignment of field: " , stringify ! ( thread0_storage ) ,
                "::" , stringify ! ( t0st_sched ) ));
}
impl Clone for thread0_storage {
    fn clone(&self) -> Self { *self }
}
impl Default for thread0_storage {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for thread0_storage {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "thread0_storage {{ t0st_thread: {:?}, t0st_sched: {:?} }}"
               , self . t0st_thread , self . t0st_sched)
    }
}
extern "C" {
    pub fn thread_lock_block(arg1: *mut thread) -> *mut mtx;
}
extern "C" {
    pub fn thread_lock_unblock(arg1: *mut thread, arg2: *mut mtx);
}
extern "C" {
    pub fn thread_lock_set(arg1: *mut thread, arg2: *mut mtx);
}
extern "C" {
    #[link_name = "M_PARGS"]
    pub static mut M_PARGS: [malloc_type; 1usize];
}
extern "C" {
    #[link_name = "M_PGRP"]
    pub static mut M_PGRP: [malloc_type; 1usize];
}
extern "C" {
    #[link_name = "M_SESSION"]
    pub static mut M_SESSION: [malloc_type; 1usize];
}
extern "C" {
    #[link_name = "M_SUBPROC"]
    pub static mut M_SUBPROC: [malloc_type; 1usize];
}
extern "C" {
    #[link_name = "pid_max"]
    pub static mut pid_max: pid_t;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pidhashhead {
    pub lh_first: *mut proc_,
}
#[test]
fn bindgen_test_layout_pidhashhead() {
    assert_eq!(::core::mem::size_of::<pidhashhead>() , 8usize , concat ! (
               "Size of: " , stringify ! ( pidhashhead ) ));
    assert_eq! (::core::mem::align_of::<pidhashhead>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pidhashhead ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pidhashhead ) ) . lh_first as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pidhashhead ) , "::" ,
                stringify ! ( lh_first ) ));
}
impl Clone for pidhashhead {
    fn clone(&self) -> Self { *self }
}
impl Default for pidhashhead {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    #[link_name = "pidhashtbl"]
    pub static mut pidhashtbl: *mut pidhashhead;
}
extern "C" {
    #[link_name = "pidhash"]
    pub static mut pidhash: u_long;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tidhashhead {
    pub lh_first: *mut thread,
}
#[test]
fn bindgen_test_layout_tidhashhead() {
    assert_eq!(::core::mem::size_of::<tidhashhead>() , 8usize , concat ! (
               "Size of: " , stringify ! ( tidhashhead ) ));
    assert_eq! (::core::mem::align_of::<tidhashhead>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( tidhashhead ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tidhashhead ) ) . lh_first as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tidhashhead ) , "::" ,
                stringify ! ( lh_first ) ));
}
impl Clone for tidhashhead {
    fn clone(&self) -> Self { *self }
}
impl Default for tidhashhead {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    #[link_name = "tidhashtbl"]
    pub static mut tidhashtbl: *mut tidhashhead;
}
extern "C" {
    #[link_name = "tidhash"]
    pub static mut tidhash: u_long;
}
extern "C" {
    #[link_name = "tidhash_lock"]
    pub static mut tidhash_lock: rwlock;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pgrphashhead {
    pub lh_first: *mut pgrp,
}
#[test]
fn bindgen_test_layout_pgrphashhead() {
    assert_eq!(::core::mem::size_of::<pgrphashhead>() , 8usize , concat ! (
               "Size of: " , stringify ! ( pgrphashhead ) ));
    assert_eq! (::core::mem::align_of::<pgrphashhead>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pgrphashhead ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pgrphashhead ) ) . lh_first as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pgrphashhead ) , "::" ,
                stringify ! ( lh_first ) ));
}
impl Clone for pgrphashhead {
    fn clone(&self) -> Self { *self }
}
impl Default for pgrphashhead {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    #[link_name = "pgrphashtbl"]
    pub static mut pgrphashtbl: *mut pgrphashhead;
}
extern "C" {
    #[link_name = "pgrphash"]
    pub static mut pgrphash: u_long;
}
extern "C" {
    #[link_name = "allproc_lock"]
    pub static mut allproc_lock: sx;
}
extern "C" {
    #[link_name = "allproc_gen"]
    pub static mut allproc_gen: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "proctree_lock"]
    pub static mut proctree_lock: sx;
}
extern "C" {
    #[link_name = "ppeers_lock"]
    pub static mut ppeers_lock: mtx;
}
extern "C" {
    #[link_name = "proc0"]
    pub static mut proc0: proc_;
}
extern "C" {
    #[link_name = "thread0_st"]
    pub static mut thread0_st: thread0_storage;
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct vmspace {
    pub _address: u8,
}
impl Clone for vmspace {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "vmspace0"]
    pub static mut vmspace0: vmspace;
}
extern "C" {
    #[link_name = "hogticks"]
    pub static mut hogticks: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "lastpid"]
    pub static mut lastpid: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "nprocs"]
    pub static mut nprocs: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "maxproc"]
    pub static mut maxproc: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "maxprocperuid"]
    pub static mut maxprocperuid: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "ps_arg_cache_limit"]
    pub static mut ps_arg_cache_limit: u_long;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct proclist {
    pub lh_first: *mut proc_,
}
#[test]
fn bindgen_test_layout_proclist() {
    assert_eq!(::core::mem::size_of::<proclist>() , 8usize , concat ! (
               "Size of: " , stringify ! ( proclist ) ));
    assert_eq! (::core::mem::align_of::<proclist>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( proclist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const proclist ) ) . lh_first as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( proclist ) , "::" ,
                stringify ! ( lh_first ) ));
}
impl Clone for proclist {
    fn clone(&self) -> Self { *self }
}
impl Default for proclist {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct procqueue {
    pub tqh_first: *mut proc_,
    pub tqh_last: *mut *mut proc_,
}
#[test]
fn bindgen_test_layout_procqueue() {
    assert_eq!(::core::mem::size_of::<procqueue>() , 16usize , concat ! (
               "Size of: " , stringify ! ( procqueue ) ));
    assert_eq! (::core::mem::align_of::<procqueue>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( procqueue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const procqueue ) ) . tqh_first as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( procqueue ) , "::" ,
                stringify ! ( tqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const procqueue ) ) . tqh_last as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( procqueue ) , "::" ,
                stringify ! ( tqh_last ) ));
}
impl Clone for procqueue {
    fn clone(&self) -> Self { *self }
}
impl Default for procqueue {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct threadqueue {
    pub tqh_first: *mut thread,
    pub tqh_last: *mut *mut thread,
}
#[test]
fn bindgen_test_layout_threadqueue() {
    assert_eq!(::core::mem::size_of::<threadqueue>() , 16usize , concat ! (
               "Size of: " , stringify ! ( threadqueue ) ));
    assert_eq! (::core::mem::align_of::<threadqueue>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( threadqueue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const threadqueue ) ) . tqh_first as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( threadqueue ) , "::" ,
                stringify ! ( tqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const threadqueue ) ) . tqh_last as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( threadqueue ) , "::" ,
                stringify ! ( tqh_last ) ));
}
impl Clone for threadqueue {
    fn clone(&self) -> Self { *self }
}
impl Default for threadqueue {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    #[link_name = "allproc"]
    pub static mut allproc: proclist;
}
extern "C" {
    #[link_name = "zombproc"]
    pub static mut zombproc: proclist;
}
extern "C" {
    #[link_name = "initproc"]
    pub static mut initproc: *mut proc_;
}
extern "C" {
    #[link_name = "pageproc"]
    pub static mut pageproc: *mut proc_;
}
extern "C" {
    #[link_name = "proc_zone"]
    pub static mut proc_zone: *mut uma_zone;
}
extern "C" {
    pub fn pfind(arg1: pid_t) -> *mut proc_;
}
extern "C" {
    pub fn pfind_any(arg1: pid_t) -> *mut proc_;
}
extern "C" {
    pub fn pfind_locked(pid: pid_t) -> *mut proc_;
}
extern "C" {
    pub fn pgfind(arg1: pid_t) -> *mut pgrp;
}
extern "C" {
    pub fn zpfind(arg1: pid_t) -> *mut proc_;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct fork_req {
    pub fr_flags: ::kernel::sys::raw::c_int,
    pub fr_pages: ::kernel::sys::raw::c_int,
    pub fr_pidp: *mut ::kernel::sys::raw::c_int,
    pub fr_procp: *mut *mut proc_,
    pub fr_pd_fd: *mut ::kernel::sys::raw::c_int,
    pub fr_pd_flags: ::kernel::sys::raw::c_int,
    pub fr_pd_fcaps: *mut filecaps,
}
#[test]
fn bindgen_test_layout_fork_req() {
    assert_eq!(::core::mem::size_of::<fork_req>() , 48usize , concat ! (
               "Size of: " , stringify ! ( fork_req ) ));
    assert_eq! (::core::mem::align_of::<fork_req>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( fork_req ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fork_req ) ) . fr_flags as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( fork_req ) , "::" ,
                stringify ! ( fr_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fork_req ) ) . fr_pages as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( fork_req ) , "::" ,
                stringify ! ( fr_pages ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fork_req ) ) . fr_pidp as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( fork_req ) , "::" ,
                stringify ! ( fr_pidp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fork_req ) ) . fr_procp as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( fork_req ) , "::" ,
                stringify ! ( fr_procp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fork_req ) ) . fr_pd_fd as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( fork_req ) , "::" ,
                stringify ! ( fr_pd_fd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fork_req ) ) . fr_pd_flags as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( fork_req ) , "::" ,
                stringify ! ( fr_pd_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const fork_req ) ) . fr_pd_fcaps as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( fork_req ) , "::" ,
                stringify ! ( fr_pd_fcaps ) ));
}
impl Clone for fork_req {
    fn clone(&self) -> Self { *self }
}
impl Default for fork_req {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    pub fn pget(pid: pid_t, flags: ::kernel::sys::raw::c_int,
                pp: *mut *mut proc_) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn ast(framep: *mut trapframe);
}
extern "C" {
    pub fn choosethread() -> *mut thread;
}
extern "C" {
    pub fn cr_cansee(u1: *mut ucred, u2: *mut ucred)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn cr_canseesocket(cred: *mut ucred, so: *mut socket)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn cr_canseeothergids(u1: *mut ucred, u2: *mut ucred)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn cr_canseeotheruids(u1: *mut ucred, u2: *mut ucred)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn cr_canseejailproc(u1: *mut ucred, u2: *mut ucred)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn cr_cansignal(cred: *mut ucred, proc_: *mut proc_,
                        signum: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn enterpgrp(p: *mut proc_, pgid: pid_t, pgrp: *mut pgrp,
                     sess: *mut session) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn enterthispgrp(p: *mut proc_, pgrp: *mut pgrp)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn faultin(p: *mut proc_);
}
extern "C" {
    pub fn fixjobc(p: *mut proc_, pgrp: *mut pgrp,
                   entering: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn fork1(arg1: *mut thread, arg2: *mut fork_req)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn fork_exit(arg1:
                         ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                         *mut ::kernel::sys::raw::c_void,
                                                                     arg2:
                                                                         *mut trapframe)>,
                     arg2: *mut ::kernel::sys::raw::c_void,
                     arg3: *mut trapframe);
}
extern "C" {
    pub fn fork_return(arg1: *mut thread, arg2: *mut trapframe);
}
extern "C" {
    pub fn inferior(p: *mut proc_) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn kern_proc_vmmap_resident(map: *mut vm_map,
                                    entry: *mut vm_map_entry,
                                    resident_count:
                                        *mut ::kernel::sys::raw::c_int,
                                    super_: *mut bool_);
}
extern "C" {
    pub fn kern_yield(arg1: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn kick_proc0();
}
extern "C" {
    pub fn killjobc();
}
extern "C" {
    pub fn leavepgrp(p: *mut proc_) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn maybe_preempt(td: *mut thread) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn maybe_yield();
}
extern "C" {
    pub fn mi_switch(flags: ::kernel::sys::raw::c_int, newtd: *mut thread);
}
extern "C" {
    pub fn p_candebug(td: *mut thread, p: *mut proc_)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn p_cansee(td: *mut thread, p: *mut proc_)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn p_cansched(td: *mut thread, p: *mut proc_)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn p_cansignal(td: *mut thread, p: *mut proc_,
                       signum: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn p_canwait(td: *mut thread, p: *mut proc_)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn pargs_alloc(len: ::kernel::sys::raw::c_int) -> *mut pargs;
}
extern "C" {
    pub fn pargs_drop(pa: *mut pargs);
}
extern "C" {
    pub fn pargs_hold(pa: *mut pargs);
}
extern "C" {
    pub fn proc_getargv(td: *mut thread, p: *mut proc_, sb: *mut sbuf)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn proc_getauxv(td: *mut thread, p: *mut proc_, sb: *mut sbuf)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn proc_getenvv(td: *mut thread, p: *mut proc_, sb: *mut sbuf)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn procinit();
}
extern "C" {
    pub fn proc_linkup0(p: *mut proc_, td: *mut thread);
}
extern "C" {
    pub fn proc_linkup(p: *mut proc_, td: *mut thread);
}
extern "C" {
    pub fn proc_realparent(child: *mut proc_) -> *mut proc_;
}
extern "C" {
    pub fn proc_reap(td: *mut thread, p: *mut proc_,
                     status: *mut ::kernel::sys::raw::c_int,
                     options: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn proc_reparent(child: *mut proc_, newparent: *mut proc_);
}
extern "C" {
    pub fn proc_set_traced(p: *mut proc_, stop: bool_);
}
extern "C" {
    pub fn pstats_alloc() -> *mut pstats;
}
extern "C" {
    pub fn pstats_fork(src: *mut pstats, dst: *mut pstats);
}
extern "C" {
    pub fn pstats_free(ps: *mut pstats);
}
extern "C" {
    pub fn reaper_abandon_children(p: *mut proc_, exiting: bool_);
}
extern "C" {
    pub fn securelevel_ge(cr: *mut ucred, level: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn securelevel_gt(cr: *mut ucred, level: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sess_hold(arg1: *mut session);
}
extern "C" {
    pub fn sess_release(arg1: *mut session);
}
extern "C" {
    pub fn setrunnable(arg1: *mut thread) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn setsugid(p: *mut proc_);
}
extern "C" {
    pub fn should_yield() -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sigonstack(sp: usize) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn stopevent(arg1: *mut proc_, arg2: u_int, arg3: u_int);
}
extern "C" {
    pub fn tdfind(arg1: lwpid_t, arg2: pid_t) -> *mut thread;
}
extern "C" {
    pub fn threadinit();
}
extern "C" {
    pub fn tidhash_add(arg1: *mut thread);
}
extern "C" {
    pub fn tidhash_remove(arg1: *mut thread);
}
extern "C" {
    pub fn cpu_idle(arg1: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn cpu_idle_wakeup(arg1: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "cpu_idle_hook"]
    pub static mut cpu_idle_hook:
               ::core::option::Option<unsafe extern "C" fn(arg1: sbintime_t)>;
}
extern "C" {
    pub fn cpu_switch(arg1: *mut thread, arg2: *mut thread, arg3: *mut mtx);
}
extern "C" {
    pub fn cpu_throw(arg1: *mut thread, arg2: *mut thread);
}
extern "C" {
    pub fn unsleep(arg1: *mut thread);
}
extern "C" {
    pub fn userret(arg1: *mut thread, arg2: *mut trapframe);
}
extern "C" {
    pub fn cpu_exit(arg1: *mut thread);
}
extern "C" {
    pub fn exit1(arg1: *mut thread, arg2: ::kernel::sys::raw::c_int,
                 arg3: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn cpu_copy_thread(td: *mut thread, td0: *mut thread);
}
extern "C" {
    pub fn cpu_fetch_syscall_args(td: *mut thread)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn cpu_fork(arg1: *mut thread, arg2: *mut proc_, arg3: *mut thread,
                    arg4: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn cpu_fork_kthread_handler(arg1: *mut thread,
                                    arg2:
                                        ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                                        *mut ::kernel::sys::raw::c_void)>,
                                    arg3: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn cpu_set_syscall_retval(arg1: *mut thread,
                                  arg2: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn cpu_set_upcall(arg1: *mut thread,
                          arg2:
                              ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                              *mut ::kernel::sys::raw::c_void)>,
                          arg3: *mut ::kernel::sys::raw::c_void,
                          arg4: *mut stack_t);
}
extern "C" {
    pub fn cpu_set_user_tls(arg1: *mut thread,
                            tls_base: *mut ::kernel::sys::raw::c_void)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn cpu_thread_alloc(arg1: *mut thread);
}
extern "C" {
    pub fn cpu_thread_clean(arg1: *mut thread);
}
extern "C" {
    pub fn cpu_thread_exit(arg1: *mut thread);
}
extern "C" {
    pub fn cpu_thread_free(arg1: *mut thread);
}
extern "C" {
    pub fn cpu_thread_swapin(arg1: *mut thread);
}
extern "C" {
    pub fn cpu_thread_swapout(arg1: *mut thread);
}
extern "C" {
    pub fn thread_alloc(pages: ::kernel::sys::raw::c_int) -> *mut thread;
}
extern "C" {
    pub fn thread_alloc_stack(arg1: *mut thread,
                              pages: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn thread_cow_get_proc(newtd: *mut thread, p: *mut proc_);
}
extern "C" {
    pub fn thread_cow_get(newtd: *mut thread, td: *mut thread);
}
extern "C" {
    pub fn thread_cow_free(td: *mut thread);
}
extern "C" {
    pub fn thread_cow_update(td: *mut thread);
}
extern "C" {
    pub fn thread_create(td: *mut thread, rtp: *mut rtprio,
                         initialize_thread:
                             ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                             *mut thread,
                                                                         arg2:
                                                                             *mut ::kernel::sys::raw::c_void)
                                                        ->
                                                            ::kernel::sys::raw::c_int>,
                         thunk: *mut ::kernel::sys::raw::c_void)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn thread_exit();
}
extern "C" {
    pub fn thread_free(td: *mut thread);
}
extern "C" {
    pub fn thread_link(td: *mut thread, p: *mut proc_);
}
extern "C" {
    pub fn thread_reap();
}
extern "C" {
    pub fn thread_single(p: *mut proc_, how: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn thread_single_end(p: *mut proc_, how: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn thread_stash(td: *mut thread);
}
extern "C" {
    pub fn thread_stopped(p: *mut proc_);
}
extern "C" {
    pub fn childproc_stopped(child: *mut proc_,
                             reason: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn childproc_continued(child: *mut proc_);
}
extern "C" {
    pub fn childproc_exited(child: *mut proc_);
}
extern "C" {
    pub fn thread_suspend_check(how: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn thread_suspend_check_needed() -> bool_;
}
extern "C" {
    pub fn thread_suspend_switch(arg1: *mut thread, p: *mut proc_);
}
extern "C" {
    pub fn thread_suspend_one(td: *mut thread);
}
extern "C" {
    pub fn thread_unlink(td: *mut thread);
}
extern "C" {
    pub fn thread_unsuspend(p: *mut proc_);
}
extern "C" {
    pub fn thread_wait(p: *mut proc_);
}
extern "C" {
    pub fn thread_find(p: *mut proc_, tid: lwpid_t) -> *mut thread;
}
extern "C" {
    pub fn stop_all_proc();
}
extern "C" {
    pub fn resume_all_proc();
}
extern "C" {
    #[link_name = "softdep_ast_cleanup"]
    pub static mut softdep_ast_cleanup:
               ::core::option::Option<unsafe extern "C" fn(arg1:
                                                               *mut thread)>;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct epoch {
    _unused: [u8; 0],
}
pub type epoch_t = *mut epoch;
extern "C" {
    #[link_name = "global_epoch"]
    pub static mut global_epoch: epoch_t;
}
extern "C" {
    #[link_name = "global_epoch_preempt"]
    pub static mut global_epoch_preempt: epoch_t;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct epoch_context {
    pub data: [*mut ::kernel::sys::raw::c_void; 2usize],
}
#[test]
fn bindgen_test_layout_epoch_context() {
    assert_eq!(::core::mem::size_of::<epoch_context>() , 16usize , concat ! (
               "Size of: " , stringify ! ( epoch_context ) ));
    assert_eq! (::core::mem::align_of::<epoch_context>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( epoch_context ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const epoch_context ) ) . data as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( epoch_context ) , "::"
                , stringify ! ( data ) ));
}
impl Clone for epoch_context {
    fn clone(&self) -> Self { *self }
}
impl Default for epoch_context {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type epoch_context_t = *mut epoch_context;
extern "C" {
    pub fn epoch_alloc(flags: ::kernel::sys::raw::c_int) -> epoch_t;
}
extern "C" {
    pub fn epoch_free(epoch: epoch_t);
}
extern "C" {
    pub fn epoch_enter(epoch: epoch_t);
}
extern "C" {
    pub fn epoch_enter_preempt_internal(epoch: epoch_t, td: *mut thread);
}
extern "C" {
    pub fn epoch_exit(epoch: epoch_t);
}
extern "C" {
    pub fn epoch_exit_preempt_internal(epoch: epoch_t, td: *mut thread);
}
extern "C" {
    pub fn epoch_wait(epoch: epoch_t);
}
extern "C" {
    pub fn epoch_wait_preempt(epoch: epoch_t);
}
extern "C" {
    pub fn epoch_call(epoch: epoch_t, ctx: epoch_context_t,
                      callback:
                          ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                          epoch_context_t)>);
}
extern "C" {
    pub fn in_epoch() -> ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "pcpu_entry_epoch_cb_count"]
    pub static mut pcpu_entry_epoch_cb_count: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "pcpu_entry_epoch_cb_task"]
    pub static mut pcpu_entry_epoch_cb_task: grouptask;
}
#[repr(C)]
#[derive(Copy)]
pub struct rwlock_padalign {
    pub lock_object: lock_object,
    pub rw_lock: usize,
    pub __bindgen_padding_0: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_rwlock_padalign() {
    assert_eq!(::core::mem::size_of::<rwlock_padalign>() , 64usize , concat !
               ( "Size of: " , stringify ! ( rwlock_padalign ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rwlock_padalign ) ) . lock_object as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rwlock_padalign ) ,
                "::" , stringify ! ( lock_object ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rwlock_padalign ) ) . rw_lock as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rwlock_padalign ) ,
                "::" , stringify ! ( rw_lock ) ));
}
impl Clone for rwlock_padalign {
    fn clone(&self) -> Self { *self }
}
impl Default for rwlock_padalign {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for rwlock_padalign {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "rwlock_padalign {{ lock_object: {:?}, rw_lock: {:?} }}" ,
               self . lock_object , self . rw_lock)
    }
}
extern "C" {
    pub fn _rw_init_flags(c: *mut usize,
                          name: *const ::kernel::sys::raw::c_char,
                          opts: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn _rw_destroy(c: *mut usize);
}
extern "C" {
    pub fn rw_sysinit(arg: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn rw_sysinit_flags(arg: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn _rw_wowned(c: *const usize) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn _rw_wlock_cookie(c: *mut usize,
                            file: *const ::kernel::sys::raw::c_char,
                            line: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn __rw_try_wlock_int(rw: *mut rwlock,
                              file: *const ::kernel::sys::raw::c_char,
                              line: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn __rw_try_wlock(c: *mut usize,
                          file: *const ::kernel::sys::raw::c_char,
                          line: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn _rw_wunlock_cookie(c: *mut usize,
                              file: *const ::kernel::sys::raw::c_char,
                              line: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn __rw_rlock_int(rw: *mut rwlock,
                          file: *const ::kernel::sys::raw::c_char,
                          line: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn __rw_rlock(c: *mut usize, file: *const ::kernel::sys::raw::c_char,
                      line: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn __rw_try_rlock_int(rw: *mut rwlock,
                              file: *const ::kernel::sys::raw::c_char,
                              line: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn __rw_try_rlock(c: *mut usize,
                          file: *const ::kernel::sys::raw::c_char,
                          line: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn _rw_runlock_cookie_int(rw: *mut rwlock,
                                  file: *const ::kernel::sys::raw::c_char,
                                  line: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn _rw_runlock_cookie(c: *mut usize,
                              file: *const ::kernel::sys::raw::c_char,
                              line: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn __rw_wlock_hard(c: *mut usize, v: usize,
                           file: *const ::kernel::sys::raw::c_char,
                           line: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn __rw_wunlock_hard(c: *mut usize, v: usize,
                             file: *const ::kernel::sys::raw::c_char,
                             line: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn __rw_try_upgrade_int(rw: *mut rwlock,
                                file: *const ::kernel::sys::raw::c_char,
                                line: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn __rw_try_upgrade(c: *mut usize,
                            file: *const ::kernel::sys::raw::c_char,
                            line: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn __rw_downgrade_int(rw: *mut rwlock,
                              file: *const ::kernel::sys::raw::c_char,
                              line: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn __rw_downgrade(c: *mut usize,
                          file: *const ::kernel::sys::raw::c_char,
                          line: ::kernel::sys::raw::c_int);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rw_args {
    pub ra_rw: *mut ::kernel::sys::raw::c_void,
    pub ra_desc: *const ::kernel::sys::raw::c_char,
    pub ra_flags: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_rw_args() {
    assert_eq!(::core::mem::size_of::<rw_args>() , 24usize , concat ! (
               "Size of: " , stringify ! ( rw_args ) ));
    assert_eq! (::core::mem::align_of::<rw_args>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rw_args ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rw_args ) ) . ra_rw as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rw_args ) , "::" ,
                stringify ! ( ra_rw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rw_args ) ) . ra_desc as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rw_args ) , "::" ,
                stringify ! ( ra_desc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rw_args ) ) . ra_flags as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rw_args ) , "::" ,
                stringify ! ( ra_flags ) ));
}
impl Clone for rw_args {
    fn clone(&self) -> Self { *self }
}
impl Default for rw_args {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    pub fn sx_sysinit(arg: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn sx_init_flags(sx: *mut sx,
                         description: *const ::kernel::sys::raw::c_char,
                         opts: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn sx_destroy(sx: *mut sx);
}
extern "C" {
    pub fn sx_try_slock_int(sx: *mut sx,
                            file: *const ::kernel::sys::raw::c_char,
                            line: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sx_try_slock_(sx: *mut sx, file: *const ::kernel::sys::raw::c_char,
                         line: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sx_try_xlock_int(sx: *mut sx,
                            file: *const ::kernel::sys::raw::c_char,
                            line: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sx_try_xlock_(sx: *mut sx, file: *const ::kernel::sys::raw::c_char,
                         line: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sx_try_upgrade_int(sx: *mut sx,
                              file: *const ::kernel::sys::raw::c_char,
                              line: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sx_try_upgrade_(sx: *mut sx,
                           file: *const ::kernel::sys::raw::c_char,
                           line: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn sx_downgrade_int(sx: *mut sx,
                            file: *const ::kernel::sys::raw::c_char,
                            line: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn sx_downgrade_(sx: *mut sx, file: *const ::kernel::sys::raw::c_char,
                         line: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn _sx_slock_int(sx: *mut sx, opts: ::kernel::sys::raw::c_int,
                         file: *const ::kernel::sys::raw::c_char,
                         line: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn _sx_slock(sx: *mut sx, opts: ::kernel::sys::raw::c_int,
                     file: *const ::kernel::sys::raw::c_char,
                     line: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn _sx_xlock(sx: *mut sx, opts: ::kernel::sys::raw::c_int,
                     file: *const ::kernel::sys::raw::c_char,
                     line: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn _sx_sunlock_int(sx: *mut sx,
                           file: *const ::kernel::sys::raw::c_char,
                           line: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn _sx_sunlock(sx: *mut sx, file: *const ::kernel::sys::raw::c_char,
                       line: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn _sx_xunlock(sx: *mut sx, file: *const ::kernel::sys::raw::c_char,
                       line: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn _sx_xlock_hard(sx: *mut sx, x: usize,
                          opts: ::kernel::sys::raw::c_int,
                          file: *const ::kernel::sys::raw::c_char,
                          line: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn _sx_xunlock_hard(sx: *mut sx, x: usize,
                            file: *const ::kernel::sys::raw::c_char,
                            line: ::kernel::sys::raw::c_int);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct sx_args {
    pub sa_sx: *mut sx,
    pub sa_desc: *const ::kernel::sys::raw::c_char,
    pub sa_flags: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_sx_args() {
    assert_eq!(::core::mem::size_of::<sx_args>() , 24usize , concat ! (
               "Size of: " , stringify ! ( sx_args ) ));
    assert_eq! (::core::mem::align_of::<sx_args>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( sx_args ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sx_args ) ) . sa_sx as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sx_args ) , "::" ,
                stringify ! ( sa_sx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sx_args ) ) . sa_desc as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sx_args ) , "::" ,
                stringify ! ( sa_desc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sx_args ) ) . sa_flags as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( sx_args ) , "::" ,
                stringify ! ( sa_flags ) ));
}
impl Clone for sx_args {
    fn clone(&self) -> Self { *self }
}
impl Default for sx_args {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct altq_pktattr {
    pub pattr_class: *mut ::kernel::sys::raw::c_void,
    pub pattr_af: ::kernel::sys::raw::c_int,
    pub pattr_hdr: caddr_t,
}
#[test]
fn bindgen_test_layout_altq_pktattr() {
    assert_eq!(::core::mem::size_of::<altq_pktattr>() , 24usize , concat ! (
               "Size of: " , stringify ! ( altq_pktattr ) ));
    assert_eq! (::core::mem::align_of::<altq_pktattr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( altq_pktattr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const altq_pktattr ) ) . pattr_class as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( altq_pktattr ) , "::" ,
                stringify ! ( pattr_class ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const altq_pktattr ) ) . pattr_af as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( altq_pktattr ) , "::" ,
                stringify ! ( pattr_af ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const altq_pktattr ) ) . pattr_hdr as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( altq_pktattr ) , "::" ,
                stringify ! ( pattr_hdr ) ));
}
impl Clone for altq_pktattr {
    fn clone(&self) -> Self { *self }
}
impl Default for altq_pktattr {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct tb_regulator {
    pub tbr_rate: i64,
    pub tbr_depth: i64,
    pub tbr_token: i64,
    pub tbr_filluptime: i64,
    pub tbr_last: u_int64_t,
    pub tbr_lastop: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_tb_regulator() {
    assert_eq!(::core::mem::size_of::<tb_regulator>() , 48usize , concat ! (
               "Size of: " , stringify ! ( tb_regulator ) ));
    assert_eq! (::core::mem::align_of::<tb_regulator>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( tb_regulator ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tb_regulator ) ) . tbr_rate as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tb_regulator ) , "::" ,
                stringify ! ( tbr_rate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tb_regulator ) ) . tbr_depth as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tb_regulator ) , "::" ,
                stringify ! ( tbr_depth ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tb_regulator ) ) . tbr_token as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( tb_regulator ) , "::" ,
                stringify ! ( tbr_token ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tb_regulator ) ) . tbr_filluptime as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( tb_regulator ) , "::" ,
                stringify ! ( tbr_filluptime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tb_regulator ) ) . tbr_last as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( tb_regulator ) , "::" ,
                stringify ! ( tbr_last ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tb_regulator ) ) . tbr_lastop as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( tb_regulator ) , "::" ,
                stringify ! ( tbr_lastop ) ));
}
impl Clone for tb_regulator {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct top_cdnr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifaltq {
    pub ifq_head: *mut mbuf,
    pub ifq_tail: *mut mbuf,
    pub ifq_len: ::kernel::sys::raw::c_int,
    pub ifq_maxlen: ::kernel::sys::raw::c_int,
    pub ifq_mtx: mtx,
    pub ifq_drv_head: *mut mbuf,
    pub ifq_drv_tail: *mut mbuf,
    pub ifq_drv_len: ::kernel::sys::raw::c_int,
    pub ifq_drv_maxlen: ::kernel::sys::raw::c_int,
    pub altq_type: ::kernel::sys::raw::c_int,
    pub altq_flags: ::kernel::sys::raw::c_int,
    pub altq_disc: *mut ::kernel::sys::raw::c_void,
    pub altq_ifp: *mut ifnet,
    pub altq_enqueue: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ifaltq,
                                                                  arg2:
                                                                      *mut mbuf,
                                                                  arg3:
                                                                      *mut altq_pktattr)
                                                 ->
                                                     ::kernel::sys::raw::c_int>,
    pub altq_dequeue: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ifaltq,
                                                                  arg2:
                                                                      ::kernel::sys::raw::c_int)
                                                 -> *mut mbuf>,
    pub altq_request: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut ifaltq,
                                                                  arg2:
                                                                      ::kernel::sys::raw::c_int,
                                                                  arg3:
                                                                      *mut ::kernel::sys::raw::c_void)
                                                 ->
                                                     ::kernel::sys::raw::c_int>,
    pub altq_clfier: *mut ::kernel::sys::raw::c_void,
    pub altq_classify: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                       *mut ::kernel::sys::raw::c_void,
                                                                   arg2:
                                                                       *mut mbuf,
                                                                   arg3:
                                                                       ::kernel::sys::raw::c_int)
                                                  ->
                                                      *mut ::kernel::sys::raw::c_void>,
    pub altq_tbr: *mut tb_regulator,
    pub altq_cdnr: *mut top_cdnr,
}
#[test]
fn bindgen_test_layout_ifaltq() {
    assert_eq!(::core::mem::size_of::<ifaltq>() , 160usize , concat ! (
               "Size of: " , stringify ! ( ifaltq ) ));
    assert_eq! (::core::mem::align_of::<ifaltq>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ifaltq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaltq ) ) . ifq_head as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaltq ) , "::" ,
                stringify ! ( ifq_head ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaltq ) ) . ifq_tail as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaltq ) , "::" ,
                stringify ! ( ifq_tail ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaltq ) ) . ifq_len as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaltq ) , "::" ,
                stringify ! ( ifq_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaltq ) ) . ifq_maxlen as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaltq ) , "::" ,
                stringify ! ( ifq_maxlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaltq ) ) . ifq_mtx as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaltq ) , "::" ,
                stringify ! ( ifq_mtx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaltq ) ) . ifq_drv_head as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaltq ) , "::" ,
                stringify ! ( ifq_drv_head ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaltq ) ) . ifq_drv_tail as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaltq ) , "::" ,
                stringify ! ( ifq_drv_tail ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaltq ) ) . ifq_drv_len as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaltq ) , "::" ,
                stringify ! ( ifq_drv_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaltq ) ) . ifq_drv_maxlen as * const _
                as usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaltq ) , "::" ,
                stringify ! ( ifq_drv_maxlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaltq ) ) . altq_type as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaltq ) , "::" ,
                stringify ! ( altq_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaltq ) ) . altq_flags as * const _ as
                usize } , 84usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaltq ) , "::" ,
                stringify ! ( altq_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaltq ) ) . altq_disc as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaltq ) , "::" ,
                stringify ! ( altq_disc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaltq ) ) . altq_ifp as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaltq ) , "::" ,
                stringify ! ( altq_ifp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaltq ) ) . altq_enqueue as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaltq ) , "::" ,
                stringify ! ( altq_enqueue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaltq ) ) . altq_dequeue as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaltq ) , "::" ,
                stringify ! ( altq_dequeue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaltq ) ) . altq_request as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaltq ) , "::" ,
                stringify ! ( altq_request ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaltq ) ) . altq_clfier as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaltq ) , "::" ,
                stringify ! ( altq_clfier ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaltq ) ) . altq_classify as * const _
                as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaltq ) , "::" ,
                stringify ! ( altq_classify ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaltq ) ) . altq_tbr as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaltq ) , "::" ,
                stringify ! ( altq_tbr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaltq ) ) . altq_cdnr as * const _ as
                usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaltq ) , "::" ,
                stringify ! ( altq_cdnr ) ));
}
impl Clone for ifaltq {
    fn clone(&self) -> Self { *self }
}
impl Default for ifaltq {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct altq_tag {
    pub qid: u_int32_t,
    pub af: ::kernel::sys::raw::c_int,
    pub hdr: *mut ::kernel::sys::raw::c_void,
}
#[test]
fn bindgen_test_layout_altq_tag() {
    assert_eq!(::core::mem::size_of::<altq_tag>() , 16usize , concat ! (
               "Size of: " , stringify ! ( altq_tag ) ));
    assert_eq! (::core::mem::align_of::<altq_tag>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( altq_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const altq_tag ) ) . qid as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( altq_tag ) , "::" ,
                stringify ! ( qid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const altq_tag ) ) . af as * const _ as usize }
                , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( altq_tag ) , "::" ,
                stringify ! ( af ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const altq_tag ) ) . hdr as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( altq_tag ) , "::" ,
                stringify ! ( hdr ) ));
}
impl Clone for altq_tag {
    fn clone(&self) -> Self { *self }
}
impl Default for altq_tag {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    pub fn altq_attach(arg1: *mut ifaltq, arg2: ::kernel::sys::raw::c_int,
                       arg3: *mut ::kernel::sys::raw::c_void,
                       arg4:
                           ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                           *mut ifaltq,
                                                                       arg2:
                                                                           *mut mbuf,
                                                                       arg3:
                                                                           *mut altq_pktattr)
                                                      ->
                                                          ::kernel::sys::raw::c_int>,
                       arg5:
                           ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                           *mut ifaltq,
                                                                       arg2:
                                                                           ::kernel::sys::raw::c_int)
                                                      -> *mut mbuf>,
                       arg6:
                           ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                           *mut ifaltq,
                                                                       arg2:
                                                                           ::kernel::sys::raw::c_int,
                                                                       arg3:
                                                                           *mut ::kernel::sys::raw::c_void)
                                                      ->
                                                          ::kernel::sys::raw::c_int>,
                       arg7: *mut ::kernel::sys::raw::c_void,
                       arg8:
                           ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                           *mut ::kernel::sys::raw::c_void,
                                                                       arg2:
                                                                           *mut mbuf,
                                                                       arg3:
                                                                           ::kernel::sys::raw::c_int)
                                                      ->
                                                          *mut ::kernel::sys::raw::c_void>)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn altq_detach(arg1: *mut ifaltq) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn altq_enable(arg1: *mut ifaltq) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn altq_disable(arg1: *mut ifaltq) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "tbr_dequeue_ptr"]
    pub static mut tbr_dequeue_ptr:
               ::core::option::Option<unsafe extern "C" fn(arg1: *mut ifaltq,
                                                           arg2:
                                                               ::kernel::sys::raw::c_int)
                                          -> *mut mbuf>;
}
extern "C" {
    #[link_name = "altq_input"]
    pub static mut altq_input:
               ::core::option::Option<unsafe extern "C" fn(arg1: *mut mbuf,
                                                           arg2:
                                                               ::kernel::sys::raw::c_int)
                                          -> ::kernel::sys::raw::c_int>;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifnethead {
    pub cstqh_first: *mut ifnet,
    pub cstqh_last: *mut *mut ifnet,
}
#[test]
fn bindgen_test_layout_ifnethead() {
    assert_eq!(::core::mem::size_of::<ifnethead>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ifnethead ) ));
    assert_eq! (::core::mem::align_of::<ifnethead>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ifnethead ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnethead ) ) . cstqh_first as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnethead ) , "::" ,
                stringify ! ( cstqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnethead ) ) . cstqh_last as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnethead ) , "::" ,
                stringify ! ( cstqh_last ) ));
}
impl Clone for ifnethead {
    fn clone(&self) -> Self { *self }
}
impl Default for ifnethead {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifaddrhead {
    pub cstqh_first: *mut ifaddr,
    pub cstqh_last: *mut *mut ifaddr,
}
#[test]
fn bindgen_test_layout_ifaddrhead() {
    assert_eq!(::core::mem::size_of::<ifaddrhead>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ifaddrhead ) ));
    assert_eq! (::core::mem::align_of::<ifaddrhead>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ifaddrhead ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaddrhead ) ) . cstqh_first as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaddrhead ) , "::" ,
                stringify ! ( cstqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaddrhead ) ) . cstqh_last as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaddrhead ) , "::" ,
                stringify ! ( cstqh_last ) ));
}
impl Clone for ifaddrhead {
    fn clone(&self) -> Self { *self }
}
impl Default for ifaddrhead {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifmultihead {
    pub cstqh_first: *mut ifmultiaddr,
    pub cstqh_last: *mut *mut ifmultiaddr,
}
#[test]
fn bindgen_test_layout_ifmultihead() {
    assert_eq!(::core::mem::size_of::<ifmultihead>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ifmultihead ) ));
    assert_eq! (::core::mem::align_of::<ifmultihead>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ifmultihead ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmultihead ) ) . cstqh_first as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmultihead ) , "::" ,
                stringify ! ( cstqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmultihead ) ) . cstqh_last as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmultihead ) , "::" ,
                stringify ! ( cstqh_last ) ));
}
impl Clone for ifmultihead {
    fn clone(&self) -> Self { *self }
}
impl Default for ifmultihead {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifgrouphead {
    pub cstqh_first: *mut ifg_group,
    pub cstqh_last: *mut *mut ifg_group,
}
#[test]
fn bindgen_test_layout_ifgrouphead() {
    assert_eq!(::core::mem::size_of::<ifgrouphead>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ifgrouphead ) ));
    assert_eq! (::core::mem::align_of::<ifgrouphead>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ifgrouphead ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifgrouphead ) ) . cstqh_first as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifgrouphead ) , "::" ,
                stringify ! ( cstqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifgrouphead ) ) . cstqh_last as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifgrouphead ) , "::" ,
                stringify ! ( cstqh_last ) ));
}
impl Clone for ifgrouphead {
    fn clone(&self) -> Self { *self }
}
impl Default for ifgrouphead {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pfil_head {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "link_pfil_hook"]
    pub static mut link_pfil_hook: pfil_head;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hhook_head {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "ipsec_hhh_in"]
    pub static mut ipsec_hhh_in: [*mut hhook_head; 2usize];
}
extern "C" {
    #[link_name = "ipsec_hhh_out"]
    pub static mut ipsec_hhh_out: [*mut hhook_head; 2usize];
}
extern "C" {
    #[link_name = "net_epoch_preempt"]
    pub static mut net_epoch_preempt: epoch_t;
}
extern "C" {
    #[link_name = "net_epoch"]
    pub static mut net_epoch: epoch_t;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ift_counter {
    IFCOUNTER_IPACKETS = 0,
    IFCOUNTER_IERRORS = 1,
    IFCOUNTER_OPACKETS = 2,
    IFCOUNTER_OERRORS = 3,
    IFCOUNTER_COLLISIONS = 4,
    IFCOUNTER_IBYTES = 5,
    IFCOUNTER_OBYTES = 6,
    IFCOUNTER_IMCASTS = 7,
    IFCOUNTER_OMCASTS = 8,
    IFCOUNTER_IQDROPS = 9,
    IFCOUNTER_OQDROPS = 10,
    IFCOUNTER_NOPROTO = 11,
    IFCOUNTERS = 12,
}
pub type if_t = *mut ifnet;
pub type if_start_fn_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: if_t)>;
pub type if_ioctl_fn_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: if_t, arg2: u_long,
                                                arg3: caddr_t)
                               -> ::kernel::sys::raw::c_int>;
pub type if_init_fn_t =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void)>;
pub type if_qflush_fn_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: if_t)>;
pub type if_transmit_fn_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: if_t, arg2: *mut mbuf)
                               -> ::kernel::sys::raw::c_int>;
pub type if_get_counter_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: if_t, arg2: ift_counter)
                               -> u64>;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct ifnet_hw_tsomax {
    pub tsomaxbytes: u_int,
    pub tsomaxsegcount: u_int,
    pub tsomaxsegsize: u_int,
}
#[test]
fn bindgen_test_layout_ifnet_hw_tsomax() {
    assert_eq!(::core::mem::size_of::<ifnet_hw_tsomax>() , 12usize , concat !
               ( "Size of: " , stringify ! ( ifnet_hw_tsomax ) ));
    assert_eq! (::core::mem::align_of::<ifnet_hw_tsomax>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( ifnet_hw_tsomax ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet_hw_tsomax ) ) . tsomaxbytes as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet_hw_tsomax ) ,
                "::" , stringify ! ( tsomaxbytes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet_hw_tsomax ) ) . tsomaxsegcount as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet_hw_tsomax ) ,
                "::" , stringify ! ( tsomaxsegcount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifnet_hw_tsomax ) ) . tsomaxsegsize as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifnet_hw_tsomax ) ,
                "::" , stringify ! ( tsomaxsegsize ) ));
}
impl Clone for ifnet_hw_tsomax {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ife_type { IFENCAP_LL = 1, }
#[repr(C)]
#[derive(Debug, Copy)]
pub struct if_encap_req {
    pub buf: *mut u_char,
    pub bufsize: usize,
    pub rtype: ife_type,
    pub flags: u32,
    pub family: ::kernel::sys::raw::c_int,
    pub lladdr_off: ::kernel::sys::raw::c_int,
    pub lladdr_len: ::kernel::sys::raw::c_int,
    pub lladdr: *mut ::kernel::sys::raw::c_char,
    pub hdata: *mut ::kernel::sys::raw::c_char,
}
#[test]
fn bindgen_test_layout_if_encap_req() {
    assert_eq!(::core::mem::size_of::<if_encap_req>() , 56usize , concat ! (
               "Size of: " , stringify ! ( if_encap_req ) ));
    assert_eq! (::core::mem::align_of::<if_encap_req>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( if_encap_req ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_encap_req ) ) . buf as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_encap_req ) , "::" ,
                stringify ! ( buf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_encap_req ) ) . bufsize as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( if_encap_req ) , "::" ,
                stringify ! ( bufsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_encap_req ) ) . rtype as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( if_encap_req ) , "::" ,
                stringify ! ( rtype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_encap_req ) ) . flags as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( if_encap_req ) , "::" ,
                stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_encap_req ) ) . family as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( if_encap_req ) , "::" ,
                stringify ! ( family ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_encap_req ) ) . lladdr_off as * const
                _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( if_encap_req ) , "::" ,
                stringify ! ( lladdr_off ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_encap_req ) ) . lladdr_len as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( if_encap_req ) , "::" ,
                stringify ! ( lladdr_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_encap_req ) ) . lladdr as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( if_encap_req ) , "::" ,
                stringify ! ( lladdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_encap_req ) ) . hdata as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( if_encap_req ) , "::" ,
                stringify ! ( hdata ) ));
}
impl Clone for if_encap_req {
    fn clone(&self) -> Self { *self }
}
impl Default for if_encap_req {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct if_snd_tag_alloc_header {
    pub type_: u32,
    pub flowid: u32,
    pub flowtype: u32,
}
#[test]
fn bindgen_test_layout_if_snd_tag_alloc_header() {
    assert_eq!(::core::mem::size_of::<if_snd_tag_alloc_header>() , 12usize ,
               concat ! (
               "Size of: " , stringify ! ( if_snd_tag_alloc_header ) ));
    assert_eq! (::core::mem::align_of::<if_snd_tag_alloc_header>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( if_snd_tag_alloc_header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_snd_tag_alloc_header ) ) . type_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_snd_tag_alloc_header
                ) , "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_snd_tag_alloc_header ) ) . flowid as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( if_snd_tag_alloc_header
                ) , "::" , stringify ! ( flowid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_snd_tag_alloc_header ) ) . flowtype as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( if_snd_tag_alloc_header
                ) , "::" , stringify ! ( flowtype ) ));
}
impl Clone for if_snd_tag_alloc_header {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct if_snd_tag_alloc_rate_limit {
    pub hdr: if_snd_tag_alloc_header,
    pub max_rate: u64,
}
#[test]
fn bindgen_test_layout_if_snd_tag_alloc_rate_limit() {
    assert_eq!(::core::mem::size_of::<if_snd_tag_alloc_rate_limit>() , 24usize
               , concat ! (
               "Size of: " , stringify ! ( if_snd_tag_alloc_rate_limit ) ));
    assert_eq! (::core::mem::align_of::<if_snd_tag_alloc_rate_limit>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( if_snd_tag_alloc_rate_limit )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_snd_tag_alloc_rate_limit ) ) . hdr as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                if_snd_tag_alloc_rate_limit ) , "::" , stringify ! ( hdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_snd_tag_alloc_rate_limit ) ) .
                max_rate as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                if_snd_tag_alloc_rate_limit ) , "::" , stringify ! ( max_rate
                ) ));
}
impl Clone for if_snd_tag_alloc_rate_limit {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct if_snd_tag_rate_limit_params {
    pub max_rate: u64,
    pub queue_level: u32,
    pub reserved: u32,
}
#[test]
fn bindgen_test_layout_if_snd_tag_rate_limit_params() {
    assert_eq!(::core::mem::size_of::<if_snd_tag_rate_limit_params>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( if_snd_tag_rate_limit_params ) ));
    assert_eq! (::core::mem::align_of::<if_snd_tag_rate_limit_params>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( if_snd_tag_rate_limit_params )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_snd_tag_rate_limit_params ) ) .
                max_rate as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                if_snd_tag_rate_limit_params ) , "::" , stringify ! ( max_rate
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_snd_tag_rate_limit_params ) ) .
                queue_level as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                if_snd_tag_rate_limit_params ) , "::" , stringify ! (
                queue_level ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_snd_tag_rate_limit_params ) ) .
                reserved as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                if_snd_tag_rate_limit_params ) , "::" , stringify ! ( reserved
                ) ));
}
impl Clone for if_snd_tag_rate_limit_params {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union if_snd_tag_alloc_params {
    pub hdr: if_snd_tag_alloc_header,
    pub rate_limit: if_snd_tag_alloc_rate_limit,
    pub unlimited: if_snd_tag_alloc_rate_limit,
    _bindgen_union_align: [u64; 3usize],
}
#[test]
fn bindgen_test_layout_if_snd_tag_alloc_params() {
    assert_eq!(::core::mem::size_of::<if_snd_tag_alloc_params>() , 24usize ,
               concat ! (
               "Size of: " , stringify ! ( if_snd_tag_alloc_params ) ));
    assert_eq! (::core::mem::align_of::<if_snd_tag_alloc_params>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( if_snd_tag_alloc_params ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_snd_tag_alloc_params ) ) . hdr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_snd_tag_alloc_params
                ) , "::" , stringify ! ( hdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_snd_tag_alloc_params ) ) . rate_limit
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_snd_tag_alloc_params
                ) , "::" , stringify ! ( rate_limit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_snd_tag_alloc_params ) ) . unlimited
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_snd_tag_alloc_params
                ) , "::" , stringify ! ( unlimited ) ));
}
impl Clone for if_snd_tag_alloc_params {
    fn clone(&self) -> Self { *self }
}
impl Default for if_snd_tag_alloc_params {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for if_snd_tag_alloc_params {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "if_snd_tag_alloc_params {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy)]
pub union if_snd_tag_modify_params {
    pub rate_limit: if_snd_tag_rate_limit_params,
    pub unlimited: if_snd_tag_rate_limit_params,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_if_snd_tag_modify_params() {
    assert_eq!(::core::mem::size_of::<if_snd_tag_modify_params>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( if_snd_tag_modify_params ) ));
    assert_eq! (::core::mem::align_of::<if_snd_tag_modify_params>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( if_snd_tag_modify_params ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_snd_tag_modify_params ) ) . rate_limit
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                if_snd_tag_modify_params ) , "::" , stringify ! ( rate_limit )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_snd_tag_modify_params ) ) . unlimited
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                if_snd_tag_modify_params ) , "::" , stringify ! ( unlimited )
                ));
}
impl Clone for if_snd_tag_modify_params {
    fn clone(&self) -> Self { *self }
}
impl Default for if_snd_tag_modify_params {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for if_snd_tag_modify_params {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "if_snd_tag_modify_params {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy)]
pub union if_snd_tag_query_params {
    pub rate_limit: if_snd_tag_rate_limit_params,
    pub unlimited: if_snd_tag_rate_limit_params,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_if_snd_tag_query_params() {
    assert_eq!(::core::mem::size_of::<if_snd_tag_query_params>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( if_snd_tag_query_params ) ));
    assert_eq! (::core::mem::align_of::<if_snd_tag_query_params>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( if_snd_tag_query_params ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_snd_tag_query_params ) ) . rate_limit
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_snd_tag_query_params
                ) , "::" , stringify ! ( rate_limit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_snd_tag_query_params ) ) . unlimited
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_snd_tag_query_params
                ) , "::" , stringify ! ( unlimited ) ));
}
impl Clone for if_snd_tag_query_params {
    fn clone(&self) -> Self { *self }
}
impl Default for if_snd_tag_query_params {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for if_snd_tag_query_params {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "if_snd_tag_query_params {{ union }}")
    }
}
pub type if_snd_tag_alloc_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ifnet,
                                                arg2:
                                                    *mut if_snd_tag_alloc_params,
                                                arg3: *mut *mut m_snd_tag)
                               -> ::kernel::sys::raw::c_int>;
pub type if_snd_tag_modify_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut m_snd_tag,
                                                arg2:
                                                    *mut if_snd_tag_modify_params)
                               -> ::kernel::sys::raw::c_int>;
pub type if_snd_tag_query_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut m_snd_tag,
                                                arg2:
                                                    *mut if_snd_tag_query_params)
                               -> ::kernel::sys::raw::c_int>;
pub type if_snd_tag_free_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut m_snd_tag)>;
extern "C" {
    pub fn if_addr_rlock(ifp: *mut ifnet);
}
extern "C" {
    pub fn if_addr_runlock(ifp: *mut ifnet);
}
extern "C" {
    pub fn if_maddr_rlock(ifp: if_t);
}
extern "C" {
    pub fn if_maddr_runlock(ifp: if_t);
}
pub type iflladdr_event_handler_t =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut ifnet)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_iflladdr_event {
    pub ee: eventhandler_entry,
    pub eh_func: iflladdr_event_handler_t,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_iflladdr_event() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_iflladdr_event>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_iflladdr_event )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_iflladdr_event>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_iflladdr_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_iflladdr_event ) ) .
                ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_iflladdr_event ) , "::" , stringify ! ( ee
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_iflladdr_event ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_iflladdr_event ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_iflladdr_event {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_iflladdr_event {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type ifaddr_event_handler_t =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut ifnet)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_ifaddr_event {
    pub ee: eventhandler_entry,
    pub eh_func: ifaddr_event_handler_t,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_ifaddr_event() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_ifaddr_event>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_ifaddr_event )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_ifaddr_event>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_ifaddr_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_ifaddr_event ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_ifaddr_event ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_ifaddr_event ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_ifaddr_event ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_ifaddr_event {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_ifaddr_event {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type ifnet_arrival_event_handler_t =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut ifnet)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_ifnet_arrival_event {
    pub ee: eventhandler_entry,
    pub eh_func: ifnet_arrival_event_handler_t,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_ifnet_arrival_event() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_ifnet_arrival_event>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_ifnet_arrival_event ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_ifnet_arrival_event>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_ifnet_arrival_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_ifnet_arrival_event )
                ) . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_ifnet_arrival_event ) , "::" , stringify !
                ( ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_ifnet_arrival_event )
                ) . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_ifnet_arrival_event ) , "::" , stringify !
                ( eh_func ) ));
}
impl Clone for eventhandler_entry_ifnet_arrival_event {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_ifnet_arrival_event {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type ifnet_departure_event_handler_t =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut ifnet)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_ifnet_departure_event {
    pub ee: eventhandler_entry,
    pub eh_func: ifnet_departure_event_handler_t,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_ifnet_departure_event() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_ifnet_departure_event>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_ifnet_departure_event ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_ifnet_departure_event>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_ifnet_departure_event ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const eventhandler_entry_ifnet_departure_event ) )
                . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_ifnet_departure_event ) , "::" , stringify
                ! ( ee ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const eventhandler_entry_ifnet_departure_event ) )
                . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_ifnet_departure_event ) , "::" , stringify
                ! ( eh_func ) ));
}
impl Clone for eventhandler_entry_ifnet_departure_event {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_ifnet_departure_event {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type ifnet_link_event_handler_t =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut ifnet,
                                                arg3:
                                                    ::kernel::sys::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_ifnet_link_event {
    pub ee: eventhandler_entry,
    pub eh_func: ifnet_link_event_handler_t,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_ifnet_link_event() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_ifnet_link_event>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_ifnet_link_event
               ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_ifnet_link_event>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_ifnet_link_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_ifnet_link_event ) ) .
                ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_ifnet_link_event ) , "::" , stringify ! (
                ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_ifnet_link_event ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_ifnet_link_event ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_ifnet_link_event {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_ifnet_link_event {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type ifnet_event_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                ifp: *mut ifnet,
                                                event:
                                                    ::kernel::sys::raw::c_int)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_ifnet_event {
    pub ee: eventhandler_entry,
    pub eh_func: ifnet_event_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_ifnet_event() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_ifnet_event>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_ifnet_event )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_ifnet_event>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_ifnet_event
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_ifnet_event ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_ifnet_event ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_ifnet_event ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_ifnet_event ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_ifnet_event {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_ifnet_event {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifg_group {
    pub ifg_group: [::kernel::sys::raw::c_char; 16usize],
    pub ifg_refcnt: u_int,
    pub ifg_pf_kif: *mut ::kernel::sys::raw::c_void,
    pub ifg_members: ifg_group__bindgen_ty_1,
    pub ifg_next: ifg_group__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifg_group__bindgen_ty_1 {
    pub cstqh_first: *mut ifg_member,
    pub cstqh_last: *mut *mut ifg_member,
}
#[test]
fn bindgen_test_layout_ifg_group__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<ifg_group__bindgen_ty_1>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( ifg_group__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<ifg_group__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( ifg_group__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifg_group__bindgen_ty_1 ) ) . cstqh_first
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifg_group__bindgen_ty_1
                ) , "::" , stringify ! ( cstqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifg_group__bindgen_ty_1 ) ) . cstqh_last
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifg_group__bindgen_ty_1
                ) , "::" , stringify ! ( cstqh_last ) ));
}
impl Clone for ifg_group__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for ifg_group__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifg_group__bindgen_ty_2 {
    pub cstqe_next: *mut ifg_group,
}
#[test]
fn bindgen_test_layout_ifg_group__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<ifg_group__bindgen_ty_2>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( ifg_group__bindgen_ty_2 ) ));
    assert_eq! (::core::mem::align_of::<ifg_group__bindgen_ty_2>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( ifg_group__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifg_group__bindgen_ty_2 ) ) . cstqe_next
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifg_group__bindgen_ty_2
                ) , "::" , stringify ! ( cstqe_next ) ));
}
impl Clone for ifg_group__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for ifg_group__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_ifg_group() {
    assert_eq!(::core::mem::size_of::<ifg_group>() , 56usize , concat ! (
               "Size of: " , stringify ! ( ifg_group ) ));
    assert_eq! (::core::mem::align_of::<ifg_group>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ifg_group ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifg_group ) ) . ifg_group as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifg_group ) , "::" ,
                stringify ! ( ifg_group ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifg_group ) ) . ifg_refcnt as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ifg_group ) , "::" ,
                stringify ! ( ifg_refcnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifg_group ) ) . ifg_pf_kif as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ifg_group ) , "::" ,
                stringify ! ( ifg_pf_kif ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifg_group ) ) . ifg_members as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( ifg_group ) , "::" ,
                stringify ! ( ifg_members ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifg_group ) ) . ifg_next as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( ifg_group ) , "::" ,
                stringify ! ( ifg_next ) ));
}
impl Clone for ifg_group {
    fn clone(&self) -> Self { *self }
}
impl Default for ifg_group {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifg_member {
    pub ifgm_next: ifg_member__bindgen_ty_1,
    pub ifgm_ifp: *mut ifnet,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifg_member__bindgen_ty_1 {
    pub cstqe_next: *mut ifg_member,
}
#[test]
fn bindgen_test_layout_ifg_member__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<ifg_member__bindgen_ty_1>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( ifg_member__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<ifg_member__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( ifg_member__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifg_member__bindgen_ty_1 ) ) . cstqe_next
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                ifg_member__bindgen_ty_1 ) , "::" , stringify ! ( cstqe_next )
                ));
}
impl Clone for ifg_member__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for ifg_member__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_ifg_member() {
    assert_eq!(::core::mem::size_of::<ifg_member>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ifg_member ) ));
    assert_eq! (::core::mem::align_of::<ifg_member>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ifg_member ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifg_member ) ) . ifgm_next as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifg_member ) , "::" ,
                stringify ! ( ifgm_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifg_member ) ) . ifgm_ifp as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifg_member ) , "::" ,
                stringify ! ( ifgm_ifp ) ));
}
impl Clone for ifg_member {
    fn clone(&self) -> Self { *self }
}
impl Default for ifg_member {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifg_list {
    pub ifgl_group: *mut ifg_group,
    pub ifgl_next: ifg_list__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifg_list__bindgen_ty_1 {
    pub cstqe_next: *mut ifg_list,
}
#[test]
fn bindgen_test_layout_ifg_list__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<ifg_list__bindgen_ty_1>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( ifg_list__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<ifg_list__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( ifg_list__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifg_list__bindgen_ty_1 ) ) . cstqe_next
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifg_list__bindgen_ty_1
                ) , "::" , stringify ! ( cstqe_next ) ));
}
impl Clone for ifg_list__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for ifg_list__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_ifg_list() {
    assert_eq!(::core::mem::size_of::<ifg_list>() , 16usize , concat ! (
               "Size of: " , stringify ! ( ifg_list ) ));
    assert_eq! (::core::mem::align_of::<ifg_list>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ifg_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifg_list ) ) . ifgl_group as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifg_list ) , "::" ,
                stringify ! ( ifgl_group ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifg_list ) ) . ifgl_next as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifg_list ) , "::" ,
                stringify ! ( ifgl_next ) ));
}
impl Clone for ifg_list {
    fn clone(&self) -> Self { *self }
}
impl Default for ifg_list {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type group_attach_event_handler_t =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut ifg_group)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_group_attach_event {
    pub ee: eventhandler_entry,
    pub eh_func: group_attach_event_handler_t,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_group_attach_event() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_group_attach_event>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_group_attach_event ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_group_attach_event>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_group_attach_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_group_attach_event ) )
                . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_group_attach_event ) , "::" , stringify ! (
                ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_group_attach_event ) )
                . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_group_attach_event ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_group_attach_event {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_group_attach_event {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type group_detach_event_handler_t =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut ifg_group)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_group_detach_event {
    pub ee: eventhandler_entry,
    pub eh_func: group_detach_event_handler_t,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_group_detach_event() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_group_detach_event>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_group_detach_event ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_group_detach_event>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_group_detach_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_group_detach_event ) )
                . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_group_detach_event ) , "::" , stringify ! (
                ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_group_detach_event ) )
                . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_group_detach_event ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_group_detach_event {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_group_detach_event {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type group_change_event_handler_t =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2:
                                                    *const ::kernel::sys::raw::c_char)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_group_change_event {
    pub ee: eventhandler_entry,
    pub eh_func: group_change_event_handler_t,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_group_change_event() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_group_change_event>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_group_change_event ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_group_change_event>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_group_change_event ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_group_change_event ) )
                . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_group_change_event ) , "::" , stringify ! (
                ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_group_change_event ) )
                . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_group_change_event ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_group_change_event {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_group_change_event {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifaddr {
    pub ifa_addr: *mut sockaddr,
    pub ifa_dstaddr: *mut sockaddr,
    pub ifa_netmask: *mut sockaddr,
    pub ifa_ifp: *mut ifnet,
    pub ifa_carp: *mut carp_softc,
    pub ifa_link: ifaddr__bindgen_ty_1,
    pub ifa_rtrequest: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                       ::kernel::sys::raw::c_int,
                                                                   arg2:
                                                                       *mut rtentry,
                                                                   arg3:
                                                                       *mut rt_addrinfo)>,
    pub ifa_flags: u_short,
    pub ifa_refcnt: u_int,
    pub ifa_ipackets: counter_u64_t,
    pub ifa_opackets: counter_u64_t,
    pub ifa_ibytes: counter_u64_t,
    pub ifa_obytes: counter_u64_t,
    pub ifa_epoch_ctx: epoch_context,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifaddr__bindgen_ty_1 {
    pub cstqe_next: *mut ifaddr,
}
#[test]
fn bindgen_test_layout_ifaddr__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<ifaddr__bindgen_ty_1>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( ifaddr__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<ifaddr__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( ifaddr__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaddr__bindgen_ty_1 ) ) . cstqe_next as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaddr__bindgen_ty_1 )
                , "::" , stringify ! ( cstqe_next ) ));
}
impl Clone for ifaddr__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for ifaddr__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_ifaddr() {
    assert_eq!(::core::mem::size_of::<ifaddr>() , 112usize , concat ! (
               "Size of: " , stringify ! ( ifaddr ) ));
    assert_eq! (::core::mem::align_of::<ifaddr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ifaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaddr ) ) . ifa_addr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaddr ) , "::" ,
                stringify ! ( ifa_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaddr ) ) . ifa_dstaddr as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaddr ) , "::" ,
                stringify ! ( ifa_dstaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaddr ) ) . ifa_netmask as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaddr ) , "::" ,
                stringify ! ( ifa_netmask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaddr ) ) . ifa_ifp as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaddr ) , "::" ,
                stringify ! ( ifa_ifp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaddr ) ) . ifa_carp as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaddr ) , "::" ,
                stringify ! ( ifa_carp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaddr ) ) . ifa_link as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaddr ) , "::" ,
                stringify ! ( ifa_link ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaddr ) ) . ifa_rtrequest as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaddr ) , "::" ,
                stringify ! ( ifa_rtrequest ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaddr ) ) . ifa_flags as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaddr ) , "::" ,
                stringify ! ( ifa_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaddr ) ) . ifa_refcnt as * const _ as
                usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaddr ) , "::" ,
                stringify ! ( ifa_refcnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaddr ) ) . ifa_ipackets as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaddr ) , "::" ,
                stringify ! ( ifa_ipackets ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaddr ) ) . ifa_opackets as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaddr ) , "::" ,
                stringify ! ( ifa_opackets ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaddr ) ) . ifa_ibytes as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaddr ) , "::" ,
                stringify ! ( ifa_ibytes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaddr ) ) . ifa_obytes as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaddr ) , "::" ,
                stringify ! ( ifa_obytes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifaddr ) ) . ifa_epoch_ctx as * const _
                as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( ifaddr ) , "::" ,
                stringify ! ( ifa_epoch_ctx ) ));
}
impl Clone for ifaddr {
    fn clone(&self) -> Self { *self }
}
impl Default for ifaddr {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    pub fn ifa_alloc(size: usize, flags: ::kernel::sys::raw::c_int)
     -> *mut ifaddr;
}
extern "C" {
    pub fn ifa_free(ifa: *mut ifaddr);
}
extern "C" {
    pub fn ifa_ref(ifa: *mut ifaddr);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifmultiaddr {
    pub ifma_link: ifmultiaddr__bindgen_ty_1,
    pub ifma_addr: *mut sockaddr,
    pub ifma_lladdr: *mut sockaddr,
    pub ifma_ifp: *mut ifnet,
    pub ifma_refcount: u_int,
    pub ifma_protospec: *mut ::kernel::sys::raw::c_void,
    pub ifma_llifma: *mut ifmultiaddr,
    pub ifma_epoch_ctx: epoch_context,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifmultiaddr__bindgen_ty_1 {
    pub cstqe_next: *mut ifmultiaddr,
}
#[test]
fn bindgen_test_layout_ifmultiaddr__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<ifmultiaddr__bindgen_ty_1>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( ifmultiaddr__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<ifmultiaddr__bindgen_ty_1>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( ifmultiaddr__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmultiaddr__bindgen_ty_1 ) ) .
                cstqe_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                ifmultiaddr__bindgen_ty_1 ) , "::" , stringify ! ( cstqe_next
                ) ));
}
impl Clone for ifmultiaddr__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for ifmultiaddr__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_ifmultiaddr() {
    assert_eq!(::core::mem::size_of::<ifmultiaddr>() , 72usize , concat ! (
               "Size of: " , stringify ! ( ifmultiaddr ) ));
    assert_eq! (::core::mem::align_of::<ifmultiaddr>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ifmultiaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmultiaddr ) ) . ifma_link as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmultiaddr ) , "::" ,
                stringify ! ( ifma_link ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmultiaddr ) ) . ifma_addr as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmultiaddr ) , "::" ,
                stringify ! ( ifma_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmultiaddr ) ) . ifma_lladdr as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmultiaddr ) , "::" ,
                stringify ! ( ifma_lladdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmultiaddr ) ) . ifma_ifp as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmultiaddr ) , "::" ,
                stringify ! ( ifma_ifp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmultiaddr ) ) . ifma_refcount as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmultiaddr ) , "::" ,
                stringify ! ( ifma_refcount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmultiaddr ) ) . ifma_protospec as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmultiaddr ) , "::" ,
                stringify ! ( ifma_protospec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmultiaddr ) ) . ifma_llifma as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmultiaddr ) , "::" ,
                stringify ! ( ifma_llifma ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmultiaddr ) ) . ifma_epoch_ctx as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmultiaddr ) , "::" ,
                stringify ! ( ifma_epoch_ctx ) ));
}
impl Clone for ifmultiaddr {
    fn clone(&self) -> Self { *self }
}
impl Default for ifmultiaddr {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    #[link_name = "ifnet_rwlock"]
    pub static mut ifnet_rwlock: rwlock;
}
extern "C" {
    #[link_name = "ifnet_sxlock"]
    pub static mut ifnet_sxlock: sx;
}
extern "C" {
    pub fn ifnet_byindex(idx: u_short) -> *mut ifnet;
}
extern "C" {
    pub fn ifnet_byindex_locked(idx: u_short) -> *mut ifnet;
}
extern "C" {
    pub fn ifnet_byindex_ref(idx: u_short) -> *mut ifnet;
}
extern "C" {
    pub fn ifaddr_byindex(idx: u_short) -> *mut ifaddr;
}
extern "C" {
    #[link_name = "ifnet"]
    pub static mut ifnet: ifnethead;
}
extern "C" {
    #[link_name = "ifg_head"]
    pub static mut ifg_head: ifgrouphead;
}
extern "C" {
    #[link_name = "if_index"]
    pub static mut if_index: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "loif"]
    pub static mut loif: *mut ifnet;
}
extern "C" {
    pub fn if_addgroup(arg1: *mut ifnet,
                       arg2: *const ::kernel::sys::raw::c_char)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_delgroup(arg1: *mut ifnet,
                       arg2: *const ::kernel::sys::raw::c_char)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_addmulti(arg1: *mut ifnet, arg2: *mut sockaddr,
                       arg3: *mut *mut ifmultiaddr)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_allmulti(arg1: *mut ifnet, arg2: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_alloc(arg1: u_char) -> *mut ifnet;
}
extern "C" {
    pub fn if_attach(arg1: *mut ifnet);
}
extern "C" {
    pub fn if_dead(arg1: *mut ifnet);
}
extern "C" {
    pub fn if_delmulti(arg1: *mut ifnet, arg2: *mut sockaddr)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_delmulti_ifma(arg1: *mut ifmultiaddr);
}
extern "C" {
    pub fn if_delmulti_ifma_flags(arg1: *mut ifmultiaddr,
                                  flags: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn if_detach(arg1: *mut ifnet);
}
extern "C" {
    pub fn if_purgeaddrs(arg1: *mut ifnet);
}
extern "C" {
    pub fn if_delallmulti(arg1: *mut ifnet);
}
extern "C" {
    pub fn if_down(arg1: *mut ifnet);
}
extern "C" {
    pub fn if_findmulti(arg1: *mut ifnet, arg2: *const sockaddr)
     -> *mut ifmultiaddr;
}
extern "C" {
    pub fn if_freemulti(ifma: *mut ifmultiaddr);
}
extern "C" {
    pub fn if_free(arg1: *mut ifnet);
}
extern "C" {
    pub fn if_initname(arg1: *mut ifnet,
                       arg2: *const ::kernel::sys::raw::c_char,
                       arg3: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn if_link_state_change(arg1: *mut ifnet,
                                arg2: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn if_printf(arg1: *mut ifnet,
                     arg2: *const ::kernel::sys::raw::c_char, ...)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_ref(arg1: *mut ifnet);
}
extern "C" {
    pub fn if_rele(arg1: *mut ifnet);
}
extern "C" {
    pub fn if_setlladdr(arg1: *mut ifnet, arg2: *const u_char,
                        arg3: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_up(arg1: *mut ifnet);
}
extern "C" {
    pub fn ifioctl(arg1: *mut socket, arg2: u_long, arg3: caddr_t,
                   arg4: *mut thread) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn ifpromisc(arg1: *mut ifnet, arg2: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn ifunit(arg1: *const ::kernel::sys::raw::c_char) -> *mut ifnet;
}
extern "C" {
    pub fn ifunit_ref(arg1: *const ::kernel::sys::raw::c_char) -> *mut ifnet;
}
extern "C" {
    pub fn ifa_add_loopback_route(arg1: *mut ifaddr, arg2: *mut sockaddr)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn ifa_del_loopback_route(arg1: *mut ifaddr, arg2: *mut sockaddr)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn ifa_switch_loopback_route(arg1: *mut ifaddr, arg2: *mut sockaddr)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn ifa_ifwithaddr(arg1: *const sockaddr) -> *mut ifaddr;
}
extern "C" {
    pub fn ifa_ifwithaddr_check(arg1: *const sockaddr)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn ifa_ifwithbroadaddr(arg1: *const sockaddr,
                               arg2: ::kernel::sys::raw::c_int)
     -> *mut ifaddr;
}
extern "C" {
    pub fn ifa_ifwithdstaddr(arg1: *const sockaddr,
                             arg2: ::kernel::sys::raw::c_int) -> *mut ifaddr;
}
extern "C" {
    pub fn ifa_ifwithnet(arg1: *const sockaddr,
                         arg2: ::kernel::sys::raw::c_int,
                         arg3: ::kernel::sys::raw::c_int) -> *mut ifaddr;
}
extern "C" {
    pub fn ifa_ifwithroute(arg1: ::kernel::sys::raw::c_int,
                           arg2: *const sockaddr, arg3: *mut sockaddr,
                           arg4: u_int) -> *mut ifaddr;
}
extern "C" {
    pub fn ifaof_ifpforaddr(arg1: *const sockaddr, arg2: *mut ifnet)
     -> *mut ifaddr;
}
extern "C" {
    pub fn ifa_preferred(arg1: *mut ifaddr, arg2: *mut ifaddr)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_simloop(ifp: *mut ifnet, m: *mut mbuf,
                      af: ::kernel::sys::raw::c_int,
                      hlen: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
pub type if_com_alloc_t =
    ::core::option::Option<unsafe extern "C" fn(type_: u_char,
                                                ifp: *mut ifnet)
                               -> *mut ::kernel::sys::raw::c_void>;
pub type if_com_free_t =
    ::core::option::Option<unsafe extern "C" fn(com:
                                                    *mut ::kernel::sys::raw::c_void,
                                                type_: u_char)>;
extern "C" {
    pub fn if_register_com_alloc(type_: u_char, a: if_com_alloc_t,
                                 f: if_com_free_t);
}
extern "C" {
    pub fn if_deregister_com_alloc(type_: u_char);
}
extern "C" {
    pub fn if_data_copy(arg1: *mut ifnet, arg2: *mut if_data);
}
extern "C" {
    pub fn if_get_counter_default(arg1: *mut ifnet, arg2: ift_counter) -> u64;
}
extern "C" {
    pub fn if_inc_counter(arg1: *mut ifnet, arg2: ift_counter, arg3: i64);
}
extern "C" {
    pub fn if_setbaudrate(ifp: if_t, baudrate: u64) -> u64;
}
extern "C" {
    pub fn if_getbaudrate(ifp: if_t) -> u64;
}
extern "C" {
    pub fn if_setcapabilities(ifp: if_t,
                              capabilities: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_setcapabilitiesbit(ifp: if_t, setbit: ::kernel::sys::raw::c_int,
                                 clearbit: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_getcapabilities(ifp: if_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_togglecapenable(ifp: if_t, togglecap: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_setcapenable(ifp: if_t, capenable: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_setcapenablebit(ifp: if_t, setcap: ::kernel::sys::raw::c_int,
                              clearcap: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_getcapenable(ifp: if_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_getdname(ifp: if_t) -> *const ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn if_setdev(ifp: if_t, dev: *mut ::kernel::sys::raw::c_void)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_setdrvflagbits(ifp: if_t,
                             if_setflags: ::kernel::sys::raw::c_int,
                             clear_flags: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_getdrvflags(ifp: if_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_setdrvflags(ifp: if_t, flags: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_clearhwassist(ifp: if_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_sethwassistbits(ifp: if_t, toset: ::kernel::sys::raw::c_int,
                              toclear: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_sethwassist(ifp: if_t, hwassist_bit: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_gethwassist(ifp: if_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_setsoftc(ifp: if_t, softc: *mut ::kernel::sys::raw::c_void)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_getsoftc(ifp: if_t) -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn if_setflags(ifp: if_t, flags: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_gethwaddr(ifp: if_t, arg1: *mut ifreq)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_setmtu(ifp: if_t, mtu: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_getmtu(ifp: if_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_getmtu_family(ifp: if_t, family: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_setflagbits(ifp: if_t, set: ::kernel::sys::raw::c_int,
                          clear: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_getflags(ifp: if_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_sendq_empty(ifp: if_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_setsendqready(ifp: if_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_setsendqlen(ifp: if_t, tx_desc_count: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_sethwtsomax(ifp: if_t, if_hw_tsomax: u_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_sethwtsomaxsegcount(ifp: if_t, if_hw_tsomaxsegcount: u_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_sethwtsomaxsegsize(ifp: if_t, if_hw_tsomaxsegsize: u_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_gethwtsomax(ifp: if_t) -> u_int;
}
extern "C" {
    pub fn if_gethwtsomaxsegcount(ifp: if_t) -> u_int;
}
extern "C" {
    pub fn if_gethwtsomaxsegsize(ifp: if_t) -> u_int;
}
extern "C" {
    pub fn if_input(ifp: if_t, sendmp: *mut mbuf)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_sendq_prepend(ifp: if_t, m: *mut mbuf)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_dequeue(ifp: if_t) -> *mut mbuf;
}
extern "C" {
    pub fn if_setifheaderlen(ifp: if_t, len: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_setrcvif(m: *mut mbuf, ifp: if_t);
}
extern "C" {
    pub fn if_setvtag(m: *mut mbuf, tag: u_int16_t);
}
extern "C" {
    pub fn if_getvtag(m: *mut mbuf) -> u_int16_t;
}
extern "C" {
    pub fn if_vlantrunkinuse(ifp: if_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_getlladdr(ifp: if_t) -> caddr_t;
}
extern "C" {
    pub fn if_gethandle(arg1: u_char) -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn if_bpfmtap(ifp: if_t, m: *mut mbuf);
}
extern "C" {
    pub fn if_etherbpfmtap(ifp: if_t, m: *mut mbuf);
}
extern "C" {
    pub fn if_vlancap(ifp: if_t);
}
extern "C" {
    pub fn if_setupmultiaddr(ifp: if_t, mta: *mut ::kernel::sys::raw::c_void,
                             cnt: *mut ::kernel::sys::raw::c_int,
                             max: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_multiaddr_array(ifp: if_t, mta: *mut ::kernel::sys::raw::c_void,
                              cnt: *mut ::kernel::sys::raw::c_int,
                              max: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_multiaddr_count(ifp: if_t, max: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_multi_apply(ifp: *mut ifnet,
                          filter:
                              ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                              *mut ::kernel::sys::raw::c_void,
                                                                          arg2:
                                                                              *mut ifmultiaddr,
                                                                          arg3:
                                                                              ::kernel::sys::raw::c_int)
                                                         ->
                                                             ::kernel::sys::raw::c_int>,
                          arg: *mut ::kernel::sys::raw::c_void)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_getamcount(ifp: if_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_getifaddr(ifp: if_t) -> *mut ifaddr;
}
extern "C" {
    pub fn if_setinitfn(ifp: if_t,
                        arg1:
                            ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                            *mut ::kernel::sys::raw::c_void)>);
}
extern "C" {
    pub fn if_setioctlfn(ifp: if_t,
                         arg1:
                             ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                             if_t,
                                                                         arg2:
                                                                             u_long,
                                                                         arg3:
                                                                             caddr_t)
                                                        ->
                                                            ::kernel::sys::raw::c_int>);
}
extern "C" {
    pub fn if_setstartfn(ifp: if_t,
                         arg1:
                             ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                             if_t)>);
}
extern "C" {
    pub fn if_settransmitfn(ifp: if_t, arg1: if_transmit_fn_t);
}
extern "C" {
    pub fn if_setqflushfn(ifp: if_t, arg1: if_qflush_fn_t);
}
extern "C" {
    pub fn if_setgetcounterfn(ifp: if_t, arg1: if_get_counter_t);
}
extern "C" {
    pub fn drbr_inuse_drv(ifp: if_t, br: *mut buf_ring)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn drbr_dequeue_drv(ifp: if_t, br: *mut buf_ring) -> *mut mbuf;
}
extern "C" {
    pub fn drbr_needs_enqueue_drv(ifp: if_t, br: *mut buf_ring)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn drbr_enqueue_drv(ifp: if_t, br: *mut buf_ring, m: *mut mbuf)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_hw_tsomax_common(ifp: if_t, arg1: *mut ifnet_hw_tsomax);
}
extern "C" {
    pub fn if_hw_tsomax_update(ifp: if_t, arg1: *mut ifnet_hw_tsomax)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn ifr_data_get_ptr(ifrp: *mut ::kernel::sys::raw::c_void)
     -> *mut ::kernel::sys::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifqueue {
    pub ifq_head: *mut mbuf,
    pub ifq_tail: *mut mbuf,
    pub ifq_len: ::kernel::sys::raw::c_int,
    pub ifq_maxlen: ::kernel::sys::raw::c_int,
    pub ifq_mtx: mtx,
}
#[test]
fn bindgen_test_layout_ifqueue() {
    assert_eq!(::core::mem::size_of::<ifqueue>() , 56usize , concat ! (
               "Size of: " , stringify ! ( ifqueue ) ));
    assert_eq! (::core::mem::align_of::<ifqueue>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ifqueue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifqueue ) ) . ifq_head as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifqueue ) , "::" ,
                stringify ! ( ifq_head ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifqueue ) ) . ifq_tail as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifqueue ) , "::" ,
                stringify ! ( ifq_tail ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifqueue ) ) . ifq_len as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ifqueue ) , "::" ,
                stringify ! ( ifq_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifqueue ) ) . ifq_maxlen as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( ifqueue ) , "::" ,
                stringify ! ( ifq_maxlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifqueue ) ) . ifq_mtx as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ifqueue ) , "::" ,
                stringify ! ( ifq_mtx ) ));
}
impl Clone for ifqueue {
    fn clone(&self) -> Self { *self }
}
impl Default for ifqueue {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    pub fn if_handoff(ifq: *mut ifqueue, m: *mut mbuf, ifp: *mut ifnet,
                      adjust: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_start(arg1: *mut ifnet);
}
extern "C" {
    #[link_name = "ifqmaxlen"]
    pub static mut ifqmaxlen: ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn if_qflush(arg1: *mut ifnet);
}
extern "C" {
    pub fn ifq_init(arg1: *mut ifaltq, ifp: *mut ifnet);
}
extern "C" {
    pub fn ifq_delete(arg1: *mut ifaltq);
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct arphdr {
    pub ar_hrd: u_short,
    pub ar_pro: u_short,
    pub ar_hln: u_char,
    pub ar_pln: u_char,
    pub ar_op: u_short,
}
#[test]
fn bindgen_test_layout_arphdr() {
    assert_eq!(::core::mem::size_of::<arphdr>() , 8usize , concat ! (
               "Size of: " , stringify ! ( arphdr ) ));
    assert_eq! (::core::mem::align_of::<arphdr>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( arphdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const arphdr ) ) . ar_hrd as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( arphdr ) , "::" ,
                stringify ! ( ar_hrd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const arphdr ) ) . ar_pro as * const _ as usize
                } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( arphdr ) , "::" ,
                stringify ! ( ar_pro ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const arphdr ) ) . ar_hln as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( arphdr ) , "::" ,
                stringify ! ( ar_hln ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const arphdr ) ) . ar_pln as * const _ as usize
                } , 5usize , concat ! (
                "Alignment of field: " , stringify ! ( arphdr ) , "::" ,
                stringify ! ( ar_pln ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const arphdr ) ) . ar_op as * const _ as usize
                } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( arphdr ) , "::" ,
                stringify ! ( ar_op ) ));
}
impl Clone for arphdr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct arpreq {
    pub arp_pa: sockaddr,
    pub arp_ha: sockaddr,
    pub arp_flags: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_arpreq() {
    assert_eq!(::core::mem::size_of::<arpreq>() , 36usize , concat ! (
               "Size of: " , stringify ! ( arpreq ) ));
    assert_eq! (::core::mem::align_of::<arpreq>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( arpreq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const arpreq ) ) . arp_pa as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( arpreq ) , "::" ,
                stringify ! ( arp_pa ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const arpreq ) ) . arp_ha as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( arpreq ) , "::" ,
                stringify ! ( arp_ha ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const arpreq ) ) . arp_flags as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( arpreq ) , "::" ,
                stringify ! ( arp_flags ) ));
}
impl Clone for arpreq {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct arpstat {
    pub txrequests: u64,
    pub txreplies: u64,
    pub rxrequests: u64,
    pub rxreplies: u64,
    pub received: u64,
    pub arp_spares: [u64; 4usize],
    pub dropped: u64,
    pub timeouts: u64,
    pub dupips: u64,
}
#[test]
fn bindgen_test_layout_arpstat() {
    assert_eq!(::core::mem::size_of::<arpstat>() , 96usize , concat ! (
               "Size of: " , stringify ! ( arpstat ) ));
    assert_eq! (::core::mem::align_of::<arpstat>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( arpstat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const arpstat ) ) . txrequests as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( arpstat ) , "::" ,
                stringify ! ( txrequests ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const arpstat ) ) . txreplies as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( arpstat ) , "::" ,
                stringify ! ( txreplies ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const arpstat ) ) . rxrequests as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( arpstat ) , "::" ,
                stringify ! ( rxrequests ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const arpstat ) ) . rxreplies as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( arpstat ) , "::" ,
                stringify ! ( rxreplies ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const arpstat ) ) . received as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( arpstat ) , "::" ,
                stringify ! ( received ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const arpstat ) ) . arp_spares as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( arpstat ) , "::" ,
                stringify ! ( arp_spares ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const arpstat ) ) . dropped as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( arpstat ) , "::" ,
                stringify ! ( dropped ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const arpstat ) ) . timeouts as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( arpstat ) , "::" ,
                stringify ! ( timeouts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const arpstat ) ) . dupips as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( arpstat ) , "::" ,
                stringify ! ( dupips ) ));
}
impl Clone for arpstat {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "arpstat"]
    pub static mut arpstat: [counter_u64_t; 12usize];
}
#[repr(C)]
#[derive(Copy)]
pub struct sockaddr_dl {
    pub sdl_len: u_char,
    pub sdl_family: u_char,
    pub sdl_index: u_short,
    pub sdl_type: u_char,
    pub sdl_nlen: u_char,
    pub sdl_alen: u_char,
    pub sdl_slen: u_char,
    pub sdl_data: [::kernel::sys::raw::c_char; 46usize],
}
#[test]
fn bindgen_test_layout_sockaddr_dl() {
    assert_eq!(::core::mem::size_of::<sockaddr_dl>() , 54usize , concat ! (
               "Size of: " , stringify ! ( sockaddr_dl ) ));
    assert_eq! (::core::mem::align_of::<sockaddr_dl>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( sockaddr_dl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_dl ) ) . sdl_len as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_dl ) , "::" ,
                stringify ! ( sdl_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_dl ) ) . sdl_family as * const _
                as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_dl ) , "::" ,
                stringify ! ( sdl_family ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_dl ) ) . sdl_index as * const _
                as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_dl ) , "::" ,
                stringify ! ( sdl_index ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_dl ) ) . sdl_type as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_dl ) , "::" ,
                stringify ! ( sdl_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_dl ) ) . sdl_nlen as * const _
                as usize } , 5usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_dl ) , "::" ,
                stringify ! ( sdl_nlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_dl ) ) . sdl_alen as * const _
                as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_dl ) , "::" ,
                stringify ! ( sdl_alen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_dl ) ) . sdl_slen as * const _
                as usize } , 7usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_dl ) , "::" ,
                stringify ! ( sdl_slen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_dl ) ) . sdl_data as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_dl ) , "::" ,
                stringify ! ( sdl_data ) ));
}
impl Clone for sockaddr_dl {
    fn clone(&self) -> Self { *self }
}
impl Default for sockaddr_dl {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for sockaddr_dl {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "sockaddr_dl {{ sdl_len: {:?}, sdl_family: {:?}, sdl_index: {:?}, sdl_type: {:?}, sdl_nlen: {:?}, sdl_alen: {:?}, sdl_slen: {:?}, sdl_data: [{}] }}"
               , self . sdl_len , self . sdl_family , self . sdl_index , self
               . sdl_type , self . sdl_nlen , self . sdl_alen , self .
               sdl_slen , self . sdl_data . iter (  ) . enumerate (  ) . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ))
    }
}
extern "C" {
    pub fn link_alloc_sdl(arg1: usize, arg2: ::kernel::sys::raw::c_int)
     -> *mut sockaddr_dl;
}
extern "C" {
    pub fn link_free_sdl(sa: *mut sockaddr);
}
extern "C" {
    pub fn link_init_sdl(arg1: *mut ifnet, arg2: *mut sockaddr, arg3: u_char)
     -> *mut sockaddr_dl;
}
pub type ifm_change_cb_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ifnet)
                               -> ::kernel::sys::raw::c_int>;
pub type ifm_stat_cb_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut ifnet,
                                                req: *mut ifmediareq)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifmedia_entry {
    pub ifm_list: ifmedia_entry__bindgen_ty_1,
    pub ifm_media: ::kernel::sys::raw::c_int,
    pub ifm_data: ::kernel::sys::raw::c_int,
    pub ifm_aux: *mut ::kernel::sys::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifmedia_entry__bindgen_ty_1 {
    pub le_next: *mut ifmedia_entry,
    pub le_prev: *mut *mut ifmedia_entry,
}
#[test]
fn bindgen_test_layout_ifmedia_entry__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<ifmedia_entry__bindgen_ty_1>() , 16usize
               , concat ! (
               "Size of: " , stringify ! ( ifmedia_entry__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<ifmedia_entry__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( ifmedia_entry__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmedia_entry__bindgen_ty_1 ) ) . le_next
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                ifmedia_entry__bindgen_ty_1 ) , "::" , stringify ! ( le_next )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmedia_entry__bindgen_ty_1 ) ) . le_prev
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                ifmedia_entry__bindgen_ty_1 ) , "::" , stringify ! ( le_prev )
                ));
}
impl Clone for ifmedia_entry__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for ifmedia_entry__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_ifmedia_entry() {
    assert_eq!(::core::mem::size_of::<ifmedia_entry>() , 32usize , concat ! (
               "Size of: " , stringify ! ( ifmedia_entry ) ));
    assert_eq! (::core::mem::align_of::<ifmedia_entry>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( ifmedia_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmedia_entry ) ) . ifm_list as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmedia_entry ) , "::"
                , stringify ! ( ifm_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmedia_entry ) ) . ifm_media as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmedia_entry ) , "::"
                , stringify ! ( ifm_media ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmedia_entry ) ) . ifm_data as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmedia_entry ) , "::"
                , stringify ! ( ifm_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmedia_entry ) ) . ifm_aux as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmedia_entry ) , "::"
                , stringify ! ( ifm_aux ) ));
}
impl Clone for ifmedia_entry {
    fn clone(&self) -> Self { *self }
}
impl Default for ifmedia_entry {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    pub fn ifmedia_init(ifm: *mut ifmedia,
                        dontcare_mask: ::kernel::sys::raw::c_int,
                        change_callback: ifm_change_cb_t,
                        status_callback: ifm_stat_cb_t);
}
extern "C" {
    pub fn ifmedia_removeall(ifm: *mut ifmedia);
}
extern "C" {
    pub fn ifmedia_add(ifm: *mut ifmedia, mword: ::kernel::sys::raw::c_int,
                       data: ::kernel::sys::raw::c_int,
                       aux: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn ifmedia_list_add(mp: *mut ifmedia, lp: *mut ifmedia_entry,
                            count: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn ifmedia_set(ifm: *mut ifmedia, mword: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn ifmedia_ioctl(ifp: *mut ifnet, ifr: *mut ifreq, ifm: *mut ifmedia,
                         cmd: u_long) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn ifmedia_baudrate(arg1: ::kernel::sys::raw::c_int) -> u64;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifmedia_description {
    pub ifmt_word: ::kernel::sys::raw::c_int,
    pub ifmt_string: *const ::kernel::sys::raw::c_char,
}
#[test]
fn bindgen_test_layout_ifmedia_description() {
    assert_eq!(::core::mem::size_of::<ifmedia_description>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( ifmedia_description )
               ));
    assert_eq! (::core::mem::align_of::<ifmedia_description>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( ifmedia_description ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmedia_description ) ) . ifmt_word as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmedia_description ) ,
                "::" , stringify ! ( ifmt_word ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmedia_description ) ) . ifmt_string as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmedia_description ) ,
                "::" , stringify ! ( ifmt_string ) ));
}
impl Clone for ifmedia_description {
    fn clone(&self) -> Self { *self }
}
impl Default for ifmedia_description {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct ifmedia_baudrate {
    pub ifmb_word: ::kernel::sys::raw::c_int,
    pub ifmb_baudrate: u64,
}
#[test]
fn bindgen_test_layout_ifmedia_baudrate() {
    assert_eq!(::core::mem::size_of::<ifmedia_baudrate>() , 16usize , concat !
               ( "Size of: " , stringify ! ( ifmedia_baudrate ) ));
    assert_eq! (::core::mem::align_of::<ifmedia_baudrate>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( ifmedia_baudrate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmedia_baudrate ) ) . ifmb_word as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmedia_baudrate ) ,
                "::" , stringify ! ( ifmb_word ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmedia_baudrate ) ) . ifmb_baudrate as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ifmedia_baudrate ) ,
                "::" , stringify ! ( ifmb_baudrate ) ));
}
impl Clone for ifmedia_baudrate {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ifmedia_status_description {
    pub ifms_type: ::kernel::sys::raw::c_int,
    pub ifms_valid: ::kernel::sys::raw::c_int,
    pub ifms_bit: ::kernel::sys::raw::c_int,
    pub ifms_string: [*const ::kernel::sys::raw::c_char; 2usize],
}
#[test]
fn bindgen_test_layout_ifmedia_status_description() {
    assert_eq!(::core::mem::size_of::<ifmedia_status_description>() , 32usize
               , concat ! (
               "Size of: " , stringify ! ( ifmedia_status_description ) ));
    assert_eq! (::core::mem::align_of::<ifmedia_status_description>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( ifmedia_status_description )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmedia_status_description ) ) .
                ifms_type as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                ifmedia_status_description ) , "::" , stringify ! ( ifms_type
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmedia_status_description ) ) .
                ifms_valid as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                ifmedia_status_description ) , "::" , stringify ! ( ifms_valid
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmedia_status_description ) ) . ifms_bit
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                ifmedia_status_description ) , "::" , stringify ! ( ifms_bit )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ifmedia_status_description ) ) .
                ifms_string as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                ifmedia_status_description ) , "::" , stringify ! (
                ifms_string ) ));
}
impl Clone for ifmedia_status_description {
    fn clone(&self) -> Self { *self }
}
impl Default for ifmedia_status_description {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvlist {
    _unused: [u8; 0],
}
pub type nvlist_t = nvlist;
extern "C" {
    #[link_name = "M_NVLIST"]
    pub static mut M_NVLIST: [malloc_type; 1usize];
}
extern "C" {
    pub fn nvlist_create(flags: ::kernel::sys::raw::c_int) -> *mut nvlist_t;
}
extern "C" {
    pub fn nvlist_destroy(nvl: *mut nvlist_t);
}
extern "C" {
    pub fn nvlist_error(nvl: *const nvlist_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn nvlist_empty(nvl: *const nvlist_t) -> bool_;
}
extern "C" {
    pub fn nvlist_flags(nvl: *const nvlist_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn nvlist_set_error(nvl: *mut nvlist_t,
                            error: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn nvlist_clone(nvl: *const nvlist_t) -> *mut nvlist_t;
}
extern "C" {
    pub fn nvlist_size(nvl: *const nvlist_t) -> usize;
}
extern "C" {
    pub fn nvlist_pack(nvl: *const nvlist_t, sizep: *mut usize)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn nvlist_unpack(buf: *const ::kernel::sys::raw::c_void, size: usize,
                         flags: ::kernel::sys::raw::c_int) -> *mut nvlist_t;
}
extern "C" {
    pub fn nvlist_send(sock: ::kernel::sys::raw::c_int, nvl: *const nvlist_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn nvlist_recv(sock: ::kernel::sys::raw::c_int,
                       flags: ::kernel::sys::raw::c_int) -> *mut nvlist_t;
}
extern "C" {
    pub fn nvlist_xfer(sock: ::kernel::sys::raw::c_int, nvl: *mut nvlist_t,
                       flags: ::kernel::sys::raw::c_int) -> *mut nvlist_t;
}
extern "C" {
    pub fn nvlist_next(nvl: *const nvlist_t,
                       typep: *mut ::kernel::sys::raw::c_int,
                       cookiep: *mut *mut ::kernel::sys::raw::c_void)
     -> *const ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn nvlist_get_parent(nvl: *const nvlist_t,
                             cookiep: *mut *mut ::kernel::sys::raw::c_void)
     -> *const nvlist_t;
}
extern "C" {
    pub fn nvlist_get_array_next(nvl: *const nvlist_t) -> *const nvlist_t;
}
extern "C" {
    pub fn nvlist_in_array(nvl: *const nvlist_t) -> bool_;
}
extern "C" {
    pub fn nvlist_get_pararr(nvl: *const nvlist_t,
                             cookiep: *mut *mut ::kernel::sys::raw::c_void)
     -> *const nvlist_t;
}
extern "C" {
    pub fn nvlist_exists(nvl: *const nvlist_t,
                         name: *const ::kernel::sys::raw::c_char) -> bool_;
}
extern "C" {
    pub fn nvlist_exists_type(nvl: *const nvlist_t,
                              name: *const ::kernel::sys::raw::c_char,
                              type_: ::kernel::sys::raw::c_int) -> bool_;
}
extern "C" {
    pub fn nvlist_exists_null(nvl: *const nvlist_t,
                              name: *const ::kernel::sys::raw::c_char)
     -> bool_;
}
extern "C" {
    pub fn nvlist_exists_bool(nvl: *const nvlist_t,
                              name: *const ::kernel::sys::raw::c_char)
     -> bool_;
}
extern "C" {
    pub fn nvlist_exists_number(nvl: *const nvlist_t,
                                name: *const ::kernel::sys::raw::c_char)
     -> bool_;
}
extern "C" {
    pub fn nvlist_exists_string(nvl: *const nvlist_t,
                                name: *const ::kernel::sys::raw::c_char)
     -> bool_;
}
extern "C" {
    pub fn nvlist_exists_nvlist(nvl: *const nvlist_t,
                                name: *const ::kernel::sys::raw::c_char)
     -> bool_;
}
extern "C" {
    pub fn nvlist_exists_binary(nvl: *const nvlist_t,
                                name: *const ::kernel::sys::raw::c_char)
     -> bool_;
}
extern "C" {
    pub fn nvlist_exists_bool_array(nvl: *const nvlist_t,
                                    name: *const ::kernel::sys::raw::c_char)
     -> bool_;
}
extern "C" {
    pub fn nvlist_exists_number_array(nvl: *const nvlist_t,
                                      name: *const ::kernel::sys::raw::c_char)
     -> bool_;
}
extern "C" {
    pub fn nvlist_exists_string_array(nvl: *const nvlist_t,
                                      name: *const ::kernel::sys::raw::c_char)
     -> bool_;
}
extern "C" {
    pub fn nvlist_exists_nvlist_array(nvl: *const nvlist_t,
                                      name: *const ::kernel::sys::raw::c_char)
     -> bool_;
}
extern "C" {
    pub fn nvlist_add_null(nvl: *mut nvlist_t,
                           name: *const ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn nvlist_add_bool(nvl: *mut nvlist_t,
                           name: *const ::kernel::sys::raw::c_char,
                           value: bool_);
}
extern "C" {
    pub fn nvlist_add_number(nvl: *mut nvlist_t,
                             name: *const ::kernel::sys::raw::c_char,
                             value: u64);
}
extern "C" {
    pub fn nvlist_add_string(nvl: *mut nvlist_t,
                             name: *const ::kernel::sys::raw::c_char,
                             value: *const ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn nvlist_add_stringf(nvl: *mut nvlist_t,
                              name: *const ::kernel::sys::raw::c_char,
                              valuefmt:
                                  *const ::kernel::sys::raw::c_char, ...);
}
extern "C" {
    pub fn nvlist_add_nvlist(nvl: *mut nvlist_t,
                             name: *const ::kernel::sys::raw::c_char,
                             value: *const nvlist_t);
}
extern "C" {
    pub fn nvlist_add_binary(nvl: *mut nvlist_t,
                             name: *const ::kernel::sys::raw::c_char,
                             value: *const ::kernel::sys::raw::c_void,
                             size: usize);
}
extern "C" {
    pub fn nvlist_add_bool_array(nvl: *mut nvlist_t,
                                 name: *const ::kernel::sys::raw::c_char,
                                 value: *const bool_, nitems: usize);
}
extern "C" {
    pub fn nvlist_add_number_array(nvl: *mut nvlist_t,
                                   name: *const ::kernel::sys::raw::c_char,
                                   value: *const u64, nitems: usize);
}
extern "C" {
    pub fn nvlist_add_string_array(nvl: *mut nvlist_t,
                                   name: *const ::kernel::sys::raw::c_char,
                                   value:
                                       *const *const ::kernel::sys::raw::c_char,
                                   nitems: usize);
}
extern "C" {
    pub fn nvlist_add_nvlist_array(nvl: *mut nvlist_t,
                                   name: *const ::kernel::sys::raw::c_char,
                                   value: *const *const nvlist_t,
                                   nitems: usize);
}
extern "C" {
    pub fn nvlist_move_string(nvl: *mut nvlist_t,
                              name: *const ::kernel::sys::raw::c_char,
                              value: *mut ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn nvlist_move_nvlist(nvl: *mut nvlist_t,
                              name: *const ::kernel::sys::raw::c_char,
                              value: *mut nvlist_t);
}
extern "C" {
    pub fn nvlist_move_binary(nvl: *mut nvlist_t,
                              name: *const ::kernel::sys::raw::c_char,
                              value: *mut ::kernel::sys::raw::c_void,
                              size: usize);
}
extern "C" {
    pub fn nvlist_move_bool_array(nvl: *mut nvlist_t,
                                  name: *const ::kernel::sys::raw::c_char,
                                  value: *mut bool_, nitems: usize);
}
extern "C" {
    pub fn nvlist_move_string_array(nvl: *mut nvlist_t,
                                    name: *const ::kernel::sys::raw::c_char,
                                    value:
                                        *mut *mut ::kernel::sys::raw::c_char,
                                    nitems: usize);
}
extern "C" {
    pub fn nvlist_move_nvlist_array(nvl: *mut nvlist_t,
                                    name: *const ::kernel::sys::raw::c_char,
                                    value: *mut *mut nvlist_t, nitems: usize);
}
extern "C" {
    pub fn nvlist_move_number_array(nvl: *mut nvlist_t,
                                    name: *const ::kernel::sys::raw::c_char,
                                    value: *mut u64, nitems: usize);
}
extern "C" {
    pub fn nvlist_get_bool(nvl: *const nvlist_t,
                           name: *const ::kernel::sys::raw::c_char) -> bool_;
}
extern "C" {
    pub fn nvlist_get_number(nvl: *const nvlist_t,
                             name: *const ::kernel::sys::raw::c_char) -> u64;
}
extern "C" {
    pub fn nvlist_get_string(nvl: *const nvlist_t,
                             name: *const ::kernel::sys::raw::c_char)
     -> *const ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn nvlist_get_nvlist(nvl: *const nvlist_t,
                             name: *const ::kernel::sys::raw::c_char)
     -> *const nvlist_t;
}
extern "C" {
    pub fn nvlist_get_binary(nvl: *const nvlist_t,
                             name: *const ::kernel::sys::raw::c_char,
                             sizep: *mut usize)
     -> *const ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn nvlist_get_bool_array(nvl: *const nvlist_t,
                                 name: *const ::kernel::sys::raw::c_char,
                                 nitemsp: *mut usize) -> *const bool_;
}
extern "C" {
    pub fn nvlist_get_number_array(nvl: *const nvlist_t,
                                   name: *const ::kernel::sys::raw::c_char,
                                   nitemsp: *mut usize) -> *const u64;
}
extern "C" {
    pub fn nvlist_get_string_array(nvl: *const nvlist_t,
                                   name: *const ::kernel::sys::raw::c_char,
                                   nitemsp: *mut usize)
     -> *const *const ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn nvlist_get_nvlist_array(nvl: *const nvlist_t,
                                   name: *const ::kernel::sys::raw::c_char,
                                   nitemsp: *mut usize)
     -> *const *const nvlist_t;
}
extern "C" {
    pub fn nvlist_take_bool(nvl: *mut nvlist_t,
                            name: *const ::kernel::sys::raw::c_char) -> bool_;
}
extern "C" {
    pub fn nvlist_take_number(nvl: *mut nvlist_t,
                              name: *const ::kernel::sys::raw::c_char) -> u64;
}
extern "C" {
    pub fn nvlist_take_string(nvl: *mut nvlist_t,
                              name: *const ::kernel::sys::raw::c_char)
     -> *mut ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn nvlist_take_nvlist(nvl: *mut nvlist_t,
                              name: *const ::kernel::sys::raw::c_char)
     -> *mut nvlist_t;
}
extern "C" {
    pub fn nvlist_take_binary(nvl: *mut nvlist_t,
                              name: *const ::kernel::sys::raw::c_char,
                              sizep: *mut usize)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn nvlist_take_bool_array(nvl: *mut nvlist_t,
                                  name: *const ::kernel::sys::raw::c_char,
                                  nitemsp: *mut usize) -> *mut bool_;
}
extern "C" {
    pub fn nvlist_take_number_array(nvl: *mut nvlist_t,
                                    name: *const ::kernel::sys::raw::c_char,
                                    nitemsp: *mut usize) -> *mut u64;
}
extern "C" {
    pub fn nvlist_take_string_array(nvl: *mut nvlist_t,
                                    name: *const ::kernel::sys::raw::c_char,
                                    nitemsp: *mut usize)
     -> *mut *mut ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn nvlist_take_nvlist_array(nvl: *mut nvlist_t,
                                    name: *const ::kernel::sys::raw::c_char,
                                    nitemsp: *mut usize)
     -> *mut *mut nvlist_t;
}
extern "C" {
    pub fn nvlist_free(nvl: *mut nvlist_t,
                       name: *const ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn nvlist_free_type(nvl: *mut nvlist_t,
                            name: *const ::kernel::sys::raw::c_char,
                            type_: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn nvlist_free_null(nvl: *mut nvlist_t,
                            name: *const ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn nvlist_free_bool(nvl: *mut nvlist_t,
                            name: *const ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn nvlist_free_number(nvl: *mut nvlist_t,
                              name: *const ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn nvlist_free_string(nvl: *mut nvlist_t,
                              name: *const ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn nvlist_free_nvlist(nvl: *mut nvlist_t,
                              name: *const ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn nvlist_free_binary(nvl: *mut nvlist_t,
                              name: *const ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn nvlist_free_bool_array(nvl: *mut nvlist_t,
                                  name: *const ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn nvlist_free_number_array(nvl: *mut nvlist_t,
                                    name: *const ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn nvlist_free_string_array(nvl: *mut nvlist_t,
                                    name: *const ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn nvlist_free_nvlist_array(nvl: *mut nvlist_t,
                                    name: *const ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn nvlist_free_binary_array(nvl: *mut nvlist_t,
                                    name: *const ::kernel::sys::raw::c_char);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gtaskqueue {
    _unused: [u8; 0],
}
pub type gtaskqueue_enqueue_fn =
    ::core::option::Option<unsafe extern "C" fn(context:
                                                    *mut ::kernel::sys::raw::c_void)>;
extern "C" {
    pub fn gtaskqueue_block(queue: *mut gtaskqueue);
}
extern "C" {
    pub fn gtaskqueue_unblock(queue: *mut gtaskqueue);
}
extern "C" {
    pub fn gtaskqueue_cancel(queue: *mut gtaskqueue, gtask: *mut gtask)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn gtaskqueue_drain(queue: *mut gtaskqueue, task: *mut gtask);
}
extern "C" {
    pub fn gtaskqueue_drain_all(queue: *mut gtaskqueue);
}
extern "C" {
    pub fn grouptaskqueue_enqueue(queue: *mut gtaskqueue, task: *mut gtask)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn taskqgroup_attach(qgroup: *mut taskqgroup, grptask: *mut grouptask,
                             uniq: *mut ::kernel::sys::raw::c_void,
                             irq: ::kernel::sys::raw::c_int,
                             name: *const ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn taskqgroup_attach_cpu(qgroup: *mut taskqgroup,
                                 grptask: *mut grouptask,
                                 uniq: *mut ::kernel::sys::raw::c_void,
                                 cpu: ::kernel::sys::raw::c_int,
                                 irq: ::kernel::sys::raw::c_int,
                                 name: *mut ::kernel::sys::raw::c_char)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn taskqgroup_detach(qgroup: *mut taskqgroup, gtask: *mut grouptask);
}
extern "C" {
    pub fn taskqgroup_create(name: *mut ::kernel::sys::raw::c_char)
     -> *mut taskqgroup;
}
extern "C" {
    pub fn taskqgroup_destroy(qgroup: *mut taskqgroup);
}
extern "C" {
    pub fn taskqgroup_adjust(qgroup: *mut taskqgroup,
                             cnt: ::kernel::sys::raw::c_int,
                             stride: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn taskqgroup_config_gtask_init(ctx: *mut ::kernel::sys::raw::c_void,
                                        gtask: *mut grouptask,
                                        fn_: gtask_fn_t,
                                        name:
                                            *const ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn taskqgroup_config_gtask_deinit(gtask: *mut grouptask);
}
extern "C" {
    #[link_name = "qgroup_net"]
    pub static mut qgroup_net: *mut taskqgroup;
}
extern "C" {
    #[link_name = "qgroup_softirq"]
    pub static mut qgroup_softirq: *mut taskqgroup;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct if_clone {
    _unused: [u8; 0],
}
pub type qidx_t = u16;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iflib_ctx {
    _unused: [u8; 0],
}
pub type if_ctx_t = *mut iflib_ctx;
#[repr(C)]
#[derive(Copy)]
pub struct if_shared_ctx {
    pub isc_magic: ::kernel::sys::raw::c_uint,
    pub isc_driver: *mut driver_t,
    pub isc_q_align: bus_size_t,
    pub isc_tx_maxsize: bus_size_t,
    pub isc_tx_maxsegsize: bus_size_t,
    pub isc_rx_maxsize: bus_size_t,
    pub isc_rx_maxsegsize: bus_size_t,
    pub isc_rx_nsegments: ::kernel::sys::raw::c_int,
    pub isc_admin_intrcnt: ::kernel::sys::raw::c_int,
    pub isc_vendor_info: *mut pci_vendor_info_t,
    pub isc_driver_version: *mut ::kernel::sys::raw::c_char,
    pub isc_parse_devinfo: ::core::option::Option<unsafe extern "C" fn(device_id:
                                                                           *mut u16,
                                                                       subvendor_id:
                                                                           *mut u16,
                                                                       subdevice_id:
                                                                           *mut u16,
                                                                       rev_id:
                                                                           *mut u16)>,
    pub isc_nrxd_min: [::kernel::sys::raw::c_int; 8usize],
    pub isc_nrxd_default: [::kernel::sys::raw::c_int; 8usize],
    pub isc_nrxd_max: [::kernel::sys::raw::c_int; 8usize],
    pub isc_ntxd_min: [::kernel::sys::raw::c_int; 8usize],
    pub isc_ntxd_default: [::kernel::sys::raw::c_int; 8usize],
    pub isc_ntxd_max: [::kernel::sys::raw::c_int; 8usize],
    pub __bindgen_padding_0: [u32; 10usize],
    pub isc_nfl: ::kernel::sys::raw::c_int,
    pub isc_ntxqs: ::kernel::sys::raw::c_int,
    pub isc_nrxqs: ::kernel::sys::raw::c_int,
    pub isc_rx_process_limit: ::kernel::sys::raw::c_int,
    pub isc_tx_reclaim_thresh: ::kernel::sys::raw::c_int,
    pub isc_flags: ::kernel::sys::raw::c_int,
    pub isc_name: *const ::kernel::sys::raw::c_char,
    pub __bindgen_padding_1: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_if_shared_ctx() {
    assert_eq!(::core::mem::size_of::<if_shared_ctx>() , 384usize , concat ! (
               "Size of: " , stringify ! ( if_shared_ctx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_magic as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_magic ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_driver as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_driver ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_q_align as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_q_align ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_tx_maxsize as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_tx_maxsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_tx_maxsegsize as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_tx_maxsegsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_rx_maxsize as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_rx_maxsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_rx_maxsegsize as
                * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_rx_maxsegsize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_rx_nsegments as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_rx_nsegments ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_admin_intrcnt as
                * const _ as usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_admin_intrcnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_vendor_info as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_vendor_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_driver_version as
                * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_driver_version ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_parse_devinfo as
                * const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_parse_devinfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_nrxd_min as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_nrxd_min ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_nrxd_default as *
                const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_nrxd_default ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_nrxd_max as *
                const _ as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_nrxd_max ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_ntxd_min as *
                const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_ntxd_min ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_ntxd_default as *
                const _ as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_ntxd_default ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_ntxd_max as *
                const _ as usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_ntxd_max ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_nfl as * const _
                as usize } , 320usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_nfl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_ntxqs as * const
                _ as usize } , 324usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_ntxqs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_nrxqs as * const
                _ as usize } , 328usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_nrxqs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_rx_process_limit
                as * const _ as usize } , 332usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_rx_process_limit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_tx_reclaim_thresh
                as * const _ as usize } , 336usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_tx_reclaim_thresh ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_flags as * const
                _ as usize } , 340usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_shared_ctx ) ) . isc_name as * const _
                as usize } , 344usize , concat ! (
                "Alignment of field: " , stringify ! ( if_shared_ctx ) , "::"
                , stringify ! ( isc_name ) ));
}
impl Clone for if_shared_ctx {
    fn clone(&self) -> Self { *self }
}
impl Default for if_shared_ctx {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for if_shared_ctx {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "if_shared_ctx {{ isc_magic: {:?}, isc_driver: {:?}, isc_q_align: {:?}, isc_tx_maxsize: {:?}, isc_tx_maxsegsize: {:?}, isc_rx_maxsize: {:?}, isc_rx_maxsegsize: {:?}, isc_rx_nsegments: {:?}, isc_admin_intrcnt: {:?}, isc_vendor_info: {:?}, isc_driver_version: {:?}, isc_parse_devinfo: {:?}, isc_nrxd_min: {:?}, isc_nrxd_default: {:?}, isc_nrxd_max: {:?}, isc_ntxd_min: {:?}, isc_ntxd_default: {:?}, isc_ntxd_max: {:?}, isc_nfl: {:?}, isc_ntxqs: {:?}, isc_nrxqs: {:?}, isc_rx_process_limit: {:?}, isc_tx_reclaim_thresh: {:?}, isc_flags: {:?}, isc_name: {:?} }}"
               , self . isc_magic , self . isc_driver , self . isc_q_align ,
               self . isc_tx_maxsize , self . isc_tx_maxsegsize , self .
               isc_rx_maxsize , self . isc_rx_maxsegsize , self .
               isc_rx_nsegments , self . isc_admin_intrcnt , self .
               isc_vendor_info , self . isc_driver_version , self .
               isc_parse_devinfo , self . isc_nrxd_min , self .
               isc_nrxd_default , self . isc_nrxd_max , self . isc_ntxd_min ,
               self . isc_ntxd_default , self . isc_ntxd_max , self . isc_nfl
               , self . isc_ntxqs , self . isc_nrxqs , self .
               isc_rx_process_limit , self . isc_tx_reclaim_thresh , self .
               isc_flags , self . isc_name)
    }
}
pub type if_shared_ctx_t = *mut if_shared_ctx;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct if_int_delay_info {
    pub iidi_ctx: if_ctx_t,
    pub iidi_offset: ::kernel::sys::raw::c_int,
    pub iidi_value: ::kernel::sys::raw::c_int,
    pub iidi_oidp: *mut sysctl_oid,
    pub iidi_req: *mut sysctl_req,
}
#[test]
fn bindgen_test_layout_if_int_delay_info() {
    assert_eq!(::core::mem::size_of::<if_int_delay_info>() , 32usize , concat
               ! ( "Size of: " , stringify ! ( if_int_delay_info ) ));
    assert_eq! (::core::mem::align_of::<if_int_delay_info>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( if_int_delay_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_int_delay_info ) ) . iidi_ctx as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_int_delay_info ) ,
                "::" , stringify ! ( iidi_ctx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_int_delay_info ) ) . iidi_offset as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( if_int_delay_info ) ,
                "::" , stringify ! ( iidi_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_int_delay_info ) ) . iidi_value as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( if_int_delay_info ) ,
                "::" , stringify ! ( iidi_value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_int_delay_info ) ) . iidi_oidp as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( if_int_delay_info ) ,
                "::" , stringify ! ( iidi_oidp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_int_delay_info ) ) . iidi_req as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( if_int_delay_info ) ,
                "::" , stringify ! ( iidi_req ) ));
}
impl Clone for if_int_delay_info {
    fn clone(&self) -> Self { *self }
}
impl Default for if_int_delay_info {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type if_int_delay_info_t = *mut if_int_delay_info;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct if_pseudo {
    _unused: [u8; 0],
}
pub type if_pseudo_t = *mut if_pseudo;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct if_rxd_frag {
    pub irf_flid: u8,
    pub irf_idx: qidx_t,
    pub irf_len: u16,
}
#[test]
fn bindgen_test_layout_if_rxd_frag() {
    assert_eq!(::core::mem::size_of::<if_rxd_frag>() , 6usize , concat ! (
               "Size of: " , stringify ! ( if_rxd_frag ) ));
    assert_eq! (::core::mem::align_of::<if_rxd_frag>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( if_rxd_frag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_frag ) ) . irf_flid as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_frag ) , "::" ,
                stringify ! ( irf_flid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_frag ) ) . irf_idx as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_frag ) , "::" ,
                stringify ! ( irf_idx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_frag ) ) . irf_len as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_frag ) , "::" ,
                stringify ! ( irf_len ) ));
}
impl Clone for if_rxd_frag {
    fn clone(&self) -> Self { *self }
}
pub type if_rxd_frag_t = *mut if_rxd_frag;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct if_rxd_info {
    pub iri_qsidx: u16,
    pub iri_vtag: u16,
    pub iri_len: u16,
    pub iri_cidx: qidx_t,
    pub iri_ifp: *mut ifnet,
    pub iri_frags: if_rxd_frag_t,
    pub iri_flowid: u32,
    pub iri_csum_flags: u32,
    pub iri_csum_data: u32,
    pub iri_flags: u8,
    pub iri_nfrags: u8,
    pub iri_rsstype: u8,
    pub iri_pad: u8,
}
#[test]
fn bindgen_test_layout_if_rxd_info() {
    assert_eq!(::core::mem::size_of::<if_rxd_info>() , 40usize , concat ! (
               "Size of: " , stringify ! ( if_rxd_info ) ));
    assert_eq! (::core::mem::align_of::<if_rxd_info>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( if_rxd_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_info ) ) . iri_qsidx as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_info ) , "::" ,
                stringify ! ( iri_qsidx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_info ) ) . iri_vtag as * const _
                as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_info ) , "::" ,
                stringify ! ( iri_vtag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_info ) ) . iri_len as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_info ) , "::" ,
                stringify ! ( iri_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_info ) ) . iri_cidx as * const _
                as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_info ) , "::" ,
                stringify ! ( iri_cidx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_info ) ) . iri_ifp as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_info ) , "::" ,
                stringify ! ( iri_ifp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_info ) ) . iri_frags as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_info ) , "::" ,
                stringify ! ( iri_frags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_info ) ) . iri_flowid as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_info ) , "::" ,
                stringify ! ( iri_flowid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_info ) ) . iri_csum_flags as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_info ) , "::" ,
                stringify ! ( iri_csum_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_info ) ) . iri_csum_data as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_info ) , "::" ,
                stringify ! ( iri_csum_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_info ) ) . iri_flags as * const _
                as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_info ) , "::" ,
                stringify ! ( iri_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_info ) ) . iri_nfrags as * const _
                as usize } , 37usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_info ) , "::" ,
                stringify ! ( iri_nfrags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_info ) ) . iri_rsstype as * const
                _ as usize } , 38usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_info ) , "::" ,
                stringify ! ( iri_rsstype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_info ) ) . iri_pad as * const _ as
                usize } , 39usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_info ) , "::" ,
                stringify ! ( iri_pad ) ));
}
impl Clone for if_rxd_info {
    fn clone(&self) -> Self { *self }
}
impl Default for if_rxd_info {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type if_rxd_info_t = *mut if_rxd_info;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct if_rxd_update {
    pub iru_paddrs: *mut u64,
    pub iru_vaddrs: *mut caddr_t,
    pub iru_idxs: *mut qidx_t,
    pub iru_pidx: qidx_t,
    pub iru_qsidx: u16,
    pub iru_count: u16,
    pub iru_buf_size: u16,
    pub iru_flidx: u8,
}
#[test]
fn bindgen_test_layout_if_rxd_update() {
    assert_eq!(::core::mem::size_of::<if_rxd_update>() , 40usize , concat ! (
               "Size of: " , stringify ! ( if_rxd_update ) ));
    assert_eq! (::core::mem::align_of::<if_rxd_update>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( if_rxd_update ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_update ) ) . iru_paddrs as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_update ) , "::"
                , stringify ! ( iru_paddrs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_update ) ) . iru_vaddrs as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_update ) , "::"
                , stringify ! ( iru_vaddrs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_update ) ) . iru_idxs as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_update ) , "::"
                , stringify ! ( iru_idxs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_update ) ) . iru_pidx as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_update ) , "::"
                , stringify ! ( iru_pidx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_update ) ) . iru_qsidx as * const
                _ as usize } , 26usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_update ) , "::"
                , stringify ! ( iru_qsidx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_update ) ) . iru_count as * const
                _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_update ) , "::"
                , stringify ! ( iru_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_update ) ) . iru_buf_size as *
                const _ as usize } , 30usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_update ) , "::"
                , stringify ! ( iru_buf_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_rxd_update ) ) . iru_flidx as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( if_rxd_update ) , "::"
                , stringify ! ( iru_flidx ) ));
}
impl Clone for if_rxd_update {
    fn clone(&self) -> Self { *self }
}
impl Default for if_rxd_update {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type if_rxd_update_t = *mut if_rxd_update;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct if_pkt_info {
    pub ipi_segs: *mut bus_dma_segment_t,
    pub ipi_len: u32,
    pub ipi_qsidx: u16,
    pub ipi_nsegs: qidx_t,
    pub ipi_ndescs: qidx_t,
    pub ipi_flags: u16,
    pub ipi_pidx: qidx_t,
    pub ipi_new_pidx: qidx_t,
    pub ipi_ehdrlen: u8,
    pub ipi_ip_hlen: u8,
    pub ipi_tcp_hlen: u8,
    pub ipi_ipproto: u8,
    pub ipi_csum_flags: u32,
    pub ipi_tso_segsz: u16,
    pub ipi_vtag: u16,
    pub ipi_etype: u16,
    pub ipi_tcp_hflags: u8,
    pub ipi_mflags: u8,
    pub ipi_tcp_seq: u32,
    pub ipi_tcp_sum: u32,
}
#[test]
fn bindgen_test_layout_if_pkt_info() {
    assert_eq!(::core::mem::size_of::<if_pkt_info>() , 48usize , concat ! (
               "Size of: " , stringify ! ( if_pkt_info ) ));
    assert_eq! (::core::mem::align_of::<if_pkt_info>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( if_pkt_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_pkt_info ) ) . ipi_segs as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_pkt_info ) , "::" ,
                stringify ! ( ipi_segs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_pkt_info ) ) . ipi_len as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( if_pkt_info ) , "::" ,
                stringify ! ( ipi_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_pkt_info ) ) . ipi_qsidx as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( if_pkt_info ) , "::" ,
                stringify ! ( ipi_qsidx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_pkt_info ) ) . ipi_nsegs as * const _
                as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( if_pkt_info ) , "::" ,
                stringify ! ( ipi_nsegs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_pkt_info ) ) . ipi_ndescs as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( if_pkt_info ) , "::" ,
                stringify ! ( ipi_ndescs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_pkt_info ) ) . ipi_flags as * const _
                as usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( if_pkt_info ) , "::" ,
                stringify ! ( ipi_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_pkt_info ) ) . ipi_pidx as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( if_pkt_info ) , "::" ,
                stringify ! ( ipi_pidx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_pkt_info ) ) . ipi_new_pidx as * const
                _ as usize } , 22usize , concat ! (
                "Alignment of field: " , stringify ! ( if_pkt_info ) , "::" ,
                stringify ! ( ipi_new_pidx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_pkt_info ) ) . ipi_ehdrlen as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( if_pkt_info ) , "::" ,
                stringify ! ( ipi_ehdrlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_pkt_info ) ) . ipi_ip_hlen as * const
                _ as usize } , 25usize , concat ! (
                "Alignment of field: " , stringify ! ( if_pkt_info ) , "::" ,
                stringify ! ( ipi_ip_hlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_pkt_info ) ) . ipi_tcp_hlen as * const
                _ as usize } , 26usize , concat ! (
                "Alignment of field: " , stringify ! ( if_pkt_info ) , "::" ,
                stringify ! ( ipi_tcp_hlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_pkt_info ) ) . ipi_ipproto as * const
                _ as usize } , 27usize , concat ! (
                "Alignment of field: " , stringify ! ( if_pkt_info ) , "::" ,
                stringify ! ( ipi_ipproto ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_pkt_info ) ) . ipi_csum_flags as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( if_pkt_info ) , "::" ,
                stringify ! ( ipi_csum_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_pkt_info ) ) . ipi_tso_segsz as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( if_pkt_info ) , "::" ,
                stringify ! ( ipi_tso_segsz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_pkt_info ) ) . ipi_vtag as * const _
                as usize } , 34usize , concat ! (
                "Alignment of field: " , stringify ! ( if_pkt_info ) , "::" ,
                stringify ! ( ipi_vtag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_pkt_info ) ) . ipi_etype as * const _
                as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( if_pkt_info ) , "::" ,
                stringify ! ( ipi_etype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_pkt_info ) ) . ipi_tcp_hflags as *
                const _ as usize } , 38usize , concat ! (
                "Alignment of field: " , stringify ! ( if_pkt_info ) , "::" ,
                stringify ! ( ipi_tcp_hflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_pkt_info ) ) . ipi_mflags as * const _
                as usize } , 39usize , concat ! (
                "Alignment of field: " , stringify ! ( if_pkt_info ) , "::" ,
                stringify ! ( ipi_mflags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_pkt_info ) ) . ipi_tcp_seq as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( if_pkt_info ) , "::" ,
                stringify ! ( ipi_tcp_seq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_pkt_info ) ) . ipi_tcp_sum as * const
                _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( if_pkt_info ) , "::" ,
                stringify ! ( ipi_tcp_sum ) ));
}
impl Clone for if_pkt_info {
    fn clone(&self) -> Self { *self }
}
impl Default for if_pkt_info {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type if_pkt_info_t = *mut if_pkt_info;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct if_irq {
    pub ii_res: *mut resource,
    pub ii_rid: ::kernel::sys::raw::c_int,
    pub ii_tag: *mut ::kernel::sys::raw::c_void,
}
#[test]
fn bindgen_test_layout_if_irq() {
    assert_eq!(::core::mem::size_of::<if_irq>() , 24usize , concat ! (
               "Size of: " , stringify ! ( if_irq ) ));
    assert_eq! (::core::mem::align_of::<if_irq>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( if_irq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_irq ) ) . ii_res as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_irq ) , "::" ,
                stringify ! ( ii_res ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_irq ) ) . ii_rid as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( if_irq ) , "::" ,
                stringify ! ( ii_rid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_irq ) ) . ii_tag as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( if_irq ) , "::" ,
                stringify ! ( ii_tag ) ));
}
impl Clone for if_irq {
    fn clone(&self) -> Self { *self }
}
impl Default for if_irq {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type if_irq_t = *mut if_irq;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum iflib_intr_mode_t {
    IFLIB_INTR_LEGACY = 0,
    IFLIB_INTR_MSI = 1,
    IFLIB_INTR_MSIX = 2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pci_vendor_info {
    pub pvi_vendor_id: u32,
    pub pvi_device_id: u32,
    pub pvi_subvendor_id: u32,
    pub pvi_subdevice_id: u32,
    pub pvi_rev_id: u32,
    pub pvi_class_mask: u32,
    pub pvi_name: caddr_t,
}
#[test]
fn bindgen_test_layout_pci_vendor_info() {
    assert_eq!(::core::mem::size_of::<pci_vendor_info>() , 32usize , concat !
               ( "Size of: " , stringify ! ( pci_vendor_info ) ));
    assert_eq! (::core::mem::align_of::<pci_vendor_info>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( pci_vendor_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_vendor_info ) ) . pvi_vendor_id as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pci_vendor_info ) ,
                "::" , stringify ! ( pvi_vendor_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_vendor_info ) ) . pvi_device_id as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( pci_vendor_info ) ,
                "::" , stringify ! ( pvi_device_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_vendor_info ) ) . pvi_subvendor_id as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pci_vendor_info ) ,
                "::" , stringify ! ( pvi_subvendor_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_vendor_info ) ) . pvi_subdevice_id as
                * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( pci_vendor_info ) ,
                "::" , stringify ! ( pvi_subdevice_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_vendor_info ) ) . pvi_rev_id as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( pci_vendor_info ) ,
                "::" , stringify ! ( pvi_rev_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_vendor_info ) ) . pvi_class_mask as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( pci_vendor_info ) ,
                "::" , stringify ! ( pvi_class_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_vendor_info ) ) . pvi_name as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( pci_vendor_info ) ,
                "::" , stringify ! ( pvi_name ) ));
}
impl Clone for pci_vendor_info {
    fn clone(&self) -> Self { *self }
}
impl Default for pci_vendor_info {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type pci_vendor_info_t = pci_vendor_info;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct if_txrx {
    pub ift_txd_encap: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                       *mut ::kernel::sys::raw::c_void,
                                                                   arg2:
                                                                       if_pkt_info_t)
                                                  ->
                                                      ::kernel::sys::raw::c_int>,
    pub ift_txd_flush: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                       *mut ::kernel::sys::raw::c_void,
                                                                   arg2: u16,
                                                                   pidx:
                                                                       qidx_t)>,
    pub ift_txd_credits_update: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                                *mut ::kernel::sys::raw::c_void,
                                                                            qsidx:
                                                                                u16,
                                                                            clear:
                                                                                bool_)
                                                           ->
                                                               ::kernel::sys::raw::c_int>,
    pub ift_rxd_available: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                           *mut ::kernel::sys::raw::c_void,
                                                                       qsidx:
                                                                           u16,
                                                                       pidx:
                                                                           qidx_t,
                                                                       budget:
                                                                           qidx_t)
                                                      ->
                                                          ::kernel::sys::raw::c_int>,
    pub ift_rxd_pkt_get: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                         *mut ::kernel::sys::raw::c_void,
                                                                     ri:
                                                                         if_rxd_info_t)
                                                    ->
                                                        ::kernel::sys::raw::c_int>,
    pub ift_rxd_refill: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                        *mut ::kernel::sys::raw::c_void,
                                                                    iru:
                                                                        if_rxd_update_t)>,
    pub ift_rxd_flush: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                       *mut ::kernel::sys::raw::c_void,
                                                                   qsidx: u16,
                                                                   flidx: u8,
                                                                   pidx:
                                                                       qidx_t)>,
    pub ift_legacy_intr: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                         *mut ::kernel::sys::raw::c_void)
                                                    ->
                                                        ::kernel::sys::raw::c_int>,
}
#[test]
fn bindgen_test_layout_if_txrx() {
    assert_eq!(::core::mem::size_of::<if_txrx>() , 64usize , concat ! (
               "Size of: " , stringify ! ( if_txrx ) ));
    assert_eq! (::core::mem::align_of::<if_txrx>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( if_txrx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_txrx ) ) . ift_txd_encap as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_txrx ) , "::" ,
                stringify ! ( ift_txd_encap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_txrx ) ) . ift_txd_flush as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( if_txrx ) , "::" ,
                stringify ! ( ift_txd_flush ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_txrx ) ) . ift_txd_credits_update as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( if_txrx ) , "::" ,
                stringify ! ( ift_txd_credits_update ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_txrx ) ) . ift_rxd_available as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( if_txrx ) , "::" ,
                stringify ! ( ift_rxd_available ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_txrx ) ) . ift_rxd_pkt_get as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( if_txrx ) , "::" ,
                stringify ! ( ift_rxd_pkt_get ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_txrx ) ) . ift_rxd_refill as * const _
                as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( if_txrx ) , "::" ,
                stringify ! ( ift_rxd_refill ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_txrx ) ) . ift_rxd_flush as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( if_txrx ) , "::" ,
                stringify ! ( ift_rxd_flush ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_txrx ) ) . ift_legacy_intr as * const
                _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( if_txrx ) , "::" ,
                stringify ! ( ift_legacy_intr ) ));
}
impl Clone for if_txrx {
    fn clone(&self) -> Self { *self }
}
impl Default for if_txrx {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type if_txrx_t = *mut if_txrx;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct if_softc_ctx {
    pub isc_vectors: ::kernel::sys::raw::c_int,
    pub isc_nrxqsets: ::kernel::sys::raw::c_int,
    pub isc_ntxqsets: ::kernel::sys::raw::c_int,
    pub isc_min_tx_latency: u8,
    pub isc_rx_mvec_enable: u8,
    pub isc_txrx_budget_bytes_max: u32,
    pub isc_msix_bar: ::kernel::sys::raw::c_int,
    pub isc_tx_nsegments: ::kernel::sys::raw::c_int,
    pub isc_ntxd: [::kernel::sys::raw::c_int; 8usize],
    pub isc_nrxd: [::kernel::sys::raw::c_int; 8usize],
    pub isc_txqsizes: [u32; 8usize],
    pub isc_rxqsizes: [u32; 8usize],
    pub isc_txd_size: [u8; 8usize],
    pub isc_rxd_size: [u8; 8usize],
    pub isc_tx_tso_segments_max: ::kernel::sys::raw::c_int,
    pub isc_tx_tso_size_max: ::kernel::sys::raw::c_int,
    pub isc_tx_tso_segsize_max: ::kernel::sys::raw::c_int,
    pub isc_tx_csum_flags: ::kernel::sys::raw::c_int,
    pub isc_capenable: ::kernel::sys::raw::c_int,
    pub isc_rss_table_size: ::kernel::sys::raw::c_int,
    pub isc_rss_table_mask: ::kernel::sys::raw::c_int,
    pub isc_nrxqsets_max: ::kernel::sys::raw::c_int,
    pub isc_ntxqsets_max: ::kernel::sys::raw::c_int,
    pub isc_tx_qdepth: u32,
    pub isc_intr: iflib_intr_mode_t,
    pub isc_max_frame_size: u16,
    pub isc_min_frame_size: u16,
    pub isc_pause_frames: u32,
    pub isc_vendor_info: pci_vendor_info_t,
    pub isc_disable_msix: ::kernel::sys::raw::c_int,
    pub isc_txrx: if_txrx_t,
}
#[test]
fn bindgen_test_layout_if_softc_ctx() {
    assert_eq!(::core::mem::size_of::<if_softc_ctx>() , 272usize , concat ! (
               "Size of: " , stringify ! ( if_softc_ctx ) ));
    assert_eq! (::core::mem::align_of::<if_softc_ctx>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( if_softc_ctx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_vectors as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_vectors ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_nrxqsets as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_nrxqsets ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_ntxqsets as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_ntxqsets ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_min_tx_latency as
                * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_min_tx_latency ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_rx_mvec_enable as
                * const _ as usize } , 13usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_rx_mvec_enable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) .
                isc_txrx_budget_bytes_max as * const _ as usize } , 16usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_txrx_budget_bytes_max ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_msix_bar as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_msix_bar ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_tx_nsegments as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_tx_nsegments ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_ntxd as * const _
                as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_ntxd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_nrxd as * const _
                as usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_nrxd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_txqsizes as *
                const _ as usize } , 92usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_txqsizes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_rxqsizes as *
                const _ as usize } , 124usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_rxqsizes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_txd_size as *
                const _ as usize } , 156usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_txd_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_rxd_size as *
                const _ as usize } , 164usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_rxd_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) .
                isc_tx_tso_segments_max as * const _ as usize } , 172usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_tx_tso_segments_max ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_tx_tso_size_max as
                * const _ as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_tx_tso_size_max ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_tx_tso_segsize_max
                as * const _ as usize } , 180usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_tx_tso_segsize_max ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_tx_csum_flags as *
                const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_tx_csum_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_capenable as *
                const _ as usize } , 188usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_capenable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_rss_table_size as
                * const _ as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_rss_table_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_rss_table_mask as
                * const _ as usize } , 196usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_rss_table_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_nrxqsets_max as *
                const _ as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_nrxqsets_max ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_ntxqsets_max as *
                const _ as usize } , 204usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_ntxqsets_max ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_tx_qdepth as *
                const _ as usize } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_tx_qdepth ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_intr as * const _
                as usize } , 212usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_intr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_max_frame_size as
                * const _ as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_max_frame_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_min_frame_size as
                * const _ as usize } , 218usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_min_frame_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_pause_frames as *
                const _ as usize } , 220usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_pause_frames ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_vendor_info as *
                const _ as usize } , 224usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_vendor_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_disable_msix as *
                const _ as usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_disable_msix ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const if_softc_ctx ) ) . isc_txrx as * const _
                as usize } , 264usize , concat ! (
                "Alignment of field: " , stringify ! ( if_softc_ctx ) , "::" ,
                stringify ! ( isc_txrx ) ));
}
impl Clone for if_softc_ctx {
    fn clone(&self) -> Self { *self }
}
impl Default for if_softc_ctx {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type if_softc_ctx_t = *mut if_softc_ctx;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct iflib_dma_info {
    pub idi_paddr: bus_addr_t,
    pub idi_vaddr: caddr_t,
    pub idi_tag: bus_dma_tag_t,
    pub idi_map: bus_dmamap_t,
    pub idi_size: u32,
}
#[test]
fn bindgen_test_layout_iflib_dma_info() {
    assert_eq!(::core::mem::size_of::<iflib_dma_info>() , 40usize , concat ! (
               "Size of: " , stringify ! ( iflib_dma_info ) ));
    assert_eq! (::core::mem::align_of::<iflib_dma_info>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( iflib_dma_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const iflib_dma_info ) ) . idi_paddr as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( iflib_dma_info ) , "::"
                , stringify ! ( idi_paddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const iflib_dma_info ) ) . idi_vaddr as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( iflib_dma_info ) , "::"
                , stringify ! ( idi_vaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const iflib_dma_info ) ) . idi_tag as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( iflib_dma_info ) , "::"
                , stringify ! ( idi_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const iflib_dma_info ) ) . idi_map as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( iflib_dma_info ) , "::"
                , stringify ! ( idi_map ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const iflib_dma_info ) ) . idi_size as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( iflib_dma_info ) , "::"
                , stringify ! ( idi_size ) ));
}
impl Clone for iflib_dma_info {
    fn clone(&self) -> Self { *self }
}
impl Default for iflib_dma_info {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type iflib_dma_info_t = *mut iflib_dma_info;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum iflib_intr_type_t {
    IFLIB_INTR_RX = 0,
    IFLIB_INTR_TX = 1,
    IFLIB_INTR_RXTX = 2,
    IFLIB_INTR_ADMIN = 3,
    IFLIB_INTR_IOV = 4,
}
extern "C" {
    pub fn iflib_get_softc(ctx: if_ctx_t) -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn iflib_get_dev(ctx: if_ctx_t) -> device_t;
}
extern "C" {
    pub fn iflib_get_ifp(ctx: if_ctx_t) -> if_t;
}
extern "C" {
    pub fn iflib_get_media(ctx: if_ctx_t) -> *mut ifmedia;
}
extern "C" {
    pub fn iflib_get_softc_ctx(ctx: if_ctx_t) -> if_softc_ctx_t;
}
extern "C" {
    pub fn iflib_get_sctx(ctx: if_ctx_t) -> if_shared_ctx_t;
}
extern "C" {
    pub fn iflib_set_mac(ctx: if_ctx_t, mac: *mut u8);
}
extern "C" {
    pub fn iflib_device_probe(arg1: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn iflib_device_attach(arg1: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn iflib_device_detach(arg1: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn iflib_device_suspend(arg1: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn iflib_device_resume(arg1: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn iflib_device_shutdown(arg1: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn iflib_device_iov_init(arg1: device_t, arg2: u16,
                                 arg3: *const nvlist_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn iflib_device_iov_uninit(arg1: device_t);
}
extern "C" {
    pub fn iflib_device_iov_add_vf(arg1: device_t, arg2: u16,
                                   arg3: *const nvlist_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn iflib_device_register(dev: device_t,
                                 softc: *mut ::kernel::sys::raw::c_void,
                                 sctx: if_shared_ctx_t, ctxp: *mut if_ctx_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn iflib_device_deregister(arg1: if_ctx_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn iflib_irq_alloc(arg1: if_ctx_t, arg2: if_irq_t,
                           arg3: ::kernel::sys::raw::c_int,
                           arg4: driver_filter_t,
                           filter_arg: *mut ::kernel::sys::raw::c_void,
                           arg5: driver_intr_t,
                           arg: *mut ::kernel::sys::raw::c_void,
                           name: *mut ::kernel::sys::raw::c_char)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn iflib_irq_alloc_generic(ctx: if_ctx_t, irq: if_irq_t,
                                   rid: ::kernel::sys::raw::c_int,
                                   type_: iflib_intr_type_t,
                                   filter: driver_filter_t,
                                   filter_arg:
                                       *mut ::kernel::sys::raw::c_void,
                                   qid: ::kernel::sys::raw::c_int,
                                   name: *mut ::kernel::sys::raw::c_char)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn iflib_softirq_alloc_generic(ctx: if_ctx_t, irq: if_irq_t,
                                       type_: iflib_intr_type_t,
                                       arg: *mut ::kernel::sys::raw::c_void,
                                       qid: ::kernel::sys::raw::c_int,
                                       name: *mut ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn iflib_irq_free(ctx: if_ctx_t, irq: if_irq_t);
}
extern "C" {
    pub fn iflib_io_tqg_attach(gt: *mut grouptask,
                               uniq: *mut ::kernel::sys::raw::c_void,
                               cpu: ::kernel::sys::raw::c_int,
                               name: *mut ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn iflib_config_gtask_init(ctx: *mut ::kernel::sys::raw::c_void,
                                   gtask: *mut grouptask, fn_: gtask_fn_t,
                                   name: *const ::kernel::sys::raw::c_char);
}
extern "C" {
    pub fn iflib_config_gtask_deinit(gtask: *mut grouptask);
}
extern "C" {
    pub fn iflib_tx_intr_deferred(ctx: if_ctx_t,
                                  txqid: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn iflib_rx_intr_deferred(ctx: if_ctx_t,
                                  rxqid: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn iflib_admin_intr_deferred(ctx: if_ctx_t);
}
extern "C" {
    pub fn iflib_iov_intr_deferred(ctx: if_ctx_t);
}
extern "C" {
    pub fn iflib_link_state_change(ctx: if_ctx_t,
                                   linkstate: ::kernel::sys::raw::c_int,
                                   baudrate: u64);
}
extern "C" {
    pub fn iflib_dma_alloc(ctx: if_ctx_t, size: ::kernel::sys::raw::c_int,
                           dma: iflib_dma_info_t,
                           mapflags: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn iflib_dma_free(dma: iflib_dma_info_t);
}
extern "C" {
    pub fn iflib_dma_alloc_multi(ctx: if_ctx_t,
                                 sizes: *mut ::kernel::sys::raw::c_int,
                                 dmalist: *mut iflib_dma_info_t,
                                 mapflags: ::kernel::sys::raw::c_int,
                                 count: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn iflib_dma_free_multi(dmalist: *mut iflib_dma_info_t,
                                count: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn iflib_ctx_lock_get(arg1: if_ctx_t) -> *mut sx;
}
extern "C" {
    pub fn iflib_qset_lock_get(arg1: if_ctx_t, arg2: u16) -> *mut mtx;
}
extern "C" {
    pub fn iflib_led_create(ctx: if_ctx_t);
}
extern "C" {
    pub fn iflib_add_int_delay_sysctl(arg1: if_ctx_t,
                                      arg2: *const ::kernel::sys::raw::c_char,
                                      arg3: *const ::kernel::sys::raw::c_char,
                                      arg4: if_int_delay_info_t,
                                      arg5: ::kernel::sys::raw::c_int,
                                      arg6: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn iflib_clone_register(arg1: if_shared_ctx_t) -> if_pseudo_t;
}
extern "C" {
    pub fn iflib_clone_deregister(arg1: if_pseudo_t);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum ifType {
    IFT_OTHER = 1,
    IFT_1822 = 2,
    IFT_HDH1822 = 3,
    IFT_X25DDN = 4,
    IFT_X25 = 5,
    IFT_ETHER = 6,
    IFT_ISO88023 = 7,
    IFT_ISO88024 = 8,
    IFT_ISO88025 = 9,
    IFT_ISO88026 = 10,
    IFT_STARLAN = 11,
    IFT_P10 = 12,
    IFT_P80 = 13,
    IFT_HY = 14,
    IFT_FDDI = 15,
    IFT_LAPB = 16,
    IFT_SDLC = 17,
    IFT_T1 = 18,
    IFT_CEPT = 19,
    IFT_ISDNBASIC = 20,
    IFT_ISDNPRIMARY = 21,
    IFT_PTPSERIAL = 22,
    IFT_PPP = 23,
    IFT_LOOP = 24,
    IFT_EON = 25,
    IFT_XETHER = 26,
    IFT_NSIP = 27,
    IFT_SLIP = 28,
    IFT_ULTRA = 29,
    IFT_DS3 = 30,
    IFT_SIP = 31,
    IFT_FRELAY = 32,
    IFT_RS232 = 33,
    IFT_PARA = 34,
    IFT_ARCNET = 35,
    IFT_ARCNETPLUS = 36,
    IFT_ATM = 37,
    IFT_MIOX25 = 38,
    IFT_SONET = 39,
    IFT_X25PLE = 40,
    IFT_ISO88022LLC = 41,
    IFT_LOCALTALK = 42,
    IFT_SMDSDXI = 43,
    IFT_FRELAYDCE = 44,
    IFT_V35 = 45,
    IFT_HSSI = 46,
    IFT_HIPPI = 47,
    IFT_MODEM = 48,
    IFT_AAL5 = 49,
    IFT_SONETPATH = 50,
    IFT_SONETVT = 51,
    IFT_SMDSICIP = 52,
    IFT_PROPVIRTUAL = 53,
    IFT_PROPMUX = 54,
    IFT_IEEE80212 = 55,
    IFT_FIBRECHANNEL = 56,
    IFT_HIPPIINTERFACE = 57,
    IFT_FRAMERELAYINTERCONNECT = 58,
    IFT_AFLANE8023 = 59,
    IFT_AFLANE8025 = 60,
    IFT_CCTEMUL = 61,
    IFT_FASTETHER = 62,
    IFT_ISDN = 63,
    IFT_V11 = 64,
    IFT_V36 = 65,
    IFT_G703AT64K = 66,
    IFT_G703AT2MB = 67,
    IFT_QLLC = 68,
    IFT_FASTETHERFX = 69,
    IFT_CHANNEL = 70,
    IFT_IEEE80211 = 71,
    IFT_IBM370PARCHAN = 72,
    IFT_ESCON = 73,
    IFT_DLSW = 74,
    IFT_ISDNS = 75,
    IFT_ISDNU = 76,
    IFT_LAPD = 77,
    IFT_IPSWITCH = 78,
    IFT_RSRB = 79,
    IFT_ATMLOGICAL = 80,
    IFT_DS0 = 81,
    IFT_DS0BUNDLE = 82,
    IFT_BSC = 83,
    IFT_ASYNC = 84,
    IFT_CNR = 85,
    IFT_ISO88025DTR = 86,
    IFT_EPLRS = 87,
    IFT_ARAP = 88,
    IFT_PROPCNLS = 89,
    IFT_HOSTPAD = 90,
    IFT_TERMPAD = 91,
    IFT_FRAMERELAYMPI = 92,
    IFT_X213 = 93,
    IFT_ADSL = 94,
    IFT_RADSL = 95,
    IFT_SDSL = 96,
    IFT_VDSL = 97,
    IFT_ISO88025CRFPINT = 98,
    IFT_MYRINET = 99,
    IFT_VOICEEM = 100,
    IFT_VOICEFXO = 101,
    IFT_VOICEFXS = 102,
    IFT_VOICEENCAP = 103,
    IFT_VOICEOVERIP = 104,
    IFT_ATMDXI = 105,
    IFT_ATMFUNI = 106,
    IFT_ATMIMA = 107,
    IFT_PPPMULTILINKBUNDLE = 108,
    IFT_IPOVERCDLC = 109,
    IFT_IPOVERCLAW = 110,
    IFT_STACKTOSTACK = 111,
    IFT_VIRTUALIPADDRESS = 112,
    IFT_MPC = 113,
    IFT_IPOVERATM = 114,
    IFT_ISO88025FIBER = 115,
    IFT_TDLC = 116,
    IFT_GIGABITETHERNET = 117,
    IFT_HDLC = 118,
    IFT_LAPF = 119,
    IFT_V37 = 120,
    IFT_X25MLP = 121,
    IFT_X25HUNTGROUP = 122,
    IFT_TRANSPHDLC = 123,
    IFT_INTERLEAVE = 124,
    IFT_FAST = 125,
    IFT_IP = 126,
    IFT_DOCSCABLEMACLAYER = 127,
    IFT_DOCSCABLEDOWNSTREAM = 128,
    IFT_DOCSCABLEUPSTREAM = 129,
    IFT_A12MPPSWITCH = 130,
    IFT_TUNNEL = 131,
    IFT_COFFEE = 132,
    IFT_CES = 133,
    IFT_ATMSUBINTERFACE = 134,
    IFT_L2VLAN = 135,
    IFT_L3IPVLAN = 136,
    IFT_L3IPXVLAN = 137,
    IFT_DIGITALPOWERLINE = 138,
    IFT_MEDIAMAILOVERIP = 139,
    IFT_DTM = 140,
    IFT_DCN = 141,
    IFT_IPFORWARD = 142,
    IFT_MSDSL = 143,
    IFT_IEEE1394 = 144,
    IFT_IFGSN = 145,
    IFT_DVBRCCMACLAYER = 146,
    IFT_DVBRCCDOWNSTREAM = 147,
    IFT_DVBRCCUPSTREAM = 148,
    IFT_ATMVIRTUAL = 149,
    IFT_MPLSTUNNEL = 150,
    IFT_SRP = 151,
    IFT_VOICEOVERATM = 152,
    IFT_VOICEOVERFRAMERELAY = 153,
    IFT_IDSL = 154,
    IFT_COMPOSITELINK = 155,
    IFT_SS7SIGLINK = 156,
    IFT_PROPWIRELESSP2P = 157,
    IFT_FRFORWARD = 158,
    IFT_RFC1483 = 159,
    IFT_USB = 160,
    IFT_IEEE8023ADLAG = 161,
    IFT_BGPPOLICYACCOUNTING = 162,
    IFT_FRF16MFRBUNDLE = 163,
    IFT_H323GATEKEEPER = 164,
    IFT_H323PROXY = 165,
    IFT_MPLS = 166,
    IFT_MFSIGLINK = 167,
    IFT_HDSL2 = 168,
    IFT_SHDSL = 169,
    IFT_DS1FDL = 170,
    IFT_POS = 171,
    IFT_DVBASILN = 172,
    IFT_DVBASIOUT = 173,
    IFT_PLC = 174,
    IFT_NFAS = 175,
    IFT_TR008 = 176,
    IFT_GR303RDT = 177,
    IFT_GR303IDT = 178,
    IFT_ISUP = 179,
    IFT_PROPDOCSWIRELESSMACLAYER = 180,
    IFT_PROPDOCSWIRELESSDOWNSTREAM = 181,
    IFT_PROPDOCSWIRELESSUPSTREAM = 182,
    IFT_HIPERLAN2 = 183,
    IFT_PROPBWAP2MP = 184,
    IFT_SONETOVERHEADCHANNEL = 185,
    IFT_DIGITALWRAPPEROVERHEADCHANNEL = 186,
    IFT_AAL2 = 187,
    IFT_RADIOMAC = 188,
    IFT_ATMRADIO = 189,
    IFT_IMT = 190,
    IFT_MVL = 191,
    IFT_REACHDSL = 192,
    IFT_FRDLCIENDPT = 193,
    IFT_ATMVCIENDPT = 194,
    IFT_OPTICALCHANNEL = 195,
    IFT_OPTICALTRANSPORT = 196,
    IFT_INFINIBAND = 199,
    IFT_BRIDGE = 209,
    IFT_STF = 215,
    IFT_GIF = 240,
    IFT_PVC = 241,
    IFT_ENC = 244,
    IFT_PFLOG = 246,
    IFT_PFSYNC = 247,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct vlanreq {
    pub vlr_parent: [::kernel::sys::raw::c_char; 16usize],
    pub vlr_tag: u_short,
}
#[test]
fn bindgen_test_layout_vlanreq() {
    assert_eq!(::core::mem::size_of::<vlanreq>() , 18usize , concat ! (
               "Size of: " , stringify ! ( vlanreq ) ));
    assert_eq! (::core::mem::align_of::<vlanreq>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( vlanreq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vlanreq ) ) . vlr_parent as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( vlanreq ) , "::" ,
                stringify ! ( vlr_parent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vlanreq ) ) . vlr_tag as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( vlanreq ) , "::" ,
                stringify ! ( vlr_tag ) ));
}
impl Clone for vlanreq {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "vlan_trunk_cap_p"]
    pub static mut vlan_trunk_cap_p:
               ::core::option::Option<unsafe extern "C" fn(arg1: *mut ifnet)>;
}
extern "C" {
    #[link_name = "vlan_trunkdev_p"]
    pub static mut vlan_trunkdev_p:
               ::core::option::Option<unsafe extern "C" fn(arg1: *mut ifnet)
                                          -> *mut ifnet>;
}
extern "C" {
    #[link_name = "vlan_devat_p"]
    pub static mut vlan_devat_p:
               ::core::option::Option<unsafe extern "C" fn(arg1: *mut ifnet,
                                                           arg2: u16)
                                          -> *mut ifnet>;
}
extern "C" {
    #[link_name = "vlan_tag_p"]
    pub static mut vlan_tag_p:
               ::core::option::Option<unsafe extern "C" fn(arg1: *mut ifnet,
                                                           arg2: *mut u16)
                                          -> ::kernel::sys::raw::c_int>;
}
extern "C" {
    #[link_name = "vlan_setcookie_p"]
    pub static mut vlan_setcookie_p:
               ::core::option::Option<unsafe extern "C" fn(arg1: *mut ifnet,
                                                           arg2:
                                                               *mut ::kernel::sys::raw::c_void)
                                          -> ::kernel::sys::raw::c_int>;
}
extern "C" {
    #[link_name = "vlan_cookie_p"]
    pub static mut vlan_cookie_p:
               ::core::option::Option<unsafe extern "C" fn(arg1: *mut ifnet)
                                          -> *mut ::kernel::sys::raw::c_void>;
}
pub type vlan_config_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut ifnet, arg3: u16)>;
pub type vlan_unconfig_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2: *mut ifnet, arg3: u16)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_vlan_config {
    pub ee: eventhandler_entry,
    pub eh_func: vlan_config_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_vlan_config() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_vlan_config>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_vlan_config )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_vlan_config>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( eventhandler_entry_vlan_config
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_vlan_config ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_vlan_config ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_vlan_config ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_vlan_config ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_vlan_config {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_vlan_config {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_vlan_unconfig {
    pub ee: eventhandler_entry,
    pub eh_func: vlan_unconfig_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_vlan_unconfig() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_vlan_unconfig>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_vlan_unconfig )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_vlan_unconfig>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_vlan_unconfig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_vlan_unconfig ) ) . ee
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_vlan_unconfig ) , "::" , stringify ! ( ee )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_vlan_unconfig ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_vlan_unconfig ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_vlan_unconfig {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_vlan_unconfig {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type n_short = u_int16_t;
pub type n_long = u_int32_t;
pub type n_time = u_int32_t;
extern "C" {
    pub fn cr_canseeinpcb(cred: *mut ucred, inp: *mut inpcb)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn iptime() -> u32;
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
#[test]
fn bindgen_test_layout_in_addr() {
    assert_eq!(::core::mem::size_of::<in_addr>() , 4usize , concat ! (
               "Size of: " , stringify ! ( in_addr ) ));
    assert_eq! (::core::mem::align_of::<in_addr>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( in_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const in_addr ) ) . s_addr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( in_addr ) , "::" ,
                stringify ! ( s_addr ) ));
}
impl Clone for in_addr {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct sockaddr_in {
    pub sin_len: u8,
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: in_addr,
    pub sin_zero: [::kernel::sys::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout_sockaddr_in() {
    assert_eq!(::core::mem::size_of::<sockaddr_in>() , 16usize , concat ! (
               "Size of: " , stringify ! ( sockaddr_in ) ));
    assert_eq! (::core::mem::align_of::<sockaddr_in>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( sockaddr_in ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_in ) ) . sin_len as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_in ) , "::" ,
                stringify ! ( sin_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_in ) ) . sin_family as * const _
                as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_in ) , "::" ,
                stringify ! ( sin_family ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_in ) ) . sin_port as * const _
                as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_in ) , "::" ,
                stringify ! ( sin_port ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_in ) ) . sin_addr as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_in ) , "::" ,
                stringify ! ( sin_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_in ) ) . sin_zero as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_in ) , "::" ,
                stringify ! ( sin_zero ) ));
}
impl Clone for sockaddr_in {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct ip_mreq {
    pub imr_multiaddr: in_addr,
    pub imr_interface: in_addr,
}
#[test]
fn bindgen_test_layout_ip_mreq() {
    assert_eq!(::core::mem::size_of::<ip_mreq>() , 8usize , concat ! (
               "Size of: " , stringify ! ( ip_mreq ) ));
    assert_eq! (::core::mem::align_of::<ip_mreq>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( ip_mreq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_mreq ) ) . imr_multiaddr as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_mreq ) , "::" ,
                stringify ! ( imr_multiaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_mreq ) ) . imr_interface as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_mreq ) , "::" ,
                stringify ! ( imr_interface ) ));
}
impl Clone for ip_mreq {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct ip_mreqn {
    pub imr_multiaddr: in_addr,
    pub imr_address: in_addr,
    pub imr_ifindex: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_ip_mreqn() {
    assert_eq!(::core::mem::size_of::<ip_mreqn>() , 12usize , concat ! (
               "Size of: " , stringify ! ( ip_mreqn ) ));
    assert_eq! (::core::mem::align_of::<ip_mreqn>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( ip_mreqn ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_mreqn ) ) . imr_multiaddr as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_mreqn ) , "::" ,
                stringify ! ( imr_multiaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_mreqn ) ) . imr_address as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_mreqn ) , "::" ,
                stringify ! ( imr_address ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_mreqn ) ) . imr_ifindex as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_mreqn ) , "::" ,
                stringify ! ( imr_ifindex ) ));
}
impl Clone for ip_mreqn {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct ip_mreq_source {
    pub imr_multiaddr: in_addr,
    pub imr_sourceaddr: in_addr,
    pub imr_interface: in_addr,
}
#[test]
fn bindgen_test_layout_ip_mreq_source() {
    assert_eq!(::core::mem::size_of::<ip_mreq_source>() , 12usize , concat ! (
               "Size of: " , stringify ! ( ip_mreq_source ) ));
    assert_eq! (::core::mem::align_of::<ip_mreq_source>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( ip_mreq_source ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_mreq_source ) ) . imr_multiaddr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_mreq_source ) , "::"
                , stringify ! ( imr_multiaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_mreq_source ) ) . imr_sourceaddr as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_mreq_source ) , "::"
                , stringify ! ( imr_sourceaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_mreq_source ) ) . imr_interface as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_mreq_source ) , "::"
                , stringify ! ( imr_interface ) ));
}
impl Clone for ip_mreq_source {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct group_req {
    pub gr_interface: u32,
    pub gr_group: sockaddr_storage,
}
#[test]
fn bindgen_test_layout_group_req() {
    assert_eq!(::core::mem::size_of::<group_req>() , 136usize , concat ! (
               "Size of: " , stringify ! ( group_req ) ));
    assert_eq! (::core::mem::align_of::<group_req>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( group_req ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const group_req ) ) . gr_interface as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( group_req ) , "::" ,
                stringify ! ( gr_interface ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const group_req ) ) . gr_group as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( group_req ) , "::" ,
                stringify ! ( gr_group ) ));
}
impl Clone for group_req {
    fn clone(&self) -> Self { *self }
}
impl Default for group_req {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for group_req {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "group_req {{ gr_interface: {:?}, gr_group: {:?} }}" , self
               . gr_interface , self . gr_group)
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct group_source_req {
    pub gsr_interface: u32,
    pub gsr_group: sockaddr_storage,
    pub gsr_source: sockaddr_storage,
}
#[test]
fn bindgen_test_layout_group_source_req() {
    assert_eq!(::core::mem::size_of::<group_source_req>() , 264usize , concat
               ! ( "Size of: " , stringify ! ( group_source_req ) ));
    assert_eq! (::core::mem::align_of::<group_source_req>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( group_source_req ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const group_source_req ) ) . gsr_interface as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( group_source_req ) ,
                "::" , stringify ! ( gsr_interface ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const group_source_req ) ) . gsr_group as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( group_source_req ) ,
                "::" , stringify ! ( gsr_group ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const group_source_req ) ) . gsr_source as *
                const _ as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( group_source_req ) ,
                "::" , stringify ! ( gsr_source ) ));
}
impl Clone for group_source_req {
    fn clone(&self) -> Self { *self }
}
impl Default for group_source_req {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for group_source_req {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "group_source_req {{ gsr_interface: {:?}, gsr_group: {:?}, gsr_source: {:?} }}"
               , self . gsr_interface , self . gsr_group , self . gsr_source)
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct __msfilterreq {
    pub msfr_ifindex: u32,
    pub msfr_fmode: u32,
    pub msfr_nsrcs: u32,
    pub msfr_group: sockaddr_storage,
    pub msfr_srcs: *mut sockaddr_storage,
}
#[test]
fn bindgen_test_layout___msfilterreq() {
    assert_eq!(::core::mem::size_of::<__msfilterreq>() , 152usize , concat ! (
               "Size of: " , stringify ! ( __msfilterreq ) ));
    assert_eq! (::core::mem::align_of::<__msfilterreq>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __msfilterreq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __msfilterreq ) ) . msfr_ifindex as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __msfilterreq ) , "::"
                , stringify ! ( msfr_ifindex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __msfilterreq ) ) . msfr_fmode as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __msfilterreq ) , "::"
                , stringify ! ( msfr_fmode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __msfilterreq ) ) . msfr_nsrcs as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __msfilterreq ) , "::"
                , stringify ! ( msfr_nsrcs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __msfilterreq ) ) . msfr_group as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __msfilterreq ) , "::"
                , stringify ! ( msfr_group ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __msfilterreq ) ) . msfr_srcs as * const
                _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( __msfilterreq ) , "::"
                , stringify ! ( msfr_srcs ) ));
}
impl Clone for __msfilterreq {
    fn clone(&self) -> Self { *self }
}
impl Default for __msfilterreq {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for __msfilterreq {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "__msfilterreq {{ msfr_ifindex: {:?}, msfr_fmode: {:?}, msfr_nsrcs: {:?}, msfr_group: {:?}, msfr_srcs: {:?} }}"
               , self . msfr_ifindex , self . msfr_fmode , self . msfr_nsrcs ,
               self . msfr_group , self . msfr_srcs)
    }
}
extern "C" {
    pub fn setipv4sourcefilter(arg1: ::kernel::sys::raw::c_int, arg2: in_addr,
                               arg3: in_addr, arg4: u32, arg5: u32,
                               arg6: *mut in_addr)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn getipv4sourcefilter(arg1: ::kernel::sys::raw::c_int, arg2: in_addr,
                               arg3: in_addr, arg4: *mut u32, arg5: *mut u32,
                               arg6: *mut in_addr)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn setsourcefilter(arg1: ::kernel::sys::raw::c_int, arg2: u32,
                           arg3: *mut sockaddr, arg4: socklen_t, arg5: u32,
                           arg6: u32, arg7: *mut sockaddr_storage)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn getsourcefilter(arg1: ::kernel::sys::raw::c_int, arg2: u32,
                           arg3: *mut sockaddr, arg4: socklen_t,
                           arg5: *mut u32, arg6: *mut u32,
                           arg7: *mut sockaddr_storage)
     -> ::kernel::sys::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_ifaddr {
    _unused: [u8; 0],
}
extern "C" {
    pub fn in_broadcast(arg1: in_addr, arg2: *mut ifnet)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn in_ifaddr_broadcast(arg1: in_addr, arg2: *mut in_ifaddr)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn in_canforward(arg1: in_addr) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn in_localaddr(arg1: in_addr) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn in_localip(arg1: in_addr) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn in_ifhasaddr(arg1: *mut ifnet, arg2: in_addr)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn inet_aton(arg1: *const ::kernel::sys::raw::c_char,
                     arg2: *mut in_addr) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn inet_ntoa_r(ina: in_addr, buf: *mut ::kernel::sys::raw::c_char)
     -> *mut ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn inet_ntop(arg1: ::kernel::sys::raw::c_int,
                     arg2: *const ::kernel::sys::raw::c_void,
                     arg3: *mut ::kernel::sys::raw::c_char, arg4: socklen_t)
     -> *mut ::kernel::sys::raw::c_char;
}
extern "C" {
    pub fn inet_pton(af: ::kernel::sys::raw::c_int,
                     arg1: *const ::kernel::sys::raw::c_char,
                     arg2: *mut ::kernel::sys::raw::c_void)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn in_ifdetach(arg1: *mut ifnet);
}
#[repr(C)]
#[derive(Copy)]
pub struct in6_addr {
    pub __u6_addr: in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub union in6_addr__bindgen_ty_1 {
    pub __u6_addr8: [u8; 16usize],
    pub __u6_addr16: [u16; 8usize],
    pub __u6_addr32: [u32; 4usize],
    _bindgen_union_align: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_in6_addr__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<in6_addr__bindgen_ty_1>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( in6_addr__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<in6_addr__bindgen_ty_1>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( in6_addr__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const in6_addr__bindgen_ty_1 ) ) . __u6_addr8
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( in6_addr__bindgen_ty_1
                ) , "::" , stringify ! ( __u6_addr8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const in6_addr__bindgen_ty_1 ) ) . __u6_addr16
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( in6_addr__bindgen_ty_1
                ) , "::" , stringify ! ( __u6_addr16 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const in6_addr__bindgen_ty_1 ) ) . __u6_addr32
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( in6_addr__bindgen_ty_1
                ) , "::" , stringify ! ( __u6_addr32 ) ));
}
impl Clone for in6_addr__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for in6_addr__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for in6_addr__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "in6_addr__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_in6_addr() {
    assert_eq!(::core::mem::size_of::<in6_addr>() , 16usize , concat ! (
               "Size of: " , stringify ! ( in6_addr ) ));
    assert_eq! (::core::mem::align_of::<in6_addr>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( in6_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const in6_addr ) ) . __u6_addr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( in6_addr ) , "::" ,
                stringify ! ( __u6_addr ) ));
}
impl Clone for in6_addr {
    fn clone(&self) -> Self { *self }
}
impl Default for in6_addr {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for in6_addr {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "in6_addr {{ __u6_addr: {:?} }}" , self . __u6_addr)
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct sockaddr_in6 {
    pub sin6_len: u8,
    pub sin6_family: sa_family_t,
    pub sin6_port: in_port_t,
    pub sin6_flowinfo: u32,
    pub sin6_addr: in6_addr,
    pub sin6_scope_id: u32,
}
#[test]
fn bindgen_test_layout_sockaddr_in6() {
    assert_eq!(::core::mem::size_of::<sockaddr_in6>() , 28usize , concat ! (
               "Size of: " , stringify ! ( sockaddr_in6 ) ));
    assert_eq! (::core::mem::align_of::<sockaddr_in6>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( sockaddr_in6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_in6 ) ) . sin6_len as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_in6 ) , "::" ,
                stringify ! ( sin6_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_in6 ) ) . sin6_family as * const
                _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_in6 ) , "::" ,
                stringify ! ( sin6_family ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_in6 ) ) . sin6_port as * const _
                as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_in6 ) , "::" ,
                stringify ! ( sin6_port ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_in6 ) ) . sin6_flowinfo as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_in6 ) , "::" ,
                stringify ! ( sin6_flowinfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_in6 ) ) . sin6_addr as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_in6 ) , "::" ,
                stringify ! ( sin6_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_in6 ) ) . sin6_scope_id as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_in6 ) , "::" ,
                stringify ! ( sin6_scope_id ) ));
}
impl Clone for sockaddr_in6 {
    fn clone(&self) -> Self { *self }
}
impl Default for sockaddr_in6 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for sockaddr_in6 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "sockaddr_in6 {{ sin6_len: {:?}, sin6_family: {:?}, sin6_port: {:?}, sin6_flowinfo: {:?}, sin6_addr: {:?}, sin6_scope_id: {:?} }}"
               , self . sin6_len , self . sin6_family , self . sin6_port ,
               self . sin6_flowinfo , self . sin6_addr , self . sin6_scope_id)
    }
}
extern "C" {
    #[link_name = "sa6_any"]
    pub static sa6_any: sockaddr_in6;
}
extern "C" {
    #[link_name = "in6mask0"]
    pub static in6mask0: in6_addr;
}
extern "C" {
    #[link_name = "in6mask32"]
    pub static in6mask32: in6_addr;
}
extern "C" {
    #[link_name = "in6mask64"]
    pub static in6mask64: in6_addr;
}
extern "C" {
    #[link_name = "in6mask96"]
    pub static in6mask96: in6_addr;
}
extern "C" {
    #[link_name = "in6mask128"]
    pub static in6mask128: in6_addr;
}
extern "C" {
    #[link_name = "in6addr_any"]
    pub static in6addr_any: in6_addr;
}
extern "C" {
    #[link_name = "in6addr_loopback"]
    pub static in6addr_loopback: in6_addr;
}
extern "C" {
    #[link_name = "in6addr_nodelocal_allnodes"]
    pub static in6addr_nodelocal_allnodes: in6_addr;
}
extern "C" {
    #[link_name = "in6addr_linklocal_allnodes"]
    pub static in6addr_linklocal_allnodes: in6_addr;
}
extern "C" {
    #[link_name = "in6addr_linklocal_allrouters"]
    pub static in6addr_linklocal_allrouters: in6_addr;
}
extern "C" {
    #[link_name = "in6addr_linklocal_allv2routers"]
    pub static in6addr_linklocal_allv2routers: in6_addr;
}
#[repr(C)]
#[derive(Copy)]
pub struct route_in6 {
    pub ro_rt: *mut rtentry,
    pub ro_lle: *mut llentry,
    pub ro_prepend: *mut ::kernel::sys::raw::c_char,
    pub ro_plen: u16,
    pub ro_flags: u16,
    pub ro_mtu: u16,
    pub spare: u16,
    pub ro_dst: sockaddr_in6,
}
#[test]
fn bindgen_test_layout_route_in6() {
    assert_eq!(::core::mem::size_of::<route_in6>() , 64usize , concat ! (
               "Size of: " , stringify ! ( route_in6 ) ));
    assert_eq! (::core::mem::align_of::<route_in6>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( route_in6 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const route_in6 ) ) . ro_rt as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( route_in6 ) , "::" ,
                stringify ! ( ro_rt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const route_in6 ) ) . ro_lle as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( route_in6 ) , "::" ,
                stringify ! ( ro_lle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const route_in6 ) ) . ro_prepend as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( route_in6 ) , "::" ,
                stringify ! ( ro_prepend ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const route_in6 ) ) . ro_plen as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( route_in6 ) , "::" ,
                stringify ! ( ro_plen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const route_in6 ) ) . ro_flags as * const _ as
                usize } , 26usize , concat ! (
                "Alignment of field: " , stringify ! ( route_in6 ) , "::" ,
                stringify ! ( ro_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const route_in6 ) ) . ro_mtu as * const _ as
                usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( route_in6 ) , "::" ,
                stringify ! ( ro_mtu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const route_in6 ) ) . spare as * const _ as
                usize } , 30usize , concat ! (
                "Alignment of field: " , stringify ! ( route_in6 ) , "::" ,
                stringify ! ( spare ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const route_in6 ) ) . ro_dst as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( route_in6 ) , "::" ,
                stringify ! ( ro_dst ) ));
}
impl Clone for route_in6 {
    fn clone(&self) -> Self { *self }
}
impl Default for route_in6 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for route_in6 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "route_in6 {{ ro_rt: {:?}, ro_lle: {:?}, ro_prepend: {:?}, ro_plen: {:?}, ro_flags: {:?}, ro_mtu: {:?}, spare: {:?}, ro_dst: {:?} }}"
               , self . ro_rt , self . ro_lle , self . ro_prepend , self .
               ro_plen , self . ro_flags , self . ro_mtu , self . spare , self
               . ro_dst)
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct ipv6_mreq {
    pub ipv6mr_multiaddr: in6_addr,
    pub ipv6mr_interface: ::kernel::sys::raw::c_uint,
}
#[test]
fn bindgen_test_layout_ipv6_mreq() {
    assert_eq!(::core::mem::size_of::<ipv6_mreq>() , 20usize , concat ! (
               "Size of: " , stringify ! ( ipv6_mreq ) ));
    assert_eq! (::core::mem::align_of::<ipv6_mreq>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( ipv6_mreq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ipv6_mreq ) ) . ipv6mr_multiaddr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ipv6_mreq ) , "::" ,
                stringify ! ( ipv6mr_multiaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ipv6_mreq ) ) . ipv6mr_interface as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( ipv6_mreq ) , "::" ,
                stringify ! ( ipv6mr_interface ) ));
}
impl Clone for ipv6_mreq {
    fn clone(&self) -> Self { *self }
}
impl Default for ipv6_mreq {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for ipv6_mreq {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "ipv6_mreq {{ ipv6mr_multiaddr: {:?}, ipv6mr_interface: {:?} }}"
               , self . ipv6mr_multiaddr , self . ipv6mr_interface)
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct in6_pktinfo {
    pub ipi6_addr: in6_addr,
    pub ipi6_ifindex: ::kernel::sys::raw::c_uint,
}
#[test]
fn bindgen_test_layout_in6_pktinfo() {
    assert_eq!(::core::mem::size_of::<in6_pktinfo>() , 20usize , concat ! (
               "Size of: " , stringify ! ( in6_pktinfo ) ));
    assert_eq! (::core::mem::align_of::<in6_pktinfo>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( in6_pktinfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const in6_pktinfo ) ) . ipi6_addr as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( in6_pktinfo ) , "::" ,
                stringify ! ( ipi6_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const in6_pktinfo ) ) . ipi6_ifindex as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( in6_pktinfo ) , "::" ,
                stringify ! ( ipi6_ifindex ) ));
}
impl Clone for in6_pktinfo {
    fn clone(&self) -> Self { *self }
}
impl Default for in6_pktinfo {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for in6_pktinfo {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "in6_pktinfo {{ ipi6_addr: {:?}, ipi6_ifindex: {:?} }}" ,
               self . ipi6_addr , self . ipi6_ifindex)
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct ip6_mtuinfo {
    pub ip6m_addr: sockaddr_in6,
    pub ip6m_mtu: u32,
}
#[test]
fn bindgen_test_layout_ip6_mtuinfo() {
    assert_eq!(::core::mem::size_of::<ip6_mtuinfo>() , 32usize , concat ! (
               "Size of: " , stringify ! ( ip6_mtuinfo ) ));
    assert_eq! (::core::mem::align_of::<ip6_mtuinfo>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( ip6_mtuinfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip6_mtuinfo ) ) . ip6m_addr as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ip6_mtuinfo ) , "::" ,
                stringify ! ( ip6m_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip6_mtuinfo ) ) . ip6m_mtu as * const _
                as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( ip6_mtuinfo ) , "::" ,
                stringify ! ( ip6m_mtu ) ));
}
impl Clone for ip6_mtuinfo {
    fn clone(&self) -> Self { *self }
}
impl Default for ip6_mtuinfo {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for ip6_mtuinfo {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "ip6_mtuinfo {{ ip6m_addr: {:?}, ip6m_mtu: {:?} }}" , self
               . ip6m_addr , self . ip6m_mtu)
    }
}
#[repr(C, packed)]
#[derive(Copy)]
pub struct ip6_hdr {
    pub ip6_ctlun: ip6_hdr__bindgen_ty_1,
    pub ip6_src: in6_addr,
    pub ip6_dst: in6_addr,
}
#[repr(C)]
#[derive(Copy)]
pub union ip6_hdr__bindgen_ty_1 {
    pub ip6_un1: ip6_hdr__bindgen_ty_1_ip6_hdrctl,
    pub ip6_un2_vfc: u_int8_t,
    _bindgen_union_align: [u32; 2usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct ip6_hdr__bindgen_ty_1_ip6_hdrctl {
    pub ip6_un1_flow: u_int32_t,
    pub ip6_un1_plen: u_int16_t,
    pub ip6_un1_nxt: u_int8_t,
    pub ip6_un1_hlim: u_int8_t,
}
#[test]
fn bindgen_test_layout_ip6_hdr__bindgen_ty_1_ip6_hdrctl() {
    assert_eq!(::core::mem::size_of::<ip6_hdr__bindgen_ty_1_ip6_hdrctl>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( ip6_hdr__bindgen_ty_1_ip6_hdrctl )
               ));
    assert_eq! (::core::mem::align_of::<ip6_hdr__bindgen_ty_1_ip6_hdrctl>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                ip6_hdr__bindgen_ty_1_ip6_hdrctl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip6_hdr__bindgen_ty_1_ip6_hdrctl ) ) .
                ip6_un1_flow as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                ip6_hdr__bindgen_ty_1_ip6_hdrctl ) , "::" , stringify ! (
                ip6_un1_flow ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip6_hdr__bindgen_ty_1_ip6_hdrctl ) ) .
                ip6_un1_plen as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                ip6_hdr__bindgen_ty_1_ip6_hdrctl ) , "::" , stringify ! (
                ip6_un1_plen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip6_hdr__bindgen_ty_1_ip6_hdrctl ) ) .
                ip6_un1_nxt as * const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! (
                ip6_hdr__bindgen_ty_1_ip6_hdrctl ) , "::" , stringify ! (
                ip6_un1_nxt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip6_hdr__bindgen_ty_1_ip6_hdrctl ) ) .
                ip6_un1_hlim as * const _ as usize } , 7usize , concat ! (
                "Alignment of field: " , stringify ! (
                ip6_hdr__bindgen_ty_1_ip6_hdrctl ) , "::" , stringify ! (
                ip6_un1_hlim ) ));
}
impl Clone for ip6_hdr__bindgen_ty_1_ip6_hdrctl {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_ip6_hdr__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<ip6_hdr__bindgen_ty_1>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( ip6_hdr__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<ip6_hdr__bindgen_ty_1>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( ip6_hdr__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip6_hdr__bindgen_ty_1 ) ) . ip6_un1 as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ip6_hdr__bindgen_ty_1 )
                , "::" , stringify ! ( ip6_un1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip6_hdr__bindgen_ty_1 ) ) . ip6_un2_vfc
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ip6_hdr__bindgen_ty_1 )
                , "::" , stringify ! ( ip6_un2_vfc ) ));
}
impl Clone for ip6_hdr__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for ip6_hdr__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for ip6_hdr__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "ip6_hdr__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_ip6_hdr() {
    assert_eq!(::core::mem::size_of::<ip6_hdr>() , 40usize , concat ! (
               "Size of: " , stringify ! ( ip6_hdr ) ));
    assert_eq! (::core::mem::align_of::<ip6_hdr>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( ip6_hdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip6_hdr ) ) . ip6_ctlun as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ip6_hdr ) , "::" ,
                stringify ! ( ip6_ctlun ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip6_hdr ) ) . ip6_src as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ip6_hdr ) , "::" ,
                stringify ! ( ip6_src ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip6_hdr ) ) . ip6_dst as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ip6_hdr ) , "::" ,
                stringify ! ( ip6_dst ) ));
}
impl Clone for ip6_hdr {
    fn clone(&self) -> Self { *self }
}
impl Default for ip6_hdr {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for ip6_hdr {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "ip6_hdr {{ ip6_ctlun: {:?}, ip6_src: {:?}, ip6_dst: {:?} }}" ,
               self . ip6_ctlun , self . ip6_src , self . ip6_dst)
    }
}
extern "C" {
    pub fn in6_cksum_pseudo(arg1: *mut ip6_hdr, arg2: u32, arg3: u8,
                            arg4: u16) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn in6_cksum(arg1: *mut mbuf, arg2: u_int8_t, arg3: u_int32_t,
                     arg4: u_int32_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn in6_cksum_partial(arg1: *mut mbuf, arg2: u_int8_t, arg3: u_int32_t,
                             arg4: u_int32_t, arg5: u_int32_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn in6_localaddr(arg1: *mut in6_addr) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn in6_localip(arg1: *mut in6_addr) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn in6_ifhasaddr(arg1: *mut ifnet, arg2: *mut in6_addr)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn in6_addrscope(arg1: *const in6_addr) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn ip6_sprintf(arg1: *mut ::kernel::sys::raw::c_char,
                       arg2: *const in6_addr)
     -> *mut ::kernel::sys::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in6_ifaddr {
    _unused: [u8; 0],
}
extern "C" {
    pub fn in6_ifawithifp(arg1: *mut ifnet, arg2: *mut in6_addr)
     -> *mut in6_ifaddr;
}
extern "C" {
    pub fn in6_if_up(arg1: *mut ifnet);
}
extern "C" {
    #[link_name = "ip6_protox"]
    pub static mut ip6_protox: [u_char; 0usize];
}
extern "C" {
    pub fn in6_sin6_2_sin(sin: *mut sockaddr_in, sin6: *mut sockaddr_in6);
}
extern "C" {
    pub fn in6_sin_2_v4mapsin6(sin: *mut sockaddr_in,
                               sin6: *mut sockaddr_in6);
}
extern "C" {
    pub fn in6_sin6_2_sin_in_sock(nam: *mut sockaddr);
}
extern "C" {
    pub fn in6_sin_2_v4mapsin6_in_sock(nam: *mut *mut sockaddr);
}
extern "C" {
    pub fn addrsel_policy_init();
}
extern "C" {
    pub fn inet6_option_space(arg1: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn inet6_option_init(arg1: *mut ::kernel::sys::raw::c_void,
                             arg2: *mut *mut cmsghdr,
                             arg3: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn inet6_option_append(arg1: *mut cmsghdr, arg2: *const u8,
                               arg3: ::kernel::sys::raw::c_int,
                               arg4: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn inet6_option_alloc(arg1: *mut cmsghdr,
                              arg2: ::kernel::sys::raw::c_int,
                              arg3: ::kernel::sys::raw::c_int,
                              arg4: ::kernel::sys::raw::c_int) -> *mut u8;
}
extern "C" {
    pub fn inet6_option_next(arg1: *const cmsghdr, arg2: *mut *mut u8)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn inet6_option_find(arg1: *const cmsghdr, arg2: *mut *mut u8,
                             arg3: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn inet6_rthdr_space(arg1: ::kernel::sys::raw::c_int,
                             arg2: ::kernel::sys::raw::c_int) -> usize;
}
extern "C" {
    pub fn inet6_rthdr_init(arg1: *mut ::kernel::sys::raw::c_void,
                            arg2: ::kernel::sys::raw::c_int) -> *mut cmsghdr;
}
extern "C" {
    pub fn inet6_rthdr_add(arg1: *mut cmsghdr, arg2: *const in6_addr,
                           arg3: ::kernel::sys::raw::c_uint)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn inet6_rthdr_lasthop(arg1: *mut cmsghdr,
                               arg2: ::kernel::sys::raw::c_uint)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn inet6_rthdr_segments(arg1: *const cmsghdr)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn inet6_rthdr_getaddr(arg1: *mut cmsghdr,
                               arg2: ::kernel::sys::raw::c_int)
     -> *mut in6_addr;
}
extern "C" {
    pub fn inet6_rthdr_getflags(arg1: *const cmsghdr,
                                arg2: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_init(arg1: *mut ::kernel::sys::raw::c_void,
                          arg2: socklen_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_append(arg1: *mut ::kernel::sys::raw::c_void,
                            arg2: socklen_t, arg3: ::kernel::sys::raw::c_int,
                            arg4: u8, arg5: socklen_t, arg6: u8,
                            arg7: *mut *mut ::kernel::sys::raw::c_void)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_finish(arg1: *mut ::kernel::sys::raw::c_void,
                            arg2: socklen_t, arg3: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_set_val(arg1: *mut ::kernel::sys::raw::c_void,
                             arg2: ::kernel::sys::raw::c_int,
                             arg3: *mut ::kernel::sys::raw::c_void,
                             arg4: socklen_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_next(arg1: *mut ::kernel::sys::raw::c_void,
                          arg2: socklen_t, arg3: ::kernel::sys::raw::c_int,
                          arg4: *mut u8, arg5: *mut socklen_t,
                          arg6: *mut *mut ::kernel::sys::raw::c_void)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_find(arg1: *mut ::kernel::sys::raw::c_void,
                          arg2: socklen_t, arg3: ::kernel::sys::raw::c_int,
                          arg4: u8, arg5: *mut socklen_t,
                          arg6: *mut *mut ::kernel::sys::raw::c_void)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn inet6_opt_get_val(arg1: *mut ::kernel::sys::raw::c_void,
                             arg2: ::kernel::sys::raw::c_int,
                             arg3: *mut ::kernel::sys::raw::c_void,
                             arg4: socklen_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn inet6_rth_space(arg1: ::kernel::sys::raw::c_int,
                           arg2: ::kernel::sys::raw::c_int) -> socklen_t;
}
extern "C" {
    pub fn inet6_rth_init(arg1: *mut ::kernel::sys::raw::c_void,
                          arg2: socklen_t, arg3: ::kernel::sys::raw::c_int,
                          arg4: ::kernel::sys::raw::c_int)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn inet6_rth_add(arg1: *mut ::kernel::sys::raw::c_void,
                         arg2: *const in6_addr) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn inet6_rth_reverse(arg1: *const ::kernel::sys::raw::c_void,
                             arg2: *mut ::kernel::sys::raw::c_void)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn inet6_rth_segments(arg1: *const ::kernel::sys::raw::c_void)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn inet6_rth_getaddr(arg1: *const ::kernel::sys::raw::c_void,
                             arg2: ::kernel::sys::raw::c_int)
     -> *mut in6_addr;
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct ether_arp {
    pub ea_hdr: arphdr,
    pub arp_sha: [u_char; 6usize],
    pub arp_spa: [u_char; 4usize],
    pub arp_tha: [u_char; 6usize],
    pub arp_tpa: [u_char; 4usize],
}
#[test]
fn bindgen_test_layout_ether_arp() {
    assert_eq!(::core::mem::size_of::<ether_arp>() , 28usize , concat ! (
               "Size of: " , stringify ! ( ether_arp ) ));
    assert_eq! (::core::mem::align_of::<ether_arp>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( ether_arp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ether_arp ) ) . ea_hdr as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ether_arp ) , "::" ,
                stringify ! ( ea_hdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ether_arp ) ) . arp_sha as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ether_arp ) , "::" ,
                stringify ! ( arp_sha ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ether_arp ) ) . arp_spa as * const _ as
                usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( ether_arp ) , "::" ,
                stringify ! ( arp_spa ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ether_arp ) ) . arp_tha as * const _ as
                usize } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( ether_arp ) , "::" ,
                stringify ! ( arp_tha ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ether_arp ) ) . arp_tpa as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( ether_arp ) , "::" ,
                stringify ! ( arp_tpa ) ));
}
impl Clone for ether_arp {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct sockaddr_inarp {
    pub sin_len: u_char,
    pub sin_family: u_char,
    pub sin_port: u_short,
    pub sin_addr: in_addr,
    pub sin_srcaddr: in_addr,
    pub sin_tos: u_short,
    pub sin_other: u_short,
}
#[test]
fn bindgen_test_layout_sockaddr_inarp() {
    assert_eq!(::core::mem::size_of::<sockaddr_inarp>() , 16usize , concat ! (
               "Size of: " , stringify ! ( sockaddr_inarp ) ));
    assert_eq! (::core::mem::align_of::<sockaddr_inarp>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( sockaddr_inarp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_inarp ) ) . sin_len as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_inarp ) , "::"
                , stringify ! ( sin_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_inarp ) ) . sin_family as *
                const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_inarp ) , "::"
                , stringify ! ( sin_family ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_inarp ) ) . sin_port as * const
                _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_inarp ) , "::"
                , stringify ! ( sin_port ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_inarp ) ) . sin_addr as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_inarp ) , "::"
                , stringify ! ( sin_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_inarp ) ) . sin_srcaddr as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_inarp ) , "::"
                , stringify ! ( sin_srcaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_inarp ) ) . sin_tos as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_inarp ) , "::"
                , stringify ! ( sin_tos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const sockaddr_inarp ) ) . sin_other as * const
                _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( sockaddr_inarp ) , "::"
                , stringify ! ( sin_other ) ));
}
impl Clone for sockaddr_inarp {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "ether_ipmulticast_min"]
    pub static mut ether_ipmulticast_min: [u_char; 6usize];
}
extern "C" {
    #[link_name = "ether_ipmulticast_max"]
    pub static mut ether_ipmulticast_max: [u_char; 6usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llentry {
    _unused: [u8; 0],
}
extern "C" {
    pub fn arpresolve_addr(ifp: *mut ifnet, flags: ::kernel::sys::raw::c_int,
                           dst: *const sockaddr,
                           desten: *mut ::kernel::sys::raw::c_char,
                           pflags: *mut u32, plle: *mut *mut llentry)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn arpresolve(ifp: *mut ifnet, is_gw: ::kernel::sys::raw::c_int,
                      m: *mut mbuf, dst: *const sockaddr, desten: *mut u_char,
                      pflags: *mut u32, plle: *mut *mut llentry)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn arprequest(arg1: *mut ifnet, arg2: *const in_addr,
                      arg3: *const in_addr, arg4: *mut u_char);
}
extern "C" {
    pub fn arp_ifinit(arg1: *mut ifnet, arg2: *mut ifaddr);
}
extern "C" {
    pub fn arp_announce_ifaddr(arg1: *mut ifnet, addr: in_addr,
                               arg2: *mut u_char);
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy)]
pub struct ip {
    pub _bitfield_1: u8,
    pub ip_tos: u_char,
    pub ip_len: u_short,
    pub ip_id: u_short,
    pub ip_off: u_short,
    pub ip_ttl: u_char,
    pub ip_p: u_char,
    pub ip_sum: u_short,
    pub ip_src: in_addr,
    pub ip_dst: in_addr,
}
#[test]
fn bindgen_test_layout_ip() {
    assert_eq!(::core::mem::size_of::<ip>() , 20usize , concat ! (
               "Size of: " , stringify ! ( ip ) ));
    assert_eq! (::core::mem::align_of::<ip>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( ip ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip ) ) . ip_tos as * const _ as usize } ,
                1usize , concat ! (
                "Alignment of field: " , stringify ! ( ip ) , "::" , stringify
                ! ( ip_tos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip ) ) . ip_len as * const _ as usize } ,
                2usize , concat ! (
                "Alignment of field: " , stringify ! ( ip ) , "::" , stringify
                ! ( ip_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip ) ) . ip_id as * const _ as usize } ,
                4usize , concat ! (
                "Alignment of field: " , stringify ! ( ip ) , "::" , stringify
                ! ( ip_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip ) ) . ip_off as * const _ as usize } ,
                6usize , concat ! (
                "Alignment of field: " , stringify ! ( ip ) , "::" , stringify
                ! ( ip_off ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip ) ) . ip_ttl as * const _ as usize } ,
                8usize , concat ! (
                "Alignment of field: " , stringify ! ( ip ) , "::" , stringify
                ! ( ip_ttl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip ) ) . ip_p as * const _ as usize } ,
                9usize , concat ! (
                "Alignment of field: " , stringify ! ( ip ) , "::" , stringify
                ! ( ip_p ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip ) ) . ip_sum as * const _ as usize } ,
                10usize , concat ! (
                "Alignment of field: " , stringify ! ( ip ) , "::" , stringify
                ! ( ip_sum ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip ) ) . ip_src as * const _ as usize } ,
                12usize , concat ! (
                "Alignment of field: " , stringify ! ( ip ) , "::" , stringify
                ! ( ip_src ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip ) ) . ip_dst as * const _ as usize } ,
                16usize , concat ! (
                "Alignment of field: " , stringify ! ( ip ) , "::" , stringify
                ! ( ip_dst ) ));
}
impl Clone for ip {
    fn clone(&self) -> Self { *self }
}
impl ip {
    #[inline]
    pub fn ip_hl(&self) -> u_char {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 15u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_ip_hl(&mut self, val: u_char) {
        let mask = 15u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn ip_v(&self) -> u_char {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 240u64 as u8;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_ip_v(&mut self, val: u_char) {
        let mask = 240u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(ip_hl: u_char, ip_v: u_char) -> u8 {
        ({ ({ 0 } | ((ip_hl as u8 as u8) << 0usize) & (15u64 as u8)) } |
             ((ip_v as u8 as u8) << 4usize) & (240u64 as u8))
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct ip_timestamp {
    pub ipt_code: u_char,
    pub ipt_len: u_char,
    pub ipt_ptr: u_char,
    pub _bitfield_1: u8,
    pub ipt_timestamp: ip_timestamp_ipt_timestamp,
}
#[repr(C)]
#[derive(Copy)]
pub union ip_timestamp_ipt_timestamp {
    pub ipt_time: [u32; 1usize],
    pub ipt_ta: [ip_timestamp_ipt_timestamp_ipt_ta; 1usize],
    _bindgen_union_align: [u32; 2usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct ip_timestamp_ipt_timestamp_ipt_ta {
    pub ipt_addr: in_addr,
    pub ipt_time: u32,
}
#[test]
fn bindgen_test_layout_ip_timestamp_ipt_timestamp_ipt_ta() {
    assert_eq!(::core::mem::size_of::<ip_timestamp_ipt_timestamp_ipt_ta>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( ip_timestamp_ipt_timestamp_ipt_ta )
               ));
    assert_eq! (::core::mem::align_of::<ip_timestamp_ipt_timestamp_ipt_ta>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                ip_timestamp_ipt_timestamp_ipt_ta ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_timestamp_ipt_timestamp_ipt_ta ) ) .
                ipt_addr as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                ip_timestamp_ipt_timestamp_ipt_ta ) , "::" , stringify ! (
                ipt_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_timestamp_ipt_timestamp_ipt_ta ) ) .
                ipt_time as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                ip_timestamp_ipt_timestamp_ipt_ta ) , "::" , stringify ! (
                ipt_time ) ));
}
impl Clone for ip_timestamp_ipt_timestamp_ipt_ta {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_ip_timestamp_ipt_timestamp() {
    assert_eq!(::core::mem::size_of::<ip_timestamp_ipt_timestamp>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( ip_timestamp_ipt_timestamp ) ));
    assert_eq! (::core::mem::align_of::<ip_timestamp_ipt_timestamp>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( ip_timestamp_ipt_timestamp )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_timestamp_ipt_timestamp ) ) . ipt_time
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                ip_timestamp_ipt_timestamp ) , "::" , stringify ! ( ipt_time )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_timestamp_ipt_timestamp ) ) . ipt_ta
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                ip_timestamp_ipt_timestamp ) , "::" , stringify ! ( ipt_ta )
                ));
}
impl Clone for ip_timestamp_ipt_timestamp {
    fn clone(&self) -> Self { *self }
}
impl Default for ip_timestamp_ipt_timestamp {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for ip_timestamp_ipt_timestamp {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "ip_timestamp_ipt_timestamp {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_ip_timestamp() {
    assert_eq!(::core::mem::size_of::<ip_timestamp>() , 12usize , concat ! (
               "Size of: " , stringify ! ( ip_timestamp ) ));
    assert_eq! (::core::mem::align_of::<ip_timestamp>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( ip_timestamp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_timestamp ) ) . ipt_code as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_timestamp ) , "::" ,
                stringify ! ( ipt_code ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_timestamp ) ) . ipt_len as * const _
                as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_timestamp ) , "::" ,
                stringify ! ( ipt_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_timestamp ) ) . ipt_ptr as * const _
                as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_timestamp ) , "::" ,
                stringify ! ( ipt_ptr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip_timestamp ) ) . ipt_timestamp as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ip_timestamp ) , "::" ,
                stringify ! ( ipt_timestamp ) ));
}
impl Clone for ip_timestamp {
    fn clone(&self) -> Self { *self }
}
impl Default for ip_timestamp {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for ip_timestamp {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "ip_timestamp {{ ipt_code: {:?}, ipt_len: {:?}, ipt_ptr: {:?}, ipt_flg : {:?}, ipt_oflw : {:?}, ipt_timestamp: {:?} }}"
               , self . ipt_code , self . ipt_len , self . ipt_ptr , self .
               ipt_flg (  ) , self . ipt_oflw (  ) , self . ipt_timestamp)
    }
}
impl ip_timestamp {
    #[inline]
    pub fn ipt_flg(&self) -> u_char {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 15u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_ipt_flg(&mut self, val: u_char) {
        let mask = 15u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn ipt_oflw(&self) -> u_char {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 240u64 as u8;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_ipt_oflw(&mut self, val: u_char) {
        let mask = 240u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(ipt_flg: u_char, ipt_oflw: u_char) -> u8 {
        ({ ({ 0 } | ((ipt_flg as u8 as u8) << 0usize) & (15u64 as u8)) } |
             ((ipt_oflw as u8 as u8) << 4usize) & (240u64 as u8))
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct ippseudo {
    pub ippseudo_src: in_addr,
    pub ippseudo_dst: in_addr,
    pub ippseudo_pad: u_char,
    pub ippseudo_p: u_char,
    pub ippseudo_len: u_short,
}
#[test]
fn bindgen_test_layout_ippseudo() {
    assert_eq!(::core::mem::size_of::<ippseudo>() , 12usize , concat ! (
               "Size of: " , stringify ! ( ippseudo ) ));
    assert_eq! (::core::mem::align_of::<ippseudo>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( ippseudo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ippseudo ) ) . ippseudo_src as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ippseudo ) , "::" ,
                stringify ! ( ippseudo_src ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ippseudo ) ) . ippseudo_dst as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ippseudo ) , "::" ,
                stringify ! ( ippseudo_dst ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ippseudo ) ) . ippseudo_pad as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( ippseudo ) , "::" ,
                stringify ! ( ippseudo_pad ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ippseudo ) ) . ippseudo_p as * const _ as
                usize } , 9usize , concat ! (
                "Alignment of field: " , stringify ! ( ippseudo ) , "::" ,
                stringify ! ( ippseudo_p ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ippseudo ) ) . ippseudo_len as * const _
                as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( ippseudo ) , "::" ,
                stringify ! ( ippseudo_len ) ));
}
impl Clone for ippseudo {
    fn clone(&self) -> Self { *self }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy)]
pub struct ip6_ext {
    pub ip6e_nxt: u_int8_t,
    pub ip6e_len: u_int8_t,
}
#[test]
fn bindgen_test_layout_ip6_ext() {
    assert_eq!(::core::mem::size_of::<ip6_ext>() , 2usize , concat ! (
               "Size of: " , stringify ! ( ip6_ext ) ));
    assert_eq! (::core::mem::align_of::<ip6_ext>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( ip6_ext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip6_ext ) ) . ip6e_nxt as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ip6_ext ) , "::" ,
                stringify ! ( ip6e_nxt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip6_ext ) ) . ip6e_len as * const _ as
                usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( ip6_ext ) , "::" ,
                stringify ! ( ip6e_len ) ));
}
impl Clone for ip6_ext {
    fn clone(&self) -> Self { *self }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy)]
pub struct ip6_hbh {
    pub ip6h_nxt: u_int8_t,
    pub ip6h_len: u_int8_t,
}
#[test]
fn bindgen_test_layout_ip6_hbh() {
    assert_eq!(::core::mem::size_of::<ip6_hbh>() , 2usize , concat ! (
               "Size of: " , stringify ! ( ip6_hbh ) ));
    assert_eq! (::core::mem::align_of::<ip6_hbh>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( ip6_hbh ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip6_hbh ) ) . ip6h_nxt as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ip6_hbh ) , "::" ,
                stringify ! ( ip6h_nxt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip6_hbh ) ) . ip6h_len as * const _ as
                usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( ip6_hbh ) , "::" ,
                stringify ! ( ip6h_len ) ));
}
impl Clone for ip6_hbh {
    fn clone(&self) -> Self { *self }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy)]
pub struct ip6_dest {
    pub ip6d_nxt: u_int8_t,
    pub ip6d_len: u_int8_t,
}
#[test]
fn bindgen_test_layout_ip6_dest() {
    assert_eq!(::core::mem::size_of::<ip6_dest>() , 2usize , concat ! (
               "Size of: " , stringify ! ( ip6_dest ) ));
    assert_eq! (::core::mem::align_of::<ip6_dest>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( ip6_dest ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip6_dest ) ) . ip6d_nxt as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ip6_dest ) , "::" ,
                stringify ! ( ip6d_nxt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip6_dest ) ) . ip6d_len as * const _ as
                usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( ip6_dest ) , "::" ,
                stringify ! ( ip6d_len ) ));
}
impl Clone for ip6_dest {
    fn clone(&self) -> Self { *self }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy)]
pub struct ip6_opt {
    pub ip6o_type: u_int8_t,
    pub ip6o_len: u_int8_t,
}
#[test]
fn bindgen_test_layout_ip6_opt() {
    assert_eq!(::core::mem::size_of::<ip6_opt>() , 2usize , concat ! (
               "Size of: " , stringify ! ( ip6_opt ) ));
    assert_eq! (::core::mem::align_of::<ip6_opt>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( ip6_opt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip6_opt ) ) . ip6o_type as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ip6_opt ) , "::" ,
                stringify ! ( ip6o_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip6_opt ) ) . ip6o_len as * const _ as
                usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( ip6_opt ) , "::" ,
                stringify ! ( ip6o_len ) ));
}
impl Clone for ip6_opt {
    fn clone(&self) -> Self { *self }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy)]
pub struct ip6_opt_jumbo {
    pub ip6oj_type: u_int8_t,
    pub ip6oj_len: u_int8_t,
    pub ip6oj_jumbo_len: [u_int8_t; 4usize],
}
#[test]
fn bindgen_test_layout_ip6_opt_jumbo() {
    assert_eq!(::core::mem::size_of::<ip6_opt_jumbo>() , 6usize , concat ! (
               "Size of: " , stringify ! ( ip6_opt_jumbo ) ));
    assert_eq! (::core::mem::align_of::<ip6_opt_jumbo>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( ip6_opt_jumbo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip6_opt_jumbo ) ) . ip6oj_type as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ip6_opt_jumbo ) , "::"
                , stringify ! ( ip6oj_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip6_opt_jumbo ) ) . ip6oj_len as * const
                _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( ip6_opt_jumbo ) , "::"
                , stringify ! ( ip6oj_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip6_opt_jumbo ) ) . ip6oj_jumbo_len as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( ip6_opt_jumbo ) , "::"
                , stringify ! ( ip6oj_jumbo_len ) ));
}
impl Clone for ip6_opt_jumbo {
    fn clone(&self) -> Self { *self }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy)]
pub struct ip6_opt_nsap {
    pub ip6on_type: u_int8_t,
    pub ip6on_len: u_int8_t,
    pub ip6on_src_nsap_len: u_int8_t,
    pub ip6on_dst_nsap_len: u_int8_t,
}
#[test]
fn bindgen_test_layout_ip6_opt_nsap() {
    assert_eq!(::core::mem::size_of::<ip6_opt_nsap>() , 4usize , concat ! (
               "Size of: " , stringify ! ( ip6_opt_nsap ) ));
    assert_eq! (::core::mem::align_of::<ip6_opt_nsap>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( ip6_opt_nsap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip6_opt_nsap ) ) . ip6on_type as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ip6_opt_nsap ) , "::" ,
                stringify ! ( ip6on_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip6_opt_nsap ) ) . ip6on_len as * const _
                as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( ip6_opt_nsap ) , "::" ,
                stringify ! ( ip6on_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip6_opt_nsap ) ) . ip6on_src_nsap_len as
                * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( ip6_opt_nsap ) , "::" ,
                stringify ! ( ip6on_src_nsap_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip6_opt_nsap ) ) . ip6on_dst_nsap_len as
                * const _ as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( ip6_opt_nsap ) , "::" ,
                stringify ! ( ip6on_dst_nsap_len ) ));
}
impl Clone for ip6_opt_nsap {
    fn clone(&self) -> Self { *self }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy)]
pub struct ip6_opt_tunnel {
    pub ip6ot_type: u_int8_t,
    pub ip6ot_len: u_int8_t,
    pub ip6ot_encap_limit: u_int8_t,
}
#[test]
fn bindgen_test_layout_ip6_opt_tunnel() {
    assert_eq!(::core::mem::size_of::<ip6_opt_tunnel>() , 3usize , concat ! (
               "Size of: " , stringify ! ( ip6_opt_tunnel ) ));
    assert_eq! (::core::mem::align_of::<ip6_opt_tunnel>() , 1usize , concat !
                ( "Alignment of " , stringify ! ( ip6_opt_tunnel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip6_opt_tunnel ) ) . ip6ot_type as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ip6_opt_tunnel ) , "::"
                , stringify ! ( ip6ot_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip6_opt_tunnel ) ) . ip6ot_len as * const
                _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( ip6_opt_tunnel ) , "::"
                , stringify ! ( ip6ot_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip6_opt_tunnel ) ) . ip6ot_encap_limit as
                * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( ip6_opt_tunnel ) , "::"
                , stringify ! ( ip6ot_encap_limit ) ));
}
impl Clone for ip6_opt_tunnel {
    fn clone(&self) -> Self { *self }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy)]
pub struct ip6_opt_router {
    pub ip6or_type: u_int8_t,
    pub ip6or_len: u_int8_t,
    pub ip6or_value: [u_int8_t; 2usize],
}
#[test]
fn bindgen_test_layout_ip6_opt_router() {
    assert_eq!(::core::mem::size_of::<ip6_opt_router>() , 4usize , concat ! (
               "Size of: " , stringify ! ( ip6_opt_router ) ));
    assert_eq! (::core::mem::align_of::<ip6_opt_router>() , 1usize , concat !
                ( "Alignment of " , stringify ! ( ip6_opt_router ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip6_opt_router ) ) . ip6or_type as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ip6_opt_router ) , "::"
                , stringify ! ( ip6or_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip6_opt_router ) ) . ip6or_len as * const
                _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( ip6_opt_router ) , "::"
                , stringify ! ( ip6or_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip6_opt_router ) ) . ip6or_value as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( ip6_opt_router ) , "::"
                , stringify ! ( ip6or_value ) ));
}
impl Clone for ip6_opt_router {
    fn clone(&self) -> Self { *self }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy)]
pub struct ip6_rthdr {
    pub ip6r_nxt: u_int8_t,
    pub ip6r_len: u_int8_t,
    pub ip6r_type: u_int8_t,
    pub ip6r_segleft: u_int8_t,
}
#[test]
fn bindgen_test_layout_ip6_rthdr() {
    assert_eq!(::core::mem::size_of::<ip6_rthdr>() , 4usize , concat ! (
               "Size of: " , stringify ! ( ip6_rthdr ) ));
    assert_eq! (::core::mem::align_of::<ip6_rthdr>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( ip6_rthdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip6_rthdr ) ) . ip6r_nxt as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ip6_rthdr ) , "::" ,
                stringify ! ( ip6r_nxt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip6_rthdr ) ) . ip6r_len as * const _ as
                usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( ip6_rthdr ) , "::" ,
                stringify ! ( ip6r_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip6_rthdr ) ) . ip6r_type as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( ip6_rthdr ) , "::" ,
                stringify ! ( ip6r_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip6_rthdr ) ) . ip6r_segleft as * const _
                as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( ip6_rthdr ) , "::" ,
                stringify ! ( ip6r_segleft ) ));
}
impl Clone for ip6_rthdr {
    fn clone(&self) -> Self { *self }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy)]
pub struct ip6_rthdr0 {
    pub ip6r0_nxt: u_int8_t,
    pub ip6r0_len: u_int8_t,
    pub ip6r0_type: u_int8_t,
    pub ip6r0_segleft: u_int8_t,
    pub ip6r0_reserved: u_int32_t,
}
#[test]
fn bindgen_test_layout_ip6_rthdr0() {
    assert_eq!(::core::mem::size_of::<ip6_rthdr0>() , 8usize , concat ! (
               "Size of: " , stringify ! ( ip6_rthdr0 ) ));
    assert_eq! (::core::mem::align_of::<ip6_rthdr0>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( ip6_rthdr0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip6_rthdr0 ) ) . ip6r0_nxt as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ip6_rthdr0 ) , "::" ,
                stringify ! ( ip6r0_nxt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip6_rthdr0 ) ) . ip6r0_len as * const _
                as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( ip6_rthdr0 ) , "::" ,
                stringify ! ( ip6r0_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip6_rthdr0 ) ) . ip6r0_type as * const _
                as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( ip6_rthdr0 ) , "::" ,
                stringify ! ( ip6r0_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip6_rthdr0 ) ) . ip6r0_segleft as * const
                _ as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( ip6_rthdr0 ) , "::" ,
                stringify ! ( ip6r0_segleft ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip6_rthdr0 ) ) . ip6r0_reserved as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ip6_rthdr0 ) , "::" ,
                stringify ! ( ip6r0_reserved ) ));
}
impl Clone for ip6_rthdr0 {
    fn clone(&self) -> Self { *self }
}
#[repr(C, packed)]
#[derive(Debug, Default, Copy)]
pub struct ip6_frag {
    pub ip6f_nxt: u_int8_t,
    pub ip6f_reserved: u_int8_t,
    pub ip6f_offlg: u_int16_t,
    pub ip6f_ident: u_int32_t,
}
#[test]
fn bindgen_test_layout_ip6_frag() {
    assert_eq!(::core::mem::size_of::<ip6_frag>() , 8usize , concat ! (
               "Size of: " , stringify ! ( ip6_frag ) ));
    assert_eq! (::core::mem::align_of::<ip6_frag>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( ip6_frag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip6_frag ) ) . ip6f_nxt as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ip6_frag ) , "::" ,
                stringify ! ( ip6f_nxt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip6_frag ) ) . ip6f_reserved as * const _
                as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( ip6_frag ) , "::" ,
                stringify ! ( ip6f_reserved ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip6_frag ) ) . ip6f_offlg as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( ip6_frag ) , "::" ,
                stringify ! ( ip6f_offlg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ip6_frag ) ) . ip6f_ident as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ip6_frag ) , "::" ,
                stringify ! ( ip6f_ident ) ));
}
impl Clone for ip6_frag {
    fn clone(&self) -> Self { *self }
}
pub type tcp_seq = u_int32_t;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct tcphdr {
    pub th_sport: u_short,
    pub th_dport: u_short,
    pub th_seq: tcp_seq,
    pub th_ack: tcp_seq,
    pub _bitfield_1: u8,
    pub th_flags: u_char,
    pub th_win: u_short,
    pub th_sum: u_short,
    pub th_urp: u_short,
}
#[test]
fn bindgen_test_layout_tcphdr() {
    assert_eq!(::core::mem::size_of::<tcphdr>() , 20usize , concat ! (
               "Size of: " , stringify ! ( tcphdr ) ));
    assert_eq! (::core::mem::align_of::<tcphdr>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( tcphdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcphdr ) ) . th_sport as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tcphdr ) , "::" ,
                stringify ! ( th_sport ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcphdr ) ) . th_dport as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( tcphdr ) , "::" ,
                stringify ! ( th_dport ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcphdr ) ) . th_seq as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( tcphdr ) , "::" ,
                stringify ! ( th_seq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcphdr ) ) . th_ack as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tcphdr ) , "::" ,
                stringify ! ( th_ack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcphdr ) ) . th_flags as * const _ as
                usize } , 13usize , concat ! (
                "Alignment of field: " , stringify ! ( tcphdr ) , "::" ,
                stringify ! ( th_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcphdr ) ) . th_win as * const _ as usize
                } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( tcphdr ) , "::" ,
                stringify ! ( th_win ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcphdr ) ) . th_sum as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( tcphdr ) , "::" ,
                stringify ! ( th_sum ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcphdr ) ) . th_urp as * const _ as usize
                } , 18usize , concat ! (
                "Alignment of field: " , stringify ! ( tcphdr ) , "::" ,
                stringify ! ( th_urp ) ));
}
impl Clone for tcphdr {
    fn clone(&self) -> Self { *self }
}
impl tcphdr {
    #[inline]
    pub fn th_x2(&self) -> u_char {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 15u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_th_x2(&mut self, val: u_char) {
        let mask = 15u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn th_off(&self) -> u_char {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 240u64 as u8;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_th_off(&mut self, val: u_char) {
        let mask = 240u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(th_x2: u_char, th_off: u_char) -> u8 {
        ({ ({ 0 } | ((th_x2 as u8 as u8) << 0usize) & (15u64 as u8)) } |
             ((th_off as u8 as u8) << 4usize) & (240u64 as u8))
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct tcp_info {
    pub tcpi_state: u_int8_t,
    pub __tcpi_ca_state: u_int8_t,
    pub __tcpi_retransmits: u_int8_t,
    pub __tcpi_probes: u_int8_t,
    pub __tcpi_backoff: u_int8_t,
    pub tcpi_options: u_int8_t,
    pub _bitfield_1: u8,
    pub tcpi_rto: u_int32_t,
    pub __tcpi_ato: u_int32_t,
    pub tcpi_snd_mss: u_int32_t,
    pub tcpi_rcv_mss: u_int32_t,
    pub __tcpi_unacked: u_int32_t,
    pub __tcpi_sacked: u_int32_t,
    pub __tcpi_lost: u_int32_t,
    pub __tcpi_retrans: u_int32_t,
    pub __tcpi_fackets: u_int32_t,
    pub __tcpi_last_data_sent: u_int32_t,
    pub __tcpi_last_ack_sent: u_int32_t,
    pub tcpi_last_data_recv: u_int32_t,
    pub __tcpi_last_ack_recv: u_int32_t,
    pub __tcpi_pmtu: u_int32_t,
    pub __tcpi_rcv_ssthresh: u_int32_t,
    pub tcpi_rtt: u_int32_t,
    pub tcpi_rttvar: u_int32_t,
    pub tcpi_snd_ssthresh: u_int32_t,
    pub tcpi_snd_cwnd: u_int32_t,
    pub __tcpi_advmss: u_int32_t,
    pub __tcpi_reordering: u_int32_t,
    pub __tcpi_rcv_rtt: u_int32_t,
    pub tcpi_rcv_space: u_int32_t,
    pub tcpi_snd_wnd: u_int32_t,
    pub tcpi_snd_bwnd: u_int32_t,
    pub tcpi_snd_nxt: u_int32_t,
    pub tcpi_rcv_nxt: u_int32_t,
    pub tcpi_toe_tid: u_int32_t,
    pub tcpi_snd_rexmitpack: u_int32_t,
    pub tcpi_rcv_ooopack: u_int32_t,
    pub tcpi_snd_zerowin: u_int32_t,
    pub __tcpi_pad: [u_int32_t; 26usize],
}
#[test]
fn bindgen_test_layout_tcp_info() {
    assert_eq!(::core::mem::size_of::<tcp_info>() , 236usize , concat ! (
               "Size of: " , stringify ! ( tcp_info ) ));
    assert_eq! (::core::mem::align_of::<tcp_info>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( tcp_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . tcpi_state as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( tcpi_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . __tcpi_ca_state as * const
                _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( __tcpi_ca_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . __tcpi_retransmits as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( __tcpi_retransmits ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . __tcpi_probes as * const _
                as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( __tcpi_probes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . __tcpi_backoff as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( __tcpi_backoff ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . tcpi_options as * const _
                as usize } , 5usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( tcpi_options ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . tcpi_rto as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( tcpi_rto ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . __tcpi_ato as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( __tcpi_ato ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . tcpi_snd_mss as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( tcpi_snd_mss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . tcpi_rcv_mss as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( tcpi_rcv_mss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . __tcpi_unacked as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( __tcpi_unacked ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . __tcpi_sacked as * const _
                as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( __tcpi_sacked ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . __tcpi_lost as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( __tcpi_lost ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . __tcpi_retrans as * const
                _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( __tcpi_retrans ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . __tcpi_fackets as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( __tcpi_fackets ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . __tcpi_last_data_sent as *
                const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( __tcpi_last_data_sent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . __tcpi_last_ack_sent as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( __tcpi_last_ack_sent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . tcpi_last_data_recv as *
                const _ as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( tcpi_last_data_recv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . __tcpi_last_ack_recv as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( __tcpi_last_ack_recv ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . __tcpi_pmtu as * const _
                as usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( __tcpi_pmtu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . __tcpi_rcv_ssthresh as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( __tcpi_rcv_ssthresh ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . tcpi_rtt as * const _ as
                usize } , 68usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( tcpi_rtt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . tcpi_rttvar as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( tcpi_rttvar ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . tcpi_snd_ssthresh as *
                const _ as usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( tcpi_snd_ssthresh ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . tcpi_snd_cwnd as * const _
                as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( tcpi_snd_cwnd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . __tcpi_advmss as * const _
                as usize } , 84usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( __tcpi_advmss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . __tcpi_reordering as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( __tcpi_reordering ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . __tcpi_rcv_rtt as * const
                _ as usize } , 92usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( __tcpi_rcv_rtt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . tcpi_rcv_space as * const
                _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( tcpi_rcv_space ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . tcpi_snd_wnd as * const _
                as usize } , 100usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( tcpi_snd_wnd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . tcpi_snd_bwnd as * const _
                as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( tcpi_snd_bwnd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . tcpi_snd_nxt as * const _
                as usize } , 108usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( tcpi_snd_nxt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . tcpi_rcv_nxt as * const _
                as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( tcpi_rcv_nxt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . tcpi_toe_tid as * const _
                as usize } , 116usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( tcpi_toe_tid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . tcpi_snd_rexmitpack as *
                const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( tcpi_snd_rexmitpack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . tcpi_rcv_ooopack as *
                const _ as usize } , 124usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( tcpi_rcv_ooopack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . tcpi_snd_zerowin as *
                const _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( tcpi_snd_zerowin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_info ) ) . __tcpi_pad as * const _ as
                usize } , 132usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_info ) , "::" ,
                stringify ! ( __tcpi_pad ) ));
}
impl Clone for tcp_info {
    fn clone(&self) -> Self { *self }
}
impl tcp_info {
    #[inline]
    pub fn tcpi_snd_wscale(&self) -> u_int8_t {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 15u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_tcpi_snd_wscale(&mut self, val: u_int8_t) {
        let mask = 15u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn tcpi_rcv_wscale(&self) -> u_int8_t {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 240u64 as u8;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_tcpi_rcv_wscale(&mut self, val: u_int8_t) {
        let mask = 240u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(tcpi_snd_wscale: u_int8_t,
                          tcpi_rcv_wscale: u_int8_t) -> u8 {
        ({
             ({ 0 } |
                  ((tcpi_snd_wscale as u8 as u8) << 0usize) & (15u64 as u8))
         } | ((tcpi_rcv_wscale as u8 as u8) << 4usize) & (240u64 as u8))
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct tcp_fastopen {
    pub enable: ::kernel::sys::raw::c_int,
    pub psk: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_tcp_fastopen() {
    assert_eq!(::core::mem::size_of::<tcp_fastopen>() , 20usize , concat ! (
               "Size of: " , stringify ! ( tcp_fastopen ) ));
    assert_eq! (::core::mem::align_of::<tcp_fastopen>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( tcp_fastopen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_fastopen ) ) . enable as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_fastopen ) , "::" ,
                stringify ! ( enable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_fastopen ) ) . psk as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_fastopen ) , "::" ,
                stringify ! ( psk ) ));
}
impl Clone for tcp_fastopen {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct tcp_function_set {
    pub function_set_name: [::kernel::sys::raw::c_char; 32usize],
    pub pcbcnt: u32,
}
#[test]
fn bindgen_test_layout_tcp_function_set() {
    assert_eq!(::core::mem::size_of::<tcp_function_set>() , 36usize , concat !
               ( "Size of: " , stringify ! ( tcp_function_set ) ));
    assert_eq! (::core::mem::align_of::<tcp_function_set>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( tcp_function_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_function_set ) ) . function_set_name
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_function_set ) ,
                "::" , stringify ! ( function_set_name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tcp_function_set ) ) . pcbcnt as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( tcp_function_set ) ,
                "::" , stringify ! ( pcbcnt ) ));
}
impl Clone for tcp_function_set {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct udphdr {
    pub uh_sport: u_short,
    pub uh_dport: u_short,
    pub uh_ulen: u_short,
    pub uh_sum: u_short,
}
#[test]
fn bindgen_test_layout_udphdr() {
    assert_eq!(::core::mem::size_of::<udphdr>() , 8usize , concat ! (
               "Size of: " , stringify ! ( udphdr ) ));
    assert_eq! (::core::mem::align_of::<udphdr>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( udphdr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const udphdr ) ) . uh_sport as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( udphdr ) , "::" ,
                stringify ! ( uh_sport ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const udphdr ) ) . uh_dport as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( udphdr ) , "::" ,
                stringify ! ( uh_dport ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const udphdr ) ) . uh_ulen as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( udphdr ) , "::" ,
                stringify ! ( uh_ulen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const udphdr ) ) . uh_sum as * const _ as usize
                } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( udphdr ) , "::" ,
                stringify ! ( uh_sum ) ));
}
impl Clone for udphdr {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn in_cksum_hdr(ip: *const ip) -> u_int;
}
extern "C" {
    pub fn in_addword(sum: u_short, b: u_short) -> u_short;
}
extern "C" {
    pub fn in_pseudo(sum: u_int, b: u_int, c: u_int) -> u_short;
}
extern "C" {
    pub fn in_cksum_skip(m: *mut mbuf, len: ::kernel::sys::raw::c_int,
                         skip: ::kernel::sys::raw::c_int) -> u_short;
}
pub type led_t =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    *mut ::kernel::sys::raw::c_void,
                                                arg2:
                                                    ::kernel::sys::raw::c_int)>;
extern "C" {
    pub fn led_create_state(arg1: led_t,
                            arg2: *mut ::kernel::sys::raw::c_void,
                            arg3: *const ::kernel::sys::raw::c_char,
                            arg4: ::kernel::sys::raw::c_int) -> *mut cdev;
}
extern "C" {
    pub fn led_create(arg1: led_t, arg2: *mut ::kernel::sys::raw::c_void,
                      arg3: *const ::kernel::sys::raw::c_char) -> *mut cdev;
}
extern "C" {
    pub fn led_destroy(arg1: *mut cdev);
}
extern "C" {
    pub fn led_set(arg1: *const ::kernel::sys::raw::c_char,
                   arg2: *const ::kernel::sys::raw::c_char)
     -> ::kernel::sys::raw::c_int;
}
pub type pci_addr_t = u64;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct pcicfg_bridge {
    pub br_seclat: u8,
    pub br_subbus: u8,
    pub br_secbus: u8,
    pub br_pribus: u8,
    pub br_control: u16,
}
#[test]
fn bindgen_test_layout_pcicfg_bridge() {
    assert_eq!(::core::mem::size_of::<pcicfg_bridge>() , 6usize , concat ! (
               "Size of: " , stringify ! ( pcicfg_bridge ) ));
    assert_eq! (::core::mem::align_of::<pcicfg_bridge>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( pcicfg_bridge ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_bridge ) ) . br_seclat as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_bridge ) , "::"
                , stringify ! ( br_seclat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_bridge ) ) . br_subbus as * const
                _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_bridge ) , "::"
                , stringify ! ( br_subbus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_bridge ) ) . br_secbus as * const
                _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_bridge ) , "::"
                , stringify ! ( br_secbus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_bridge ) ) . br_pribus as * const
                _ as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_bridge ) , "::"
                , stringify ! ( br_pribus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_bridge ) ) . br_control as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_bridge ) , "::"
                , stringify ! ( br_control ) ));
}
impl Clone for pcicfg_bridge {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct pcicfg_pp {
    pub pp_cap: u16,
    pub pp_status: u8,
    pub pp_bse: u8,
    pub pp_data: u8,
}
#[test]
fn bindgen_test_layout_pcicfg_pp() {
    assert_eq!(::core::mem::size_of::<pcicfg_pp>() , 6usize , concat ! (
               "Size of: " , stringify ! ( pcicfg_pp ) ));
    assert_eq! (::core::mem::align_of::<pcicfg_pp>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( pcicfg_pp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_pp ) ) . pp_cap as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_pp ) , "::" ,
                stringify ! ( pp_cap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_pp ) ) . pp_status as * const _ as
                usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_pp ) , "::" ,
                stringify ! ( pp_status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_pp ) ) . pp_bse as * const _ as
                usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_pp ) , "::" ,
                stringify ! ( pp_bse ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_pp ) ) . pp_data as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_pp ) , "::" ,
                stringify ! ( pp_data ) ));
}
impl Clone for pcicfg_pp {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pci_map {
    pub pm_value: pci_addr_t,
    pub pm_size: pci_addr_t,
    pub pm_reg: u16,
    pub pm_link: pci_map__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pci_map__bindgen_ty_1 {
    pub stqe_next: *mut pci_map,
}
#[test]
fn bindgen_test_layout_pci_map__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<pci_map__bindgen_ty_1>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( pci_map__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<pci_map__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( pci_map__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_map__bindgen_ty_1 ) ) . stqe_next as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pci_map__bindgen_ty_1 )
                , "::" , stringify ! ( stqe_next ) ));
}
impl Clone for pci_map__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for pci_map__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_pci_map() {
    assert_eq!(::core::mem::size_of::<pci_map>() , 32usize , concat ! (
               "Size of: " , stringify ! ( pci_map ) ));
    assert_eq! (::core::mem::align_of::<pci_map>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pci_map ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_map ) ) . pm_value as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pci_map ) , "::" ,
                stringify ! ( pm_value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_map ) ) . pm_size as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pci_map ) , "::" ,
                stringify ! ( pm_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_map ) ) . pm_reg as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( pci_map ) , "::" ,
                stringify ! ( pm_reg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_map ) ) . pm_link as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( pci_map ) , "::" ,
                stringify ! ( pm_link ) ));
}
impl Clone for pci_map {
    fn clone(&self) -> Self { *self }
}
impl Default for pci_map {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct vpd_readonly {
    pub keyword: [::kernel::sys::raw::c_char; 2usize],
    pub value: *mut ::kernel::sys::raw::c_char,
    pub len: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_vpd_readonly() {
    assert_eq!(::core::mem::size_of::<vpd_readonly>() , 24usize , concat ! (
               "Size of: " , stringify ! ( vpd_readonly ) ));
    assert_eq! (::core::mem::align_of::<vpd_readonly>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( vpd_readonly ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vpd_readonly ) ) . keyword as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( vpd_readonly ) , "::" ,
                stringify ! ( keyword ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vpd_readonly ) ) . value as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( vpd_readonly ) , "::" ,
                stringify ! ( value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vpd_readonly ) ) . len as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( vpd_readonly ) , "::" ,
                stringify ! ( len ) ));
}
impl Clone for vpd_readonly {
    fn clone(&self) -> Self { *self }
}
impl Default for vpd_readonly {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct vpd_write {
    pub keyword: [::kernel::sys::raw::c_char; 2usize],
    pub value: *mut ::kernel::sys::raw::c_char,
    pub start: ::kernel::sys::raw::c_int,
    pub len: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_vpd_write() {
    assert_eq!(::core::mem::size_of::<vpd_write>() , 24usize , concat ! (
               "Size of: " , stringify ! ( vpd_write ) ));
    assert_eq! (::core::mem::align_of::<vpd_write>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( vpd_write ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vpd_write ) ) . keyword as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( vpd_write ) , "::" ,
                stringify ! ( keyword ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vpd_write ) ) . value as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( vpd_write ) , "::" ,
                stringify ! ( value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vpd_write ) ) . start as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( vpd_write ) , "::" ,
                stringify ! ( start ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vpd_write ) ) . len as * const _ as usize
                } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( vpd_write ) , "::" ,
                stringify ! ( len ) ));
}
impl Clone for vpd_write {
    fn clone(&self) -> Self { *self }
}
impl Default for vpd_write {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pcicfg_vpd {
    pub vpd_reg: u8,
    pub vpd_cached: ::kernel::sys::raw::c_char,
    pub vpd_ident: *mut ::kernel::sys::raw::c_char,
    pub vpd_rocnt: ::kernel::sys::raw::c_int,
    pub vpd_ros: *mut vpd_readonly,
    pub vpd_wcnt: ::kernel::sys::raw::c_int,
    pub vpd_w: *mut vpd_write,
}
#[test]
fn bindgen_test_layout_pcicfg_vpd() {
    assert_eq!(::core::mem::size_of::<pcicfg_vpd>() , 48usize , concat ! (
               "Size of: " , stringify ! ( pcicfg_vpd ) ));
    assert_eq! (::core::mem::align_of::<pcicfg_vpd>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pcicfg_vpd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_vpd ) ) . vpd_reg as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_vpd ) , "::" ,
                stringify ! ( vpd_reg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_vpd ) ) . vpd_cached as * const _
                as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_vpd ) , "::" ,
                stringify ! ( vpd_cached ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_vpd ) ) . vpd_ident as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_vpd ) , "::" ,
                stringify ! ( vpd_ident ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_vpd ) ) . vpd_rocnt as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_vpd ) , "::" ,
                stringify ! ( vpd_rocnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_vpd ) ) . vpd_ros as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_vpd ) , "::" ,
                stringify ! ( vpd_ros ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_vpd ) ) . vpd_wcnt as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_vpd ) , "::" ,
                stringify ! ( vpd_wcnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_vpd ) ) . vpd_w as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_vpd ) , "::" ,
                stringify ! ( vpd_w ) ));
}
impl Clone for pcicfg_vpd {
    fn clone(&self) -> Self { *self }
}
impl Default for pcicfg_vpd {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct pcicfg_msi {
    pub msi_ctrl: u16,
    pub msi_location: u8,
    pub msi_msgnum: u8,
    pub msi_alloc: ::kernel::sys::raw::c_int,
    pub msi_addr: u64,
    pub msi_data: u16,
    pub msi_handlers: u_int,
}
#[test]
fn bindgen_test_layout_pcicfg_msi() {
    assert_eq!(::core::mem::size_of::<pcicfg_msi>() , 24usize , concat ! (
               "Size of: " , stringify ! ( pcicfg_msi ) ));
    assert_eq! (::core::mem::align_of::<pcicfg_msi>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pcicfg_msi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_msi ) ) . msi_ctrl as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_msi ) , "::" ,
                stringify ! ( msi_ctrl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_msi ) ) . msi_location as * const
                _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_msi ) , "::" ,
                stringify ! ( msi_location ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_msi ) ) . msi_msgnum as * const _
                as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_msi ) , "::" ,
                stringify ! ( msi_msgnum ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_msi ) ) . msi_alloc as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_msi ) , "::" ,
                stringify ! ( msi_alloc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_msi ) ) . msi_addr as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_msi ) , "::" ,
                stringify ! ( msi_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_msi ) ) . msi_data as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_msi ) , "::" ,
                stringify ! ( msi_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_msi ) ) . msi_handlers as * const
                _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_msi ) , "::" ,
                stringify ! ( msi_handlers ) ));
}
impl Clone for pcicfg_msi {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct msix_vector {
    pub mv_address: u64,
    pub mv_data: u32,
    pub mv_irq: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_msix_vector() {
    assert_eq!(::core::mem::size_of::<msix_vector>() , 16usize , concat ! (
               "Size of: " , stringify ! ( msix_vector ) ));
    assert_eq! (::core::mem::align_of::<msix_vector>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( msix_vector ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msix_vector ) ) . mv_address as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( msix_vector ) , "::" ,
                stringify ! ( mv_address ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msix_vector ) ) . mv_data as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( msix_vector ) , "::" ,
                stringify ! ( mv_data ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msix_vector ) ) . mv_irq as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( msix_vector ) , "::" ,
                stringify ! ( mv_irq ) ));
}
impl Clone for msix_vector {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct msix_table_entry {
    pub mte_vector: u_int,
    pub mte_handlers: u_int,
}
#[test]
fn bindgen_test_layout_msix_table_entry() {
    assert_eq!(::core::mem::size_of::<msix_table_entry>() , 8usize , concat !
               ( "Size of: " , stringify ! ( msix_table_entry ) ));
    assert_eq! (::core::mem::align_of::<msix_table_entry>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( msix_table_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msix_table_entry ) ) . mte_vector as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( msix_table_entry ) ,
                "::" , stringify ! ( mte_vector ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const msix_table_entry ) ) . mte_handlers as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( msix_table_entry ) ,
                "::" , stringify ! ( mte_handlers ) ));
}
impl Clone for msix_table_entry {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pcicfg_msix {
    pub msix_ctrl: u16,
    pub msix_msgnum: u16,
    pub msix_location: u8,
    pub msix_table_bar: u8,
    pub msix_pba_bar: u8,
    pub msix_table_offset: u32,
    pub msix_pba_offset: u32,
    pub msix_alloc: ::kernel::sys::raw::c_int,
    pub msix_table_len: ::kernel::sys::raw::c_int,
    pub msix_table: *mut msix_table_entry,
    pub msix_vectors: *mut msix_vector,
    pub msix_table_res: *mut resource,
    pub msix_pba_res: *mut resource,
}
#[test]
fn bindgen_test_layout_pcicfg_msix() {
    assert_eq!(::core::mem::size_of::<pcicfg_msix>() , 56usize , concat ! (
               "Size of: " , stringify ! ( pcicfg_msix ) ));
    assert_eq! (::core::mem::align_of::<pcicfg_msix>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pcicfg_msix ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_msix ) ) . msix_ctrl as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_msix ) , "::" ,
                stringify ! ( msix_ctrl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_msix ) ) . msix_msgnum as * const
                _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_msix ) , "::" ,
                stringify ! ( msix_msgnum ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_msix ) ) . msix_location as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_msix ) , "::" ,
                stringify ! ( msix_location ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_msix ) ) . msix_table_bar as *
                const _ as usize } , 5usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_msix ) , "::" ,
                stringify ! ( msix_table_bar ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_msix ) ) . msix_pba_bar as * const
                _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_msix ) , "::" ,
                stringify ! ( msix_pba_bar ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_msix ) ) . msix_table_offset as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_msix ) , "::" ,
                stringify ! ( msix_table_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_msix ) ) . msix_pba_offset as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_msix ) , "::" ,
                stringify ! ( msix_pba_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_msix ) ) . msix_alloc as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_msix ) , "::" ,
                stringify ! ( msix_alloc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_msix ) ) . msix_table_len as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_msix ) , "::" ,
                stringify ! ( msix_table_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_msix ) ) . msix_table as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_msix ) , "::" ,
                stringify ! ( msix_table ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_msix ) ) . msix_vectors as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_msix ) , "::" ,
                stringify ! ( msix_vectors ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_msix ) ) . msix_table_res as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_msix ) , "::" ,
                stringify ! ( msix_table_res ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_msix ) ) . msix_pba_res as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_msix ) , "::" ,
                stringify ! ( msix_pba_res ) ));
}
impl Clone for pcicfg_msix {
    fn clone(&self) -> Self { *self }
}
impl Default for pcicfg_msix {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct pcicfg_ht {
    pub ht_slave: u8,
    pub ht_msimap: u8,
    pub ht_msictrl: u16,
    pub ht_msiaddr: u64,
}
#[test]
fn bindgen_test_layout_pcicfg_ht() {
    assert_eq!(::core::mem::size_of::<pcicfg_ht>() , 16usize , concat ! (
               "Size of: " , stringify ! ( pcicfg_ht ) ));
    assert_eq! (::core::mem::align_of::<pcicfg_ht>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pcicfg_ht ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_ht ) ) . ht_slave as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_ht ) , "::" ,
                stringify ! ( ht_slave ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_ht ) ) . ht_msimap as * const _ as
                usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_ht ) , "::" ,
                stringify ! ( ht_msimap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_ht ) ) . ht_msictrl as * const _
                as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_ht ) , "::" ,
                stringify ! ( ht_msictrl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_ht ) ) . ht_msiaddr as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_ht ) , "::" ,
                stringify ! ( ht_msiaddr ) ));
}
impl Clone for pcicfg_ht {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct pcicfg_pcie {
    pub pcie_location: u8,
    pub pcie_type: u8,
    pub pcie_flags: u16,
    pub pcie_device_ctl: u16,
    pub pcie_link_ctl: u16,
    pub pcie_slot_ctl: u16,
    pub pcie_root_ctl: u16,
    pub pcie_device_ctl2: u16,
    pub pcie_link_ctl2: u16,
    pub pcie_slot_ctl2: u16,
}
#[test]
fn bindgen_test_layout_pcicfg_pcie() {
    assert_eq!(::core::mem::size_of::<pcicfg_pcie>() , 18usize , concat ! (
               "Size of: " , stringify ! ( pcicfg_pcie ) ));
    assert_eq! (::core::mem::align_of::<pcicfg_pcie>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( pcicfg_pcie ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_pcie ) ) . pcie_location as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_pcie ) , "::" ,
                stringify ! ( pcie_location ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_pcie ) ) . pcie_type as * const _
                as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_pcie ) , "::" ,
                stringify ! ( pcie_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_pcie ) ) . pcie_flags as * const _
                as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_pcie ) , "::" ,
                stringify ! ( pcie_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_pcie ) ) . pcie_device_ctl as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_pcie ) , "::" ,
                stringify ! ( pcie_device_ctl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_pcie ) ) . pcie_link_ctl as *
                const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_pcie ) , "::" ,
                stringify ! ( pcie_link_ctl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_pcie ) ) . pcie_slot_ctl as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_pcie ) , "::" ,
                stringify ! ( pcie_slot_ctl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_pcie ) ) . pcie_root_ctl as *
                const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_pcie ) , "::" ,
                stringify ! ( pcie_root_ctl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_pcie ) ) . pcie_device_ctl2 as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_pcie ) , "::" ,
                stringify ! ( pcie_device_ctl2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_pcie ) ) . pcie_link_ctl2 as *
                const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_pcie ) , "::" ,
                stringify ! ( pcie_link_ctl2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_pcie ) ) . pcie_slot_ctl2 as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_pcie ) , "::" ,
                stringify ! ( pcie_slot_ctl2 ) ));
}
impl Clone for pcicfg_pcie {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct pcicfg_pcix {
    pub pcix_command: u16,
    pub pcix_location: u8,
}
#[test]
fn bindgen_test_layout_pcicfg_pcix() {
    assert_eq!(::core::mem::size_of::<pcicfg_pcix>() , 4usize , concat ! (
               "Size of: " , stringify ! ( pcicfg_pcix ) ));
    assert_eq! (::core::mem::align_of::<pcicfg_pcix>() , 2usize , concat ! (
                "Alignment of " , stringify ! ( pcicfg_pcix ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_pcix ) ) . pcix_command as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_pcix ) , "::" ,
                stringify ! ( pcix_command ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_pcix ) ) . pcix_location as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_pcix ) , "::" ,
                stringify ! ( pcix_location ) ));
}
impl Clone for pcicfg_pcix {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct pcicfg_vf {
    pub index: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_pcicfg_vf() {
    assert_eq!(::core::mem::size_of::<pcicfg_vf>() , 4usize , concat ! (
               "Size of: " , stringify ! ( pcicfg_vf ) ));
    assert_eq! (::core::mem::align_of::<pcicfg_vf>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( pcicfg_vf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_vf ) ) . index as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_vf ) , "::" ,
                stringify ! ( index ) ));
}
impl Clone for pcicfg_vf {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pci_ea_entry {
    pub eae_bei: ::kernel::sys::raw::c_int,
    pub eae_flags: u32,
    pub eae_base: u64,
    pub eae_max_offset: u64,
    pub eae_cfg_offset: u32,
    pub eae_link: pci_ea_entry__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pci_ea_entry__bindgen_ty_1 {
    pub stqe_next: *mut pci_ea_entry,
}
#[test]
fn bindgen_test_layout_pci_ea_entry__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<pci_ea_entry__bindgen_ty_1>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( pci_ea_entry__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<pci_ea_entry__bindgen_ty_1>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( pci_ea_entry__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_ea_entry__bindgen_ty_1 ) ) .
                stqe_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pci_ea_entry__bindgen_ty_1 ) , "::" , stringify ! ( stqe_next
                ) ));
}
impl Clone for pci_ea_entry__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for pci_ea_entry__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_pci_ea_entry() {
    assert_eq!(::core::mem::size_of::<pci_ea_entry>() , 40usize , concat ! (
               "Size of: " , stringify ! ( pci_ea_entry ) ));
    assert_eq! (::core::mem::align_of::<pci_ea_entry>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pci_ea_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_ea_entry ) ) . eae_bei as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pci_ea_entry ) , "::" ,
                stringify ! ( eae_bei ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_ea_entry ) ) . eae_flags as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( pci_ea_entry ) , "::" ,
                stringify ! ( eae_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_ea_entry ) ) . eae_base as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pci_ea_entry ) , "::" ,
                stringify ! ( eae_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_ea_entry ) ) . eae_max_offset as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( pci_ea_entry ) , "::" ,
                stringify ! ( eae_max_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_ea_entry ) ) . eae_cfg_offset as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( pci_ea_entry ) , "::" ,
                stringify ! ( eae_cfg_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pci_ea_entry ) ) . eae_link as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( pci_ea_entry ) , "::" ,
                stringify ! ( eae_link ) ));
}
impl Clone for pci_ea_entry {
    fn clone(&self) -> Self { *self }
}
impl Default for pci_ea_entry {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pcicfg_ea {
    pub ea_location: ::kernel::sys::raw::c_int,
    pub ea_entries: pcicfg_ea__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pcicfg_ea__bindgen_ty_1 {
    pub stqh_first: *mut pci_ea_entry,
    pub stqh_last: *mut *mut pci_ea_entry,
}
#[test]
fn bindgen_test_layout_pcicfg_ea__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<pcicfg_ea__bindgen_ty_1>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( pcicfg_ea__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<pcicfg_ea__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( pcicfg_ea__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_ea__bindgen_ty_1 ) ) . stqh_first
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_ea__bindgen_ty_1
                ) , "::" , stringify ! ( stqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_ea__bindgen_ty_1 ) ) . stqh_last
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_ea__bindgen_ty_1
                ) , "::" , stringify ! ( stqh_last ) ));
}
impl Clone for pcicfg_ea__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for pcicfg_ea__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_pcicfg_ea() {
    assert_eq!(::core::mem::size_of::<pcicfg_ea>() , 24usize , concat ! (
               "Size of: " , stringify ! ( pcicfg_ea ) ));
    assert_eq! (::core::mem::align_of::<pcicfg_ea>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pcicfg_ea ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_ea ) ) . ea_location as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_ea ) , "::" ,
                stringify ! ( ea_location ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg_ea ) ) . ea_entries as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg_ea ) , "::" ,
                stringify ! ( ea_entries ) ));
}
impl Clone for pcicfg_ea {
    fn clone(&self) -> Self { *self }
}
impl Default for pcicfg_ea {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pcicfg {
    pub dev: device_t,
    pub maps: pcicfg__bindgen_ty_1,
    pub subvendor: u16,
    pub subdevice: u16,
    pub vendor: u16,
    pub device: u16,
    pub cmdreg: u16,
    pub statreg: u16,
    pub baseclass: u8,
    pub subclass: u8,
    pub progif: u8,
    pub revid: u8,
    pub hdrtype: u8,
    pub cachelnsz: u8,
    pub intpin: u8,
    pub intline: u8,
    pub mingnt: u8,
    pub maxlat: u8,
    pub lattimer: u8,
    pub mfdev: u8,
    pub nummaps: u8,
    pub domain: u32,
    pub bus: u8,
    pub slot: u8,
    pub func: u8,
    pub flags: u32,
    pub bridge: pcicfg_bridge,
    pub pp: pcicfg_pp,
    pub vpd: pcicfg_vpd,
    pub msi: pcicfg_msi,
    pub msix: pcicfg_msix,
    pub ht: pcicfg_ht,
    pub pcie: pcicfg_pcie,
    pub pcix: pcicfg_pcix,
    pub iov: *mut pcicfg_iov,
    pub vf: pcicfg_vf,
    pub ea: pcicfg_ea,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pcicfg__bindgen_ty_1 {
    pub stqh_first: *mut pci_map,
    pub stqh_last: *mut *mut pci_map,
}
#[test]
fn bindgen_test_layout_pcicfg__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<pcicfg__bindgen_ty_1>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( pcicfg__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<pcicfg__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( pcicfg__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg__bindgen_ty_1 ) ) . stqh_first as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg__bindgen_ty_1 )
                , "::" , stringify ! ( stqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg__bindgen_ty_1 ) ) . stqh_last as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg__bindgen_ty_1 )
                , "::" , stringify ! ( stqh_last ) ));
}
impl Clone for pcicfg__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for pcicfg__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_pcicfg() {
    assert_eq!(::core::mem::size_of::<pcicfg>() , 288usize , concat ! (
               "Size of: " , stringify ! ( pcicfg ) ));
    assert_eq! (::core::mem::align_of::<pcicfg>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pcicfg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . dev as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( dev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . maps as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( maps ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . subvendor as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( subvendor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . subdevice as * const _ as
                usize } , 26usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( subdevice ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . vendor as * const _ as usize
                } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( vendor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . device as * const _ as usize
                } , 30usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( device ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . cmdreg as * const _ as usize
                } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( cmdreg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . statreg as * const _ as
                usize } , 34usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( statreg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . baseclass as * const _ as
                usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( baseclass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . subclass as * const _ as
                usize } , 37usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( subclass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . progif as * const _ as usize
                } , 38usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( progif ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . revid as * const _ as usize
                } , 39usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( revid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . hdrtype as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( hdrtype ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . cachelnsz as * const _ as
                usize } , 41usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( cachelnsz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . intpin as * const _ as usize
                } , 42usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( intpin ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . intline as * const _ as
                usize } , 43usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( intline ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . mingnt as * const _ as usize
                } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( mingnt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . maxlat as * const _ as usize
                } , 45usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( maxlat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . lattimer as * const _ as
                usize } , 46usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( lattimer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . mfdev as * const _ as usize
                } , 47usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( mfdev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . nummaps as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( nummaps ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . domain as * const _ as usize
                } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( domain ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . bus as * const _ as usize }
                , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( bus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . slot as * const _ as usize }
                , 57usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( slot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . func as * const _ as usize }
                , 58usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . flags as * const _ as usize
                } , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . bridge as * const _ as usize
                } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( bridge ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . pp as * const _ as usize } ,
                70usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( pp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . vpd as * const _ as usize }
                , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( vpd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . msi as * const _ as usize }
                , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( msi ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . msix as * const _ as usize }
                , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( msix ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . ht as * const _ as usize } ,
                208usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( ht ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . pcie as * const _ as usize }
                , 224usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( pcie ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . pcix as * const _ as usize }
                , 242usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( pcix ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . iov as * const _ as usize }
                , 248usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( iov ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . vf as * const _ as usize } ,
                256usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( vf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcicfg ) ) . ea as * const _ as usize } ,
                264usize , concat ! (
                "Alignment of field: " , stringify ! ( pcicfg ) , "::" ,
                stringify ! ( ea ) ));
}
impl Clone for pcicfg {
    fn clone(&self) -> Self { *self }
}
impl Default for pcicfg {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
pub type pcicfgregs = pcicfg;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct pcih1cfgregs {
    pub pmembase: pci_addr_t,
    pub pmemlimit: pci_addr_t,
    pub membase: u32,
    pub memlimit: u32,
    pub iobase: u32,
    pub iolimit: u32,
    pub secstat: u16,
    pub bridgectl: u16,
    pub seclat: u8,
}
#[test]
fn bindgen_test_layout_pcih1cfgregs() {
    assert_eq!(::core::mem::size_of::<pcih1cfgregs>() , 40usize , concat ! (
               "Size of: " , stringify ! ( pcih1cfgregs ) ));
    assert_eq! (::core::mem::align_of::<pcih1cfgregs>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pcih1cfgregs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcih1cfgregs ) ) . pmembase as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pcih1cfgregs ) , "::" ,
                stringify ! ( pmembase ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcih1cfgregs ) ) . pmemlimit as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pcih1cfgregs ) , "::" ,
                stringify ! ( pmemlimit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcih1cfgregs ) ) . membase as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( pcih1cfgregs ) , "::" ,
                stringify ! ( membase ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcih1cfgregs ) ) . memlimit as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( pcih1cfgregs ) , "::" ,
                stringify ! ( memlimit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcih1cfgregs ) ) . iobase as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( pcih1cfgregs ) , "::" ,
                stringify ! ( iobase ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcih1cfgregs ) ) . iolimit as * const _
                as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( pcih1cfgregs ) , "::" ,
                stringify ! ( iolimit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcih1cfgregs ) ) . secstat as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( pcih1cfgregs ) , "::" ,
                stringify ! ( secstat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcih1cfgregs ) ) . bridgectl as * const _
                as usize } , 34usize , concat ! (
                "Alignment of field: " , stringify ! ( pcih1cfgregs ) , "::" ,
                stringify ! ( bridgectl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcih1cfgregs ) ) . seclat as * const _ as
                usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( pcih1cfgregs ) , "::" ,
                stringify ! ( seclat ) ));
}
impl Clone for pcih1cfgregs {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct pcih2cfgregs {
    pub membase0: u32,
    pub memlimit0: u32,
    pub membase1: u32,
    pub memlimit1: u32,
    pub iobase0: u32,
    pub iolimit0: u32,
    pub iobase1: u32,
    pub iolimit1: u32,
    pub pccardif: u32,
    pub secstat: u16,
    pub bridgectl: u16,
    pub seclat: u8,
}
#[test]
fn bindgen_test_layout_pcih2cfgregs() {
    assert_eq!(::core::mem::size_of::<pcih2cfgregs>() , 44usize , concat ! (
               "Size of: " , stringify ! ( pcih2cfgregs ) ));
    assert_eq! (::core::mem::align_of::<pcih2cfgregs>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( pcih2cfgregs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcih2cfgregs ) ) . membase0 as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pcih2cfgregs ) , "::" ,
                stringify ! ( membase0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcih2cfgregs ) ) . memlimit0 as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( pcih2cfgregs ) , "::" ,
                stringify ! ( memlimit0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcih2cfgregs ) ) . membase1 as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pcih2cfgregs ) , "::" ,
                stringify ! ( membase1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcih2cfgregs ) ) . memlimit1 as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( pcih2cfgregs ) , "::" ,
                stringify ! ( memlimit1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcih2cfgregs ) ) . iobase0 as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( pcih2cfgregs ) , "::" ,
                stringify ! ( iobase0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcih2cfgregs ) ) . iolimit0 as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( pcih2cfgregs ) , "::" ,
                stringify ! ( iolimit0 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcih2cfgregs ) ) . iobase1 as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( pcih2cfgregs ) , "::" ,
                stringify ! ( iobase1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcih2cfgregs ) ) . iolimit1 as * const _
                as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( pcih2cfgregs ) , "::" ,
                stringify ! ( iolimit1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcih2cfgregs ) ) . pccardif as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( pcih2cfgregs ) , "::" ,
                stringify ! ( pccardif ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcih2cfgregs ) ) . secstat as * const _
                as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( pcih2cfgregs ) , "::" ,
                stringify ! ( secstat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcih2cfgregs ) ) . bridgectl as * const _
                as usize } , 38usize , concat ! (
                "Alignment of field: " , stringify ! ( pcih2cfgregs ) , "::" ,
                stringify ! ( bridgectl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pcih2cfgregs ) ) . seclat as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( pcih2cfgregs ) , "::" ,
                stringify ! ( seclat ) ));
}
impl Clone for pcih2cfgregs {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "pci_numdevs"]
    pub static mut pci_numdevs: u32;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pci_id_type { PCI_ID_RID = 0, PCI_ID_MSI = 1, }
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pci_feature { PCI_FEATURE_HP = 0, PCI_FEATURE_AER = 1, }
extern "C" {
    #[link_name = "pci_read_config_desc"]
    pub static mut pci_read_config_desc: kobjop_desc;
}
/// @brief A function implementing the PCI_READ_CONFIG() method
pub type pci_read_config_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t,
                                                child: device_t,
                                                reg:
                                                    ::kernel::sys::raw::c_int,
                                                width:
                                                    ::kernel::sys::raw::c_int)
                               -> u_int32_t>;
extern "C" {
    #[link_name = "pci_write_config_desc"]
    pub static mut pci_write_config_desc: kobjop_desc;
}
/// @brief A function implementing the PCI_WRITE_CONFIG() method
pub type pci_write_config_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t,
                                                child: device_t,
                                                reg:
                                                    ::kernel::sys::raw::c_int,
                                                val: u_int32_t,
                                                width:
                                                    ::kernel::sys::raw::c_int)>;
extern "C" {
    #[link_name = "pci_get_powerstate_desc"]
    pub static mut pci_get_powerstate_desc: kobjop_desc;
}
/// @brief A function implementing the PCI_GET_POWERSTATE() method
pub type pci_get_powerstate_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t,
                                                child: device_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "pci_set_powerstate_desc"]
    pub static mut pci_set_powerstate_desc: kobjop_desc;
}
/// @brief A function implementing the PCI_SET_POWERSTATE() method
pub type pci_set_powerstate_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t,
                                                child: device_t,
                                                state:
                                                    ::kernel::sys::raw::c_int)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "pci_get_vpd_ident_desc"]
    pub static mut pci_get_vpd_ident_desc: kobjop_desc;
}
/// @brief A function implementing the PCI_GET_VPD_IDENT() method
pub type pci_get_vpd_ident_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t,
                                                child: device_t,
                                                identptr:
                                                    *mut *const ::kernel::sys::raw::c_char)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "pci_get_vpd_readonly_desc"]
    pub static mut pci_get_vpd_readonly_desc: kobjop_desc;
}
/// @brief A function implementing the PCI_GET_VPD_READONLY() method
pub type pci_get_vpd_readonly_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t,
                                                child: device_t,
                                                kw:
                                                    *const ::kernel::sys::raw::c_char,
                                                vptr:
                                                    *mut *const ::kernel::sys::raw::c_char)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "pci_enable_busmaster_desc"]
    pub static mut pci_enable_busmaster_desc: kobjop_desc;
}
/// @brief A function implementing the PCI_ENABLE_BUSMASTER() method
pub type pci_enable_busmaster_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t,
                                                child: device_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "pci_disable_busmaster_desc"]
    pub static mut pci_disable_busmaster_desc: kobjop_desc;
}
/// @brief A function implementing the PCI_DISABLE_BUSMASTER() method
pub type pci_disable_busmaster_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t,
                                                child: device_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "pci_enable_io_desc"]
    pub static mut pci_enable_io_desc: kobjop_desc;
}
/// @brief A function implementing the PCI_ENABLE_IO() method
pub type pci_enable_io_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t,
                                                child: device_t,
                                                space:
                                                    ::kernel::sys::raw::c_int)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "pci_disable_io_desc"]
    pub static mut pci_disable_io_desc: kobjop_desc;
}
/// @brief A function implementing the PCI_DISABLE_IO() method
pub type pci_disable_io_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t,
                                                child: device_t,
                                                space:
                                                    ::kernel::sys::raw::c_int)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "pci_assign_interrupt_desc"]
    pub static mut pci_assign_interrupt_desc: kobjop_desc;
}
/// @brief A function implementing the PCI_ASSIGN_INTERRUPT() method
pub type pci_assign_interrupt_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t,
                                                child: device_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "pci_find_cap_desc"]
    pub static mut pci_find_cap_desc: kobjop_desc;
}
/// @brief A function implementing the PCI_FIND_CAP() method
pub type pci_find_cap_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t,
                                                child: device_t,
                                                capability:
                                                    ::kernel::sys::raw::c_int,
                                                capreg:
                                                    *mut ::kernel::sys::raw::c_int)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "pci_find_next_cap_desc"]
    pub static mut pci_find_next_cap_desc: kobjop_desc;
}
/// @brief A function implementing the PCI_FIND_NEXT_CAP() method
pub type pci_find_next_cap_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t,
                                                child: device_t,
                                                capability:
                                                    ::kernel::sys::raw::c_int,
                                                start:
                                                    ::kernel::sys::raw::c_int,
                                                capreg:
                                                    *mut ::kernel::sys::raw::c_int)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "pci_find_extcap_desc"]
    pub static mut pci_find_extcap_desc: kobjop_desc;
}
/// @brief A function implementing the PCI_FIND_EXTCAP() method
pub type pci_find_extcap_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t,
                                                child: device_t,
                                                capability:
                                                    ::kernel::sys::raw::c_int,
                                                capreg:
                                                    *mut ::kernel::sys::raw::c_int)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "pci_find_next_extcap_desc"]
    pub static mut pci_find_next_extcap_desc: kobjop_desc;
}
/// @brief A function implementing the PCI_FIND_NEXT_EXTCAP() method
pub type pci_find_next_extcap_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t,
                                                child: device_t,
                                                capability:
                                                    ::kernel::sys::raw::c_int,
                                                start:
                                                    ::kernel::sys::raw::c_int,
                                                capreg:
                                                    *mut ::kernel::sys::raw::c_int)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "pci_find_htcap_desc"]
    pub static mut pci_find_htcap_desc: kobjop_desc;
}
/// @brief A function implementing the PCI_FIND_HTCAP() method
pub type pci_find_htcap_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t,
                                                child: device_t,
                                                capability:
                                                    ::kernel::sys::raw::c_int,
                                                capreg:
                                                    *mut ::kernel::sys::raw::c_int)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "pci_find_next_htcap_desc"]
    pub static mut pci_find_next_htcap_desc: kobjop_desc;
}
/// @brief A function implementing the PCI_FIND_NEXT_HTCAP() method
pub type pci_find_next_htcap_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t,
                                                child: device_t,
                                                capability:
                                                    ::kernel::sys::raw::c_int,
                                                start:
                                                    ::kernel::sys::raw::c_int,
                                                capreg:
                                                    *mut ::kernel::sys::raw::c_int)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "pci_alloc_msi_desc"]
    pub static mut pci_alloc_msi_desc: kobjop_desc;
}
/// @brief A function implementing the PCI_ALLOC_MSI() method
pub type pci_alloc_msi_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t,
                                                child: device_t,
                                                count:
                                                    *mut ::kernel::sys::raw::c_int)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "pci_alloc_msix_desc"]
    pub static mut pci_alloc_msix_desc: kobjop_desc;
}
/// @brief A function implementing the PCI_ALLOC_MSIX() method
pub type pci_alloc_msix_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t,
                                                child: device_t,
                                                count:
                                                    *mut ::kernel::sys::raw::c_int)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "pci_enable_msi_desc"]
    pub static mut pci_enable_msi_desc: kobjop_desc;
}
/// @brief A function implementing the PCI_ENABLE_MSI() method
pub type pci_enable_msi_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t,
                                                child: device_t, address: u64,
                                                data: u16)>;
extern "C" {
    #[link_name = "pci_enable_msix_desc"]
    pub static mut pci_enable_msix_desc: kobjop_desc;
}
/// @brief A function implementing the PCI_ENABLE_MSIX() method
pub type pci_enable_msix_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t,
                                                child: device_t, index: u_int,
                                                address: u64, data: u32)>;
extern "C" {
    #[link_name = "pci_disable_msi_desc"]
    pub static mut pci_disable_msi_desc: kobjop_desc;
}
/// @brief A function implementing the PCI_DISABLE_MSI() method
pub type pci_disable_msi_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t,
                                                child: device_t)>;
extern "C" {
    #[link_name = "pci_remap_msix_desc"]
    pub static mut pci_remap_msix_desc: kobjop_desc;
}
/// @brief A function implementing the PCI_REMAP_MSIX() method
pub type pci_remap_msix_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t,
                                                child: device_t,
                                                count:
                                                    ::kernel::sys::raw::c_int,
                                                vectors: *const u_int)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "pci_release_msi_desc"]
    pub static mut pci_release_msi_desc: kobjop_desc;
}
/// @brief A function implementing the PCI_RELEASE_MSI() method
pub type pci_release_msi_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t,
                                                child: device_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "pci_msi_count_desc"]
    pub static mut pci_msi_count_desc: kobjop_desc;
}
/// @brief A function implementing the PCI_MSI_COUNT() method
pub type pci_msi_count_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t,
                                                child: device_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "pci_msix_count_desc"]
    pub static mut pci_msix_count_desc: kobjop_desc;
}
/// @brief A function implementing the PCI_MSIX_COUNT() method
pub type pci_msix_count_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t,
                                                child: device_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "pci_msix_pba_bar_desc"]
    pub static mut pci_msix_pba_bar_desc: kobjop_desc;
}
/// @brief A function implementing the PCI_MSIX_PBA_BAR() method
pub type pci_msix_pba_bar_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t,
                                                child: device_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "pci_msix_table_bar_desc"]
    pub static mut pci_msix_table_bar_desc: kobjop_desc;
}
/// @brief A function implementing the PCI_MSIX_TABLE_BAR() method
pub type pci_msix_table_bar_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t,
                                                child: device_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "pci_get_id_desc"]
    pub static mut pci_get_id_desc: kobjop_desc;
}
/// @brief A function implementing the PCI_GET_ID() method
pub type pci_get_id_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t,
                                                child: device_t,
                                                type_: pci_id_type,
                                                id: *mut usize)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "pci_alloc_devinfo_desc"]
    pub static mut pci_alloc_devinfo_desc: kobjop_desc;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pci_devinfo {
    _unused: [u8; 0],
}
/// @brief A function implementing the PCI_ALLOC_DEVINFO() method
pub type pci_alloc_devinfo_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t)
                               -> *mut pci_devinfo>;
extern "C" {
    #[link_name = "pci_child_added_desc"]
    pub static mut pci_child_added_desc: kobjop_desc;
}
/// @brief A function implementing the PCI_CHILD_ADDED() method
pub type pci_child_added_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t,
                                                child: device_t)>;
extern "C" {
    #[link_name = "pci_iov_attach_desc"]
    pub static mut pci_iov_attach_desc: kobjop_desc;
}
/// @brief A function implementing the PCI_IOV_ATTACH() method
pub type pci_iov_attach_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t,
                                                child: device_t,
                                                pf_schema: *mut nvlist,
                                                vf_schema: *mut nvlist,
                                                name:
                                                    *const ::kernel::sys::raw::c_char)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "pci_iov_detach_desc"]
    pub static mut pci_iov_detach_desc: kobjop_desc;
}
/// @brief A function implementing the PCI_IOV_DETACH() method
pub type pci_iov_detach_t =
    ::core::option::Option<unsafe extern "C" fn(dev: device_t,
                                                child: device_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "pci_create_iov_child_desc"]
    pub static mut pci_create_iov_child_desc: kobjop_desc;
}
/// @brief A function implementing the PCI_CREATE_IOV_CHILD() method
pub type pci_create_iov_child_t =
    ::core::option::Option<unsafe extern "C" fn(bus: device_t, pf: device_t,
                                                rid: u16, vid: u16, did: u16)
                               -> device_t>;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pci_device_ivars {
    PCI_IVAR_SUBVENDOR = 0,
    PCI_IVAR_SUBDEVICE = 1,
    PCI_IVAR_VENDOR = 2,
    PCI_IVAR_DEVICE = 3,
    PCI_IVAR_DEVID = 4,
    PCI_IVAR_CLASS = 5,
    PCI_IVAR_SUBCLASS = 6,
    PCI_IVAR_PROGIF = 7,
    PCI_IVAR_REVID = 8,
    PCI_IVAR_INTPIN = 9,
    PCI_IVAR_IRQ = 10,
    PCI_IVAR_DOMAIN = 11,
    PCI_IVAR_BUS = 12,
    PCI_IVAR_SLOT = 13,
    PCI_IVAR_FUNCTION = 14,
    PCI_IVAR_ETHADDR = 15,
    PCI_IVAR_CMDREG = 16,
    PCI_IVAR_CACHELNSZ = 17,
    PCI_IVAR_MINGNT = 18,
    PCI_IVAR_MAXLAT = 19,
    PCI_IVAR_LATTIMER = 20,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pcib_device_ivars { PCIB_IVAR_DOMAIN = 0, PCIB_IVAR_BUS = 1, }
extern "C" {
    pub fn pci_find_bsf(arg1: u8, arg2: u8, arg3: u8) -> device_t;
}
extern "C" {
    pub fn pci_find_dbsf(arg1: u32, arg2: u8, arg3: u8, arg4: u8) -> device_t;
}
extern "C" {
    pub fn pci_find_device(arg1: u16, arg2: u16) -> device_t;
}
extern "C" {
    pub fn pci_find_class(class: u8, subclass: u8) -> device_t;
}
extern "C" {
    pub fn pci_pending_msix(dev: device_t, index: u_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn pci_msi_device_blacklisted(dev: device_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn pci_msix_device_blacklisted(dev: device_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn pci_ht_map_msi(dev: device_t, addr: u64);
}
extern "C" {
    pub fn pci_find_pcie_root_port(dev: device_t) -> device_t;
}
extern "C" {
    pub fn pci_get_max_payload(dev: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn pci_get_max_read_req(dev: device_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn pci_restore_state(dev: device_t);
}
extern "C" {
    pub fn pci_save_state(dev: device_t);
}
extern "C" {
    pub fn pci_set_max_read_req(dev: device_t,
                                size: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn pcie_read_config(dev: device_t, reg: ::kernel::sys::raw::c_int,
                            width: ::kernel::sys::raw::c_int) -> u32;
}
extern "C" {
    pub fn pcie_write_config(dev: device_t, reg: ::kernel::sys::raw::c_int,
                             value: u32, width: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn pcie_adjust_config(dev: device_t, reg: ::kernel::sys::raw::c_int,
                              mask: u32, value: u32,
                              width: ::kernel::sys::raw::c_int) -> u32;
}
extern "C" {
    pub fn pcie_flr(dev: device_t, max_delay: u_int, force: bool_) -> bool_;
}
extern "C" {
    pub fn pcie_get_max_completion_timeout(dev: device_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn pcie_wait_for_pending_transactions(dev: device_t, max_delay: u_int)
     -> bool_;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cdevsw {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "pcicdev"]
    pub static mut pcicdev: cdevsw;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct devlist {
    pub stqh_first: *mut pci_devinfo,
    pub stqh_last: *mut *mut pci_devinfo,
}
#[test]
fn bindgen_test_layout_devlist() {
    assert_eq!(::core::mem::size_of::<devlist>() , 16usize , concat ! (
               "Size of: " , stringify ! ( devlist ) ));
    assert_eq! (::core::mem::align_of::<devlist>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( devlist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const devlist ) ) . stqh_first as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( devlist ) , "::" ,
                stringify ! ( stqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const devlist ) ) . stqh_last as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( devlist ) , "::" ,
                stringify ! ( stqh_last ) ));
}
impl Clone for devlist {
    fn clone(&self) -> Self { *self }
}
impl Default for devlist {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    #[link_name = "pci_devq"]
    pub static mut pci_devq: devlist;
}
extern "C" {
    #[link_name = "pci_generation"]
    pub static mut pci_generation: u32;
}
extern "C" {
    pub fn pci_find_bar(dev: device_t, reg: ::kernel::sys::raw::c_int)
     -> *mut pci_map;
}
extern "C" {
    pub fn pci_bar_enabled(dev: device_t, pm: *mut pci_map)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn pci_fetch_vpd_list(dev: device_t) -> *mut pcicfg_vpd;
}
extern "C" {
    pub fn vga_pci_is_boot_display(dev: device_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn vga_pci_map_bios(dev: device_t, size: *mut usize)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn vga_pci_unmap_bios(dev: device_t,
                              bios: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn vga_pci_repost(dev: device_t) -> ::kernel::sys::raw::c_int;
}
/// Global eventhandlers invoked when PCI devices are added or removed
/// from the system.
pub type pci_event_fn =
    ::core::option::Option<unsafe extern "C" fn(arg:
                                                    *mut ::kernel::sys::raw::c_void,
                                                dev: device_t)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_pci_add_device {
    pub ee: eventhandler_entry,
    pub eh_func: pci_event_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_pci_add_device() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_pci_add_device>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( eventhandler_entry_pci_add_device )
               ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_pci_add_device>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_pci_add_device ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_pci_add_device ) ) .
                ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_pci_add_device ) , "::" , stringify ! ( ee
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_pci_add_device ) ) .
                eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_pci_add_device ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_pci_add_device {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_pci_add_device {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct eventhandler_entry_pci_delete_device {
    pub ee: eventhandler_entry,
    pub eh_func: pci_event_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_pci_delete_device() {
    assert_eq!(::core::mem::size_of::<eventhandler_entry_pci_delete_device>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               eventhandler_entry_pci_delete_device ) ));
    assert_eq! (::core::mem::align_of::<eventhandler_entry_pci_delete_device>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                eventhandler_entry_pci_delete_device ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_pci_delete_device ) )
                . ee as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_pci_delete_device ) , "::" , stringify ! (
                ee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const eventhandler_entry_pci_delete_device ) )
                . eh_func as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                eventhandler_entry_pci_delete_device ) , "::" , stringify ! (
                eh_func ) ));
}
impl Clone for eventhandler_entry_pci_delete_device {
    fn clone(&self) -> Self { *self }
}
impl Default for eventhandler_entry_pci_delete_device {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kaiocb {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockopt {
    _unused: [u8; 0],
}
pub type pr_input_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut *mut mbuf,
                                                arg2:
                                                    *mut ::kernel::sys::raw::c_int,
                                                arg3:
                                                    ::kernel::sys::raw::c_int)
                               -> ::kernel::sys::raw::c_int>;
pub type pr_output_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut mbuf,
                                                arg2: *mut socket, ...)
                               -> ::kernel::sys::raw::c_int>;
pub type pr_ctlinput_t =
    ::core::option::Option<unsafe extern "C" fn(arg1:
                                                    ::kernel::sys::raw::c_int,
                                                arg2: *mut sockaddr,
                                                arg3:
                                                    *mut ::kernel::sys::raw::c_void)>;
pub type pr_ctloutput_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut socket,
                                                arg2: *mut sockopt)
                               -> ::kernel::sys::raw::c_int>;
pub type pr_init_t = ::core::option::Option<unsafe extern "C" fn()>;
pub type pr_fasttimo_t = ::core::option::Option<unsafe extern "C" fn()>;
pub type pr_slowtimo_t = ::core::option::Option<unsafe extern "C" fn()>;
pub type pr_drain_t = ::core::option::Option<unsafe extern "C" fn()>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stat {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pr_usrreqs {
    pub pru_abort: ::core::option::Option<unsafe extern "C" fn(so:
                                                                   *mut socket)>,
    pub pru_accept: ::core::option::Option<unsafe extern "C" fn(so:
                                                                    *mut socket,
                                                                nam:
                                                                    *mut *mut sockaddr)
                                               -> ::kernel::sys::raw::c_int>,
    pub pru_attach: ::core::option::Option<unsafe extern "C" fn(so:
                                                                    *mut socket,
                                                                proto:
                                                                    ::kernel::sys::raw::c_int,
                                                                td:
                                                                    *mut thread)
                                               -> ::kernel::sys::raw::c_int>,
    pub pru_bind: ::core::option::Option<unsafe extern "C" fn(so: *mut socket,
                                                              nam:
                                                                  *mut sockaddr,
                                                              td: *mut thread)
                                             -> ::kernel::sys::raw::c_int>,
    pub pru_connect: ::core::option::Option<unsafe extern "C" fn(so:
                                                                     *mut socket,
                                                                 nam:
                                                                     *mut sockaddr,
                                                                 td:
                                                                     *mut thread)
                                                -> ::kernel::sys::raw::c_int>,
    pub pru_connect2: ::core::option::Option<unsafe extern "C" fn(so1:
                                                                      *mut socket,
                                                                  so2:
                                                                      *mut socket)
                                                 ->
                                                     ::kernel::sys::raw::c_int>,
    pub pru_control: ::core::option::Option<unsafe extern "C" fn(so:
                                                                     *mut socket,
                                                                 cmd: u_long,
                                                                 data:
                                                                     caddr_t,
                                                                 ifp:
                                                                     *mut ifnet,
                                                                 td:
                                                                     *mut thread)
                                                -> ::kernel::sys::raw::c_int>,
    pub pru_detach: ::core::option::Option<unsafe extern "C" fn(so:
                                                                    *mut socket)>,
    pub pru_disconnect: ::core::option::Option<unsafe extern "C" fn(so:
                                                                        *mut socket)
                                                   ->
                                                       ::kernel::sys::raw::c_int>,
    pub pru_listen: ::core::option::Option<unsafe extern "C" fn(so:
                                                                    *mut socket,
                                                                backlog:
                                                                    ::kernel::sys::raw::c_int,
                                                                td:
                                                                    *mut thread)
                                               -> ::kernel::sys::raw::c_int>,
    pub pru_peeraddr: ::core::option::Option<unsafe extern "C" fn(so:
                                                                      *mut socket,
                                                                  nam:
                                                                      *mut *mut sockaddr)
                                                 ->
                                                     ::kernel::sys::raw::c_int>,
    pub pru_rcvd: ::core::option::Option<unsafe extern "C" fn(so: *mut socket,
                                                              flags:
                                                                  ::kernel::sys::raw::c_int)
                                             -> ::kernel::sys::raw::c_int>,
    pub pru_rcvoob: ::core::option::Option<unsafe extern "C" fn(so:
                                                                    *mut socket,
                                                                m: *mut mbuf,
                                                                flags:
                                                                    ::kernel::sys::raw::c_int)
                                               -> ::kernel::sys::raw::c_int>,
    pub pru_send: ::core::option::Option<unsafe extern "C" fn(so: *mut socket,
                                                              flags:
                                                                  ::kernel::sys::raw::c_int,
                                                              m: *mut mbuf,
                                                              addr:
                                                                  *mut sockaddr,
                                                              control:
                                                                  *mut mbuf,
                                                              td: *mut thread)
                                             -> ::kernel::sys::raw::c_int>,
    pub pru_ready: ::core::option::Option<unsafe extern "C" fn(so:
                                                                   *mut socket,
                                                               m: *mut mbuf,
                                                               count:
                                                                   ::kernel::sys::raw::c_int)
                                              -> ::kernel::sys::raw::c_int>,
    pub pru_sense: ::core::option::Option<unsafe extern "C" fn(so:
                                                                   *mut socket,
                                                               sb: *mut stat)
                                              -> ::kernel::sys::raw::c_int>,
    pub pru_shutdown: ::core::option::Option<unsafe extern "C" fn(so:
                                                                      *mut socket)
                                                 ->
                                                     ::kernel::sys::raw::c_int>,
    pub pru_flush: ::core::option::Option<unsafe extern "C" fn(so:
                                                                   *mut socket,
                                                               direction:
                                                                   ::kernel::sys::raw::c_int)
                                              -> ::kernel::sys::raw::c_int>,
    pub pru_sockaddr: ::core::option::Option<unsafe extern "C" fn(so:
                                                                      *mut socket,
                                                                  nam:
                                                                      *mut *mut sockaddr)
                                                 ->
                                                     ::kernel::sys::raw::c_int>,
    pub pru_sosend: ::core::option::Option<unsafe extern "C" fn(so:
                                                                    *mut socket,
                                                                addr:
                                                                    *mut sockaddr,
                                                                uio: *mut uio,
                                                                top:
                                                                    *mut mbuf,
                                                                control:
                                                                    *mut mbuf,
                                                                flags:
                                                                    ::kernel::sys::raw::c_int,
                                                                td:
                                                                    *mut thread)
                                               -> ::kernel::sys::raw::c_int>,
    pub pru_soreceive: ::core::option::Option<unsafe extern "C" fn(so:
                                                                       *mut socket,
                                                                   paddr:
                                                                       *mut *mut sockaddr,
                                                                   uio:
                                                                       *mut uio,
                                                                   mp0:
                                                                       *mut *mut mbuf,
                                                                   controlp:
                                                                       *mut *mut mbuf,
                                                                   flagsp:
                                                                       *mut ::kernel::sys::raw::c_int)
                                                  ->
                                                      ::kernel::sys::raw::c_int>,
    pub pru_sopoll: ::core::option::Option<unsafe extern "C" fn(so:
                                                                    *mut socket,
                                                                events:
                                                                    ::kernel::sys::raw::c_int,
                                                                cred:
                                                                    *mut ucred,
                                                                td:
                                                                    *mut thread)
                                               -> ::kernel::sys::raw::c_int>,
    pub pru_sosetlabel: ::core::option::Option<unsafe extern "C" fn(so:
                                                                        *mut socket)>,
    pub pru_close: ::core::option::Option<unsafe extern "C" fn(so:
                                                                   *mut socket)>,
    pub pru_bindat: ::core::option::Option<unsafe extern "C" fn(fd:
                                                                    ::kernel::sys::raw::c_int,
                                                                so:
                                                                    *mut socket,
                                                                nam:
                                                                    *mut sockaddr,
                                                                td:
                                                                    *mut thread)
                                               -> ::kernel::sys::raw::c_int>,
    pub pru_connectat: ::core::option::Option<unsafe extern "C" fn(fd:
                                                                       ::kernel::sys::raw::c_int,
                                                                   so:
                                                                       *mut socket,
                                                                   nam:
                                                                       *mut sockaddr,
                                                                   td:
                                                                       *mut thread)
                                                  ->
                                                      ::kernel::sys::raw::c_int>,
    pub pru_aio_queue: ::core::option::Option<unsafe extern "C" fn(so:
                                                                       *mut socket,
                                                                   job:
                                                                       *mut kaiocb)
                                                  ->
                                                      ::kernel::sys::raw::c_int>,
}
#[test]
fn bindgen_test_layout_pr_usrreqs() {
    assert_eq!(::core::mem::size_of::<pr_usrreqs>() , 216usize , concat ! (
               "Size of: " , stringify ! ( pr_usrreqs ) ));
    assert_eq! (::core::mem::align_of::<pr_usrreqs>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pr_usrreqs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pr_usrreqs ) ) . pru_abort as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pr_usrreqs ) , "::" ,
                stringify ! ( pru_abort ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pr_usrreqs ) ) . pru_accept as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pr_usrreqs ) , "::" ,
                stringify ! ( pru_accept ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pr_usrreqs ) ) . pru_attach as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( pr_usrreqs ) , "::" ,
                stringify ! ( pru_attach ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pr_usrreqs ) ) . pru_bind as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( pr_usrreqs ) , "::" ,
                stringify ! ( pru_bind ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pr_usrreqs ) ) . pru_connect as * const _
                as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( pr_usrreqs ) , "::" ,
                stringify ! ( pru_connect ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pr_usrreqs ) ) . pru_connect2 as * const
                _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( pr_usrreqs ) , "::" ,
                stringify ! ( pru_connect2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pr_usrreqs ) ) . pru_control as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( pr_usrreqs ) , "::" ,
                stringify ! ( pru_control ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pr_usrreqs ) ) . pru_detach as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( pr_usrreqs ) , "::" ,
                stringify ! ( pru_detach ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pr_usrreqs ) ) . pru_disconnect as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( pr_usrreqs ) , "::" ,
                stringify ! ( pru_disconnect ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pr_usrreqs ) ) . pru_listen as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( pr_usrreqs ) , "::" ,
                stringify ! ( pru_listen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pr_usrreqs ) ) . pru_peeraddr as * const
                _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( pr_usrreqs ) , "::" ,
                stringify ! ( pru_peeraddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pr_usrreqs ) ) . pru_rcvd as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( pr_usrreqs ) , "::" ,
                stringify ! ( pru_rcvd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pr_usrreqs ) ) . pru_rcvoob as * const _
                as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( pr_usrreqs ) , "::" ,
                stringify ! ( pru_rcvoob ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pr_usrreqs ) ) . pru_send as * const _ as
                usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( pr_usrreqs ) , "::" ,
                stringify ! ( pru_send ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pr_usrreqs ) ) . pru_ready as * const _
                as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( pr_usrreqs ) , "::" ,
                stringify ! ( pru_ready ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pr_usrreqs ) ) . pru_sense as * const _
                as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( pr_usrreqs ) , "::" ,
                stringify ! ( pru_sense ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pr_usrreqs ) ) . pru_shutdown as * const
                _ as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( pr_usrreqs ) , "::" ,
                stringify ! ( pru_shutdown ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pr_usrreqs ) ) . pru_flush as * const _
                as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( pr_usrreqs ) , "::" ,
                stringify ! ( pru_flush ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pr_usrreqs ) ) . pru_sockaddr as * const
                _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( pr_usrreqs ) , "::" ,
                stringify ! ( pru_sockaddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pr_usrreqs ) ) . pru_sosend as * const _
                as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( pr_usrreqs ) , "::" ,
                stringify ! ( pru_sosend ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pr_usrreqs ) ) . pru_soreceive as * const
                _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( pr_usrreqs ) , "::" ,
                stringify ! ( pru_soreceive ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pr_usrreqs ) ) . pru_sopoll as * const _
                as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( pr_usrreqs ) , "::" ,
                stringify ! ( pru_sopoll ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pr_usrreqs ) ) . pru_sosetlabel as *
                const _ as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( pr_usrreqs ) , "::" ,
                stringify ! ( pru_sosetlabel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pr_usrreqs ) ) . pru_close as * const _
                as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( pr_usrreqs ) , "::" ,
                stringify ! ( pru_close ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pr_usrreqs ) ) . pru_bindat as * const _
                as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( pr_usrreqs ) , "::" ,
                stringify ! ( pru_bindat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pr_usrreqs ) ) . pru_connectat as * const
                _ as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( pr_usrreqs ) , "::" ,
                stringify ! ( pru_connectat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pr_usrreqs ) ) . pru_aio_queue as * const
                _ as usize } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( pr_usrreqs ) , "::" ,
                stringify ! ( pru_aio_queue ) ));
}
impl Clone for pr_usrreqs {
    fn clone(&self) -> Self { *self }
}
impl Default for pr_usrreqs {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    pub fn pru_accept_notsupp(so: *mut socket, nam: *mut *mut sockaddr)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn pru_aio_queue_notsupp(so: *mut socket, job: *mut kaiocb)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn pru_attach_notsupp(so: *mut socket,
                              proto: ::kernel::sys::raw::c_int,
                              td: *mut thread) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn pru_bind_notsupp(so: *mut socket, nam: *mut sockaddr,
                            td: *mut thread) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn pru_bindat_notsupp(fd: ::kernel::sys::raw::c_int, so: *mut socket,
                              nam: *mut sockaddr, td: *mut thread)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn pru_connect_notsupp(so: *mut socket, nam: *mut sockaddr,
                               td: *mut thread) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn pru_connectat_notsupp(fd: ::kernel::sys::raw::c_int,
                                 so: *mut socket, nam: *mut sockaddr,
                                 td: *mut thread)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn pru_connect2_notsupp(so1: *mut socket, so2: *mut socket)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn pru_control_notsupp(so: *mut socket, cmd: u_long, data: caddr_t,
                               ifp: *mut ifnet, td: *mut thread)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn pru_disconnect_notsupp(so: *mut socket)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn pru_listen_notsupp(so: *mut socket,
                              backlog: ::kernel::sys::raw::c_int,
                              td: *mut thread) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn pru_peeraddr_notsupp(so: *mut socket, nam: *mut *mut sockaddr)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn pru_rcvd_notsupp(so: *mut socket, flags: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn pru_rcvoob_notsupp(so: *mut socket, m: *mut mbuf,
                              flags: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn pru_send_notsupp(so: *mut socket, flags: ::kernel::sys::raw::c_int,
                            m: *mut mbuf, addr: *mut sockaddr,
                            control: *mut mbuf, td: *mut thread)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn pru_ready_notsupp(so: *mut socket, m: *mut mbuf,
                             count: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn pru_sense_null(so: *mut socket, sb: *mut stat)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn pru_shutdown_notsupp(so: *mut socket) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn pru_sockaddr_notsupp(so: *mut socket, nam: *mut *mut sockaddr)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn pru_sosend_notsupp(so: *mut socket, addr: *mut sockaddr,
                              uio: *mut uio, top: *mut mbuf,
                              control: *mut mbuf,
                              flags: ::kernel::sys::raw::c_int,
                              td: *mut thread) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn pru_soreceive_notsupp(so: *mut socket, paddr: *mut *mut sockaddr,
                                 uio: *mut uio, mp0: *mut *mut mbuf,
                                 controlp: *mut *mut mbuf,
                                 flagsp: *mut ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn pru_sopoll_notsupp(so: *mut socket,
                              events: ::kernel::sys::raw::c_int,
                              cred: *mut ucred, td: *mut thread)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn pfctlinput(arg1: ::kernel::sys::raw::c_int, arg2: *mut sockaddr);
}
extern "C" {
    pub fn pfctlinput2(arg1: ::kernel::sys::raw::c_int, arg2: *mut sockaddr,
                       arg3: *mut ::kernel::sys::raw::c_void);
}
extern "C" {
    pub fn pffinddomain(family: ::kernel::sys::raw::c_int) -> *mut domain;
}
extern "C" {
    pub fn pffindproto(family: ::kernel::sys::raw::c_int,
                       protocol: ::kernel::sys::raw::c_int,
                       type_: ::kernel::sys::raw::c_int) -> *mut protosw;
}
extern "C" {
    pub fn pffindtype(family: ::kernel::sys::raw::c_int,
                      type_: ::kernel::sys::raw::c_int) -> *mut protosw;
}
extern "C" {
    pub fn pf_proto_register(family: ::kernel::sys::raw::c_int,
                             npr: *mut protosw) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn pf_proto_unregister(family: ::kernel::sys::raw::c_int,
                               protocol: ::kernel::sys::raw::c_int,
                               type_: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
pub type vm_inherit_t = ::kernel::sys::raw::c_char;
pub type vm_prot_t = u_char;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum obj_type {
    OBJT_DEFAULT = 0,
    OBJT_SWAP = 1,
    OBJT_VNODE = 2,
    OBJT_DEVICE = 3,
    OBJT_PHYS = 4,
    OBJT_DEAD = 5,
    OBJT_SG = 6,
    OBJT_MGTDEVICE = 7,
}
pub type objtype_t = u_char;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_map_object {
    _unused: [u8; 0],
}
pub type vm_map_object_t = vm_map_object;
pub type vm_map_entry_t = *mut vm_map_entry;
pub type vm_map_t = *mut vm_map;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_object {
    _unused: [u8; 0],
}
pub type vm_object_t = *mut vm_object;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_reserv {
    _unused: [u8; 0],
}
pub type vm_reserv_t = *mut vm_reserv;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct kva_md_info {
    pub buffer_sva: vm_offset_t,
    pub buffer_eva: vm_offset_t,
    pub clean_sva: vm_offset_t,
    pub clean_eva: vm_offset_t,
}
#[test]
fn bindgen_test_layout_kva_md_info() {
    assert_eq!(::core::mem::size_of::<kva_md_info>() , 32usize , concat ! (
               "Size of: " , stringify ! ( kva_md_info ) ));
    assert_eq! (::core::mem::align_of::<kva_md_info>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( kva_md_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kva_md_info ) ) . buffer_sva as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( kva_md_info ) , "::" ,
                stringify ! ( buffer_sva ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kva_md_info ) ) . buffer_eva as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( kva_md_info ) , "::" ,
                stringify ! ( buffer_eva ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kva_md_info ) ) . clean_sva as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( kva_md_info ) , "::" ,
                stringify ! ( clean_sva ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const kva_md_info ) ) . clean_eva as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( kva_md_info ) , "::" ,
                stringify ! ( clean_eva ) ));
}
impl Clone for kva_md_info {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "kmi"]
    pub static mut kmi: kva_md_info;
}
extern "C" {
    pub fn vm_ksubmap_init(arg1: *mut kva_md_info);
}
extern "C" {
    #[link_name = "old_mlock"]
    pub static mut old_mlock: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "vm_ndomains"]
    pub static mut vm_ndomains: ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn swap_reserve(incr: vm_ooffset_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn swap_reserve_by_cred(incr: vm_ooffset_t, cred: *mut ucred)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn swap_reserve_force(incr: vm_ooffset_t);
}
extern "C" {
    pub fn swap_release(decr: vm_ooffset_t);
}
extern "C" {
    pub fn swap_release_by_cred(decr: vm_ooffset_t, cred: *mut ucred);
}
extern "C" {
    pub fn swapper();
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct pmap_statistics {
    pub resident_count: ::kernel::sys::raw::c_long,
    pub wired_count: ::kernel::sys::raw::c_long,
}
#[test]
fn bindgen_test_layout_pmap_statistics() {
    assert_eq!(::core::mem::size_of::<pmap_statistics>() , 16usize , concat !
               ( "Size of: " , stringify ! ( pmap_statistics ) ));
    assert_eq! (::core::mem::align_of::<pmap_statistics>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( pmap_statistics ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pmap_statistics ) ) . resident_count as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pmap_statistics ) ,
                "::" , stringify ! ( resident_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pmap_statistics ) ) . wired_count as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pmap_statistics ) ,
                "::" , stringify ! ( wired_count ) ));
}
impl Clone for pmap_statistics {
    fn clone(&self) -> Self { *self }
}
pub type pmap_statistics_t = *mut pmap_statistics;
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct vm_radix {
    pub rt_root: usize,
}
#[test]
fn bindgen_test_layout_vm_radix() {
    assert_eq!(::core::mem::size_of::<vm_radix>() , 8usize , concat ! (
               "Size of: " , stringify ! ( vm_radix ) ));
    assert_eq! (::core::mem::align_of::<vm_radix>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( vm_radix ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const vm_radix ) ) . rt_root as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( vm_radix ) , "::" ,
                stringify ! ( rt_root ) ));
}
impl Clone for vm_radix {
    fn clone(&self) -> Self { *self }
}
pub type pd_entry_t = u_int64_t;
pub type pt_entry_t = u_int64_t;
pub type pdp_entry_t = u_int64_t;
pub type pml4_entry_t = u_int64_t;
extern "C" {
    #[link_name = "nkpt"]
    pub static mut nkpt: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "KPDPphys"]
    pub static mut KPDPphys: u_int64_t;
}
extern "C" {
    #[link_name = "KPML4phys"]
    pub static mut KPML4phys: u_int64_t;
}
extern "C" {
    pub fn vtopte(arg1: vm_offset_t) -> *mut pt_entry_t;
}
extern "C" {
    #[link_name = "pg_nx"]
    pub static mut pg_nx: pt_entry_t;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pv_entry {
    pub pv_va: vm_offset_t,
    pub pv_next: pv_entry__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pv_entry__bindgen_ty_1 {
    pub tqe_next: *mut pv_entry,
    pub tqe_prev: *mut *mut pv_entry,
}
#[test]
fn bindgen_test_layout_pv_entry__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<pv_entry__bindgen_ty_1>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( pv_entry__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<pv_entry__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( pv_entry__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_entry__bindgen_ty_1 ) ) . tqe_next as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_entry__bindgen_ty_1
                ) , "::" , stringify ! ( tqe_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_entry__bindgen_ty_1 ) ) . tqe_prev as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_entry__bindgen_ty_1
                ) , "::" , stringify ! ( tqe_prev ) ));
}
impl Clone for pv_entry__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for pv_entry__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_pv_entry() {
    assert_eq!(::core::mem::size_of::<pv_entry>() , 24usize , concat ! (
               "Size of: " , stringify ! ( pv_entry ) ));
    assert_eq! (::core::mem::align_of::<pv_entry>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pv_entry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_entry ) ) . pv_va as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_entry ) , "::" ,
                stringify ! ( pv_va ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_entry ) ) . pv_next as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_entry ) , "::" ,
                stringify ! ( pv_next ) ));
}
impl Clone for pv_entry {
    fn clone(&self) -> Self { *self }
}
impl Default for pv_entry {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct pv_chunk {
    pub pc_pmap: pmap_t,
    pub pc_list: pv_chunk__bindgen_ty_1,
    pub pc_map: [u64; 3usize],
    pub pc_lru: pv_chunk__bindgen_ty_2,
    pub pc_pventry: [pv_entry; 168usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pv_chunk__bindgen_ty_1 {
    pub tqe_next: *mut pv_chunk,
    pub tqe_prev: *mut *mut pv_chunk,
}
#[test]
fn bindgen_test_layout_pv_chunk__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<pv_chunk__bindgen_ty_1>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( pv_chunk__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<pv_chunk__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( pv_chunk__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_chunk__bindgen_ty_1 ) ) . tqe_next as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_chunk__bindgen_ty_1
                ) , "::" , stringify ! ( tqe_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_chunk__bindgen_ty_1 ) ) . tqe_prev as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_chunk__bindgen_ty_1
                ) , "::" , stringify ! ( tqe_prev ) ));
}
impl Clone for pv_chunk__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for pv_chunk__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pv_chunk__bindgen_ty_2 {
    pub tqe_next: *mut pv_chunk,
    pub tqe_prev: *mut *mut pv_chunk,
}
#[test]
fn bindgen_test_layout_pv_chunk__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<pv_chunk__bindgen_ty_2>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( pv_chunk__bindgen_ty_2 )
               ));
    assert_eq! (::core::mem::align_of::<pv_chunk__bindgen_ty_2>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( pv_chunk__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_chunk__bindgen_ty_2 ) ) . tqe_next as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_chunk__bindgen_ty_2
                ) , "::" , stringify ! ( tqe_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_chunk__bindgen_ty_2 ) ) . tqe_prev as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_chunk__bindgen_ty_2
                ) , "::" , stringify ! ( tqe_prev ) ));
}
impl Clone for pv_chunk__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for pv_chunk__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_pv_chunk() {
    assert_eq!(::core::mem::size_of::<pv_chunk>() , 4096usize , concat ! (
               "Size of: " , stringify ! ( pv_chunk ) ));
    assert_eq! (::core::mem::align_of::<pv_chunk>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( pv_chunk ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_chunk ) ) . pc_pmap as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_chunk ) , "::" ,
                stringify ! ( pc_pmap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_chunk ) ) . pc_list as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_chunk ) , "::" ,
                stringify ! ( pc_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_chunk ) ) . pc_map as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_chunk ) , "::" ,
                stringify ! ( pc_map ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_chunk ) ) . pc_lru as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_chunk ) , "::" ,
                stringify ! ( pc_lru ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_chunk ) ) . pc_pventry as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_chunk ) , "::" ,
                stringify ! ( pc_pventry ) ));
}
impl Clone for pv_chunk {
    fn clone(&self) -> Self { *self }
}
impl Default for pv_chunk {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for pv_chunk {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "pv_chunk {{ pc_pmap: {:?}, pc_list: {:?}, pc_map: {:?}, pc_lru: {:?}, pc_pventry: [{}] }}"
               , self . pc_pmap , self . pc_list , self . pc_map , self .
               pc_lru , self . pc_pventry . iter (  ) . enumerate (  ) . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ))
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct md_page {
    pub pv_list: md_page__bindgen_ty_1,
    pub pv_gen: ::kernel::sys::raw::c_int,
    pub pat_mode: ::kernel::sys::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct md_page__bindgen_ty_1 {
    pub tqh_first: *mut pv_entry,
    pub tqh_last: *mut *mut pv_entry,
}
#[test]
fn bindgen_test_layout_md_page__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<md_page__bindgen_ty_1>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( md_page__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<md_page__bindgen_ty_1>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( md_page__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const md_page__bindgen_ty_1 ) ) . tqh_first as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( md_page__bindgen_ty_1 )
                , "::" , stringify ! ( tqh_first ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const md_page__bindgen_ty_1 ) ) . tqh_last as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( md_page__bindgen_ty_1 )
                , "::" , stringify ! ( tqh_last ) ));
}
impl Clone for md_page__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for md_page__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_md_page() {
    assert_eq!(::core::mem::size_of::<md_page>() , 24usize , concat ! (
               "Size of: " , stringify ! ( md_page ) ));
    assert_eq! (::core::mem::align_of::<md_page>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( md_page ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const md_page ) ) . pv_list as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( md_page ) , "::" ,
                stringify ! ( pv_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const md_page ) ) . pv_gen as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( md_page ) , "::" ,
                stringify ! ( pv_gen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const md_page ) ) . pat_mode as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( md_page ) , "::" ,
                stringify ! ( pat_mode ) ));
}
impl Clone for md_page {
    fn clone(&self) -> Self { *self }
}
impl Default for md_page {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum pmap_type { PT_X86 = 0, PT_EPT = 1, PT_RVI = 2, }
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct pmap_pcids {
    pub pm_pcid: u32,
    pub pm_gen: u32,
}
#[test]
fn bindgen_test_layout_pmap_pcids() {
    assert_eq!(::core::mem::size_of::<pmap_pcids>() , 8usize , concat ! (
               "Size of: " , stringify ! ( pmap_pcids ) ));
    assert_eq! (::core::mem::align_of::<pmap_pcids>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( pmap_pcids ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pmap_pcids ) ) . pm_pcid as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pmap_pcids ) , "::" ,
                stringify ! ( pm_pcid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pmap_pcids ) ) . pm_gen as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( pmap_pcids ) , "::" ,
                stringify ! ( pm_gen ) ));
}
impl Clone for pmap_pcids {
    fn clone(&self) -> Self { *self }
}
pub type pmap_t = *mut pmap;
extern "C" {
    #[link_name = "kernel_pmap_store"]
    pub static mut kernel_pmap_store: pmap;
}
extern "C" {
    pub fn pmap_pinit_type(pmap: pmap_t, pm_type: pmap_type,
                           flags: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn pmap_emulate_accessed_dirty(pmap: pmap_t, va: vm_offset_t,
                                       ftype: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
pub type pv_entry_t = *mut pv_entry;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pv_chunk_header {
    pub pc_pmap: pmap_t,
    pub pc_list: pv_chunk_header__bindgen_ty_1,
    pub pc_map: [u64; 3usize],
    pub pc_lru: pv_chunk_header__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pv_chunk_header__bindgen_ty_1 {
    pub tqe_next: *mut pv_chunk,
    pub tqe_prev: *mut *mut pv_chunk,
}
#[test]
fn bindgen_test_layout_pv_chunk_header__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<pv_chunk_header__bindgen_ty_1>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( pv_chunk_header__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<pv_chunk_header__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( pv_chunk_header__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_chunk_header__bindgen_ty_1 ) ) .
                tqe_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pv_chunk_header__bindgen_ty_1 ) , "::" , stringify ! (
                tqe_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_chunk_header__bindgen_ty_1 ) ) .
                tqe_prev as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                pv_chunk_header__bindgen_ty_1 ) , "::" , stringify ! (
                tqe_prev ) ));
}
impl Clone for pv_chunk_header__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for pv_chunk_header__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct pv_chunk_header__bindgen_ty_2 {
    pub tqe_next: *mut pv_chunk,
    pub tqe_prev: *mut *mut pv_chunk,
}
#[test]
fn bindgen_test_layout_pv_chunk_header__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<pv_chunk_header__bindgen_ty_2>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( pv_chunk_header__bindgen_ty_2 ) ));
    assert_eq! (::core::mem::align_of::<pv_chunk_header__bindgen_ty_2>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( pv_chunk_header__bindgen_ty_2
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_chunk_header__bindgen_ty_2 ) ) .
                tqe_next as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                pv_chunk_header__bindgen_ty_2 ) , "::" , stringify ! (
                tqe_next ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_chunk_header__bindgen_ty_2 ) ) .
                tqe_prev as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                pv_chunk_header__bindgen_ty_2 ) , "::" , stringify ! (
                tqe_prev ) ));
}
impl Clone for pv_chunk_header__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for pv_chunk_header__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[test]
fn bindgen_test_layout_pv_chunk_header() {
    assert_eq!(::core::mem::size_of::<pv_chunk_header>() , 64usize , concat !
               ( "Size of: " , stringify ! ( pv_chunk_header ) ));
    assert_eq! (::core::mem::align_of::<pv_chunk_header>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( pv_chunk_header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_chunk_header ) ) . pc_pmap as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_chunk_header ) ,
                "::" , stringify ! ( pc_pmap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_chunk_header ) ) . pc_list as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_chunk_header ) ,
                "::" , stringify ! ( pc_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_chunk_header ) ) . pc_map as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_chunk_header ) ,
                "::" , stringify ! ( pc_map ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const pv_chunk_header ) ) . pc_lru as * const _
                as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( pv_chunk_header ) ,
                "::" , stringify ! ( pc_lru ) ));
}
impl Clone for pv_chunk_header {
    fn clone(&self) -> Self { *self }
}
impl Default for pv_chunk_header {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    #[link_name = "CADDR1"]
    pub static mut CADDR1: caddr_t;
}
extern "C" {
    #[link_name = "CMAP1"]
    pub static mut CMAP1: *mut pt_entry_t;
}
extern "C" {
    #[link_name = "phys_avail"]
    pub static mut phys_avail: [vm_paddr_t; 0usize];
}
extern "C" {
    #[link_name = "dump_avail"]
    pub static mut dump_avail: [vm_paddr_t; 0usize];
}
extern "C" {
    #[link_name = "virtual_avail"]
    pub static mut virtual_avail: vm_offset_t;
}
extern "C" {
    #[link_name = "virtual_end"]
    pub static mut virtual_end: vm_offset_t;
}
extern "C" {
    #[link_name = "dmaplimit"]
    pub static mut dmaplimit: vm_paddr_t;
}
extern "C" {
    #[link_name = "pmap_pcid_enabled"]
    pub static mut pmap_pcid_enabled: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "invpcid_works"]
    pub static mut invpcid_works: ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn pmap_activate_sw(arg1: *mut thread);
}
extern "C" {
    pub fn pmap_bootstrap(arg1: *mut vm_paddr_t);
}
extern "C" {
    pub fn pmap_cache_bits(pmap: pmap_t, mode: ::kernel::sys::raw::c_int,
                           is_pde: boolean_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn pmap_change_attr(arg1: vm_offset_t, arg2: vm_size_t,
                            arg3: ::kernel::sys::raw::c_int)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn pmap_demote_DMAP(base: vm_paddr_t, len: vm_size_t,
                            invalidate: boolean_t);
}
extern "C" {
    pub fn pmap_init_pat();
}
extern "C" {
    pub fn pmap_kenter(va: vm_offset_t, pa: vm_paddr_t);
}
extern "C" {
    pub fn pmap_kenter_temporary(pa: vm_paddr_t, i: ::kernel::sys::raw::c_int)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn pmap_kextract(arg1: vm_offset_t) -> vm_paddr_t;
}
extern "C" {
    pub fn pmap_kremove(arg1: vm_offset_t);
}
extern "C" {
    pub fn pmap_mapbios(arg1: vm_paddr_t, arg2: vm_size_t)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn pmap_mapdev(arg1: vm_paddr_t, arg2: vm_size_t)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn pmap_mapdev_attr(arg1: vm_paddr_t, arg2: vm_size_t,
                            arg3: ::kernel::sys::raw::c_int)
     -> *mut ::kernel::sys::raw::c_void;
}
extern "C" {
    pub fn pmap_page_is_mapped(m: vm_page_t) -> boolean_t;
}
extern "C" {
    pub fn pmap_page_set_memattr(m: vm_page_t, ma: vm_memattr_t);
}
extern "C" {
    pub fn pmap_pinit_pml4(arg1: vm_page_t);
}
extern "C" {
    pub fn pmap_ps_enabled(pmap: pmap_t) -> bool_;
}
extern "C" {
    pub fn pmap_unmapdev(arg1: vm_offset_t, arg2: vm_size_t);
}
extern "C" {
    pub fn pmap_invalidate_page(arg1: pmap_t, arg2: vm_offset_t);
}
extern "C" {
    pub fn pmap_invalidate_range(arg1: pmap_t, arg2: vm_offset_t,
                                 arg3: vm_offset_t);
}
extern "C" {
    pub fn pmap_invalidate_all(arg1: pmap_t);
}
extern "C" {
    pub fn pmap_invalidate_cache();
}
extern "C" {
    pub fn pmap_invalidate_cache_pages(pages: *mut vm_page_t,
                                       count: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn pmap_invalidate_cache_range(sva: vm_offset_t, eva: vm_offset_t,
                                       force: boolean_t);
}
extern "C" {
    pub fn pmap_get_mapping(pmap: pmap_t, va: vm_offset_t, ptr: *mut u64,
                            num: *mut ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn pmap_map_io_transient(arg1: *mut vm_page_t, arg2: *mut vm_offset_t,
                                 arg3: ::kernel::sys::raw::c_int,
                                 arg4: boolean_t) -> boolean_t;
}
extern "C" {
    pub fn pmap_unmap_io_transient(arg1: *mut vm_page_t,
                                   arg2: *mut vm_offset_t,
                                   arg3: ::kernel::sys::raw::c_int,
                                   arg4: boolean_t);
}
extern "C" {
    pub fn pmap_pti_add_kva(sva: vm_offset_t, eva: vm_offset_t, exec: bool_);
}
extern "C" {
    pub fn pmap_pti_remove_kva(sva: vm_offset_t, eva: vm_offset_t);
}
extern "C" {
    pub fn pmap_pti_pcid_invalidate(ucr3: u64, kcr3: u64);
}
extern "C" {
    pub fn pmap_pti_pcid_invlpg(ucr3: u64, kcr3: u64, va: vm_offset_t);
}
extern "C" {
    pub fn pmap_pti_pcid_invlrng(ucr3: u64, kcr3: u64, sva: vm_offset_t,
                                 eva: vm_offset_t);
}
extern "C" {
    #[link_name = "kernel_vm_end"]
    pub static mut kernel_vm_end: vm_offset_t;
}
extern "C" {
    pub fn pmap_activate(td: *mut thread);
}
extern "C" {
    pub fn pmap_advise(pmap: pmap_t, sva: vm_offset_t, eva: vm_offset_t,
                       advice: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn pmap_align_superpage(arg1: vm_object_t, arg2: vm_ooffset_t,
                                arg3: *mut vm_offset_t, arg4: vm_size_t);
}
extern "C" {
    pub fn pmap_clear_modify(m: vm_page_t);
}
extern "C" {
    pub fn pmap_copy(arg1: pmap_t, arg2: pmap_t, arg3: vm_offset_t,
                     arg4: vm_size_t, arg5: vm_offset_t);
}
extern "C" {
    pub fn pmap_copy_page(arg1: vm_page_t, arg2: vm_page_t);
}
extern "C" {
    pub fn pmap_copy_pages(ma: *mut vm_page_t, a_offset: vm_offset_t,
                           mb: *mut vm_page_t, b_offset: vm_offset_t,
                           xfersize: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn pmap_enter(pmap: pmap_t, va: vm_offset_t, m: vm_page_t,
                      prot: vm_prot_t, flags: u_int, psind: i8)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn pmap_enter_object(pmap: pmap_t, start: vm_offset_t,
                             end: vm_offset_t, m_start: vm_page_t,
                             prot: vm_prot_t);
}
extern "C" {
    pub fn pmap_enter_quick(pmap: pmap_t, va: vm_offset_t, m: vm_page_t,
                            prot: vm_prot_t);
}
extern "C" {
    pub fn pmap_extract(pmap: pmap_t, va: vm_offset_t) -> vm_paddr_t;
}
extern "C" {
    pub fn pmap_extract_and_hold(pmap: pmap_t, va: vm_offset_t,
                                 prot: vm_prot_t) -> vm_page_t;
}
extern "C" {
    pub fn pmap_growkernel(arg1: vm_offset_t);
}
extern "C" {
    pub fn pmap_init();
}
extern "C" {
    pub fn pmap_is_modified(m: vm_page_t) -> boolean_t;
}
extern "C" {
    pub fn pmap_is_prefaultable(pmap: pmap_t, va: vm_offset_t) -> boolean_t;
}
extern "C" {
    pub fn pmap_is_referenced(m: vm_page_t) -> boolean_t;
}
extern "C" {
    pub fn pmap_map(arg1: *mut vm_offset_t, arg2: vm_paddr_t,
                    arg3: vm_paddr_t, arg4: ::kernel::sys::raw::c_int)
     -> vm_offset_t;
}
extern "C" {
    pub fn pmap_mincore(pmap: pmap_t, addr: vm_offset_t,
                        locked_pa: *mut vm_paddr_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn pmap_object_init_pt(pmap: pmap_t, addr: vm_offset_t,
                               object: vm_object_t, pindex: vm_pindex_t,
                               size: vm_size_t);
}
extern "C" {
    pub fn pmap_page_exists_quick(pmap: pmap_t, m: vm_page_t) -> boolean_t;
}
extern "C" {
    pub fn pmap_page_init(m: vm_page_t);
}
extern "C" {
    pub fn pmap_page_wired_mappings(m: vm_page_t)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn pmap_pinit(arg1: pmap_t) -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn pmap_pinit0(arg1: pmap_t);
}
extern "C" {
    pub fn pmap_protect(arg1: pmap_t, arg2: vm_offset_t, arg3: vm_offset_t,
                        arg4: vm_prot_t);
}
extern "C" {
    pub fn pmap_qenter(arg1: vm_offset_t, arg2: *mut vm_page_t,
                       arg3: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn pmap_qremove(arg1: vm_offset_t, arg2: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn pmap_quick_enter_page(arg1: vm_page_t) -> vm_offset_t;
}
extern "C" {
    pub fn pmap_quick_remove_page(arg1: vm_offset_t);
}
extern "C" {
    pub fn pmap_release(arg1: pmap_t);
}
extern "C" {
    pub fn pmap_remove(arg1: pmap_t, arg2: vm_offset_t, arg3: vm_offset_t);
}
extern "C" {
    pub fn pmap_remove_all(m: vm_page_t);
}
extern "C" {
    pub fn pmap_remove_pages(arg1: pmap_t);
}
extern "C" {
    pub fn pmap_remove_write(m: vm_page_t);
}
extern "C" {
    pub fn pmap_sync_icache(arg1: pmap_t, arg2: vm_offset_t, arg3: vm_size_t);
}
extern "C" {
    pub fn pmap_ts_referenced(m: vm_page_t) -> boolean_t;
}
extern "C" {
    pub fn pmap_unwire(pmap: pmap_t, start: vm_offset_t, end: vm_offset_t);
}
extern "C" {
    pub fn pmap_zero_page(arg1: vm_page_t);
}
extern "C" {
    pub fn pmap_zero_page_area(arg1: vm_page_t,
                               off: ::kernel::sys::raw::c_int,
                               size: ::kernel::sys::raw::c_int);
}
extern "C" {
    #[link_name = "clkintr_pending"]
    pub static mut clkintr_pending: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "i8254_freq"]
    pub static mut i8254_freq: u_int;
}
extern "C" {
    #[link_name = "i8254_max_count"]
    pub static mut i8254_max_count: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "tsc_freq"]
    pub static mut tsc_freq: u64;
}
extern "C" {
    #[link_name = "tsc_is_invariant"]
    pub static mut tsc_is_invariant: ::kernel::sys::raw::c_int;
}
extern "C" {
    #[link_name = "tsc_perf_stat"]
    pub static mut tsc_perf_stat: ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn i8254_init();
}
extern "C" {
    pub fn i8254_delay(arg1: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn clock_init();
}
extern "C" {
    pub fn startrtclock();
}
extern "C" {
    pub fn init_TSC();
}
extern "C" {
    pub fn resume_TSC();
}
extern "C" {
    pub fn timer_spkr_acquire() -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn timer_spkr_release() -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn timer_spkr_setfreq(freq: ::kernel::sys::raw::c_int);
}
pub type u64 = u64;
pub type u32 = u32;
pub type u16 = u16;
pub type u8 = u8;
pub type s64 = i64;
pub type s32 = i32;
pub type s16 = i16;
pub type s8 = i8;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct e1000_osdep {
    pub mem_bus_space_tag: bus_space_tag_t,
    pub mem_bus_space_handle: bus_space_handle_t,
    pub io_bus_space_tag: bus_space_tag_t,
    pub io_bus_space_handle: bus_space_handle_t,
    pub flash_bus_space_tag: bus_space_tag_t,
    pub flash_bus_space_handle: bus_space_handle_t,
    pub dev: device_t,
    pub ctx: if_ctx_t,
}
#[test]
fn bindgen_test_layout_e1000_osdep() {
    assert_eq!(::core::mem::size_of::<e1000_osdep>() , 64usize , concat ! (
               "Size of: " , stringify ! ( e1000_osdep ) ));
    assert_eq! (::core::mem::align_of::<e1000_osdep>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( e1000_osdep ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_osdep ) ) . mem_bus_space_tag as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_osdep ) , "::" ,
                stringify ! ( mem_bus_space_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_osdep ) ) . mem_bus_space_handle as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_osdep ) , "::" ,
                stringify ! ( mem_bus_space_handle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_osdep ) ) . io_bus_space_tag as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_osdep ) , "::" ,
                stringify ! ( io_bus_space_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_osdep ) ) . io_bus_space_handle as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_osdep ) , "::" ,
                stringify ! ( io_bus_space_handle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_osdep ) ) . flash_bus_space_tag as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_osdep ) , "::" ,
                stringify ! ( flash_bus_space_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_osdep ) ) . flash_bus_space_handle
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_osdep ) , "::" ,
                stringify ! ( flash_bus_space_handle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_osdep ) ) . dev as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_osdep ) , "::" ,
                stringify ! ( dev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_osdep ) ) . ctx as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_osdep ) , "::" ,
                stringify ! ( ctx ) ));
}
impl Clone for e1000_osdep {
    fn clone(&self) -> Self { *self }
}
impl Default for e1000_osdep {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct e1000_hw {
    pub back: *mut ::kernel::sys::raw::c_void,
    pub hw_addr: *mut u8,
    pub flash_address: *mut u8,
    pub io_base: ::kernel::sys::raw::c_ulong,
    pub mac: e1000_mac_info,
    pub fc: e1000_fc_info,
    pub phy: e1000_phy_info,
    pub nvm: e1000_nvm_info,
    pub bus: e1000_bus_info,
    pub mbx: e1000_mbx_info,
    pub mng_cookie: e1000_host_mng_dhcp_cookie,
    pub dev_spec: e1000_hw__bindgen_ty_1,
    pub device_id: u16,
    pub subsystem_vendor_id: u16,
    pub subsystem_device_id: u16,
    pub vendor_id: u16,
    pub revision_id: u8,
}
#[repr(C)]
#[derive(Copy)]
pub union e1000_hw__bindgen_ty_1 {
    pub _82541: e1000_dev_spec_82541,
    pub _82542: e1000_dev_spec_82542,
    pub _82543: e1000_dev_spec_82543,
    pub _82571: e1000_dev_spec_82571,
    pub _80003es2lan: e1000_dev_spec_80003es2lan,
    pub ich8lan: e1000_dev_spec_ich8lan,
    pub _82575: e1000_dev_spec_82575,
    pub vf: e1000_dev_spec_vf,
    _bindgen_union_align: [u32; 2052usize],
}
#[test]
fn bindgen_test_layout_e1000_hw__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<e1000_hw__bindgen_ty_1>() , 8208usize ,
               concat ! ( "Size of: " , stringify ! ( e1000_hw__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<e1000_hw__bindgen_ty_1>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( e1000_hw__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw__bindgen_ty_1 ) ) . _82541 as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw__bindgen_ty_1
                ) , "::" , stringify ! ( _82541 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw__bindgen_ty_1 ) ) . _82542 as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw__bindgen_ty_1
                ) , "::" , stringify ! ( _82542 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw__bindgen_ty_1 ) ) . _82543 as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw__bindgen_ty_1
                ) , "::" , stringify ! ( _82543 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw__bindgen_ty_1 ) ) . _82571 as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw__bindgen_ty_1
                ) , "::" , stringify ! ( _82571 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw__bindgen_ty_1 ) ) . _80003es2lan
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw__bindgen_ty_1
                ) , "::" , stringify ! ( _80003es2lan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw__bindgen_ty_1 ) ) . ich8lan as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw__bindgen_ty_1
                ) , "::" , stringify ! ( ich8lan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw__bindgen_ty_1 ) ) . _82575 as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw__bindgen_ty_1
                ) , "::" , stringify ! ( _82575 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw__bindgen_ty_1 ) ) . vf as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw__bindgen_ty_1
                ) , "::" , stringify ! ( vf ) ));
}
impl Clone for e1000_hw__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for e1000_hw__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for e1000_hw__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "e1000_hw__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_e1000_hw() {
    assert_eq!(::core::mem::size_of::<e1000_hw>() , 9608usize , concat ! (
               "Size of: " , stringify ! ( e1000_hw ) ));
    assert_eq! (::core::mem::align_of::<e1000_hw>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( e1000_hw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw ) ) . back as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw ) , "::" ,
                stringify ! ( back ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw ) ) . hw_addr as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw ) , "::" ,
                stringify ! ( hw_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw ) ) . flash_address as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw ) , "::" ,
                stringify ! ( flash_address ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw ) ) . io_base as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw ) , "::" ,
                stringify ! ( io_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw ) ) . mac as * const _ as usize
                } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw ) , "::" ,
                stringify ! ( mac ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw ) ) . fc as * const _ as usize }
                , 864usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw ) , "::" ,
                stringify ! ( fc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw ) ) . phy as * const _ as usize
                } , 888usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw ) , "::" ,
                stringify ! ( phy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw ) ) . nvm as * const _ as usize
                } , 1152usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw ) , "::" ,
                stringify ! ( nvm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw ) ) . bus as * const _ as usize
                } , 1256usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw ) , "::" ,
                stringify ! ( bus ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw ) ) . mbx as * const _ as usize
                } , 1272usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw ) , "::" ,
                stringify ! ( mbx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw ) ) . mng_cookie as * const _ as
                usize } , 1368usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw ) , "::" ,
                stringify ! ( mng_cookie ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw ) ) . dev_spec as * const _ as
                usize } , 1384usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw ) , "::" ,
                stringify ! ( dev_spec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw ) ) . device_id as * const _ as
                usize } , 9592usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw ) , "::" ,
                stringify ! ( device_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw ) ) . subsystem_vendor_id as *
                const _ as usize } , 9594usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw ) , "::" ,
                stringify ! ( subsystem_vendor_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw ) ) . subsystem_device_id as *
                const _ as usize } , 9596usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw ) , "::" ,
                stringify ! ( subsystem_device_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw ) ) . vendor_id as * const _ as
                usize } , 9598usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw ) , "::" ,
                stringify ! ( vendor_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw ) ) . revision_id as * const _
                as usize } , 9600usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw ) , "::" ,
                stringify ! ( revision_id ) ));
}
impl Clone for e1000_hw {
    fn clone(&self) -> Self { *self }
}
impl Default for e1000_hw {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for e1000_hw {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "e1000_hw {{ back: {:?}, hw_addr: {:?}, flash_address: {:?}, io_base: {:?}, mac: {:?}, fc: {:?}, phy: {:?}, nvm: {:?}, bus: {:?}, mbx: {:?}, mng_cookie: {:?}, dev_spec: {:?}, device_id: {:?}, subsystem_vendor_id: {:?}, subsystem_device_id: {:?}, vendor_id: {:?}, revision_id: {:?} }}"
               , self . back , self . hw_addr , self . flash_address , self .
               io_base , self . mac , self . fc , self . phy , self . nvm ,
               self . bus , self . mbx , self . mng_cookie , self . dev_spec ,
               self . device_id , self . subsystem_vendor_id , self .
               subsystem_device_id , self . vendor_id , self . revision_id)
    }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum e1000_mac_type {
    e1000_undefined = 0,
    e1000_82542 = 1,
    e1000_82543 = 2,
    e1000_82544 = 3,
    e1000_82540 = 4,
    e1000_82545 = 5,
    e1000_82545_rev_3 = 6,
    e1000_82546 = 7,
    e1000_82546_rev_3 = 8,
    e1000_82541 = 9,
    e1000_82541_rev_2 = 10,
    e1000_82547 = 11,
    e1000_82547_rev_2 = 12,
    e1000_82571 = 13,
    e1000_82572 = 14,
    e1000_82573 = 15,
    e1000_82574 = 16,
    e1000_82583 = 17,
    e1000_80003es2lan = 18,
    e1000_ich8lan = 19,
    e1000_ich9lan = 20,
    e1000_ich10lan = 21,
    e1000_pchlan = 22,
    e1000_pch2lan = 23,
    e1000_pch_lpt = 24,
    e1000_pch_spt = 25,
    e1000_pch_cnp = 26,
    e1000_82575 = 27,
    e1000_82576 = 28,
    e1000_82580 = 29,
    e1000_i350 = 30,
    e1000_i354 = 31,
    e1000_i210 = 32,
    e1000_i211 = 33,
    e1000_vfadapt = 34,
    e1000_vfadapt_i350 = 35,
    e1000_num_macs = 36,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum e1000_media_type {
    e1000_media_type_unknown = 0,
    e1000_media_type_copper = 1,
    e1000_media_type_fiber = 2,
    e1000_media_type_internal_serdes = 3,
    e1000_num_media_types = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum e1000_nvm_type {
    e1000_nvm_unknown = 0,
    e1000_nvm_none = 1,
    e1000_nvm_eeprom_spi = 2,
    e1000_nvm_eeprom_microwire = 3,
    e1000_nvm_flash_hw = 4,
    e1000_nvm_invm = 5,
    e1000_nvm_flash_sw = 6,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum e1000_nvm_override {
    e1000_nvm_override_none = 0,
    e1000_nvm_override_spi_small = 1,
    e1000_nvm_override_spi_large = 2,
    e1000_nvm_override_microwire_small = 3,
    e1000_nvm_override_microwire_large = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum e1000_phy_type {
    e1000_phy_unknown = 0,
    e1000_phy_none = 1,
    e1000_phy_m88 = 2,
    e1000_phy_igp = 3,
    e1000_phy_igp_2 = 4,
    e1000_phy_gg82563 = 5,
    e1000_phy_igp_3 = 6,
    e1000_phy_ife = 7,
    e1000_phy_bm = 8,
    e1000_phy_82578 = 9,
    e1000_phy_82577 = 10,
    e1000_phy_82579 = 11,
    e1000_phy_i217 = 12,
    e1000_phy_82580 = 13,
    e1000_phy_vf = 14,
    e1000_phy_i210 = 15,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum e1000_bus_type {
    e1000_bus_type_unknown = 0,
    e1000_bus_type_pci = 1,
    e1000_bus_type_pcix = 2,
    e1000_bus_type_pci_express = 3,
    e1000_bus_type_reserved = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum e1000_bus_speed {
    e1000_bus_speed_unknown = 0,
    e1000_bus_speed_33 = 1,
    e1000_bus_speed_66 = 2,
    e1000_bus_speed_100 = 3,
    e1000_bus_speed_120 = 4,
    e1000_bus_speed_133 = 5,
    e1000_bus_speed_2500 = 6,
    e1000_bus_speed_5000 = 7,
    e1000_bus_speed_reserved = 8,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum e1000_bus_width {
    e1000_bus_width_unknown = 0,
    e1000_bus_width_pcie_x1 = 1,
    e1000_bus_width_pcie_x2 = 2,
    e1000_bus_width_pcie_x4 = 4,
    e1000_bus_width_pcie_x8 = 8,
    e1000_bus_width_32 = 9,
    e1000_bus_width_64 = 10,
    e1000_bus_width_reserved = 11,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum e1000_1000t_rx_status {
    e1000_1000t_rx_status_not_ok = 0,
    e1000_1000t_rx_status_ok = 1,
    e1000_1000t_rx_status_undefined = 255,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum e1000_rev_polarity {
    e1000_rev_polarity_normal = 0,
    e1000_rev_polarity_reversed = 1,
    e1000_rev_polarity_undefined = 255,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum e1000_fc_mode {
    e1000_fc_none = 0,
    e1000_fc_rx_pause = 1,
    e1000_fc_tx_pause = 2,
    e1000_fc_full = 3,
    e1000_fc_default = 255,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum e1000_ffe_config {
    e1000_ffe_config_enabled = 0,
    e1000_ffe_config_active = 1,
    e1000_ffe_config_blocked = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum e1000_dsp_config {
    e1000_dsp_config_disabled = 0,
    e1000_dsp_config_enabled = 1,
    e1000_dsp_config_activated = 2,
    e1000_dsp_config_undefined = 255,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum e1000_ms_type {
    e1000_ms_hw_default = 0,
    e1000_ms_force_master = 1,
    e1000_ms_force_slave = 2,
    e1000_ms_auto = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum e1000_smart_speed {
    e1000_smart_speed_default = 0,
    e1000_smart_speed_on = 1,
    e1000_smart_speed_off = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum e1000_serdes_link_state {
    e1000_serdes_link_down = 0,
    e1000_serdes_link_autoneg_progress = 1,
    e1000_serdes_link_autoneg_complete = 2,
    e1000_serdes_link_forced_up = 3,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct e1000_rx_desc {
    pub buffer_addr: u64,
    pub length: u16,
    pub csum: u16,
    pub status: u8,
    pub errors: u8,
    pub special: u16,
}
#[test]
fn bindgen_test_layout_e1000_rx_desc() {
    assert_eq!(::core::mem::size_of::<e1000_rx_desc>() , 16usize , concat ! (
               "Size of: " , stringify ! ( e1000_rx_desc ) ));
    assert_eq! (::core::mem::align_of::<e1000_rx_desc>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( e1000_rx_desc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_rx_desc ) ) . buffer_addr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_rx_desc ) , "::"
                , stringify ! ( buffer_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_rx_desc ) ) . length as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_rx_desc ) , "::"
                , stringify ! ( length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_rx_desc ) ) . csum as * const _ as
                usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_rx_desc ) , "::"
                , stringify ! ( csum ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_rx_desc ) ) . status as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_rx_desc ) , "::"
                , stringify ! ( status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_rx_desc ) ) . errors as * const _
                as usize } , 13usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_rx_desc ) , "::"
                , stringify ! ( errors ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_rx_desc ) ) . special as * const _
                as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_rx_desc ) , "::"
                , stringify ! ( special ) ));
}
impl Clone for e1000_rx_desc {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union e1000_rx_desc_extended {
    pub read: e1000_rx_desc_extended__bindgen_ty_1,
    pub wb: e1000_rx_desc_extended__bindgen_ty_2,
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct e1000_rx_desc_extended__bindgen_ty_1 {
    pub buffer_addr: u64,
    pub reserved: u64,
}
#[test]
fn bindgen_test_layout_e1000_rx_desc_extended__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<e1000_rx_desc_extended__bindgen_ty_1>()
               , 16usize , concat ! (
               "Size of: " , stringify ! (
               e1000_rx_desc_extended__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<e1000_rx_desc_extended__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                e1000_rx_desc_extended__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_rx_desc_extended__bindgen_ty_1 ) )
                . buffer_addr as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_rx_desc_extended__bindgen_ty_1 ) , "::" , stringify ! (
                buffer_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_rx_desc_extended__bindgen_ty_1 ) )
                . reserved as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_rx_desc_extended__bindgen_ty_1 ) , "::" , stringify ! (
                reserved ) ));
}
impl Clone for e1000_rx_desc_extended__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct e1000_rx_desc_extended__bindgen_ty_2 {
    pub lower: e1000_rx_desc_extended__bindgen_ty_2__bindgen_ty_1,
    pub upper: e1000_rx_desc_extended__bindgen_ty_2__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy)]
pub struct e1000_rx_desc_extended__bindgen_ty_2__bindgen_ty_1 {
    pub mrq: u32,
    pub hi_dword: e1000_rx_desc_extended__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub union e1000_rx_desc_extended__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    pub rss: u32,
    pub csum_ip: e1000_rx_desc_extended__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct e1000_rx_desc_extended__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub ip_id: u16,
    pub csum: u16,
}
#[test]
fn bindgen_test_layout_e1000_rx_desc_extended__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<e1000_rx_desc_extended__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>()
               , 4usize , concat ! (
               "Size of: " , stringify ! (
               e1000_rx_desc_extended__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
               ) ));
    assert_eq! (::core::mem::align_of::<e1000_rx_desc_extended__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>()
                , 2usize , concat ! (
                "Alignment of " , stringify ! (
                e1000_rx_desc_extended__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                e1000_rx_desc_extended__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
                ) ) . ip_id as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_rx_desc_extended__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
                ) , "::" , stringify ! ( ip_id ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                e1000_rx_desc_extended__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
                ) ) . csum as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_rx_desc_extended__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
                ) , "::" , stringify ! ( csum ) ));
}
impl Clone for
 e1000_rx_desc_extended__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_e1000_rx_desc_extended__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<e1000_rx_desc_extended__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1>()
               , 4usize , concat ! (
               "Size of: " , stringify ! (
               e1000_rx_desc_extended__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1
               ) ));
    assert_eq! (::core::mem::align_of::<e1000_rx_desc_extended__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                e1000_rx_desc_extended__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                e1000_rx_desc_extended__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1
                ) ) . rss as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_rx_desc_extended__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1
                ) , "::" , stringify ! ( rss ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                e1000_rx_desc_extended__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1
                ) ) . csum_ip as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_rx_desc_extended__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1
                ) , "::" , stringify ! ( csum_ip ) ));
}
impl Clone for
 e1000_rx_desc_extended__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for
 e1000_rx_desc_extended__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for
 e1000_rx_desc_extended__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "e1000_rx_desc_extended__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_e1000_rx_desc_extended__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<e1000_rx_desc_extended__bindgen_ty_2__bindgen_ty_1>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               e1000_rx_desc_extended__bindgen_ty_2__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<e1000_rx_desc_extended__bindgen_ty_2__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                e1000_rx_desc_extended__bindgen_ty_2__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                e1000_rx_desc_extended__bindgen_ty_2__bindgen_ty_1 ) ) . mrq
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_rx_desc_extended__bindgen_ty_2__bindgen_ty_1 ) , "::" ,
                stringify ! ( mrq ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                e1000_rx_desc_extended__bindgen_ty_2__bindgen_ty_1 ) ) .
                hi_dword as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_rx_desc_extended__bindgen_ty_2__bindgen_ty_1 ) , "::" ,
                stringify ! ( hi_dword ) ));
}
impl Clone for e1000_rx_desc_extended__bindgen_ty_2__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for e1000_rx_desc_extended__bindgen_ty_2__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for e1000_rx_desc_extended__bindgen_ty_2__bindgen_ty_1
 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "e1000_rx_desc_extended__bindgen_ty_2__bindgen_ty_1 {{ mrq: {:?}, hi_dword: {:?} }}"
               , self . mrq , self . hi_dword)
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct e1000_rx_desc_extended__bindgen_ty_2__bindgen_ty_2 {
    pub status_error: u32,
    pub length: u16,
    pub vlan: u16,
}
#[test]
fn bindgen_test_layout_e1000_rx_desc_extended__bindgen_ty_2__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<e1000_rx_desc_extended__bindgen_ty_2__bindgen_ty_2>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               e1000_rx_desc_extended__bindgen_ty_2__bindgen_ty_2 ) ));
    assert_eq! (::core::mem::align_of::<e1000_rx_desc_extended__bindgen_ty_2__bindgen_ty_2>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                e1000_rx_desc_extended__bindgen_ty_2__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                e1000_rx_desc_extended__bindgen_ty_2__bindgen_ty_2 ) ) .
                status_error as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_rx_desc_extended__bindgen_ty_2__bindgen_ty_2 ) , "::" ,
                stringify ! ( status_error ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                e1000_rx_desc_extended__bindgen_ty_2__bindgen_ty_2 ) ) .
                length as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_rx_desc_extended__bindgen_ty_2__bindgen_ty_2 ) , "::" ,
                stringify ! ( length ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                e1000_rx_desc_extended__bindgen_ty_2__bindgen_ty_2 ) ) . vlan
                as * const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_rx_desc_extended__bindgen_ty_2__bindgen_ty_2 ) , "::" ,
                stringify ! ( vlan ) ));
}
impl Clone for e1000_rx_desc_extended__bindgen_ty_2__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_e1000_rx_desc_extended__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<e1000_rx_desc_extended__bindgen_ty_2>()
               , 16usize , concat ! (
               "Size of: " , stringify ! (
               e1000_rx_desc_extended__bindgen_ty_2 ) ));
    assert_eq! (::core::mem::align_of::<e1000_rx_desc_extended__bindgen_ty_2>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                e1000_rx_desc_extended__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_rx_desc_extended__bindgen_ty_2 ) )
                . lower as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_rx_desc_extended__bindgen_ty_2 ) , "::" , stringify ! (
                lower ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_rx_desc_extended__bindgen_ty_2 ) )
                . upper as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_rx_desc_extended__bindgen_ty_2 ) , "::" , stringify ! (
                upper ) ));
}
impl Clone for e1000_rx_desc_extended__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for e1000_rx_desc_extended__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for e1000_rx_desc_extended__bindgen_ty_2 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "e1000_rx_desc_extended__bindgen_ty_2 {{ lower: {:?}, upper: {:?} }}"
               , self . lower , self . upper)
    }
}
#[test]
fn bindgen_test_layout_e1000_rx_desc_extended() {
    assert_eq!(::core::mem::size_of::<e1000_rx_desc_extended>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( e1000_rx_desc_extended )
               ));
    assert_eq! (::core::mem::align_of::<e1000_rx_desc_extended>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( e1000_rx_desc_extended ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_rx_desc_extended ) ) . read as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_rx_desc_extended
                ) , "::" , stringify ! ( read ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_rx_desc_extended ) ) . wb as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_rx_desc_extended
                ) , "::" , stringify ! ( wb ) ));
}
impl Clone for e1000_rx_desc_extended {
    fn clone(&self) -> Self { *self }
}
impl Default for e1000_rx_desc_extended {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for e1000_rx_desc_extended {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "e1000_rx_desc_extended {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy)]
pub union e1000_rx_desc_packet_split {
    pub read: e1000_rx_desc_packet_split__bindgen_ty_1,
    pub wb: e1000_rx_desc_packet_split__bindgen_ty_2,
    _bindgen_union_align: [u64; 4usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct e1000_rx_desc_packet_split__bindgen_ty_1 {
    pub buffer_addr: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_e1000_rx_desc_packet_split__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<e1000_rx_desc_packet_split__bindgen_ty_1>()
               , 32usize , concat ! (
               "Size of: " , stringify ! (
               e1000_rx_desc_packet_split__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<e1000_rx_desc_packet_split__bindgen_ty_1>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                e1000_rx_desc_packet_split__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const e1000_rx_desc_packet_split__bindgen_ty_1 ) )
                . buffer_addr as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_rx_desc_packet_split__bindgen_ty_1 ) , "::" , stringify
                ! ( buffer_addr ) ));
}
impl Clone for e1000_rx_desc_packet_split__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct e1000_rx_desc_packet_split__bindgen_ty_2 {
    pub lower: e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_1,
    pub middle: e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_2,
    pub upper: e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_3,
    pub reserved: u64,
}
#[repr(C)]
#[derive(Copy)]
pub struct e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_1 {
    pub mrq: u32,
    pub hi_dword: e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub union e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    pub rss: u32,
    pub csum_ip: e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub ip_id: u16,
    pub csum: u16,
}
#[test]
fn bindgen_test_layout_e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>()
               , 4usize , concat ! (
               "Size of: " , stringify ! (
               e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
               ) ));
    assert_eq! (::core::mem::align_of::<e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>()
                , 2usize , concat ! (
                "Alignment of " , stringify ! (
                e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
                ) ) . ip_id as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
                ) , "::" , stringify ! ( ip_id ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
                ) ) . csum as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
                ) , "::" , stringify ! ( csum ) ));
}
impl Clone for
 e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1>()
               , 4usize , concat ! (
               "Size of: " , stringify ! (
               e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1
               ) ));
    assert_eq! (::core::mem::align_of::<e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1
                ) ) . rss as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1
                ) , "::" , stringify ! ( rss ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1
                ) ) . csum_ip as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1
                ) , "::" , stringify ! ( csum_ip ) ));
}
impl Clone for
 e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for
 e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for
 e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_1>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_1 ) ) .
                mrq as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_1 ) ,
                "::" , stringify ! ( mrq ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_1 ) ) .
                hi_dword as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_1 ) ,
                "::" , stringify ! ( hi_dword ) ));
}
impl Clone for e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for
 e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_1 {{ mrq: {:?}, hi_dword: {:?} }}"
               , self . mrq , self . hi_dword)
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_2 {
    pub status_error: u32,
    pub length0: u16,
    pub vlan: u16,
}
#[test]
fn bindgen_test_layout_e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_2>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_2 ) ));
    assert_eq! (::core::mem::align_of::<e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_2>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_2 ) ) .
                status_error as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_2 ) ,
                "::" , stringify ! ( status_error ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_2 ) ) .
                length0 as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_2 ) ,
                "::" , stringify ! ( length0 ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_2 ) ) .
                vlan as * const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_2 ) ,
                "::" , stringify ! ( vlan ) ));
}
impl Clone for e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_3 {
    pub header_status: u16,
    pub length: [u16; 3usize],
}
#[test]
fn bindgen_test_layout_e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_3() {
    assert_eq!(::core::mem::size_of::<e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_3>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_3 ) ));
    assert_eq! (::core::mem::align_of::<e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_3>()
                , 2usize , concat ! (
                "Alignment of " , stringify ! (
                e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_3 ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_3 ) ) .
                header_status as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_3 ) ,
                "::" , stringify ! ( header_status ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_3 ) ) .
                length as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_3 ) ,
                "::" , stringify ! ( length ) ));
}
impl Clone for e1000_rx_desc_packet_split__bindgen_ty_2__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_e1000_rx_desc_packet_split__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<e1000_rx_desc_packet_split__bindgen_ty_2>()
               , 32usize , concat ! (
               "Size of: " , stringify ! (
               e1000_rx_desc_packet_split__bindgen_ty_2 ) ));
    assert_eq! (::core::mem::align_of::<e1000_rx_desc_packet_split__bindgen_ty_2>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                e1000_rx_desc_packet_split__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const e1000_rx_desc_packet_split__bindgen_ty_2 ) )
                . lower as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_rx_desc_packet_split__bindgen_ty_2 ) , "::" , stringify
                ! ( lower ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const e1000_rx_desc_packet_split__bindgen_ty_2 ) )
                . middle as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_rx_desc_packet_split__bindgen_ty_2 ) , "::" , stringify
                ! ( middle ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const e1000_rx_desc_packet_split__bindgen_ty_2 ) )
                . upper as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_rx_desc_packet_split__bindgen_ty_2 ) , "::" , stringify
                ! ( upper ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const e1000_rx_desc_packet_split__bindgen_ty_2 ) )
                . reserved as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_rx_desc_packet_split__bindgen_ty_2 ) , "::" , stringify
                ! ( reserved ) ));
}
impl Clone for e1000_rx_desc_packet_split__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for e1000_rx_desc_packet_split__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for e1000_rx_desc_packet_split__bindgen_ty_2 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "e1000_rx_desc_packet_split__bindgen_ty_2 {{ lower: {:?}, middle: {:?}, upper: {:?}, reserved: {:?} }}"
               , self . lower , self . middle , self . upper , self .
               reserved)
    }
}
#[test]
fn bindgen_test_layout_e1000_rx_desc_packet_split() {
    assert_eq!(::core::mem::size_of::<e1000_rx_desc_packet_split>() , 32usize
               , concat ! (
               "Size of: " , stringify ! ( e1000_rx_desc_packet_split ) ));
    assert_eq! (::core::mem::align_of::<e1000_rx_desc_packet_split>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( e1000_rx_desc_packet_split )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_rx_desc_packet_split ) ) . read as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_rx_desc_packet_split ) , "::" , stringify ! ( read ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_rx_desc_packet_split ) ) . wb as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_rx_desc_packet_split ) , "::" , stringify ! ( wb ) ));
}
impl Clone for e1000_rx_desc_packet_split {
    fn clone(&self) -> Self { *self }
}
impl Default for e1000_rx_desc_packet_split {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for e1000_rx_desc_packet_split {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "e1000_rx_desc_packet_split {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct e1000_tx_desc {
    pub buffer_addr: u64,
    pub lower: e1000_tx_desc__bindgen_ty_1,
    pub upper: e1000_tx_desc__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy)]
pub union e1000_tx_desc__bindgen_ty_1 {
    pub data: u32,
    pub flags: e1000_tx_desc__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct e1000_tx_desc__bindgen_ty_1__bindgen_ty_1 {
    pub length: u16,
    pub cso: u8,
    pub cmd: u8,
}
#[test]
fn bindgen_test_layout_e1000_tx_desc__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<e1000_tx_desc__bindgen_ty_1__bindgen_ty_1>()
               , 4usize , concat ! (
               "Size of: " , stringify ! (
               e1000_tx_desc__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<e1000_tx_desc__bindgen_ty_1__bindgen_ty_1>()
                , 2usize , concat ! (
                "Alignment of " , stringify ! (
                e1000_tx_desc__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const e1000_tx_desc__bindgen_ty_1__bindgen_ty_1 ) )
                . length as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_tx_desc__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify
                ! ( length ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const e1000_tx_desc__bindgen_ty_1__bindgen_ty_1 ) )
                . cso as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_tx_desc__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify
                ! ( cso ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const e1000_tx_desc__bindgen_ty_1__bindgen_ty_1 ) )
                . cmd as * const _ as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_tx_desc__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify
                ! ( cmd ) ));
}
impl Clone for e1000_tx_desc__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_e1000_tx_desc__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<e1000_tx_desc__bindgen_ty_1>() , 4usize
               , concat ! (
               "Size of: " , stringify ! ( e1000_tx_desc__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<e1000_tx_desc__bindgen_ty_1>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( e1000_tx_desc__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_tx_desc__bindgen_ty_1 ) ) . data as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_tx_desc__bindgen_ty_1 ) , "::" , stringify ! ( data )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_tx_desc__bindgen_ty_1 ) ) . flags
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_tx_desc__bindgen_ty_1 ) , "::" , stringify ! ( flags )
                ));
}
impl Clone for e1000_tx_desc__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for e1000_tx_desc__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for e1000_tx_desc__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "e1000_tx_desc__bindgen_ty_1 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy)]
pub union e1000_tx_desc__bindgen_ty_2 {
    pub data: u32,
    pub fields: e1000_tx_desc__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct e1000_tx_desc__bindgen_ty_2__bindgen_ty_1 {
    pub status: u8,
    pub css: u8,
    pub special: u16,
}
#[test]
fn bindgen_test_layout_e1000_tx_desc__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<e1000_tx_desc__bindgen_ty_2__bindgen_ty_1>()
               , 4usize , concat ! (
               "Size of: " , stringify ! (
               e1000_tx_desc__bindgen_ty_2__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<e1000_tx_desc__bindgen_ty_2__bindgen_ty_1>()
                , 2usize , concat ! (
                "Alignment of " , stringify ! (
                e1000_tx_desc__bindgen_ty_2__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const e1000_tx_desc__bindgen_ty_2__bindgen_ty_1 ) )
                . status as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_tx_desc__bindgen_ty_2__bindgen_ty_1 ) , "::" , stringify
                ! ( status ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const e1000_tx_desc__bindgen_ty_2__bindgen_ty_1 ) )
                . css as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_tx_desc__bindgen_ty_2__bindgen_ty_1 ) , "::" , stringify
                ! ( css ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const e1000_tx_desc__bindgen_ty_2__bindgen_ty_1 ) )
                . special as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_tx_desc__bindgen_ty_2__bindgen_ty_1 ) , "::" , stringify
                ! ( special ) ));
}
impl Clone for e1000_tx_desc__bindgen_ty_2__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_e1000_tx_desc__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<e1000_tx_desc__bindgen_ty_2>() , 4usize
               , concat ! (
               "Size of: " , stringify ! ( e1000_tx_desc__bindgen_ty_2 ) ));
    assert_eq! (::core::mem::align_of::<e1000_tx_desc__bindgen_ty_2>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( e1000_tx_desc__bindgen_ty_2 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_tx_desc__bindgen_ty_2 ) ) . data as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_tx_desc__bindgen_ty_2 ) , "::" , stringify ! ( data )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_tx_desc__bindgen_ty_2 ) ) . fields
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_tx_desc__bindgen_ty_2 ) , "::" , stringify ! ( fields )
                ));
}
impl Clone for e1000_tx_desc__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for e1000_tx_desc__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for e1000_tx_desc__bindgen_ty_2 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "e1000_tx_desc__bindgen_ty_2 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_e1000_tx_desc() {
    assert_eq!(::core::mem::size_of::<e1000_tx_desc>() , 16usize , concat ! (
               "Size of: " , stringify ! ( e1000_tx_desc ) ));
    assert_eq! (::core::mem::align_of::<e1000_tx_desc>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( e1000_tx_desc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_tx_desc ) ) . buffer_addr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_tx_desc ) , "::"
                , stringify ! ( buffer_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_tx_desc ) ) . lower as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_tx_desc ) , "::"
                , stringify ! ( lower ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_tx_desc ) ) . upper as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_tx_desc ) , "::"
                , stringify ! ( upper ) ));
}
impl Clone for e1000_tx_desc {
    fn clone(&self) -> Self { *self }
}
impl Default for e1000_tx_desc {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for e1000_tx_desc {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "e1000_tx_desc {{ buffer_addr: {:?}, lower: {:?}, upper: {:?} }}"
               , self . buffer_addr , self . lower , self . upper)
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct e1000_context_desc {
    pub lower_setup: e1000_context_desc__bindgen_ty_1,
    pub upper_setup: e1000_context_desc__bindgen_ty_2,
    pub cmd_and_length: u32,
    pub tcp_seg_setup: e1000_context_desc__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy)]
pub union e1000_context_desc__bindgen_ty_1 {
    pub ip_config: u32,
    pub ip_fields: e1000_context_desc__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct e1000_context_desc__bindgen_ty_1__bindgen_ty_1 {
    pub ipcss: u8,
    pub ipcso: u8,
    pub ipcse: u16,
}
#[test]
fn bindgen_test_layout_e1000_context_desc__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<e1000_context_desc__bindgen_ty_1__bindgen_ty_1>()
               , 4usize , concat ! (
               "Size of: " , stringify ! (
               e1000_context_desc__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<e1000_context_desc__bindgen_ty_1__bindgen_ty_1>()
                , 2usize , concat ! (
                "Alignment of " , stringify ! (
                e1000_context_desc__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const e1000_context_desc__bindgen_ty_1__bindgen_ty_1 )
                ) . ipcss as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_context_desc__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( ipcss ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const e1000_context_desc__bindgen_ty_1__bindgen_ty_1 )
                ) . ipcso as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_context_desc__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( ipcso ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const e1000_context_desc__bindgen_ty_1__bindgen_ty_1 )
                ) . ipcse as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_context_desc__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( ipcse ) ));
}
impl Clone for e1000_context_desc__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_e1000_context_desc__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<e1000_context_desc__bindgen_ty_1>() ,
               4usize , concat ! (
               "Size of: " , stringify ! ( e1000_context_desc__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<e1000_context_desc__bindgen_ty_1>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                e1000_context_desc__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_context_desc__bindgen_ty_1 ) ) .
                ip_config as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_context_desc__bindgen_ty_1 ) , "::" , stringify ! (
                ip_config ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_context_desc__bindgen_ty_1 ) ) .
                ip_fields as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_context_desc__bindgen_ty_1 ) , "::" , stringify ! (
                ip_fields ) ));
}
impl Clone for e1000_context_desc__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for e1000_context_desc__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for e1000_context_desc__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "e1000_context_desc__bindgen_ty_1 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy)]
pub union e1000_context_desc__bindgen_ty_2 {
    pub tcp_config: u32,
    pub tcp_fields: e1000_context_desc__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct e1000_context_desc__bindgen_ty_2__bindgen_ty_1 {
    pub tucss: u8,
    pub tucso: u8,
    pub tucse: u16,
}
#[test]
fn bindgen_test_layout_e1000_context_desc__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<e1000_context_desc__bindgen_ty_2__bindgen_ty_1>()
               , 4usize , concat ! (
               "Size of: " , stringify ! (
               e1000_context_desc__bindgen_ty_2__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<e1000_context_desc__bindgen_ty_2__bindgen_ty_1>()
                , 2usize , concat ! (
                "Alignment of " , stringify ! (
                e1000_context_desc__bindgen_ty_2__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const e1000_context_desc__bindgen_ty_2__bindgen_ty_1 )
                ) . tucss as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_context_desc__bindgen_ty_2__bindgen_ty_1 ) , "::" ,
                stringify ! ( tucss ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const e1000_context_desc__bindgen_ty_2__bindgen_ty_1 )
                ) . tucso as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_context_desc__bindgen_ty_2__bindgen_ty_1 ) , "::" ,
                stringify ! ( tucso ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const e1000_context_desc__bindgen_ty_2__bindgen_ty_1 )
                ) . tucse as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_context_desc__bindgen_ty_2__bindgen_ty_1 ) , "::" ,
                stringify ! ( tucse ) ));
}
impl Clone for e1000_context_desc__bindgen_ty_2__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_e1000_context_desc__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<e1000_context_desc__bindgen_ty_2>() ,
               4usize , concat ! (
               "Size of: " , stringify ! ( e1000_context_desc__bindgen_ty_2 )
               ));
    assert_eq! (::core::mem::align_of::<e1000_context_desc__bindgen_ty_2>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                e1000_context_desc__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_context_desc__bindgen_ty_2 ) ) .
                tcp_config as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_context_desc__bindgen_ty_2 ) , "::" , stringify ! (
                tcp_config ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_context_desc__bindgen_ty_2 ) ) .
                tcp_fields as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_context_desc__bindgen_ty_2 ) , "::" , stringify ! (
                tcp_fields ) ));
}
impl Clone for e1000_context_desc__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for e1000_context_desc__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for e1000_context_desc__bindgen_ty_2 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "e1000_context_desc__bindgen_ty_2 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy)]
pub union e1000_context_desc__bindgen_ty_3 {
    pub data: u32,
    pub fields: e1000_context_desc__bindgen_ty_3__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct e1000_context_desc__bindgen_ty_3__bindgen_ty_1 {
    pub status: u8,
    pub hdr_len: u8,
    pub mss: u16,
}
#[test]
fn bindgen_test_layout_e1000_context_desc__bindgen_ty_3__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<e1000_context_desc__bindgen_ty_3__bindgen_ty_1>()
               , 4usize , concat ! (
               "Size of: " , stringify ! (
               e1000_context_desc__bindgen_ty_3__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<e1000_context_desc__bindgen_ty_3__bindgen_ty_1>()
                , 2usize , concat ! (
                "Alignment of " , stringify ! (
                e1000_context_desc__bindgen_ty_3__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const e1000_context_desc__bindgen_ty_3__bindgen_ty_1 )
                ) . status as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_context_desc__bindgen_ty_3__bindgen_ty_1 ) , "::" ,
                stringify ! ( status ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const e1000_context_desc__bindgen_ty_3__bindgen_ty_1 )
                ) . hdr_len as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_context_desc__bindgen_ty_3__bindgen_ty_1 ) , "::" ,
                stringify ! ( hdr_len ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const e1000_context_desc__bindgen_ty_3__bindgen_ty_1 )
                ) . mss as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_context_desc__bindgen_ty_3__bindgen_ty_1 ) , "::" ,
                stringify ! ( mss ) ));
}
impl Clone for e1000_context_desc__bindgen_ty_3__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_e1000_context_desc__bindgen_ty_3() {
    assert_eq!(::core::mem::size_of::<e1000_context_desc__bindgen_ty_3>() ,
               4usize , concat ! (
               "Size of: " , stringify ! ( e1000_context_desc__bindgen_ty_3 )
               ));
    assert_eq! (::core::mem::align_of::<e1000_context_desc__bindgen_ty_3>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                e1000_context_desc__bindgen_ty_3 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_context_desc__bindgen_ty_3 ) ) .
                data as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_context_desc__bindgen_ty_3 ) , "::" , stringify ! ( data
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_context_desc__bindgen_ty_3 ) ) .
                fields as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_context_desc__bindgen_ty_3 ) , "::" , stringify ! (
                fields ) ));
}
impl Clone for e1000_context_desc__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
impl Default for e1000_context_desc__bindgen_ty_3 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for e1000_context_desc__bindgen_ty_3 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "e1000_context_desc__bindgen_ty_3 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_e1000_context_desc() {
    assert_eq!(::core::mem::size_of::<e1000_context_desc>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( e1000_context_desc ) ));
    assert_eq! (::core::mem::align_of::<e1000_context_desc>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( e1000_context_desc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_context_desc ) ) . lower_setup as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_context_desc ) ,
                "::" , stringify ! ( lower_setup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_context_desc ) ) . upper_setup as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_context_desc ) ,
                "::" , stringify ! ( upper_setup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_context_desc ) ) . cmd_and_length
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_context_desc ) ,
                "::" , stringify ! ( cmd_and_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_context_desc ) ) . tcp_seg_setup as
                * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_context_desc ) ,
                "::" , stringify ! ( tcp_seg_setup ) ));
}
impl Clone for e1000_context_desc {
    fn clone(&self) -> Self { *self }
}
impl Default for e1000_context_desc {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for e1000_context_desc {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "e1000_context_desc {{ lower_setup: {:?}, upper_setup: {:?}, cmd_and_length: {:?}, tcp_seg_setup: {:?} }}"
               , self . lower_setup , self . upper_setup , self .
               cmd_and_length , self . tcp_seg_setup)
    }
}
#[repr(C)]
#[derive(Copy)]
pub struct e1000_data_desc {
    pub buffer_addr: u64,
    pub lower: e1000_data_desc__bindgen_ty_1,
    pub upper: e1000_data_desc__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy)]
pub union e1000_data_desc__bindgen_ty_1 {
    pub data: u32,
    pub flags: e1000_data_desc__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct e1000_data_desc__bindgen_ty_1__bindgen_ty_1 {
    pub length: u16,
    pub typ_len_ext: u8,
    pub cmd: u8,
}
#[test]
fn bindgen_test_layout_e1000_data_desc__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<e1000_data_desc__bindgen_ty_1__bindgen_ty_1>()
               , 4usize , concat ! (
               "Size of: " , stringify ! (
               e1000_data_desc__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<e1000_data_desc__bindgen_ty_1__bindgen_ty_1>()
                , 2usize , concat ! (
                "Alignment of " , stringify ! (
                e1000_data_desc__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const e1000_data_desc__bindgen_ty_1__bindgen_ty_1 )
                ) . length as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_data_desc__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( length ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const e1000_data_desc__bindgen_ty_1__bindgen_ty_1 )
                ) . typ_len_ext as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_data_desc__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( typ_len_ext ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const e1000_data_desc__bindgen_ty_1__bindgen_ty_1 )
                ) . cmd as * const _ as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_data_desc__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( cmd ) ));
}
impl Clone for e1000_data_desc__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_e1000_data_desc__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<e1000_data_desc__bindgen_ty_1>() ,
               4usize , concat ! (
               "Size of: " , stringify ! ( e1000_data_desc__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<e1000_data_desc__bindgen_ty_1>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( e1000_data_desc__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_data_desc__bindgen_ty_1 ) ) . data
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_data_desc__bindgen_ty_1 ) , "::" , stringify ! ( data )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_data_desc__bindgen_ty_1 ) ) . flags
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_data_desc__bindgen_ty_1 ) , "::" , stringify ! ( flags )
                ));
}
impl Clone for e1000_data_desc__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for e1000_data_desc__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for e1000_data_desc__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "e1000_data_desc__bindgen_ty_1 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy)]
pub union e1000_data_desc__bindgen_ty_2 {
    pub data: u32,
    pub fields: e1000_data_desc__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct e1000_data_desc__bindgen_ty_2__bindgen_ty_1 {
    pub status: u8,
    pub popts: u8,
    pub special: u16,
}
#[test]
fn bindgen_test_layout_e1000_data_desc__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<e1000_data_desc__bindgen_ty_2__bindgen_ty_1>()
               , 4usize , concat ! (
               "Size of: " , stringify ! (
               e1000_data_desc__bindgen_ty_2__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<e1000_data_desc__bindgen_ty_2__bindgen_ty_1>()
                , 2usize , concat ! (
                "Alignment of " , stringify ! (
                e1000_data_desc__bindgen_ty_2__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const e1000_data_desc__bindgen_ty_2__bindgen_ty_1 )
                ) . status as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_data_desc__bindgen_ty_2__bindgen_ty_1 ) , "::" ,
                stringify ! ( status ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const e1000_data_desc__bindgen_ty_2__bindgen_ty_1 )
                ) . popts as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_data_desc__bindgen_ty_2__bindgen_ty_1 ) , "::" ,
                stringify ! ( popts ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const e1000_data_desc__bindgen_ty_2__bindgen_ty_1 )
                ) . special as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_data_desc__bindgen_ty_2__bindgen_ty_1 ) , "::" ,
                stringify ! ( special ) ));
}
impl Clone for e1000_data_desc__bindgen_ty_2__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_e1000_data_desc__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<e1000_data_desc__bindgen_ty_2>() ,
               4usize , concat ! (
               "Size of: " , stringify ! ( e1000_data_desc__bindgen_ty_2 ) ));
    assert_eq! (::core::mem::align_of::<e1000_data_desc__bindgen_ty_2>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( e1000_data_desc__bindgen_ty_2
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_data_desc__bindgen_ty_2 ) ) . data
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_data_desc__bindgen_ty_2 ) , "::" , stringify ! ( data )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_data_desc__bindgen_ty_2 ) ) .
                fields as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_data_desc__bindgen_ty_2 ) , "::" , stringify ! ( fields
                ) ));
}
impl Clone for e1000_data_desc__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for e1000_data_desc__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for e1000_data_desc__bindgen_ty_2 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "e1000_data_desc__bindgen_ty_2 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_e1000_data_desc() {
    assert_eq!(::core::mem::size_of::<e1000_data_desc>() , 16usize , concat !
               ( "Size of: " , stringify ! ( e1000_data_desc ) ));
    assert_eq! (::core::mem::align_of::<e1000_data_desc>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( e1000_data_desc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_data_desc ) ) . buffer_addr as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_data_desc ) ,
                "::" , stringify ! ( buffer_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_data_desc ) ) . lower as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_data_desc ) ,
                "::" , stringify ! ( lower ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_data_desc ) ) . upper as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_data_desc ) ,
                "::" , stringify ! ( upper ) ));
}
impl Clone for e1000_data_desc {
    fn clone(&self) -> Self { *self }
}
impl Default for e1000_data_desc {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for e1000_data_desc {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "e1000_data_desc {{ buffer_addr: {:?}, lower: {:?}, upper: {:?} }}"
               , self . buffer_addr , self . lower , self . upper)
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct e1000_hw_stats {
    pub crcerrs: u64,
    pub algnerrc: u64,
    pub symerrs: u64,
    pub rxerrc: u64,
    pub mpc: u64,
    pub scc: u64,
    pub ecol: u64,
    pub mcc: u64,
    pub latecol: u64,
    pub colc: u64,
    pub dc: u64,
    pub tncrs: u64,
    pub sec: u64,
    pub cexterr: u64,
    pub rlec: u64,
    pub xonrxc: u64,
    pub xontxc: u64,
    pub xoffrxc: u64,
    pub xofftxc: u64,
    pub fcruc: u64,
    pub prc64: u64,
    pub prc127: u64,
    pub prc255: u64,
    pub prc511: u64,
    pub prc1023: u64,
    pub prc1522: u64,
    pub gprc: u64,
    pub bprc: u64,
    pub mprc: u64,
    pub gptc: u64,
    pub gorc: u64,
    pub gotc: u64,
    pub rnbc: u64,
    pub ruc: u64,
    pub rfc: u64,
    pub roc: u64,
    pub rjc: u64,
    pub mgprc: u64,
    pub mgpdc: u64,
    pub mgptc: u64,
    pub tor: u64,
    pub tot: u64,
    pub tpr: u64,
    pub tpt: u64,
    pub ptc64: u64,
    pub ptc127: u64,
    pub ptc255: u64,
    pub ptc511: u64,
    pub ptc1023: u64,
    pub ptc1522: u64,
    pub mptc: u64,
    pub bptc: u64,
    pub tsctc: u64,
    pub tsctfc: u64,
    pub iac: u64,
    pub icrxptc: u64,
    pub icrxatc: u64,
    pub ictxptc: u64,
    pub ictxatc: u64,
    pub ictxqec: u64,
    pub ictxqmtc: u64,
    pub icrxdmtc: u64,
    pub icrxoc: u64,
    pub cbtmpc: u64,
    pub htdpmc: u64,
    pub cbrdpc: u64,
    pub cbrmpc: u64,
    pub rpthc: u64,
    pub hgptc: u64,
    pub htcbdpc: u64,
    pub hgorc: u64,
    pub hgotc: u64,
    pub lenerrs: u64,
    pub scvpc: u64,
    pub hrmpc: u64,
    pub doosync: u64,
    pub o2bgptc: u64,
    pub o2bspc: u64,
    pub b2ospc: u64,
    pub b2ogprc: u64,
}
#[test]
fn bindgen_test_layout_e1000_hw_stats() {
    assert_eq!(::core::mem::size_of::<e1000_hw_stats>() , 640usize , concat !
               ( "Size of: " , stringify ! ( e1000_hw_stats ) ));
    assert_eq! (::core::mem::align_of::<e1000_hw_stats>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( e1000_hw_stats ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . crcerrs as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( crcerrs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . algnerrc as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( algnerrc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . symerrs as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( symerrs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . rxerrc as * const _
                as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( rxerrc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . mpc as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( mpc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . scc as * const _ as
                usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( scc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . ecol as * const _ as
                usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( ecol ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . mcc as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( mcc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . latecol as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( latecol ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . colc as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( colc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . dc as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( dc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . tncrs as * const _
                as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( tncrs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . sec as * const _ as
                usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( sec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . cexterr as * const _
                as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( cexterr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . rlec as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( rlec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . xonrxc as * const _
                as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( xonrxc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . xontxc as * const _
                as usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( xontxc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . xoffrxc as * const _
                as usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( xoffrxc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . xofftxc as * const _
                as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( xofftxc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . fcruc as * const _
                as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( fcruc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . prc64 as * const _
                as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( prc64 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . prc127 as * const _
                as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( prc127 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . prc255 as * const _
                as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( prc255 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . prc511 as * const _
                as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( prc511 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . prc1023 as * const _
                as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( prc1023 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . prc1522 as * const _
                as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( prc1522 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . gprc as * const _ as
                usize } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( gprc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . bprc as * const _ as
                usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( bprc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . mprc as * const _ as
                usize } , 224usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( mprc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . gptc as * const _ as
                usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( gptc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . gorc as * const _ as
                usize } , 240usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( gorc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . gotc as * const _ as
                usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( gotc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . rnbc as * const _ as
                usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( rnbc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . ruc as * const _ as
                usize } , 264usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( ruc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . rfc as * const _ as
                usize } , 272usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( rfc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . roc as * const _ as
                usize } , 280usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( roc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . rjc as * const _ as
                usize } , 288usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( rjc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . mgprc as * const _
                as usize } , 296usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( mgprc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . mgpdc as * const _
                as usize } , 304usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( mgpdc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . mgptc as * const _
                as usize } , 312usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( mgptc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . tor as * const _ as
                usize } , 320usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( tor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . tot as * const _ as
                usize } , 328usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( tot ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . tpr as * const _ as
                usize } , 336usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( tpr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . tpt as * const _ as
                usize } , 344usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( tpt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . ptc64 as * const _
                as usize } , 352usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( ptc64 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . ptc127 as * const _
                as usize } , 360usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( ptc127 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . ptc255 as * const _
                as usize } , 368usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( ptc255 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . ptc511 as * const _
                as usize } , 376usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( ptc511 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . ptc1023 as * const _
                as usize } , 384usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( ptc1023 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . ptc1522 as * const _
                as usize } , 392usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( ptc1522 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . mptc as * const _ as
                usize } , 400usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( mptc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . bptc as * const _ as
                usize } , 408usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( bptc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . tsctc as * const _
                as usize } , 416usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( tsctc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . tsctfc as * const _
                as usize } , 424usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( tsctfc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . iac as * const _ as
                usize } , 432usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( iac ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . icrxptc as * const _
                as usize } , 440usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( icrxptc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . icrxatc as * const _
                as usize } , 448usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( icrxatc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . ictxptc as * const _
                as usize } , 456usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( ictxptc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . ictxatc as * const _
                as usize } , 464usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( ictxatc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . ictxqec as * const _
                as usize } , 472usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( ictxqec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . ictxqmtc as * const
                _ as usize } , 480usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( ictxqmtc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . icrxdmtc as * const
                _ as usize } , 488usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( icrxdmtc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . icrxoc as * const _
                as usize } , 496usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( icrxoc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . cbtmpc as * const _
                as usize } , 504usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( cbtmpc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . htdpmc as * const _
                as usize } , 512usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( htdpmc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . cbrdpc as * const _
                as usize } , 520usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( cbrdpc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . cbrmpc as * const _
                as usize } , 528usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( cbrmpc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . rpthc as * const _
                as usize } , 536usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( rpthc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . hgptc as * const _
                as usize } , 544usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( hgptc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . htcbdpc as * const _
                as usize } , 552usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( htcbdpc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . hgorc as * const _
                as usize } , 560usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( hgorc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . hgotc as * const _
                as usize } , 568usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( hgotc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . lenerrs as * const _
                as usize } , 576usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( lenerrs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . scvpc as * const _
                as usize } , 584usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( scvpc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . hrmpc as * const _
                as usize } , 592usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( hrmpc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . doosync as * const _
                as usize } , 600usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( doosync ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . o2bgptc as * const _
                as usize } , 608usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( o2bgptc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . o2bspc as * const _
                as usize } , 616usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( o2bspc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . b2ospc as * const _
                as usize } , 624usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( b2ospc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_hw_stats ) ) . b2ogprc as * const _
                as usize } , 632usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_hw_stats ) , "::"
                , stringify ! ( b2ogprc ) ));
}
impl Clone for e1000_hw_stats {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct e1000_vf_stats {
    pub base_gprc: u64,
    pub base_gptc: u64,
    pub base_gorc: u64,
    pub base_gotc: u64,
    pub base_mprc: u64,
    pub base_gotlbc: u64,
    pub base_gptlbc: u64,
    pub base_gorlbc: u64,
    pub base_gprlbc: u64,
    pub last_gprc: u32,
    pub last_gptc: u32,
    pub last_gorc: u32,
    pub last_gotc: u32,
    pub last_mprc: u32,
    pub last_gotlbc: u32,
    pub last_gptlbc: u32,
    pub last_gorlbc: u32,
    pub last_gprlbc: u32,
    pub gprc: u64,
    pub gptc: u64,
    pub gorc: u64,
    pub gotc: u64,
    pub mprc: u64,
    pub gotlbc: u64,
    pub gptlbc: u64,
    pub gorlbc: u64,
    pub gprlbc: u64,
}
#[test]
fn bindgen_test_layout_e1000_vf_stats() {
    assert_eq!(::core::mem::size_of::<e1000_vf_stats>() , 184usize , concat !
               ( "Size of: " , stringify ! ( e1000_vf_stats ) ));
    assert_eq! (::core::mem::align_of::<e1000_vf_stats>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( e1000_vf_stats ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_vf_stats ) ) . base_gprc as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_vf_stats ) , "::"
                , stringify ! ( base_gprc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_vf_stats ) ) . base_gptc as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_vf_stats ) , "::"
                , stringify ! ( base_gptc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_vf_stats ) ) . base_gorc as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_vf_stats ) , "::"
                , stringify ! ( base_gorc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_vf_stats ) ) . base_gotc as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_vf_stats ) , "::"
                , stringify ! ( base_gotc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_vf_stats ) ) . base_mprc as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_vf_stats ) , "::"
                , stringify ! ( base_mprc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_vf_stats ) ) . base_gotlbc as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_vf_stats ) , "::"
                , stringify ! ( base_gotlbc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_vf_stats ) ) . base_gptlbc as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_vf_stats ) , "::"
                , stringify ! ( base_gptlbc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_vf_stats ) ) . base_gorlbc as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_vf_stats ) , "::"
                , stringify ! ( base_gorlbc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_vf_stats ) ) . base_gprlbc as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_vf_stats ) , "::"
                , stringify ! ( base_gprlbc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_vf_stats ) ) . last_gprc as * const
                _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_vf_stats ) , "::"
                , stringify ! ( last_gprc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_vf_stats ) ) . last_gptc as * const
                _ as usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_vf_stats ) , "::"
                , stringify ! ( last_gptc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_vf_stats ) ) . last_gorc as * const
                _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_vf_stats ) , "::"
                , stringify ! ( last_gorc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_vf_stats ) ) . last_gotc as * const
                _ as usize } , 84usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_vf_stats ) , "::"
                , stringify ! ( last_gotc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_vf_stats ) ) . last_mprc as * const
                _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_vf_stats ) , "::"
                , stringify ! ( last_mprc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_vf_stats ) ) . last_gotlbc as *
                const _ as usize } , 92usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_vf_stats ) , "::"
                , stringify ! ( last_gotlbc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_vf_stats ) ) . last_gptlbc as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_vf_stats ) , "::"
                , stringify ! ( last_gptlbc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_vf_stats ) ) . last_gorlbc as *
                const _ as usize } , 100usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_vf_stats ) , "::"
                , stringify ! ( last_gorlbc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_vf_stats ) ) . last_gprlbc as *
                const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_vf_stats ) , "::"
                , stringify ! ( last_gprlbc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_vf_stats ) ) . gprc as * const _ as
                usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_vf_stats ) , "::"
                , stringify ! ( gprc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_vf_stats ) ) . gptc as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_vf_stats ) , "::"
                , stringify ! ( gptc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_vf_stats ) ) . gorc as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_vf_stats ) , "::"
                , stringify ! ( gorc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_vf_stats ) ) . gotc as * const _ as
                usize } , 136usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_vf_stats ) , "::"
                , stringify ! ( gotc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_vf_stats ) ) . mprc as * const _ as
                usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_vf_stats ) , "::"
                , stringify ! ( mprc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_vf_stats ) ) . gotlbc as * const _
                as usize } , 152usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_vf_stats ) , "::"
                , stringify ! ( gotlbc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_vf_stats ) ) . gptlbc as * const _
                as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_vf_stats ) , "::"
                , stringify ! ( gptlbc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_vf_stats ) ) . gorlbc as * const _
                as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_vf_stats ) , "::"
                , stringify ! ( gorlbc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_vf_stats ) ) . gprlbc as * const _
                as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_vf_stats ) , "::"
                , stringify ! ( gprlbc ) ));
}
impl Clone for e1000_vf_stats {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct e1000_phy_stats {
    pub idle_errors: u32,
    pub receive_errors: u32,
}
#[test]
fn bindgen_test_layout_e1000_phy_stats() {
    assert_eq!(::core::mem::size_of::<e1000_phy_stats>() , 8usize , concat ! (
               "Size of: " , stringify ! ( e1000_phy_stats ) ));
    assert_eq! (::core::mem::align_of::<e1000_phy_stats>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( e1000_phy_stats ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_phy_stats ) ) . idle_errors as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_phy_stats ) ,
                "::" , stringify ! ( idle_errors ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_phy_stats ) ) . receive_errors as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_phy_stats ) ,
                "::" , stringify ! ( receive_errors ) ));
}
impl Clone for e1000_phy_stats {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct e1000_host_mng_dhcp_cookie {
    pub signature: u32,
    pub status: u8,
    pub reserved0: u8,
    pub vlan_id: u16,
    pub reserved1: u32,
    pub reserved2: u16,
    pub reserved3: u8,
    pub checksum: u8,
}
#[test]
fn bindgen_test_layout_e1000_host_mng_dhcp_cookie() {
    assert_eq!(::core::mem::size_of::<e1000_host_mng_dhcp_cookie>() , 16usize
               , concat ! (
               "Size of: " , stringify ! ( e1000_host_mng_dhcp_cookie ) ));
    assert_eq! (::core::mem::align_of::<e1000_host_mng_dhcp_cookie>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( e1000_host_mng_dhcp_cookie )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_host_mng_dhcp_cookie ) ) .
                signature as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_host_mng_dhcp_cookie ) , "::" , stringify ! ( signature
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_host_mng_dhcp_cookie ) ) . status
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_host_mng_dhcp_cookie ) , "::" , stringify ! ( status )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_host_mng_dhcp_cookie ) ) .
                reserved0 as * const _ as usize } , 5usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_host_mng_dhcp_cookie ) , "::" , stringify ! ( reserved0
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_host_mng_dhcp_cookie ) ) . vlan_id
                as * const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_host_mng_dhcp_cookie ) , "::" , stringify ! ( vlan_id )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_host_mng_dhcp_cookie ) ) .
                reserved1 as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_host_mng_dhcp_cookie ) , "::" , stringify ! ( reserved1
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_host_mng_dhcp_cookie ) ) .
                reserved2 as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_host_mng_dhcp_cookie ) , "::" , stringify ! ( reserved2
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_host_mng_dhcp_cookie ) ) .
                reserved3 as * const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_host_mng_dhcp_cookie ) , "::" , stringify ! ( reserved3
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_host_mng_dhcp_cookie ) ) . checksum
                as * const _ as usize } , 15usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_host_mng_dhcp_cookie ) , "::" , stringify ! ( checksum )
                ));
}
impl Clone for e1000_host_mng_dhcp_cookie {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct e1000_host_command_header {
    pub command_id: u8,
    pub command_length: u8,
    pub command_options: u8,
    pub checksum: u8,
}
#[test]
fn bindgen_test_layout_e1000_host_command_header() {
    assert_eq!(::core::mem::size_of::<e1000_host_command_header>() , 4usize ,
               concat ! (
               "Size of: " , stringify ! ( e1000_host_command_header ) ));
    assert_eq! (::core::mem::align_of::<e1000_host_command_header>() , 1usize
                , concat ! (
                "Alignment of " , stringify ! ( e1000_host_command_header )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_host_command_header ) ) .
                command_id as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_host_command_header ) , "::" , stringify ! ( command_id
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_host_command_header ) ) .
                command_length as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_host_command_header ) , "::" , stringify ! (
                command_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_host_command_header ) ) .
                command_options as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_host_command_header ) , "::" , stringify ! (
                command_options ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_host_command_header ) ) . checksum
                as * const _ as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_host_command_header ) , "::" , stringify ! ( checksum )
                ));
}
impl Clone for e1000_host_command_header {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct e1000_host_command_info {
    pub command_header: e1000_host_command_header,
    pub command_data: [u8; 252usize],
}
#[test]
fn bindgen_test_layout_e1000_host_command_info() {
    assert_eq!(::core::mem::size_of::<e1000_host_command_info>() , 256usize ,
               concat ! (
               "Size of: " , stringify ! ( e1000_host_command_info ) ));
    assert_eq! (::core::mem::align_of::<e1000_host_command_info>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( e1000_host_command_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_host_command_info ) ) .
                command_header as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_host_command_info
                ) , "::" , stringify ! ( command_header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_host_command_info ) ) .
                command_data as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_host_command_info
                ) , "::" , stringify ! ( command_data ) ));
}
impl Clone for e1000_host_command_info {
    fn clone(&self) -> Self { *self }
}
impl Default for e1000_host_command_info {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for e1000_host_command_info {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "e1000_host_command_info {{ command_header: {:?}, command_data: [{}] }}"
               , self . command_header , self . command_data . iter (  ) .
               enumerate (  ) . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ))
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct e1000_host_mng_command_header {
    pub command_id: u8,
    pub checksum: u8,
    pub reserved1: u16,
    pub reserved2: u16,
    pub command_length: u16,
}
#[test]
fn bindgen_test_layout_e1000_host_mng_command_header() {
    assert_eq!(::core::mem::size_of::<e1000_host_mng_command_header>() ,
               8usize , concat ! (
               "Size of: " , stringify ! ( e1000_host_mng_command_header ) ));
    assert_eq! (::core::mem::align_of::<e1000_host_mng_command_header>() ,
                2usize , concat ! (
                "Alignment of " , stringify ! ( e1000_host_mng_command_header
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_host_mng_command_header ) ) .
                command_id as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_host_mng_command_header ) , "::" , stringify ! (
                command_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_host_mng_command_header ) ) .
                checksum as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_host_mng_command_header ) , "::" , stringify ! (
                checksum ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_host_mng_command_header ) ) .
                reserved1 as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_host_mng_command_header ) , "::" , stringify ! (
                reserved1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_host_mng_command_header ) ) .
                reserved2 as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_host_mng_command_header ) , "::" , stringify ! (
                reserved2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_host_mng_command_header ) ) .
                command_length as * const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_host_mng_command_header ) , "::" , stringify ! (
                command_length ) ));
}
impl Clone for e1000_host_mng_command_header {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct e1000_host_mng_command_info {
    pub command_header: e1000_host_mng_command_header,
    pub command_data: [u8; 1784usize],
}
#[test]
fn bindgen_test_layout_e1000_host_mng_command_info() {
    assert_eq!(::core::mem::size_of::<e1000_host_mng_command_info>() ,
               1792usize , concat ! (
               "Size of: " , stringify ! ( e1000_host_mng_command_info ) ));
    assert_eq! (::core::mem::align_of::<e1000_host_mng_command_info>() ,
                2usize , concat ! (
                "Alignment of " , stringify ! ( e1000_host_mng_command_info )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_host_mng_command_info ) ) .
                command_header as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_host_mng_command_info ) , "::" , stringify ! (
                command_header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_host_mng_command_info ) ) .
                command_data as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_host_mng_command_info ) , "::" , stringify ! (
                command_data ) ));
}
impl Clone for e1000_host_mng_command_info {
    fn clone(&self) -> Self { *self }
}
impl Default for e1000_host_mng_command_info {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for e1000_host_mng_command_info {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "e1000_host_mng_command_info {{ command_header: {:?}, command_data: [{}] }}"
               , self . command_header , self . command_data . iter (  ) .
               enumerate (  ) . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ))
    }
}
extern "C" {
    pub fn e1000_init_mac_ops_generic(hw: *mut e1000_hw);
}
extern "C" {
    pub fn e1000_null_mac_generic(hw: *mut e1000_hw);
}
extern "C" {
    pub fn e1000_null_ops_generic(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_null_link_info(hw: *mut e1000_hw, s: *mut u16, d: *mut u16)
     -> s32;
}
extern "C" {
    pub fn e1000_null_mng_mode(hw: *mut e1000_hw) -> bool_;
}
extern "C" {
    pub fn e1000_null_update_mc(hw: *mut e1000_hw, h: *mut u8, a: u32);
}
extern "C" {
    pub fn e1000_null_write_vfta(hw: *mut e1000_hw, a: u32, b: u32);
}
extern "C" {
    pub fn e1000_null_rar_set(hw: *mut e1000_hw, h: *mut u8, a: u32)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn e1000_null_set_obff_timer(hw: *mut e1000_hw, a: u32) -> s32;
}
extern "C" {
    pub fn e1000_blink_led_generic(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_check_for_copper_link_generic(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_check_for_fiber_link_generic(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_check_for_serdes_link_generic(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_cleanup_led_generic(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_commit_fc_settings_generic(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_poll_fiber_serdes_link_generic(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_config_fc_after_link_up_generic(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_disable_pcie_master_generic(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_force_mac_fc_generic(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_get_auto_rd_done_generic(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_get_bus_info_pci_generic(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_get_bus_info_pcie_generic(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_set_lan_id_single_port(hw: *mut e1000_hw);
}
extern "C" {
    pub fn e1000_set_lan_id_multi_port_pci(hw: *mut e1000_hw);
}
extern "C" {
    pub fn e1000_get_speed_and_duplex_copper_generic(hw: *mut e1000_hw,
                                                     speed: *mut u16,
                                                     duplex: *mut u16) -> s32;
}
extern "C" {
    pub fn e1000_get_speed_and_duplex_fiber_serdes_generic(hw: *mut e1000_hw,
                                                           speed: *mut u16,
                                                           duplex: *mut u16)
     -> s32;
}
extern "C" {
    pub fn e1000_id_led_init_generic(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_led_on_generic(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_led_off_generic(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_update_mc_addr_list_generic(hw: *mut e1000_hw,
                                             mc_addr_list: *mut u8,
                                             mc_addr_count: u32);
}
extern "C" {
    pub fn e1000_set_default_fc_generic(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_set_fc_watermarks_generic(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_setup_fiber_serdes_link_generic(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_setup_led_generic(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_setup_link_generic(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_validate_mdi_setting_crossover_generic(hw: *mut e1000_hw)
     -> s32;
}
extern "C" {
    pub fn e1000_write_8bit_ctrl_reg_generic(hw: *mut e1000_hw, reg: u32,
                                             offset: u32, data: u8) -> s32;
}
extern "C" {
    pub fn e1000_hash_mc_addr_generic(hw: *mut e1000_hw, mc_addr: *mut u8)
     -> u32;
}
extern "C" {
    pub fn e1000_clear_hw_cntrs_base_generic(hw: *mut e1000_hw);
}
extern "C" {
    pub fn e1000_clear_vfta_generic(hw: *mut e1000_hw);
}
extern "C" {
    pub fn e1000_init_rx_addrs_generic(hw: *mut e1000_hw, rar_count: u16);
}
extern "C" {
    pub fn e1000_pcix_mmrbc_workaround_generic(hw: *mut e1000_hw);
}
extern "C" {
    pub fn e1000_check_alt_mac_addr_generic(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_reset_adaptive_generic(hw: *mut e1000_hw);
}
extern "C" {
    pub fn e1000_set_pcie_no_snoop_generic(hw: *mut e1000_hw, no_snoop: u32);
}
extern "C" {
    pub fn e1000_update_adaptive_generic(hw: *mut e1000_hw);
}
extern "C" {
    pub fn e1000_write_vfta_generic(hw: *mut e1000_hw, offset: u32,
                                    value: u32);
}
extern "C" {
    pub fn e1000_get_hw_semaphore(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_put_hw_semaphore(hw: *mut e1000_hw);
}
extern "C" {
    pub fn e1000_acquire_swfw_sync(hw: *mut e1000_hw, mask: u16) -> s32;
}
extern "C" {
    pub fn e1000_release_swfw_sync(hw: *mut e1000_hw, mask: u16);
}
extern "C" {
    pub fn e1000_init_phy_ops_generic(hw: *mut e1000_hw);
}
extern "C" {
    pub fn e1000_null_read_reg(hw: *mut e1000_hw, offset: u32, data: *mut u16)
     -> s32;
}
extern "C" {
    pub fn e1000_null_phy_generic(hw: *mut e1000_hw);
}
extern "C" {
    pub fn e1000_null_lplu_state(hw: *mut e1000_hw, active: bool_) -> s32;
}
extern "C" {
    pub fn e1000_null_write_reg(hw: *mut e1000_hw, offset: u32, data: u16)
     -> s32;
}
extern "C" {
    pub fn e1000_null_set_page(hw: *mut e1000_hw, data: u16) -> s32;
}
extern "C" {
    pub fn e1000_read_i2c_byte_null(hw: *mut e1000_hw, byte_offset: u8,
                                    dev_addr: u8, data: *mut u8) -> s32;
}
extern "C" {
    pub fn e1000_write_i2c_byte_null(hw: *mut e1000_hw, byte_offset: u8,
                                     dev_addr: u8, data: u8) -> s32;
}
extern "C" {
    pub fn e1000_check_downshift_generic(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_check_polarity_m88(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_check_polarity_igp(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_check_polarity_ife(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_check_reset_block_generic(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_phy_setup_autoneg(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_copper_link_autoneg(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_copper_link_setup_igp(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_copper_link_setup_m88(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_copper_link_setup_m88_gen2(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_phy_force_speed_duplex_igp(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_phy_force_speed_duplex_m88(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_phy_force_speed_duplex_ife(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_get_cable_length_m88(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_get_cable_length_m88_gen2(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_get_cable_length_igp_2(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_get_cfg_done_generic(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_get_phy_id(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_get_phy_info_igp(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_get_phy_info_m88(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_get_phy_info_ife(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_phy_sw_reset_generic(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_phy_force_speed_duplex_setup(hw: *mut e1000_hw,
                                              phy_ctrl: *mut u16);
}
extern "C" {
    pub fn e1000_phy_hw_reset_generic(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_phy_reset_dsp_generic(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_read_kmrn_reg_generic(hw: *mut e1000_hw, offset: u32,
                                       data: *mut u16) -> s32;
}
extern "C" {
    pub fn e1000_read_kmrn_reg_locked(hw: *mut e1000_hw, offset: u32,
                                      data: *mut u16) -> s32;
}
extern "C" {
    pub fn e1000_set_page_igp(hw: *mut e1000_hw, page: u16) -> s32;
}
extern "C" {
    pub fn e1000_read_phy_reg_igp(hw: *mut e1000_hw, offset: u32,
                                  data: *mut u16) -> s32;
}
extern "C" {
    pub fn e1000_read_phy_reg_igp_locked(hw: *mut e1000_hw, offset: u32,
                                         data: *mut u16) -> s32;
}
extern "C" {
    pub fn e1000_read_phy_reg_m88(hw: *mut e1000_hw, offset: u32,
                                  data: *mut u16) -> s32;
}
extern "C" {
    pub fn e1000_set_d3_lplu_state_generic(hw: *mut e1000_hw, active: bool_)
     -> s32;
}
extern "C" {
    pub fn e1000_setup_copper_link_generic(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_write_kmrn_reg_generic(hw: *mut e1000_hw, offset: u32,
                                        data: u16) -> s32;
}
extern "C" {
    pub fn e1000_write_kmrn_reg_locked(hw: *mut e1000_hw, offset: u32,
                                       data: u16) -> s32;
}
extern "C" {
    pub fn e1000_write_phy_reg_igp(hw: *mut e1000_hw, offset: u32, data: u16)
     -> s32;
}
extern "C" {
    pub fn e1000_write_phy_reg_igp_locked(hw: *mut e1000_hw, offset: u32,
                                          data: u16) -> s32;
}
extern "C" {
    pub fn e1000_write_phy_reg_m88(hw: *mut e1000_hw, offset: u32, data: u16)
     -> s32;
}
extern "C" {
    pub fn e1000_phy_has_link_generic(hw: *mut e1000_hw, iterations: u32,
                                      usec_interval: u32, success: *mut bool_)
     -> s32;
}
extern "C" {
    pub fn e1000_phy_init_script_igp3(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_get_phy_type_from_id(phy_id: u32) -> e1000_phy_type;
}
extern "C" {
    pub fn e1000_determine_phy_address(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_write_phy_reg_bm(hw: *mut e1000_hw, offset: u32, data: u16)
     -> s32;
}
extern "C" {
    pub fn e1000_read_phy_reg_bm(hw: *mut e1000_hw, offset: u32,
                                 data: *mut u16) -> s32;
}
extern "C" {
    pub fn e1000_enable_phy_wakeup_reg_access_bm(hw: *mut e1000_hw,
                                                 phy_reg: *mut u16) -> s32;
}
extern "C" {
    pub fn e1000_disable_phy_wakeup_reg_access_bm(hw: *mut e1000_hw,
                                                  phy_reg: *mut u16) -> s32;
}
extern "C" {
    pub fn e1000_read_phy_reg_bm2(hw: *mut e1000_hw, offset: u32,
                                  data: *mut u16) -> s32;
}
extern "C" {
    pub fn e1000_write_phy_reg_bm2(hw: *mut e1000_hw, offset: u32, data: u16)
     -> s32;
}
extern "C" {
    pub fn e1000_power_up_phy_copper(hw: *mut e1000_hw);
}
extern "C" {
    pub fn e1000_power_down_phy_copper(hw: *mut e1000_hw);
}
extern "C" {
    pub fn e1000_read_phy_reg_mdic(hw: *mut e1000_hw, offset: u32,
                                   data: *mut u16) -> s32;
}
extern "C" {
    pub fn e1000_write_phy_reg_mdic(hw: *mut e1000_hw, offset: u32, data: u16)
     -> s32;
}
extern "C" {
    pub fn e1000_read_phy_reg_i2c(hw: *mut e1000_hw, offset: u32,
                                  data: *mut u16) -> s32;
}
extern "C" {
    pub fn e1000_write_phy_reg_i2c(hw: *mut e1000_hw, offset: u32, data: u16)
     -> s32;
}
extern "C" {
    pub fn e1000_read_sfp_data_byte(hw: *mut e1000_hw, offset: u16,
                                    data: *mut u8) -> s32;
}
extern "C" {
    pub fn e1000_write_sfp_data_byte(hw: *mut e1000_hw, offset: u16, data: u8)
     -> s32;
}
extern "C" {
    pub fn e1000_read_phy_reg_hv(hw: *mut e1000_hw, offset: u32,
                                 data: *mut u16) -> s32;
}
extern "C" {
    pub fn e1000_read_phy_reg_hv_locked(hw: *mut e1000_hw, offset: u32,
                                        data: *mut u16) -> s32;
}
extern "C" {
    pub fn e1000_read_phy_reg_page_hv(hw: *mut e1000_hw, offset: u32,
                                      data: *mut u16) -> s32;
}
extern "C" {
    pub fn e1000_write_phy_reg_hv(hw: *mut e1000_hw, offset: u32, data: u16)
     -> s32;
}
extern "C" {
    pub fn e1000_write_phy_reg_hv_locked(hw: *mut e1000_hw, offset: u32,
                                         data: u16) -> s32;
}
extern "C" {
    pub fn e1000_write_phy_reg_page_hv(hw: *mut e1000_hw, offset: u32,
                                       data: u16) -> s32;
}
extern "C" {
    pub fn e1000_link_stall_workaround_hv(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_copper_link_setup_82577(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_check_polarity_82577(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_get_phy_info_82577(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_phy_force_speed_duplex_82577(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_get_cable_length_82577(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_write_phy_reg_gs40g(hw: *mut e1000_hw, offset: u32,
                                     data: u16) -> s32;
}
extern "C" {
    pub fn e1000_read_phy_reg_gs40g(hw: *mut e1000_hw, offset: u32,
                                    data: *mut u16) -> s32;
}
extern "C" {
    pub fn e1000_read_phy_reg_mphy(hw: *mut e1000_hw, address: u32,
                                   data: *mut u32) -> s32;
}
extern "C" {
    pub fn e1000_write_phy_reg_mphy(hw: *mut e1000_hw, address: u32,
                                    data: u32, line_override: bool_) -> s32;
}
extern "C" {
    pub fn e1000_is_mphy_ready(hw: *mut e1000_hw) -> bool_;
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct sfp_e1000_flags {
    pub _bitfield_1: u8,
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_sfp_e1000_flags() {
    assert_eq!(::core::mem::size_of::<sfp_e1000_flags>() , 1usize , concat ! (
               "Size of: " , stringify ! ( sfp_e1000_flags ) ));
    assert_eq! (::core::mem::align_of::<sfp_e1000_flags>() , 1usize , concat !
                ( "Alignment of " , stringify ! ( sfp_e1000_flags ) ));
}
impl Clone for sfp_e1000_flags {
    fn clone(&self) -> Self { *self }
}
impl sfp_e1000_flags {
    #[inline]
    pub fn e1000_base_sx(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 1u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_e1000_base_sx(&mut self, val: u8) {
        let mask = 1u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn e1000_base_lx(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 2u64 as u8;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_e1000_base_lx(&mut self, val: u8) {
        let mask = 2u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn e1000_base_cx(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 4u64 as u8;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_e1000_base_cx(&mut self, val: u8) {
        let mask = 4u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn e1000_base_t(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 8u64 as u8;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_e1000_base_t(&mut self, val: u8) {
        let mask = 8u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn e100_base_lx(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 16u64 as u8;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_e100_base_lx(&mut self, val: u8) {
        let mask = 16u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn e100_base_fx(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 32u64 as u8;
        let val = (unit_field_val & mask) >> 5usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_e100_base_fx(&mut self, val: u8) {
        let mask = 32u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 5usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn e10_base_bx10(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 64u64 as u8;
        let val = (unit_field_val & mask) >> 6usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_e10_base_bx10(&mut self, val: u8) {
        let mask = 64u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 6usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn e10_base_px(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 128u64 as u8;
        let val = (unit_field_val & mask) >> 7usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_e10_base_px(&mut self, val: u8) {
        let mask = 128u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 7usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(e1000_base_sx: u8, e1000_base_lx: u8,
                          e1000_base_cx: u8, e1000_base_t: u8,
                          e100_base_lx: u8, e100_base_fx: u8,
                          e10_base_bx10: u8, e10_base_px: u8) -> u8 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({
                                      ({
                                           ({ 0 } |
                                                ((e1000_base_sx as u8 as u8)
                                                     << 0usize) &
                                                    (1u64 as u8))
                                       } |
                                           ((e1000_base_lx as u8 as u8) <<
                                                1usize) & (2u64 as u8))
                                  } |
                                      ((e1000_base_cx as u8 as u8) << 2usize)
                                          & (4u64 as u8))
                             } |
                                 ((e1000_base_t as u8 as u8) << 3usize) &
                                     (8u64 as u8))
                        } |
                            ((e100_base_lx as u8 as u8) << 4usize) &
                                (16u64 as u8))
                   } | ((e100_base_fx as u8 as u8) << 5usize) & (32u64 as u8))
              } | ((e10_base_bx10 as u8 as u8) << 6usize) & (64u64 as u8))
         } | ((e10_base_px as u8 as u8) << 7usize) & (128u64 as u8))
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct e1000_pba {
    pub word: [u16; 2usize],
    pub pba_block: *mut u16,
}
#[test]
fn bindgen_test_layout_e1000_pba() {
    assert_eq!(::core::mem::size_of::<e1000_pba>() , 16usize , concat ! (
               "Size of: " , stringify ! ( e1000_pba ) ));
    assert_eq! (::core::mem::align_of::<e1000_pba>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( e1000_pba ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_pba ) ) . word as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_pba ) , "::" ,
                stringify ! ( word ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_pba ) ) . pba_block as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_pba ) , "::" ,
                stringify ! ( pba_block ) ));
}
impl Clone for e1000_pba {
    fn clone(&self) -> Self { *self }
}
impl Default for e1000_pba {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
extern "C" {
    pub fn e1000_init_nvm_ops_generic(hw: *mut e1000_hw);
}
extern "C" {
    pub fn e1000_null_read_nvm(hw: *mut e1000_hw, a: u16, b: u16, c: *mut u16)
     -> s32;
}
extern "C" {
    pub fn e1000_null_nvm_generic(hw: *mut e1000_hw);
}
extern "C" {
    pub fn e1000_null_led_default(hw: *mut e1000_hw, data: *mut u16) -> s32;
}
extern "C" {
    pub fn e1000_null_write_nvm(hw: *mut e1000_hw, a: u16, b: u16,
                                c: *mut u16) -> s32;
}
extern "C" {
    pub fn e1000_acquire_nvm_generic(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_poll_eerd_eewr_done(hw: *mut e1000_hw,
                                     ee_reg: ::kernel::sys::raw::c_int)
     -> s32;
}
extern "C" {
    pub fn e1000_read_mac_addr_generic(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_read_pba_string_generic(hw: *mut e1000_hw, pba_num: *mut u8,
                                         pba_num_size: u32) -> s32;
}
extern "C" {
    pub fn e1000_read_pba_length_generic(hw: *mut e1000_hw,
                                         pba_num_size: *mut u32) -> s32;
}
extern "C" {
    pub fn e1000_read_pba_raw(hw: *mut e1000_hw, eeprom_buf: *mut u16,
                              eeprom_buf_size: u32, max_pba_block_size: u16,
                              pba: *mut e1000_pba) -> s32;
}
extern "C" {
    pub fn e1000_write_pba_raw(hw: *mut e1000_hw, eeprom_buf: *mut u16,
                               eeprom_buf_size: u32, pba: *mut e1000_pba)
     -> s32;
}
extern "C" {
    pub fn e1000_get_pba_block_size(hw: *mut e1000_hw, eeprom_buf: *mut u16,
                                    eeprom_buf_size: u32,
                                    pba_block_size: *mut u16) -> s32;
}
extern "C" {
    pub fn e1000_read_nvm_spi(hw: *mut e1000_hw, offset: u16, words: u16,
                              data: *mut u16) -> s32;
}
extern "C" {
    pub fn e1000_read_nvm_microwire(hw: *mut e1000_hw, offset: u16,
                                    words: u16, data: *mut u16) -> s32;
}
extern "C" {
    pub fn e1000_read_nvm_eerd(hw: *mut e1000_hw, offset: u16, words: u16,
                               data: *mut u16) -> s32;
}
extern "C" {
    pub fn e1000_valid_led_default_generic(hw: *mut e1000_hw, data: *mut u16)
     -> s32;
}
extern "C" {
    pub fn e1000_validate_nvm_checksum_generic(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_write_nvm_microwire(hw: *mut e1000_hw, offset: u16,
                                     words: u16, data: *mut u16) -> s32;
}
extern "C" {
    pub fn e1000_write_nvm_spi(hw: *mut e1000_hw, offset: u16, words: u16,
                               data: *mut u16) -> s32;
}
extern "C" {
    pub fn e1000_update_nvm_checksum_generic(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_stop_nvm(hw: *mut e1000_hw);
}
extern "C" {
    pub fn e1000_release_nvm_generic(hw: *mut e1000_hw);
}
extern "C" {
    pub fn e1000_check_mng_mode_generic(hw: *mut e1000_hw) -> bool_;
}
extern "C" {
    pub fn e1000_enable_tx_pkt_filtering_generic(hw: *mut e1000_hw) -> bool_;
}
extern "C" {
    pub fn e1000_mng_enable_host_if_generic(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_mng_host_if_write_generic(hw: *mut e1000_hw, buffer: *mut u8,
                                           length: u16, offset: u16,
                                           sum: *mut u8) -> s32;
}
extern "C" {
    pub fn e1000_mng_write_cmd_header_generic(hw: *mut e1000_hw,
                                              hdr:
                                                  *mut e1000_host_mng_command_header)
     -> s32;
}
extern "C" {
    pub fn e1000_mng_write_dhcp_info_generic(hw: *mut e1000_hw,
                                             buffer: *mut u8, length: u16)
     -> s32;
}
extern "C" {
    pub fn e1000_enable_mng_pass_thru(hw: *mut e1000_hw) -> bool_;
}
extern "C" {
    pub fn e1000_calculate_checksum(buffer: *mut u8, length: u32) -> u8;
}
extern "C" {
    pub fn e1000_host_interface_command(hw: *mut e1000_hw, buffer: *mut u8,
                                        length: u32) -> s32;
}
extern "C" {
    pub fn e1000_load_firmware(hw: *mut e1000_hw, buffer: *mut u8,
                               length: u32) -> s32;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum e1000_mng_mode {
    e1000_mng_mode_none = 0,
    e1000_mng_mode_asf = 1,
    e1000_mng_mode_pt = 2,
    e1000_mng_mode_ipmi = 3,
    e1000_mng_mode_host_if_only = 4,
}
extern "C" {
    pub fn e1000_read_mbx(arg1: *mut e1000_hw, arg2: *mut u32, arg3: u16,
                          arg4: u16) -> s32;
}
extern "C" {
    pub fn e1000_write_mbx(arg1: *mut e1000_hw, arg2: *mut u32, arg3: u16,
                           arg4: u16) -> s32;
}
extern "C" {
    pub fn e1000_read_posted_mbx(arg1: *mut e1000_hw, arg2: *mut u32,
                                 arg3: u16, arg4: u16) -> s32;
}
extern "C" {
    pub fn e1000_write_posted_mbx(arg1: *mut e1000_hw, arg2: *mut u32,
                                  arg3: u16, arg4: u16) -> s32;
}
extern "C" {
    pub fn e1000_check_for_msg(arg1: *mut e1000_hw, arg2: u16) -> s32;
}
extern "C" {
    pub fn e1000_check_for_ack(arg1: *mut e1000_hw, arg2: u16) -> s32;
}
extern "C" {
    pub fn e1000_check_for_rst(arg1: *mut e1000_hw, arg2: u16) -> s32;
}
extern "C" {
    pub fn e1000_init_mbx_ops_generic(hw: *mut e1000_hw);
}
extern "C" {
    pub fn e1000_init_mbx_params_vf(arg1: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_init_mbx_params_pf(arg1: *mut e1000_hw) -> s32;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct e1000_mac_operations {
    pub init_params: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                     *mut e1000_hw)
                                                -> s32>,
    pub id_led_init: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                     *mut e1000_hw)
                                                -> s32>,
    pub blink_led: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                   *mut e1000_hw)
                                              -> s32>,
    pub check_mng_mode: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                        *mut e1000_hw)
                                                   -> bool_>,
    pub check_for_link: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                        *mut e1000_hw)
                                                   -> s32>,
    pub cleanup_led: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                     *mut e1000_hw)
                                                -> s32>,
    pub clear_hw_cntrs: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                        *mut e1000_hw)>,
    pub clear_vfta: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                    *mut e1000_hw)>,
    pub get_bus_info: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut e1000_hw)
                                                 -> s32>,
    pub set_lan_id: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                    *mut e1000_hw)>,
    pub get_link_up_info: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                          *mut e1000_hw,
                                                                      arg2:
                                                                          *mut u16,
                                                                      arg3:
                                                                          *mut u16)
                                                     -> s32>,
    pub led_on: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                *mut e1000_hw)
                                           -> s32>,
    pub led_off: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                 *mut e1000_hw)
                                            -> s32>,
    pub update_mc_addr_list: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                             *mut e1000_hw,
                                                                         arg2:
                                                                             *mut u8,
                                                                         arg3:
                                                                             u32)>,
    pub reset_hw: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                  *mut e1000_hw)
                                             -> s32>,
    pub init_hw: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                 *mut e1000_hw)
                                            -> s32>,
    pub shutdown_serdes: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                         *mut e1000_hw)>,
    pub power_up_serdes: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                         *mut e1000_hw)>,
    pub setup_link: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                    *mut e1000_hw)
                                               -> s32>,
    pub setup_physical_interface: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                                  *mut e1000_hw)
                                                             -> s32>,
    pub setup_led: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                   *mut e1000_hw)
                                              -> s32>,
    pub write_vfta: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                    *mut e1000_hw,
                                                                arg2: u32,
                                                                arg3: u32)>,
    pub config_collision_dist: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                               *mut e1000_hw)>,
    pub rar_set: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                 *mut e1000_hw,
                                                             arg2: *mut u8,
                                                             arg3: u32)
                                            -> ::kernel::sys::raw::c_int>,
    pub read_mac_addr: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                       *mut e1000_hw)
                                                  -> s32>,
    pub validate_mdi_setting: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                              *mut e1000_hw)
                                                         -> s32>,
    pub set_obff_timer: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                        *mut e1000_hw,
                                                                    arg2: u32)
                                                   -> s32>,
    pub acquire_swfw_sync: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                           *mut e1000_hw,
                                                                       arg2:
                                                                           u16)
                                                      -> s32>,
    pub release_swfw_sync: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                           *mut e1000_hw,
                                                                       arg2:
                                                                           u16)>,
}
#[test]
fn bindgen_test_layout_e1000_mac_operations() {
    assert_eq!(::core::mem::size_of::<e1000_mac_operations>() , 232usize ,
               concat ! ( "Size of: " , stringify ! ( e1000_mac_operations )
               ));
    assert_eq! (::core::mem::align_of::<e1000_mac_operations>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( e1000_mac_operations ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mac_operations ) ) . init_params as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mac_operations )
                , "::" , stringify ! ( init_params ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mac_operations ) ) . id_led_init as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mac_operations )
                , "::" , stringify ! ( id_led_init ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mac_operations ) ) . blink_led as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mac_operations )
                , "::" , stringify ! ( blink_led ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mac_operations ) ) . check_mng_mode
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mac_operations )
                , "::" , stringify ! ( check_mng_mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mac_operations ) ) . check_for_link
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mac_operations )
                , "::" , stringify ! ( check_for_link ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mac_operations ) ) . cleanup_led as
                * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mac_operations )
                , "::" , stringify ! ( cleanup_led ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mac_operations ) ) . clear_hw_cntrs
                as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mac_operations )
                , "::" , stringify ! ( clear_hw_cntrs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mac_operations ) ) . clear_vfta as
                * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mac_operations )
                , "::" , stringify ! ( clear_vfta ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mac_operations ) ) . get_bus_info
                as * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mac_operations )
                , "::" , stringify ! ( get_bus_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mac_operations ) ) . set_lan_id as
                * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mac_operations )
                , "::" , stringify ! ( set_lan_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mac_operations ) ) .
                get_link_up_info as * const _ as usize } , 80usize , concat !
                (
                "Alignment of field: " , stringify ! ( e1000_mac_operations )
                , "::" , stringify ! ( get_link_up_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mac_operations ) ) . led_on as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mac_operations )
                , "::" , stringify ! ( led_on ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mac_operations ) ) . led_off as *
                const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mac_operations )
                , "::" , stringify ! ( led_off ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mac_operations ) ) .
                update_mc_addr_list as * const _ as usize } , 104usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( e1000_mac_operations )
                , "::" , stringify ! ( update_mc_addr_list ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mac_operations ) ) . reset_hw as *
                const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mac_operations )
                , "::" , stringify ! ( reset_hw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mac_operations ) ) . init_hw as *
                const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mac_operations )
                , "::" , stringify ! ( init_hw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mac_operations ) ) .
                shutdown_serdes as * const _ as usize } , 128usize , concat !
                (
                "Alignment of field: " , stringify ! ( e1000_mac_operations )
                , "::" , stringify ! ( shutdown_serdes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mac_operations ) ) .
                power_up_serdes as * const _ as usize } , 136usize , concat !
                (
                "Alignment of field: " , stringify ! ( e1000_mac_operations )
                , "::" , stringify ! ( power_up_serdes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mac_operations ) ) . setup_link as
                * const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mac_operations )
                , "::" , stringify ! ( setup_link ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mac_operations ) ) .
                setup_physical_interface as * const _ as usize } , 152usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( e1000_mac_operations )
                , "::" , stringify ! ( setup_physical_interface ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mac_operations ) ) . setup_led as *
                const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mac_operations )
                , "::" , stringify ! ( setup_led ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mac_operations ) ) . write_vfta as
                * const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mac_operations )
                , "::" , stringify ! ( write_vfta ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mac_operations ) ) .
                config_collision_dist as * const _ as usize } , 176usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( e1000_mac_operations )
                , "::" , stringify ! ( config_collision_dist ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mac_operations ) ) . rar_set as *
                const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mac_operations )
                , "::" , stringify ! ( rar_set ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mac_operations ) ) . read_mac_addr
                as * const _ as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mac_operations )
                , "::" , stringify ! ( read_mac_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mac_operations ) ) .
                validate_mdi_setting as * const _ as usize } , 200usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( e1000_mac_operations )
                , "::" , stringify ! ( validate_mdi_setting ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mac_operations ) ) . set_obff_timer
                as * const _ as usize } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mac_operations )
                , "::" , stringify ! ( set_obff_timer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mac_operations ) ) .
                acquire_swfw_sync as * const _ as usize } , 216usize , concat
                ! (
                "Alignment of field: " , stringify ! ( e1000_mac_operations )
                , "::" , stringify ! ( acquire_swfw_sync ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mac_operations ) ) .
                release_swfw_sync as * const _ as usize } , 224usize , concat
                ! (
                "Alignment of field: " , stringify ! ( e1000_mac_operations )
                , "::" , stringify ! ( release_swfw_sync ) ));
}
impl Clone for e1000_mac_operations {
    fn clone(&self) -> Self { *self }
}
impl Default for e1000_mac_operations {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct e1000_phy_operations {
    pub init_params: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                     *mut e1000_hw)
                                                -> s32>,
    pub acquire: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                 *mut e1000_hw)
                                            -> s32>,
    pub cfg_on_link_up: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                        *mut e1000_hw)
                                                   -> s32>,
    pub check_polarity: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                        *mut e1000_hw)
                                                   -> s32>,
    pub check_reset_block: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                           *mut e1000_hw)
                                                      -> s32>,
    pub commit: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                *mut e1000_hw)
                                           -> s32>,
    pub force_speed_duplex: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                            *mut e1000_hw)
                                                       -> s32>,
    pub get_cfg_done: ::core::option::Option<unsafe extern "C" fn(hw:
                                                                      *mut e1000_hw)
                                                 -> s32>,
    pub get_cable_length: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                          *mut e1000_hw)
                                                     -> s32>,
    pub get_info: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                  *mut e1000_hw)
                                             -> s32>,
    pub set_page: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                  *mut e1000_hw,
                                                              arg2: u16)
                                             -> s32>,
    pub read_reg: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                  *mut e1000_hw,
                                                              arg2: u32,
                                                              arg3: *mut u16)
                                             -> s32>,
    pub read_reg_locked: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                         *mut e1000_hw,
                                                                     arg2:
                                                                         u32,
                                                                     arg3:
                                                                         *mut u16)
                                                    -> s32>,
    pub read_reg_page: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                       *mut e1000_hw,
                                                                   arg2: u32,
                                                                   arg3:
                                                                       *mut u16)
                                                  -> s32>,
    pub release: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                 *mut e1000_hw)>,
    pub reset: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                               *mut e1000_hw)
                                          -> s32>,
    pub set_d0_lplu_state: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                           *mut e1000_hw,
                                                                       arg2:
                                                                           bool_)
                                                      -> s32>,
    pub set_d3_lplu_state: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                           *mut e1000_hw,
                                                                       arg2:
                                                                           bool_)
                                                      -> s32>,
    pub write_reg: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                   *mut e1000_hw,
                                                               arg2: u32,
                                                               arg3: u16)
                                              -> s32>,
    pub write_reg_locked: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                          *mut e1000_hw,
                                                                      arg2:
                                                                          u32,
                                                                      arg3:
                                                                          u16)
                                                     -> s32>,
    pub write_reg_page: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                        *mut e1000_hw,
                                                                    arg2: u32,
                                                                    arg3: u16)
                                                   -> s32>,
    pub power_up: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                  *mut e1000_hw)>,
    pub power_down: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                    *mut e1000_hw)>,
    pub read_i2c_byte: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                       *mut e1000_hw,
                                                                   arg2: u8,
                                                                   arg3: u8,
                                                                   arg4:
                                                                       *mut u8)
                                                  -> s32>,
    pub write_i2c_byte: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                        *mut e1000_hw,
                                                                    arg2: u8,
                                                                    arg3: u8,
                                                                    arg4: u8)
                                                   -> s32>,
}
#[test]
fn bindgen_test_layout_e1000_phy_operations() {
    assert_eq!(::core::mem::size_of::<e1000_phy_operations>() , 200usize ,
               concat ! ( "Size of: " , stringify ! ( e1000_phy_operations )
               ));
    assert_eq! (::core::mem::align_of::<e1000_phy_operations>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( e1000_phy_operations ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_phy_operations ) ) . init_params as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_phy_operations )
                , "::" , stringify ! ( init_params ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_phy_operations ) ) . acquire as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_phy_operations )
                , "::" , stringify ! ( acquire ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_phy_operations ) ) . cfg_on_link_up
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_phy_operations )
                , "::" , stringify ! ( cfg_on_link_up ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_phy_operations ) ) . check_polarity
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_phy_operations )
                , "::" , stringify ! ( check_polarity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_phy_operations ) ) .
                check_reset_block as * const _ as usize } , 32usize , concat !
                (
                "Alignment of field: " , stringify ! ( e1000_phy_operations )
                , "::" , stringify ! ( check_reset_block ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_phy_operations ) ) . commit as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_phy_operations )
                , "::" , stringify ! ( commit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_phy_operations ) ) .
                force_speed_duplex as * const _ as usize } , 48usize , concat
                ! (
                "Alignment of field: " , stringify ! ( e1000_phy_operations )
                , "::" , stringify ! ( force_speed_duplex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_phy_operations ) ) . get_cfg_done
                as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_phy_operations )
                , "::" , stringify ! ( get_cfg_done ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_phy_operations ) ) .
                get_cable_length as * const _ as usize } , 64usize , concat !
                (
                "Alignment of field: " , stringify ! ( e1000_phy_operations )
                , "::" , stringify ! ( get_cable_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_phy_operations ) ) . get_info as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_phy_operations )
                , "::" , stringify ! ( get_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_phy_operations ) ) . set_page as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_phy_operations )
                , "::" , stringify ! ( set_page ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_phy_operations ) ) . read_reg as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_phy_operations )
                , "::" , stringify ! ( read_reg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_phy_operations ) ) .
                read_reg_locked as * const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_phy_operations )
                , "::" , stringify ! ( read_reg_locked ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_phy_operations ) ) . read_reg_page
                as * const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_phy_operations )
                , "::" , stringify ! ( read_reg_page ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_phy_operations ) ) . release as *
                const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_phy_operations )
                , "::" , stringify ! ( release ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_phy_operations ) ) . reset as *
                const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_phy_operations )
                , "::" , stringify ! ( reset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_phy_operations ) ) .
                set_d0_lplu_state as * const _ as usize } , 128usize , concat
                ! (
                "Alignment of field: " , stringify ! ( e1000_phy_operations )
                , "::" , stringify ! ( set_d0_lplu_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_phy_operations ) ) .
                set_d3_lplu_state as * const _ as usize } , 136usize , concat
                ! (
                "Alignment of field: " , stringify ! ( e1000_phy_operations )
                , "::" , stringify ! ( set_d3_lplu_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_phy_operations ) ) . write_reg as *
                const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_phy_operations )
                , "::" , stringify ! ( write_reg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_phy_operations ) ) .
                write_reg_locked as * const _ as usize } , 152usize , concat !
                (
                "Alignment of field: " , stringify ! ( e1000_phy_operations )
                , "::" , stringify ! ( write_reg_locked ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_phy_operations ) ) . write_reg_page
                as * const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_phy_operations )
                , "::" , stringify ! ( write_reg_page ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_phy_operations ) ) . power_up as *
                const _ as usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_phy_operations )
                , "::" , stringify ! ( power_up ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_phy_operations ) ) . power_down as
                * const _ as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_phy_operations )
                , "::" , stringify ! ( power_down ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_phy_operations ) ) . read_i2c_byte
                as * const _ as usize } , 184usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_phy_operations )
                , "::" , stringify ! ( read_i2c_byte ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_phy_operations ) ) . write_i2c_byte
                as * const _ as usize } , 192usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_phy_operations )
                , "::" , stringify ! ( write_i2c_byte ) ));
}
impl Clone for e1000_phy_operations {
    fn clone(&self) -> Self { *self }
}
impl Default for e1000_phy_operations {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct e1000_nvm_operations {
    pub init_params: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                     *mut e1000_hw)
                                                -> s32>,
    pub acquire: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                 *mut e1000_hw)
                                            -> s32>,
    pub read: ::core::option::Option<unsafe extern "C" fn(arg1: *mut e1000_hw,
                                                          arg2: u16,
                                                          arg3: u16,
                                                          arg4: *mut u16)
                                         -> s32>,
    pub release: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                 *mut e1000_hw)>,
    pub reload: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                *mut e1000_hw)>,
    pub update: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                *mut e1000_hw)
                                           -> s32>,
    pub valid_led_default: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                           *mut e1000_hw,
                                                                       arg2:
                                                                           *mut u16)
                                                      -> s32>,
    pub validate: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                  *mut e1000_hw)
                                             -> s32>,
    pub write: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                               *mut e1000_hw,
                                                           arg2: u16,
                                                           arg3: u16,
                                                           arg4: *mut u16)
                                          -> s32>,
}
#[test]
fn bindgen_test_layout_e1000_nvm_operations() {
    assert_eq!(::core::mem::size_of::<e1000_nvm_operations>() , 72usize ,
               concat ! ( "Size of: " , stringify ! ( e1000_nvm_operations )
               ));
    assert_eq! (::core::mem::align_of::<e1000_nvm_operations>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( e1000_nvm_operations ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_nvm_operations ) ) . init_params as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_nvm_operations )
                , "::" , stringify ! ( init_params ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_nvm_operations ) ) . acquire as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_nvm_operations )
                , "::" , stringify ! ( acquire ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_nvm_operations ) ) . read as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_nvm_operations )
                , "::" , stringify ! ( read ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_nvm_operations ) ) . release as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_nvm_operations )
                , "::" , stringify ! ( release ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_nvm_operations ) ) . reload as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_nvm_operations )
                , "::" , stringify ! ( reload ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_nvm_operations ) ) . update as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_nvm_operations )
                , "::" , stringify ! ( update ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_nvm_operations ) ) .
                valid_led_default as * const _ as usize } , 48usize , concat !
                (
                "Alignment of field: " , stringify ! ( e1000_nvm_operations )
                , "::" , stringify ! ( valid_led_default ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_nvm_operations ) ) . validate as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_nvm_operations )
                , "::" , stringify ! ( validate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_nvm_operations ) ) . write as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_nvm_operations )
                , "::" , stringify ! ( write ) ));
}
impl Clone for e1000_nvm_operations {
    fn clone(&self) -> Self { *self }
}
impl Default for e1000_nvm_operations {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct e1000_mac_info {
    pub ops: e1000_mac_operations,
    pub addr: [u8; 6usize],
    pub perm_addr: [u8; 6usize],
    pub type_: e1000_mac_type,
    pub collision_delta: u32,
    pub ledctl_default: u32,
    pub ledctl_mode1: u32,
    pub ledctl_mode2: u32,
    pub mc_filter_type: u32,
    pub tx_packet_delta: u32,
    pub txcw: u32,
    pub current_ifs_val: u16,
    pub ifs_max_val: u16,
    pub ifs_min_val: u16,
    pub ifs_ratio: u16,
    pub ifs_step_size: u16,
    pub mta_reg_count: u16,
    pub uta_reg_count: u16,
    pub mta_shadow: [u32; 128usize],
    pub rar_entry_count: u16,
    pub forced_speed_duplex: u8,
    pub adaptive_ifs: bool_,
    pub has_fwsm: bool_,
    pub arc_subsystem_valid: bool_,
    pub asf_firmware_present: bool_,
    pub autoneg: bool_,
    pub autoneg_failed: bool_,
    pub get_link_status: bool_,
    pub in_ifs_mode: bool_,
    pub report_tx_early: bool_,
    pub serdes_link_state: e1000_serdes_link_state,
    pub serdes_has_link: bool_,
    pub tx_pkt_filtering: bool_,
    pub max_frame_size: u32,
}
#[test]
fn bindgen_test_layout_e1000_mac_info() {
    assert_eq!(::core::mem::size_of::<e1000_mac_info>() , 832usize , concat !
               ( "Size of: " , stringify ! ( e1000_mac_info ) ));
    assert_eq! (::core::mem::align_of::<e1000_mac_info>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( e1000_mac_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mac_info ) ) . ops as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mac_info ) , "::"
                , stringify ! ( ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mac_info ) ) . addr as * const _ as
                usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mac_info ) , "::"
                , stringify ! ( addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mac_info ) ) . perm_addr as * const
                _ as usize } , 238usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mac_info ) , "::"
                , stringify ! ( perm_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mac_info ) ) . type_ as * const _
                as usize } , 244usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mac_info ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mac_info ) ) . collision_delta as *
                const _ as usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mac_info ) , "::"
                , stringify ! ( collision_delta ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mac_info ) ) . ledctl_default as *
                const _ as usize } , 252usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mac_info ) , "::"
                , stringify ! ( ledctl_default ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mac_info ) ) . ledctl_mode1 as *
                const _ as usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mac_info ) , "::"
                , stringify ! ( ledctl_mode1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mac_info ) ) . ledctl_mode2 as *
                const _ as usize } , 260usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mac_info ) , "::"
                , stringify ! ( ledctl_mode2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mac_info ) ) . mc_filter_type as *
                const _ as usize } , 264usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mac_info ) , "::"
                , stringify ! ( mc_filter_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mac_info ) ) . tx_packet_delta as *
                const _ as usize } , 268usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mac_info ) , "::"
                , stringify ! ( tx_packet_delta ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mac_info ) ) . txcw as * const _ as
                usize } , 272usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mac_info ) , "::"
                , stringify ! ( txcw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mac_info ) ) . current_ifs_val as *
                const _ as usize } , 276usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mac_info ) , "::"
                , stringify ! ( current_ifs_val ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mac_info ) ) . ifs_max_val as *
                const _ as usize } , 278usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mac_info ) , "::"
                , stringify ! ( ifs_max_val ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mac_info ) ) . ifs_min_val as *
                const _ as usize } , 280usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mac_info ) , "::"
                , stringify ! ( ifs_min_val ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mac_info ) ) . ifs_ratio as * const
                _ as usize } , 282usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mac_info ) , "::"
                , stringify ! ( ifs_ratio ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mac_info ) ) . ifs_step_size as *
                const _ as usize } , 284usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mac_info ) , "::"
                , stringify ! ( ifs_step_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mac_info ) ) . mta_reg_count as *
                const _ as usize } , 286usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mac_info ) , "::"
                , stringify ! ( mta_reg_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mac_info ) ) . uta_reg_count as *
                const _ as usize } , 288usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mac_info ) , "::"
                , stringify ! ( uta_reg_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mac_info ) ) . mta_shadow as *
                const _ as usize } , 292usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mac_info ) , "::"
                , stringify ! ( mta_shadow ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mac_info ) ) . rar_entry_count as *
                const _ as usize } , 804usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mac_info ) , "::"
                , stringify ! ( rar_entry_count ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mac_info ) ) . forced_speed_duplex
                as * const _ as usize } , 806usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mac_info ) , "::"
                , stringify ! ( forced_speed_duplex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mac_info ) ) . adaptive_ifs as *
                const _ as usize } , 807usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mac_info ) , "::"
                , stringify ! ( adaptive_ifs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mac_info ) ) . has_fwsm as * const
                _ as usize } , 808usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mac_info ) , "::"
                , stringify ! ( has_fwsm ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mac_info ) ) . arc_subsystem_valid
                as * const _ as usize } , 809usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mac_info ) , "::"
                , stringify ! ( arc_subsystem_valid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mac_info ) ) . asf_firmware_present
                as * const _ as usize } , 810usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mac_info ) , "::"
                , stringify ! ( asf_firmware_present ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mac_info ) ) . autoneg as * const _
                as usize } , 811usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mac_info ) , "::"
                , stringify ! ( autoneg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mac_info ) ) . autoneg_failed as *
                const _ as usize } , 812usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mac_info ) , "::"
                , stringify ! ( autoneg_failed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mac_info ) ) . get_link_status as *
                const _ as usize } , 813usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mac_info ) , "::"
                , stringify ! ( get_link_status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mac_info ) ) . in_ifs_mode as *
                const _ as usize } , 814usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mac_info ) , "::"
                , stringify ! ( in_ifs_mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mac_info ) ) . report_tx_early as *
                const _ as usize } , 815usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mac_info ) , "::"
                , stringify ! ( report_tx_early ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mac_info ) ) . serdes_link_state as
                * const _ as usize } , 816usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mac_info ) , "::"
                , stringify ! ( serdes_link_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mac_info ) ) . serdes_has_link as *
                const _ as usize } , 820usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mac_info ) , "::"
                , stringify ! ( serdes_has_link ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mac_info ) ) . tx_pkt_filtering as
                * const _ as usize } , 821usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mac_info ) , "::"
                , stringify ! ( tx_pkt_filtering ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mac_info ) ) . max_frame_size as *
                const _ as usize } , 824usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mac_info ) , "::"
                , stringify ! ( max_frame_size ) ));
}
impl Clone for e1000_mac_info {
    fn clone(&self) -> Self { *self }
}
impl Default for e1000_mac_info {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for e1000_mac_info {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "e1000_mac_info {{ ops: {:?}, addr: {:?}, perm_addr: {:?}, type: {:?}, collision_delta: {:?}, ledctl_default: {:?}, ledctl_mode1: {:?}, ledctl_mode2: {:?}, mc_filter_type: {:?}, tx_packet_delta: {:?}, txcw: {:?}, current_ifs_val: {:?}, ifs_max_val: {:?}, ifs_min_val: {:?}, ifs_ratio: {:?}, ifs_step_size: {:?}, mta_reg_count: {:?}, uta_reg_count: {:?}, mta_shadow: [{}], rar_entry_count: {:?}, forced_speed_duplex: {:?}, adaptive_ifs: {:?}, has_fwsm: {:?}, arc_subsystem_valid: {:?}, asf_firmware_present: {:?}, autoneg: {:?}, autoneg_failed: {:?}, get_link_status: {:?}, in_ifs_mode: {:?}, report_tx_early: {:?}, serdes_link_state: {:?}, serdes_has_link: {:?}, tx_pkt_filtering: {:?}, max_frame_size: {:?} }}"
               , self . ops , self . addr , self . perm_addr , self . type ,
               self . collision_delta , self . ledctl_default , self .
               ledctl_mode1 , self . ledctl_mode2 , self . mc_filter_type ,
               self . tx_packet_delta , self . txcw , self . current_ifs_val ,
               self . ifs_max_val , self . ifs_min_val , self . ifs_ratio ,
               self . ifs_step_size , self . mta_reg_count , self .
               uta_reg_count , self . mta_shadow . iter (  ) . enumerate (  )
               . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ) , self . rar_entry_count , self .
               forced_speed_duplex , self . adaptive_ifs , self . has_fwsm ,
               self . arc_subsystem_valid , self . asf_firmware_present , self
               . autoneg , self . autoneg_failed , self . get_link_status ,
               self . in_ifs_mode , self . report_tx_early , self .
               serdes_link_state , self . serdes_has_link , self .
               tx_pkt_filtering , self . max_frame_size)
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct e1000_phy_info {
    pub ops: e1000_phy_operations,
    pub type_: e1000_phy_type,
    pub local_rx: e1000_1000t_rx_status,
    pub remote_rx: e1000_1000t_rx_status,
    pub ms_type: e1000_ms_type,
    pub original_ms_type: e1000_ms_type,
    pub cable_polarity: e1000_rev_polarity,
    pub smart_speed: e1000_smart_speed,
    pub addr: u32,
    pub id: u32,
    pub reset_delay_us: u32,
    pub revision: u32,
    pub media_type: e1000_media_type,
    pub autoneg_advertised: u16,
    pub autoneg_mask: u16,
    pub cable_length: u16,
    pub max_cable_length: u16,
    pub min_cable_length: u16,
    pub mdix: u8,
    pub disable_polarity_correction: bool_,
    pub is_mdix: bool_,
    pub polarity_correction: bool_,
    pub speed_downgraded: bool_,
    pub autoneg_wait_to_complete: bool_,
}
#[test]
fn bindgen_test_layout_e1000_phy_info() {
    assert_eq!(::core::mem::size_of::<e1000_phy_info>() , 264usize , concat !
               ( "Size of: " , stringify ! ( e1000_phy_info ) ));
    assert_eq! (::core::mem::align_of::<e1000_phy_info>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( e1000_phy_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_phy_info ) ) . ops as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_phy_info ) , "::"
                , stringify ! ( ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_phy_info ) ) . type_ as * const _
                as usize } , 200usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_phy_info ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_phy_info ) ) . local_rx as * const
                _ as usize } , 204usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_phy_info ) , "::"
                , stringify ! ( local_rx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_phy_info ) ) . remote_rx as * const
                _ as usize } , 208usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_phy_info ) , "::"
                , stringify ! ( remote_rx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_phy_info ) ) . ms_type as * const _
                as usize } , 212usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_phy_info ) , "::"
                , stringify ! ( ms_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_phy_info ) ) . original_ms_type as
                * const _ as usize } , 216usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_phy_info ) , "::"
                , stringify ! ( original_ms_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_phy_info ) ) . cable_polarity as *
                const _ as usize } , 220usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_phy_info ) , "::"
                , stringify ! ( cable_polarity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_phy_info ) ) . smart_speed as *
                const _ as usize } , 224usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_phy_info ) , "::"
                , stringify ! ( smart_speed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_phy_info ) ) . addr as * const _ as
                usize } , 228usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_phy_info ) , "::"
                , stringify ! ( addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_phy_info ) ) . id as * const _ as
                usize } , 232usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_phy_info ) , "::"
                , stringify ! ( id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_phy_info ) ) . reset_delay_us as *
                const _ as usize } , 236usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_phy_info ) , "::"
                , stringify ! ( reset_delay_us ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_phy_info ) ) . revision as * const
                _ as usize } , 240usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_phy_info ) , "::"
                , stringify ! ( revision ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_phy_info ) ) . media_type as *
                const _ as usize } , 244usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_phy_info ) , "::"
                , stringify ! ( media_type ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_phy_info ) ) . autoneg_advertised
                as * const _ as usize } , 248usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_phy_info ) , "::"
                , stringify ! ( autoneg_advertised ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_phy_info ) ) . autoneg_mask as *
                const _ as usize } , 250usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_phy_info ) , "::"
                , stringify ! ( autoneg_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_phy_info ) ) . cable_length as *
                const _ as usize } , 252usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_phy_info ) , "::"
                , stringify ! ( cable_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_phy_info ) ) . max_cable_length as
                * const _ as usize } , 254usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_phy_info ) , "::"
                , stringify ! ( max_cable_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_phy_info ) ) . min_cable_length as
                * const _ as usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_phy_info ) , "::"
                , stringify ! ( min_cable_length ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_phy_info ) ) . mdix as * const _ as
                usize } , 258usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_phy_info ) , "::"
                , stringify ! ( mdix ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_phy_info ) ) .
                disable_polarity_correction as * const _ as usize } , 259usize
                , concat ! (
                "Alignment of field: " , stringify ! ( e1000_phy_info ) , "::"
                , stringify ! ( disable_polarity_correction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_phy_info ) ) . is_mdix as * const _
                as usize } , 260usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_phy_info ) , "::"
                , stringify ! ( is_mdix ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_phy_info ) ) . polarity_correction
                as * const _ as usize } , 261usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_phy_info ) , "::"
                , stringify ! ( polarity_correction ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_phy_info ) ) . speed_downgraded as
                * const _ as usize } , 262usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_phy_info ) , "::"
                , stringify ! ( speed_downgraded ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_phy_info ) ) .
                autoneg_wait_to_complete as * const _ as usize } , 263usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( e1000_phy_info ) , "::"
                , stringify ! ( autoneg_wait_to_complete ) ));
}
impl Clone for e1000_phy_info {
    fn clone(&self) -> Self { *self }
}
impl Default for e1000_phy_info {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct e1000_nvm_info {
    pub ops: e1000_nvm_operations,
    pub type_: e1000_nvm_type,
    pub override_: e1000_nvm_override,
    pub flash_bank_size: u32,
    pub flash_base_addr: u32,
    pub word_size: u16,
    pub delay_usec: u16,
    pub address_bits: u16,
    pub opcode_bits: u16,
    pub page_size: u16,
}
#[test]
fn bindgen_test_layout_e1000_nvm_info() {
    assert_eq!(::core::mem::size_of::<e1000_nvm_info>() , 104usize , concat !
               ( "Size of: " , stringify ! ( e1000_nvm_info ) ));
    assert_eq! (::core::mem::align_of::<e1000_nvm_info>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( e1000_nvm_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_nvm_info ) ) . ops as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_nvm_info ) , "::"
                , stringify ! ( ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_nvm_info ) ) . type_ as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_nvm_info ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_nvm_info ) ) . override_ as * const
                _ as usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_nvm_info ) , "::"
                , stringify ! ( override_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_nvm_info ) ) . flash_bank_size as *
                const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_nvm_info ) , "::"
                , stringify ! ( flash_bank_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_nvm_info ) ) . flash_base_addr as *
                const _ as usize } , 84usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_nvm_info ) , "::"
                , stringify ! ( flash_base_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_nvm_info ) ) . word_size as * const
                _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_nvm_info ) , "::"
                , stringify ! ( word_size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_nvm_info ) ) . delay_usec as *
                const _ as usize } , 90usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_nvm_info ) , "::"
                , stringify ! ( delay_usec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_nvm_info ) ) . address_bits as *
                const _ as usize } , 92usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_nvm_info ) , "::"
                , stringify ! ( address_bits ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_nvm_info ) ) . opcode_bits as *
                const _ as usize } , 94usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_nvm_info ) , "::"
                , stringify ! ( opcode_bits ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_nvm_info ) ) . page_size as * const
                _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_nvm_info ) , "::"
                , stringify ! ( page_size ) ));
}
impl Clone for e1000_nvm_info {
    fn clone(&self) -> Self { *self }
}
impl Default for e1000_nvm_info {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct e1000_bus_info {
    pub type_: e1000_bus_type,
    pub speed: e1000_bus_speed,
    pub width: e1000_bus_width,
    pub func: u16,
    pub pci_cmd_word: u16,
}
#[test]
fn bindgen_test_layout_e1000_bus_info() {
    assert_eq!(::core::mem::size_of::<e1000_bus_info>() , 16usize , concat ! (
               "Size of: " , stringify ! ( e1000_bus_info ) ));
    assert_eq! (::core::mem::align_of::<e1000_bus_info>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( e1000_bus_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_bus_info ) ) . type_ as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_bus_info ) , "::"
                , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_bus_info ) ) . speed as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_bus_info ) , "::"
                , stringify ! ( speed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_bus_info ) ) . width as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_bus_info ) , "::"
                , stringify ! ( width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_bus_info ) ) . func as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_bus_info ) , "::"
                , stringify ! ( func ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_bus_info ) ) . pci_cmd_word as *
                const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_bus_info ) , "::"
                , stringify ! ( pci_cmd_word ) ));
}
impl Clone for e1000_bus_info {
    fn clone(&self) -> Self { *self }
}
impl Default for e1000_bus_info {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct e1000_fc_info {
    pub high_water: u32,
    pub low_water: u32,
    pub pause_time: u16,
    pub refresh_time: u16,
    pub send_xon: bool_,
    pub strict_ieee: bool_,
    pub current_mode: e1000_fc_mode,
    pub requested_mode: e1000_fc_mode,
}
#[test]
fn bindgen_test_layout_e1000_fc_info() {
    assert_eq!(::core::mem::size_of::<e1000_fc_info>() , 24usize , concat ! (
               "Size of: " , stringify ! ( e1000_fc_info ) ));
    assert_eq! (::core::mem::align_of::<e1000_fc_info>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( e1000_fc_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_fc_info ) ) . high_water as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_fc_info ) , "::"
                , stringify ! ( high_water ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_fc_info ) ) . low_water as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_fc_info ) , "::"
                , stringify ! ( low_water ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_fc_info ) ) . pause_time as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_fc_info ) , "::"
                , stringify ! ( pause_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_fc_info ) ) . refresh_time as *
                const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_fc_info ) , "::"
                , stringify ! ( refresh_time ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_fc_info ) ) . send_xon as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_fc_info ) , "::"
                , stringify ! ( send_xon ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_fc_info ) ) . strict_ieee as *
                const _ as usize } , 13usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_fc_info ) , "::"
                , stringify ! ( strict_ieee ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_fc_info ) ) . current_mode as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_fc_info ) , "::"
                , stringify ! ( current_mode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_fc_info ) ) . requested_mode as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_fc_info ) , "::"
                , stringify ! ( requested_mode ) ));
}
impl Clone for e1000_fc_info {
    fn clone(&self) -> Self { *self }
}
impl Default for e1000_fc_info {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct e1000_mbx_operations {
    pub init_params: ::core::option::Option<unsafe extern "C" fn(hw:
                                                                     *mut e1000_hw)
                                                -> s32>,
    pub read: ::core::option::Option<unsafe extern "C" fn(arg1: *mut e1000_hw,
                                                          arg2: *mut u32,
                                                          arg3: u16,
                                                          arg4: u16) -> s32>,
    pub write: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                               *mut e1000_hw,
                                                           arg2: *mut u32,
                                                           arg3: u16,
                                                           arg4: u16) -> s32>,
    pub read_posted: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                     *mut e1000_hw,
                                                                 arg2:
                                                                     *mut u32,
                                                                 arg3: u16,
                                                                 arg4: u16)
                                                -> s32>,
    pub write_posted: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                      *mut e1000_hw,
                                                                  arg2:
                                                                      *mut u32,
                                                                  arg3: u16,
                                                                  arg4: u16)
                                                 -> s32>,
    pub check_for_msg: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                       *mut e1000_hw,
                                                                   arg2: u16)
                                                  -> s32>,
    pub check_for_ack: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                       *mut e1000_hw,
                                                                   arg2: u16)
                                                  -> s32>,
    pub check_for_rst: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                       *mut e1000_hw,
                                                                   arg2: u16)
                                                  -> s32>,
}
#[test]
fn bindgen_test_layout_e1000_mbx_operations() {
    assert_eq!(::core::mem::size_of::<e1000_mbx_operations>() , 64usize ,
               concat ! ( "Size of: " , stringify ! ( e1000_mbx_operations )
               ));
    assert_eq! (::core::mem::align_of::<e1000_mbx_operations>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( e1000_mbx_operations ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mbx_operations ) ) . init_params as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mbx_operations )
                , "::" , stringify ! ( init_params ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mbx_operations ) ) . read as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mbx_operations )
                , "::" , stringify ! ( read ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mbx_operations ) ) . write as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mbx_operations )
                , "::" , stringify ! ( write ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mbx_operations ) ) . read_posted as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mbx_operations )
                , "::" , stringify ! ( read_posted ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mbx_operations ) ) . write_posted
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mbx_operations )
                , "::" , stringify ! ( write_posted ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mbx_operations ) ) . check_for_msg
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mbx_operations )
                , "::" , stringify ! ( check_for_msg ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mbx_operations ) ) . check_for_ack
                as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mbx_operations )
                , "::" , stringify ! ( check_for_ack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mbx_operations ) ) . check_for_rst
                as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mbx_operations )
                , "::" , stringify ! ( check_for_rst ) ));
}
impl Clone for e1000_mbx_operations {
    fn clone(&self) -> Self { *self }
}
impl Default for e1000_mbx_operations {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct e1000_mbx_stats {
    pub msgs_tx: u32,
    pub msgs_rx: u32,
    pub acks: u32,
    pub reqs: u32,
    pub rsts: u32,
}
#[test]
fn bindgen_test_layout_e1000_mbx_stats() {
    assert_eq!(::core::mem::size_of::<e1000_mbx_stats>() , 20usize , concat !
               ( "Size of: " , stringify ! ( e1000_mbx_stats ) ));
    assert_eq! (::core::mem::align_of::<e1000_mbx_stats>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( e1000_mbx_stats ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mbx_stats ) ) . msgs_tx as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mbx_stats ) ,
                "::" , stringify ! ( msgs_tx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mbx_stats ) ) . msgs_rx as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mbx_stats ) ,
                "::" , stringify ! ( msgs_rx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mbx_stats ) ) . acks as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mbx_stats ) ,
                "::" , stringify ! ( acks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mbx_stats ) ) . reqs as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mbx_stats ) ,
                "::" , stringify ! ( reqs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mbx_stats ) ) . rsts as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mbx_stats ) ,
                "::" , stringify ! ( rsts ) ));
}
impl Clone for e1000_mbx_stats {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct e1000_mbx_info {
    pub ops: e1000_mbx_operations,
    pub stats: e1000_mbx_stats,
    pub timeout: u32,
    pub usec_delay: u32,
    pub size: u16,
}
#[test]
fn bindgen_test_layout_e1000_mbx_info() {
    assert_eq!(::core::mem::size_of::<e1000_mbx_info>() , 96usize , concat ! (
               "Size of: " , stringify ! ( e1000_mbx_info ) ));
    assert_eq! (::core::mem::align_of::<e1000_mbx_info>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( e1000_mbx_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mbx_info ) ) . ops as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mbx_info ) , "::"
                , stringify ! ( ops ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mbx_info ) ) . stats as * const _
                as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mbx_info ) , "::"
                , stringify ! ( stats ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mbx_info ) ) . timeout as * const _
                as usize } , 84usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mbx_info ) , "::"
                , stringify ! ( timeout ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mbx_info ) ) . usec_delay as *
                const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mbx_info ) , "::"
                , stringify ! ( usec_delay ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_mbx_info ) ) . size as * const _ as
                usize } , 92usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_mbx_info ) , "::"
                , stringify ! ( size ) ));
}
impl Clone for e1000_mbx_info {
    fn clone(&self) -> Self { *self }
}
impl Default for e1000_mbx_info {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct e1000_dev_spec_82541 {
    pub dsp_config: e1000_dsp_config,
    pub ffe_config: e1000_ffe_config,
    pub spd_default: u16,
    pub phy_init_script: bool_,
}
#[test]
fn bindgen_test_layout_e1000_dev_spec_82541() {
    assert_eq!(::core::mem::size_of::<e1000_dev_spec_82541>() , 12usize ,
               concat ! ( "Size of: " , stringify ! ( e1000_dev_spec_82541 )
               ));
    assert_eq! (::core::mem::align_of::<e1000_dev_spec_82541>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( e1000_dev_spec_82541 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_dev_spec_82541 ) ) . dsp_config as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_dev_spec_82541 )
                , "::" , stringify ! ( dsp_config ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_dev_spec_82541 ) ) . ffe_config as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_dev_spec_82541 )
                , "::" , stringify ! ( ffe_config ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_dev_spec_82541 ) ) . spd_default as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_dev_spec_82541 )
                , "::" , stringify ! ( spd_default ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_dev_spec_82541 ) ) .
                phy_init_script as * const _ as usize } , 10usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_dev_spec_82541 )
                , "::" , stringify ! ( phy_init_script ) ));
}
impl Clone for e1000_dev_spec_82541 {
    fn clone(&self) -> Self { *self }
}
impl Default for e1000_dev_spec_82541 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct e1000_dev_spec_82542 {
    pub dma_fairness: bool_,
}
#[test]
fn bindgen_test_layout_e1000_dev_spec_82542() {
    assert_eq!(::core::mem::size_of::<e1000_dev_spec_82542>() , 1usize ,
               concat ! ( "Size of: " , stringify ! ( e1000_dev_spec_82542 )
               ));
    assert_eq! (::core::mem::align_of::<e1000_dev_spec_82542>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( e1000_dev_spec_82542 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_dev_spec_82542 ) ) . dma_fairness
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_dev_spec_82542 )
                , "::" , stringify ! ( dma_fairness ) ));
}
impl Clone for e1000_dev_spec_82542 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct e1000_dev_spec_82543 {
    pub tbi_compatibility: u32,
    pub dma_fairness: bool_,
    pub init_phy_disabled: bool_,
}
#[test]
fn bindgen_test_layout_e1000_dev_spec_82543() {
    assert_eq!(::core::mem::size_of::<e1000_dev_spec_82543>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( e1000_dev_spec_82543 )
               ));
    assert_eq! (::core::mem::align_of::<e1000_dev_spec_82543>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( e1000_dev_spec_82543 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_dev_spec_82543 ) ) .
                tbi_compatibility as * const _ as usize } , 0usize , concat !
                (
                "Alignment of field: " , stringify ! ( e1000_dev_spec_82543 )
                , "::" , stringify ! ( tbi_compatibility ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_dev_spec_82543 ) ) . dma_fairness
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_dev_spec_82543 )
                , "::" , stringify ! ( dma_fairness ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_dev_spec_82543 ) ) .
                init_phy_disabled as * const _ as usize } , 5usize , concat !
                (
                "Alignment of field: " , stringify ! ( e1000_dev_spec_82543 )
                , "::" , stringify ! ( init_phy_disabled ) ));
}
impl Clone for e1000_dev_spec_82543 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct e1000_dev_spec_82571 {
    pub laa_is_present: bool_,
    pub smb_counter: u32,
}
#[test]
fn bindgen_test_layout_e1000_dev_spec_82571() {
    assert_eq!(::core::mem::size_of::<e1000_dev_spec_82571>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( e1000_dev_spec_82571 )
               ));
    assert_eq! (::core::mem::align_of::<e1000_dev_spec_82571>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( e1000_dev_spec_82571 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_dev_spec_82571 ) ) . laa_is_present
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_dev_spec_82571 )
                , "::" , stringify ! ( laa_is_present ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_dev_spec_82571 ) ) . smb_counter as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_dev_spec_82571 )
                , "::" , stringify ! ( smb_counter ) ));
}
impl Clone for e1000_dev_spec_82571 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct e1000_dev_spec_80003es2lan {
    pub mdic_wa_enable: bool_,
}
#[test]
fn bindgen_test_layout_e1000_dev_spec_80003es2lan() {
    assert_eq!(::core::mem::size_of::<e1000_dev_spec_80003es2lan>() , 1usize ,
               concat ! (
               "Size of: " , stringify ! ( e1000_dev_spec_80003es2lan ) ));
    assert_eq! (::core::mem::align_of::<e1000_dev_spec_80003es2lan>() , 1usize
                , concat ! (
                "Alignment of " , stringify ! ( e1000_dev_spec_80003es2lan )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_dev_spec_80003es2lan ) ) .
                mdic_wa_enable as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_dev_spec_80003es2lan ) , "::" , stringify ! (
                mdic_wa_enable ) ));
}
impl Clone for e1000_dev_spec_80003es2lan {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct e1000_shadow_ram {
    pub value: u16,
    pub modified: bool_,
}
#[test]
fn bindgen_test_layout_e1000_shadow_ram() {
    assert_eq!(::core::mem::size_of::<e1000_shadow_ram>() , 4usize , concat !
               ( "Size of: " , stringify ! ( e1000_shadow_ram ) ));
    assert_eq! (::core::mem::align_of::<e1000_shadow_ram>() , 2usize , concat
                ! ( "Alignment of " , stringify ! ( e1000_shadow_ram ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_shadow_ram ) ) . value as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_shadow_ram ) ,
                "::" , stringify ! ( value ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_shadow_ram ) ) . modified as *
                const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_shadow_ram ) ,
                "::" , stringify ! ( modified ) ));
}
impl Clone for e1000_shadow_ram {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum e1000_ulp_state {
    e1000_ulp_state_unknown = 0,
    e1000_ulp_state_off = 1,
    e1000_ulp_state_on = 2,
}
#[repr(C)]
#[derive(Copy)]
pub struct e1000_dev_spec_ich8lan {
    pub kmrn_lock_loss_workaround_enabled: bool_,
    pub shadow_ram: [e1000_shadow_ram; 2048usize],
    pub nvm_k1_enabled: bool_,
    pub disable_k1_off: bool_,
    pub eee_disable: bool_,
    pub eee_lp_ability: u16,
    pub ulp_state: e1000_ulp_state,
    pub ulp_capability_disabled: bool_,
    pub during_suspend_flow: bool_,
    pub during_dpg_exit: bool_,
}
#[test]
fn bindgen_test_layout_e1000_dev_spec_ich8lan() {
    assert_eq!(::core::mem::size_of::<e1000_dev_spec_ich8lan>() , 8208usize ,
               concat ! ( "Size of: " , stringify ! ( e1000_dev_spec_ich8lan )
               ));
    assert_eq! (::core::mem::align_of::<e1000_dev_spec_ich8lan>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( e1000_dev_spec_ich8lan ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_dev_spec_ich8lan ) ) .
                kmrn_lock_loss_workaround_enabled as * const _ as usize } ,
                0usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_dev_spec_ich8lan
                ) , "::" , stringify ! ( kmrn_lock_loss_workaround_enabled )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_dev_spec_ich8lan ) ) . shadow_ram
                as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_dev_spec_ich8lan
                ) , "::" , stringify ! ( shadow_ram ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_dev_spec_ich8lan ) ) .
                nvm_k1_enabled as * const _ as usize } , 8194usize , concat !
                (
                "Alignment of field: " , stringify ! ( e1000_dev_spec_ich8lan
                ) , "::" , stringify ! ( nvm_k1_enabled ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_dev_spec_ich8lan ) ) .
                disable_k1_off as * const _ as usize } , 8195usize , concat !
                (
                "Alignment of field: " , stringify ! ( e1000_dev_spec_ich8lan
                ) , "::" , stringify ! ( disable_k1_off ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_dev_spec_ich8lan ) ) . eee_disable
                as * const _ as usize } , 8196usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_dev_spec_ich8lan
                ) , "::" , stringify ! ( eee_disable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_dev_spec_ich8lan ) ) .
                eee_lp_ability as * const _ as usize } , 8198usize , concat !
                (
                "Alignment of field: " , stringify ! ( e1000_dev_spec_ich8lan
                ) , "::" , stringify ! ( eee_lp_ability ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_dev_spec_ich8lan ) ) . ulp_state as
                * const _ as usize } , 8200usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_dev_spec_ich8lan
                ) , "::" , stringify ! ( ulp_state ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_dev_spec_ich8lan ) ) .
                ulp_capability_disabled as * const _ as usize } , 8204usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( e1000_dev_spec_ich8lan
                ) , "::" , stringify ! ( ulp_capability_disabled ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_dev_spec_ich8lan ) ) .
                during_suspend_flow as * const _ as usize } , 8205usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( e1000_dev_spec_ich8lan
                ) , "::" , stringify ! ( during_suspend_flow ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_dev_spec_ich8lan ) ) .
                during_dpg_exit as * const _ as usize } , 8206usize , concat !
                (
                "Alignment of field: " , stringify ! ( e1000_dev_spec_ich8lan
                ) , "::" , stringify ! ( during_dpg_exit ) ));
}
impl Clone for e1000_dev_spec_ich8lan {
    fn clone(&self) -> Self { *self }
}
impl Default for e1000_dev_spec_ich8lan {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for e1000_dev_spec_ich8lan {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "e1000_dev_spec_ich8lan {{ kmrn_lock_loss_workaround_enabled: {:?}, shadow_ram: [{}], nvm_k1_enabled: {:?}, disable_k1_off: {:?}, eee_disable: {:?}, eee_lp_ability: {:?}, ulp_state: {:?}, ulp_capability_disabled: {:?}, during_suspend_flow: {:?}, during_dpg_exit: {:?} }}"
               , self . kmrn_lock_loss_workaround_enabled , self . shadow_ram
               . iter (  ) . enumerate (  ) . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ) , self . nvm_k1_enabled , self . disable_k1_off ,
               self . eee_disable , self . eee_lp_ability , self . ulp_state ,
               self . ulp_capability_disabled , self . during_suspend_flow ,
               self . during_dpg_exit)
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct e1000_dev_spec_82575 {
    pub sgmii_active: bool_,
    pub global_device_reset: bool_,
    pub eee_disable: bool_,
    pub module_plugged: bool_,
    pub clear_semaphore_once: bool_,
    pub mtu: u32,
    pub eth_flags: sfp_e1000_flags,
    pub media_port: u8,
    pub media_changed: bool_,
}
#[test]
fn bindgen_test_layout_e1000_dev_spec_82575() {
    assert_eq!(::core::mem::size_of::<e1000_dev_spec_82575>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( e1000_dev_spec_82575 )
               ));
    assert_eq! (::core::mem::align_of::<e1000_dev_spec_82575>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( e1000_dev_spec_82575 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_dev_spec_82575 ) ) . sgmii_active
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_dev_spec_82575 )
                , "::" , stringify ! ( sgmii_active ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_dev_spec_82575 ) ) .
                global_device_reset as * const _ as usize } , 1usize , concat
                ! (
                "Alignment of field: " , stringify ! ( e1000_dev_spec_82575 )
                , "::" , stringify ! ( global_device_reset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_dev_spec_82575 ) ) . eee_disable as
                * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_dev_spec_82575 )
                , "::" , stringify ! ( eee_disable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_dev_spec_82575 ) ) . module_plugged
                as * const _ as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_dev_spec_82575 )
                , "::" , stringify ! ( module_plugged ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_dev_spec_82575 ) ) .
                clear_semaphore_once as * const _ as usize } , 4usize , concat
                ! (
                "Alignment of field: " , stringify ! ( e1000_dev_spec_82575 )
                , "::" , stringify ! ( clear_semaphore_once ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_dev_spec_82575 ) ) . mtu as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_dev_spec_82575 )
                , "::" , stringify ! ( mtu ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_dev_spec_82575 ) ) . eth_flags as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_dev_spec_82575 )
                , "::" , stringify ! ( eth_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_dev_spec_82575 ) ) . media_port as
                * const _ as usize } , 13usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_dev_spec_82575 )
                , "::" , stringify ! ( media_port ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_dev_spec_82575 ) ) . media_changed
                as * const _ as usize } , 14usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_dev_spec_82575 )
                , "::" , stringify ! ( media_changed ) ));
}
impl Clone for e1000_dev_spec_82575 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct e1000_dev_spec_vf {
    pub vf_number: u32,
    pub v2p_mailbox: u32,
}
#[test]
fn bindgen_test_layout_e1000_dev_spec_vf() {
    assert_eq!(::core::mem::size_of::<e1000_dev_spec_vf>() , 8usize , concat !
               ( "Size of: " , stringify ! ( e1000_dev_spec_vf ) ));
    assert_eq! (::core::mem::align_of::<e1000_dev_spec_vf>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( e1000_dev_spec_vf ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_dev_spec_vf ) ) . vf_number as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_dev_spec_vf ) ,
                "::" , stringify ! ( vf_number ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_dev_spec_vf ) ) . v2p_mailbox as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_dev_spec_vf ) ,
                "::" , stringify ! ( v2p_mailbox ) ));
}
impl Clone for e1000_dev_spec_vf {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn e1000_init_script_state_82541(hw: *mut e1000_hw, state: bool_);
}
extern "C" {
    pub fn e1000_tbi_adjust_stats_82543(hw: *mut e1000_hw,
                                        stats: *mut e1000_hw_stats,
                                        frame_len: u32, mac_addr: *mut u8,
                                        max_frame_size: u32);
}
extern "C" {
    pub fn e1000_set_tbi_compatibility_82543(hw: *mut e1000_hw, state: bool_);
}
extern "C" {
    pub fn e1000_tbi_sbp_enabled_82543(hw: *mut e1000_hw) -> bool_;
}
extern "C" {
    pub fn e1000_check_phy_82574(hw: *mut e1000_hw) -> bool_;
}
extern "C" {
    pub fn e1000_get_laa_state_82571(hw: *mut e1000_hw) -> bool_;
}
extern "C" {
    pub fn e1000_set_laa_state_82571(hw: *mut e1000_hw, state: bool_);
}
extern "C" {
    pub fn e1000_set_kmrn_lock_loss_workaround_ich8lan(hw: *mut e1000_hw,
                                                       state: bool_);
}
extern "C" {
    pub fn e1000_igp3_phy_powerdown_workaround_ich8lan(hw: *mut e1000_hw);
}
extern "C" {
    pub fn e1000_gig_downshift_workaround_ich8lan(hw: *mut e1000_hw);
}
extern "C" {
    pub fn e1000_suspend_workarounds_ich8lan(hw: *mut e1000_hw);
}
extern "C" {
    pub fn e1000_resume_workarounds_pchlan(hw: *mut e1000_hw) -> u32;
}
extern "C" {
    pub fn e1000_configure_k1_ich8lan(hw: *mut e1000_hw, k1_enable: bool_)
     -> s32;
}
extern "C" {
    pub fn e1000_copy_rx_addrs_to_phy_ich8lan(hw: *mut e1000_hw);
}
extern "C" {
    pub fn e1000_lv_jumbo_workaround_ich8lan(hw: *mut e1000_hw, enable: bool_)
     -> s32;
}
extern "C" {
    pub fn e1000_read_emi_reg_locked(hw: *mut e1000_hw, addr: u16,
                                     data: *mut u16) -> s32;
}
extern "C" {
    pub fn e1000_write_emi_reg_locked(hw: *mut e1000_hw, addr: u16, data: u16)
     -> s32;
}
extern "C" {
    pub fn e1000_set_eee_pchlan(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_enable_ulp_lpt_lp(hw: *mut e1000_hw, to_sx: bool_) -> s32;
}
extern "C" {
    pub fn e1000_disable_ulp_lpt_lp(hw: *mut e1000_hw, force: bool_) -> s32;
}
#[repr(C)]
#[derive(Copy)]
pub union e1000_adv_rx_desc {
    pub read: e1000_adv_rx_desc__bindgen_ty_1,
    pub wb: e1000_adv_rx_desc__bindgen_ty_2,
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct e1000_adv_rx_desc__bindgen_ty_1 {
    pub pkt_addr: u64,
    pub hdr_addr: u64,
}
#[test]
fn bindgen_test_layout_e1000_adv_rx_desc__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<e1000_adv_rx_desc__bindgen_ty_1>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( e1000_adv_rx_desc__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<e1000_adv_rx_desc__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                e1000_adv_rx_desc__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_adv_rx_desc__bindgen_ty_1 ) ) .
                pkt_addr as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_adv_rx_desc__bindgen_ty_1 ) , "::" , stringify ! (
                pkt_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_adv_rx_desc__bindgen_ty_1 ) ) .
                hdr_addr as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_adv_rx_desc__bindgen_ty_1 ) , "::" , stringify ! (
                hdr_addr ) ));
}
impl Clone for e1000_adv_rx_desc__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct e1000_adv_rx_desc__bindgen_ty_2 {
    pub lower: e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1,
    pub upper: e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy)]
pub struct e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1 {
    pub lo_dword: e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
    pub hi_dword: e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy)]
pub union e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    pub data: u32,
    pub hs_rss: e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub pkt_info: u16,
    pub hdr_info: u16,
}
#[test]
fn bindgen_test_layout_e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>()
               , 4usize , concat ! (
               "Size of: " , stringify ! (
               e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
               ) ));
    assert_eq! (::core::mem::align_of::<e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>()
                , 2usize , concat ! (
                "Alignment of " , stringify ! (
                e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
                ) ) . pkt_info as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
                ) , "::" , stringify ! ( pkt_info ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
                ) ) . hdr_info as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
                ) , "::" , stringify ! ( hdr_info ) ));
}
impl Clone for
 e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1>()
               , 4usize , concat ! (
               "Size of: " , stringify ! (
               e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 )
                ) . data as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 )
                , "::" , stringify ! ( data ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 )
                ) . hs_rss as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 )
                , "::" , stringify ! ( hs_rss ) ));
}
impl Clone for e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for
 e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy)]
pub union e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2 {
    pub rss: u32,
    pub csum_ip: e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub ip_id: u16,
    pub csum: u16,
}
#[test]
fn bindgen_test_layout_e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>()
               , 4usize , concat ! (
               "Size of: " , stringify ! (
               e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1
               ) ));
    assert_eq! (::core::mem::align_of::<e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>()
                , 2usize , concat ! (
                "Alignment of " , stringify ! (
                e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1
                ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1
                ) ) . ip_id as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1
                ) , "::" , stringify ! ( ip_id ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1
                ) ) . csum as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1
                ) , "::" , stringify ! ( csum ) ));
}
impl Clone for
 e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2>()
               , 4usize , concat ! (
               "Size of: " , stringify ! (
               e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2 )
               ));
    assert_eq! (::core::mem::align_of::<e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2 )
                ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2 )
                ) . rss as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2 )
                , "::" , stringify ! ( rss ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2 )
                ) . csum_ip as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2 )
                , "::" , stringify ! ( csum_ip ) ));
}
impl Clone for e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for
 e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1
                ) ) . lo_dword as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1 ) , "::" ,
                stringify ! ( lo_dword ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1
                ) ) . hi_dword as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1 ) , "::" ,
                stringify ! ( hi_dword ) ));
}
impl Clone for e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl Default for e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_1 {{ lo_dword: {:?}, hi_dword: {:?} }}"
               , self . lo_dword , self . hi_dword)
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_2 {
    pub status_error: u32,
    pub length: u16,
    pub vlan: u16,
}
#[test]
fn bindgen_test_layout_e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_2>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_2 ) ));
    assert_eq! (::core::mem::align_of::<e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_2>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_2
                ) ) . status_error as * const _ as usize } , 0usize , concat !
                (
                "Alignment of field: " , stringify ! (
                e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_2 ) , "::" ,
                stringify ! ( status_error ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_2
                ) ) . length as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_2 ) , "::" ,
                stringify ! ( length ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_2
                ) ) . vlan as * const _ as usize } , 6usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_2 ) , "::" ,
                stringify ! ( vlan ) ));
}
impl Clone for e1000_adv_rx_desc__bindgen_ty_2__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_e1000_adv_rx_desc__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<e1000_adv_rx_desc__bindgen_ty_2>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( e1000_adv_rx_desc__bindgen_ty_2 )
               ));
    assert_eq! (::core::mem::align_of::<e1000_adv_rx_desc__bindgen_ty_2>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                e1000_adv_rx_desc__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_adv_rx_desc__bindgen_ty_2 ) ) .
                lower as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_adv_rx_desc__bindgen_ty_2 ) , "::" , stringify ! ( lower
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_adv_rx_desc__bindgen_ty_2 ) ) .
                upper as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_adv_rx_desc__bindgen_ty_2 ) , "::" , stringify ! ( upper
                ) ));
}
impl Clone for e1000_adv_rx_desc__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl Default for e1000_adv_rx_desc__bindgen_ty_2 {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for e1000_adv_rx_desc__bindgen_ty_2 {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "e1000_adv_rx_desc__bindgen_ty_2 {{ lower: {:?}, upper: {:?} }}"
               , self . lower , self . upper)
    }
}
#[test]
fn bindgen_test_layout_e1000_adv_rx_desc() {
    assert_eq!(::core::mem::size_of::<e1000_adv_rx_desc>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( e1000_adv_rx_desc ) ));
    assert_eq! (::core::mem::align_of::<e1000_adv_rx_desc>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( e1000_adv_rx_desc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_adv_rx_desc ) ) . read as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_adv_rx_desc ) ,
                "::" , stringify ! ( read ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_adv_rx_desc ) ) . wb as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_adv_rx_desc ) ,
                "::" , stringify ! ( wb ) ));
}
impl Clone for e1000_adv_rx_desc {
    fn clone(&self) -> Self { *self }
}
impl Default for e1000_adv_rx_desc {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for e1000_adv_rx_desc {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "e1000_adv_rx_desc {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy)]
pub union e1000_adv_tx_desc {
    pub read: e1000_adv_tx_desc__bindgen_ty_1,
    pub wb: e1000_adv_tx_desc__bindgen_ty_2,
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct e1000_adv_tx_desc__bindgen_ty_1 {
    pub buffer_addr: u64,
    pub cmd_type_len: u32,
    pub olinfo_status: u32,
}
#[test]
fn bindgen_test_layout_e1000_adv_tx_desc__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<e1000_adv_tx_desc__bindgen_ty_1>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( e1000_adv_tx_desc__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<e1000_adv_tx_desc__bindgen_ty_1>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                e1000_adv_tx_desc__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_adv_tx_desc__bindgen_ty_1 ) ) .
                buffer_addr as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_adv_tx_desc__bindgen_ty_1 ) , "::" , stringify ! (
                buffer_addr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_adv_tx_desc__bindgen_ty_1 ) ) .
                cmd_type_len as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_adv_tx_desc__bindgen_ty_1 ) , "::" , stringify ! (
                cmd_type_len ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_adv_tx_desc__bindgen_ty_1 ) ) .
                olinfo_status as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_adv_tx_desc__bindgen_ty_1 ) , "::" , stringify ! (
                olinfo_status ) ));
}
impl Clone for e1000_adv_tx_desc__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct e1000_adv_tx_desc__bindgen_ty_2 {
    pub rsvd: u64,
    pub nxtseq_seed: u32,
    pub status: u32,
}
#[test]
fn bindgen_test_layout_e1000_adv_tx_desc__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<e1000_adv_tx_desc__bindgen_ty_2>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( e1000_adv_tx_desc__bindgen_ty_2 )
               ));
    assert_eq! (::core::mem::align_of::<e1000_adv_tx_desc__bindgen_ty_2>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                e1000_adv_tx_desc__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_adv_tx_desc__bindgen_ty_2 ) ) .
                rsvd as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_adv_tx_desc__bindgen_ty_2 ) , "::" , stringify ! ( rsvd
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_adv_tx_desc__bindgen_ty_2 ) ) .
                nxtseq_seed as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_adv_tx_desc__bindgen_ty_2 ) , "::" , stringify ! (
                nxtseq_seed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_adv_tx_desc__bindgen_ty_2 ) ) .
                status as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_adv_tx_desc__bindgen_ty_2 ) , "::" , stringify ! (
                status ) ));
}
impl Clone for e1000_adv_tx_desc__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_e1000_adv_tx_desc() {
    assert_eq!(::core::mem::size_of::<e1000_adv_tx_desc>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( e1000_adv_tx_desc ) ));
    assert_eq! (::core::mem::align_of::<e1000_adv_tx_desc>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( e1000_adv_tx_desc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_adv_tx_desc ) ) . read as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_adv_tx_desc ) ,
                "::" , stringify ! ( read ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_adv_tx_desc ) ) . wb as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( e1000_adv_tx_desc ) ,
                "::" , stringify ! ( wb ) ));
}
impl Clone for e1000_adv_tx_desc {
    fn clone(&self) -> Self { *self }
}
impl Default for e1000_adv_tx_desc {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for e1000_adv_tx_desc {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "e1000_adv_tx_desc {{ union }}")
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct e1000_adv_tx_context_desc {
    pub vlan_macip_lens: u32,
    pub seqnum_seed: u32,
    pub type_tucmd_mlhl: u32,
    pub mss_l4len_idx: u32,
}
#[test]
fn bindgen_test_layout_e1000_adv_tx_context_desc() {
    assert_eq!(::core::mem::size_of::<e1000_adv_tx_context_desc>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( e1000_adv_tx_context_desc ) ));
    assert_eq! (::core::mem::align_of::<e1000_adv_tx_context_desc>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( e1000_adv_tx_context_desc )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_adv_tx_context_desc ) ) .
                vlan_macip_lens as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_adv_tx_context_desc ) , "::" , stringify ! (
                vlan_macip_lens ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_adv_tx_context_desc ) ) .
                seqnum_seed as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_adv_tx_context_desc ) , "::" , stringify ! ( seqnum_seed
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_adv_tx_context_desc ) ) .
                type_tucmd_mlhl as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_adv_tx_context_desc ) , "::" , stringify ! (
                type_tucmd_mlhl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const e1000_adv_tx_context_desc ) ) .
                mss_l4len_idx as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                e1000_adv_tx_context_desc ) , "::" , stringify ! (
                mss_l4len_idx ) ));
}
impl Clone for e1000_adv_tx_context_desc {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn e1000_vmdq_set_loopback_pf(hw: *mut e1000_hw, enable: bool_);
}
extern "C" {
    pub fn e1000_vmdq_set_anti_spoofing_pf(hw: *mut e1000_hw, enable: bool_,
                                           pf: ::kernel::sys::raw::c_int);
}
extern "C" {
    pub fn e1000_vmdq_set_replication_pf(hw: *mut e1000_hw, enable: bool_);
}
extern "C" {
    pub fn e1000_init_nvm_params_82575(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_init_hw_82575(hw: *mut e1000_hw) -> s32;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum e1000_promisc_type {
    e1000_promisc_disabled = 0,
    e1000_promisc_unicast = 1,
    e1000_promisc_multicast = 2,
    e1000_promisc_enabled = 3,
    e1000_num_promisc_types = 4,
}
extern "C" {
    pub fn e1000_vfta_set_vf(arg1: *mut e1000_hw, arg2: u16, arg3: bool_);
}
extern "C" {
    pub fn e1000_rlpml_set_vf(arg1: *mut e1000_hw, arg2: u16);
}
extern "C" {
    pub fn e1000_promisc_set_vf(arg1: *mut e1000_hw,
                                type_: e1000_promisc_type) -> s32;
}
extern "C" {
    pub fn e1000_write_vfta_i350(hw: *mut e1000_hw, offset: u32, value: u32);
}
extern "C" {
    pub fn e1000_rxpbs_adjust_82580(data: u32) -> u16;
}
extern "C" {
    pub fn e1000_read_emi_reg(hw: *mut e1000_hw, addr: u16, data: *mut u16)
     -> s32;
}
extern "C" {
    pub fn e1000_set_eee_i350(hw: *mut e1000_hw, adv1G: bool_, adv100M: bool_)
     -> s32;
}
extern "C" {
    pub fn e1000_set_eee_i354(hw: *mut e1000_hw, adv1G: bool_, adv100M: bool_)
     -> s32;
}
extern "C" {
    pub fn e1000_get_eee_status_i354(arg1: *mut e1000_hw, arg2: *mut bool_)
     -> s32;
}
extern "C" {
    pub fn e1000_initialize_M88E1512_phy(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_initialize_M88E1543_phy(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_set_i2c_bb(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_read_i2c_byte_generic(hw: *mut e1000_hw, byte_offset: u8,
                                       dev_addr: u8, data: *mut u8) -> s32;
}
extern "C" {
    pub fn e1000_write_i2c_byte_generic(hw: *mut e1000_hw, byte_offset: u8,
                                        dev_addr: u8, data: u8) -> s32;
}
extern "C" {
    pub fn e1000_i2c_bus_clear(hw: *mut e1000_hw);
}
extern "C" {
    pub fn e1000_get_flash_presence_i210(hw: *mut e1000_hw) -> bool_;
}
extern "C" {
    pub fn e1000_update_flash_i210(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_update_nvm_checksum_i210(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_validate_nvm_checksum_i210(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_write_nvm_srwr_i210(hw: *mut e1000_hw, offset: u16,
                                     words: u16, data: *mut u16) -> s32;
}
extern "C" {
    pub fn e1000_read_nvm_srrd_i210(hw: *mut e1000_hw, offset: u16,
                                    words: u16, data: *mut u16) -> s32;
}
extern "C" {
    pub fn e1000_read_xmdio_reg(hw: *mut e1000_hw, addr: u16, dev_addr: u8,
                                data: *mut u16) -> s32;
}
extern "C" {
    pub fn e1000_write_xmdio_reg(hw: *mut e1000_hw, addr: u16, dev_addr: u8,
                                 data: u16) -> s32;
}
extern "C" {
    pub fn e1000_init_hw_i210(hw: *mut e1000_hw) -> s32;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum E1000_INVM_STRUCTURE_TYPE {
    E1000_INVM_UNINITIALIZED_STRUCTURE = 0,
    E1000_INVM_WORD_AUTOLOAD_STRUCTURE = 1,
    E1000_INVM_CSR_AUTOLOAD_STRUCTURE = 2,
    E1000_INVM_PHY_REGISTER_AUTOLOAD_STRUCTURE = 3,
    E1000_INVM_RSA_KEY_SHA256_STRUCTURE = 4,
    E1000_INVM_INVALIDATED_STRUCTURE = 15,
}
extern "C" {
    pub fn e1000_pci_clear_mwi(hw: *mut e1000_hw);
}
extern "C" {
    pub fn e1000_pci_set_mwi(hw: *mut e1000_hw);
}
extern "C" {
    pub fn e1000_read_pcie_cap_reg(hw: *mut e1000_hw, reg: u32,
                                   value: *mut u16) -> s32;
}
extern "C" {
    pub fn e1000_write_pcie_cap_reg(hw: *mut e1000_hw, reg: u32,
                                    value: *mut u16) -> s32;
}
extern "C" {
    pub fn e1000_read_pci_cfg(hw: *mut e1000_hw, reg: u32, value: *mut u16);
}
extern "C" {
    pub fn e1000_write_pci_cfg(hw: *mut e1000_hw, reg: u32, value: *mut u16);
}
extern "C" {
    pub fn e1000_init_function_pointers_82542(hw: *mut e1000_hw);
}
extern "C" {
    pub fn e1000_init_function_pointers_82543(hw: *mut e1000_hw);
}
extern "C" {
    pub fn e1000_init_function_pointers_82540(hw: *mut e1000_hw);
}
extern "C" {
    pub fn e1000_init_function_pointers_82571(hw: *mut e1000_hw);
}
extern "C" {
    pub fn e1000_init_function_pointers_82541(hw: *mut e1000_hw);
}
extern "C" {
    pub fn e1000_init_function_pointers_80003es2lan(hw: *mut e1000_hw);
}
extern "C" {
    pub fn e1000_init_function_pointers_ich8lan(hw: *mut e1000_hw);
}
extern "C" {
    pub fn e1000_init_function_pointers_82575(hw: *mut e1000_hw);
}
extern "C" {
    pub fn e1000_rx_fifo_flush_82575(hw: *mut e1000_hw);
}
extern "C" {
    pub fn e1000_init_function_pointers_vf(hw: *mut e1000_hw);
}
extern "C" {
    pub fn e1000_power_up_fiber_serdes_link(hw: *mut e1000_hw);
}
extern "C" {
    pub fn e1000_shutdown_fiber_serdes_link(hw: *mut e1000_hw);
}
extern "C" {
    pub fn e1000_init_function_pointers_i210(hw: *mut e1000_hw);
}
extern "C" {
    pub fn e1000_set_obff_timer(hw: *mut e1000_hw, itr: u32) -> s32;
}
extern "C" {
    pub fn e1000_set_mac_type(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_setup_init_funcs(hw: *mut e1000_hw, init_device: bool_)
     -> s32;
}
extern "C" {
    pub fn e1000_init_mac_params(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_init_nvm_params(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_init_phy_params(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_init_mbx_params(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_get_bus_info(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_clear_vfta(hw: *mut e1000_hw);
}
extern "C" {
    pub fn e1000_write_vfta(hw: *mut e1000_hw, offset: u32, value: u32);
}
extern "C" {
    pub fn e1000_force_mac_fc(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_check_for_link(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_reset_hw(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_init_hw(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_setup_link(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_get_speed_and_duplex(hw: *mut e1000_hw, speed: *mut u16,
                                      duplex: *mut u16) -> s32;
}
extern "C" {
    pub fn e1000_disable_pcie_master(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_config_collision_dist(hw: *mut e1000_hw);
}
extern "C" {
    pub fn e1000_rar_set(hw: *mut e1000_hw, addr: *mut u8, index: u32)
     -> ::kernel::sys::raw::c_int;
}
extern "C" {
    pub fn e1000_hash_mc_addr(hw: *mut e1000_hw, mc_addr: *mut u8) -> u32;
}
extern "C" {
    pub fn e1000_update_mc_addr_list(hw: *mut e1000_hw, mc_addr_list: *mut u8,
                                     mc_addr_count: u32);
}
extern "C" {
    pub fn e1000_setup_led(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_cleanup_led(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_check_reset_block(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_blink_led(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_led_on(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_led_off(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_id_led_init(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_reset_adaptive(hw: *mut e1000_hw);
}
extern "C" {
    pub fn e1000_update_adaptive(hw: *mut e1000_hw);
}
extern "C" {
    pub fn e1000_get_cable_length(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_validate_mdi_setting(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_read_phy_reg(hw: *mut e1000_hw, offset: u32, data: *mut u16)
     -> s32;
}
extern "C" {
    pub fn e1000_write_phy_reg(hw: *mut e1000_hw, offset: u32, data: u16)
     -> s32;
}
extern "C" {
    pub fn e1000_write_8bit_ctrl_reg(hw: *mut e1000_hw, reg: u32, offset: u32,
                                     data: u8) -> s32;
}
extern "C" {
    pub fn e1000_get_phy_info(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_release_phy(hw: *mut e1000_hw);
}
extern "C" {
    pub fn e1000_acquire_phy(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_cfg_on_link_up(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_phy_hw_reset(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_phy_commit(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_power_up_phy(hw: *mut e1000_hw);
}
extern "C" {
    pub fn e1000_power_down_phy(hw: *mut e1000_hw);
}
extern "C" {
    pub fn e1000_read_mac_addr(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_read_pba_string(hw: *mut e1000_hw, pba_num: *mut u8,
                                 pba_num_size: u32) -> s32;
}
extern "C" {
    pub fn e1000_read_pba_length(hw: *mut e1000_hw, pba_num_size: *mut u32)
     -> s32;
}
extern "C" {
    pub fn e1000_reload_nvm(hw: *mut e1000_hw);
}
extern "C" {
    pub fn e1000_update_nvm_checksum(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_validate_nvm_checksum(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_read_nvm(hw: *mut e1000_hw, offset: u16, words: u16,
                          data: *mut u16) -> s32;
}
extern "C" {
    pub fn e1000_read_kmrn_reg(hw: *mut e1000_hw, offset: u32, data: *mut u16)
     -> s32;
}
extern "C" {
    pub fn e1000_write_kmrn_reg(hw: *mut e1000_hw, offset: u32, data: u16)
     -> s32;
}
extern "C" {
    pub fn e1000_write_nvm(hw: *mut e1000_hw, offset: u16, words: u16,
                           data: *mut u16) -> s32;
}
extern "C" {
    pub fn e1000_set_d3_lplu_state(hw: *mut e1000_hw, active: bool_) -> s32;
}
extern "C" {
    pub fn e1000_set_d0_lplu_state(hw: *mut e1000_hw, active: bool_) -> s32;
}
extern "C" {
    pub fn e1000_check_mng_mode(hw: *mut e1000_hw) -> bool_;
}
extern "C" {
    pub fn e1000_enable_tx_pkt_filtering(hw: *mut e1000_hw) -> bool_;
}
extern "C" {
    pub fn e1000_mng_enable_host_if(hw: *mut e1000_hw) -> s32;
}
extern "C" {
    pub fn e1000_mng_host_if_write(hw: *mut e1000_hw, buffer: *mut u8,
                                   length: u16, offset: u16, sum: *mut u8)
     -> s32;
}
extern "C" {
    pub fn e1000_mng_write_cmd_header(hw: *mut e1000_hw,
                                      hdr: *mut e1000_host_mng_command_header)
     -> s32;
}
extern "C" {
    pub fn e1000_mng_write_dhcp_info(hw: *mut e1000_hw, buffer: *mut u8,
                                     length: u16) -> s32;
}
extern "C" {
    pub fn e1000_translate_register_82542(reg: u32) -> u32;
}
extern "C" {
    #[link_name = "ifdi_knlist_add_desc"]
    pub static mut ifdi_knlist_add_desc: kobjop_desc;
}
/// @brief A function implementing the IFDI_KNLIST_ADD() method
pub type ifdi_knlist_add_t =
    ::core::option::Option<unsafe extern "C" fn(_ctx: if_ctx_t,
                                                _kn: *mut knote)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "ifdi_knote_event_desc"]
    pub static mut ifdi_knote_event_desc: kobjop_desc;
}
/// @brief A function implementing the IFDI_KNOTE_EVENT() method
pub type ifdi_knote_event_t =
    ::core::option::Option<unsafe extern "C" fn(_ctx: if_ctx_t,
                                                _kn: *mut knote,
                                                hint:
                                                    ::kernel::sys::raw::c_int)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "ifdi_object_info_get_desc"]
    pub static mut ifdi_object_info_get_desc: kobjop_desc;
}
/// @brief A function implementing the IFDI_OBJECT_INFO_GET() method
pub type ifdi_object_info_get_t =
    ::core::option::Option<unsafe extern "C" fn(_ctx: if_ctx_t,
                                                data:
                                                    *mut ::kernel::sys::raw::c_void,
                                                size:
                                                    ::kernel::sys::raw::c_int)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "ifdi_attach_pre_desc"]
    pub static mut ifdi_attach_pre_desc: kobjop_desc;
}
/// @brief A function implementing the IFDI_ATTACH_PRE() method
pub type ifdi_attach_pre_t =
    ::core::option::Option<unsafe extern "C" fn(_ctx: if_ctx_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "ifdi_attach_post_desc"]
    pub static mut ifdi_attach_post_desc: kobjop_desc;
}
/// @brief A function implementing the IFDI_ATTACH_POST() method
pub type ifdi_attach_post_t =
    ::core::option::Option<unsafe extern "C" fn(_ctx: if_ctx_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "ifdi_reinit_pre_desc"]
    pub static mut ifdi_reinit_pre_desc: kobjop_desc;
}
/// @brief A function implementing the IFDI_REINIT_PRE() method
pub type ifdi_reinit_pre_t =
    ::core::option::Option<unsafe extern "C" fn(_ctx: if_ctx_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "ifdi_reinit_post_desc"]
    pub static mut ifdi_reinit_post_desc: kobjop_desc;
}
/// @brief A function implementing the IFDI_REINIT_POST() method
pub type ifdi_reinit_post_t =
    ::core::option::Option<unsafe extern "C" fn(_ctx: if_ctx_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "ifdi_cloneattach_desc"]
    pub static mut ifdi_cloneattach_desc: kobjop_desc;
}
/// @brief A function implementing the IFDI_CLONEATTACH() method
pub type ifdi_cloneattach_t =
    ::core::option::Option<unsafe extern "C" fn(_ctx: if_ctx_t,
                                                _ifc: *mut if_clone,
                                                _name:
                                                    *const ::kernel::sys::raw::c_char,
                                                params: caddr_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "ifdi_detach_desc"]
    pub static mut ifdi_detach_desc: kobjop_desc;
}
/// @brief A function implementing the IFDI_DETACH() method
pub type ifdi_detach_t =
    ::core::option::Option<unsafe extern "C" fn(_ctx: if_ctx_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "ifdi_suspend_desc"]
    pub static mut ifdi_suspend_desc: kobjop_desc;
}
/// @brief A function implementing the IFDI_SUSPEND() method
pub type ifdi_suspend_t =
    ::core::option::Option<unsafe extern "C" fn(_ctx: if_ctx_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "ifdi_shutdown_desc"]
    pub static mut ifdi_shutdown_desc: kobjop_desc;
}
/// @brief A function implementing the IFDI_SHUTDOWN() method
pub type ifdi_shutdown_t =
    ::core::option::Option<unsafe extern "C" fn(_ctx: if_ctx_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "ifdi_resume_desc"]
    pub static mut ifdi_resume_desc: kobjop_desc;
}
/// @brief A function implementing the IFDI_RESUME() method
pub type ifdi_resume_t =
    ::core::option::Option<unsafe extern "C" fn(_ctx: if_ctx_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "ifdi_tx_queues_alloc_desc"]
    pub static mut ifdi_tx_queues_alloc_desc: kobjop_desc;
}
/// @brief A function implementing the IFDI_TX_QUEUES_ALLOC() method
pub type ifdi_tx_queues_alloc_t =
    ::core::option::Option<unsafe extern "C" fn(_ctx: if_ctx_t,
                                                _vaddrs: *mut caddr_t,
                                                _paddrs: *mut u64,
                                                ntxqs:
                                                    ::kernel::sys::raw::c_int,
                                                ntxqsets:
                                                    ::kernel::sys::raw::c_int)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "ifdi_rx_queues_alloc_desc"]
    pub static mut ifdi_rx_queues_alloc_desc: kobjop_desc;
}
/// @brief A function implementing the IFDI_RX_QUEUES_ALLOC() method
pub type ifdi_rx_queues_alloc_t =
    ::core::option::Option<unsafe extern "C" fn(_ctx: if_ctx_t,
                                                _vaddrs: *mut caddr_t,
                                                _paddrs: *mut u64,
                                                nrxqs:
                                                    ::kernel::sys::raw::c_int,
                                                nrxqsets:
                                                    ::kernel::sys::raw::c_int)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "ifdi_queues_free_desc"]
    pub static mut ifdi_queues_free_desc: kobjop_desc;
}
/// @brief A function implementing the IFDI_QUEUES_FREE() method
pub type ifdi_queues_free_t =
    ::core::option::Option<unsafe extern "C" fn(_ctx: if_ctx_t)>;
extern "C" {
    #[link_name = "ifdi_rx_clset_desc"]
    pub static mut ifdi_rx_clset_desc: kobjop_desc;
}
/// @brief A function implementing the IFDI_RX_CLSET() method
pub type ifdi_rx_clset_t =
    ::core::option::Option<unsafe extern "C" fn(_ctx: if_ctx_t, _fl: u16,
                                                _qsetid: u16,
                                                _sdcl: *mut caddr_t)>;
extern "C" {
    #[link_name = "ifdi_init_desc"]
    pub static mut ifdi_init_desc: kobjop_desc;
}
/// @brief A function implementing the IFDI_INIT() method
pub type ifdi_init_t =
    ::core::option::Option<unsafe extern "C" fn(_ctx: if_ctx_t)>;
extern "C" {
    #[link_name = "ifdi_stop_desc"]
    pub static mut ifdi_stop_desc: kobjop_desc;
}
/// @brief A function implementing the IFDI_STOP() method
pub type ifdi_stop_t =
    ::core::option::Option<unsafe extern "C" fn(_ctx: if_ctx_t)>;
extern "C" {
    #[link_name = "ifdi_msix_intr_assign_desc"]
    pub static mut ifdi_msix_intr_assign_desc: kobjop_desc;
}
/// @brief A function implementing the IFDI_MSIX_INTR_ASSIGN() method
pub type ifdi_msix_intr_assign_t =
    ::core::option::Option<unsafe extern "C" fn(_sctx: if_ctx_t,
                                                msix:
                                                    ::kernel::sys::raw::c_int)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "ifdi_intr_enable_desc"]
    pub static mut ifdi_intr_enable_desc: kobjop_desc;
}
/// @brief A function implementing the IFDI_INTR_ENABLE() method
pub type ifdi_intr_enable_t =
    ::core::option::Option<unsafe extern "C" fn(_ctx: if_ctx_t)>;
extern "C" {
    #[link_name = "ifdi_intr_disable_desc"]
    pub static mut ifdi_intr_disable_desc: kobjop_desc;
}
/// @brief A function implementing the IFDI_INTR_DISABLE() method
pub type ifdi_intr_disable_t =
    ::core::option::Option<unsafe extern "C" fn(_ctx: if_ctx_t)>;
extern "C" {
    #[link_name = "ifdi_rx_queue_intr_enable_desc"]
    pub static mut ifdi_rx_queue_intr_enable_desc: kobjop_desc;
}
/// @brief A function implementing the IFDI_RX_QUEUE_INTR_ENABLE() method
pub type ifdi_rx_queue_intr_enable_t =
    ::core::option::Option<unsafe extern "C" fn(_ctx: if_ctx_t, _qid: u16)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "ifdi_tx_queue_intr_enable_desc"]
    pub static mut ifdi_tx_queue_intr_enable_desc: kobjop_desc;
}
/// @brief A function implementing the IFDI_TX_QUEUE_INTR_ENABLE() method
pub type ifdi_tx_queue_intr_enable_t =
    ::core::option::Option<unsafe extern "C" fn(_ctx: if_ctx_t, _qid: u16)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "ifdi_link_intr_enable_desc"]
    pub static mut ifdi_link_intr_enable_desc: kobjop_desc;
}
/// @brief A function implementing the IFDI_LINK_INTR_ENABLE() method
pub type ifdi_link_intr_enable_t =
    ::core::option::Option<unsafe extern "C" fn(_ctx: if_ctx_t)>;
extern "C" {
    #[link_name = "ifdi_multi_set_desc"]
    pub static mut ifdi_multi_set_desc: kobjop_desc;
}
/// @brief A function implementing the IFDI_MULTI_SET() method
pub type ifdi_multi_set_t =
    ::core::option::Option<unsafe extern "C" fn(_ctx: if_ctx_t)>;
extern "C" {
    #[link_name = "ifdi_mtu_set_desc"]
    pub static mut ifdi_mtu_set_desc: kobjop_desc;
}
/// @brief A function implementing the IFDI_MTU_SET() method
pub type ifdi_mtu_set_t =
    ::core::option::Option<unsafe extern "C" fn(_ctx: if_ctx_t, _mtu: u32)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "ifdi_mac_set_desc"]
    pub static mut ifdi_mac_set_desc: kobjop_desc;
}
/// @brief A function implementing the IFDI_MAC_SET() method
pub type ifdi_mac_set_t =
    ::core::option::Option<unsafe extern "C" fn(_ctx: if_ctx_t,
                                                _mac: *const u8)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "ifdi_media_set_desc"]
    pub static mut ifdi_media_set_desc: kobjop_desc;
}
/// @brief A function implementing the IFDI_MEDIA_SET() method
pub type ifdi_media_set_t =
    ::core::option::Option<unsafe extern "C" fn(_ctx: if_ctx_t)>;
extern "C" {
    #[link_name = "ifdi_promisc_set_desc"]
    pub static mut ifdi_promisc_set_desc: kobjop_desc;
}
/// @brief A function implementing the IFDI_PROMISC_SET() method
pub type ifdi_promisc_set_t =
    ::core::option::Option<unsafe extern "C" fn(_ctx: if_ctx_t,
                                                _flags:
                                                    ::kernel::sys::raw::c_int)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "ifdi_crcstrip_set_desc"]
    pub static mut ifdi_crcstrip_set_desc: kobjop_desc;
}
/// @brief A function implementing the IFDI_CRCSTRIP_SET() method
pub type ifdi_crcstrip_set_t =
    ::core::option::Option<unsafe extern "C" fn(_ctx: if_ctx_t,
                                                _onoff:
                                                    ::kernel::sys::raw::c_int,
                                                _strip:
                                                    ::kernel::sys::raw::c_int)>;
extern "C" {
    #[link_name = "ifdi_vflr_handle_desc"]
    pub static mut ifdi_vflr_handle_desc: kobjop_desc;
}
/// @brief A function implementing the IFDI_VFLR_HANDLE() method
pub type ifdi_vflr_handle_t =
    ::core::option::Option<unsafe extern "C" fn(_ctx: if_ctx_t)>;
extern "C" {
    #[link_name = "ifdi_iov_init_desc"]
    pub static mut ifdi_iov_init_desc: kobjop_desc;
}
/// @brief A function implementing the IFDI_IOV_INIT() method
pub type ifdi_iov_init_t =
    ::core::option::Option<unsafe extern "C" fn(_ctx: if_ctx_t, num_vfs: u16,
                                                params: *const nvlist_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "ifdi_iov_uninit_desc"]
    pub static mut ifdi_iov_uninit_desc: kobjop_desc;
}
/// @brief A function implementing the IFDI_IOV_UNINIT() method
pub type ifdi_iov_uninit_t =
    ::core::option::Option<unsafe extern "C" fn(_ctx: if_ctx_t)>;
extern "C" {
    #[link_name = "ifdi_iov_vf_add_desc"]
    pub static mut ifdi_iov_vf_add_desc: kobjop_desc;
}
/// @brief A function implementing the IFDI_IOV_VF_ADD() method
pub type ifdi_iov_vf_add_t =
    ::core::option::Option<unsafe extern "C" fn(_ctx: if_ctx_t, num_vfs: u16,
                                                params: *const nvlist_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "ifdi_update_admin_status_desc"]
    pub static mut ifdi_update_admin_status_desc: kobjop_desc;
}
/// @brief A function implementing the IFDI_UPDATE_ADMIN_STATUS() method
pub type ifdi_update_admin_status_t =
    ::core::option::Option<unsafe extern "C" fn(_ctx: if_ctx_t)>;
extern "C" {
    #[link_name = "ifdi_media_status_desc"]
    pub static mut ifdi_media_status_desc: kobjop_desc;
}
/// @brief A function implementing the IFDI_MEDIA_STATUS() method
pub type ifdi_media_status_t =
    ::core::option::Option<unsafe extern "C" fn(_ctx: if_ctx_t,
                                                _ifm: *mut ifmediareq)>;
extern "C" {
    #[link_name = "ifdi_media_change_desc"]
    pub static mut ifdi_media_change_desc: kobjop_desc;
}
/// @brief A function implementing the IFDI_MEDIA_CHANGE() method
pub type ifdi_media_change_t =
    ::core::option::Option<unsafe extern "C" fn(_ctx: if_ctx_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "ifdi_get_counter_desc"]
    pub static mut ifdi_get_counter_desc: kobjop_desc;
}
/// @brief A function implementing the IFDI_GET_COUNTER() method
pub type ifdi_get_counter_t =
    ::core::option::Option<unsafe extern "C" fn(_ctx: if_ctx_t,
                                                cnt: ift_counter) -> u64>;
extern "C" {
    #[link_name = "ifdi_priv_ioctl_desc"]
    pub static mut ifdi_priv_ioctl_desc: kobjop_desc;
}
/// @brief A function implementing the IFDI_PRIV_IOCTL() method
pub type ifdi_priv_ioctl_t =
    ::core::option::Option<unsafe extern "C" fn(_ctx: if_ctx_t, _cmd: u_long,
                                                _data: caddr_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "ifdi_i2c_req_desc"]
    pub static mut ifdi_i2c_req_desc: kobjop_desc;
}
/// @brief A function implementing the IFDI_I2C_REQ() method
pub type ifdi_i2c_req_t =
    ::core::option::Option<unsafe extern "C" fn(_ctx: if_ctx_t,
                                                _req: *mut ifi2creq)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "ifdi_txq_setup_desc"]
    pub static mut ifdi_txq_setup_desc: kobjop_desc;
}
/// @brief A function implementing the IFDI_TXQ_SETUP() method
pub type ifdi_txq_setup_t =
    ::core::option::Option<unsafe extern "C" fn(_ctx: if_ctx_t, _txqid: u32)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "ifdi_rxq_setup_desc"]
    pub static mut ifdi_rxq_setup_desc: kobjop_desc;
}
/// @brief A function implementing the IFDI_RXQ_SETUP() method
pub type ifdi_rxq_setup_t =
    ::core::option::Option<unsafe extern "C" fn(_ctx: if_ctx_t, _txqid: u32)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "ifdi_timer_desc"]
    pub static mut ifdi_timer_desc: kobjop_desc;
}
/// @brief A function implementing the IFDI_TIMER() method
pub type ifdi_timer_t =
    ::core::option::Option<unsafe extern "C" fn(_ctx: if_ctx_t, _txqid: u16)>;
extern "C" {
    #[link_name = "ifdi_watchdog_reset_desc"]
    pub static mut ifdi_watchdog_reset_desc: kobjop_desc;
}
/// @brief A function implementing the IFDI_WATCHDOG_RESET() method
pub type ifdi_watchdog_reset_t =
    ::core::option::Option<unsafe extern "C" fn(_ctx: if_ctx_t)>;
extern "C" {
    #[link_name = "ifdi_watchdog_reset_queue_desc"]
    pub static mut ifdi_watchdog_reset_queue_desc: kobjop_desc;
}
/// @brief A function implementing the IFDI_WATCHDOG_RESET_QUEUE() method
pub type ifdi_watchdog_reset_queue_t =
    ::core::option::Option<unsafe extern "C" fn(_ctx: if_ctx_t, _q: u16)>;
extern "C" {
    #[link_name = "ifdi_led_func_desc"]
    pub static mut ifdi_led_func_desc: kobjop_desc;
}
/// @brief A function implementing the IFDI_LED_FUNC() method
pub type ifdi_led_func_t =
    ::core::option::Option<unsafe extern "C" fn(_ctx: if_ctx_t,
                                                _onoff:
                                                    ::kernel::sys::raw::c_int)>;
extern "C" {
    #[link_name = "ifdi_vlan_register_desc"]
    pub static mut ifdi_vlan_register_desc: kobjop_desc;
}
/// @brief A function implementing the IFDI_VLAN_REGISTER() method
pub type ifdi_vlan_register_t =
    ::core::option::Option<unsafe extern "C" fn(_ctx: if_ctx_t, _vtag: u16)>;
extern "C" {
    #[link_name = "ifdi_vlan_unregister_desc"]
    pub static mut ifdi_vlan_unregister_desc: kobjop_desc;
}
/// @brief A function implementing the IFDI_VLAN_UNREGISTER() method
pub type ifdi_vlan_unregister_t =
    ::core::option::Option<unsafe extern "C" fn(_ctx: if_ctx_t, _vtag: u16)>;
extern "C" {
    #[link_name = "ifdi_sysctl_int_delay_desc"]
    pub static mut ifdi_sysctl_int_delay_desc: kobjop_desc;
}
/// @brief A function implementing the IFDI_SYSCTL_INT_DELAY() method
pub type ifdi_sysctl_int_delay_t =
    ::core::option::Option<unsafe extern "C" fn(_sctx: if_ctx_t,
                                                _iidi: if_int_delay_info_t)
                               -> ::kernel::sys::raw::c_int>;
extern "C" {
    #[link_name = "ifdi_debug_desc"]
    pub static mut ifdi_debug_desc: kobjop_desc;
}
/// @brief A function implementing the IFDI_DEBUG() method
pub type ifdi_debug_t =
    ::core::option::Option<unsafe extern "C" fn(_ctx: if_ctx_t)>;
#[repr(C)]
#[derive(Copy)]
pub struct adapter {
    pub ifp: *mut ifnet,
    pub hw: e1000_hw,
    pub shared: if_softc_ctx_t,
    pub ctx: if_ctx_t,
    pub osdep: e1000_osdep,
    pub dev: device_t,
    pub led_dev: *mut cdev,
    pub tx_queues: *mut em_tx_queue,
    pub rx_queues: *mut em_rx_queue,
    pub irq: if_irq,
    pub memory: *mut resource,
    pub flash: *mut resource,
    pub ioport: *mut resource,
    pub io_rid: ::kernel::sys::raw::c_int,
    pub res: *mut resource,
    pub tag: *mut ::kernel::sys::raw::c_void,
    pub linkvec: u32,
    pub ivars: u32,
    pub media: *mut ifmedia,
    pub msix: ::kernel::sys::raw::c_int,
    pub if_flags: ::kernel::sys::raw::c_int,
    pub em_insert_vlan_header: ::kernel::sys::raw::c_int,
    pub ims: u32,
    pub in_detach: bool_,
    pub flags: u32,
    pub link_task: grouptask,
    pub num_vlans: u16,
    pub txd_cmd: u32,
    pub tx_process_limit: u32,
    pub rx_process_limit: u32,
    pub rx_mbuf_sz: u32,
    pub wol: u32,
    pub has_manage: bool_,
    pub has_amt: bool_,
    pub mta: *mut u8,
    pub shadow_vfta: [u32; 128usize],
    pub link_active: u16,
    pub fc: u16,
    pub link_speed: u16,
    pub link_duplex: u16,
    pub smartspeed: u32,
    pub dmac: u32,
    pub link_mask: ::kernel::sys::raw::c_int,
    pub que_mask: u64,
    pub tx_int_delay: em_int_delay_info,
    pub tx_abs_int_delay: em_int_delay_info,
    pub rx_int_delay: em_int_delay_info,
    pub rx_abs_int_delay: em_int_delay_info,
    pub tx_itr: em_int_delay_info,
    pub dropped_pkts: ::kernel::sys::raw::c_ulong,
    pub link_irq: ::kernel::sys::raw::c_ulong,
    pub mbuf_defrag_failed: ::kernel::sys::raw::c_ulong,
    pub no_tx_dma_setup: ::kernel::sys::raw::c_ulong,
    pub no_tx_map_avail: ::kernel::sys::raw::c_ulong,
    pub rx_overruns: ::kernel::sys::raw::c_ulong,
    pub watchdog_events: ::kernel::sys::raw::c_ulong,
    pub stats: e1000_hw_stats,
    pub vf_ifp: u16,
}
#[test]
fn bindgen_test_layout_adapter() {
    assert_eq!(::core::mem::size_of::<adapter>() , 11312usize , concat ! (
               "Size of: " , stringify ! ( adapter ) ));
    assert_eq! (::core::mem::align_of::<adapter>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( adapter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const adapter ) ) . ifp as * const _ as usize }
                , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( adapter ) , "::" ,
                stringify ! ( ifp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const adapter ) ) . hw as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( adapter ) , "::" ,
                stringify ! ( hw ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const adapter ) ) . shared as * const _ as
                usize } , 9616usize , concat ! (
                "Alignment of field: " , stringify ! ( adapter ) , "::" ,
                stringify ! ( shared ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const adapter ) ) . ctx as * const _ as usize }
                , 9624usize , concat ! (
                "Alignment of field: " , stringify ! ( adapter ) , "::" ,
                stringify ! ( ctx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const adapter ) ) . osdep as * const _ as usize
                } , 9632usize , concat ! (
                "Alignment of field: " , stringify ! ( adapter ) , "::" ,
                stringify ! ( osdep ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const adapter ) ) . dev as * const _ as usize }
                , 9696usize , concat ! (
                "Alignment of field: " , stringify ! ( adapter ) , "::" ,
                stringify ! ( dev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const adapter ) ) . led_dev as * const _ as
                usize } , 9704usize , concat ! (
                "Alignment of field: " , stringify ! ( adapter ) , "::" ,
                stringify ! ( led_dev ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const adapter ) ) . tx_queues as * const _ as
                usize } , 9712usize , concat ! (
                "Alignment of field: " , stringify ! ( adapter ) , "::" ,
                stringify ! ( tx_queues ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const adapter ) ) . rx_queues as * const _ as
                usize } , 9720usize , concat ! (
                "Alignment of field: " , stringify ! ( adapter ) , "::" ,
                stringify ! ( rx_queues ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const adapter ) ) . irq as * const _ as usize }
                , 9728usize , concat ! (
                "Alignment of field: " , stringify ! ( adapter ) , "::" ,
                stringify ! ( irq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const adapter ) ) . memory as * const _ as
                usize } , 9752usize , concat ! (
                "Alignment of field: " , stringify ! ( adapter ) , "::" ,
                stringify ! ( memory ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const adapter ) ) . flash as * const _ as usize
                } , 9760usize , concat ! (
                "Alignment of field: " , stringify ! ( adapter ) , "::" ,
                stringify ! ( flash ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const adapter ) ) . ioport as * const _ as
                usize } , 9768usize , concat ! (
                "Alignment of field: " , stringify ! ( adapter ) , "::" ,
                stringify ! ( ioport ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const adapter ) ) . io_rid as * const _ as
                usize } , 9776usize , concat ! (
                "Alignment of field: " , stringify ! ( adapter ) , "::" ,
                stringify ! ( io_rid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const adapter ) ) . res as * const _ as usize }
                , 9784usize , concat ! (
                "Alignment of field: " , stringify ! ( adapter ) , "::" ,
                stringify ! ( res ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const adapter ) ) . tag as * const _ as usize }
                , 9792usize , concat ! (
                "Alignment of field: " , stringify ! ( adapter ) , "::" ,
                stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const adapter ) ) . linkvec as * const _ as
                usize } , 9800usize , concat ! (
                "Alignment of field: " , stringify ! ( adapter ) , "::" ,
                stringify ! ( linkvec ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const adapter ) ) . ivars as * const _ as usize
                } , 9804usize , concat ! (
                "Alignment of field: " , stringify ! ( adapter ) , "::" ,
                stringify ! ( ivars ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const adapter ) ) . media as * const _ as usize
                } , 9808usize , concat ! (
                "Alignment of field: " , stringify ! ( adapter ) , "::" ,
                stringify ! ( media ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const adapter ) ) . msix as * const _ as usize
                } , 9816usize , concat ! (
                "Alignment of field: " , stringify ! ( adapter ) , "::" ,
                stringify ! ( msix ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const adapter ) ) . if_flags as * const _ as
                usize } , 9820usize , concat ! (
                "Alignment of field: " , stringify ! ( adapter ) , "::" ,
                stringify ! ( if_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const adapter ) ) . em_insert_vlan_header as *
                const _ as usize } , 9824usize , concat ! (
                "Alignment of field: " , stringify ! ( adapter ) , "::" ,
                stringify ! ( em_insert_vlan_header ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const adapter ) ) . ims as * const _ as usize }
                , 9828usize , concat ! (
                "Alignment of field: " , stringify ! ( adapter ) , "::" ,
                stringify ! ( ims ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const adapter ) ) . in_detach as * const _ as
                usize } , 9832usize , concat ! (
                "Alignment of field: " , stringify ! ( adapter ) , "::" ,
                stringify ! ( in_detach ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const adapter ) ) . flags as * const _ as usize
                } , 9836usize , concat ! (
                "Alignment of field: " , stringify ! ( adapter ) , "::" ,
                stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const adapter ) ) . link_task as * const _ as
                usize } , 9840usize , concat ! (
                "Alignment of field: " , stringify ! ( adapter ) , "::" ,
                stringify ! ( link_task ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const adapter ) ) . num_vlans as * const _ as
                usize } , 9944usize , concat ! (
                "Alignment of field: " , stringify ! ( adapter ) , "::" ,
                stringify ! ( num_vlans ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const adapter ) ) . txd_cmd as * const _ as
                usize } , 9948usize , concat ! (
                "Alignment of field: " , stringify ! ( adapter ) , "::" ,
                stringify ! ( txd_cmd ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const adapter ) ) . tx_process_limit as * const
                _ as usize } , 9952usize , concat ! (
                "Alignment of field: " , stringify ! ( adapter ) , "::" ,
                stringify ! ( tx_process_limit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const adapter ) ) . rx_process_limit as * const
                _ as usize } , 9956usize , concat ! (
                "Alignment of field: " , stringify ! ( adapter ) , "::" ,
                stringify ! ( rx_process_limit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const adapter ) ) . rx_mbuf_sz as * const _ as
                usize } , 9960usize , concat ! (
                "Alignment of field: " , stringify ! ( adapter ) , "::" ,
                stringify ! ( rx_mbuf_sz ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const adapter ) ) . wol as * const _ as usize }
                , 9964usize , concat ! (
                "Alignment of field: " , stringify ! ( adapter ) , "::" ,
                stringify ! ( wol ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const adapter ) ) . has_manage as * const _ as
                usize } , 9968usize , concat ! (
                "Alignment of field: " , stringify ! ( adapter ) , "::" ,
                stringify ! ( has_manage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const adapter ) ) . has_amt as * const _ as
                usize } , 9969usize , concat ! (
                "Alignment of field: " , stringify ! ( adapter ) , "::" ,
                stringify ! ( has_amt ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const adapter ) ) . mta as * const _ as usize }
                , 9976usize , concat ! (
                "Alignment of field: " , stringify ! ( adapter ) , "::" ,
                stringify ! ( mta ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const adapter ) ) . shadow_vfta as * const _ as
                usize } , 9984usize , concat ! (
                "Alignment of field: " , stringify ! ( adapter ) , "::" ,
                stringify ! ( shadow_vfta ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const adapter ) ) . link_active as * const _ as
                usize } , 10496usize , concat ! (
                "Alignment of field: " , stringify ! ( adapter ) , "::" ,
                stringify ! ( link_active ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const adapter ) ) . fc as * const _ as usize }
                , 10498usize , concat ! (
                "Alignment of field: " , stringify ! ( adapter ) , "::" ,
                stringify ! ( fc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const adapter ) ) . link_speed as * const _ as
                usize } , 10500usize , concat ! (
                "Alignment of field: " , stringify ! ( adapter ) , "::" ,
                stringify ! ( link_speed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const adapter ) ) . link_duplex as * const _ as
                usize } , 10502usize , concat ! (
                "Alignment of field: " , stringify ! ( adapter ) , "::" ,
                stringify ! ( link_duplex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const adapter ) ) . smartspeed as * const _ as
                usize } , 10504usize , concat ! (
                "Alignment of field: " , stringify ! ( adapter ) , "::" ,
                stringify ! ( smartspeed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const adapter ) ) . dmac as * const _ as usize
                } , 10508usize , concat ! (
                "Alignment of field: " , stringify ! ( adapter ) , "::" ,
                stringify ! ( dmac ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const adapter ) ) . link_mask as * const _ as
                usize } , 10512usize , concat ! (
                "Alignment of field: " , stringify ! ( adapter ) , "::" ,
                stringify ! ( link_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const adapter ) ) . que_mask as * const _ as
                usize } , 10520usize , concat ! (
                "Alignment of field: " , stringify ! ( adapter ) , "::" ,
                stringify ! ( que_mask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const adapter ) ) . tx_int_delay as * const _
                as usize } , 10528usize , concat ! (
                "Alignment of field: " , stringify ! ( adapter ) , "::" ,
                stringify ! ( tx_int_delay ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const adapter ) ) . tx_abs_int_delay as * const
                _ as usize } , 10544usize , concat ! (
                "Alignment of field: " , stringify ! ( adapter ) , "::" ,
                stringify ! ( tx_abs_int_delay ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const adapter ) ) . rx_int_delay as * const _
                as usize } , 10560usize , concat ! (
                "Alignment of field: " , stringify ! ( adapter ) , "::" ,
                stringify ! ( rx_int_delay ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const adapter ) ) . rx_abs_int_delay as * const
                _ as usize } , 10576usize , concat ! (
                "Alignment of field: " , stringify ! ( adapter ) , "::" ,
                stringify ! ( rx_abs_int_delay ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const adapter ) ) . tx_itr as * const _ as
                usize } , 10592usize , concat ! (
                "Alignment of field: " , stringify ! ( adapter ) , "::" ,
                stringify ! ( tx_itr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const adapter ) ) . dropped_pkts as * const _
                as usize } , 10608usize , concat ! (
                "Alignment of field: " , stringify ! ( adapter ) , "::" ,
                stringify ! ( dropped_pkts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const adapter ) ) . link_irq as * const _ as
                usize } , 10616usize , concat ! (
                "Alignment of field: " , stringify ! ( adapter ) , "::" ,
                stringify ! ( link_irq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const adapter ) ) . mbuf_defrag_failed as *
                const _ as usize } , 10624usize , concat ! (
                "Alignment of field: " , stringify ! ( adapter ) , "::" ,
                stringify ! ( mbuf_defrag_failed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const adapter ) ) . no_tx_dma_setup as * const
                _ as usize } , 10632usize , concat ! (
                "Alignment of field: " , stringify ! ( adapter ) , "::" ,
                stringify ! ( no_tx_dma_setup ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const adapter ) ) . no_tx_map_avail as * const
                _ as usize } , 10640usize , concat ! (
                "Alignment of field: " , stringify ! ( adapter ) , "::" ,
                stringify ! ( no_tx_map_avail ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const adapter ) ) . rx_overruns as * const _ as
                usize } , 10648usize , concat ! (
                "Alignment of field: " , stringify ! ( adapter ) , "::" ,
                stringify ! ( rx_overruns ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const adapter ) ) . watchdog_events as * const
                _ as usize } , 10656usize , concat ! (
                "Alignment of field: " , stringify ! ( adapter ) , "::" ,
                stringify ! ( watchdog_events ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const adapter ) ) . stats as * const _ as usize
                } , 10664usize , concat ! (
                "Alignment of field: " , stringify ! ( adapter ) , "::" ,
                stringify ! ( stats ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const adapter ) ) . vf_ifp as * const _ as
                usize } , 11304usize , concat ! (
                "Alignment of field: " , stringify ! ( adapter ) , "::" ,
                stringify ! ( vf_ifp ) ));
}
impl Clone for adapter {
    fn clone(&self) -> Self { *self }
}
impl Default for adapter {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for adapter {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f ,
               "adapter {{ ifp: {:?}, hw: {:?}, shared: {:?}, ctx: {:?}, osdep: {:?}, dev: {:?}, led_dev: {:?}, tx_queues: {:?}, rx_queues: {:?}, irq: {:?}, memory: {:?}, flash: {:?}, ioport: {:?}, io_rid: {:?}, res: {:?}, tag: {:?}, linkvec: {:?}, ivars: {:?}, media: {:?}, msix: {:?}, if_flags: {:?}, em_insert_vlan_header: {:?}, ims: {:?}, in_detach: {:?}, flags: {:?}, link_task: {:?}, num_vlans: {:?}, txd_cmd: {:?}, tx_process_limit: {:?}, rx_process_limit: {:?}, rx_mbuf_sz: {:?}, wol: {:?}, has_manage: {:?}, has_amt: {:?}, mta: {:?}, shadow_vfta: [{}], link_active: {:?}, fc: {:?}, link_speed: {:?}, link_duplex: {:?}, smartspeed: {:?}, dmac: {:?}, link_mask: {:?}, que_mask: {:?}, tx_int_delay: {:?}, tx_abs_int_delay: {:?}, rx_int_delay: {:?}, rx_abs_int_delay: {:?}, tx_itr: {:?}, dropped_pkts: {:?}, link_irq: {:?}, mbuf_defrag_failed: {:?}, no_tx_dma_setup: {:?}, no_tx_map_avail: {:?}, rx_overruns: {:?}, watchdog_events: {:?}, stats: {:?}, vf_ifp: {:?} }}"
               , self . ifp , self . hw , self . shared , self . ctx , self .
               osdep , self . dev , self . led_dev , self . tx_queues , self .
               rx_queues , self . irq , self . memory , self . flash , self .
               ioport , self . io_rid , self . res , self . tag , self .
               linkvec , self . ivars , self . media , self . msix , self .
               if_flags , self . em_insert_vlan_header , self . ims , self .
               in_detach , self . flags , self . link_task , self . num_vlans
               , self . txd_cmd , self . tx_process_limit , self .
               rx_process_limit , self . rx_mbuf_sz , self . wol , self .
               has_manage , self . has_amt , self . mta , self . shadow_vfta .
               iter (  ) . enumerate (  ) . map (
               | ( i , v ) | format ! (
               "{}{:?}" , if i > 0 { ", " } else { "" } , v ) ) . collect :: <
               String > (  ) , self . link_active , self . fc , self .
               link_speed , self . link_duplex , self . smartspeed , self .
               dmac , self . link_mask , self . que_mask , self . tx_int_delay
               , self . tx_abs_int_delay , self . rx_int_delay , self .
               rx_abs_int_delay , self . tx_itr , self . dropped_pkts , self .
               link_irq , self . mbuf_defrag_failed , self . no_tx_dma_setup ,
               self . no_tx_map_avail , self . rx_overruns , self .
               watchdog_events , self . stats , self . vf_ifp)
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct em_int_delay_info {
    pub adapter: *mut adapter,
    pub offset: ::kernel::sys::raw::c_int,
    pub value: ::kernel::sys::raw::c_int,
}
#[test]
fn bindgen_test_layout_em_int_delay_info() {
    assert_eq!(::core::mem::size_of::<em_int_delay_info>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( em_int_delay_info ) ));
    assert_eq! (::core::mem::align_of::<em_int_delay_info>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( em_int_delay_info ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const em_int_delay_info ) ) . adapter as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( em_int_delay_info ) ,
                "::" , stringify ! ( adapter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const em_int_delay_info ) ) . offset as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( em_int_delay_info ) ,
                "::" , stringify ! ( offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const em_int_delay_info ) ) . value as * const
                _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( em_int_delay_info ) ,
                "::" , stringify ! ( value ) ));
}
impl Clone for em_int_delay_info {
    fn clone(&self) -> Self { *self }
}
impl Default for em_int_delay_info {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tx_ring {
    pub adapter: *mut adapter,
    pub tx_base: *mut e1000_tx_desc,
    pub tx_paddr: u64,
    pub tx_rsq: *mut qidx_t,
    pub tx_tso: bool_,
    pub me: u8,
    pub tx_rs_cidx: qidx_t,
    pub tx_rs_pidx: qidx_t,
    pub tx_cidx_processed: qidx_t,
    pub tag: *mut ::kernel::sys::raw::c_void,
    pub res: *mut resource,
    pub tx_irq: ::kernel::sys::raw::c_ulong,
    pub csum_flags: ::kernel::sys::raw::c_int,
    pub csum_lhlen: ::kernel::sys::raw::c_int,
    pub csum_iphlen: ::kernel::sys::raw::c_int,
    pub csum_thlen: ::kernel::sys::raw::c_int,
    pub csum_mss: ::kernel::sys::raw::c_int,
    pub csum_pktlen: ::kernel::sys::raw::c_int,
    pub csum_txd_upper: u32,
    pub csum_txd_lower: u32,
}
#[test]
fn bindgen_test_layout_tx_ring() {
    assert_eq!(::core::mem::size_of::<tx_ring>() , 96usize , concat ! (
               "Size of: " , stringify ! ( tx_ring ) ));
    assert_eq! (::core::mem::align_of::<tx_ring>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( tx_ring ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tx_ring ) ) . adapter as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( tx_ring ) , "::" ,
                stringify ! ( adapter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tx_ring ) ) . tx_base as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( tx_ring ) , "::" ,
                stringify ! ( tx_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tx_ring ) ) . tx_paddr as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( tx_ring ) , "::" ,
                stringify ! ( tx_paddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tx_ring ) ) . tx_rsq as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( tx_ring ) , "::" ,
                stringify ! ( tx_rsq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tx_ring ) ) . tx_tso as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( tx_ring ) , "::" ,
                stringify ! ( tx_tso ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tx_ring ) ) . me as * const _ as usize }
                , 33usize , concat ! (
                "Alignment of field: " , stringify ! ( tx_ring ) , "::" ,
                stringify ! ( me ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tx_ring ) ) . tx_rs_cidx as * const _ as
                usize } , 34usize , concat ! (
                "Alignment of field: " , stringify ! ( tx_ring ) , "::" ,
                stringify ! ( tx_rs_cidx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tx_ring ) ) . tx_rs_pidx as * const _ as
                usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( tx_ring ) , "::" ,
                stringify ! ( tx_rs_pidx ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tx_ring ) ) . tx_cidx_processed as *
                const _ as usize } , 38usize , concat ! (
                "Alignment of field: " , stringify ! ( tx_ring ) , "::" ,
                stringify ! ( tx_cidx_processed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tx_ring ) ) . tag as * const _ as usize }
                , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( tx_ring ) , "::" ,
                stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tx_ring ) ) . res as * const _ as usize }
                , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( tx_ring ) , "::" ,
                stringify ! ( res ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tx_ring ) ) . tx_irq as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( tx_ring ) , "::" ,
                stringify ! ( tx_irq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tx_ring ) ) . csum_flags as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( tx_ring ) , "::" ,
                stringify ! ( csum_flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tx_ring ) ) . csum_lhlen as * const _ as
                usize } , 68usize , concat ! (
                "Alignment of field: " , stringify ! ( tx_ring ) , "::" ,
                stringify ! ( csum_lhlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tx_ring ) ) . csum_iphlen as * const _ as
                usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( tx_ring ) , "::" ,
                stringify ! ( csum_iphlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tx_ring ) ) . csum_thlen as * const _ as
                usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! ( tx_ring ) , "::" ,
                stringify ! ( csum_thlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tx_ring ) ) . csum_mss as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( tx_ring ) , "::" ,
                stringify ! ( csum_mss ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tx_ring ) ) . csum_pktlen as * const _ as
                usize } , 84usize , concat ! (
                "Alignment of field: " , stringify ! ( tx_ring ) , "::" ,
                stringify ! ( csum_pktlen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tx_ring ) ) . csum_txd_upper as * const _
                as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( tx_ring ) , "::" ,
                stringify ! ( csum_txd_upper ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const tx_ring ) ) . csum_txd_lower as * const _
                as usize } , 92usize , concat ! (
                "Alignment of field: " , stringify ! ( tx_ring ) , "::" ,
                stringify ! ( csum_txd_lower ) ));
}
impl Clone for tx_ring {
    fn clone(&self) -> Self { *self }
}
impl Default for tx_ring {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct rx_ring {
    pub adapter: *mut adapter,
    pub que: *mut em_rx_queue,
    pub me: u32,
    pub payload: u32,
    pub rx_base: *mut e1000_rx_desc_extended,
    pub rx_paddr: u64,
    pub tag: *mut ::kernel::sys::raw::c_void,
    pub res: *mut resource,
    pub discard: bool_,
    pub rx_irq: ::kernel::sys::raw::c_ulong,
    pub rx_discarded: ::kernel::sys::raw::c_ulong,
    pub rx_packets: ::kernel::sys::raw::c_ulong,
    pub rx_bytes: ::kernel::sys::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_rx_ring() {
    assert_eq!(::core::mem::size_of::<rx_ring>() , 96usize , concat ! (
               "Size of: " , stringify ! ( rx_ring ) ));
    assert_eq! (::core::mem::align_of::<rx_ring>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( rx_ring ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rx_ring ) ) . adapter as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( rx_ring ) , "::" ,
                stringify ! ( adapter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rx_ring ) ) . que as * const _ as usize }
                , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( rx_ring ) , "::" ,
                stringify ! ( que ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rx_ring ) ) . me as * const _ as usize }
                , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( rx_ring ) , "::" ,
                stringify ! ( me ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rx_ring ) ) . payload as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( rx_ring ) , "::" ,
                stringify ! ( payload ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rx_ring ) ) . rx_base as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( rx_ring ) , "::" ,
                stringify ! ( rx_base ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rx_ring ) ) . rx_paddr as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( rx_ring ) , "::" ,
                stringify ! ( rx_paddr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rx_ring ) ) . tag as * const _ as usize }
                , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( rx_ring ) , "::" ,
                stringify ! ( tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rx_ring ) ) . res as * const _ as usize }
                , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( rx_ring ) , "::" ,
                stringify ! ( res ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rx_ring ) ) . discard as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( rx_ring ) , "::" ,
                stringify ! ( discard ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rx_ring ) ) . rx_irq as * const _ as
                usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( rx_ring ) , "::" ,
                stringify ! ( rx_irq ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rx_ring ) ) . rx_discarded as * const _
                as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( rx_ring ) , "::" ,
                stringify ! ( rx_discarded ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rx_ring ) ) . rx_packets as * const _ as
                usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( rx_ring ) , "::" ,
                stringify ! ( rx_packets ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const rx_ring ) ) . rx_bytes as * const _ as
                usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( rx_ring ) , "::" ,
                stringify ! ( rx_bytes ) ));
}
impl Clone for rx_ring {
    fn clone(&self) -> Self { *self }
}
impl Default for rx_ring {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct em_tx_queue {
    pub adapter: *mut adapter,
    pub msix: u32,
    pub eims: u32,
    pub me: u32,
    pub txr: tx_ring,
}
#[test]
fn bindgen_test_layout_em_tx_queue() {
    assert_eq!(::core::mem::size_of::<em_tx_queue>() , 120usize , concat ! (
               "Size of: " , stringify ! ( em_tx_queue ) ));
    assert_eq! (::core::mem::align_of::<em_tx_queue>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( em_tx_queue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const em_tx_queue ) ) . adapter as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( em_tx_queue ) , "::" ,
                stringify ! ( adapter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const em_tx_queue ) ) . msix as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( em_tx_queue ) , "::" ,
                stringify ! ( msix ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const em_tx_queue ) ) . eims as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( em_tx_queue ) , "::" ,
                stringify ! ( eims ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const em_tx_queue ) ) . me as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( em_tx_queue ) , "::" ,
                stringify ! ( me ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const em_tx_queue ) ) . txr as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( em_tx_queue ) , "::" ,
                stringify ! ( txr ) ));
}
impl Clone for em_tx_queue {
    fn clone(&self) -> Self { *self }
}
impl Default for em_tx_queue {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct em_rx_queue {
    pub adapter: *mut adapter,
    pub me: u32,
    pub msix: u32,
    pub eims: u32,
    pub rxr: rx_ring,
    pub irqs: u64,
    pub que_irq: if_irq,
}
#[test]
fn bindgen_test_layout_em_rx_queue() {
    assert_eq!(::core::mem::size_of::<em_rx_queue>() , 152usize , concat ! (
               "Size of: " , stringify ! ( em_rx_queue ) ));
    assert_eq! (::core::mem::align_of::<em_rx_queue>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( em_rx_queue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const em_rx_queue ) ) . adapter as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( em_rx_queue ) , "::" ,
                stringify ! ( adapter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const em_rx_queue ) ) . me as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( em_rx_queue ) , "::" ,
                stringify ! ( me ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const em_rx_queue ) ) . msix as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( em_rx_queue ) , "::" ,
                stringify ! ( msix ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const em_rx_queue ) ) . eims as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( em_rx_queue ) , "::" ,
                stringify ! ( eims ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const em_rx_queue ) ) . rxr as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( em_rx_queue ) , "::" ,
                stringify ! ( rxr ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const em_rx_queue ) ) . irqs as * const _ as
                usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! ( em_rx_queue ) , "::" ,
                stringify ! ( irqs ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const em_rx_queue ) ) . que_irq as * const _ as
                usize } , 128usize , concat ! (
                "Alignment of field: " , stringify ! ( em_rx_queue ) , "::" ,
                stringify ! ( que_irq ) ));
}
impl Clone for em_rx_queue {
    fn clone(&self) -> Self { *self }
}
impl Default for em_rx_queue {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
/// vendor_info_array
///
/// This array contains the list of Subvendor/Subdevice IDs on which the driver
/// should load.
///
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct _em_vendor_info_t {
    pub vendor_id: ::kernel::sys::raw::c_uint,
    pub device_id: ::kernel::sys::raw::c_uint,
    pub subvendor_id: ::kernel::sys::raw::c_uint,
    pub subdevice_id: ::kernel::sys::raw::c_uint,
    pub index: ::kernel::sys::raw::c_uint,
}
#[test]
fn bindgen_test_layout__em_vendor_info_t() {
    assert_eq!(::core::mem::size_of::<_em_vendor_info_t>() , 20usize , concat
               ! ( "Size of: " , stringify ! ( _em_vendor_info_t ) ));
    assert_eq! (::core::mem::align_of::<_em_vendor_info_t>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( _em_vendor_info_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _em_vendor_info_t ) ) . vendor_id as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _em_vendor_info_t ) ,
                "::" , stringify ! ( vendor_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _em_vendor_info_t ) ) . device_id as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( _em_vendor_info_t ) ,
                "::" , stringify ! ( device_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _em_vendor_info_t ) ) . subvendor_id as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _em_vendor_info_t ) ,
                "::" , stringify ! ( subvendor_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _em_vendor_info_t ) ) . subdevice_id as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( _em_vendor_info_t ) ,
                "::" , stringify ! ( subdevice_id ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _em_vendor_info_t ) ) . index as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _em_vendor_info_t ) ,
                "::" , stringify ! ( index ) ));
}
impl Clone for _em_vendor_info_t {
    fn clone(&self) -> Self { *self }
}
pub type em_vendor_info_t = _em_vendor_info_t;
extern "C" {
    pub fn em_dump_rs(arg1: *mut adapter);
}
#[repr(C)]
#[derive(Copy)]
pub union ich8_hws_flash_status {
    pub hsf_status: ich8_hws_flash_status_ich8_hsfsts,
    pub regval: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct ich8_hws_flash_status_ich8_hsfsts {
    pub _bitfield_1: [u8; 2usize],
    pub __bindgen_align: [u16; 0usize],
}
#[test]
fn bindgen_test_layout_ich8_hws_flash_status_ich8_hsfsts() {
    assert_eq!(::core::mem::size_of::<ich8_hws_flash_status_ich8_hsfsts>() ,
               2usize , concat ! (
               "Size of: " , stringify ! ( ich8_hws_flash_status_ich8_hsfsts )
               ));
    assert_eq! (::core::mem::align_of::<ich8_hws_flash_status_ich8_hsfsts>() ,
                2usize , concat ! (
                "Alignment of " , stringify ! (
                ich8_hws_flash_status_ich8_hsfsts ) ));
}
impl Clone for ich8_hws_flash_status_ich8_hsfsts {
    fn clone(&self) -> Self { *self }
}
impl ich8_hws_flash_status_ich8_hsfsts {
    #[inline]
    pub fn flcdone(&self) -> u16 {
        let mut unit_field_val: u16 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u16
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>())
        };
        let mask = 1u64 as u16;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::core::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_flcdone(&mut self, val: u16) {
        let mask = 1u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u16
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn flcerr(&self) -> u16 {
        let mut unit_field_val: u16 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u16
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>())
        };
        let mask = 2u64 as u16;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::core::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_flcerr(&mut self, val: u16) {
        let mask = 2u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u16
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn dael(&self) -> u16 {
        let mut unit_field_val: u16 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u16
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>())
        };
        let mask = 4u64 as u16;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::core::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_dael(&mut self, val: u16) {
        let mask = 4u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u16
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn berasesz(&self) -> u16 {
        let mut unit_field_val: u16 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u16
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>())
        };
        let mask = 24u64 as u16;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::core::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_berasesz(&mut self, val: u16) {
        let mask = 24u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u16
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn flcinprog(&self) -> u16 {
        let mut unit_field_val: u16 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u16
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>())
        };
        let mask = 32u64 as u16;
        let val = (unit_field_val & mask) >> 5usize;
        unsafe { ::core::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_flcinprog(&mut self, val: u16) {
        let mask = 32u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u16
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 5usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn reserved1(&self) -> u16 {
        let mut unit_field_val: u16 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u16
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>())
        };
        let mask = 192u64 as u16;
        let val = (unit_field_val & mask) >> 6usize;
        unsafe { ::core::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_reserved1(&mut self, val: u16) {
        let mask = 192u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u16
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 6usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn reserved2(&self) -> u16 {
        let mut unit_field_val: u16 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u16
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>())
        };
        let mask = 16128u64 as u16;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::core::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_reserved2(&mut self, val: u16) {
        let mask = 16128u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u16
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn fldesvalid(&self) -> u16 {
        let mut unit_field_val: u16 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u16
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>())
        };
        let mask = 16384u64 as u16;
        let val = (unit_field_val & mask) >> 14usize;
        unsafe { ::core::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_fldesvalid(&mut self, val: u16) {
        let mask = 16384u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u16
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 14usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn flockdn(&self) -> u16 {
        let mut unit_field_val: u16 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u16
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>())
        };
        let mask = 32768u64 as u16;
        let val = (unit_field_val & mask) >> 15usize;
        unsafe { ::core::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_flockdn(&mut self, val: u16) {
        let mask = 32768u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u16
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 15usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(flcdone: u16, flcerr: u16, dael: u16, berasesz: u16,
                          flcinprog: u16, reserved1: u16, reserved2: u16,
                          fldesvalid: u16, flockdn: u16) -> u16 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({
                                      ({
                                           ({
                                                ({ 0 } |
                                                     ((flcdone as u16 as u16)
                                                          << 0usize) &
                                                         (1u64 as u16))
                                            } |
                                                ((flcerr as u16 as u16) <<
                                                     1usize) & (2u64 as u16))
                                       } |
                                           ((dael as u16 as u16) << 2usize) &
                                               (4u64 as u16))
                                  } |
                                      ((berasesz as u16 as u16) << 3usize) &
                                          (24u64 as u16))
                             } |
                                 ((flcinprog as u16 as u16) << 5usize) &
                                     (32u64 as u16))
                        } |
                            ((reserved1 as u16 as u16) << 6usize) &
                                (192u64 as u16))
                   } |
                       ((reserved2 as u16 as u16) << 8usize) &
                           (16128u64 as u16))
              } | ((fldesvalid as u16 as u16) << 14usize) & (16384u64 as u16))
         } | ((flockdn as u16 as u16) << 15usize) & (32768u64 as u16))
    }
}
#[test]
fn bindgen_test_layout_ich8_hws_flash_status() {
    assert_eq!(::core::mem::size_of::<ich8_hws_flash_status>() , 2usize ,
               concat ! ( "Size of: " , stringify ! ( ich8_hws_flash_status )
               ));
    assert_eq! (::core::mem::align_of::<ich8_hws_flash_status>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( ich8_hws_flash_status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ich8_hws_flash_status ) ) . hsf_status as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ich8_hws_flash_status )
                , "::" , stringify ! ( hsf_status ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ich8_hws_flash_status ) ) . regval as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ich8_hws_flash_status )
                , "::" , stringify ! ( regval ) ));
}
impl Clone for ich8_hws_flash_status {
    fn clone(&self) -> Self { *self }
}
impl Default for ich8_hws_flash_status {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for ich8_hws_flash_status {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "ich8_hws_flash_status {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy)]
pub union ich8_hws_flash_ctrl {
    pub hsf_ctrl: ich8_hws_flash_ctrl_ich8_hsflctl,
    pub regval: u16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct ich8_hws_flash_ctrl_ich8_hsflctl {
    pub _bitfield_1: [u8; 2usize],
    pub __bindgen_align: [u16; 0usize],
}
#[test]
fn bindgen_test_layout_ich8_hws_flash_ctrl_ich8_hsflctl() {
    assert_eq!(::core::mem::size_of::<ich8_hws_flash_ctrl_ich8_hsflctl>() ,
               2usize , concat ! (
               "Size of: " , stringify ! ( ich8_hws_flash_ctrl_ich8_hsflctl )
               ));
    assert_eq! (::core::mem::align_of::<ich8_hws_flash_ctrl_ich8_hsflctl>() ,
                2usize , concat ! (
                "Alignment of " , stringify ! (
                ich8_hws_flash_ctrl_ich8_hsflctl ) ));
}
impl Clone for ich8_hws_flash_ctrl_ich8_hsflctl {
    fn clone(&self) -> Self { *self }
}
impl ich8_hws_flash_ctrl_ich8_hsflctl {
    #[inline]
    pub fn flcgo(&self) -> u16 {
        let mut unit_field_val: u16 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u16
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>())
        };
        let mask = 1u64 as u16;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::core::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_flcgo(&mut self, val: u16) {
        let mask = 1u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u16
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn flcycle(&self) -> u16 {
        let mut unit_field_val: u16 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u16
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>())
        };
        let mask = 6u64 as u16;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::core::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_flcycle(&mut self, val: u16) {
        let mask = 6u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u16
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn reserved(&self) -> u16 {
        let mut unit_field_val: u16 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u16
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>())
        };
        let mask = 248u64 as u16;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::core::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u16) {
        let mask = 248u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u16
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn fldbcount(&self) -> u16 {
        let mut unit_field_val: u16 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u16
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>())
        };
        let mask = 768u64 as u16;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::core::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_fldbcount(&mut self, val: u16) {
        let mask = 768u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u16
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn flockdn(&self) -> u16 {
        let mut unit_field_val: u16 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u16
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>())
        };
        let mask = 64512u64 as u16;
        let val = (unit_field_val & mask) >> 10usize;
        unsafe { ::core::mem::transmute(val as u16) }
    }
    #[inline]
    pub fn set_flockdn(&mut self, val: u16) {
        let mask = 64512u64 as u16;
        let val = val as u16 as u16;
        let mut unit_field_val: u16 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u16
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 10usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u16>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(flcgo: u16, flcycle: u16, reserved: u16,
                          fldbcount: u16, flockdn: u16) -> u16 {
        ({
             ({
                  ({
                       ({
                            ({ 0 } |
                                 ((flcgo as u16 as u16) << 0usize) &
                                     (1u64 as u16))
                        } |
                            ((flcycle as u16 as u16) << 1usize) &
                                (6u64 as u16))
                   } | ((reserved as u16 as u16) << 3usize) & (248u64 as u16))
              } | ((fldbcount as u16 as u16) << 8usize) & (768u64 as u16))
         } | ((flockdn as u16 as u16) << 10usize) & (64512u64 as u16))
    }
}
#[test]
fn bindgen_test_layout_ich8_hws_flash_ctrl() {
    assert_eq!(::core::mem::size_of::<ich8_hws_flash_ctrl>() , 2usize , concat
               ! ( "Size of: " , stringify ! ( ich8_hws_flash_ctrl ) ));
    assert_eq! (::core::mem::align_of::<ich8_hws_flash_ctrl>() , 2usize ,
                concat ! (
                "Alignment of " , stringify ! ( ich8_hws_flash_ctrl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ich8_hws_flash_ctrl ) ) . hsf_ctrl as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ich8_hws_flash_ctrl ) ,
                "::" , stringify ! ( hsf_ctrl ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ich8_hws_flash_ctrl ) ) . regval as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ich8_hws_flash_ctrl ) ,
                "::" , stringify ! ( regval ) ));
}
impl Clone for ich8_hws_flash_ctrl {
    fn clone(&self) -> Self { *self }
}
impl Default for ich8_hws_flash_ctrl {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for ich8_hws_flash_ctrl {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "ich8_hws_flash_ctrl {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy)]
pub union ich8_hws_flash_regacc {
    pub hsf_flregacc: ich8_hws_flash_regacc_ich8_flracc,
    pub regval: u16,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct ich8_hws_flash_regacc_ich8_flracc {
    pub _bitfield_1: [u8; 4usize],
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_ich8_hws_flash_regacc_ich8_flracc() {
    assert_eq!(::core::mem::size_of::<ich8_hws_flash_regacc_ich8_flracc>() ,
               4usize , concat ! (
               "Size of: " , stringify ! ( ich8_hws_flash_regacc_ich8_flracc )
               ));
    assert_eq! (::core::mem::align_of::<ich8_hws_flash_regacc_ich8_flracc>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                ich8_hws_flash_regacc_ich8_flracc ) ));
}
impl Clone for ich8_hws_flash_regacc_ich8_flracc {
    fn clone(&self) -> Self { *self }
}
impl ich8_hws_flash_regacc_ich8_flracc {
    #[inline]
    pub fn grra(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u32
                                                 as *mut u8,
                                             ::core::mem::size_of::<u32>())
        };
        let mask = 255u64 as u32;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::core::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_grra(&mut self, val: u32) {
        let mask = 255u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u32
                                                 as *mut u8,
                                             ::core::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn grwa(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u32
                                                 as *mut u8,
                                             ::core::mem::size_of::<u32>())
        };
        let mask = 65280u64 as u32;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::core::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_grwa(&mut self, val: u32) {
        let mask = 65280u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u32
                                                 as *mut u8,
                                             ::core::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn gmrag(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u32
                                                 as *mut u8,
                                             ::core::mem::size_of::<u32>())
        };
        let mask = 16711680u64 as u32;
        let val = (unit_field_val & mask) >> 16usize;
        unsafe { ::core::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_gmrag(&mut self, val: u32) {
        let mask = 16711680u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u32
                                                 as *mut u8,
                                             ::core::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 16usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn gmwag(&self) -> u32 {
        let mut unit_field_val: u32 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u32
                                                 as *mut u8,
                                             ::core::mem::size_of::<u32>())
        };
        let mask = 4278190080u64 as u32;
        let val = (unit_field_val & mask) >> 24usize;
        unsafe { ::core::mem::transmute(val as u32) }
    }
    #[inline]
    pub fn set_gmwag(&mut self, val: u32) {
        let mask = 4278190080u64 as u32;
        let val = val as u32 as u32;
        let mut unit_field_val: u32 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u32
                                                 as *mut u8,
                                             ::core::mem::size_of::<u32>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 24usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u32>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(grra: u32, grwa: u32, gmrag: u32, gmwag: u32)
     -> u32 {
        ({
             ({
                  ({
                       ({ 0 } |
                            ((grra as u32 as u32) << 0usize) &
                                (255u64 as u32))
                   } | ((grwa as u32 as u32) << 8usize) & (65280u64 as u32))
              } | ((gmrag as u32 as u32) << 16usize) & (16711680u64 as u32))
         } | ((gmwag as u32 as u32) << 24usize) & (4278190080u64 as u32))
    }
}
#[test]
fn bindgen_test_layout_ich8_hws_flash_regacc() {
    assert_eq!(::core::mem::size_of::<ich8_hws_flash_regacc>() , 4usize ,
               concat ! ( "Size of: " , stringify ! ( ich8_hws_flash_regacc )
               ));
    assert_eq! (::core::mem::align_of::<ich8_hws_flash_regacc>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( ich8_hws_flash_regacc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ich8_hws_flash_regacc ) ) . hsf_flregacc
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ich8_hws_flash_regacc )
                , "::" , stringify ! ( hsf_flregacc ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ich8_hws_flash_regacc ) ) . regval as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ich8_hws_flash_regacc )
                , "::" , stringify ! ( regval ) ));
}
impl Clone for ich8_hws_flash_regacc {
    fn clone(&self) -> Self { *self }
}
impl Default for ich8_hws_flash_regacc {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
impl ::kernel::fmt::Debug for ich8_hws_flash_regacc {
    fn fmt(&self, f: &mut ::kernel::fmt::Formatter) -> ::kernel::fmt::Result {
        write!(f , "ich8_hws_flash_regacc {{ union }}")
    }
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __va_list_tag {
    pub gp_offset: ::kernel::sys::raw::c_uint,
    pub fp_offset: ::kernel::sys::raw::c_uint,
    pub overflow_arg_area: *mut ::kernel::sys::raw::c_void,
    pub reg_save_area: *mut ::kernel::sys::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(::core::mem::size_of::<__va_list_tag>() , 24usize , concat ! (
               "Size of: " , stringify ! ( __va_list_tag ) ));
    assert_eq! (::core::mem::align_of::<__va_list_tag>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __va_list_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . gp_offset as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( gp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . fp_offset as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( fp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . overflow_arg_area as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( overflow_arg_area ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . reg_save_area as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( reg_save_area ) ));
}
impl Clone for __va_list_tag {
    fn clone(&self) -> Self { *self }
}
impl Default for __va_list_tag {
    fn default() -> Self { unsafe { ::core::mem::zeroed() } }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct witness {
    pub _address: u8,
}
impl Clone for witness {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct filedesc {
    pub _address: u8,
}
impl Clone for filedesc {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct filedesc_to_leader {
    pub _address: u8,
}
impl Clone for filedesc_to_leader {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct pstats {
    pub _address: u8,
}
impl Clone for pstats {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct plimit {
    pub _address: u8,
}
impl Clone for plimit {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct itimers {
    pub _address: u8,
}
impl Clone for itimers {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct sysentvec {
    pub _address: u8,
}
impl Clone for sysentvec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct label {
    pub _address: u8,
}
impl Clone for label {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct ktr_request {
    pub _address: u8,
}
impl Clone for ktr_request {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct seltd {
    pub _address: u8,
}
impl Clone for seltd {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct rl_q_entry {
    pub _address: u8,
}
impl Clone for rl_q_entry {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct umtx_q {
    pub _address: u8,
}
impl Clone for umtx_q {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct file {
    pub _address: u8,
}
impl Clone for file {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct uidinfo {
    pub _address: u8,
}
impl Clone for uidinfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct amd64tss {
    pub _address: u8,
}
impl Clone for amd64tss {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct domain {
    pub _address: u8,
}
impl Clone for domain {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct bpf_d {
    pub _address: u8,
}
impl Clone for bpf_d {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct aioliojob {
    pub _address: u8,
}
impl Clone for aioliojob {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct sysent {
    pub _address: u8,
}
impl Clone for sysent {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct cdev_priv {
    pub _address: u8,
}
impl Clone for cdev_priv {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Default, Copy)]
pub struct pcicfg_iov {
    pub _address: u8,
}
impl Clone for pcicfg_iov {
    fn clone(&self) -> Self { *self }
}
